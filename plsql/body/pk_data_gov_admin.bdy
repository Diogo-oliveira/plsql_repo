/*-- Last Change Revision: $Rev: 2047336 $*/
/*-- Last Change by: $Author: ana.matos $*/
/*-- Date of last change: $Date: 2022-10-13 11:29:50 +0100 (qui, 13 out 2022) $*/

CREATE OR REPLACE PACKAGE BODY pk_data_gov_admin IS

    e_bad_data    EXCEPTION;
    e_internal    EXCEPTION;
    e_external    EXCEPTION;
    e_unspecified EXCEPTION;

    g_inst institution.id_institution%TYPE;

    k_default_limit CONSTANT NUMBER(24) := 50000;

    g_commit_limit NUMBER(24) := k_default_limit;

    FUNCTION get_inst RETURN NUMBER IS
    BEGIN
        --1 is the value that was fixed before
        RETURN nvl(g_inst, 1);
    END get_inst;

    PROCEDURE set_inst(i_inst IN NUMBER) IS
    BEGIN
        g_inst := i_inst;
    END set_inst;

    FUNCTION get_prof(i_inst IN NUMBER DEFAULT NULL) RETURN profissional IS
        l_id_prof professional.id_professional%TYPE;
        l_prof    profissional;
    BEGIN
        IF i_inst IS NOT NULL
        THEN
            set_inst(i_inst => i_inst);
        END IF;
    
        --l_prof              profissional := profissional(142, 1, 1);
        l_id_prof := pk_sysconfig.get_config(i_code_cf   => 'ID_PROF_BACKGROUND',
                                             i_prof_inst => get_inst,
                                             i_prof_soft => 0);
        l_prof    := profissional(l_id_prof, get_inst, 0);
    
        RETURN l_prof;
    
    END get_prof;

    FUNCTION get_commit_limit RETURN NUMBER IS
    BEGIN
        RETURN g_commit_limit;
    END get_commit_limit;

    PROCEDURE set_commit_limit(i_commit_step IN NUMBER) IS
        l_ret NUMBER(24);
    BEGIN
        IF i_commit_step IS NULL
        THEN
            l_ret := k_default_limit;
        ELSE
            l_ret := i_commit_step;
        END IF;
    
        g_commit_limit := l_ret;
    END set_commit_limit;

    FUNCTION get_yes RETURN VARCHAR2 IS
    BEGIN
        RETURN 'Y';
    END get_yes;

    FUNCTION get_no RETURN VARCHAR2 IS
    BEGIN
        RETURN 'N';
    END get_no;

    PROCEDURE process_statistics IS
    BEGIN
        FOR rec IN (SELECT 'begin
dbms_stats.gather_table_stats(ownname => ''ALERT'', tabname => ''' || table_name || ''', estimate_percent=> 100, method_opt=> ''for all columns size 1 for all indexed columns size auto'', no_invalidate => false, degree => 4);
end;' run
                      FROM user_tables
                     WHERE table_name LIKE '%_EA' ESCAPE '\'
                       AND table_name NOT LIKE 'ERR%')
        LOOP
            EXECUTE IMMEDIATE rec.run;
        END LOOP;
    END process_statistics;

    PROCEDURE create_missing_epis_info IS
    BEGIN
    
        g_error := 'INSERT INTO EPIS_INFO';
        dbms_output.put_line(g_error);
        INSERT INTO epis_info
            (id_episode, id_schedule, id_room)
            SELECT id_episode,
                   -1,
                   (SELECT id_room
                      FROM room rom
                      JOIN department dpt
                        ON dpt.id_department = rom.id_department
                     WHERE dpt.id_institution = vis.id_institution
                       AND dpt.flg_available = 'Y'
                       AND rom.flg_available = 'Y'
                       AND rownum < 2 -- no way to guess the right room
                    ) id_room
              FROM episode epi
              JOIN visit vis
                ON vis.id_visit = epi.id_visit
             WHERE NOT EXISTS (SELECT id_episode
                      FROM epis_info nfo
                     WHERE nfo.id_episode = epi.id_episode) log errors INTO err$_epis_info(to_char(SYSDATE))
             reject LIMIT unlimited;
    
        g_error := 'INSERT INVALID RECORD EPIS_INFO';
    
    END create_missing_epis_info;

    PROCEDURE clean_err00_tables IS
        l_truncate CONSTANT VARCHAR2(0050 CHAR) := 'truncate table err$_';
        tbl table_varchar;
    BEGIN
    
        tbl := table_varchar('episode',
                             'epis_info',
                             'discharge_notes',
                             'epis_diagnosis',
                             'epis_diagram',
                             'epis_recomend',
                             'monitorization',
                             'interv_prescription',
                             'care_plan',
                             'care_plan_hist',
                             'clin_record',
                             'event_most_freq',
                             'p1_external_request',
                             'p1_match',
                             'pat_child_feed_dev',
                             'pat_cli_attributes',
                             'pat_dmgr_hist',
                             'pat_family_member',
                             'pat_family_prof',
                             'pat_graffar_crit',
                             'pat_health_plan',
                             'pat_history',
                             'pat_job',
                             'pat_medication_det',
                             'pat_necessity',
                             'pat_soc_attributes',
                             'pat_vacc',
                             'pat_vaccine',
                             'sr_surgery_record',
                             'unidose_car_patient',
                             'unidose_car_patient_hist',
                             'vaccine_det');
    
        <<loop_thru_tables>>
        FOR i IN 1 .. tbl.count
        LOOP
            BEGIN
                EXECUTE IMMEDIATE l_truncate || tbl(i);
                --  pk_utils.put_line( l_truncate || tbl(i) );
            EXCEPTION
                WHEN OTHERS THEN
                    dbms_output.put_line(SQLERRM || ' ' || tbl(i));
                    RAISE;
            END;
        
        END LOOP loop_thru_tables;
    
    END clean_err00_tables;

    FUNCTION ins_invalid_record
    (
        i_ea_table_name       VARCHAR2,
        i_id_pk_1_value       NUMBER,
        i_id_pk_1_col_name    VARCHAR2,
        i_id_pk_2_value       NUMBER,
        i_id_pk_2_col_name    VARCHAR2,
        i_id_pk_3_value       NUMBER,
        i_id_pk_3_col_name    VARCHAR2,
        i_id_pk_4_value       NUMBER,
        i_id_pk_4_col_name    VARCHAR2,
        i_dt_validation       TIMESTAMP WITH TIME ZONE,
        i_validation_type     INTEGER,
        i_in_patient          NUMBER,
        i_in_episode          NUMBER,
        i_in_schedule         NUMBER,
        i_in_external_request NUMBER,
        i_in_institution      NUMBER,
        i_in_start_dt         TIMESTAMP WITH TIME ZONE,
        i_in_end_dt           TIMESTAMP WITH TIME ZONE
    ) RETURN BOOLEAN IS
        l_error t_error_out;
    BEGIN
    
        g_error := 'INSERT';
        INSERT INTO data_gov_invalid_recs
            (ea_table_name,
             id_pk_1_value,
             id_pk_1_col_name,
             id_pk_2_value,
             id_pk_2_col_name,
             id_pk_3_value,
             id_pk_3_col_name,
             id_pk_4_value,
             id_pk_4_col_name,
             dt_validation,
             validation_type,
             i_patient,
             i_episode,
             i_schedule,
             i_external_request,
             i_institution,
             i_start_dt,
             i_end_dt)
        VALUES
            (i_ea_table_name,
             i_id_pk_1_value,
             i_id_pk_1_col_name,
             i_id_pk_2_value,
             i_id_pk_2_col_name,
             i_id_pk_3_value,
             i_id_pk_3_col_name,
             i_id_pk_4_value,
             i_id_pk_4_col_name,
             i_dt_validation,
             i_validation_type,
             i_in_patient,
             i_in_episode,
             i_in_schedule,
             i_in_external_request,
             i_in_institution,
             i_in_start_dt,
             i_in_end_dt);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'INS_INVALID_RECORD',
                                              l_error);
            RETURN FALSE;
    END ins_invalid_record;

    /**
    * Migração de dados para a tabela icnp_epis_diagnosis
    * id_visit, id_epis_type, flg_executions e id_patient
    *
    * @author  Joana Barroso
    * @version 2.4.3d
    * @since   14/10/2008
    */

    PROCEDURE admin_50_icnp_epis_diagnosis IS
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        CURSOR c_recreate IS
        -- flg_executions 'Y' tem registo em icnp_epis_diag_interv
            SELECT ed.id_icnp_epis_diag,
                   v.id_patient,
                   v.id_visit,
                   e.id_epis_type,
                   get_yes() flg_executions,
                   e.id_episode
              FROM icnp_epis_diagnosis ed
              JOIN episode e
                ON ed.id_episode = e.id_episode
              JOIN visit v
                ON e.id_visit = v.id_visit
             WHERE ed.id_icnp_epis_diag IN
                   (SELECT iedi.id_icnp_epis_diag
                      FROM icnp_epis_diag_interv iedi
                      JOIN icnp_epis_intervention iei
                        ON iei.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                      JOIN icnp_interv_plan ipp
                        ON ipp.id_icnp_epis_interv = iedi.id_icnp_epis_interv)
            UNION ALL
            -- flg_executions 'N' não tem registo em icnp_epis_diag_interv
            SELECT ed.id_icnp_epis_diag,
                   v.id_patient,
                   v.id_visit,
                   e.id_epis_type,
                   get_no() flg_executions,
                   e.id_episode
              FROM icnp_epis_diagnosis ed
              JOIN episode e
                ON ed.id_episode = e.id_episode
              JOIN visit v
                ON e.id_visit = v.id_visit
             WHERE ed.id_icnp_epis_diag NOT IN
                   (SELECT iedi.id_icnp_epis_diag
                      FROM icnp_epis_diag_interv iedi
                      JOIN icnp_epis_intervention iei
                        ON iei.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                      JOIN icnp_interv_plan ipp
                        ON ipp.id_icnp_epis_interv = iedi.id_icnp_epis_interv)
             ORDER BY id_icnp_epis_diag;
    
        CURSOR c_validate IS
            SELECT ed.id_icnp_epis_diag,
                   v.id_visit,
                   ed.id_visit ed_visit,
                   e.id_episode,
                   ed.id_episode ed_episode,
                   v.id_patient,
                   ed.id_patient ed_patient,
                   ed.flg_executions,
                   (SELECT DISTINCT iedi.id_icnp_epis_diag
                      FROM icnp_epis_diag_interv iedi
                      JOIN icnp_interv_plan ipp
                        ON ipp.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                      JOIN icnp_epis_intervention iei
                        ON iei.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                     WHERE iedi.id_icnp_epis_diag = ed.id_icnp_epis_diag) test
              FROM icnp_epis_diagnosis ed
              JOIN episode e
                ON ed.id_episode = e.id_episode
              JOIN visit v
                ON e.id_visit = v.id_visit
               AND ed.id_patient = v.id_patient
             ORDER BY ed.id_icnp_epis_diag;
    
        l_recreate c_recreate%ROWTYPE;
        l_validate c_validate%ROWTYPE;
    
        l_num_rows PLS_INTEGER := 0;
    
        l_no_errors_found BOOLEAN := TRUE;
    
        -- TYPE t_icnp_epis_diagnosis IS TABLE OF icnp_epis_diagnosis%ROWTYPE;
        -- l_data t_icnp_epis_diagnosis;
    BEGIN
    
        l_num_rows := 0;
    
        -- Se é para validar os dados
        IF i_validate_table
        THEN
        
            g_error := 'OPEN C_VALIDATE';
            OPEN c_validate;
            LOOP
            
                g_error := 'FETCH C_VALIDATE';
                FETCH c_validate
                    INTO l_validate;
            
                IF (l_validate.id_visit != l_validate.ed_visit)
                   OR (l_validate.id_episode != l_validate.ed_episode)
                   OR (l_validate.id_patient != l_validate.ed_patient)
                   OR (l_validate.flg_executions = get_no() AND l_validate.test IS NOT NULL)
                   OR (l_validate.flg_executions = get_yes() AND l_validate.test != l_validate.id_icnp_epis_diag)
                   OR (l_validate.flg_executions != get_yes() OR l_validate.flg_executions != get_no())
                THEN
                    l_no_errors_found := FALSE;
                
                    IF i_output_invalid_records
                    THEN
                        IF NOT ins_invalid_record(i_ea_table_name       => 'ICNP_EPIS_DIAGNOSIS',
                                                  i_id_pk_1_value       => l_validate.id_icnp_epis_diag,
                                                  i_id_pk_1_col_name    => 'ID_CNP_EPIS_DIAGNOSIS',
                                                  i_id_pk_2_value       => l_validate.id_visit,
                                                  i_id_pk_2_col_name    => 'ID_VISIT',
                                                  i_id_pk_3_value       => l_validate.id_episode,
                                                  i_id_pk_3_col_name    => 'ID_EPISODE',
                                                  i_id_pk_4_value       => l_validate.flg_executions,
                                                  i_id_pk_4_col_name    => 'FLG_EXECUTIONS',
                                                  i_dt_validation       => g_sysdate_tstz,
                                                  i_validation_type     => g_validation_type_2,
                                                  i_in_patient          => i_patient,
                                                  i_in_episode          => i_episode,
                                                  i_in_schedule         => i_schedule,
                                                  i_in_external_request => i_external_request,
                                                  i_in_institution      => i_institution,
                                                  i_in_start_dt         => i_start_dt,
                                                  i_in_end_dt           => i_end_dt)
                        
                        THEN
                            RAISE e_internal;
                        END IF;
                    END IF;
                END IF;
            
                EXIT WHEN c_validate%NOTFOUND;
            END LOOP;
        
            CLOSE c_validate;
        
        END IF;
    
        -- Se é para carregar os dados
        IF i_recreate_table
        THEN
            g_error := 'OPEN C_RECREATE';
            OPEN c_recreate;
        
            LOOP
                g_error := 'FETCH C_RECREATE';
                FETCH c_recreate --BULK COLLECT
                    INTO l_recreate; -- LIMIT i_commit_step;
            
                g_error := 'FORALL - UPDATE icnp_epis_diagnosis';
                --FORALL i IN 1 .. l_recreate.COUNT
                UPDATE icnp_epis_diagnosis
                   SET id_patient     = l_recreate.id_patient,
                       id_visit       = l_recreate.id_visit,
                       id_epis_type   = l_recreate.id_epis_type,
                       flg_executions = l_recreate.flg_executions
                 WHERE id_icnp_epis_diag = l_recreate.id_icnp_epis_diag
                   AND id_episode = l_recreate.id_episode;
            
                EXIT WHEN c_recreate%NOTFOUND;
            
                l_num_rows := l_num_rows + 1;
                IF l_num_rows >= i_commit_step
                THEN
                    COMMIT;
                    l_num_rows := 0;
                END IF;
            END LOOP;
        
            CLOSE c_recreate;
            COMMIT;
        
        END IF;
    
        IF NOT l_no_errors_found
        THEN
            -- inconsistent data
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        
    END admin_50_icnp_epis_diagnosis;

    /**
    * Migração de dados VISIT.ID_VISIT e PATIENT.ID_PATIENT para a tabela NURSE_TEA_REQ
    *
    * @author  Luís Maia
    * @version 2.4.3d
    * @since   15/10/2008
    */

    PROCEDURE admin_50_nurse_tea_req IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        CURSOR c_recreate IS
            SELECT ntr.id_nurse_tea_req, epi.id_episode, vis.id_visit, vis.id_patient
              FROM nurse_tea_req ntr
              JOIN episode epi
                ON ntr.id_episode = epi.id_episode
              JOIN visit vis
                ON epi.id_visit = vis.id_visit
             ORDER BY ntr.id_nurse_tea_req;
    
        CURSOR c_validate IS
            SELECT ntr.id_nurse_tea_req,
                   epi.id_episode,
                   vis.id_visit,
                   vis.id_patient,
                   ntr.id_patient       pat_ntr,
                   ntr.id_visit         vis_ntr
              FROM nurse_tea_req ntr
              JOIN episode epi
                ON ntr.id_episode = epi.id_episode
              JOIN visit vis
                ON epi.id_visit = vis.id_visit
             ORDER BY ntr.id_nurse_tea_req;
    
        l_recreate c_recreate%ROWTYPE;
        l_validate c_validate%ROWTYPE;
    
        l_num_rows        PLS_INTEGER := 0;
        l_no_errors_found BOOLEAN := TRUE;
    
    BEGIN
    
        l_num_rows := 0;
    
        -- Se é para validar os dados
        IF i_validate_table
        THEN
            g_error := 'OPEN C_VALIDATE';
            OPEN c_validate;
            LOOP
                g_error := 'FETCH C_VALIDATE';
                FETCH c_validate
                    INTO l_validate;
            
                IF (l_validate.id_visit != l_validate.vis_ntr)
                   OR (l_validate.id_patient != l_validate.pat_ntr)
                THEN
                    l_no_errors_found := FALSE;
                
                    IF i_output_invalid_records
                    THEN
                        IF NOT ins_invalid_record(i_ea_table_name       => 'NURSE_TEA_REQ',
                                                  i_id_pk_1_value       => l_validate.id_nurse_tea_req,
                                                  i_id_pk_1_col_name    => 'ID_NURSE_TEA_REQ',
                                                  i_id_pk_2_value       => l_validate.id_episode,
                                                  i_id_pk_2_col_name    => 'ID_EPISODE',
                                                  i_id_pk_3_value       => l_validate.id_visit,
                                                  i_id_pk_3_col_name    => 'ID_VISIT',
                                                  i_id_pk_4_value       => l_validate.id_patient,
                                                  i_id_pk_4_col_name    => 'ID_PATIENT',
                                                  i_dt_validation       => g_sysdate_tstz,
                                                  i_validation_type     => g_validation_type_2,
                                                  i_in_patient          => i_patient,
                                                  i_in_episode          => i_episode,
                                                  i_in_schedule         => i_schedule,
                                                  i_in_external_request => i_external_request,
                                                  i_in_institution      => i_institution,
                                                  i_in_start_dt         => i_start_dt,
                                                  i_in_end_dt           => i_end_dt)
                        
                        THEN
                            RAISE e_internal;
                        
                        END IF;
                    END IF;
                END IF;
            
                EXIT WHEN c_validate%NOTFOUND;
            END LOOP;
        
            CLOSE c_validate;
        END IF;
    
        -- Se é para carregar os dados
        IF i_recreate_table
        THEN
            g_error := 'OPEN C_RECREATE';
            OPEN c_recreate;
        
            LOOP
                g_error := 'FETCH C_RECREATE';
                FETCH c_recreate --BULK COLLECT
                    INTO l_recreate; -- LIMIT i_commit_step;
            
                g_error := 'FORALL - UPDATE nurse_tea_req';
                --FORALL i IN 1 .. l_recreate.COUNT
                UPDATE nurse_tea_req ntr
                   SET ntr.id_visit = l_recreate.id_visit, ntr.id_patient = l_recreate.id_patient
                 WHERE ntr.id_nurse_tea_req = l_recreate.id_nurse_tea_req
                   AND ntr.id_episode = l_recreate.id_episode;
            
                EXIT WHEN c_recreate%NOTFOUND;
            
                l_num_rows := l_num_rows + 1;
                IF l_num_rows >= i_commit_step
                THEN
                    COMMIT;
                    l_num_rows := 0;
                END IF;
            END LOOP;
            CLOSE c_recreate;
            COMMIT;
        END IF;
    
        IF NOT l_no_errors_found
        THEN
            -- inconsistent data
            g_error := 'Warning, inconsistent data';
            dbms_output.put_line(g_error);
            RAISE e_bad_data;
        
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        
    END admin_50_nurse_tea_req;

    /**
    * Migration script for EXAMS_EA
    *
    * @author  João Ribeiro
    * @version 2.4.3d
    * @since   16/10/2008
    */

    PROCEDURE admin_50_exams_ea IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        ins_invalid_record_error EXCEPTION;
    
    BEGIN
    
        pk_frmw.disable_index(i_table_name => 'EXAMS_EA', i_disable_fk => TRUE);
    
        EXECUTE IMMEDIATE 'truncate table exams_ea';
        EXECUTE IMMEDIATE 'truncate table err$_exams_ea';
    
        INSERT /*+append*/
        INTO exams_ea
            (id_exam_req,
             id_exam_req_det,
             id_exam_result,
             id_exam,
             id_exam_group,
             dt_req,
             dt_begin,
             dt_pend_req,
             priority,
             
             status_str_req,
             status_msg_req,
             status_icon_req,
             status_flg_req,
             
             status_str,
             status_msg,
             status_icon,
             status_flg,
             
             flg_type,
             id_exam_cat,
             flg_available,
             flg_notes,
             flg_doc,
             flg_time,
             flg_status_req,
             flg_status_det,
             flg_referral,
             id_prof_req,
             id_prof_performed,
             start_time,
             end_time,
             id_epis_doc_perform,
             desc_perform_notes,
             dt_result,
             id_epis_doc_result,
             desc_result,
             flg_status_result,
             flg_relevant,
             id_exam_codification,
             id_room,
             id_movement,
             id_task_dependency,
             flg_req_origin_module,
             notes,
             notes_patient,
             notes_technician,
             notes_cancel,
             id_patient,
             id_visit,
             id_episode,
             id_episode_origin,
             id_prev_episode,
             dt_dg_last_update)
            SELECT id_exam_req,
                   id_exam_req_det,
                   id_exam_result,
                   id_exam,
                   id_exam_group,
                   dt_req_tstz,
                   dt_begin_tstz,
                   dt_pend_req_tstz,
                   priority,
                   --req
                   t_req.status_str  status_str_req,
                   t_req.status_msg  status_msg_req,
                   t_req.status_icon status_icon_req,
                   t_req.status_flg  status_flg_req,
                   --det
                   t_det.status_str,
                   t_det.status_msg,
                   t_det.status_icon,
                   t_det.status_flg,
                   --
                   flg_type,
                   id_exam_cat,
                   flg_available,
                   flg_notes,
                   flg_doc,
                   flg_time,
                   flg_status_er,
                   flg_status_erd,
                   flg_referral,
                   id_prof_req,
                   id_prof_performed,
                   start_time,
                   end_time,
                   id_epis_doc_perform,
                   desc_perform_notes,
                   dt_exam_result_tstz,
                   id_epis_doc_result,
                   desc_result,
                   flg_status_result,
                   flg_relevant,
                   id_exam_codification,
                   id_room,
                   id_movement,
                   id_task_dependency,
                   flg_req_origin_module,
                   notes,
                   notes_patient,
                   notes_technician,
                   notes_cancel,
                   id_patient,
                   id_visit,
                   id_episode,
                   id_episode_origin,
                   id_prev_episode,
                   l_current_timestamp
              FROM (SELECT row_number() over(PARTITION BY erd.id_exam_req_det ORDER BY ed.dt_creation_tstz DESC, eres.dt_exam_result_tstz DESC) rn,
                           er.id_exam_req,
                           erd.id_exam_req_det,
                           eres.id_exam_result,
                           erd.id_exam,
                           er.id_exam_group,
                           er.dt_req_tstz,
                           er.dt_begin_tstz,
                           er.dt_pend_req_tstz,
                           er.priority,
                           ex.flg_type,
                           ex.id_exam_cat,
                           ex.flg_available,
                           decode(coalesce(erd.notes, erd.notes_cancel, er.notes_tech),
                                  NULL,
                                  pk_exam_constant.g_no,
                                  pk_exam_constant.g_yes) flg_notes,
                           decode((SELECT 1
                                    FROM exam_media_archive ema
                                   WHERE ema.id_exam_req_det = erd.id_exam_req_det
                                     AND ema.flg_type = pk_exam_constant.g_media_archive_exam_doc
                                     AND ema.flg_status = pk_exam_constant.g_active
                                     AND rownum = 1),
                                  1,
                                  pk_exam_constant.g_yes,
                                  pk_exam_constant.g_no) flg_doc,
                           er.flg_time,
                           er.flg_status flg_status_er,
                           erd.flg_status flg_status_erd,
                           erd.flg_referral,
                           er.id_prof_req,
                           erd.id_prof_performed,
                           erd.start_time,
                           erd.end_time,
                           ed.id_epis_documentation id_epis_doc_perform,
                           ed.notes desc_perform_notes,
                           eres.dt_exam_result_tstz,
                           eres.id_epis_documentation id_epis_doc_result,
                           eres.notes desc_result,
                           rs.value flg_status_result,
                           eres.id_abnormality,
                           eres.flg_relevant,
                           erd.id_exam_codification,
                           erd.id_room,
                           erd.id_movement,
                           erd.id_task_dependency,
                           erd.flg_req_origin_module,
                           erd.notes,
                           er.notes_patient,
                           erd.notes_tech notes_technician,
                           erd.notes_cancel,
                           er.id_patient,
                           v.id_visit,
                           er.id_episode,
                           er.id_episode_origin,
                           er.id_prev_episode
                      FROM exam_req er
                      JOIN (SELECT *
                             FROM exam_req_det erd
                            WHERE erd.flg_status NOT IN
                                  (pk_exam_constant.g_exam_predefined, pk_exam_constant.g_exam_draft)) erd
                        ON erd.id_exam_req = er.id_exam_req
                      LEFT JOIN episode ep
                        ON er.id_episode = ep.id_episode
                      LEFT JOIN episode ep_origin
                        ON er.id_episode_origin = ep_origin.id_episode
                      LEFT JOIN visit v
                        ON ep.id_visit = v.id_visit
                      JOIN exam ex
                        ON erd.id_exam = ex.id_exam
                      LEFT JOIN (SELECT *
                                  FROM epis_documentation ed
                                 WHERE ed.id_doc_area = pk_exam_constant.g_doc_area_exam
                                   AND ed.flg_status = pk_touch_option.g_epis_bartchart_act) ed
                        ON erd.id_exam_req_det = ed.id_epis_context
                      LEFT JOIN (SELECT *
                                  FROM exam_result er
                                 WHERE er.flg_status != pk_exam_constant.g_exam_cancel) eres
                        ON erd.id_exam_req_det = eres.id_exam_req_det
                      LEFT JOIN result_status rs
                        ON eres.id_result_status = rs.id_result_status) t
             CROSS JOIN TABLE(pk_ea_logic_exams.get_exam_status_req_all(l_lang, l_prof, t.id_episode, t.flg_time, CASE WHEN t.flg_status_er = pk_exam_constant.g_exam_result THEN CASE WHEN t.priority != pk_exam_constant.g_exam_normal THEN t.flg_status_er || pk_exam_constant.g_exam_urgent ELSE t.flg_status_er END ELSE t.flg_status_er END, t.dt_req_tstz, t.dt_begin_tstz)) t_req
             CROSS JOIN TABLE(pk_ea_logic_exams.get_exam_status_det_all(l_lang, l_prof, t.id_episode, t.flg_time, t.flg_status_erd, t.flg_referral, CASE WHEN t.flg_status_erd = pk_exam_constant.g_exam_result THEN CASE WHEN t.priority != pk_exam_constant.g_exam_normal OR (t.id_abnormality IS NOT NULL AND t.id_abnormality != 7) THEN t.flg_status_result || pk_exam_constant.g_exam_urgent ELSE t.flg_status_result END ELSE t.flg_status_result END, t.dt_req_tstz, t.dt_pend_req_tstz, t.dt_begin_tstz)) t_det
             WHERE t.rn = 1 log errors INTO err$_exams_ea(to_char(SYSDATE)) reject LIMIT unlimited;
    
        pk_frmw.enable_index(i_table_name => 'EXAMS_EA', i_enable_fk => TRUE);
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_exams_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
        COMMIT;
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_exams_ea.');
    END admin_50_exams_ea;

    /**
    * Migration script for LAB_TESTS_EA
    *
    * @author  João Ribeiro
    * @version 2.4.3d
    * @since   16/10/2008
    */

    PROCEDURE admin_50_lab_tests_ea IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        ins_invalid_record_error EXCEPTION;
    
    BEGIN
    
        pk_frmw.disable_index(i_table_name => 'LAB_TESTS_EA', i_disable_fk => TRUE);
    
        EXECUTE IMMEDIATE 'truncate table lab_tests_ea';
        EXECUTE IMMEDIATE 'truncate table err$_lab_tests_ea';
    
        INSERT /*+append*/
        INTO lab_tests_ea
            (id_analysis_req,
             id_analysis_req_det,
             id_ard_parent,
             id_analysis_result,
             id_analysis,
             dt_req,
             dt_target,
             dt_pend_req,
             dt_harvest,
             dt_analysis_result,
             status_str_req,
             status_msg_req,
             status_icon_req,
             status_flg_req,
             status_str,
             status_msg,
             status_icon,
             status_flg,
             id_sample_type,
             id_exam_cat,
             flg_notes,
             flg_doc,
             flg_time_harvest,
             flg_status_req,
             flg_status_det,
             flg_status_harvest,
             flg_status_result,
             flg_priority,
             flg_col_inst,
             flg_referral,
             id_prof_writes,
             id_prof_order,
             dt_order,
             id_order_type,
             flg_abnormality,
             flg_relevant,
             id_analysis_codification,
             id_room_req,
             id_institution,
             id_movement,
             id_task_dependency,
             id_exec_institution,
             flg_req_origin_module,
             flg_orig_analysis,
             notes,
             notes_technician,
             notes_patient,
             notes_cancel,
             id_patient,
             id_visit,
             id_episode,
             id_episode_origin,
             id_episode_destination,
             id_prev_episode,
             dt_dg_last_update)
            SELECT id_analysis_req,
                   id_analysis_req_det,
                   id_ard_parent,
                   id_analysis_result,
                   id_analysis,
                   dt_req_tstz,
                   dt_target_tstz,
                   dt_pend_req_tstz,
                   dt_harvest_tstz,
                   dt_analysis_result_tstz,
                   status_str_req,
                   status_msg_req,
                   status_icon_req,
                   status_flg_req,
                   status_str,
                   status_msg,
                   status_icon,
                   status_flg,
                   id_sample_type,
                   id_exam_cat,
                   flg_notes,
                   flg_doc,
                   flg_time_harvest,
                   flg_status_ar,
                   flg_status_ard,
                   flg_status_h,
                   flg_status_r,
                   flg_urgency,
                   flg_col_inst,
                   flg_referral,
                   id_prof_writes,
                   id_prof_order,
                   dt_order,
                   id_order_type,
                   flg_abnormality,
                   flg_relevant,
                   id_analysis_codification,
                   id_room_req,
                   id_institution,
                   id_movement,
                   id_task_dependency,
                   id_exec_institution,
                   flg_req_origin_module,
                   flg_orig_analysis,
                   notes,
                   notes_technician,
                   notes_patient,
                   notes_cancel,
                   id_patient,
                   id_visit,
                   id_episode,
                   id_episode_origin,
                   id_episode_destination,
                   id_prev_episode,
                   l_current_timestamp dt_dg_last_update
              FROM (SELECT row_number() over(PARTITION BY ard.id_analysis_req_det ORDER BY h.dt_harvest_tstz DESC, ares.dt_analysis_result_tstz DESC) rn,
                           ar.id_analysis_req,
                           ard.id_analysis_req_det,
                           ard.id_ard_parent,
                           ares.id_analysis_result,
                           ard.id_analysis,
                           ar.dt_req_tstz,
                           ard.dt_target_tstz,
                           ard.dt_pend_req_tstz,
                           h.dt_harvest_tstz,
                           ares.dt_analysis_result_tstz,
                           ard.id_sample_type,
                           ard.id_exam_cat,
                           decode(coalesce(ard.notes, ard.notes_cancel, ard.notes_tech, ard.notes_justify),
                                  NULL,
                                  pk_lab_tests_constant.g_no,
                                  pk_lab_tests_constant.g_yes) flg_notes,
                           decode((SELECT 1
                                    FROM analysis_media_archive ama
                                   WHERE ama.id_analysis_req_det = ard.id_analysis_req_det
                                     AND ama.flg_type = pk_lab_tests_constant.g_media_archive_analysis_doc
                                     AND ama.flg_status = pk_lab_tests_constant.g_active
                                     AND rownum = 1),
                                  1,
                                  pk_exam_constant.g_yes,
                                  pk_exam_constant.g_no) flg_doc,
                           ard.flg_time_harvest,
                           ar.flg_status flg_status_ar,
                           ard.flg_status flg_status_ard,
                           h.flg_status flg_status_h,
                           rs.value flg_status_r,
                           ard.flg_urgency,
                           ard.flg_col_inst,
                           ard.flg_referral,
                           ar.id_prof_writes,
                           csh.id_prof_ordered_by id_prof_order,
                           csh.dt_ordered_by dt_order,
                           csh.id_order_type,
                           arp.id_abnormality,
                           decode(arp.id_abnormality, NULL, pk_lab_tests_constant.g_no, pk_lab_tests_constant.g_yes) flg_abnormality,
                           arp.flg_relevant,
                           ard.id_analysis_codification,
                           ard.id_room_req,
                           ar.id_institution,
                           ard.id_movement,
                           ard.id_task_dependency,
                           ard.id_exec_institution,
                           ard.flg_req_origin_module,
                           ares.flg_orig_analysis,
                           ard.notes,
                           ard.notes_patient,
                           ard.notes_tech notes_technician,
                           ard.notes_cancel,
                           ar.id_patient,
                           ar.id_visit,
                           ar.id_episode,
                           ar.id_episode_origin,
                           ar.id_episode_destination,
                           ar.id_prev_episode,
                           t_req.status_str status_str_req,
                           t_req.status_msg status_msg_req,
                           t_req.status_icon status_icon_req,
                           t_req.status_flg status_flg_req,
                           --
                           t_det.status_str,
                           t_det.status_msg,
                           t_det.status_icon,
                           t_det.status_flg
                      FROM analysis_req_det ard
                      JOIN analysis_req ar
                        ON ard.id_analysis_req = ar.id_analysis_req
                      LEFT JOIN co_sign_hist csh
                        ON (ard.id_co_sign_order = csh.id_co_sign_hist)
                      JOIN analysis a
                        ON ard.id_analysis = a.id_analysis
                      LEFT JOIN (SELECT *
                                  FROM (SELECT ah.id_analysis_req_det,
                                               ah.id_harvest,
                                               row_number() over(PARTITION BY id_analysis_req_det ORDER BY id_harvest) rn
                                          FROM analysis_harvest ah
                                         WHERE ah.flg_status = pk_lab_tests_constant.g_active)
                                 WHERE rn = 1) ah
                        ON ard.id_analysis_req_det = ah.id_analysis_req_det
                      LEFT JOIN (SELECT *
                                  FROM (SELECT h.id_harvest,
                                               h.flg_status,
                                               h.dt_harvest_tstz,
                                               row_number() over(PARTITION BY id_harvest ORDER BY dt_harvest_tstz DESC) rn
                                          FROM harvest h)
                                 WHERE rn = 1) h
                        ON ah.id_harvest = h.id_harvest
                      LEFT JOIN analysis_result ares
                        ON ard.id_analysis_req_det = ares.id_analysis_req_det
                      LEFT JOIN (SELECT *
                                  FROM (SELECT /*+ index(arp ARLP_ABY_IDX) */
                                         arp.id_analysis_result,
                                         arp.id_abnormality,
                                         arp.flg_relevant,
                                         row_number() over(PARTITION BY arp.id_analysis_req_par ORDER BY arp.dt_ins_result_tstz DESC) rn
                                          FROM analysis_result_par arp
                                         WHERE arp.id_abnormality IS NOT NULL
                                            OR arp.flg_relevant = pk_lab_tests_constant.g_yes)
                                 WHERE rn = 1) arp
                        ON ares.id_analysis_result = arp.id_analysis_result
                      LEFT JOIN result_status rs
                        ON ares.id_result_status = rs.id_result_status
                     CROSS JOIN TABLE(pk_ea_logic_analysis.get_analysis_status_req_all(i_lang => l_lang, i_prof => l_prof, i_episode => ar.id_episode,
                    
                    i_flg_time => ard.flg_time_harvest, i_flg_status_req =>CASE
                        WHEN ar.flg_status =
                             pk_lab_tests_constant.g_analysis_result THEN
                         CASE
                             WHEN ard.flg_urgency !=
                                  pk_lab_tests_constant.g_analysis_normal THEN
                              ar.flg_status ||
                              pk_lab_tests_constant.g_analysis_urgent
                             ELSE
                              ar.flg_status
                         END
                        ELSE
                         ar.flg_status
                    END, i_dt_req => ar.dt_req_tstz, i_dt_begin => ard.dt_target_tstz)) t_req
                    
                     CROSS JOIN TABLE(pk_ea_logic_analysis.get_analysis_status_det_all(i_lang => l_lang, i_prof => l_prof, i_episode => ar.id_episode, i_flg_time => ard.flg_time_harvest, i_flg_status_det => ard.flg_status, i_flg_referral => ard.flg_referral, i_flg_status_harvest => h.flg_status, i_flg_status_result =>CASE
                        WHEN ard.flg_status =
                             pk_lab_tests_constant.g_analysis_result THEN
                         CASE
                             WHEN flg_urgency !=
                                  pk_lab_tests_constant.g_analysis_normal
                                  OR
                                  (id_abnormality IS NOT NULL AND
                                  id_abnormality != 7) THEN
                              rs.value ||
                              pk_lab_tests_constant.g_analysis_urgent
                             ELSE
                              rs.value
                         END
                        ELSE
                         rs.value
                    END, i_result => pk_lab_tests_api_db.get_lab_test_result_parameters(l_lang, l_prof, ard.id_analysis_req_det), i_dt_req => ar.dt_req_tstz, i_dt_pend_req => ard.dt_pend_req_tstz, i_dt_begin => ard.dt_target_tstz)) t_det
                     WHERE ard.flg_status NOT IN
                           (pk_lab_tests_constant.g_analysis_predefined, pk_lab_tests_constant.g_analysis_draft))
             WHERE rn = 1 log errors INTO err$_lab_tests_ea(to_char(SYSDATE)) reject LIMIT unlimited;
    
        pk_frmw.enable_index(i_table_name => 'LAB_TESTS_EA', i_enable_fk => TRUE);
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_lab_tests_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
        COMMIT;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_lab_tests_ea.');
    END admin_50_lab_tests_ea;

    /**
    * Migration script for BLOOD_PRODUCTS_EA
    *
    * @author  Ana Matos
    * @version 2.7.4.0
    * @since   10/09/2018
    */

    PROCEDURE admin_50_blood_products_ea IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        ins_invalid_record_error EXCEPTION;
    
    BEGIN
    
        pk_frmw.disable_index(i_table_name => 'BLOOD_PRODUCTS_EA', i_disable_fk => TRUE);
    
        EXECUTE IMMEDIATE 'truncate table blood_products_ea';
        EXECUTE IMMEDIATE 'truncate table err$_blood_products_ea';
    
        INSERT /*+append*/
        INTO blood_products_ea
            (id_blood_product_req,
             id_blood_product_det,
             id_hemo_type,
             flg_status_req,
             flg_status_det,
             flg_time,
             dt_begin_req,
             dt_begin_det,
             dt_blood_product,
             id_professional,
             flg_notes,
             status_str,
             status_msg,
             status_icon,
             status_flg,
             id_prof_order,
             flg_priority,
             id_episode_origin,
             id_visit,
             id_episode,
             id_patient,
             dt_blood_product_det,
             dt_dg_last_update,
             flg_doc,
             id_order_recurrence,
             id_task_dependency,
             flg_req_origin_module,
             notes,
             notes_tech,
             notes_cancel,
             id_clinical_purpose,
             clinical_purpose_notes,
             transfusion_type,
             qty_exec,
             id_unit_mea_qty_exec,
             special_instr,
             status_str_req,
             status_msg_req,
             status_icon_req,
             status_flg_req,
             barcode_lab,
             qty_received,
             id_unit_mea_qty_received,
             expiration_date,
             blood_group,
             adverse_reaction,
             blood_group_rh,
             adverse_reaction_req)
            SELECT id_blood_product_req,
                   id_blood_product_det,
                   id_hemo_type,
                   flg_status_req,
                   flg_status_det,
                   flg_time,
                   dt_req_tstz,
                   dt_begin_tstz,
                   dt_blood_product_det,
                   id_professional,
                   flg_notes,
                   t_det.status_str,
                   t_det.status_msg,
                   t_det.status_icon,
                   t_det.status_flg,
                   NULL                     id_prof_order,
                   flg_priority,
                   id_episode_origin,
                   id_visit,
                   id_episode,
                   id_patient,
                   dt_blood_product_det,
                   l_current_timestamp      dt_dg_last_update,
                   NULL                     flg_doc,
                   id_order_recurrence,
                   NULL                     id_task_dependency,
                   flg_req_origin_module,
                   notes,
                   notes_tech,
                   notes_cancel,
                   id_clinical_purpose,
                   clinical_purpose_notes,
                   transfusion_type,
                   qty_exec,
                   id_unit_mea_qty_exec,
                   special_instr,
                   t_req.status_str         status_str_req,
                   t_req.status_msg         status_msg_req,
                   t_req.status_icon        status_icon_req,
                   t_req.status_flg         status_flg_req,
                   barcode_lab,
                   qty_received,
                   id_unit_mea_qty_received,
                   expiration_date,
                   blood_group,
                   adverse_reaction,
                   blood_group_rh,
                   adverse_reaction_req
              FROM (SELECT row_number() over(PARTITION BY bpd.id_blood_product_det ORDER BY bpd.dt_begin_tstz DESC) rn,
                           bpr.id_blood_product_req,
                           bpd.id_blood_product_det,
                           bpd.id_hemo_type,
                           bpr.flg_status flg_status_req,
                           bpd.flg_status flg_status_det,
                           bpr.flg_time,
                           bpr.dt_req_tstz,
                           bpd.dt_begin_tstz,
                           bpd.dt_blood_product_det,
                           bpr.id_professional,
                           decode(bpr.notes, NULL, pk_procedures_constant.g_no, pk_procedures_constant.g_yes) flg_notes,
                           cs.id_prof_ordered_by,
                           cs.dt_ordered_by,
                           bpd.flg_priority,
                           bpr.id_episode_origin,
                           v.id_visit,
                           e.id_episode,
                           e.id_patient,
                           bpd.id_order_recurrence,
                           orp.id_order_recurr_option,
                           bpd.flg_req_origin_module,
                           bpr.notes,
                           bpd.notes_tech,
                           bpr.notes_cancel,
                           bpd.id_clinical_purpose,
                           bpd.clinical_purpose_notes,
                           bpd.transfusion_type,
                           bpd.qty_exec,
                           bpd.id_unit_mea_qty_exec,
                           bpd.special_instr,
                           bpd.barcode_lab,
                           bpd.qty_received,
                           bpd.id_unit_mea_qty_received,
                           bpd.expiration_date,
                           bpd.blood_group,
                           bpd.adverse_reaction,
                           bpd.blood_group_rh,
                           pk_blood_products_utils.get_bp_adverse_reaction_req(i_lang   => NULL,
                                                                               i_prof   => NULL,
                                                                               i_bp_req => bpr.id_blood_product_req) adverse_reaction_req
                      FROM blood_product_req bpr
                      JOIN (SELECT *
                             FROM blood_product_det bpdi
                            WHERE bpdi.flg_status != pk_blood_products_constant.g_status_det_pd) bpd
                        ON bpr.id_blood_product_req = bpd.id_blood_product_req
                      JOIN hemo_type ht
                        ON bpd.id_hemo_type = ht.id_hemo_type
                      JOIN episode e
                        ON e.id_episode = bpr.id_episode
                      JOIN visit v
                        ON v.id_visit = e.id_visit
                      LEFT JOIN episode e_origin
                        ON e_origin.id_episode = bpr.id_episode_origin
                      LEFT JOIN order_recurr_plan orp
                        ON orp.id_order_recurr_plan = bpd.id_order_recurrence
                      LEFT JOIN co_sign cs
                        ON cs.id_co_sign = bpd.id_co_sign_order) t
             CROSS JOIN TABLE(pk_ea_logic_blood_products.get_bp_status_req_all(l_lang, l_prof, t.id_episode, t.flg_time, t.flg_status_req, t.dt_req_tstz, t.dt_begin_tstz, t.id_order_recurr_option)) t_req
             CROSS JOIN TABLE(pk_ea_logic_blood_products.get_bp_status_all(l_lang, l_prof, t.id_episode, t.flg_time, t.flg_status_det, t.dt_req_tstz, t.dt_begin_tstz, t.id_order_recurr_option)) t_det
             WHERE rn = 1 log errors INTO err$_lab_tests_ea(to_char(SYSDATE)) reject LIMIT unlimited;
    
        pk_frmw.enable_index(i_table_name => 'BLOOD_PRODUCTS_EA', i_enable_fk => TRUE);
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_blood_products_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
        COMMIT;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_blood_products_ea.');
    END admin_50_blood_products_ea;

    /**
    * Migration script for INTERV_ICNP_EA
    *
    * @author  João Ribeiro
    * @version 2.4.3d
    * @since   17/10/2008
    */

    PROCEDURE admin_50_interv_icnp_ea IS
    
        i_patient          NUMBER(24) := NULL;
        i_episode          NUMBER(24) := NULL;
        i_schedule         NUMBER(24) := NULL;
        i_external_request NUMBER(24) := NULL;
        i_institution      NUMBER(24) := NULL;
        i_start_dt         TIMESTAMP WITH TIME ZONE;
        i_end_dt           TIMESTAMP WITH TIME ZONE;
        i_validate_table   BOOLEAN := FALSE;
        i_recreate_table   BOOLEAN := TRUE;
        i_commit_step      NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        --Migration script for INTERV_ICNP_EA
    
        l_count           NUMBER := 0;
        l_count_invalid   NUMBER := 0;
        l_dt_plan_tstz    icnp_interv_plan.dt_plan_tstz%TYPE;
        l_flg_status_plan icnp_interv_plan.flg_status%TYPE;
        l_id_prof_take    interv_icnp_ea.id_prof_take%TYPE;
        l_dt_take_ea      interv_icnp_ea.dt_take_ea%TYPE;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  interv_icnp_ea.status_str%TYPE;
        l_status_msg  interv_icnp_ea.status_msg%TYPE;
        l_status_icon interv_icnp_ea.status_icon%TYPE;
        l_status_flg  interv_icnp_ea.status_flg%TYPE;
    
        function_error              EXCEPTION;
        ins_invalid_record_error    EXCEPTION;
        invoking_external_prc_error EXCEPTION;
    
    BEGIN
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            DELETE FROM interv_icnp_ea;
            COMMIT;
        END IF;
    
        FOR rec IN (SELECT iei.id_icnp_epis_interv,
                           iei.id_composition           id_composition_iei,
                           iei.flg_time,
                           iei.flg_status,
                           iei.flg_type,
                           iei.dt_next_tstz,
                           ic.id_vs,
                           iei.id_prof_close,
                           iei.dt_close_tstz,
                           iei.dt_icnp_epis_interv_tstz,
                           iei.id_prof,
                           iei.id_episode_origin,
                           iei.id_episode,
                           iei.id_patient,
                           iei.notes,
                           iei.notes_close,
                           iei.dt_begin_tstz,
                           iedi.id_icnp_epis_diag,
                           ied.id_composition           id_composition_ied,
                           iei.id_order_recurr_plan,
                           iei.flg_prn,
                           orp.id_order_recurr_option
                      FROM icnp_epis_intervention iei
                      JOIN icnp_composition ic
                        ON iei.id_composition = ic.id_composition
                      JOIN icnp_epis_diag_interv iedi
                        ON iei.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                      JOIN icnp_epis_diagnosis ied
                        ON iedi.id_icnp_epis_diag = ied.id_icnp_epis_diag
                      LEFT JOIN order_recurr_plan orp
                        ON iei.id_order_recurr_plan = orp.id_order_recurr_plan
                     WHERE iei.id_episode_destination IS NULL
                       AND iei.forward_interv IS NULL)
        LOOP
        
            l_dt_plan_tstz    := NULL;
            l_flg_status_plan := NULL;
            l_id_prof_take    := NULL;
            l_dt_take_ea      := NULL;
            l_status_str      := NULL;
            l_status_msg      := NULL;
            l_status_icon     := NULL;
            l_status_flg      := NULL;
        
            BEGIN
                SELECT dt_plan_tstz,
                       flg_status,
                       (SELECT CASE
                                   WHEN rec.flg_prn = pk_alert_constant.g_yes THEN
                                    id_prof_take
                                   ELSE
                                    id_prof_take
                               END
                          FROM dual),
                       dt_take_tstz
                  INTO l_dt_plan_tstz, l_flg_status_plan, l_id_prof_take, l_dt_take_ea
                  FROM (SELECT iip.dt_plan_tstz, iip.flg_status, iip.id_prof_take, iip.dt_take_tstz
                          FROM icnp_interv_plan iip
                         WHERE iip.id_icnp_epis_interv = rec.id_icnp_epis_interv
                           AND iip.dt_plan_tstz =
                               (SELECT MAX(iip.dt_plan_tstz)
                                  FROM icnp_interv_plan iip1
                                 WHERE iip1.id_icnp_epis_interv = rec.id_icnp_epis_interv)
                         ORDER BY iip.id_icnp_interv_plan DESC)
                 WHERE rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        
            BEGIN
                --Obtains status info
                pk_ea_logic_interv_icnp.get_icnp_interv_status(i_prof                => l_prof,
                                                               i_flg_status          => rec.flg_status,
                                                               i_flg_type            => rec.flg_type,
                                                               i_flg_time            => rec.flg_time,
                                                               i_dt_next             => rec.dt_next_tstz,
                                                               i_dt_plan             => l_dt_plan_tstz,
                                                               i_flg_prn             => rec.flg_prn,
                                                               i_order_recurr_option => rec.id_order_recurr_option,
                                                               o_status_str          => l_status_str,
                                                               o_status_msg          => l_status_msg,
                                                               o_status_icon         => l_status_icon,
                                                               o_status_flg          => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
                INSERT INTO interv_icnp_ea_tmp
                    (id_icnp_epis_interv,
                     id_composition_interv,
                     id_icnp_epis_diag,
                     id_composition_diag,
                     flg_time,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_status,
                     flg_type,
                     dt_next,
                     dt_plan,
                     id_vs,
                     id_prof_close,
                     dt_close,
                     dt_icnp_epis_interv,
                     id_prof,
                     id_episode_origin,
                     id_episode,
                     id_patient,
                     flg_status_plan,
                     id_prof_take,
                     notes,
                     notes_close,
                     dt_begin,
                     id_order_recurr_plan,
                     flg_prn,
                     dt_take_ea)
                VALUES
                    (rec.id_icnp_epis_interv,
                     rec.id_composition_iei,
                     rec.id_icnp_epis_diag,
                     rec.id_composition_ied,
                     rec.flg_time,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.flg_status,
                     rec.flg_type,
                     rec.dt_next_tstz,
                     l_dt_plan_tstz,
                     rec.id_vs,
                     rec.id_prof_close,
                     rec.dt_close_tstz,
                     rec.dt_icnp_epis_interv_tstz,
                     rec.id_prof,
                     rec.id_episode_origin,
                     rec.id_episode,
                     rec.id_patient,
                     l_flg_status_plan,
                     l_id_prof_take,
                     rec.notes,
                     rec.notes_close,
                     rec.dt_begin_tstz,
                     rec.id_order_recurr_plan,
                     rec.flg_prn,
                     l_dt_take_ea);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                INSERT INTO interv_icnp_ea
                    (id_icnp_epis_interv,
                     id_composition_interv,
                     id_icnp_epis_diag,
                     id_composition_diag,
                     flg_time,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_status,
                     flg_type,
                     dt_next,
                     dt_plan,
                     id_vs,
                     id_prof_close,
                     dt_close,
                     dt_icnp_epis_interv,
                     id_prof,
                     id_episode_origin,
                     id_episode,
                     id_patient,
                     flg_status_plan,
                     id_prof_take,
                     notes,
                     notes_close,
                     dt_begin,
                     id_order_recurr_plan,
                     flg_prn,
                     dt_take_ea,
                     dt_dg_last_update)
                VALUES
                    (rec.id_icnp_epis_interv,
                     rec.id_composition_iei,
                     rec.id_icnp_epis_diag,
                     rec.id_composition_ied,
                     rec.flg_time,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.flg_status,
                     rec.flg_type,
                     rec.dt_next_tstz,
                     l_dt_plan_tstz,
                     rec.id_vs,
                     rec.id_prof_close,
                     rec.dt_close_tstz,
                     rec.dt_icnp_epis_interv_tstz,
                     rec.id_prof,
                     rec.id_episode_origin,
                     rec.id_episode,
                     rec.id_patient,
                     l_flg_status_plan,
                     l_id_prof_take,
                     rec.notes,
                     rec.notes_close,
                     rec.dt_begin_tstz,
                     rec.id_order_recurr_plan,
                     rec.flg_prn,
                     l_dt_take_ea,
                     current_timestamp);
            
            END IF;
        
            IF MOD(l_count, i_commit_step) = 0
            THEN
                COMMIT;
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_icnp_epis_interv id_ea_tmp
                           FROM interv_icnp_ea a
                           JOIN interv_icnp_ea_tmp b
                             ON a.id_icnp_epis_interv = b.id_icnp_epis_interv
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.id_composition_interv <> b.id_composition_interv OR
                                (a.id_composition_interv IS NULL AND b.id_composition_interv IS NOT NULL) OR
                                (a.id_composition_interv IS NOT NULL AND b.id_composition_interv IS NULL)) OR
                                (a.id_icnp_epis_diag <> b.id_icnp_epis_diag OR
                                (a.id_icnp_epis_diag IS NULL AND b.id_icnp_epis_diag IS NOT NULL) OR
                                (a.id_icnp_epis_diag IS NOT NULL AND b.id_icnp_epis_diag IS NULL)) OR
                                (a.id_composition_diag <> b.id_composition_diag OR
                                (a.id_composition_diag IS NULL AND b.id_composition_diag IS NOT NULL) OR
                                (a.id_composition_diag IS NOT NULL AND b.id_composition_diag IS NULL)) OR
                                (a.flg_time <> b.flg_time OR (a.flg_time IS NULL AND b.flg_time IS NOT NULL) OR
                                (a.flg_time IS NOT NULL AND b.flg_time IS NULL)) OR
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                (a.flg_status <> b.flg_status OR (a.flg_status IS NULL AND b.flg_status IS NOT NULL) OR
                                (a.flg_status IS NOT NULL AND b.flg_status IS NULL)) OR
                                (a.flg_type <> b.flg_type OR (a.flg_type IS NULL AND b.flg_type IS NOT NULL) OR
                                (a.flg_type IS NOT NULL AND b.flg_type IS NULL)) OR
                                (a.dt_next <> b.dt_next OR (a.dt_next IS NULL AND b.dt_next IS NOT NULL) OR
                                (a.dt_next IS NOT NULL AND b.dt_next IS NULL)) OR
                                (a.dt_plan <> b.dt_plan OR (a.dt_plan IS NULL AND b.dt_plan IS NOT NULL) OR
                                (a.dt_plan IS NOT NULL AND b.dt_plan IS NULL)) OR
                                (a.id_vs <> b.id_vs OR (a.id_vs IS NULL AND b.id_vs IS NOT NULL) OR
                                (a.id_vs IS NOT NULL AND b.id_vs IS NULL)) OR
                                (a.id_prof_close <> b.id_prof_close OR
                                (a.id_prof_close IS NULL AND b.id_prof_close IS NOT NULL) OR
                                (a.id_prof_close IS NOT NULL AND b.id_prof_close IS NULL)) OR
                                (a.dt_close <> b.dt_close OR (a.dt_close IS NULL AND b.dt_close IS NOT NULL) OR
                                (a.dt_close IS NOT NULL AND b.dt_close IS NULL)) OR
                                (a.dt_icnp_epis_interv <> b.dt_icnp_epis_interv OR
                                (a.dt_icnp_epis_interv IS NULL AND b.dt_icnp_epis_interv IS NOT NULL) OR
                                (a.dt_icnp_epis_interv IS NOT NULL AND b.dt_icnp_epis_interv IS NULL)) OR
                                (a.id_prof <> b.id_prof OR (a.id_prof IS NULL AND b.id_prof IS NOT NULL) OR
                                (a.id_prof IS NOT NULL AND b.id_prof IS NULL)) OR
                                (a.id_episode_origin <> b.id_episode_origin OR
                                (a.id_episode_origin IS NULL AND b.id_episode_origin IS NOT NULL) OR
                                (a.id_episode_origin IS NOT NULL AND b.id_episode_origin IS NULL)) OR
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                (a.flg_status_plan <> b.flg_status_plan OR
                                (a.flg_status_plan IS NULL AND b.flg_status_plan IS NOT NULL) OR
                                (a.flg_status_plan IS NOT NULL AND b.flg_status_plan IS NULL)) OR
                                (a.id_prof_take <> b.id_prof_take OR
                                (a.id_prof_take IS NULL AND b.id_prof_take IS NOT NULL) OR
                                (a.id_prof_take IS NOT NULL AND b.id_prof_take IS NULL)) OR
                                (a.notes <> b.notes OR (a.notes IS NULL AND b.notes IS NOT NULL) OR
                                (a.notes IS NOT NULL AND b.notes IS NULL)) OR
                                (a.notes_close <> b.notes_close OR
                                (a.notes_close IS NULL AND b.notes_close IS NOT NULL) OR
                                (a.notes_close IS NOT NULL AND b.notes_close IS NULL)) OR
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                (a.id_order_recurr_plan <> b.id_order_recurr_plan OR
                                (a.id_order_recurr_plan IS NULL AND b.id_order_recurr_plan IS NOT NULL) OR
                                (a.id_order_recurr_plan IS NOT NULL AND b.id_order_recurr_plan IS NULL)) OR
                                (a.flg_prn <> b.flg_prn OR (a.flg_prn IS NULL AND b.flg_prn IS NOT NULL) OR
                                (a.flg_prn IS NOT NULL AND b.flg_prn IS NULL)) OR
                                (a.dt_take_ea <> b.dt_take_ea OR (a.dt_take_ea IS NULL AND b.dt_take_ea IS NOT NULL) OR
                                (a.dt_take_ea IS NOT NULL AND b.dt_take_ea IS NULL))))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => 'INTERV_ICNP_EA',
                                          i_id_pk_1_value       => rec1.id_ea_tmp,
                                          i_id_pk_1_col_name    => 'ID_ICNP_EPIS_INTERV',
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT ii_ea_t.id_icnp_epis_interv id_ea_tmp
                           FROM interv_icnp_ea_tmp ii_ea_t
                          WHERE ii_ea_t.id_icnp_epis_interv NOT IN
                                (SELECT id_icnp_epis_interv
                                   FROM interv_icnp_ea))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => 'INTERV_ICNP_EA',
                                          i_id_pk_1_value       => rec2.id_ea_tmp,
                                          i_id_pk_1_col_name    => 'ID_ICNP_EPIS_INTERV',
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO interv_icnp_ea ii_ea
            USING (SELECT *
                     FROM interv_icnp_ea_tmp ii_ea_tmp
                    WHERE ii_ea_tmp.id_icnp_epis_interv IN
                          (SELECT dgir.id_pk_1_value
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.ea_table_name = 'INTERV_ICNP_EA'
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (ii_ea.id_icnp_epis_interv = t.id_icnp_epis_interv)
            WHEN MATCHED THEN
                UPDATE
                   SET ii_ea.id_composition_interv = t.id_composition_interv,
                       ii_ea.id_icnp_epis_diag     = t.id_icnp_epis_diag,
                       ii_ea.id_composition_diag   = t.id_composition_diag,
                       ii_ea.flg_time              = t.flg_time,
                       ii_ea.status_str            = t.status_str,
                       ii_ea.status_msg            = t.status_msg,
                       ii_ea.status_icon           = t.status_icon,
                       ii_ea.status_flg            = t.status_flg,
                       ii_ea.flg_status            = t.flg_status,
                       ii_ea.flg_type              = t.flg_type,
                       ii_ea.dt_next               = t.dt_next,
                       ii_ea.dt_plan               = t.dt_plan,
                       ii_ea.id_vs                 = t.id_vs,
                       ii_ea.id_prof_close         = t.id_prof_close,
                       ii_ea.dt_close              = t.dt_close,
                       ii_ea.dt_icnp_epis_interv   = t.dt_icnp_epis_interv,
                       ii_ea.id_prof               = t.id_prof,
                       ii_ea.id_episode_origin     = t.id_episode_origin,
                       ii_ea.id_episode            = t.id_episode,
                       ii_ea.id_patient            = t.id_patient,
                       ii_ea.flg_status_plan       = t.flg_status_plan,
                       ii_ea.id_prof_take          = t.id_prof_take,
                       ii_ea.notes                 = t.notes,
                       ii_ea.notes_close           = t.notes_close,
                       ii_ea.dt_begin              = t.dt_begin,
                       ii_ea.id_order_recurr_plan  = t.id_order_recurr_plan,
                       ii_ea.flg_prn               = t.flg_prn,
                       ii_ea.dt_take_ea            = t.dt_take_ea,
                       ii_ea.dt_dg_last_update     = l_current_timestamp
                 WHERE ii_ea.id_icnp_epis_interv = t.id_icnp_epis_interv
            WHEN NOT MATCHED THEN
                INSERT
                    (id_icnp_epis_interv,
                     id_composition_interv,
                     id_icnp_epis_diag,
                     id_composition_diag,
                     flg_time,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_status,
                     flg_type,
                     dt_next,
                     dt_plan,
                     id_vs,
                     id_prof_close,
                     dt_close,
                     dt_icnp_epis_interv,
                     id_prof,
                     id_episode_origin,
                     id_episode,
                     id_patient,
                     flg_status_plan,
                     id_prof_take,
                     notes,
                     notes_close,
                     dt_begin,
                     id_order_recurr_plan,
                     flg_prn,
                     dt_take_ea,
                     dt_dg_last_update)
                VALUES
                    (t.id_icnp_epis_interv,
                     t.id_composition_interv,
                     t.id_icnp_epis_diag,
                     t.id_composition_diag,
                     t.flg_time,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.flg_status,
                     t.flg_type,
                     t.dt_next,
                     t.dt_plan,
                     t.id_vs,
                     t.id_prof_close,
                     t.dt_close,
                     t.dt_icnp_epis_interv,
                     t.id_prof,
                     t.id_episode_origin,
                     t.id_episode,
                     t.id_patient,
                     t.flg_status_plan,
                     t.id_prof_take,
                     t.notes,
                     t.notes_close,
                     t.dt_begin,
                     t.id_order_recurr_plan,
                     t.flg_prn,
                     t.dt_take_ea,
                     l_current_timestamp);
        
            COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM interv_icnp_ea_tmp;
        COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'INTERV_ICNP_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        COMMIT;
    
        dbms_output.put_line('OK: ' || l_count || ' inserted records');
        dbms_output.put_line('OK: ' || l_count_invalid || ' inserted invalid records');
    
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM interv_icnp_ea_tmp;
            COMMIT;
        
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            --delete records from temporary table
            DELETE FROM interv_icnp_ea_tmp;
            COMMIT;
        
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM interv_icnp_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.raise_error(error_code_in => '-20001',
                                            text_in       => 'External error. Check table alertlog.tlog for error details.');
        
    END admin_50_interv_icnp_ea;

    /**
    * Migration script for PROCEDURES_EA
    *
    * @author  João Ribeiro
    * @version 2.4.3d
    * @since   17/10/2008
    */

    PROCEDURE admin_50_procedures_ea IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        ins_invalid_record_error EXCEPTION;
    
    BEGIN
    
        pk_frmw.disable_index(i_table_name => 'PROCEDURES_EA', i_disable_fk => TRUE);
    
        EXECUTE IMMEDIATE 'truncate table procedures_ea';
        EXECUTE IMMEDIATE 'truncate table err$_procedures_ea';
    
        INSERT /*+append*/
        INTO procedures_ea
            (id_interv_prescription,
             id_interv_presc_det,
             id_interv_presc_plan,
             id_intervention,
             flg_status_intervention,
             flg_status_req,
             flg_status_det,
             flg_status_plan,
             status_str,
             status_msg,
             status_icon,
             status_flg,
             code_intervention_alias,
             flg_time,
             flg_referral,
             flg_prty,
             id_order_recurrence,
             dt_begin_req,
             dt_begin_det,
             dt_interv_prescription,
             dt_interv_presc_det,
             dt_plan,
             id_professional,
             flg_notes,
             flg_doc,
             id_clinical_purpose,
             clinical_purpose_notes,
             flg_laterality,
             id_prof_order,
             dt_order,
             id_task_dependency,
             flg_req_origin_module,
             notes,
             notes_cancel,
             id_patient,
             id_visit,
             id_episode,
             id_episode_origin,
             dt_dg_last_update)
            SELECT t.id_interv_prescription,
                   t.id_interv_presc_det,
                   t.id_interv_presc_plan,
                   t.id_intervention,
                   t.flg_status_intervention,
                   t.flg_status_req,
                   t.flg_status_det,
                   t.flg_status_plan,
                   tf.status_str,
                   tf.status_msg,
                   tf.status_icon,
                   tf.status_flg,
                   t.code_intervention_alias,
                   t.flg_time,
                   t.flg_referral,
                   t.flg_prty,
                   t.id_order_recurrence,
                   t.dt_begin_req,
                   t.dt_begin_det,
                   t.dt_interv_prescription,
                   t.dt_interv_presc_det,
                   t.dt_plan,
                   t.id_professional,
                   t.flg_notes,
                   t.flg_doc,
                   t.id_clinical_purpose,
                   t.clinical_purpose_notes,
                   t.flg_laterality,
                   t.id_prof_order,
                   t.dt_order,
                   t.id_task_dependency,
                   t.flg_req_origin_module,
                   t.notes,
                   t.notes_cancel,
                   t.id_patient,
                   t.id_visit,
                   t.id_episode,
                   t.id_episode_origin,
                   l_current_timestamp
              FROM (SELECT ip.id_interv_prescription,
                           ipd.id_interv_presc_det,
                           MAX(ipp.id_interv_presc_plan) over(PARTITION BY ipp.id_interv_presc_det) AS id_interv_presc_plan,
                           ipd.id_intervention,
                           i.flg_status flg_status_intervention,
                           ip.flg_status flg_status_req,
                           ipd.flg_status flg_status_det,
                           ipp.flg_status flg_status_plan,
                           ipd.code_intervention_alias,
                           ip.flg_time,
                           ipd.flg_referral,
                           ipd.flg_prty,
                           ipd.id_order_recurrence,
                           ip.dt_begin_tstz dt_begin_req,
                           ipd.dt_begin_tstz dt_begin_det,
                           ip.dt_interv_prescription_tstz dt_interv_prescription,
                           ipd.dt_interv_presc_det,
                           ipp.dt_plan_tstz dt_plan,
                           ip.id_professional,
                           decode(coalesce(ipd.notes, ipd.notes_cancel),
                                  NULL,
                                  pk_procedures_constant.g_no,
                                  pk_procedures_constant.g_yes) flg_notes,
                           decode((SELECT 1
                                    FROM interv_media_archive ima
                                   WHERE ima.id_interv_presc_det = ipd.id_interv_presc_det
                                     AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_doc
                                     AND ima.flg_status = pk_procedures_constant.g_active
                                     AND rownum = 1),
                                  1,
                                  pk_procedures_constant.g_yes,
                                  pk_procedures_constant.g_no) flg_doc,
                           ipd.id_clinical_purpose,
                           ipd.clinical_purpose_notes,
                           ipd.flg_laterality,
                           nvl(cs.id_prof_ordered_by, ip.id_professional) id_prof_order,
                           nvl(cs.dt_ordered_by, ipd.dt_order_tstz) dt_order,
                           NULL id_task_dependency,
                           ipd.flg_req_origin_module,
                           ipd.notes,
                           ipd.notes_cancel,
                           ip.id_patient,
                           e.id_visit,
                           ip.id_episode,
                           ip.id_episode_origin,
                           ipd.flg_interv_type,
                           orp.id_order_recurr_option,
                           ipd.flg_prn
                      FROM interv_presc_det ipd
                      JOIN intervention i
                        ON i.id_intervention = ipd.id_intervention
                      JOIN interv_prescription ip
                        ON ip.id_interv_prescription = ipd.id_interv_prescription
                      LEFT JOIN (SELECT *
                                  FROM (SELECT id_interv_presc_det,
                                               id_interv_presc_plan,
                                               flg_status,
                                               dt_plan_tstz,
                                               rank() over(PARTITION BY id_interv_presc_det ORDER BY dt_plan_tstz DESC, id_interv_presc_plan DESC) AS rn
                                          FROM interv_presc_plan)
                                 WHERE rn = 1) ipp
                        ON ipp.id_interv_presc_det = ipd.id_interv_presc_det
                      LEFT JOIN order_recurr_plan orp
                        ON ipd.id_order_recurrence = orp.id_order_recurr_plan
                      LEFT JOIN co_sign_hist cs
                        ON ipd.id_co_sign_order = cs.id_co_sign_hist
                      LEFT JOIN episode e
                        ON e.id_episode = ip.id_episode
                      LEFT JOIN episode eo
                        ON eo.id_episode = ip.id_episode_origin) t
             CROSS JOIN TABLE(pk_ea_logic_procedures.get_procedure_status_all(i_lang => l_lang, i_prof => l_prof, i_episode => t.id_episode, i_flg_time => t.flg_time, i_flg_status_det => t.flg_status_det, i_flg_prn => t.flg_prn, i_flg_referral => t.flg_referral, i_dt_interv_prescription => t.dt_interv_prescription, i_dt_begin_req => t.dt_begin_req, i_dt_plan => t.dt_plan, i_order_recurr_option => t.id_order_recurr_option)) tf log errors
              INTO err$_procedures_ea(to_char(SYSDATE)) reject LIMIT unlimited;
    
        pk_frmw.enable_index(i_table_name => 'PROCEDURES_EA', i_enable_fk => TRUE);
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_procedures_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_procedures_ea.');
        
    END admin_50_procedures_ea;

    /********************************************************************************************
    * Actualiza as novas colunas da EPISODE, criadas devido à desnormalização da BO
    *
    * @param i_patient                Identificador de um paciente.
    * @param i_episode                Identificador de um episódio.
    * @value i_schedule               Identificador de um agendamento.
    * @param i_external_request       Identificador do P1.
    * @param i_institution            Identificador de uma instituição.
    * @param i_start_dt               Data de início a considerar para a validação/(re)construção de registos
    * @param i_end_dt                 Data de fim a considerar para a validação/(re)construção de registos
    * @param i_validate_table         Indicação da necessidade de validar os dados da tabela .
    * @param i_output_invalid_records Indicação da necessidade de guardar informação dos registos inválidos na tabela de registos inválidos.
    * @param i_recreate_table         Indicação da necessidade de refazer os dados na tabela de Easy Access/Awareness.
    * @param i_commit_step            Número de registos entre commits intermédios.
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @return   TRUE/FALSE
    *
    * @author   Rui Batista
    * @version  2.4.3d
    * @since    2008/10/16
       ********************************************************************************************/
    PROCEDURE admin_01_episode IS
    BEGIN
        NULL;
    END admin_01_episode;

    /********************************************************************************************
    * Popular a tabela de Awareness
    *
    * @param i_patient                Identificador de um paciente.
    * @param i_episode                Identificador de um episódio.
    * @value i_schedule               Identificador de um agendamento.
    * @param i_external_request       Identificador do P1.
    * @param i_institution            Identificador de uma instituição.
    * @param i_start_dt               Data de início a considerar para a validação/(re)construção de registos
    * @param i_end_dt                 Data de fim a considerar para a validação/(re)construção de registos
    * @param i_validate_table         Indicação da necessidade de validar os dados da tabela .
    * @param i_output_invalid_records Indicação da necessidade de guardar informação dos registos inválidos na tabela de registos inválidos.
    * @param i_recreate_table         Indicação da necessidade de refazer os dados na tabela de Easy Access/Awareness.
    * @param i_commit_step            Número de registos entre commits intermédios.
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @return   TRUE/FALSE
    *
    * @author   Teresa Coutinho
    * @version  2.4.3d
    * @since    2008/10/17
       ********************************************************************************************/

    FUNCTION get_decode_val(i_val_field IN NUMBER) RETURN VARCHAR2 IS
        l_ret VARCHAR2(1);
    BEGIN
        SELECT decode(i_val_field, 0, get_no(), get_yes())
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(text            => SQLERRM,
                                  object_name     => g_package_name,
                                  sub_object_name => 'get_decode_val',
                                  owner           => g_package_owner);
            RETURN get_no();
    END get_decode_val;

    PROCEDURE admin_99_awareness IS
    
        i_patient          NUMBER(24) := NULL;
        i_episode          NUMBER(24) := NULL;
        i_schedule         NUMBER(24) := NULL;
        i_external_request NUMBER(24) := NULL;
        i_institution      NUMBER(24) := NULL;
        i_start_dt         TIMESTAMP WITH TIME ZONE;
        i_end_dt           TIMESTAMP WITH TIME ZONE;
        i_validate_table   BOOLEAN := FALSE;
        i_recreate_table   BOOLEAN := TRUE;
        i_commit_step      NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        l_total_row_count NUMBER := 0;
    
        l_validation_type data_gov_invalid_recs.validation_type%TYPE;
        --l_no_errors_found BOOLEAN := TRUE;
        l_count_invalid NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        t_id_patient                 table_number := table_number();
        t_id_episode                 table_number := table_number();
        t_flg_episode                table_varchar := table_varchar();
        t_flg_pat_allergy            table_varchar := table_varchar();
        t_flg_pat_habit              table_varchar := table_varchar();
        t_flg_pat_history_diagnosis  table_varchar := table_varchar();
        t_flg_vital_sign_read        table_varchar := table_varchar();
        t_flg_epis_diagnosis         table_varchar := table_varchar();
        t_flg_analysis_req           table_varchar := table_varchar();
        t_flg_exam_req               table_varchar := table_varchar();
        t_flg_prescription           table_varchar := table_varchar();
        t_flg_drug_prescription      table_varchar := table_varchar();
        t_flg_drug_req               table_varchar := table_varchar();
        t_flg_interv_prescription    table_varchar := table_varchar();
        t_flg_nurse_activity_req     table_varchar := table_varchar();
        t_flg_monitorization         table_varchar := table_varchar();
        t_flg_icnp_epis_diagnosis    table_varchar := table_varchar();
        t_flg_icnp_epis_intervention table_varchar := table_varchar();
        t_flg_pat_pregnancy          table_varchar := table_varchar();
        t_flg_sys_alert_det          table_varchar := table_varchar();
        t_flg_presc_med              table_varchar := table_varchar();
        t_flg_presc_med_l            table_varchar := table_varchar();
        t_flg_presc_med_e            table_varchar := table_varchar();
        t_flg_presc_med_iv           table_varchar := table_varchar();
        t_flg_presc_med_r            table_varchar := table_varchar();
        t_id_visit                   table_number := table_number();
    
        CURSOR c_awareness IS
            SELECT id_patient id_patient,
                   id_episode id_episode,
                   pk_alert_constant.g_yes flg_episode,
                   (SELECT get_decode_val(flg_pat_allergy)
                      FROM dual) flg_pat_allergy,
                   (SELECT get_decode_val(flg_pat_habit)
                      FROM dual) flg_pat_habit,
                   (SELECT get_decode_val(flg_pat_history_diagnosis)
                      FROM dual) flg_pat_history_diagnosis,
                   (SELECT get_decode_val(flg_vital_sign_read)
                      FROM dual) flg_vital_sign_read,
                   (SELECT get_decode_val(flg_epis_diagnosis)
                      FROM dual) flg_epis_diagnosis,
                   (SELECT get_decode_val(flg_analysis_req)
                      FROM dual) flg_analysis_req,
                   (SELECT get_decode_val(flg_exam_req)
                      FROM dual) flg_exam_req,
                   (SELECT get_decode_val(flg_prescription)
                      FROM dual) flg_prescription,
                   (SELECT get_decode_val(flg_drug_prescription)
                      FROM dual) flg_drug_prescription,
                   (SELECT get_decode_val(flg_drug_req)
                      FROM dual) flg_drug_req,
                   (SELECT get_decode_val(flg_interv_prescription)
                      FROM dual) flg_interv_prescription,
                   (SELECT get_decode_val(flg_nurse_activity_req)
                      FROM dual) flg_nurse_activity_req,
                   (SELECT get_decode_val(flg_monitorization)
                      FROM dual) flg_monitorization,
                   (SELECT get_decode_val(flg_icnp_epis_diagnosis)
                      FROM dual) flg_icnp_epis_diagnosis,
                   (SELECT get_decode_val(flg_icnp_epis_intervention)
                      FROM dual) flg_icnp_epis_intervention,
                   (SELECT get_decode_val(flg_pat_pregnancy)
                      FROM dual) flg_pat_pregnancy,
                   (SELECT get_decode_val(flg_sys_alert_det)
                      FROM dual) flg_sys_alert_det,
                   (SELECT get_decode_val(flg_presc_med_l + flg_presc_med_e + flg_presc_med_iv + flg_presc_med_r)
                      FROM dual) flg_presc_med,
                   (SELECT get_decode_val(flg_presc_med_l)
                      FROM dual) flg_presc_med_l,
                   (SELECT get_decode_val(flg_presc_med_e)
                      FROM dual) flg_presc_med_e,
                   (SELECT get_decode_val(flg_presc_med_iv)
                      FROM dual) flg_presc_med_iv,
                   (SELECT get_decode_val(flg_presc_med_r)
                      FROM dual) flg_presc_med_r,
                   id_visit
              FROM --sql1
                   (SELECT (SELECT COUNT(0) flg_pat_allergy
                              FROM pat_allergy pa
                             WHERE pa.id_episode = sql1.id_episode) flg_pat_allergy,
                           (SELECT COUNT(0) flg_pat_habit
                              FROM pat_habit ph
                             WHERE ph.id_episode = sql1.id_episode) flg_pat_habit,
                           (SELECT COUNT(0) flg_pat_history_diagnosis
                              FROM pat_history_diagnosis phd
                             WHERE phd.id_episode = sql1.id_episode) flg_pat_history_diagnosis,
                           (SELECT COUNT(0) flg_vital_sign_read
                              FROM vital_sign_read vsr
                             WHERE vsr.id_episode = sql1.id_episode) flg_vital_sign_read,
                           (SELECT COUNT(0) flg_epis_diagnosis
                              FROM epis_diagnosis ed
                             WHERE ed.id_episode = sql1.id_episode) flg_epis_diagnosis,
                           (SELECT COUNT(0) flg_analysis_req
                              FROM analysis_req ar
                             WHERE sql1.id_episode IN (ar.id_episode, ar.id_episode_origin)) flg_analysis_req,
                           (SELECT COUNT(0) flg_exam_req
                              FROM exam_req er
                             WHERE sql1.id_episode IN (er.id_episode, er.id_episode_origin)) flg_exam_req,
                           (SELECT COUNT(0) flg_prescription
                              FROM prescription p
                             WHERE p.id_episode = sql1.id_episode) flg_prescription,
                           (SELECT COUNT(0) flg_drug_prescription
                              FROM drug_prescription dp
                             WHERE dp.id_episode = sql1.id_episode) flg_drug_prescription,
                           (SELECT COUNT(0) flg_drug_req
                              FROM drug_req dr
                             WHERE dr.id_episode = sql1.id_episode) flg_drug_req,
                           (SELECT COUNT(0) flg_interv_prescription
                              FROM interv_prescription ip
                             WHERE sql1.id_episode IN (ip.id_episode, ip.id_episode_origin)) flg_interv_prescription,
                           NULL flg_nurse_activity_req,
                           (SELECT COUNT(0) flg_monitorization
                              FROM monitorization m
                             WHERE m.id_episode = sql1.id_episode
                               AND m.flg_status != pk_alert_constant.g_monitor_vs_draft) flg_monitorization,
                           (SELECT COUNT(0) flg_icnp_epis_diagnosis
                              FROM icnp_epis_diagnosis ied
                             WHERE ied.id_episode = sql1.id_episode) flg_icnp_epis_diagnosis,
                           (SELECT COUNT(0) flg_icnp_epis_intervention
                              FROM icnp_epis_intervention iei
                             WHERE iei.id_episode = sql1.id_episode) flg_icnp_epis_intervention,
                           (SELECT COUNT(0) flg_pat_pregnancy
                              FROM pat_pregnancy pp
                             WHERE pp.id_episode = sql1.id_episode) flg_pat_pregnancy,
                           (SELECT COUNT(0) flg_sys_alert_det
                              FROM sys_alert_det sad
                             WHERE sad.id_episode = sql1.id_episode) flg_sys_alert_det,
                           (SELECT pk_rt_med_pfh.get_dga_prescription_count(i_id_workflow => table_number_id(pk_rt_med_pfh.wf_institution),
                                                                            i_id_visit    => sql1.id_visit,
                                                                            i_id_episode  => sql1.id_episode) AS flg_presc_med_l
                              FROM dual) flg_presc_med_l,
                           (SELECT pk_rt_med_pfh.get_dga_prescription_count(i_id_workflow => table_number_id(pk_rt_med_pfh.wf_ambulatory),
                                                                            i_id_visit    => sql1.id_visit,
                                                                            i_id_episode  => sql1.id_episode) AS flg_presc_med_e
                              FROM dual) flg_presc_med_e,
                           (SELECT pk_rt_med_pfh.get_dga_prescription_count(i_id_workflow => table_number_id(pk_rt_med_pfh.wf_iv),
                                                                            i_id_visit    => sql1.id_visit,
                                                                            i_id_episode  => sql1.id_episode) AS flg_presc_med_iv
                              FROM dual) flg_presc_med_iv,
                           (SELECT pk_rt_med_pfh.get_dga_prescription_count(i_id_workflow => table_number_id(pk_rt_med_pfh.wf_report),
                                                                            i_id_visit    => sql1.id_visit,
                                                                            i_id_episode  => sql1.id_episode) AS flg_presc_med_r
                              FROM dual) flg_presc_med_r,
                           sql1.id_visit,
                           sql1.id_patient,
                           sql1.id_episode
                      FROM (SELECT v.id_visit, v.id_patient, e.id_episode
                              FROM visit v
                              JOIN episode e
                                ON e.id_visit = v.id_visit
                             WHERE rownum > 0) sql1);
    
        TYPE t_c_awareness IS TABLE OF c_awareness%ROWTYPE;
    
        l_awareness t_c_awareness;
    
    BEGIN
    
        -- Se ?ara carregar os dados
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            EXECUTE IMMEDIATE 'truncate table awareness';
        
        END IF;
    
        OPEN c_awareness;
    
        FETCH c_awareness BULK COLLECT
            INTO l_awareness;
    
        CLOSE c_awareness;
    
        IF i_validate_table
        THEN
        
            --insert in temporary table
            FOR indx IN 1 .. l_awareness.count
            LOOP
                INSERT /*+ append */
                INTO awareness_tmp
                    (id_patient,
                     id_episode,
                     flg_episode,
                     flg_pat_allergy,
                     flg_pat_habit,
                     flg_pat_history_diagnosis,
                     flg_vital_sign_read,
                     flg_epis_diagnosis,
                     flg_analysis_req,
                     flg_exam_req,
                     flg_prescription,
                     flg_drug_prescription,
                     flg_drug_req,
                     flg_interv_prescription,
                     flg_nurse_activity_req,
                     flg_monitorization,
                     flg_icnp_epis_diagnosis,
                     flg_icnp_epis_intervention,
                     flg_pat_pregnancy,
                     flg_sys_alert_det,
                     flg_presc_med,
                     flg_presc_med_e,
                     flg_presc_med_iv,
                     flg_presc_med_l,
                     flg_presc_med_r,
                     id_visit)
                VALUES
                    (l_awareness(indx).id_patient,
                     l_awareness(indx).id_episode,
                     l_awareness(indx).flg_episode,
                     l_awareness(indx).flg_pat_allergy,
                     l_awareness(indx).flg_pat_habit,
                     l_awareness(indx).flg_pat_history_diagnosis,
                     l_awareness(indx).flg_vital_sign_read,
                     l_awareness(indx).flg_epis_diagnosis,
                     l_awareness(indx).flg_analysis_req,
                     l_awareness(indx).flg_exam_req,
                     l_awareness(indx).flg_prescription,
                     l_awareness(indx).flg_drug_prescription,
                     l_awareness(indx).flg_drug_req,
                     l_awareness(indx).flg_interv_prescription,
                     l_awareness(indx).flg_nurse_activity_req,
                     l_awareness(indx).flg_monitorization,
                     l_awareness(indx).flg_icnp_epis_diagnosis,
                     l_awareness(indx).flg_icnp_epis_intervention,
                     l_awareness(indx).flg_pat_pregnancy,
                     l_awareness(indx).flg_sys_alert_det,
                     l_awareness(indx).flg_presc_med,
                     l_awareness(indx).flg_presc_med_e,
                     l_awareness(indx).flg_presc_med_iv,
                     l_awareness(indx).flg_presc_med_l,
                     l_awareness(indx).flg_presc_med_r,
                     l_awareness(indx).id_visit);
            
            END LOOP;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            FOR indx IN 1 .. l_awareness.count
            LOOP
                INSERT /*+ append */
                INTO awareness
                    (id_patient,
                     id_episode,
                     flg_episode,
                     flg_pat_allergy,
                     flg_pat_habit,
                     flg_pat_history_diagnosis,
                     flg_vital_sign_read,
                     flg_epis_diagnosis,
                     flg_analysis_req,
                     flg_exam_req,
                     flg_prescription,
                     flg_drug_prescription,
                     flg_drug_req,
                     flg_interv_prescription,
                     flg_nurse_activity_req,
                     flg_monitorization,
                     flg_icnp_epis_diagnosis,
                     flg_icnp_epis_intervention,
                     flg_pat_pregnancy,
                     flg_sys_alert_det,
                     flg_presc_med,
                     flg_presc_med_e,
                     flg_presc_med_iv,
                     flg_presc_med_l,
                     flg_presc_med_r,
                     id_visit)
                VALUES
                    (l_awareness(indx).id_patient,
                     l_awareness(indx).id_episode,
                     l_awareness(indx).flg_episode,
                     l_awareness(indx).flg_pat_allergy,
                     l_awareness(indx).flg_pat_habit,
                     l_awareness(indx).flg_pat_history_diagnosis,
                     l_awareness(indx).flg_vital_sign_read,
                     l_awareness(indx).flg_epis_diagnosis,
                     l_awareness(indx).flg_analysis_req,
                     l_awareness(indx).flg_exam_req,
                     l_awareness(indx).flg_prescription,
                     l_awareness(indx).flg_drug_prescription,
                     l_awareness(indx).flg_drug_req,
                     l_awareness(indx).flg_interv_prescription,
                     l_awareness(indx).flg_nurse_activity_req,
                     l_awareness(indx).flg_monitorization,
                     l_awareness(indx).flg_icnp_epis_diagnosis,
                     l_awareness(indx).flg_icnp_epis_intervention,
                     l_awareness(indx).flg_pat_pregnancy,
                     l_awareness(indx).flg_sys_alert_det,
                     l_awareness(indx).flg_presc_med,
                     l_awareness(indx).flg_presc_med_e,
                     l_awareness(indx).flg_presc_med_iv,
                     l_awareness(indx).flg_presc_med_l,
                     l_awareness(indx).flg_presc_med_r,
                     l_awareness(indx).id_visit);
            
            END LOOP;
            COMMIT;
            l_total_row_count := l_total_row_count + t_id_patient.count;
        END IF;
    
        -----------
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_patient id_patient_awareness_tmp, b.id_episode id_epis_awareness_tmp
                           FROM awareness a
                           JOIN awareness_tmp b
                             ON a.id_patient = b.id_patient
                            AND a.id_episode = b.id_episode
                            AND ((a.flg_episode <> b.flg_episode OR
                                (a.flg_episode IS NULL AND b.flg_episode IS NOT NULL) OR
                                (a.flg_episode IS NOT NULL AND b.flg_episode IS NULL)) OR
                                (a.flg_pat_allergy <> b.flg_pat_allergy OR
                                (a.flg_pat_allergy IS NULL AND b.flg_pat_allergy IS NOT NULL) OR
                                (a.flg_pat_allergy IS NOT NULL AND b.flg_pat_allergy IS NULL)) OR
                                (a.flg_pat_habit <> b.flg_pat_habit OR
                                (a.flg_pat_habit IS NULL AND b.flg_pat_habit IS NOT NULL) OR
                                (a.flg_pat_habit IS NOT NULL AND b.flg_pat_habit IS NULL)) OR
                                (a.flg_pat_history_diagnosis <> b.flg_pat_history_diagnosis OR
                                (a.flg_pat_history_diagnosis IS NULL AND b.flg_pat_history_diagnosis IS NOT NULL) OR
                                (a.flg_pat_history_diagnosis IS NOT NULL AND b.flg_pat_history_diagnosis IS NULL)) OR
                                (a.flg_vital_sign_read <> b.flg_vital_sign_read OR
                                (a.flg_vital_sign_read IS NULL AND b.flg_vital_sign_read IS NOT NULL) OR
                                (a.flg_vital_sign_read IS NOT NULL AND b.flg_vital_sign_read IS NULL)) OR
                                (a.flg_epis_diagnosis <> b.flg_epis_diagnosis OR
                                (a.flg_epis_diagnosis IS NULL AND b.flg_epis_diagnosis IS NOT NULL) OR
                                (a.flg_epis_diagnosis IS NOT NULL AND b.flg_epis_diagnosis IS NULL)) OR
                                (a.flg_analysis_req <> b.flg_analysis_req OR
                                (a.flg_analysis_req IS NULL AND b.flg_analysis_req IS NOT NULL) OR
                                (a.flg_analysis_req IS NOT NULL AND b.flg_analysis_req IS NULL)) OR
                                (a.flg_exam_req <> b.flg_exam_req OR
                                (a.flg_exam_req IS NULL AND b.flg_exam_req IS NOT NULL) OR
                                (a.flg_exam_req IS NOT NULL AND b.flg_exam_req IS NULL)) OR
                                (a.flg_interv_prescription <> b.flg_interv_prescription OR
                                (a.flg_interv_prescription IS NULL AND b.flg_interv_prescription IS NOT NULL) OR
                                (a.flg_interv_prescription IS NOT NULL AND b.flg_interv_prescription IS NULL)) OR
                                (a.flg_nurse_activity_req <> b.flg_nurse_activity_req OR
                                (a.flg_nurse_activity_req IS NULL AND b.flg_nurse_activity_req IS NOT NULL) OR
                                (a.flg_nurse_activity_req IS NOT NULL AND b.flg_nurse_activity_req IS NULL)) OR
                                (a.flg_monitorization <> b.flg_monitorization OR
                                (a.flg_monitorization IS NULL AND b.flg_monitorization IS NOT NULL) OR
                                (a.flg_monitorization IS NOT NULL AND b.flg_monitorization IS NULL)) OR
                                (a.flg_icnp_epis_diagnosis <> b.flg_icnp_epis_diagnosis OR
                                (a.flg_icnp_epis_diagnosis IS NULL AND b.flg_icnp_epis_diagnosis IS NOT NULL) OR
                                (a.flg_icnp_epis_diagnosis IS NOT NULL AND b.flg_icnp_epis_diagnosis IS NULL)) OR
                                (a.flg_icnp_epis_intervention <> b.flg_icnp_epis_intervention OR
                                (a.flg_icnp_epis_intervention IS NULL AND b.flg_icnp_epis_intervention IS NOT NULL) OR
                                (a.flg_icnp_epis_intervention IS NOT NULL AND b.flg_icnp_epis_intervention IS NULL)) OR
                                (a.flg_pat_pregnancy <> b.flg_pat_pregnancy OR
                                (a.flg_pat_pregnancy IS NULL AND b.flg_pat_pregnancy IS NOT NULL) OR
                                (a.flg_pat_pregnancy IS NOT NULL AND b.flg_pat_pregnancy IS NULL)) OR
                                (a.flg_sys_alert_det <> b.flg_sys_alert_det OR
                                (a.flg_sys_alert_det IS NULL AND b.flg_sys_alert_det IS NOT NULL) OR
                                (a.flg_sys_alert_det IS NOT NULL AND b.flg_sys_alert_det IS NULL)) OR
                                (a.flg_presc_med <> b.flg_presc_med OR
                                (a.flg_presc_med IS NULL AND b.flg_presc_med IS NOT NULL) OR
                                (a.flg_presc_med IS NOT NULL AND b.flg_presc_med IS NULL)) OR
                                (a.flg_presc_med_e <> b.flg_presc_med_e OR
                                (a.flg_presc_med_e IS NULL AND b.flg_presc_med_e IS NOT NULL) OR
                                (a.flg_presc_med_e IS NOT NULL AND b.flg_presc_med_e IS NULL)) OR
                                (a.flg_presc_med_iv <> b.flg_presc_med_iv OR
                                (a.flg_presc_med_iv IS NULL AND b.flg_presc_med_iv IS NOT NULL) OR
                                (a.flg_presc_med_iv IS NOT NULL AND b.flg_presc_med_iv IS NULL)) OR
                                (a.flg_presc_med_l <> b.flg_presc_med_l OR
                                (a.flg_presc_med_l IS NULL AND b.flg_presc_med_l IS NOT NULL) OR
                                (a.flg_presc_med_l IS NOT NULL AND b.flg_presc_med_l IS NULL)) OR
                                (a.flg_presc_med_r <> b.flg_presc_med_r OR
                                (a.flg_presc_med_r IS NULL AND b.flg_presc_med_r IS NOT NULL) OR
                                (a.flg_presc_med_r IS NOT NULL AND b.flg_presc_med_r IS NULL)) OR
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL))))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => 'AWARENESS',
                                          i_id_pk_1_value       => rec1.id_patient_awareness_tmp,
                                          i_id_pk_1_col_name    => 'ID_PATIENT',
                                          i_id_pk_2_value       => rec1.id_epis_awareness_tmp,
                                          i_id_pk_2_col_name    => 'ID_EPISODE',
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT a_tmp.id_patient id_patient_awareness_tmp, a_tmp.id_episode id_epis_awareness_tmp
                           FROM awareness_tmp a_tmp
                          WHERE (a_tmp.id_patient, a_tmp.id_episode) NOT IN
                                (SELECT id_patient, id_episode
                                   FROM awareness))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => 'AWARENESS',
                                          i_id_pk_1_value       => rec2.id_patient_awareness_tmp,
                                          i_id_pk_1_col_name    => 'ID_PATIENT',
                                          i_id_pk_2_value       => rec2.id_epis_awareness_tmp,
                                          i_id_pk_2_col_name    => 'ID_EPISODE',
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
        
            MERGE INTO awareness a
            USING (SELECT *
                     FROM awareness_tmp a_tmp
                    WHERE (a_tmp.id_patient, a_tmp.id_episode) IN
                          (SELECT dgir.id_pk_1_value, dgir.id_pk_2_value
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.ea_table_name = 'AWARENESS'
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (a.id_patient = t.id_patient AND a.id_episode = t.id_episode)
            
            WHEN MATCHED THEN
                UPDATE
                   SET a.flg_episode                = t.flg_episode,
                       a.flg_pat_allergy            = t.flg_pat_allergy,
                       a.flg_pat_habit              = t.flg_pat_habit,
                       a.flg_pat_history_diagnosis  = t.flg_pat_history_diagnosis,
                       a.flg_vital_sign_read        = t.flg_vital_sign_read,
                       a.flg_epis_diagnosis         = t.flg_epis_diagnosis,
                       a.flg_analysis_req           = t.flg_analysis_req,
                       a.flg_exam_req               = t.flg_exam_req,
                       a.flg_prescription           = t.flg_prescription,
                       a.flg_drug_prescription      = t.flg_drug_prescription,
                       a.flg_drug_req               = t.flg_drug_req,
                       a.flg_interv_prescription    = t.flg_interv_prescription,
                       a.flg_nurse_activity_req     = t.flg_nurse_activity_req,
                       a.flg_monitorization         = t.flg_monitorization,
                       a.flg_icnp_epis_diagnosis    = t.flg_icnp_epis_diagnosis,
                       a.flg_icnp_epis_intervention = t.flg_icnp_epis_intervention,
                       a.flg_pat_pregnancy          = t.flg_pat_pregnancy,
                       a.flg_sys_alert_det          = t.flg_sys_alert_det,
                       a.flg_presc_med              = t.flg_presc_med,
                       a.flg_presc_med_e            = t.flg_presc_med_e,
                       a.flg_presc_med_iv           = t.flg_presc_med_iv,
                       a.flg_presc_med_l            = t.flg_presc_med_l,
                       a.flg_presc_med_r            = t.flg_presc_med_r,
                       a.id_visit                   = t.id_visit
                 WHERE a.id_patient = t.id_patient
                   AND a.id_episode = t.id_episode
                
            
            WHEN NOT MATCHED THEN
                INSERT
                    (id_patient,
                     id_episode,
                     flg_episode,
                     flg_pat_allergy,
                     flg_pat_habit,
                     flg_pat_history_diagnosis,
                     flg_vital_sign_read,
                     flg_epis_diagnosis,
                     flg_analysis_req,
                     flg_exam_req,
                     flg_prescription,
                     flg_drug_prescription,
                     flg_drug_req,
                     flg_interv_prescription,
                     flg_nurse_activity_req,
                     flg_monitorization,
                     flg_icnp_epis_diagnosis,
                     flg_icnp_epis_intervention,
                     flg_pat_pregnancy,
                     flg_sys_alert_det,
                     id_visit,
                     flg_presc_med,
                     flg_presc_med_e,
                     flg_presc_med_iv,
                     flg_presc_med_l,
                     flg_presc_med_r)
                VALUES
                    (t.id_patient,
                     t.id_episode,
                     t.flg_episode,
                     t.flg_pat_allergy,
                     t.flg_pat_habit,
                     t.flg_pat_history_diagnosis,
                     t.flg_vital_sign_read,
                     t.flg_epis_diagnosis,
                     t.flg_analysis_req,
                     t.flg_exam_req,
                     t.flg_prescription,
                     t.flg_drug_prescription,
                     t.flg_drug_req,
                     t.flg_interv_prescription,
                     t.flg_nurse_activity_req,
                     t.flg_monitorization,
                     t.flg_icnp_epis_diagnosis,
                     t.flg_icnp_epis_intervention,
                     t.flg_pat_pregnancy,
                     t.flg_sys_alert_det,
                     t.id_visit,
                     t.flg_presc_med,
                     t.flg_presc_med_e,
                     t.flg_presc_med_iv,
                     t.flg_presc_med_l,
                     t.flg_presc_med_r);
        
            COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM awareness_tmp;
        COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'AWARENESS'
           AND dgir.dt_validation < l_current_timestamp;
    
        COMMIT;
    
        dbms_output.put_line('OK: ' || l_total_row_count || ' inserted records');
        dbms_output.put_line('OK: ' || l_count_invalid || ' inserted invalid records');
    
        IF l_count_invalid > 0
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
    END admin_99_awareness;

    FUNCTION update_viewer_epis_archive
    (
        i_table_id_patients IN table_number,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_viewer IS
        
            SELECT *
              FROM viewer_ehr_ea
             WHERE id_patient IN (SELECT /*+opt_estimate (table t rows=0.000001)*/
                                   column_value
                                    FROM TABLE(i_table_id_patients));
    
        l_num_occur  table_number := table_number();
        l_desc_first table_varchar := table_varchar();
        l_code_first table_varchar := table_varchar();
        l_dt_first   table_varchar := table_varchar();
    
        l_date_compare VARCHAR2(200);
    
        l_dt_epis_archive   VARCHAR2(200);
        l_code_epis_archive VARCHAR2(200);
        l_desc_epis_archive VARCHAR2(4000);
    
        g_date_greater CONSTANT VARCHAR2(1 CHAR) := 'G';
        g_date_lower   CONSTANT VARCHAR2(1 CHAR) := 'L';
        g_date_equal   CONSTANT VARCHAR2(1 CHAR) := 'E';
    BEGIN
    
        g_error := 'START update_viewer_epis_archive';
    
        FOR i IN c_viewer
        LOOP
        
            l_dt_epis_archive   := NULL;
            l_code_epis_archive := NULL;
            l_desc_epis_archive := NULL;
        
            -- Compare by null       
            IF i.dt_episode IS NULL
               AND i.dt_archive IS NOT NULL
            THEN
                -- archive                
                l_dt_epis_archive   := i.dt_archive;
                l_code_epis_archive := i.code_archive;
                l_desc_epis_archive := i.desc_archive;
            ELSIF i.dt_archive IS NULL
                  AND i.dt_episode IS NOT NULL
            THEN
                l_dt_epis_archive := i.dt_episode;
                -- episode
                l_dt_epis_archive   := i.dt_episode;
                l_code_epis_archive := i.code_episode;
                l_desc_epis_archive := i.desc_episode;
            
            ELSIF i.dt_episode IS NOT NULL
                  AND i.dt_archive IS NOT NULL
            THEN
            
                -- compare date vs date
                l_date_compare := pk_date_utils.compare_dates_tsz(i_prof  => profissional(-1,
                                                                                          pk_problems.get_institution(NULL,
                                                                                                                      i.id_patient),
                                                                                          pk_problems.get_software(NULL,
                                                                                                                   i.id_patient)),
                                                                  i_date1 => i.dt_episode,
                                                                  i_date2 => i.dt_archive);
            
                -- E = they are equal so use the episode
                IF l_date_compare = g_date_greater
                   OR l_date_compare = g_date_equal
                THEN
                    -- episode
                    l_dt_epis_archive   := i.dt_episode;
                    l_code_epis_archive := i.code_episode;
                    l_desc_epis_archive := i.desc_episode;
                ELSIF l_date_compare = g_date_lower
                THEN
                    -- archive                
                    l_dt_epis_archive   := i.dt_archive;
                    l_code_epis_archive := i.code_archive;
                    l_desc_epis_archive := i.desc_archive;
                
                END IF;
            
            END IF;
        
            UPDATE viewer_ehr_ea ea
               SET ea.num_epis_archive  = nvl(i.num_episode, 0) + nvl(i.num_archive, 0),
                   ea.dt_epis_archive   = l_dt_epis_archive,
                   ea.code_epis_archive = l_code_epis_archive,
                   ea.desc_epis_archive = l_desc_epis_archive
             WHERE ea.id_patient = i.id_patient;
        
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
    END update_viewer_epis_archive;
    /********************************************************************************************
    * Actualiza as novas colunas da EPIS_INFO desnormalizada
    *
    * @param i_patient                Identificador de um paciente.
    * @param i_episode                Identificador de um episódio.
    * @value i_schedule               Identificador de um agendamento.
    * @param i_external_request       Identificador do P1.
    * @param i_institution            Identificador de uma instituição.
    * @param i_start_dt               Data de início a considerar para a validação/(re)construção de registos
    * @param i_end_dt                 Data de fim a considerar para a validação/(re)construção de registos
    * @param i_validate_table         Indicação da necessidade de validar os dados da tabela .
    * @param i_output_invalid_records Indicação da necessidade de guardar informação dos registos inválidos na tabela de registos inválidos.
    * @param i_recreate_table         Indicação da necessidade de refazer os dados na tabela de Easy Access/Awareness.
    * @param i_commit_step            Número de registos entre commits intermédios.
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @return   TRUE/FALSE
    *
    * @author   Teresa Coutinho
    * @version  2.4.3d
    * @since    2008/10/17
    ********************************************************************************************/
    --
    -- IMPORTANT:
    -- This function must be commented in development, however should not be versioned commented
    --

    --20101109 - This function was deleted because EPIS_TASK table was dropped

    PROCEDURE admin_50_referral_ea IS
        l_count_invalid NUMBER := 0;
        l_min           PLS_INTEGER;
        l_max           PLS_INTEGER;
        l_count         PLS_INTEGER;
        l_rec_bulk      PLS_INTEGER := pk_data_gov_admin.get_commit_limit;
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        -- disable all indexes
        pk_frmw.disable_index(i_table_name => 'REFERRAL_EA', i_disable_fk => TRUE);
    
        EXECUTE IMMEDIATE 'truncate table referral_ea';
        EXECUTE IMMEDIATE 'truncate table err$_referral_ea';
    
        SELECT COUNT(1)
          INTO l_count
          FROM p1_external_request exr;
    
        l_count := ceil(l_count / l_rec_bulk) + 1;
    
        l_min := 1;
        l_max := l_rec_bulk;
    
        FOR rec_count IN 1 .. l_count
        LOOP
        
            INSERT /*+append*/
            INTO referral_ea
                (id_external_request,
                 id_patient,
                 num_req,
                 flg_type,
                 flg_status,
                 id_prof_status,
                 dt_status,
                 flg_priority,
                 flg_home,
                 id_speciality,
                 decision_urg_level,
                 id_inst_orig,
                 id_inst_dest,
                 id_dep_clin_serv,
                 id_prof_redirected,
                 id_match,
                 id_prof_requested,
                 dt_requested,
                 dt_new,
                 dt_issued,
                 id_prof_triage,
                 dt_triage,
                 dt_forwarded,
                 id_schedule,
                 id_prof_schedule,
                 dt_schedule,
                 dt_efectiv,
                 dt_acknowledge,
                 dt_dg_last_update,
                 dt_last_interaction_tstz,
                 id_workflow,
                 id_external_sys,
                 ext_reference,
                 institution_name_roda,
                 id_prof_orig,
                 id_prof_sch_sugg,
                 flg_migrated,
                 nr_clinical_doc,
                 flg_received,
                 flg_sent_by,
                 nr_clin_comments,
                 nr_adm_comments,
                 dt_adm_last_comment,
                 dt_clin_last_comment,
                 id_prof_clin_comment,
                 id_prof_adm_comment,
                 id_inst_adm_comment,
                 id_inst_clin_comment)
                SELECT exr.id_external_request id_external_request,
                       exr.id_patient id_patient,
                       exr.num_req num_req,
                       exr.flg_type flg_type,
                       exr.flg_status flg_status,
                       exr.id_prof_status id_prof_status,
                       exr.dt_status_tstz dt_status,
                       exr.flg_priority flg_priority,
                       exr.flg_home flg_home,
                       exr.id_speciality id_speciality,
                       exr.decision_urg_level decision_urg_level,
                       exr.id_inst_orig id_inst_orig,
                       exr.id_inst_dest id_inst_dest,
                       exr.id_dep_clin_serv id_dep_clin_serv,
                       (SELECT i.id_prof_dest
                          FROM p1_tracking i
                         WHERE i.rowid = exr.r_tracking_rid) id_prof_redirected,
                       (SELECT m.id_match
                          FROM p1_match m
                         WHERE exr.id_patient = m.id_patient
                           AND exr.id_inst_dest = m.id_institution
                           AND m.flg_status = 'A'
                           AND rownum <= 1) id_match,
                       exr.id_prof_requested id_prof_requested,
                       exr.dt_requested dt_requested,
                       (SELECT t.dt_tracking_tstz
                          FROM (SELECT t.dt_tracking_tstz, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status = 'N'
                                   AND t.flg_type = 'S'
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) dt_new,
                       (SELECT t.dt_tracking_tstz
                          FROM (SELECT t.dt_tracking_tstz, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status = 'I'
                                   AND t.flg_type = 'S'
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) dt_issued,
                       (SELECT decode(ext_req_status, 'R', id_prof_dest, id_professional)
                          FROM (SELECT t.ext_req_status, t.id_prof_dest, t.id_professional, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status IN ('A', 'X', 'D', 'R')
                                   AND t.flg_type IN ('S', 'P')
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) id_prof_triage,
                       (SELECT i.dt_tracking_tstz
                          FROM (SELECT *
                                  FROM p1_tracking t
                                 WHERE ext_req_status = 'T'
                                   AND flg_type IN ('S', 'C')
                                 ORDER BY dt_tracking_tstz DESC) i
                         WHERE i.id_external_request = exr.id_external_request
                           AND rownum = 1) dt_triage,
                       (SELECT dt_tracking_tstz
                          FROM p1_tracking t
                         WHERE t.rowid = exr.r_tracking_rid) dt_forwarded,
                       exr.id_schedule id_schedule,
                       (SELECT spo.id_professional
                          FROM schedule s
                          JOIN schedule_outp so
                            ON so.id_schedule = s.id_schedule
                          JOIN sch_prof_outp spo
                            ON (so.id_schedule_outp = spo.id_schedule_outp)
                         WHERE (exr.id_schedule = s.id_schedule AND s.flg_status != 'C')
                           AND rownum <= 1) id_prof_schedule,
                       (SELECT s.dt_begin_tstz
                          FROM schedule s
                         WHERE (exr.id_schedule = s.id_schedule AND s.flg_status != 'C')) dt_schedule,
                       (SELECT t.dt_tracking_tstz
                          FROM (SELECT t.dt_tracking_tstz, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status = 'E'
                                   AND t.flg_type = 'S'
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) dt_efectiv,
                       (SELECT t.dt_tracking_tstz
                          FROM (SELECT t.dt_tracking_tstz, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status = 'K'
                                   AND t.flg_type = 'S'
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) dt_acknowledge,
                       g_sysdate_tstz dt_dg_last_update,
                       exr.dt_last_interaction_tstz dt_last_interaction_tstz,
                       exr.id_workflow id_workflow,
                       exr.id_external_sys id_external_sys,
                       exr.ext_reference ext_reference,
                       roda.institution_name institution_name_roda,
                       roda.id_professional id_prof_orig, -- only set when ref_orig_data is set
                       (SELECT t.id_prof_dest
                          FROM (SELECT t.id_prof_dest, t.id_external_request
                                  FROM p1_tracking t
                                 WHERE t.ext_req_status = 'A'
                                   AND t.flg_type = 'S'
                                 ORDER BY dt_tracking_tstz DESC) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND rownum <= 1) id_prof_sch_sugg,
                       exr.flg_migrated,
                       (SELECT COUNT(d.id_external_request)
                          FROM doc_external d
                         WHERE d.id_external_request = exr.id_external_request
                           AND d.flg_status = 'A') nr_clinical_doc,
                       (SELECT decode(COUNT(de.id_doc_external), 0, pk_ref_constant.g_no, pk_ref_constant.g_yes)
                          FROM doc_external de
                         WHERE de.id_external_request = exr.id_external_request
                           AND de.flg_status = pk_ref_constant.g_active
                           AND de.flg_sent_by IS NOT NULL
                           AND de.flg_received = pk_ref_constant.g_yes) flg_received,
                       (SELECT decode(COUNT(de.id_doc_external), 0, pk_ref_constant.g_no, pk_ref_constant.g_yes) flg_sent_by
                          FROM doc_external de
                         WHERE de.id_external_request = exr.id_external_request
                           AND de.flg_status = pk_ref_constant.g_active
                           AND de.flg_sent_by IS NOT NULL) flg_sent_by,
                       (SELECT COUNT(id_external_request)
                          FROM ref_comments
                         WHERE flg_type = pk_ref_constant.g_clinical_comment
                           AND flg_status = pk_ref_constant.g_active_comment
                           AND id_external_request = exr.id_external_request) nr_clin_comments,
                       (SELECT COUNT(id_external_request)
                          FROM ref_comments
                         WHERE flg_type = pk_ref_constant.g_administrative_comment
                           AND flg_status = pk_ref_constant.g_active_comment
                           AND id_external_request = exr.id_external_request) nr_adm_comments,
                       (SELECT t.dt_comment
                          FROM (SELECT rc.dt_comment,
                                       rc.id_external_request,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_administrative_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) dt_adm_last_comment,
                       (SELECT t.dt_comment
                          FROM (SELECT rc.dt_comment,
                                       rc.id_external_request,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_clinical_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) dt_clin_last_comment,
                       (SELECT t.id_professional
                          FROM (SELECT rc.dt_comment,
                                       rc.id_external_request,
                                       rc.id_professional,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_clinical_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) id_prof_clin_comment,
                       (SELECT t.id_professional
                          FROM (SELECT rc.dt_comment,
                                       rc.id_external_request,
                                       rc.id_professional,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_administrative_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) id_prof_adm_comment,
                       (SELECT t.id_institution
                          FROM (SELECT rc.id_external_request,
                                       rc.id_institution,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_administrative_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) id_inst_adm_comment,
                       (SELECT t.id_institution
                          FROM (SELECT rc.id_external_request,
                                       rc.id_institution,
                                       row_number() over(PARTITION BY rc.id_external_request ORDER BY rc.dt_comment DESC) my_row
                                  FROM ref_comments rc
                                 WHERE rc.flg_status = pk_ref_constant.g_active_comment
                                   AND rc.flg_type = pk_ref_constant.g_clinical_comment) t
                         WHERE t.id_external_request = exr.id_external_request
                           AND my_row = 1) id_inst_clin_comment
                  FROM (SELECT tbl.*,
                               (SELECT t.rowid
                                  FROM (SELECT t.rowid, t.id_external_request
                                          FROM p1_tracking t
                                         WHERE t.ext_req_status = pk_ref_constant.g_p1_status_r
                                           AND t.flg_type = pk_ref_constant.g_tracking_type_p
                                         ORDER BY dt_tracking_tstz DESC) t
                                 WHERE t.id_external_request = tbl.id_external_request
                                   AND rownum <= 1) r_tracking_rid
                          FROM (SELECT r.*
                                  FROM (SELECT rownum rn, p.*
                                          FROM (SELECT exr.*
                                                  FROM p1_external_request exr
                                                 ORDER BY exr.id_external_request) p
                                         WHERE rownum < l_max) r
                                 WHERE r.rn >= l_min) tbl) exr
                  LEFT JOIN ref_orig_data roda
                    ON (exr.id_external_request = roda.id_external_request) log errors INTO
                 err$_referral_ea(to_char(SYSDATE)) reject LIMIT unlimited;
        
            COMMIT;
        
            l_min := rec_count * l_rec_bulk;
            l_max := (rec_count + 1) * l_rec_bulk;
        
        END LOOP;
    
        -- enable all indexes
        pk_frmw.enable_index(i_table_name => 'REFERRAL_EA', i_enable_fk => TRUE);
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_referral_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_referral_ea.');
    END admin_50_referral_ea;

    PROCEDURE admin_50_monitorizations_ea IS
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        -- Migration script for MONITORIZATIONS_EA
        l_count_invalid             NUMBER := 0;
        l_count                     NUMBER := 0;
        l_id_monitorization_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_flg_status_plan           monitorization_vs_plan.flg_status%TYPE;
        l_dt_plan_tstz              monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_monit_count               NUMBER(6) := 0;
        l_current_timestamp         TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type           data_gov_invalid_recs.validation_type%TYPE;
    
        --        l_prof        profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  monitorizations_ea.status_str%TYPE;
        l_status_msg  monitorizations_ea.status_msg%TYPE;
        l_status_icon monitorizations_ea.status_icon%TYPE;
        l_status_flg  monitorizations_ea.status_flg%TYPE;
    
    BEGIN
    
        g_error := 'INI';
    
        -- Delete records to be recreated
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            g_error := 'DELETE MONITORIZATIONS EA PAT:' || i_patient || '/EPIS:' || i_episode;
            DELETE FROM monitorizations_ea;
        
            COMMIT;
        
        END IF;
    
        -- Open monitorizations record
        g_error := 'OPEN RECORD';
        FOR rec IN (SELECT m.id_monitorization,
                           mvs.id_monitorization_vs,
                           --mvp.id_monitorization_vs_plan,
                           mvs.id_vital_sign,
                           m.flg_status,
                           mvs.flg_status flg_status_det,
                           -- mvp.flg_status flg_status_plan,
                           m.flg_time,
                           m.dt_monitorization_tstz dt_monitorization,
                           --mvp.dt_plan_tstz dt_plan,
                           m.interval,
                           m.id_episode_origin,
                           m.dt_begin_tstz     dt_begin,
                           m.dt_end_tstz       dt_end,
                           --'CALCULADO' num_monit,
                           e.id_visit,
                           -- 'CALCULADO' status_str,
                           -- 'CALCULADO' status_msg,
                           -- 'CALCULADO' status_icon,
                           -- 'CALCULADO' status_flg,
                           decode(coalesce(mvs.notes_cancel, m.notes_cancel, m.notes), NULL, get_no(), get_yes()) flg_notes,
                           m.id_episode,
                           m.id_prev_episode,
                           e.id_patient,
                           m.id_professional,
                           mvs.dt_order
                      FROM monitorization m
                      JOIN monitorization_vs mvs
                        ON mvs.id_monitorization = m.id_monitorization
                      JOIN episode e
                        ON e.id_episode = m.id_episode
                     WHERE m.flg_status != pk_alert_constant.g_monitor_vs_draft
                       AND mvs.flg_status != pk_alert_constant.g_monitor_vs_draft
                       AND EXISTS (SELECT 1
                              FROM monitorization_vs_plan mvp
                             WHERE mvp.id_monitorization_vs = mvs.id_monitorization_vs))
        LOOP
        
            -- Get details
            g_error := 'GET DETAILS';
            BEGIN
                SELECT id_monitorization_vs_plan, dt_plan_tstz, flg_status
                  INTO l_id_monitorization_vs_plan, l_dt_plan_tstz, l_flg_status_plan
                  FROM (SELECT mvp.id_monitorization_vs_plan, mvp.dt_plan_tstz, mvp.flg_status
                          FROM monitorization_vs_plan mvp
                         WHERE mvp.id_monitorization_vs = rec.id_monitorization_vs
                           AND mvp.dt_plan_tstz =
                               (SELECT MAX(mvp1.dt_plan_tstz)
                                  FROM monitorization_vs_plan mvp1
                                 WHERE mvp1.id_monitorization_vs = rec.id_monitorization_vs)
                         ORDER BY mvp.id_monitorization_vs_plan DESC)
                 WHERE rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    dbms_output.put_line(rec.id_monitorization_vs || '-' || SQLERRM);
                    NULL;
            END;
        
            g_error := 'GET_LOGIC_STATUS';
        
            BEGIN
                --Obtains status info
                pk_ea_logic_monitorizations.get_monitorizations_status(i_prof            => l_prof,
                                                                       i_episode_origin  => rec.id_episode_origin,
                                                                       i_flg_time        => rec.flg_time,
                                                                       i_dt_begin        => rec.dt_begin,
                                                                       i_flg_status_det  => rec.flg_status_det,
                                                                       i_flg_status_plan => l_flg_status_plan,
                                                                       i_dt_plan         => l_dt_plan_tstz,
                                                                       o_status_str      => l_status_str,
                                                                       o_status_msg      => l_status_msg,
                                                                       o_status_icon     => l_status_icon,
                                                                       o_status_flg      => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            -- Count monitorizations
            g_error := 'COUNT MONIT';
            BEGIN
                SELECT COUNT(1)
                  INTO l_monit_count
                  FROM monitorization m
                 WHERE m.id_episode = rec.id_episode
                   AND m.flg_status != pk_alert_constant.g_monitor_vs_draft;
            EXCEPTION
                WHEN no_data_found THEN
                    l_monit_count := 0;
            END;
        
            -- If we are in validate mode fill temportary table
            IF i_validate_table
            THEN
            
                g_error := 'INSERT TEMPORARY TABLE:' || rec.id_monitorization_vs;
                INSERT INTO monitorizations_ea_tmp
                    (id_monitorization,
                     id_monitorization_vs,
                     id_monitorization_vs_plan,
                     id_vital_sign,
                     flg_status,
                     flg_status_det,
                     flg_status_plan,
                     flg_time,
                     dt_monitorization,
                     dt_plan,
                     INTERVAL,
                     id_episode_origin,
                     dt_begin,
                     dt_end,
                     num_monit,
                     id_visit,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_notes,
                     id_episode,
                     id_prev_episode,
                     id_patient,
                     id_professional,
                     dt_order)
                VALUES
                    (rec.id_monitorization,
                     rec.id_monitorization_vs,
                     l_id_monitorization_vs_plan,
                     rec.id_vital_sign,
                     rec.flg_status,
                     rec.flg_status_det,
                     l_flg_status_plan,
                     rec.flg_time,
                     rec.dt_monitorization,
                     l_dt_plan_tstz,
                     rec.interval,
                     rec.id_episode_origin,
                     rec.dt_begin,
                     rec.dt_end,
                     l_monit_count,
                     rec.id_visit,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.flg_notes,
                     rec.id_episode,
                     rec.id_prev_episode,
                     rec.id_patient,
                     rec.id_professional,
                     rec.dt_order);
            
            END IF;
        
            -- If we are in recreate mode fill easy access table
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                g_error := 'INSERT TABLE:' || rec.id_monitorization_vs;
                INSERT INTO monitorizations_ea
                    (id_monitorization,
                     id_monitorization_vs,
                     id_monitorization_vs_plan,
                     id_vital_sign,
                     flg_status,
                     flg_status_det,
                     flg_status_plan,
                     flg_time,
                     dt_monitorization,
                     dt_plan,
                     INTERVAL,
                     id_episode_origin,
                     dt_begin,
                     dt_end,
                     num_monit,
                     id_visit,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_notes,
                     id_episode,
                     id_prev_episode,
                     id_patient,
                     id_professional,
                     dt_dg_last_update,
                     dt_order)
                VALUES
                    (rec.id_monitorization,
                     rec.id_monitorization_vs,
                     l_id_monitorization_vs_plan,
                     rec.id_vital_sign,
                     rec.flg_status,
                     rec.flg_status_det,
                     l_flg_status_plan,
                     rec.flg_time,
                     rec.dt_monitorization,
                     l_dt_plan_tstz,
                     rec.interval,
                     rec.id_episode_origin,
                     rec.dt_begin,
                     rec.dt_end,
                     l_monit_count,
                     rec.id_visit,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.flg_notes,
                     rec.id_episode,
                     rec.id_prev_episode,
                     rec.id_patient,
                     rec.id_professional,
                     l_current_timestamp,
                     rec.dt_order);
            
            END IF;
        
            -- Commit
            IF MOD(l_count, i_commit_step) = 0
            THEN
                COMMIT;
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        g_error := 'OUT OF LOOP';
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            g_error := 'COMPARE VALUES';
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_monitorization_vs id_mon_tmp
                           FROM monitorizations_ea a
                           JOIN monitorizations_ea_tmp b
                             ON a.id_monitorization_vs = b.id_monitorization_vs
                          WHERE ((a.id_monitorization <> b.id_monitorization OR
                                (a.id_monitorization IS NULL AND b.id_monitorization IS NOT NULL) OR
                                (a.id_monitorization IS NOT NULL AND b.id_monitorization IS NULL)) OR
                                (a.id_monitorization_vs <> b.id_monitorization_vs OR
                                (a.id_monitorization_vs IS NULL AND b.id_monitorization_vs IS NOT NULL) OR
                                (a.id_monitorization_vs IS NOT NULL AND b.id_monitorization_vs IS NULL)) OR
                                (a.id_monitorization_vs_plan <> b.id_monitorization_vs_plan OR
                                (a.id_monitorization_vs_plan IS NULL AND b.id_monitorization_vs_plan IS NOT NULL) OR
                                (a.id_monitorization_vs_plan IS NOT NULL AND b.id_monitorization_vs_plan IS NULL)) OR
                                (a.id_vital_sign <> b.id_vital_sign OR
                                (a.id_vital_sign IS NULL AND b.id_vital_sign IS NOT NULL) OR
                                (a.id_vital_sign IS NOT NULL AND b.id_vital_sign IS NULL)) OR
                                (a.flg_status <> b.flg_status OR (a.flg_status IS NULL AND b.flg_status IS NOT NULL) OR
                                (a.flg_status IS NOT NULL AND b.flg_status IS NULL)) OR
                                (a.flg_status_det <> b.flg_status_det OR
                                (a.flg_status_det IS NULL AND b.flg_status_det IS NOT NULL) OR
                                (a.flg_status_det IS NOT NULL AND b.flg_status_det IS NULL)) OR
                                (a.flg_status_plan <> b.flg_status_plan OR
                                (a.flg_status_plan IS NULL AND b.flg_status_plan IS NOT NULL) OR
                                (a.flg_status_plan IS NOT NULL AND b.flg_status_plan IS NULL)) OR
                                (a.flg_time <> b.flg_time OR (a.flg_time IS NULL AND b.flg_time IS NOT NULL) OR
                                (a.flg_time IS NOT NULL AND b.flg_time IS NULL)) OR
                                (a.dt_monitorization <> b.dt_monitorization OR
                                (a.dt_monitorization IS NULL AND b.dt_monitorization IS NOT NULL) OR
                                (a.dt_monitorization IS NOT NULL AND b.dt_monitorization IS NULL)) OR
                                (a.dt_plan <> b.dt_plan OR (a.dt_plan IS NULL AND b.dt_plan IS NOT NULL) OR
                                (a.dt_plan IS NOT NULL AND b.dt_plan IS NULL)) OR
                                (a.interval <> b.interval OR (a.interval IS NULL AND b.interval IS NOT NULL) OR
                                (a.interval IS NOT NULL AND b.interval IS NULL)) OR
                                (a.id_episode_origin <> b.id_episode_origin OR
                                (a.id_episode_origin IS NULL AND b.id_episode_origin IS NOT NULL) OR
                                (a.id_episode_origin IS NOT NULL AND b.id_episode_origin IS NULL)) OR
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                (a.num_monit <> b.num_monit OR (a.num_monit IS NULL AND b.num_monit IS NOT NULL) OR
                                (a.num_monit IS NOT NULL AND b.num_monit IS NULL)) OR
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                (a.flg_notes <> b.flg_notes OR (a.flg_notes IS NULL AND b.flg_notes IS NOT NULL) OR
                                (a.flg_notes IS NOT NULL AND b.flg_notes IS NULL)) OR
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                (a.id_prev_episode <> b.id_prev_episode OR
                                (a.id_prev_episode IS NULL AND b.id_prev_episode IS NOT NULL) OR
                                (a.id_prev_episode IS NOT NULL AND b.id_prev_episode IS NULL)) OR
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                (a.id_professional <> b.id_professional OR
                                (a.id_professional IS NULL AND b.id_professional IS NOT NULL) OR
                                (a.id_professional IS NOT NULL AND b.id_professional IS NULL))))
            LOOP
                l_validation_type := 2;
            
                g_error := 'INVALID RECS:' || l_validation_type;
                IF NOT ins_invalid_record(i_ea_table_name       => 'MONITORIZATIONS_EA',
                                          i_id_pk_1_value       => rec1.id_mon_tmp,
                                          i_id_pk_1_col_name    => 'ID_MONITORIZATION_VS',
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT mon_ea_t.id_monitorization_vs id_mon_tmp
                           FROM monitorizations_ea_tmp mon_ea_t
                          WHERE mon_ea_t.id_monitorization_vs NOT IN
                                (SELECT mon_ea.id_monitorization_vs
                                   FROM monitorizations_ea mon_ea))
            LOOP
            
                l_validation_type := 1;
            
                g_error := 'INVALID RECS:' || l_validation_type;
            
                IF NOT ins_invalid_record(i_ea_table_name       => 'MONITORIZATIONS_EA',
                                          i_id_pk_1_value       => rec2.id_mon_tmp,
                                          i_id_pk_1_col_name    => 'ID_MONITORIZATION_VS',
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            g_error := 'MERGE RECS';
            MERGE INTO monitorizations_ea mon_ea
            USING (SELECT *
                     FROM monitorizations_ea_tmp mon_ea_tmp
                    WHERE mon_ea_tmp.id_monitorization_vs IN
                          (SELECT dgir.id_pk_1_value
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.ea_table_name = 'MONITORIZATIONS_EA'
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (mon_ea.id_monitorization_vs = t.id_monitorization_vs)
            WHEN MATCHED THEN
                UPDATE
                   SET mon_ea.id_monitorization         = t.id_monitorization,
                       mon_ea.id_monitorization_vs_plan = t.id_monitorization_vs_plan,
                       mon_ea.id_vital_sign             = t.id_vital_sign,
                       mon_ea.flg_status                = t.flg_status,
                       mon_ea.flg_status_det            = t.flg_status_det,
                       mon_ea.flg_status_plan           = t.flg_status_plan,
                       mon_ea.flg_time                  = t.flg_time,
                       mon_ea.dt_monitorization         = t.dt_monitorization,
                       mon_ea.dt_plan                   = t.dt_plan,
                       mon_ea.interval                  = t.interval,
                       mon_ea.id_episode_origin         = t.id_episode_origin,
                       mon_ea.dt_begin                  = t.dt_begin,
                       mon_ea.dt_end                    = t.dt_end,
                       mon_ea.num_monit                 = t.num_monit,
                       mon_ea.id_visit                  = t.id_visit,
                       mon_ea.status_str                = t.status_str,
                       mon_ea.status_msg                = t.status_msg,
                       mon_ea.status_icon               = t.status_icon,
                       mon_ea.status_flg                = t.status_flg,
                       mon_ea.flg_notes                 = t.flg_notes,
                       mon_ea.id_episode                = t.id_episode,
                       mon_ea.id_prev_episode           = t.id_prev_episode,
                       mon_ea.id_patient                = t.id_patient,
                       mon_ea.id_professional           = t.id_professional,
                       mon_ea.dt_dg_last_update         = l_current_timestamp,
                       mon_ea.dt_order                  = t.dt_order
                 WHERE mon_ea.id_monitorization_vs = t.id_monitorization_vs
            WHEN NOT MATCHED THEN
                INSERT
                    (id_monitorization,
                     id_monitorization_vs,
                     id_monitorization_vs_plan,
                     id_vital_sign,
                     flg_status,
                     flg_status_det,
                     flg_status_plan,
                     flg_time,
                     dt_monitorization,
                     dt_plan,
                     INTERVAL,
                     id_episode_origin,
                     dt_begin,
                     dt_end,
                     num_monit,
                     id_visit,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     flg_notes,
                     id_episode,
                     id_prev_episode,
                     id_patient,
                     id_professional,
                     dt_dg_last_update)
                VALUES
                    (t.id_monitorization,
                     t.id_monitorization_vs,
                     t.id_monitorization_vs_plan,
                     t.id_vital_sign,
                     t.flg_status,
                     t.flg_status_det,
                     t.flg_status_plan,
                     t.flg_time,
                     t.dt_monitorization,
                     t.dt_plan,
                     t.interval,
                     t.id_episode_origin,
                     t.dt_begin,
                     t.dt_end,
                     t.num_monit,
                     t.id_visit,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.flg_notes,
                     t.id_episode,
                     t.id_prev_episode,
                     t.id_patient,
                     t.id_professional,
                     l_current_timestamp);
        
            COMMIT;
        END IF;
    
        g_error := 'DELETE TEMPORARY TABLE';
    
        --delete records from temporary table
        DELETE FROM monitorizations_ea_tmp;
        COMMIT;
    
        g_error := 'DELETE OLD INVALID RECS';
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'MONITORIZATIONS_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_monitorizations_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_monitorizations_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM monitorizations_ea_tmp;
            COMMIT;
        
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        WHEN e_bad_data THEN
            --delete records from temporary table
            DELETE FROM monitorizations_ea_tmp;
            COMMIT;
        
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM monitorizations_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.raise_error(error_code_in => '-20001',
                                            text_in       => 'External error. Check table alertlog.tlog for error details.');
        
    END admin_50_monitorizations_ea;

    /**
    * Data migration for vital signs easy access tables
    *
    * @author  Paulo Fonseca
    * @version 2.5.1
    * @since   10/12/2010
    */

    PROCEDURE admin_50_vs_ea_tbls IS
        c_function_name CONSTANT VARCHAR2(32 CHAR) := 'ADMIN_50_VS_EA_TBLS';
    
        SUBTYPE t_stmt IS VARCHAR2(32000 CHAR);
        stmt t_stmt;
    
        PROCEDURE delete_tmp_tbl IS
            stmt t_stmt;
        BEGIN
            -- Delete temporary table content
            stmt := 'DELETE FROM vs_ea_tmp';
            EXECUTE IMMEDIATE stmt;
        END delete_tmp_tbl;
    
        PROCEDURE populate_tmp_tbl IS
        
            PROCEDURE insert_tmp_glasgow IS
                stmt t_stmt;
            
            BEGIN
                -- Insert the glasgow total values in the temporary table
                stmt := 'INSERT /*+append*/' || --
                        '  INTO vs_ea_tmp' || --
                        '    SELECT tg.id_vital_sign_read,' || --
                        '           tg.id_vital_sign,' || --
                        '           tg.value,' || --
                        '           :1 AS id_unit_measure,' || --
                        '           NULL AS id_vital_sign_scales,' || --
                        '           tg.id_patient,' || --
                        '           tg.id_visit,' || --
                        '           tg.id_episode,' || --
                        '           tg.id_institution_read,' || --
                        '           tg.dt_vital_sign_read_tstz,' || --
                        '           tg.id_software_read' || --
                        '      FROM (SELECT vsr.id_vital_sign_read,' || --
                        '                   vrel.id_vital_sign_parent AS id_vital_sign,' || --
                        '                   rank() over(PARTITION BY vsr.dt_vital_sign_read_tstz ORDER BY vsr.id_vital_sign_read ASC) AS rank,' || --
                        '                   SUM(vsd.value) over(PARTITION BY vsr.dt_vital_sign_read_tstz) AS VALUE,' || --
                        '                   vsr.id_patient,' || --
                        '                   e.id_visit,' || --
                        '                   vsr.id_episode,' || --
                        '                   vsr.id_institution_read,' || --
                        '                   vsr.dt_vital_sign_read_tstz,' || --
                        '                   vsr.id_software_read' || --
                        '              FROM vital_sign_read vsr' || --
                        '             INNER JOIN vital_sign_relation vrel ON vsr.id_vital_sign = vrel.id_vital_sign_detail' || --
                        '             INNER JOIN vital_sign_desc vsd ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc' || --
                        '              LEFT OUTER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '             WHERE vsr.flg_state = :2' || --
                        '               AND vrel.relation_domain = :3' || --
                        '               AND (vsr.id_episode IS NULL OR e.flg_status != :4)' || --
                        '               AND vrel.flg_available = :5) tg' || --
                        '     WHERE tg.rank = 1';
            
                EXECUTE IMMEDIATE stmt
                    USING --
                pk_vital_sign.c_without_um, --
                pk_alert_constant.g_active, --
                pk_alert_constant.g_vs_rel_sum, --
                pk_alert_constant.g_cancelled, pk_alert_constant.g_yes;
            
                COMMIT;
            
            END insert_tmp_glasgow;
        
            PROCEDURE insert_tmp_bp IS
                stmt t_stmt;
            
            BEGIN
                -- Insert the blood pressures values in the temporary table
                stmt := 'INSERT /*+append*/' || --
                        '  INTO vs_ea_tmp' || --
                        '    SELECT bp.id_vital_sign_read,' || --
                        '           bp.id_vital_sign,' || --
                        '           NULL AS VALUE,' || --
                        '           nvl(bp.id_unit_measure, :1) AS id_unit_measure,' || --
                        '           NULL AS id_vital_sign_scales,' || --
                        '           bp.id_patient,' || --
                        '           bp.id_visit,' || --
                        '           bp.id_episode,' || --
                        '           bp.id_institution_read,' || --
                        '           bp.dt_vital_sign_read_tstz,' || --
                        '           bp.id_software_read' || --
                        '      FROM (SELECT vsr.id_vital_sign_read,' || --
                        '                   vrel.id_vital_sign_parent AS id_vital_sign,' || --
                        '                   vsr.id_unit_measure,' || --
                        '                   rank() over(PARTITION BY vsr.dt_vital_sign_read_tstz ORDER BY vsr.id_vital_sign_read ASC) AS rank,' || --
                        '                   vsr.id_patient,' || --
                        '                   e.id_visit,' || --
                        '                   vsr.id_episode,' || --
                        '                   vsr.id_institution_read,' || --
                        '                   vsr.dt_vital_sign_read_tstz,' || --
                        '                   vsr.id_software_read' || --
                        '              FROM vital_sign_read vsr' || --
                        '             INNER JOIN vital_sign_relation vrel ON vsr.id_vital_sign = vrel.id_vital_sign_detail' || --
                        '              LEFT OUTER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '             WHERE vsr.flg_state = :2' || --
                        '               AND vrel.relation_domain = :3' || --
                        '               AND (vsr.id_episode IS NULL OR e.flg_status != :4)' || --
                        '               AND vrel.flg_available = :5) bp' || --
                        '     WHERE bp.rank = 1';
            
                EXECUTE IMMEDIATE stmt
                    USING --
                pk_vital_sign.c_without_um, --
                pk_alert_constant.g_active, --
                pk_alert_constant.g_vs_rel_conc, --
                pk_alert_constant.g_cancelled, pk_alert_constant.g_yes;
            
                COMMIT;
            
            END insert_tmp_bp;
        
            PROCEDURE insert_tmp_scales IS
                stmt t_stmt;
            
            BEGIN
                -- Insert the vital sign scales values in the temporary table
                stmt := 'INSERT /*+append*/' || --
                        '  INTO vs_ea_tmp' || --
                        '    SELECT vsr.id_vital_sign_read,' || --
                        '           vsr.id_vital_sign,' || --
                        '           vsse.value AS VALUE,' || --
                        '           nvl(vsse.id_unit_measure, :1) AS id_unit_measure,' || --
                        '           vss.id_vital_sign_scales,' || --
                        '           vsr.id_patient,' || --
                        '           e.id_visit,' || --
                        '           vsr.id_episode,' || --
                        '           vsr.id_institution_read,' || --
                        '           vsr.dt_vital_sign_read_tstz,' || --
                        '           vsr.id_software_read' || --
                        '      FROM vital_sign_read vsr' || --
                        '     INNER JOIN vital_sign_scales vss ON vsr.id_vital_sign = vss.id_vital_sign' || --
                        '     INNER JOIN vital_sign_scales_element vsse ON vsr.id_vs_scales_element = vsse.id_vs_scales_element' || --
                        '                                              AND vss.id_vital_sign_scales = vsse.id_vital_sign_scales' || --
                        '      LEFT OUTER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '     WHERE vsr.flg_state = :2' || --
                        '       AND (vsr.id_episode IS NULL OR e.flg_status != :3)';
            
                EXECUTE IMMEDIATE stmt
                    USING --
                pk_vital_sign.c_without_um, --
                pk_alert_constant.g_active, --
                pk_alert_constant.g_cancelled;
            
                COMMIT;
            
            END insert_tmp_scales;
        
            PROCEDURE insert_tmp_mc IS
                stmt t_stmt;
            
            BEGIN
                -- Insert the vital sign multichoices values in the temporary table
                stmt := 'INSERT /*+append*/' || --
                        '  INTO vs_ea_tmp' || --
                        '    SELECT vsr.id_vital_sign_read,' || --
                        '           vsr.id_vital_sign,' || --
                        '           vsd.order_val AS VALUE,' || --
                        '           :1 AS id_unit_measure,' || --
                        '           NULL AS id_vital_sign_scales,' || --
                        '           vsr.id_patient,' || --
                        '           e.id_visit,' || --
                        '           vsr.id_episode,' || --
                        '           vsr.id_institution_read,' || --
                        '           vsr.dt_vital_sign_read_tstz,' || --
                        '           vsr.id_software_read' || --
                        '      FROM vital_sign_read vsr' || --
                        '     INNER JOIN vital_sign_desc vsd ON vsr.id_vital_sign_desc = vsd.id_vital_sign_desc' || --
                        '                                   AND vsr.id_vital_sign = vsd.id_vital_sign' || --
                        '      LEFT OUTER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '     WHERE vsr.flg_state = :2' || --
                        '       AND (vsr.id_episode IS NULL OR e.flg_status != :3)' || --
                        '       AND EXISTS (SELECT 1' || --
                        '              FROM vital_sign vs' || --
                        '             WHERE vsr.id_vital_sign = vs.id_vital_sign' || --
                        '               AND vs.flg_fill_type = :4)' || --
                        '       AND NOT EXISTS (SELECT 1' || --
                        '              FROM vital_sign_relation vrel' || --
                        '             WHERE vsr.id_vital_sign = vrel.id_vital_sign_detail' || --
                        '               AND vrel.relation_domain = :5' || --
                        '               AND vrel.flg_available = :6)';
            
                EXECUTE IMMEDIATE stmt
                    USING --
                pk_vital_sign.c_without_um, --
                pk_alert_constant.g_active, --
                pk_alert_constant.g_cancelled, --
                pk_alert_constant.g_vs_ft_multichoice, --
                pk_alert_constant.g_vs_rel_sum, pk_alert_constant.g_yes;
            
                COMMIT;
            
            END insert_tmp_mc;
        
            PROCEDURE insert_tmp_numeric IS
                stmt t_stmt;
            
            BEGIN
                -- Insert the vital sign numeric values in the temporary table
                stmt := 'INSERT /*+append*/' || --
                        '  INTO vs_ea_tmp' || --
                        '    SELECT vsr.id_vital_sign_read,' || --
                        '           vsr.id_vital_sign,' || --
                        '           vsr.value,' || --
                        '           nvl(vsr.id_unit_measure, :1) AS id_unit_measure,' || --
                        '           NULL AS id_vital_sign_scales,' || --
                        '           vsr.id_patient,' || --
                        '           e.id_visit,' || --
                        '           vsr.id_episode,' || --
                        '           vsr.id_institution_read,' || --
                        '           vsr.dt_vital_sign_read_tstz,' || --
                        '           vsr.id_software_read' || --
                        '      FROM vital_sign_read vsr' || --
                        '      LEFT OUTER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '     WHERE vsr.flg_state = :2' || --
                        '       AND (vsr.id_episode IS NULL OR e.flg_status != :3)' || --
                        '       AND vsr.id_vs_scales_element IS NULL' || --
                        '       AND vsr.id_vital_sign_desc IS NULL' || --
                        '       AND EXISTS (SELECT 1' || --
                        '              FROM vital_sign vs' || --
                        '             WHERE vsr.id_vital_sign = vs.id_vital_sign' || --
                        '               AND vs.flg_fill_type = :4)' || --
                        '       AND NOT EXISTS (SELECT 1' || --
                        '              FROM vital_sign_relation vrel' || --
                        '             WHERE vsr.id_vital_sign = vrel.id_vital_sign_detail' || --
                        '               AND vrel.relation_domain IN (:5, :6)' || --
                        '               AND vrel.flg_available = :7)';
            
                EXECUTE IMMEDIATE stmt
                    USING --
                pk_vital_sign.c_without_um, --
                pk_alert_constant.g_active, --
                pk_alert_constant.g_cancelled, --
                pk_alert_constant.g_vs_ft_keypad, --
                pk_alert_constant.g_vs_rel_sum, --
                pk_alert_constant.g_vs_rel_conc, pk_alert_constant.g_yes;
            
                COMMIT;
            
            END insert_tmp_numeric;
        
        BEGIN
            -- Start populating temporary table
            insert_tmp_glasgow;
            insert_tmp_bp;
            insert_tmp_scales;
            insert_tmp_mc;
            insert_tmp_numeric;
        
        END populate_tmp_tbl;
    
        PROCEDURE convert_tmp_um IS
            TYPE t_vsea IS REF CURSOR;
            cur_vs_ea t_vsea;
        
            stmt_c t_stmt;
            stmt_u t_stmt;
        
            l_vital_sign       vital_sign_read.id_vital_sign%TYPE;
            l_unit_measure     vital_sign_read.id_unit_measure%TYPE;
            l_institution_read vital_sign_read.id_institution_read%TYPE;
            l_id_software_read vital_sign_read.id_software_read%TYPE;
            l_vs_um_inst       unit_measure.id_unit_measure%TYPE;
        
        BEGIN
            -- Start converting temporary table unit measures
            stmt_c := 'SELECT DISTINCT vtmp.id_vital_sign, vtmp.id_unit_measure, vtmp.id_institution_read , vtmp.ID_SOFTWARE_READ' || --
                      '  FROM vs_ea_tmp vtmp' || --
                      ' WHERE vtmp.value IS NOT NULL' || --
                      '   AND vtmp.id_unit_measure IS NOT NULL' || --
                      '   AND vtmp.id_vital_sign_scales IS NULL';
        
            OPEN cur_vs_ea FOR stmt_c;
        
            stmt_u := 'UPDATE vs_ea_tmp vtmp' || --
                      '   SET vtmp.value = pk_unit_measure.get_unit_mea_conversion(vtmp.value,' || --
                      '                                                            vtmp.id_unit_measure,' || --
                      '                                                            :1),' || --
                      '       vtmp.id_unit_measure = :2' || --
                      ' WHERE vtmp.id_vital_sign = :3' || --
                      '   AND vtmp.id_unit_measure = :4' || --
                      '   AND vtmp.id_institution_read = :5' || --
                      '   AND vtmp.id_software_read = :6';
        
            LOOP
                FETCH cur_vs_ea
                    INTO l_vital_sign, l_unit_measure, l_institution_read, l_id_software_read;
                EXIT WHEN cur_vs_ea%NOTFOUND;
            
                l_vs_um_inst := pk_vital_sign.get_vs_um_inst(i_vital_sign  => l_vital_sign,
                                                             i_institution => l_institution_read,
                                                             i_software    => l_id_software_read);
            
                IF l_unit_measure != l_vs_um_inst
                   AND pk_unit_measure.are_convertible(i_unit_meas => l_unit_measure, i_unit_meas_def => l_vs_um_inst)
                THEN
                    EXECUTE IMMEDIATE stmt_u
                        USING --
                    l_vs_um_inst, --
                    l_vs_um_inst, --
                    l_vital_sign, --
                    l_unit_measure, --
                    l_institution_read, --
                    l_id_software_read;
                
                    COMMIT;
                
                END IF;
            
            END LOOP;
        
            CLOSE cur_vs_ea;
        
        END convert_tmp_um;
    
        PROCEDURE turn_off_idxs IS
        
        BEGIN
            pk_frmw.disable_index(i_table_name => 'VS_PATIENT_EA', i_disable_fk => TRUE);
            pk_frmw.disable_index(i_table_name => 'VS_VISIT_EA', i_disable_fk => TRUE);
            pk_frmw.disable_index(i_table_name => 'VITAL_SIGNS_EA', i_disable_fk => TRUE);
        
        END turn_off_idxs;
    
        PROCEDURE turn_on_idxs IS
        
        BEGIN
            NULL;
        END turn_on_idxs;
    
        PROCEDURE clean_ea_tbls IS
            stmt t_stmt;
        
        BEGIN
            -- Truncating ea tables
            stmt := 'TRUNCATE TABLE vs_patient_ea';
            EXECUTE IMMEDIATE stmt;
            stmt := 'TRUNCATE TABLE vs_visit_ea';
            EXECUTE IMMEDIATE stmt;
            stmt := 'TRUNCATE TABLE vital_signs_ea';
            EXECUTE IMMEDIATE stmt;
        
            -- Truncating log tables
            stmt := 'TRUNCATE TABLE err$_vs_patient_ea';
            EXECUTE IMMEDIATE stmt;
            stmt := 'TRUNCATE TABLE err$_vs_visit_ea';
            EXECUTE IMMEDIATE stmt;
            stmt := 'TRUNCATE TABLE err$_vital_signs_ea';
            EXECUTE IMMEDIATE stmt;
        
        END clean_ea_tbls;
    
        PROCEDURE populate_ea_tbls IS
        
            PROCEDURE populate_vs_patient_ea_tbl IS
                stmt  t_stmt;
                n_err PLS_INTEGER;
            
            BEGIN
                -- Start populating vs_patient_ea table
                stmt := 'INSERT /*+ append */ INTO vs_patient_ea' || --
                        '    (id_patient,' || --
                        '     id_vital_sign,' || --
                        '     id_unit_measure,' || --
                        '     n_records,' || --
                        '     id_first_vsr,' || --
                        '     id_min_vsr,' || --
                        '     id_max_vsr,' || --
                        '     id_last_1_vsr,' || --
                        '     id_last_2_vsr,' || --
                        '     id_last_3_vsr)' || --
                        '    SELECT v2.id_patient,' || --
                        '           v2.id_vital_sign,' || --
                        '           v2.id_unit_measure,' || --
                        '           MAX(v2.n_records) AS n_records,' || --
                        '           MAX(v2.id_first_vsr) AS id_first_vsr,' || --
                        '           MAX(v2.id_min_vsr) AS id_min_vsr,' || --
                        '           MAX(v2.id_max_vsr) AS id_max_vsr,' || --
                        '           MAX(v2.id_last_1_vsr) AS id_last_1_vsr,' || --
                        '           MAX(v2.id_last_2_vsr) AS id_last_2_vsr,' || --
                        '           MAX(v2.id_last_3_vsr) AS id_last_3_vsr' || --
                        '      FROM (SELECT v.id_patient,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   v.cnt                  AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_patient,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           COUNT(1) over(PARTITION BY vt.id_patient, vt.id_vital_sign, vt.id_unit_measure) AS cnt' || --
                        '                      FROM vs_ea_tmp vt) v' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_patient,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   v.id_vital_sign_read   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_patient,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_patient, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.dt_vital_sign_read_tstz) AS rk' || --
                        '                      FROM vs_ea_tmp vt) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_patient,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   v.id_vital_sign_read   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_patient,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_patient, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.value ASC NULLS LAST, vt.dt_vital_sign_read_tstz ASC) AS rk' || --
                        '                      FROM vs_ea_tmp vt) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_patient,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   v.id_vital_sign_read   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_patient,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_patient, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.value DESC NULLS LAST, vt.dt_vital_sign_read_tstz ASC) AS rk' || --
                        '                      FROM vs_ea_tmp vt) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v1.id_patient,' || --
                        '                   v1.id_vital_sign,' || --
                        '                   v1.id_unit_measure,' || --
                        '                   NULL AS n_records,' || --
                        '                   NULL AS id_first_vsr,' || --
                        '                   NULL AS id_min_vsr,' || --
                        '                   NULL AS id_max_vsr,' || --
                        '                   MAX(v1.id_last_1_vsr) AS id_last_1_vsr,' || --
                        '                   MAX(v1.id_last_2_vsr) AS id_last_2_vsr,' || --
                        '                   MAX(v1.id_last_3_vsr) AS id_last_3_vsr' || --
                        '              FROM (SELECT v.id_patient,' || --
                        '                           v.id_vital_sign,' || --
                        '                           v.id_unit_measure,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 1 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_1_vsr,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 2 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_2_vsr,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 3 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_3_vsr' || --
                        '                      FROM (SELECT vt.id_vital_sign_read,' || --
                        '                                   vt.id_patient,' || --
                        '                                   vt.id_vital_sign,' || --
                        '                                   vt.id_unit_measure,' || --
                        '                                   row_number() over(PARTITION BY vt.id_patient, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.dt_vital_sign_read_tstz DESC) AS rk' || --
                        '                              FROM vs_ea_tmp vt) v' || --
                        '                     WHERE rk <= 3) v1' || --
                        '             GROUP BY id_patient, id_vital_sign, id_unit_measure) v2' || --
                        '     GROUP BY id_patient, id_vital_sign, id_unit_measure' || --
                        '   LOG ERRORS INTO err$_vs_patient_ea(to_char(SYSDATE)) reject LIMIT unlimited';
            
                EXECUTE IMMEDIATE stmt;
            
                COMMIT;
            
                SELECT COUNT(1)
                  INTO n_err
                  FROM err$_vs_patient_ea err;
            
                IF n_err > 0
                THEN
                    pk_alertlog.log_error(text            => 'VS_PATIENT_EA - Inconsistent Data',
                                          object_name     => g_package_name,
                                          sub_object_name => c_function_name);
                    raise_application_error(-20001, 'VS_PATIENT_EA - Inconsistent Data');
                END IF;
            
            END populate_vs_patient_ea_tbl;
        
            PROCEDURE populate_vs_visit_ea_tbl IS
                stmt  t_stmt;
                n_err PLS_INTEGER;
            
            BEGIN
                -- Start populating vs_visit_ea table
                stmt := 'INSERT /*+ append */ INTO vs_visit_ea' || --
                        '    (id_visit,' || --
                        '     id_vital_sign,' || --
                        '     id_unit_measure,' || --
                        '     n_records,' || --
                        '     id_first_vsr,' || --
                        '     id_min_vsr,' || --
                        '     id_max_vsr,' || --
                        '     id_last_1_vsr,' || --
                        '     id_last_2_vsr,' || --
                        '     id_last_3_vsr)' || --
                        '    SELECT v2.id_visit,' || --
                        '           v2.id_vital_sign,' || --
                        '           v2.id_unit_measure,' || --
                        '           MAX(v2.n_records) AS n_records,' || --
                        '           MAX(v2.id_first_vsr) AS id_first_vsr,' || --
                        '           MAX(v2.id_min_vsr) AS id_min_vsr,' || --
                        '           MAX(v2.id_max_vsr) AS id_max_vsr,' || --
                        '           MAX(v2.id_last_1_vsr) AS id_last_1_vsr,' || --
                        '           MAX(v2.id_last_2_vsr) AS id_last_2_vsr,' || --
                        '           MAX(v2.id_last_3_vsr) AS id_last_3_vsr' || --
                        '      FROM (SELECT v.id_visit,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   v.cnt                  AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_visit,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           COUNT(1) over(PARTITION BY vt.id_visit, vt.id_vital_sign, vt.id_unit_measure) AS cnt' || --
                        '                      FROM vs_ea_tmp vt' || --
                        '                     WHERE vt.id_visit IS NOT NULL) v' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_visit,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   v.id_vital_sign_read   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_visit,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_visit, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.dt_vital_sign_read_tstz) AS rk' || --
                        '                      FROM vs_ea_tmp vt' || --
                        '                     WHERE vt.id_visit IS NOT NULL) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_visit,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   v.id_vital_sign_read   AS id_min_vsr,' || --
                        '                   NULL                   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_visit,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_visit, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.value ASC NULLS LAST, vt.dt_vital_sign_read_tstz ASC) AS rk' || --
                        '                      FROM vs_ea_tmp vt' || --
                        '                     WHERE vt.id_visit IS NOT NULL) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v.id_visit,' || --
                        '                   v.id_vital_sign,' || --
                        '                   v.id_unit_measure,' || --
                        '                   NULL                   AS n_records,' || --
                        '                   NULL                   AS id_first_vsr,' || --
                        '                   NULL                   AS id_min_vsr,' || --
                        '                   v.id_vital_sign_read   AS id_max_vsr,' || --
                        '                   NULL                   AS id_last_1_vsr,' || --
                        '                   NULL                   AS id_last_2_vsr,' || --
                        '                   NULL                   AS id_last_3_vsr' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           vt.id_visit,' || --
                        '                           vt.id_vital_sign,' || --
                        '                           vt.id_unit_measure,' || --
                        '                           row_number() over(PARTITION BY vt.id_visit, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.value DESC NULLS LAST, vt.dt_vital_sign_read_tstz ASC) AS rk' || --
                        '                      FROM vs_ea_tmp vt' || --
                        '                     WHERE vt.id_visit IS NOT NULL) v' || --
                        '             WHERE rk = 1' || --
                        '            UNION ALL' || --
                        '            SELECT v1.id_visit,' || --
                        '                   v1.id_vital_sign,' || --
                        '                   v1.id_unit_measure,' || --
                        '                   NULL AS n_records,' || --
                        '                   NULL AS id_first_vsr,' || --
                        '                   NULL AS id_min_vsr,' || --
                        '                   NULL AS id_max_vsr,' || --
                        '                   MAX(v1.id_last_1_vsr) AS id_last_1_vsr,' || --
                        '                   MAX(v1.id_last_2_vsr) AS id_last_2_vsr,' || --
                        '                   MAX(v1.id_last_3_vsr) AS id_last_3_vsr' || --
                        '              FROM (SELECT v.id_visit,' || --
                        '                           v.id_vital_sign,' || --
                        '                           v.id_unit_measure,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 1 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_1_vsr,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 2 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_2_vsr,' || --
                        '                           CASE' || --
                        '                                WHEN rk = 3 THEN' || --
                        '                                 v.id_vital_sign_read' || --
                        '                                ELSE' || --
                        '                                 NULL' || --
                        '                            END AS id_last_3_vsr' || --
                        '                      FROM (SELECT vt.id_vital_sign_read,' || --
                        '                                   vt.id_visit,' || --
                        '                                   vt.id_vital_sign,' || --
                        '                                   vt.id_unit_measure,' || --
                        '                                   row_number() over(PARTITION BY vt.id_visit, vt.id_vital_sign, vt.id_unit_measure ORDER BY vt.dt_vital_sign_read_tstz DESC) AS rk' || --
                        '                              FROM vs_ea_tmp vt' || --
                        '                             WHERE vt.id_visit IS NOT NULL) v' || --
                        '                     WHERE rk <= 3) v1' || --
                        '             GROUP BY id_visit, id_vital_sign, id_unit_measure) v2' || --
                        '     GROUP BY id_visit, id_vital_sign, id_unit_measure' || --
                        '   LOG ERRORS INTO err$_vs_visit_ea(to_char(SYSDATE)) reject LIMIT unlimited';
            
                EXECUTE IMMEDIATE stmt;
            
                COMMIT;
            
                SELECT COUNT(1)
                  INTO n_err
                  FROM err$_vs_visit_ea err;
            
                IF n_err > 0
                THEN
                    pk_alertlog.log_error(text            => 'VS_VISIT_EA - Inconsistent Data',
                                          object_name     => g_package_name,
                                          sub_object_name => c_function_name);
                    raise_application_error(-20001, 'VS_VISIT_EA - Inconsistent Data');
                END IF;
            
            END populate_vs_visit_ea_tbl;
        
            PROCEDURE populate_vital_signs_ea_tbl IS
                stmt  t_stmt;
                n_err PLS_INTEGER;
            
            BEGIN
                -- Start populating vital_signs_ea table
                stmt := 'INSERT /*+ append */ INTO vital_signs_ea' || --
                        '    (id_vital_sign,' || --
                        '     id_vital_sign_read,' || --
                        '     id_vital_sign_desc,' || --
                        '     VALUE,' || --
                        '     id_unit_measure,' || --
                        '     dt_vital_sign_read,' || --
                        '     id_prof_read,' || --
                        '     id_prof_cancel,' || --
                        '     notes_cancel,' || --
                        '     flg_state,' || --
                        '     dt_cancel,' || --
                        '     flg_available,' || --
                        '     id_institution_read,' || --
                        '     flg_status_epis,' || --
                        '     id_visit,' || --
                        '     id_episode,' || --
                        '     id_patient,' || --
                        '     relation_domain,' || --
                        '     id_epis_triage,' || --
                        '     id_vs_scales_element)' || --
                        '    SELECT vsr.id_vital_sign,' || --
                        '           vsr.id_vital_sign_read,' || --
                        '           vsr.id_vital_sign_desc,' || --
                        '           vsr.value,' || --
                        '           vsr.id_unit_measure,' || --
                        '           vsr.dt_vital_sign_read_tstz AS dt_vital_sign_read,' || --
                        '           vsr.id_prof_read,' || --
                        '           vsr.id_prof_cancel,' || --
                        '           vsr.notes_cancel,' || --
                        '           vsr.flg_state,' || --
                        '           vsr.dt_cancel_tstz AS dt_cancel,' || --
                        '           (SELECT vs.flg_available' || --
                        '              FROM vital_sign vs' || --
                        '             WHERE vs.id_vital_sign = vsr.id_vital_sign) AS flg_available,' || --
                        '           vsr.id_institution_read,' || --
                        '           e.flg_status AS flg_status_epis,' || --
                        '           e.id_visit,' || --
                        '           vsr.id_episode,' || --
                        '           vsr.id_patient,' || --
                        '           (SELECT vrel.relation_domain' || --
                        '              FROM vital_sign_relation vrel' || --
                        '             WHERE vsr.id_vital_sign = vrel.id_vital_sign_detail' || --
                        '              AND vrel.relation_domain in (:1,:2)' || --
                        '              and vrel.flg_available = :3 ) AS relation_domain,' || --
                        '           vsr.id_epis_triage,' || --
                        '           vsr.id_vs_scales_element' || --
                        '      FROM (SELECT v.id_vital_sign_read' || --
                        '              FROM (SELECT vt.id_vital_sign_read,' || --
                        '                           row_number() over(PARTITION BY vt.id_episode, vt.id_vital_sign ORDER BY vt.dt_vital_sign_read_tstz DESC) AS rk' || --
                        '                      FROM vs_ea_tmp vt' || --
                        '                     WHERE vt.id_episode IS NOT NULL) v' || --
                        '             WHERE rk = 1) vl' || --
                        '     INNER JOIN vital_sign_read vsr ON vl.id_vital_sign_read = vsr.id_vital_sign_read' || --
                        '     INNER JOIN episode e ON vsr.id_episode = e.id_episode' || --
                        '   LOG ERRORS INTO err$_vital_signs_ea(to_char(SYSDATE)) reject LIMIT unlimited';
            
                EXECUTE IMMEDIATE stmt
                    USING pk_alert_constant.g_vs_rel_conc, pk_alert_constant.g_vs_rel_sum, pk_alert_constant.g_yes;
            
                COMMIT;
            
                SELECT COUNT(1)
                  INTO n_err
                  FROM err$_vital_signs_ea err;
            
                IF n_err > 0
                THEN
                    pk_alertlog.log_error(text            => 'VITAL_SIGNS_EA - Inconsistent Data',
                                          object_name     => g_package_name,
                                          sub_object_name => c_function_name);
                    raise_application_error(-20001, 'VITAL_SIGNS_EA - Inconsistent Data');
                END IF;
            
            END populate_vital_signs_ea_tbl;
        
        BEGIN
            -- Start populating ea tables
            --populate_vs_patient_ea_tbl;
            LOCK TABLE vs_patient_ea IN EXCLUSIVE MODE;
            --LOCK TABLE patient IN EXCLUSIVE MODE;
            pk_alertlog.log_debug('***LMAIA pk_frmw.enable_index: VS_PATIENT_EA');
            pk_frmw.enable_index(i_table_name => 'VS_PATIENT_EA', i_enable_fk => TRUE);
            COMMIT;
        
            populate_vs_visit_ea_tbl;
            LOCK TABLE vs_visit_ea IN EXCLUSIVE MODE;
            --LOCK TABLE patient IN EXCLUSIVE MODE;
            pk_alertlog.log_debug('***LMAIA pk_frmw.enable_index: VS_VISIT_EA');
            pk_frmw.enable_index(i_table_name => 'VS_VISIT_EA', i_enable_fk => TRUE);
            COMMIT;
        
            populate_vital_signs_ea_tbl;
            LOCK TABLE vital_signs_ea IN EXCLUSIVE MODE;
            --LOCK TABLE patient IN EXCLUSIVE MODE;
            pk_alertlog.log_debug('***LMAIA pk_frmw.enable_index: VITAL_SIGNS_EA');
            pk_frmw.enable_index(i_table_name => 'VITAL_SIGNS_EA', i_enable_fk => TRUE);
            COMMIT;
        
        END populate_ea_tbls;
    
    BEGIN
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 01: CALL delete_tmp_tbl ***');
        delete_tmp_tbl;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 02: CALL populate_tmp_tbl');
        populate_tmp_tbl;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 03: CALL convert_tmp_um');
        convert_tmp_um;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 04: CALL turn_off_idxs');
        turn_off_idxs;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 05: CALL clean_ea_tbls');
        clean_ea_tbls;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 06: CALL populate_ea_tbls');
        populate_ea_tbls;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 07: CALL delete_tmp_tbl');
        delete_tmp_tbl;
    
        pk_alertlog.log_debug('***admin_50_vs_ea_tbls 08: LEAVING ADMIN_50_VS_EA_TBLS ***');
    
    END admin_50_vs_ea_tbls;

    PROCEDURE admin_00_update_pat_in_episode IS
        -- MIGRATION SCRIPT FOR UPDATE_EPISODE
        l_err NUMBER(6);
    
    BEGIN
    
        g_error := 'Create missing epis_info';
        create_missing_epis_info();
    
        g_error := 'UPDATE EPISODE';
        UPDATE episode tbl
           SET (id_patient,
                id_dept,
                id_department,
                id_cs_requested,
                id_clinical_service,
                id_institution,
                id_department_requested,
                id_dept_requested,
                id_prev_epis_type) =
               (SELECT vis.id_patient id_patient,
                       nvl(dpt.id_dept, -1) id_dept,
                       nvl(dpt.id_department, -1) id_department,
                       nvl(dcs_sch.id_clinical_service, -1) id_cs_requested,
                       nvl(dcs.id_clinical_service, -1) id_clinical_service,
                       vis.id_institution id_institution,
                       nvl(dpt_sch.id_department, -1) id_department_requested,
                       nvl(dpt_sch.id_dept, -1) id_dept_requested,
                       prev_epi.id_epis_type id_prev_epis_type
                  FROM episode epi
                  JOIN visit vis
                    ON vis.id_visit = epi.id_visit
                  LEFT JOIN epis_info eio
                    ON epi.id_episode = eio.id_episode
                  LEFT JOIN dep_clin_serv dcs
                    ON dcs.id_dep_clin_serv = eio.id_dep_clin_serv
                  LEFT JOIN department dpt
                    ON dpt.id_department = dcs.id_department
                  LEFT JOIN episode prev_epi
                    ON prev_epi.id_episode = epi.id_prev_episode
                -- SCHEDULER
                  LEFT JOIN schedule sch
                    ON sch.id_schedule = eio.id_schedule
                  LEFT JOIN dep_clin_serv dcs_sch
                    ON dcs_sch.id_dep_clin_serv = sch.id_dcs_requested
                  LEFT JOIN department dpt_sch
                    ON dpt_sch.id_department = dcs_sch.id_department
                 WHERE epi.id_episode = tbl.id_episode) log errors INTO err$_episode(to_char(SYSDATE)) reject LIMIT unlimited;
    
        COMMIT;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_episode err;
    
        IF l_err > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_episode.');
    END admin_00_update_pat_in_episode;

    PROCEDURE admin_02_update_episode IS
    
        -- Migration script for update_episode
        -- create an exception handler for ORA-24381
        l_err_tables_names VARCHAR2(400 CHAR) := '';
        l_err              NUMBER(6);
    BEGIN
        -- Update only records that are NULL
        g_error := 'UPDATE CARE_PLAN';
        UPDATE care_plan cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_care_plan(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE CARE_PLAN_HIST';
        UPDATE care_plan_hist cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_care_plan_hist(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE CLIN_RECORD';
        UPDATE clin_record cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_clin_record(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE EVENT_MOST_FREQ';
        UPDATE event_most_freq cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_event_most_freq(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE P1_EXTERNAL_REQUEST';
        UPDATE p1_external_request cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_p1_external_request(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE P1_MATCH';
        UPDATE p1_match cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_p1_match(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_CHILD_FEED_DEV';
        UPDATE pat_child_feed_dev cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_child_feed_dev(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_CLI_ATTRIBUTES';
        UPDATE pat_cli_attributes cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_cli_attributes(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_DMGR_HIST';
        UPDATE pat_dmgr_hist cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_dmgr_hist(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_FAMILY_MEMBER';
        UPDATE pat_family_member cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_family_member(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_FAMILY_PROF';
        UPDATE pat_family_prof cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_family_prof(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_GRAFFAR_CRIT';
        UPDATE pat_graffar_crit cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_graffar_crit(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_HEALTH_PLAN';
        UPDATE pat_health_plan cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_health_plan(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_HISTORY';
        UPDATE pat_history cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_history(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_JOB';
        UPDATE pat_job cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_job(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_MEDICATION_DET';
        UPDATE pat_medication_det cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_medication_det(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_NECESSITY';
        UPDATE pat_necessity cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_necessity(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_NECESSITY_HIST';
        UPDATE pat_necessity_hist cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_necessity(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_SOC_ATTRIBUTES';
        UPDATE pat_soc_attributes cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_soc_attributes(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_VACC';
        UPDATE pat_vacc cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_vacc(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE PAT_VACCINE';
        UPDATE pat_vaccine cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_pat_vaccine(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE SR_SURGERY_RECORD';
        UPDATE sr_surgery_record cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_sr_surgery_record(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE UNIDOSE_CAR_PATIENT';
        UPDATE unidose_car_patient cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_unidose_car_patient(to_char(SYSDATE)) reject LIMIT unlimited;
    
        COMMIT;
    
        g_error := 'UPDATE UNIDOSE_CAR_PATIENT_HIST';
        UPDATE unidose_car_patient_hist cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_unidose_car_patient_hist(to_char(SYSDATE)) reject LIMIT
         unlimited;
        COMMIT;
    
        g_error := 'UPDATE VACCINE_DET';
        UPDATE vaccine_det cp
           SET cp.id_episode = g_default_episode
         WHERE cp.id_episode IS NULL log errors INTO err$_vaccine_det(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_care_plan err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_care_plan';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_care_plan_hist err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_care_plan_hist';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_clin_record err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_clin_record';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_event_most_freq err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_event_most_freq';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_p1_external_request err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_p1_external_request';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_p1_match err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_p1_match';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_child_feed_dev err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_child_feed_dev';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_cli_attributes err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_cli_attributes';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_dmgr_hist err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_dmgr_hist';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_family_member err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_family_member';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_family_prof err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_family_prof';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_graffar_crit err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_graffar_crit';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_health_plan err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_health_plan';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_history err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_history';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_job err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_job';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_medication_det err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_medication_det';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_necessity err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_necessity';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_soc_attributes err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_soc_attributes';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_vacc err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_vacc';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_pat_vaccine err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_pat_vaccine';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_sr_surgery_record err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_sr_surgery_record';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_unidose_car_patient err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_unidose_car_patient';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_unidose_car_patient_hist err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_unidose_car_patient_hist';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_vaccine_det err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_vaccine_det';
        END IF;
    
        IF l_err_tables_names IS NOT NULL
        THEN
            RAISE e_unspecified;
        END IF;
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table(s) ' || l_err_tables_names || '.');
    END admin_02_update_episode;

    PROCEDURE admin_03_update_patient IS
        l_err_tables_names VARCHAR2(400 CHAR) := '';
        l_err              NUMBER(6);
    BEGIN
    
        g_error := 'UPDATE discharge_notes';
        UPDATE discharge_notes tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_discharge_notes(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE epis_diagnosis';
        UPDATE epis_diagnosis tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_epis_diagnosis(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE epis_diagram';
        UPDATE epis_diagram tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_epis_diagram(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE epis_recomend';
        UPDATE epis_recomend tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_epis_recomend(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE monitorization';
        UPDATE monitorization tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_monitorization(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE interv_prescription';
        UPDATE interv_prescription tbl
           SET tbl.id_patient =
               (SELECT v.id_patient
                  FROM visit v
                  JOIN episode epis
                    ON epis.id_visit = v.id_visit
                 WHERE epis.id_episode = tbl.id_episode) log errors INTO err$_interv_prescription(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        g_error := 'UPDATE exam_req';
        UPDATE exam_req tbl
           SET tbl.id_patient = nvl((SELECT e.id_patient
                                      FROM episode e
                                     WHERE nvl(tbl.id_episode, tbl.id_episode_origin) = e.id_episode),
                                    (SELECT sg.id_patient
                                       FROM schedule_exam se, sch_group sg
                                      WHERE tbl.id_exam_req = se.id_exam_req
                                        AND se.id_schedule = sg.id_schedule
                                        AND rownum = 1)) log errors INTO err$_exam_req(to_char(SYSDATE)) reject LIMIT unlimited;
        COMMIT;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_discharge_notes err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_discharge_notes';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_epis_diagnosis err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_epis_diagnosis';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_epis_diagram err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_epis_diagram';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_epis_recomend err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_epis_recomend';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_monitorization err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_monitorization';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_interv_prescription err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_interv_prescription';
        END IF;
    
        SELECT COUNT(1)
          INTO l_err
          FROM err$_exam_req err;
    
        IF l_err > 0
        THEN
            l_err_tables_names := l_err_tables_names || '|err$_exam_req';
        END IF;
    
        IF l_err_tables_names IS NOT NULL
        THEN
            RAISE e_unspecified;
        END IF;
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table(s) ' || l_err_tables_names || '.');
        
    END admin_03_update_patient;

    PROCEDURE admin_50_update_opinion IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        v_flg_state              table_varchar := table_varchar();
        v_id                     table_varchar := table_varchar();
        v_status_str             table_varchar := table_varchar();
        v_status_msg             table_varchar := table_varchar();
        v_status_icon            table_varchar := table_varchar();
        v_status_flg             table_varchar := table_varchar();
    
        v_status_flg_ori  table_varchar := table_varchar();
        v_status_icon_ori table_varchar := table_varchar();
        v_status_msg_ori  table_varchar := table_varchar();
        v_status_str_ori  table_varchar := table_varchar();
    
        j PLS_INTEGER := 1;
    
        l_invalid_records BOOLEAN := FALSE;
    BEGIN
    
        SELECT o.flg_state AS flg_state, o.id_opinion, o.status_flg, o.status_icon, o.status_msg, o.status_str
          BULK COLLECT
          INTO v_flg_state, v_id, v_status_flg_ori, v_status_icon_ori, v_status_msg_ori, v_status_str_ori
          FROM opinion o
          JOIN episode e
            ON o.id_episode = e.id_episode
         ORDER BY o.id_opinion;
    
        FOR i IN 1 .. v_flg_state.count
        LOOP
        
            v_status_str.extend(1);
            v_status_msg.extend(1);
            v_status_icon.extend(1);
            v_status_flg.extend(1);
        
            pk_logic_opinion.get_opinion_status(i_prof        => NULL,
                                                i_flg_state   => v_flg_state(i),
                                                o_status_str  => v_status_str(j),
                                                o_status_msg  => v_status_msg(j),
                                                o_status_icon => v_status_icon(j),
                                                o_status_flg  => v_status_flg(j));
        
            IF ((i_validate_table) AND
               ((v_status_str_ori(j) <> v_status_str(j)) OR (v_status_msg_ori(j) <> v_status_msg(j)) OR
               (v_status_icon_ori(j) <> v_status_icon(j)) OR (v_status_flg_ori(j) <> v_status_flg(j))))
            THEN
            
                IF i_output_invalid_records
                THEN
                    IF NOT ins_invalid_record(i_ea_table_name       => 'OPINION',
                                              i_id_pk_1_value       => v_id(j),
                                              i_id_pk_1_col_name    => 'ID_OPINION',
                                              i_id_pk_2_value       => NULL,
                                              i_id_pk_2_col_name    => NULL,
                                              i_id_pk_3_value       => NULL,
                                              i_id_pk_3_col_name    => NULL,
                                              i_id_pk_4_value       => NULL,
                                              i_id_pk_4_col_name    => NULL,
                                              i_dt_validation       => g_sysdate_tstz,
                                              i_validation_type     => g_validation_type_2,
                                              i_in_patient          => i_patient,
                                              i_in_episode          => i_episode,
                                              i_in_schedule         => i_schedule,
                                              i_in_external_request => i_external_request,
                                              i_in_institution      => i_institution,
                                              i_in_start_dt         => i_start_dt,
                                              i_in_end_dt           => i_end_dt)
                    THEN
                        --Em caso de erro ao inserir registos inválidos, sai
                        RAISE e_internal;
                    END IF;
                    l_invalid_records := TRUE;
                
                END IF;
            
            END IF;
        
            j := j + 1;
        
        END LOOP;
    
        IF i_recreate_table
        THEN
        
            dbms_output.put_line('The table OPINION is being recreated...');
        
            FOR i IN 1 .. v_id.count
            LOOP
                UPDATE opinion o
                   SET o.status_flg  = v_status_flg(i),
                       o.status_icon = v_status_icon(i),
                       o.status_msg  = v_status_msg(i),
                       o.status_str  = v_status_str(i)
                 WHERE o.id_opinion = v_id(i);
            END LOOP;
        
            COMMIT;
        
            dbms_output.put_line('The table OPINION was recreated.');
        
        ELSIF (i_validate_table)
        THEN
        
            dbms_output.put_line('The table OPINION was validated.');
        
        END IF;
    
        IF l_invalid_records
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        
    END admin_50_update_opinion;

    PROCEDURE admin_50_update_consult_req IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
    
        v_id                  table_varchar := table_varchar();
        v_flg_status          table_varchar := table_varchar();
        v_status_str          table_varchar := table_varchar();
        v_status_msg          table_varchar := table_varchar();
        v_status_icon         table_varchar := table_varchar();
        v_status_flg          table_varchar := table_varchar();
        v_dt_consult_req_tstz table_varchar := table_varchar();
    
        v_status_flg_ori  table_varchar := table_varchar();
        v_status_icon_ori table_varchar := table_varchar();
        v_status_msg_ori  table_varchar := table_varchar();
        v_status_str_ori  table_varchar := table_varchar();
    
        j PLS_INTEGER := 1;
    
        l_invalid_records BOOLEAN := FALSE;
    BEGIN
    
        SELECT cr.flg_status          AS flg_status,
               cr.dt_consult_req_tstz AS dt_consult_req_tstz,
               cr.id_consult_req      AS id_consult_req,
               cr.status_flg,
               cr.status_icon,
               cr.status_msg,
               cr.status_str
          BULK COLLECT
          INTO v_flg_status,
               v_dt_consult_req_tstz,
               v_id,
               v_status_flg_ori,
               v_status_icon_ori,
               v_status_msg_ori,
               v_status_str_ori
          FROM consult_req cr;
    
        FOR i IN 1 .. v_flg_status.count
        LOOP
        
            v_status_str.extend(1);
            v_status_msg.extend(1);
            v_status_icon.extend(1);
            v_status_flg.extend(1);
        
            pk_logic_consult_req.get_consult_req_status(i_prof                => NULL,
                                                        i_flg_status          => v_flg_status(i),
                                                        i_dt_consult_req_tstz => v_dt_consult_req_tstz(i),
                                                        o_status_str          => v_status_str(j),
                                                        o_status_msg          => v_status_msg(j),
                                                        o_status_icon         => v_status_icon(j),
                                                        o_status_flg          => v_status_flg(j));
        
            IF ((i_validate_table) AND
               ((v_status_str_ori(j) <> v_status_str(j)) OR (v_status_msg_ori(j) <> v_status_msg(j)) OR
               (v_status_icon_ori(j) <> v_status_icon(j)) OR (v_status_flg_ori(j) <> v_status_flg(j))))
            THEN
            
                IF i_output_invalid_records
                THEN
                    IF NOT ins_invalid_record(i_ea_table_name       => 'CONSULT_REQ',
                                              i_id_pk_1_value       => v_id(j),
                                              i_id_pk_1_col_name    => 'ID_CONSULT_REQ',
                                              i_id_pk_2_value       => NULL,
                                              i_id_pk_2_col_name    => NULL,
                                              i_id_pk_3_value       => NULL,
                                              i_id_pk_3_col_name    => NULL,
                                              i_id_pk_4_value       => NULL,
                                              i_id_pk_4_col_name    => NULL,
                                              i_dt_validation       => g_sysdate_tstz,
                                              i_validation_type     => g_validation_type_2,
                                              i_in_patient          => i_patient,
                                              i_in_episode          => i_episode,
                                              i_in_schedule         => i_schedule,
                                              i_in_external_request => i_external_request,
                                              i_in_institution      => i_institution,
                                              i_in_start_dt         => i_start_dt,
                                              i_in_end_dt           => i_end_dt)
                    THEN
                        --Em caso de erro ao inserir registos inválidos, sai
                        RAISE e_internal;
                    END IF;
                
                    l_invalid_records := TRUE;
                END IF;
            
            END IF;
        
            j := j + 1;
        
        END LOOP;
    
        IF i_recreate_table
        THEN
        
            dbms_output.put_line('The table CONSULT_REQ is being recreated...');
        
            FOR i IN 1 .. v_id.count
            LOOP
                UPDATE consult_req cr
                   SET cr.status_flg  = v_status_flg(i),
                       cr.status_icon = v_status_icon(i),
                       cr.status_msg  = v_status_msg(i),
                       cr.status_str  = v_status_str(i)
                 WHERE cr.id_consult_req = v_id(i);
            END LOOP;
        
            COMMIT;
        
            dbms_output.put_line('The table CONSULT_REQ was recreated.');
        
        ELSIF (i_validate_table)
        THEN
        
            dbms_output.put_line('The table CONSULT_REQ was validated.');
        
        END IF;
    
        IF l_invalid_records
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
    END admin_50_update_consult_req;

    PROCEDURE admin_50_update_nurse_tea_req IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
    
        v_id            table_varchar := table_varchar();
        v_flg_status    table_varchar := table_varchar();
        v_flg_time      table_varchar := table_varchar();
        v_status_str    table_varchar := table_varchar();
        v_status_msg    table_varchar := table_varchar();
        v_status_icon   table_varchar := table_varchar();
        v_status_flg    table_varchar := table_varchar();
        v_dt_begin_tstz table_varchar := table_varchar();
    
        v_status_flg_ori  table_varchar := table_varchar();
        v_status_icon_ori table_varchar := table_varchar();
        v_status_msg_ori  table_varchar := table_varchar();
        v_status_str_ori  table_varchar := table_varchar();
    
        j PLS_INTEGER := 1;
    
        l_invalid_records BOOLEAN := FALSE;
    BEGIN
    
        SELECT ntr.flg_status       AS flg_status,
               ntr.dt_begin_tstz    AS dt_consult_req_tstz,
               ntr.id_nurse_tea_req AS id_consult_req,
               ntr.flg_time         AS flg_time,
               ntr.status_flg,
               ntr.status_icon,
               ntr.status_msg,
               ntr.status_str
          BULK COLLECT
          INTO v_flg_status,
               v_dt_begin_tstz,
               v_id,
               v_flg_time,
               v_status_flg_ori,
               v_status_icon_ori,
               v_status_msg_ori,
               v_status_str_ori
          FROM nurse_tea_req ntr
          JOIN episode e
            ON ntr.id_episode = e.id_episode;
    
        FOR i IN v_flg_status.first .. v_flg_status.last
        LOOP
        
            v_status_str.extend(1);
            v_status_msg.extend(1);
            v_status_icon.extend(1);
            v_status_flg.extend(1);
        
            pk_logic_nurse_tea_req.get_nurse_tea_req_status(i_prof          => NULL,
                                                            i_flg_time      => v_flg_time(i),
                                                            i_flg_status    => v_flg_status(i),
                                                            i_dt_begin_tstz => v_dt_begin_tstz(i),
                                                            o_status_str    => v_status_str(j),
                                                            o_status_msg    => v_status_msg(j),
                                                            o_status_icon   => v_status_icon(j),
                                                            o_status_flg    => v_status_flg(j));
        
            IF ((i_validate_table) AND
               ((v_status_str_ori(j) <> v_status_str(j)) OR (v_status_msg_ori(j) <> v_status_msg(j)) OR
               (v_status_icon_ori(j) <> v_status_icon(j)) OR (v_status_flg_ori(j) <> v_status_flg(j))))
            THEN
            
                IF i_output_invalid_records
                THEN
                    IF NOT ins_invalid_record(i_ea_table_name       => 'NURSE_TEA_REQ',
                                              i_id_pk_1_value       => v_id(j),
                                              i_id_pk_1_col_name    => 'ID_NURSE_TEA_REQ',
                                              i_id_pk_2_value       => NULL,
                                              i_id_pk_2_col_name    => NULL,
                                              i_id_pk_3_value       => NULL,
                                              i_id_pk_3_col_name    => NULL,
                                              i_id_pk_4_value       => NULL,
                                              i_id_pk_4_col_name    => NULL,
                                              i_dt_validation       => g_sysdate_tstz,
                                              i_validation_type     => g_validation_type_2,
                                              i_in_patient          => i_patient,
                                              i_in_episode          => i_episode,
                                              i_in_schedule         => i_schedule,
                                              i_in_external_request => i_external_request,
                                              i_in_institution      => i_institution,
                                              i_in_start_dt         => i_start_dt,
                                              i_in_end_dt           => i_end_dt)
                    THEN
                        --Em caso de erro ao inserir registos inválidos, sai
                        RAISE e_internal;
                    END IF;
                    l_invalid_records := TRUE;
                END IF;
            
            END IF;
        
            j := j + 1;
        
        END LOOP;
    
        IF i_recreate_table
        THEN
        
            dbms_output.put_line('The table NURSE_TEA_REQ is being recreated...');
        
            FOR i IN v_id.first .. v_id.last
            LOOP
                UPDATE nurse_tea_req ntr
                   SET ntr.status_flg  = v_status_flg(i),
                       ntr.status_icon = v_status_icon(i),
                       ntr.status_msg  = v_status_msg(i),
                       ntr.status_str  = v_status_str(i)
                 WHERE ntr.id_nurse_tea_req = v_id(i);
            END LOOP;
        
            COMMIT;
        
            dbms_output.put_line('The table NURSE_TEA_REQ was recreated.');
        
        ELSIF (i_validate_table)
        THEN
        
            dbms_output.put_line('The table NURSE_TEA_REQ was validated.');
        
        END IF;
    
        IF l_invalid_records
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
        
    END admin_50_update_nurse_tea_req;

    /********************************************************************************************
    * Delete Easy Access Tracking_Board_EA
    *
    * @param i_patient                Identificador de um paciente.
    * @param i_episode                Identificador de um episódio.
    * @param i_institution            Identificador de uma instituição.
    * @param i_start_dt               Data de início a considerar para a validação/(re)construção de registos
    * @param i_end_dt                 Data de fim a considerar para a validação/(re)construção de registos
    *
    * @author   Ariel Machado
    * @version  2.4.3d
    * @since    2008/10/20
    ********************************************************************************************/
    PROCEDURE delete_tracking_board_ea IS
    BEGIN
        DELETE FROM tracking_board_ea tbea;
    END delete_tracking_board_ea;

    /********************************************************************************************
    * Actualiza a Easy Access Tracking_Board_EA
    *
    * @param i_patient                Identificador de um paciente.
    * @param i_episode                Identificador de um episódio.
    * @value i_schedule               Identificador de um agendamento.
    * @param i_external_request       Identificador do P1.
    * @param i_institution            Identificador de uma instituição.
    * @param i_start_dt               Data de início a considerar para a validação/(re)construção de registos
    * @param i_end_dt                 Data de fim a considerar para a validação/(re)construção de registos
    * @param i_validate_table         Indicação da necessidade de validar os dados da tabela
    * @param i_output_invalid_records Indicação da necessidade de guardar informação dos registos inválidos na tabela de registos inválidos
    * @param i_recreate_table         Indicação da necessidade de refazer os dados na tabela de Easy Access/Awareness
    * @param i_commit_step            Número de registos entre commits intermédios
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Ariel Machado
    * @version  2.4.3d
    * @since    2008/10/20
    ********************************************************************************************/
    PROCEDURE admin_50_tracking_board_ea IS
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        function_error EXCEPTION;
        dml_errors     EXCEPTION;
        PRAGMA EXCEPTION_INIT(dml_errors, -24381);
    
        /* Active episode info */
        CURSOR c_current_epis IS
            SELECT epis.id_episode,
                   v.id_patient,
                   epis.id_epis_type,
                   nvl((SELECT e.id_triage_color
                         FROM (SELECT etr.id_triage_color, etr.id_episode
                                 FROM epis_triage etr
                                ORDER BY etr.dt_end_tstz DESC) e
                        WHERE e.id_episode = epis.id_episode
                          AND rownum < 2),
                       (SELECT tco.id_triage_color
                          FROM triage_color tco
                          JOIN triage_type tt
                            ON tco.id_triage_type = tt.id_triage_type
                         WHERE tt.id_triage_type =
                               pk_edis_triage.get_triage_type(NULL,
                                                              profissional(NULL, v.id_institution, NULL),
                                                              epis.id_episode)
                           AND tco.flg_type = pk_alert_constant.g_triage_color_flgtype_nocolor
                           AND rownum < 2)) id_triage_color,
                   epis.id_fast_track,
                   ei.id_room,
                   ei.id_bed,
                   epis.dt_begin_tstz,
                   diet.id_diet,
                   nvl2(diet.id_diet, 'DIET.CODE_DIET.' || diet.id_diet, diet.desc_diet) desc_diet,
                   ei.id_professional id_prof_resp,
                   ei.id_first_nurse_resp id_nurse_resp
              FROM episode epis
             INNER JOIN visit v
                ON epis.id_visit = v.id_visit
             INNER JOIN epis_info ei
                ON epis.id_episode = ei.id_episode
              LEFT JOIN (SELECT ed.id_episode, ed.id_diet, ed.desc_diet
                           FROM epis_diet ed
                          WHERE ed.flg_status = 'R') diet
                ON epis.id_episode = diet.id_episode
             WHERE epis.flg_status = pk_alert_constant.g_active
               AND epis.flg_ehr = 'N'
               AND epis.id_epis_type IN
                   (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient);
    
        /* Analysis */
        CURSOR c_current_analysis IS
            SELECT a.id_episode,
                   pk_ea_logic_tracking_board.count_not_nulls(table_varchar(a.lab_pend,
                                                                            a.lab_req,
                                                                            a.lab_harv,
                                                                            a.lab_transp,
                                                                            a.lab_fin,
                                                                            a.lab_result,
                                                                            a.lab_result_read,
                                                                            a.lab_ext)) lab_count,
                   a.lab_pend,
                   a.lab_req,
                   a.lab_harv,
                   a.lab_transp,
                   a.lab_fin,
                   a.lab_result,
                   a.lab_result_read,
                   a.lab_ext,
                   a.lab_wtg,
                   a.lab_cc,
                   a.lab_sos
              FROM episode epis
             INNER JOIN v_ea_logic_trk_board_analy a
                ON a.id_episode = epis.id_episode
             WHERE epis.flg_status = pk_alert_constant.g_active
               AND epis.flg_ehr = 'N'
               AND epis.id_epis_type IN
                   (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient);
    
        /* Exams */
        CURSOR c_current_exams IS
            SELECT ex.id_episode,
                   pk_ea_logic_tracking_board.count_not_nulls(table_varchar(ex.exam_pend,
                                                                            ex.exam_req,
                                                                            ex.exam_transp,
                                                                            ex.exam_exec,
                                                                            ex.exam_result,
                                                                            ex.exam_result_read,
                                                                            ex.exam_ext,
                                                                            ex.exam_perf)) exam_count,
                   ex.exam_pend,
                   ex.exam_req,
                   ex.exam_transp,
                   ex.exam_exec,
                   ex.exam_result,
                   ex.exam_result_read,
                   ex.exam_ext,
                   ex.exam_perf,
                   ex.exam_wtg,
                   ex.exam_sos
              FROM episode epis
             INNER JOIN v_ea_logic_trk_board_exam ex
                ON ex.id_episode = epis.id_episode
             WHERE epis.flg_status = pk_alert_constant.g_active
               AND epis.flg_ehr = 'N'
               AND epis.id_epis_type IN
                   (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient)
               AND ex.flg_type = pk_exam_constant.g_type_img;
    
        /* Other Exams */
        CURSOR c_current_oth_exams IS
            SELECT ex.id_episode,
                   pk_ea_logic_tracking_board.count_not_nulls(table_varchar(ex.exam_pend,
                                                                            ex.exam_req,
                                                                            ex.exam_transp,
                                                                            ex.exam_exec,
                                                                            ex.exam_result,
                                                                            ex.exam_result_read,
                                                                            ex.exam_ext,
                                                                            ex.exam_perf)) oth_exam_count,
                   ex.exam_pend oth_exam_pend,
                   ex.exam_req oth_exam_req,
                   ex.exam_transp oth_exam_transp,
                   ex.exam_exec oth_exam_exec,
                   ex.exam_result oth_exam_result,
                   ex.exam_result_read oth_exam_result_read,
                   ex.exam_ext oth_exam_ext,
                   ex.exam_perf oth_exam_perf,
                   ex.exam_wtg oth_exam_wtg,
                   ex.exam_sos oth_exam_sos
              FROM episode epis
             INNER JOIN v_ea_logic_trk_board_exam ex
                ON ex.id_episode = epis.id_episode
             WHERE epis.flg_status = pk_alert_constant.g_active
               AND epis.flg_ehr = 'N'
               AND epis.id_epis_type IN
                   (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient)
               AND ex.flg_type = pk_exam_constant.g_type_exm;
    
        /* Opinion */
        CURSOR c_current_consults IS
            SELECT COUNT(opinion_count) opinion_count,
                   id_episode,
                   substr(concatenate(state || ';'), 1, length(concatenate(state || ';')) - 1) opinion_state
              FROM (SELECT o.id_episode id_episode,
                           1 opinion_count,
                           CASE
                                WHEN o.flg_state IN (pk_opinion.g_opinion_req, pk_opinion.g_opinion_req_read) THEN
                                 '|' ||
                                 nvl(pk_date_utils.date_send_tsz(1, o.dt_problem_tstz, profissional(NULL, NULL, NULL)),
                                     'xxxxxxxxxxxxxx') || '|' || pk_alert_constant.g_display_type_date || '|' ||
                                 pk_alert_constant.g_color_red || '|' || NULL
                                ELSE
                                 '|' || '' || '|' || pk_alert_constant.g_display_type_icon || '|' ||
                                 pk_alert_constant.g_color_none || '|' || 'ConsultRepliedIcon'
                            END state
                      FROM opinion o
                     WHERE o.flg_state <> pk_opinion.g_opinion_cancel
                       AND o.id_opinion_type IS NULL)
             GROUP BY id_episode;
    
        /* Movements */
        CURSOR c_current_transp IS
            SELECT id_episode,
                   pk_ea_logic_tracking_board.count_not_nulls(table_varchar(transp.transp_delay, transp.transp_ongoing)) transp_count,
                   to_char(transp.transp_delay, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr) transp_delay,
                   to_char(transp.transp_ongoing, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr) transp_ongoing
              FROM (SELECT mov.id_episode,
                           MIN(decode(mov.flg_status, pk_alert_constant.g_mov_status_transp, mov.dt_begin_tstz, NULL)) transp_ongoing,
                           MIN(decode(mov.flg_status,
                                      pk_alert_constant.g_mov_status_req,
                                      mov.dt_req_tstz,
                                      pk_alert_constant.g_mov_status_pend,
                                      mov.dt_req_tstz,
                                      NULL)) transp_delay
                      FROM episode epis
                     INNER JOIN visit v
                        ON epis.id_visit = v.id_visit
                     INNER JOIN movement mov
                        ON epis.id_episode = mov.id_episode
                    
                     WHERE mov.flg_status IN (pk_alert_constant.g_mov_status_transp,
                                              pk_alert_constant.g_mov_status_req,
                                              pk_alert_constant.g_mov_status_pend)
                       AND epis.flg_status = pk_alert_constant.g_active
                       AND epis.flg_ehr = 'N'
                       AND epis.id_epis_type IN
                           (pk_alert_constant.g_epis_type_emergency, pk_alert_constant.g_epis_type_inpatient)
                     GROUP BY mov.id_episode) transp;
    
        l_bool_to_str table_varchar := table_varchar('FALSE', 'TRUE');
    
        l_tab_episode  table_number;
        l_tab_number_1 table_number;
        l_tab_number_2 table_number;
        l_tab_number_3 table_number;
        l_tab_number_4 table_number;
        l_tab_number_5 table_number;
        l_tab_number_6 table_number;
        l_tab_number_7 table_number;
        l_tab_number_8 table_number;
        l_tab_number_9 table_number;
    
        l_tab_tstz_1 table_timestamp_tz;
    
        l_tab_vchar_1  table_varchar;
        l_tab_vchar_2  table_varchar;
        l_tab_vchar_3  table_varchar;
        l_tab_vchar_4  table_varchar;
        l_tab_vchar_5  table_varchar;
        l_tab_vchar_6  table_varchar;
        l_tab_vchar_7  table_varchar;
        l_tab_vchar_8  table_varchar;
        l_tab_vchar_9  table_varchar;
        l_tab_vchar_10 table_varchar;
        l_tab_vchar_11 table_varchar;
    
        l_tab_episodes_to_delete table_number := table_number();
        l_tab_episodes_to_merge  table_number := table_number();
    
        l_error VARCHAR2(4000);
    
        l_invalid_records BOOLEAN := FALSE;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'VALIDATING ARGUMENTS';
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE function_error;
        END IF;
    
        dbms_output.put_line('TRACKING_BOARD_EA Table - Creation/validation script');
        dbms_output.put_line('Current execution parameters:');
    
        dbms_output.put_line(chr(9) || 'Table creation:       [' ||
                             l_bool_to_str(sys.diutil.bool_to_int(i_recreate_table) + 1) || ']');
        dbms_output.put_line(chr(9) || 'Table validation:       [' ||
                             l_bool_to_str(sys.diutil.bool_to_int(i_validate_table) + 1) || ']');
        dbms_output.put_line(chr(9) || 'Output invalid records: [' ||
                             l_bool_to_str(sys.diutil.bool_to_int(i_output_invalid_records) + 1) || ']');
    
        /* Table validation */
        IF i_validate_table
        THEN
            dbms_output.put_line('TRACKING_BOARD_EA - Table validation');
        
            -- Clean temporary table
            l_error := 'TRUNCATE tracking_board_ea_tmp';
            EXECUTE IMMEDIATE 'TRUNCATE TABLE tracking_board_ea_tmp';
        
            --Clean invalid records detected previously
            IF i_output_invalid_records
            THEN
                DELETE data_gov_invalid_recs
                 WHERE ea_table_name = 'TRACKING_BOARD_EA';
            END IF;
        
            l_error := 'FILLING OUT EPISODES INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out episodes into tracking_board_ea_tmp');
            OPEN c_current_epis;
            LOOP
                FETCH c_current_epis BULK COLLECT
                    INTO l_tab_episode,
                         l_tab_number_1,
                         l_tab_number_2,
                         l_tab_number_3,
                         l_tab_number_4,
                         l_tab_number_5,
                         l_tab_number_6,
                         l_tab_tstz_1,
                         l_tab_number_7,
                         l_tab_vchar_1,
                         l_tab_number_8,
                         l_tab_number_9 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    INSERT INTO tracking_board_ea_tmp
                        (id_episode,
                         id_patient,
                         id_epis_type,
                         id_triage_color,
                         id_fast_track,
                         id_room,
                         id_bed,
                         dt_begin,
                         id_diet,
                         desc_diet,
                         id_prof_resp,
                         id_nurse_resp,
                         dt_dg_last_update)
                    VALUES
                        (l_tab_episode(indx),
                         l_tab_number_1(indx),
                         l_tab_number_2(indx),
                         l_tab_number_3(indx),
                         l_tab_number_4(indx),
                         l_tab_number_5(indx),
                         l_tab_number_6(indx),
                         l_tab_tstz_1(indx),
                         l_tab_number_7(indx),
                         l_tab_vchar_1(indx),
                         l_tab_number_8(indx),
                         l_tab_number_9(indx),
                         g_sysdate_tstz);
                COMMIT;
            END LOOP;
        
            CLOSE c_current_epis;
        
            l_error := 'FILLING OUT ANALYSIS INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out analysis into tracking_board_ea_tmp');
            OPEN c_current_analysis;
            LOOP
                FETCH c_current_analysis BULK COLLECT
                    INTO l_tab_episode,
                         l_tab_number_1,
                         l_tab_vchar_1,
                         l_tab_vchar_2,
                         l_tab_vchar_3,
                         l_tab_vchar_4,
                         l_tab_vchar_5,
                         l_tab_vchar_6,
                         l_tab_vchar_7,
                         l_tab_vchar_8,
                         l_tab_vchar_9,
                         l_tab_vchar_10,
                         l_tab_vchar_11 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    UPDATE tracking_board_ea_tmp
                       SET lab_count       = l_tab_number_1(indx),
                           lab_pend        = l_tab_vchar_1(indx),
                           lab_req         = l_tab_vchar_2(indx),
                           lab_harv        = l_tab_vchar_3(indx),
                           lab_transp      = l_tab_vchar_4(indx),
                           lab_exec        = l_tab_vchar_5(indx),
                           lab_result      = l_tab_vchar_6(indx),
                           lab_result_read = l_tab_vchar_7(indx),
                           lab_ext         = l_tab_vchar_8(indx),
                           lab_wtg         = l_tab_vchar_9(indx),
                           lab_cc          = l_tab_vchar_10(indx),
                           lab_sos         = l_tab_vchar_11(indx)
                     WHERE id_episode = l_tab_episode(indx);
            
                COMMIT;
            
            END LOOP;
        
            CLOSE c_current_analysis;
        
            l_error := 'FILLING OUT EXAMS INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out exams into tracking_board_ea_tmp');
            OPEN c_current_exams;
            LOOP
                FETCH c_current_exams BULK COLLECT
                    INTO l_tab_episode,
                         l_tab_number_1,
                         l_tab_vchar_1,
                         l_tab_vchar_2,
                         l_tab_vchar_3,
                         l_tab_vchar_4,
                         l_tab_vchar_5,
                         l_tab_vchar_6,
                         l_tab_vchar_7,
                         l_tab_vchar_8,
                         l_tab_vchar_9,
                         l_tab_vchar_10 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    UPDATE tracking_board_ea_tmp
                       SET exam_count       = l_tab_number_1(indx),
                           exam_pend        = l_tab_vchar_1(indx),
                           exam_req         = l_tab_vchar_2(indx),
                           exam_transp      = l_tab_vchar_3(indx),
                           exam_exec        = l_tab_vchar_4(indx),
                           exam_result      = l_tab_vchar_5(indx),
                           exam_result_read = l_tab_vchar_6(indx),
                           exam_ext         = l_tab_vchar_7(indx),
                           exam_perf        = l_tab_vchar_8(indx),
                           exam_wtg         = l_tab_vchar_9(indx),
                           exam_sos         = l_tab_vchar_10(indx)
                     WHERE id_episode = l_tab_episode(indx);
            
                COMMIT;
            
            END LOOP;
        
            CLOSE c_current_exams;
        
            l_error := 'FILLING OUT EXAMS INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out other exams into tracking_board_ea_tmp');
            OPEN c_current_oth_exams;
            LOOP
                FETCH c_current_oth_exams BULK COLLECT
                    INTO l_tab_episode,
                         l_tab_number_1,
                         l_tab_vchar_1,
                         l_tab_vchar_2,
                         l_tab_vchar_3,
                         l_tab_vchar_4,
                         l_tab_vchar_5,
                         l_tab_vchar_6,
                         l_tab_vchar_7,
                         l_tab_vchar_8,
                         l_tab_vchar_9,
                         l_tab_vchar_10 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    UPDATE tracking_board_ea_tmp
                       SET oth_exam_count       = l_tab_number_1(indx),
                           oth_exam_pend        = l_tab_vchar_1(indx),
                           oth_exam_req         = l_tab_vchar_2(indx),
                           oth_exam_transp      = l_tab_vchar_3(indx),
                           oth_exam_exec        = l_tab_vchar_4(indx),
                           oth_exam_result      = l_tab_vchar_5(indx),
                           oth_exam_result_read = l_tab_vchar_6(indx),
                           oth_exam_ext         = l_tab_vchar_7(indx),
                           oth_exam_perf        = l_tab_vchar_8(indx),
                           oth_exam_wtg         = l_tab_vchar_9(indx),
                           oth_exam_sos         = l_tab_vchar_10(indx)
                     WHERE id_episode = l_tab_episode(indx);
            
                COMMIT;
            
            END LOOP;
        
            CLOSE c_current_oth_exams;
        
            l_error := 'FILLING OUT TRANSPORTS INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out transports into tracking_board_ea_tmp');
            OPEN c_current_transp;
            LOOP
                FETCH c_current_transp BULK COLLECT
                    INTO l_tab_episode, l_tab_number_1, l_tab_vchar_1, l_tab_vchar_2 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    UPDATE tracking_board_ea_tmp
                       SET transp_count   = l_tab_number_1(indx),
                           transp_delay   = l_tab_vchar_1(indx),
                           transp_ongoing = l_tab_vchar_2(indx)
                     WHERE id_episode = l_tab_episode(indx);
            
                COMMIT;
            
            END LOOP;
        
            CLOSE c_current_transp;
        
            l_error := 'FILLING OUT OPINION INTO tracking_board_ea_tmp';
            dbms_output.put_line(chr(9) || 'Filling out opinions into tracking_board_ea_tmp');
            OPEN c_current_consults;
            LOOP
                FETCH c_current_consults BULK COLLECT
                    INTO l_tab_number_1, l_tab_episode, l_tab_vchar_1 LIMIT i_commit_step;
            
                EXIT WHEN l_tab_episode.count = 0;
            
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    UPDATE tracking_board_ea_tmp
                       SET opinion_count = l_tab_number_1(indx), opinion_state = l_tab_vchar_1(indx)
                     WHERE id_episode = l_tab_episode(indx);
            
                COMMIT;
            
            END LOOP;
        
            CLOSE c_current_consults;
        
            -- Validations between TRACKING_BOARD_EA and tracking_board_ea_tmp
            l_error := 'VALIDATING TRACKING_BOARD_EA';
            dbms_output.put_line(chr(9) || 'Validating TRACKING_BOARD_EA...');
        
            -- 1st Validation: Nonexistent records
            dbms_output.put(chr(9) || chr(9) || '1st Validation: Nonexistent records...');
        
            SELECT id_episode
              BULK COLLECT
              INTO l_tab_episode
              FROM tracking_board_ea_tmp
            MINUS
            SELECT id_episode
              FROM tracking_board_ea;
        
            IF i_output_invalid_records
            THEN
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    INSERT INTO data_gov_invalid_recs
                        (ea_table_name,
                         id_pk_1_col_name,
                         id_pk_1_value,
                         dt_validation,
                         validation_type,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt)
                    VALUES
                        ('TRACKING_BOARD_EA',
                         'ID_EPISODE',
                         l_tab_episode(indx),
                         g_sysdate_tstz,
                         g_validation_type_1,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt);
                COMMIT;
            END IF;
        
            IF l_tab_episode.count > 0
            THEN
                l_tab_episodes_to_merge := l_tab_episodes_to_merge MULTISET UNION l_tab_episode;
            
                dbms_output.put_line('[FAILED] - ' || l_tab_episode.count || ' missing records.');
                l_invalid_records := TRUE;
            ELSE
                dbms_output.put_line('[PASSED].');
            END IF;
        
            -- 2nd Validation: Existent records in the table that should not exist
            dbms_output.put(chr(9) || chr(9) ||
                            '2nd Validation: Existent records in the table that should not exist...');
            SELECT id_episode
              BULK COLLECT
              INTO l_tab_episode
              FROM tracking_board_ea
            MINUS
            SELECT id_episode
              FROM tracking_board_ea_tmp;
        
            IF i_output_invalid_records
            THEN
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    INSERT INTO data_gov_invalid_recs
                        (ea_table_name,
                         id_pk_1_col_name,
                         id_pk_1_value,
                         dt_validation,
                         validation_type,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt)
                    VALUES
                        ('TRACKING_BOARD_EA',
                         'ID_EPISODE',
                         l_tab_episode(indx),
                         g_sysdate_tstz,
                         g_validation_type_2,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt);
                COMMIT;
            END IF;
        
            IF l_tab_episode.count > 0
            THEN
                l_tab_episodes_to_delete := l_tab_episodes_to_delete MULTISET UNION l_tab_episode;
                dbms_output.put_line('[FAILED] - ' || l_tab_episode.count || ' records on that should not exist.');
                l_invalid_records := TRUE;
            ELSE
                dbms_output.put_line('[PASSED].');
            END IF;
        
            -- 3rd Validation: Inconsistent data in records
            dbms_output.put(chr(9) || chr(9) || '3rd Validation: Inconsistent data in records...');
        
            SELECT ea.id_episode
              BULK COLLECT
              INTO l_tab_episode
              FROM tracking_board_ea ea
             INNER JOIN tracking_board_ea_tmp tmp
                ON ea.id_episode = tmp.id_episode
             INNER JOIN (SELECT id_episode,
                                id_patient,
                                id_epis_type,
                                id_triage_color,
                                id_fast_track,
                                id_room,
                                id_bed,
                                dt_begin,
                                id_diet,
                                desc_diet,
                                id_prof_resp,
                                id_nurse_resp,
                                lab_count,
                                to_timestamp_tz(lab_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_harv, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                exam_count,
                                to_timestamp_tz(exam_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                interv_count,
                                to_timestamp_tz(interv_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                med_count,
                                to_timestamp_tz(med_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                transp_count,
                                to_timestamp_tz(transp_delay, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(transp_ongoing, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                monit_count,
                                to_timestamp_tz(monit_delay, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(monit_ongoing, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(monit_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_perf, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_cc, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                oth_exam_count,
                                to_timestamp_tz(oth_exam_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_perf, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                opinion_count,
                                opinion_state
                           FROM tracking_board_ea ea
                         MINUS
                         SELECT id_episode,
                                id_patient,
                                id_epis_type,
                                id_triage_color,
                                id_fast_track,
                                id_room,
                                id_bed,
                                dt_begin,
                                id_diet,
                                desc_diet,
                                id_prof_resp,
                                id_nurse_resp,
                                lab_count,
                                to_timestamp_tz(lab_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_harv, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                exam_count,
                                to_timestamp_tz(exam_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                interv_count,
                                to_timestamp_tz(interv_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(interv_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                med_count,
                                to_timestamp_tz(med_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(med_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                transp_count,
                                to_timestamp_tz(transp_delay, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(transp_ongoing, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                monit_count,
                                to_timestamp_tz(monit_delay, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(monit_ongoing, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(monit_finish, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_perf, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_cc, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(lab_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(exam_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                oth_exam_count,
                                to_timestamp_tz(oth_exam_pend, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_req, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_transp, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_exec, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_result, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_result_read, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_ext, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_perf, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_wtg, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                to_timestamp_tz(oth_exam_sos, pk_alert_constant.g_dt_yyyymmddhh24miss_tzr),
                                opinion_count,
                                opinion_state
                           FROM tracking_board_ea_tmp tmp) diff
                ON ea.id_episode = diff.id_episode;
        
            IF i_output_invalid_records
            THEN
                FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                    INSERT INTO data_gov_invalid_recs
                        (ea_table_name,
                         id_pk_1_col_name,
                         id_pk_1_value,
                         dt_validation,
                         validation_type,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt)
                    VALUES
                        ('TRACKING_BOARD_EA',
                         'ID_EPISODE',
                         l_tab_episode(indx),
                         g_sysdate_tstz,
                         g_validation_type_2,
                         i_patient,
                         i_episode,
                         i_schedule,
                         i_external_request,
                         i_institution,
                         i_start_dt,
                         i_end_dt);
            
                COMMIT;
            END IF;
        
            IF l_tab_episode.count > 0
            THEN
                l_tab_episodes_to_merge := l_tab_episodes_to_merge MULTISET UNION l_tab_episode;
                dbms_output.put_line('[FAILED] - ' || l_tab_episode.count || ' records with inconsistent data.');
                l_invalid_records := TRUE;
            ELSE
                dbms_output.put_line('[PASSED].');
            END IF;
        
            dbms_output.put_line('TRACKING_BOARD_EA - Table validation [DONE]');
        END IF;
    
        /* Table reacreation */
        IF i_recreate_table
        THEN
            dbms_output.put_line('TRACKING_BOARD_EA - Table criation');
        
            IF i_validate_table
            THEN
                -- Recriates table using temporary calculated data approach
                dbms_output.put(chr(9) || 'Recreating table using validated data...');
            
                -- Clean existent records in the table that should not exist
                DELETE FROM tracking_board_ea
                 WHERE id_episode IN (SELECT *
                                        FROM TABLE(l_tab_episodes_to_delete));
            
                -- Merge nonexistent episodes or with inconsistent data
                MERGE INTO tracking_board_ea ea
                USING (SELECT *
                         FROM tracking_board_ea_tmp ea_tmp
                        WHERE ea_tmp.id_episode IN (SELECT *
                                                      FROM TABLE(l_tab_episodes_to_merge))) t
                ON (ea.id_episode = t.id_episode)
                WHEN MATCHED THEN
                    UPDATE
                       SET id_patient           = t.id_patient,
                           id_epis_type         = t.id_epis_type,
                           id_triage_color      = t.id_triage_color,
                           id_fast_track        = t.id_fast_track,
                           id_room              = t.id_room,
                           id_bed               = t.id_bed,
                           dt_begin             = t.dt_begin,
                           id_diet              = t.id_diet,
                           desc_diet            = t.desc_diet,
                           id_prof_resp         = t.id_prof_resp,
                           id_nurse_resp        = t.id_nurse_resp,
                           lab_count            = t.lab_count,
                           lab_pend             = t.lab_pend,
                           lab_req              = t.lab_req,
                           lab_harv             = t.lab_harv,
                           lab_transp           = t.lab_transp,
                           lab_exec             = t.lab_exec,
                           lab_result           = t.lab_result,
                           lab_result_read      = t.lab_result_read,
                           exam_count           = t.exam_count,
                           exam_pend            = t.exam_pend,
                           exam_req             = t.exam_req,
                           exam_transp          = t.exam_transp,
                           exam_exec            = t.exam_exec,
                           exam_result          = t.exam_result,
                           exam_result_read     = t.exam_result_read,
                           interv_count         = t.interv_count,
                           interv_pend          = t.interv_pend,
                           interv_sos           = t.interv_sos,
                           interv_req           = t.interv_req,
                           interv_exec          = t.interv_exec,
                           interv_finish        = t.interv_finish,
                           med_count            = t.med_count,
                           med_pend             = t.med_pend,
                           med_req              = t.med_req,
                           med_exec             = t.med_exec,
                           med_finish           = t.med_finish,
                           med_sos              = t.med_sos,
                           transp_count         = t.transp_count,
                           transp_delay         = t.transp_delay,
                           transp_ongoing       = t.transp_ongoing,
                           monit_count          = t.monit_count,
                           monit_delay          = t.monit_delay,
                           monit_ongoing        = t.monit_ongoing,
                           monit_finish         = t.monit_finish,
                           dt_dg_last_update    = t.dt_dg_last_update,
                           lab_ext              = t.lab_ext,
                           exam_ext             = t.exam_ext,
                           exam_perf            = t.exam_perf,
                           exam_wtg             = t.exam_wtg,
                           lab_wtg              = t.lab_wtg,
                           lab_cc               = t.lab_cc,
                           lab_sos              = t.lab_sos,
                           exam_sos             = t.exam_sos,
                           oth_exam_count       = t.oth_exam_count,
                           oth_exam_pend        = t.oth_exam_pend,
                           oth_exam_req         = t.oth_exam_req,
                           oth_exam_transp      = t.oth_exam_transp,
                           oth_exam_exec        = t.oth_exam_exec,
                           oth_exam_result      = t.oth_exam_result,
                           oth_exam_result_read = t.oth_exam_result_read,
                           oth_exam_ext         = t.oth_exam_ext,
                           oth_exam_perf        = t.oth_exam_perf,
                           oth_exam_wtg         = t.oth_exam_wtg,
                           oth_exam_sos         = t.oth_exam_sos,
                           opinion_count        = t.opinion_count,
                           opinion_state        = t.opinion_state
                     WHERE ea.id_episode = t.id_episode
                WHEN NOT MATCHED THEN
                    INSERT
                        (id_episode,
                         id_patient,
                         id_epis_type,
                         id_triage_color,
                         id_fast_track,
                         id_room,
                         id_bed,
                         dt_begin,
                         id_diet,
                         desc_diet,
                         id_prof_resp,
                         id_nurse_resp,
                         lab_count,
                         lab_pend,
                         lab_req,
                         lab_harv,
                         lab_transp,
                         lab_exec,
                         lab_result,
                         lab_result_read,
                         exam_count,
                         exam_pend,
                         exam_req,
                         exam_transp,
                         exam_exec,
                         exam_result,
                         exam_result_read,
                         interv_count,
                         interv_pend,
                         interv_sos,
                         interv_req,
                         interv_exec,
                         interv_finish,
                         med_count,
                         med_pend,
                         med_req,
                         med_exec,
                         med_finish,
                         med_sos,
                         transp_count,
                         transp_delay,
                         transp_ongoing,
                         monit_count,
                         monit_delay,
                         monit_ongoing,
                         monit_finish,
                         dt_dg_last_update,
                         lab_ext,
                         exam_ext,
                         exam_perf,
                         exam_wtg,
                         lab_wtg,
                         lab_cc,
                         lab_sos,
                         exam_sos,
                         oth_exam_count,
                         oth_exam_pend,
                         oth_exam_req,
                         oth_exam_transp,
                         oth_exam_exec,
                         oth_exam_result,
                         oth_exam_result_read,
                         oth_exam_ext,
                         oth_exam_perf,
                         oth_exam_wtg,
                         oth_exam_sos,
                         opinion_count,
                         opinion_state)
                    VALUES
                        (t.id_episode,
                         t.id_patient,
                         t.id_epis_type,
                         t.id_triage_color,
                         t.id_fast_track,
                         t.id_room,
                         t.id_bed,
                         t.dt_begin,
                         t.id_diet,
                         t.desc_diet,
                         t.id_prof_resp,
                         t.id_nurse_resp,
                         t.lab_count,
                         t.lab_pend,
                         t.lab_req,
                         t.lab_harv,
                         t.lab_transp,
                         t.lab_exec,
                         t.lab_result,
                         t.lab_result_read,
                         t.exam_count,
                         t.exam_pend,
                         t.exam_req,
                         t.exam_transp,
                         t.exam_exec,
                         t.exam_result,
                         t.exam_result_read,
                         t.interv_count,
                         t.interv_pend,
                         t.interv_sos,
                         t.interv_req,
                         t.interv_exec,
                         t.interv_finish,
                         t.med_count,
                         t.med_pend,
                         t.med_req,
                         t.med_exec,
                         t.med_finish,
                         t.med_sos,
                         t.transp_count,
                         t.transp_delay,
                         t.transp_ongoing,
                         t.monit_count,
                         t.monit_delay,
                         t.monit_ongoing,
                         t.monit_finish,
                         t.dt_dg_last_update,
                         t.lab_ext,
                         t.exam_ext,
                         t.exam_perf,
                         t.exam_wtg,
                         t.lab_wtg,
                         t.lab_cc,
                         t.lab_sos,
                         t.exam_sos,
                         t.oth_exam_count,
                         t.oth_exam_pend,
                         t.oth_exam_req,
                         t.oth_exam_transp,
                         t.oth_exam_exec,
                         t.oth_exam_result,
                         t.oth_exam_result_read,
                         t.oth_exam_ext,
                         t.oth_exam_perf,
                         t.oth_exam_wtg,
                         t.oth_exam_sos,
                         t.opinion_count,
                         t.opinion_state);
                COMMIT;
                dbms_output.put_line('[OK]');
            
            ELSE
                -- Recriates table from scratch
                dbms_output.put(chr(9) || 'Recreating table from scratch...');
            
                l_error := 'DELETE TRACKING_BOARD_EA';
                delete_tracking_board_ea;
                COMMIT;
            
                l_error := 'FILLING OUT EPISODES INTO TRACKING_BOARD_EA';
                OPEN c_current_epis;
                LOOP
                    FETCH c_current_epis BULK COLLECT
                        INTO l_tab_episode,
                             l_tab_number_1,
                             l_tab_number_2,
                             l_tab_number_3,
                             l_tab_number_4,
                             l_tab_number_5,
                             l_tab_number_6,
                             l_tab_tstz_1,
                             l_tab_number_7,
                             l_tab_vchar_1,
                             l_tab_number_8,
                             l_tab_number_9 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        INSERT INTO tracking_board_ea
                            (id_episode,
                             id_patient,
                             id_epis_type,
                             id_triage_color,
                             id_fast_track,
                             id_room,
                             id_bed,
                             dt_begin,
                             id_diet,
                             desc_diet,
                             id_prof_resp,
                             id_nurse_resp,
                             dt_dg_last_update)
                        VALUES
                            (l_tab_episode(indx),
                             l_tab_number_1(indx),
                             l_tab_number_2(indx),
                             l_tab_number_3(indx),
                             l_tab_number_4(indx),
                             l_tab_number_5(indx),
                             l_tab_number_6(indx),
                             l_tab_tstz_1(indx),
                             l_tab_number_7(indx),
                             l_tab_vchar_1(indx),
                             l_tab_number_8(indx),
                             l_tab_number_9(indx),
                             g_sysdate_tstz);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_epis;
            
                l_error := 'FILL ANALYSIS';
                OPEN c_current_analysis;
                LOOP
                    FETCH c_current_analysis BULK COLLECT
                        INTO l_tab_episode,
                             l_tab_number_1,
                             l_tab_vchar_1,
                             l_tab_vchar_2,
                             l_tab_vchar_3,
                             l_tab_vchar_4,
                             l_tab_vchar_5,
                             l_tab_vchar_6,
                             l_tab_vchar_7,
                             l_tab_vchar_8,
                             l_tab_vchar_9,
                             l_tab_vchar_10,
                             l_tab_vchar_11 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        UPDATE tracking_board_ea
                           SET lab_count       = l_tab_number_1(indx),
                               lab_pend        = l_tab_vchar_1(indx),
                               lab_req         = l_tab_vchar_2(indx),
                               lab_harv        = l_tab_vchar_3(indx),
                               lab_transp      = l_tab_vchar_4(indx),
                               lab_exec        = l_tab_vchar_5(indx),
                               lab_result      = l_tab_vchar_6(indx),
                               lab_result_read = l_tab_vchar_7(indx),
                               lab_ext         = l_tab_vchar_8(indx),
                               lab_wtg         = l_tab_vchar_9(indx),
                               lab_cc          = l_tab_vchar_10(indx),
                               lab_sos         = l_tab_vchar_11(indx)
                         WHERE id_episode = l_tab_episode(indx);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_analysis;
            
                l_error := 'FILL EXAMS';
                OPEN c_current_exams;
                LOOP
                    FETCH c_current_exams BULK COLLECT
                        INTO l_tab_episode,
                             l_tab_number_1,
                             l_tab_vchar_1,
                             l_tab_vchar_2,
                             l_tab_vchar_3,
                             l_tab_vchar_4,
                             l_tab_vchar_5,
                             l_tab_vchar_6,
                             l_tab_vchar_7,
                             l_tab_vchar_8,
                             l_tab_vchar_9,
                             l_tab_vchar_10 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        UPDATE tracking_board_ea
                           SET exam_count       = l_tab_number_1(indx),
                               exam_pend        = l_tab_vchar_1(indx),
                               exam_req         = l_tab_vchar_2(indx),
                               exam_transp      = l_tab_vchar_3(indx),
                               exam_exec        = l_tab_vchar_4(indx),
                               exam_result      = l_tab_vchar_5(indx),
                               exam_result_read = l_tab_vchar_6(indx),
                               exam_ext         = l_tab_vchar_7(indx),
                               exam_perf        = l_tab_vchar_8(indx),
                               exam_wtg         = l_tab_vchar_9(indx),
                               exam_sos         = l_tab_vchar_10(indx)
                         WHERE id_episode = l_tab_episode(indx);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_exams;
            
                l_error := 'FILL EXAMS';
                OPEN c_current_oth_exams;
                LOOP
                    FETCH c_current_oth_exams BULK COLLECT
                        INTO l_tab_episode,
                             l_tab_number_1,
                             l_tab_vchar_1,
                             l_tab_vchar_2,
                             l_tab_vchar_3,
                             l_tab_vchar_4,
                             l_tab_vchar_5,
                             l_tab_vchar_6,
                             l_tab_vchar_7,
                             l_tab_vchar_8,
                             l_tab_vchar_9,
                             l_tab_vchar_10 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        UPDATE tracking_board_ea
                           SET oth_exam_count       = l_tab_number_1(indx),
                               oth_exam_pend        = l_tab_vchar_1(indx),
                               oth_exam_req         = l_tab_vchar_2(indx),
                               oth_exam_transp      = l_tab_vchar_3(indx),
                               oth_exam_exec        = l_tab_vchar_4(indx),
                               oth_exam_result      = l_tab_vchar_5(indx),
                               oth_exam_result_read = l_tab_vchar_6(indx),
                               oth_exam_ext         = l_tab_vchar_7(indx),
                               oth_exam_perf        = l_tab_vchar_8(indx),
                               oth_exam_wtg         = l_tab_vchar_9(indx),
                               oth_exam_sos         = l_tab_vchar_10(indx)
                         WHERE id_episode = l_tab_episode(indx);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_oth_exams;
            
                l_error := 'FILL TRANSP';
                OPEN c_current_transp;
                LOOP
                    FETCH c_current_transp BULK COLLECT
                        INTO l_tab_episode, l_tab_number_1, l_tab_vchar_1, l_tab_vchar_2 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        UPDATE tracking_board_ea
                           SET transp_count   = l_tab_number_1(indx),
                               transp_delay   = l_tab_vchar_1(indx),
                               transp_ongoing = l_tab_vchar_2(indx)
                         WHERE id_episode = l_tab_episode(indx);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_transp;
            
                l_error := 'FILL CONSULTS';
                OPEN c_current_consults;
                LOOP
                    FETCH c_current_consults BULK COLLECT
                        INTO l_tab_number_1, l_tab_episode, l_tab_vchar_1 LIMIT i_commit_step;
                
                    EXIT WHEN l_tab_episode.count = 0;
                
                    FORALL indx IN l_tab_episode.first .. l_tab_episode.last SAVE EXCEPTIONS
                        UPDATE tracking_board_ea
                           SET opinion_count = l_tab_number_1(indx), opinion_state = l_tab_vchar_1(indx)
                         WHERE id_episode = l_tab_episode(indx);
                    COMMIT;
                END LOOP;
            
                CLOSE c_current_consults;
            
                dbms_output.put_line('[OK]');
            END IF;
            dbms_output.put_line('TRACKING_BOARD_EA - Table criation [DONE]');
        END IF;
    
        COMMIT;
    
        IF l_invalid_records
        THEN
            RAISE e_bad_data;
        END IF;
    
    EXCEPTION
        WHEN e_bad_data THEN
            raise_application_error(-20001, 'Inserted invalid records. Check table data_gov_invalid_recs.');
    END admin_50_tracking_board_ea;

    PROCEDURE admin_98_viewer_ehr_ea(i_inst IN NUMBER DEFAULT 0) IS
        l_ea_table CONSTANT user_tables.table_name%TYPE := 'VIEWER_EHR_EA';
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        --LOCK LANGUAGE AND PROFESSIONAL
        l_lang language.id_language%TYPE := g_log_lang;
        l_prof profissional;
    
        l_patients table_number;
        l_error    t_error_out;
    BEGIN
        g_error := '[ADMIN_98_VIEWER_EHR_EA] GET_PROF ';
    
        l_prof := get_prof(i_inst => i_inst);
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] BEGIN ';
        --validate l_id_prof
        IF NOT (l_prof.id > 0)
        THEN
            pk_alertlog.log_error('[ADMIN_98_VIEWER_EHR_EA] ID_PROF_BACKGROUND must be configured and cannot be 0');
            RAISE e_external;
        END IF;
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] disable indexes ';
        -- disable indexes
        pk_frmw.disable_index(i_table_name => l_ea_table, i_owner => g_package_owner, i_disable_fk => TRUE);
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Truncate, insert, count';
        -- clear table data
        EXECUTE IMMEDIATE 'truncate table ' || l_ea_table;
        EXECUTE IMMEDIATE 'truncate table err$_' || l_ea_table;
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] INSERT INTO viewer_ehr_ea';
        -- fill patients
        INSERT INTO viewer_ehr_ea
            (id_patient)
            SELECT p.id_patient
              FROM patient p log errors
              INTO err$_viewer_ehr_ea(to_char(SYSDATE)) reject LIMIT unlimited;
    
        l_count := SQL%ROWCOUNT;
    
        COMMIT;
    
        -- GET ALL PATIENTS filled to process (all upd_ functions should be base on this)
        SELECT id_patient
          BULK COLLECT
          INTO l_patients
          FROM viewer_ehr_ea vee;
    
        -- call ea "updater" processes
        --Allergies
        g_error := '[ADMIN_98_VIEWER_EHR_EA] ALLERGIES';
        BEGIN
            pk_allergy.upd_viewer_ehr_ea;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Exams
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Exams';
        BEGIN
            pk_exams_external_api_db.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Lab
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Lab';
        BEGIN
            pk_lab_tests_external_api_db.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Episodes
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Episodes';
        BEGIN
            pk_episode.upd_viewer_ehr_ea;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Archives
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Archives';
        BEGIN
            pk_doc.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Medication
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Medication';
        BEGIN
            pk_api_pfh_in.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Problems
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Problems';
        BEGIN
            pk_problems.upd_viewer_ehr_ea;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --Procedures
        g_error := '[ADMIN_98_VIEWER_EHR_EA] Procedures';
        BEGIN
            pk_procedures_external_api_db.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --VITAL SIGNS
        g_error := '[ADMIN_98_VIEWER_EHR_EA] VITAL SIGNS';
        BEGIN
            pk_vital_sign_core.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        --PROGRESS NOTES
        g_error := '[ADMIN_98_VIEWER_EHR_EA] PROGRESS NOTES';
        BEGIN
            pk_prog_notes_core.upd_viewer_ehr_ea(i_lang => l_lang, i_prof => l_prof);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        COMMIT;
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] enable indexes';
        BEGIN
            -- enable indexes
            pk_frmw.enable_index(i_table_name => l_ea_table, i_owner => g_package_owner, i_enable_fk => TRUE);
        EXCEPTION
            WHEN OTHERS THEN
                dbms_output.put_line('CHECK ENABLE INDEX');
        END;
    
        g_error := '[ADMIN_98_VIEWER_EHR_EA] INSERT INTO data_gov_invalid_recs';
        INSERT INTO data_gov_invalid_recs
            (ea_table_name, id_pk_1_value, id_pk_1_col_name, dt_validation, validation_type)
            SELECT l_ea_table ea_table_name,
                   id_patient id_pk_1_value,
                   'ID_PATIENT' id_pk_1_col_name,
                   l_current_timestamp dt_validation,
                   2 validation_type
              FROM err$_viewer_ehr_ea;
    
        l_count_invalid := SQL%ROWCOUNT;
    
        dbms_output.put_line('OK: ' || l_count_invalid || ' invalid record(s) inserted');
        dbms_output.put_line('OK: ' || l_count || ' record(s) inserted');
    
        COMMIT;
        g_error := '[ADMIN_98_VIEWER_EHR_EA] l_count_invalid > 0 ' || l_count_invalid;
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
    EXCEPTION
        WHEN e_external THEN
            pk_alert_exceptions.raise_error(error_code_in => '-20001',
                                            text_in       => g_error ||
                                                             'External error. Check table alertlog.tlog for error details.');
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_viewer_ehr_ea.');
    END admin_98_viewer_ehr_ea;

    PROCEDURE admin_task_tl_analysis_ea(i_episode IN NUMBER DEFAULT NULL) IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        l_flg_outdated     task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_not_outdated task_timeline_ea.flg_outdated%TYPE := 0;
    
    BEGIN
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_id_tl_task_analysis',
                              object_name     => g_package_name,
                              sub_object_name => 'ADMIN_TASK_TL_ANALYSIS_EA');
    
        IF NOT
            pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => NULL,
                                                          i_episode     => i_episode,
                                                          i_institution => NULL,
                                                          i_start_dt    => NULL,
                                                          i_end_dt      => NULL,
                                                          i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_lab)) -- ANALYSIS TASKS ONLY
        THEN
            RAISE e_internal;
        END IF;
    
        -- Insert into Easy Access table
        pk_alertlog.log_info(text            => g_error,
                             object_name     => g_package_name,
                             sub_object_name => 'ADMIN_TASK_TL_ANALYSIS_EA');
        IF i_episode IS NULL
        THEN
            FOR i IN (SELECT id_episode
                        FROM episode)
            LOOP
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     id_ref_group,
                     flg_sos,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     id_task_aggregator,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_sample_type,
                     id_sub_group_import,
                     code_desc_sample_type,
                     code_desc_sub_group,
                     id_task_related,
                     flg_type,
                     code_desc_group_parent,
                     instructions_hash)
                    SELECT id_analysis_req_det,
                           pk_prog_notes_constants.g_task_lab, -- ANALYSIS TASKS TYPE
                           id_patient,
                           id_episode,
                           id_visit,
                           id_institution,
                           dt_req_tstz,
                           id_prof_writes,
                           nvl(dt_pend_req_tstz, dt_target_tstz),
                           dt_end,
                           flg_status_ard,
                           pk_ea_logic_analysis.get_analysis_status_str_det(l_lang,
                                                                            l_prof,
                                                                            id_episode,
                                                                            flg_time_harvest,
                                                                            flg_status_ard,
                                                                            flg_referral,
                                                                            flg_status_h,
                                                                            NULL,
                                                                            NULL,
                                                                            dt_req_tstz,
                                                                            dt_pend_req_tstz,
                                                                            dt_target_tstz) status_str,
                           pk_ea_logic_analysis.get_analysis_status_msg_det(l_lang,
                                                                            l_prof,
                                                                            id_episode,
                                                                            flg_time_harvest,
                                                                            flg_status_ard,
                                                                            flg_referral,
                                                                            flg_status_h,
                                                                            NULL,
                                                                            NULL,
                                                                            dt_req_tstz,
                                                                            dt_pend_req_tstz,
                                                                            dt_target_tstz) status_msg,
                           pk_ea_logic_analysis.get_analysis_status_icon_det(l_lang,
                                                                             l_prof,
                                                                             id_episode,
                                                                             flg_time_harvest,
                                                                             flg_status_ard,
                                                                             flg_referral,
                                                                             flg_status_h,
                                                                             NULL,
                                                                             NULL,
                                                                             dt_req_tstz,
                                                                             dt_pend_req_tstz,
                                                                             dt_target_tstz) status_icon,
                           pk_ea_logic_analysis.get_analysis_status_flg_det(l_lang,
                                                                            l_prof,
                                                                            id_episode,
                                                                            flg_time_harvest,
                                                                            flg_status_ard,
                                                                            flg_referral,
                                                                            flg_status_h,
                                                                            NULL,
                                                                            NULL,
                                                                            dt_req_tstz,
                                                                            dt_pend_req_tstz,
                                                                            dt_target_tstz) status_flg,
                           code_analysis,
                           universal_desc_clob,
                           pk_alert_constant.g_tl_table_name_analysis,
                           pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                           flg_type_viewer,
                           id_ref_group,
                           flg_sos,
                           flg_outdated,
                           id_group_import,
                           code_group,
                           id_task_aggregator,
                           l_current_timestamp,
                           flg_ongoing,
                           flg_normal,
                           id_prof_exec,
                           flg_has_comments,
                           dt_last_update,
                           id_sample_type,
                           id_sub_group_import,
                           code_desc_sample_type,
                           code_desc_sub_group,
                           id_analysis_req_det,
                           flg_category_type,
                           code_desc_group_parent,
                           instructions_hash
                      FROM (SELECT ar.id_analysis_req,
                                   ard.id_analysis_req_det,
                                   ar.dt_req_tstz,
                                   NULL dt_end,
                                   nvl(ard.dt_pend_req_tstz, ard.dt_target_tstz) dt_target_tstz,
                                   ard.dt_pend_req_tstz,
                                   ard.flg_status flg_status_ard,
                                   ard.flg_time_harvest,
                                   csh.id_prof_ordered_by id_prof_order,
                                   csh.dt_ordered_by dt_order,
                                   ar.id_patient,
                                   ar.id_episode,
                                   ar.id_visit,
                                   ar.id_institution,
                                   ard.flg_referral,
                                   NULL universal_desc_clob,
                                   a.code_analysis,
                                   decode(ard.flg_status,
                                          pk_alert_constant.g_analysis_det_result,
                                          pk_alert_constant.g_flg_type_viewer_analysis_res,
                                          pk_alert_constant.g_analysis_det_read,
                                          pk_alert_constant.g_flg_type_viewer_analysis_res,
                                          pk_alert_constant.g_flg_type_viewer_analysis) flg_type_viewer,
                                   ar.id_prof_writes,
                                   decode(ard.id_order_recurrence, NULL, NULL, ard.id_analysis) id_ref_group,
                                   nvl(ard.flg_prn, pk_alert_constant.g_no) flg_sos,
                                   decode(ard.flg_status,
                                          pk_lab_tests_constant.g_analysis_result,
                                          l_flg_outdated,
                                          pk_lab_tests_constant.g_analysis_read,
                                          l_flg_outdated,
                                          l_flg_not_outdated) flg_outdated,
                                   ard.id_exam_cat id_group_import,
                                   'EXAM_CAT.CODE_EXAM_CAT.' || ard.id_exam_cat code_group,
                                   ard.id_order_recurrence id_task_aggregator,
                                   decode(ard.flg_status,
                                          pk_lab_tests_constant.g_analysis_result,
                                          pk_prog_notes_constants.g_task_finalized_f,
                                          pk_lab_tests_constant.g_analysis_read,
                                          pk_prog_notes_constants.g_task_finalized_f,
                                          pk_prog_notes_constants.g_task_ongoing_o) flg_ongoing,
                                   pk_alert_constant.g_yes flg_normal,
                                   decode(ard.id_order_recurrence,
                                          NULL,
                                          coalesce(h.id_prof_harvest, csh.id_prof_ordered_by, ar.id_prof_writes),
                                          NULL) id_prof_exec,
                                   h.flg_status flg_status_h,
                                   pk_alert_constant.g_no flg_has_comments,
                                   nvl(ard.dt_last_update_tstz, ar.dt_req_tstz) dt_last_update,
                                   ard.id_sample_type id_sample_type,
                                   'SAMPLE_TYPE.CODE_SAMPLE_TYPE.' || ard.id_sample_type code_desc_sample_type,
                                   NULL id_sub_group_import,
                                   NULL code_desc_sub_group,
                                   ais.flg_category_type,
                                   CASE
                                        WHEN pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ard.id_exam_cat) IS NOT NULL THEN
                                         'EXAM_CAT.CODE_EXAM_CAT.' ||
                                         pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ard.id_exam_cat)
                                        ELSE
                                         NULL
                                    END code_desc_group_parent,
                                   standard_hash(ard.flg_urgency || '|' || ard.flg_time_harvest || '|' ||
                                                 ard.dt_target_tstz || '|' || ard.flg_prn --|| '|' ||
                                                 --ard.id_order_recurrence 
                                                ,
                                                 'MD5') instructions_hash,
                                   row_number() over(PARTITION BY ard.id_analysis_req_det ORDER BY h.dt_harvest_tstz DESC NULLS LAST) rn
                              FROM analysis_req_det ard
                             INNER JOIN analysis_req ar
                                ON ard.id_analysis_req = ar.id_analysis_req
                              LEFT JOIN co_sign_hist csh
                                ON (ard.id_co_sign_order = csh.id_co_sign_hist)
                             INNER JOIN analysis a
                                ON ard.id_analysis = a.id_analysis
                              LEFT JOIN (SELECT *
                                          FROM (SELECT ah.id_analysis_req_det,
                                                       ah.id_harvest,
                                                       row_number() over(PARTITION BY id_analysis_req_det ORDER BY id_harvest) rn
                                                  FROM analysis_harvest ah
                                                 WHERE ah.flg_status = pk_lab_tests_constant.g_active)
                                         WHERE rn = 1) ah
                                ON ard.id_analysis_req_det = ah.id_analysis_req_det
                              LEFT JOIN (SELECT *
                                          FROM (SELECT h.id_harvest,
                                                       h.flg_status,
                                                       h.id_prof_harvest,
                                                       h.dt_harvest_tstz,
                                                       row_number() over(PARTITION BY id_harvest ORDER BY dt_harvest_tstz DESC) rn
                                                  FROM harvest h
                                                 WHERE h.flg_status IN
                                                       (pk_lab_tests_constant.g_harvest_collected,
                                                        pk_lab_tests_constant.g_harvest_finished,
                                                        pk_lab_tests_constant.g_harvest_rejected,
                                                        pk_lab_tests_constant.g_harvest_transp))
                                         WHERE rn = 1) h
                                ON ah.id_harvest = h.id_harvest
                             INNER JOIN episode e
                                ON coalesce(ar.id_episode, ar.id_episode_origin, ar.id_episode_destination) =
                                   e.id_episode
                              LEFT JOIN analysis_instit_soft ais
                                ON ais.id_analysis = ard.id_analysis
                               AND ais.id_sample_type = ard.id_sample_type
                               AND ais.flg_available = pk_lab_tests_constant.g_available
                               AND ais.flg_type = pk_lab_tests_constant.g_analysis_can_req
                               AND ais.id_institution = l_prof.institution
                               AND ais.id_software = l_prof.software
                             WHERE ard.flg_status != pk_lab_tests_constant.g_analysis_predefined
                               AND e.id_episode = i.id_episode
                               AND e.flg_status != pk_alert_constant.g_epis_status_cancel) t
                     WHERE t.rn = 1 log errors INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
            END LOOP;
        ELSE
            INSERT INTO task_timeline_ea
                (id_task_refid,
                 id_tl_task,
                 id_patient,
                 id_episode,
                 id_visit,
                 id_institution,
                 dt_req,
                 id_prof_req,
                 dt_begin,
                 dt_end,
                 flg_status_req,
                 status_str,
                 status_msg,
                 status_icon,
                 status_flg,
                 code_description,
                 universal_desc_clob,
                 table_name,
                 flg_show_method,
                 flg_type_viewer,
                 id_ref_group,
                 flg_sos,
                 flg_outdated,
                 id_group_import,
                 code_desc_group,
                 id_task_aggregator,
                 dt_dg_last_update,
                 flg_ongoing,
                 flg_normal,
                 id_prof_exec,
                 flg_has_comments,
                 dt_last_update,
                 id_sample_type,
                 id_sub_group_import,
                 code_desc_sample_type,
                 code_desc_sub_group,
                 id_task_related,
                 flg_type,
                 code_desc_group_parent,
                 instructions_hash)
                SELECT id_analysis_req_det,
                       pk_prog_notes_constants.g_task_lab, -- ANALYSIS TASKS TYPE
                       id_patient,
                       id_episode,
                       id_visit,
                       id_institution,
                       dt_req_tstz,
                       id_prof_writes,
                       nvl(dt_pend_req_tstz, dt_target_tstz),
                       dt_end,
                       flg_status_ard,
                       pk_ea_logic_analysis.get_analysis_status_str_det(l_lang,
                                                                        l_prof,
                                                                        id_episode,
                                                                        flg_time_harvest,
                                                                        flg_status_ard,
                                                                        flg_referral,
                                                                        flg_status_h,
                                                                        NULL,
                                                                        NULL,
                                                                        dt_req_tstz,
                                                                        dt_pend_req_tstz,
                                                                        dt_target_tstz) status_str,
                       pk_ea_logic_analysis.get_analysis_status_msg_det(l_lang,
                                                                        l_prof,
                                                                        id_episode,
                                                                        flg_time_harvest,
                                                                        flg_status_ard,
                                                                        flg_referral,
                                                                        flg_status_h,
                                                                        NULL,
                                                                        NULL,
                                                                        dt_req_tstz,
                                                                        dt_pend_req_tstz,
                                                                        dt_target_tstz) status_msg,
                       pk_ea_logic_analysis.get_analysis_status_icon_det(l_lang,
                                                                         l_prof,
                                                                         id_episode,
                                                                         flg_time_harvest,
                                                                         flg_status_ard,
                                                                         flg_referral,
                                                                         flg_status_h,
                                                                         NULL,
                                                                         NULL,
                                                                         dt_req_tstz,
                                                                         dt_pend_req_tstz,
                                                                         dt_target_tstz) status_icon,
                       pk_ea_logic_analysis.get_analysis_status_flg_det(l_lang,
                                                                        l_prof,
                                                                        id_episode,
                                                                        flg_time_harvest,
                                                                        flg_status_ard,
                                                                        flg_referral,
                                                                        flg_status_h,
                                                                        NULL,
                                                                        NULL,
                                                                        dt_req_tstz,
                                                                        dt_pend_req_tstz,
                                                                        dt_target_tstz) status_flg,
                       code_analysis,
                       universal_desc_clob,
                       pk_alert_constant.g_tl_table_name_analysis,
                       pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                       flg_type_viewer,
                       id_ref_group,
                       flg_sos,
                       flg_outdated,
                       id_group_import,
                       code_group,
                       id_task_aggregator,
                       l_current_timestamp,
                       flg_ongoing,
                       flg_normal,
                       id_prof_exec,
                       flg_has_comments,
                       dt_last_update,
                       id_sample_type,
                       id_sub_group_import,
                       code_desc_sample_type,
                       code_desc_sub_group,
                       id_analysis_req_det,
                       flg_category_type,
                       code_desc_group_parent,
                       instructions_hash
                  FROM (SELECT ar.id_analysis_req,
                               ard.id_analysis_req_det,
                               ar.dt_req_tstz,
                               NULL dt_end,
                               nvl(ard.dt_pend_req_tstz, ard.dt_target_tstz) dt_target_tstz,
                               ard.dt_pend_req_tstz,
                               ard.flg_status flg_status_ard,
                               ard.flg_time_harvest,
                               csh.id_prof_ordered_by id_prof_order,
                               csh.dt_ordered_by dt_order,
                               ar.id_patient,
                               ar.id_episode,
                               ar.id_visit,
                               ar.id_institution,
                               ard.flg_referral,
                               NULL universal_desc_clob,
                               a.code_analysis,
                               decode(ard.flg_status,
                                      pk_alert_constant.g_analysis_det_result,
                                      pk_alert_constant.g_flg_type_viewer_analysis_res,
                                      pk_alert_constant.g_analysis_det_read,
                                      pk_alert_constant.g_flg_type_viewer_analysis_res,
                                      pk_alert_constant.g_flg_type_viewer_analysis) flg_type_viewer,
                               ar.id_prof_writes,
                               decode(ard.id_order_recurrence, NULL, NULL, ard.id_analysis) id_ref_group,
                               nvl(ard.flg_prn, pk_alert_constant.g_no) flg_sos,
                               decode(ard.flg_status,
                                      pk_lab_tests_constant.g_analysis_result,
                                      l_flg_outdated,
                                      pk_lab_tests_constant.g_analysis_read,
                                      l_flg_outdated,
                                      l_flg_not_outdated) flg_outdated,
                               ard.id_exam_cat id_group_import,
                               'EXAM_CAT.CODE_EXAM_CAT.' || ard.id_exam_cat code_group,
                               ard.id_order_recurrence id_task_aggregator,
                               decode(ard.flg_status,
                                      pk_lab_tests_constant.g_analysis_result,
                                      pk_prog_notes_constants.g_task_finalized_f,
                                      pk_lab_tests_constant.g_analysis_read,
                                      pk_prog_notes_constants.g_task_finalized_f,
                                      pk_prog_notes_constants.g_task_ongoing_o) flg_ongoing,
                               pk_alert_constant.g_yes flg_normal,
                               decode(ard.id_order_recurrence,
                                      NULL,
                                      coalesce(h.id_prof_harvest, csh.id_prof_ordered_by, ar.id_prof_writes),
                                      NULL) id_prof_exec,
                               h.flg_status flg_status_h,
                               pk_alert_constant.g_no flg_has_comments,
                               nvl(ard.dt_last_update_tstz, ar.dt_req_tstz) dt_last_update,
                               ard.id_sample_type id_sample_type,
                               'SAMPLE_TYPE.CODE_SAMPLE_TYPE.' || ard.id_sample_type code_desc_sample_type,
                               NULL id_sub_group_import,
                               NULL code_desc_sub_group,
                               ais.flg_category_type,
                               CASE
                                    WHEN pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ard.id_exam_cat) IS NOT NULL THEN
                                     'EXAM_CAT.CODE_EXAM_CAT.' ||
                                     pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ard.id_exam_cat)
                                    ELSE
                                     NULL
                                END code_desc_group_parent,
                               standard_hash(ard.flg_urgency || '|' || ard.flg_time_harvest || '|' || ard.dt_target_tstz || '|' ||
                                             ard.flg_prn --|| '|' ||
                                             --ard.id_order_recurrence 
                                            ,
                                             'MD5') instructions_hash,
                               row_number() over(PARTITION BY ard.id_analysis_req_det ORDER BY h.dt_harvest_tstz DESC NULLS LAST) rn
                          FROM analysis_req_det ard
                         INNER JOIN analysis_req ar
                            ON ard.id_analysis_req = ar.id_analysis_req
                          LEFT JOIN co_sign_hist csh
                            ON (ard.id_co_sign_order = csh.id_co_sign_hist)
                         INNER JOIN analysis a
                            ON ard.id_analysis = a.id_analysis
                          LEFT JOIN (SELECT *
                                      FROM (SELECT ah.id_analysis_req_det,
                                                   ah.id_harvest,
                                                   row_number() over(PARTITION BY id_analysis_req_det ORDER BY id_harvest) rn
                                              FROM analysis_harvest ah
                                             WHERE ah.flg_status = pk_lab_tests_constant.g_active)
                                     WHERE rn = 1) ah
                            ON ard.id_analysis_req_det = ah.id_analysis_req_det
                          LEFT JOIN (SELECT *
                                      FROM (SELECT h.id_harvest,
                                                   h.flg_status,
                                                   h.id_prof_harvest,
                                                   h.dt_harvest_tstz,
                                                   row_number() over(PARTITION BY id_harvest ORDER BY dt_harvest_tstz DESC) rn
                                              FROM harvest h
                                             WHERE h.flg_status IN
                                                   (pk_lab_tests_constant.g_harvest_collected,
                                                    pk_lab_tests_constant.g_harvest_finished,
                                                    pk_lab_tests_constant.g_harvest_rejected,
                                                    pk_lab_tests_constant.g_harvest_transp))
                                     WHERE rn = 1) h
                            ON ah.id_harvest = h.id_harvest
                         INNER JOIN episode e
                            ON coalesce(ar.id_episode, ar.id_episode_origin, ar.id_episode_destination) = e.id_episode
                          LEFT JOIN analysis_instit_soft ais
                            ON ais.id_analysis = ard.id_analysis
                           AND ais.id_sample_type = ard.id_sample_type
                           AND ais.flg_available = pk_lab_tests_constant.g_available
                           AND ais.flg_type = pk_lab_tests_constant.g_analysis_can_req
                           AND ais.id_institution = l_prof.institution
                           AND ais.id_software = l_prof.software
                         WHERE ard.flg_status != pk_lab_tests_constant.g_analysis_predefined
                           AND e.id_episode = i_episode
                           AND e.flg_status != pk_alert_constant.g_epis_status_cancel) t
                 WHERE t.rn = 1 log errors INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
        END IF;
    END admin_task_tl_analysis_ea;

    PROCEDURE admin_task_tl_analysis_res_ea(i_episode IN NUMBER DEFAULT NULL) IS
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        l_flg_outdated                 CONSTANT task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_not_outdated             CONSTANT task_timeline_ea.flg_outdated%TYPE := 0;
        l_analy_res_status_final_f     CONSTANT result_status.value%TYPE := 'F';
        l_analy_res_status_fix_final_c CONSTANT result_status.value%TYPE := 'C';
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    BEGIN
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_lab_results',
                              object_name     => g_package_name,
                              sub_object_name => 'ADMIN_TASK_TL_ANALYSIS_RES_EA');
        IF NOT
            pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => NULL,
                                                          i_episode     => i_episode,
                                                          i_institution => NULL,
                                                          i_start_dt    => NULL,
                                                          i_end_dt      => NULL,
                                                          i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_lab_results)) -- ANALYSIS RESULTS TASK ONLY
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_episode IS NULL
        THEN
            FOR i IN (SELECT id_episode
                        FROM episode)
            LOOP
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     dt_execution,
                     id_group_import,
                     code_desc_group,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     universal_desc_clob,
                     dt_last_update,
                     id_sample_type,
                     id_sub_group_import,
                     code_desc_sample_type,
                     code_desc_sub_group,
                     flg_relevant,
                     id_task_related,
                     code_desc_group_parent)
                    SELECT id_task_refid,
                           pk_prog_notes_constants.g_task_lab_results, --analysis results task TYPE 
                           id_patient,
                           id_episode,
                           id_visit,
                           id_institution,
                           dt_req,
                           id_prof_req,
                           flg_status_res_arp,
                           code_description,
                           pk_alert_constant.g_tl_table_name_analysis_res,
                           pk_alert_constant.g_tl_oriented_visit, --visit oriented 
                           l_current_timestamp,
                           flg_outdated,
                           dt_execution,
                           id_group_import,
                           code_desc_group,
                           flg_ongoing,
                           flg_normal,
                           id_prof_exec,
                           flg_has_comments,
                           universal_desc_clob,
                           dt_last_update,
                           id_sample_type,
                           id_sub_group_import,
                           code_desc_sample_type,
                           code_desc_sub_group,
                           flg_relevant,
                           id_analysis_req_det,
                           code_desc_group_parent
                      FROM (SELECT arp.id_analysis_result_par id_task_refid,
                                   ares.id_analysis_req_det,
                                   epis.id_patient,
                                   epis.id_episode,
                                   epis.id_visit,
                                   ares.id_institution,
                                   coalesce(h.dt_harvest_tstz, ares.dt_sample, ares.dt_analysis_result_tstz) dt_req,
                                   nvl(arp.id_professional_upd, arp.id_professional) id_prof_req,
                                   'ANALYSIS_PARAMETER.CODE_ANALYSIS_PARAMETER.' || arp.id_analysis_parameter code_description,
                                   decode(nvl(ares.flg_status, pk_lab_tests_constant.g_active),
                                          pk_lab_tests_constant.g_active,
                                          decode(rs.value,
                                                 l_analy_res_status_final_f,
                                                 l_flg_outdated,
                                                 l_analy_res_status_fix_final_c,
                                                 l_flg_outdated,
                                                 l_flg_not_outdated),
                                          l_flg_outdated) flg_outdated,
                                   ares.id_exam_cat id_group_import,
                                   'EXAM_CAT.CODE_EXAM_CAT.' || ares.id_exam_cat code_desc_group,
                                   h.dt_harvest_tstz dt_execution,
                                   h.flg_status flg_status_harvest,
                                   ares.flg_status flg_status_res,
                                   rs.value flg_status_res_arp,
                                   decode(nvl(ares.flg_status, pk_lab_tests_constant.g_active),
                                          pk_lab_tests_constant.g_active,
                                          decode(rs.value,
                                                 l_analy_res_status_final_f,
                                                 pk_prog_notes_constants.g_task_finalized_f,
                                                 l_analy_res_status_fix_final_c,
                                                 pk_prog_notes_constants.g_task_finalized_f,
                                                 pk_prog_notes_constants.g_task_ongoing_o),
                                          pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                                   CASE
                                        WHEN dbms_lob.getlength(arp.desc_analysis_result) < 4000
                                             AND
                                             pk_utils.is_number(arp.desc_analysis_result) = pk_lab_tests_constant.g_yes THEN
                                         CASE
                                             WHEN pk_lab_tests_external_api_db.is_lab_result_outside_params(NULL,
                                                                                                            NULL,
                                                                                                            'I',
                                                                                                            arp.desc_analysis_result,
                                                                                                            arp.analysis_result_value,
                                                                                                            arp.ref_val_min) =
                                                  pk_alert_constant.g_yes THEN
                                              pk_alert_constant.g_no
                                             WHEN pk_lab_tests_external_api_db.is_lab_result_outside_params(NULL,
                                                                                                            NULL,
                                                                                                            'A',
                                                                                                            arp.desc_analysis_result,
                                                                                                            arp.analysis_result_value,
                                                                                                            arp.ref_val_max) =
                                                  pk_alert_constant.g_yes THEN
                                              pk_alert_constant.g_no
                                             ELSE
                                              pk_alert_constant.g_yes
                                         END
                                        ELSE
                                         pk_alert_constant.g_yes
                                    END flg_normal,
                                   coalesce(arp.id_professional_upd, arp.id_professional, ares.id_professional) id_prof_exec,
                                   CASE
                                        WHEN arp.notes_doctor_registry IS NULL
                                             OR dbms_lob.compare(arp.notes_doctor_registry, empty_clob()) = 0 THEN
                                         pk_alert_constant.g_no
                                        ELSE
                                         pk_alert_constant.g_yes
                                    END flg_has_comments,
                                   arp.notes_doctor_registry universal_desc_clob,
                                   coalesce(arp.dt_doctor_registry_tstz,
                                            arp.dt_analysis_result_par_upd,
                                            ares.dt_analysis_result_tstz) dt_last_update,
                                   ares.id_sample_type id_sample_type,
                                   'SAMPLE_TYPE.CODE_SAMPLE_TYPE.' || ares.id_sample_type code_desc_sample_type,
                                   ares.id_analysis id_sub_group_import,
                                   'ANALYSIS.CODE_ANALYSIS.' || ares.id_analysis code_desc_sub_group,
                                   arp.flg_relevant,
                                   CASE
                                        WHEN pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ares.id_exam_cat) IS NOT NULL THEN
                                         'EXAM_CAT.CODE_EXAM_CAT.' ||
                                         pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ares.id_exam_cat)
                                        ELSE
                                         NULL
                                    END code_desc_group_parent
                              FROM analysis_result_par arp
                             INNER JOIN analysis_result ares
                                ON ares.id_analysis_result = arp.id_analysis_result
                             INNER JOIN result_status rs
                                ON arp.id_result_status = rs.id_result_status
                              LEFT OUTER JOIN harvest h
                                ON ares.id_harvest = h.id_harvest
                             INNER JOIN episode epis
                                ON ares.id_episode_orig = epis.id_episode
                               AND epis.flg_status != pk_alert_constant.g_epis_status_cancel
                             WHERE nvl(ares.flg_status, pk_lab_tests_constant.g_active) = pk_lab_tests_constant.g_active
                               AND arp.id_professional_cancel IS NULL
                               AND epis.id_episode = i.id_episode) log errors
                      INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
            END LOOP;
        ELSE
            INSERT INTO task_timeline_ea
                (id_task_refid,
                 id_tl_task,
                 id_patient,
                 id_episode,
                 id_visit,
                 id_institution,
                 dt_req,
                 id_prof_req,
                 flg_status_req,
                 code_description,
                 table_name,
                 flg_show_method,
                 dt_dg_last_update,
                 flg_outdated,
                 dt_execution,
                 id_group_import,
                 code_desc_group,
                 flg_ongoing,
                 flg_normal,
                 id_prof_exec,
                 flg_has_comments,
                 universal_desc_clob,
                 dt_last_update,
                 id_sample_type,
                 id_sub_group_import,
                 code_desc_sample_type,
                 code_desc_sub_group,
                 flg_relevant,
                 id_task_related,
                 code_desc_group_parent)
                SELECT id_task_refid,
                       pk_prog_notes_constants.g_task_lab_results, --analysis results task TYPE 
                       id_patient,
                       id_episode,
                       id_visit,
                       id_institution,
                       dt_req,
                       id_prof_req,
                       flg_status_res_arp,
                       code_description,
                       pk_alert_constant.g_tl_table_name_analysis_res,
                       pk_alert_constant.g_tl_oriented_visit, --visit oriented 
                       l_current_timestamp,
                       flg_outdated,
                       dt_execution,
                       id_group_import,
                       code_desc_group,
                       flg_ongoing,
                       flg_normal,
                       id_prof_exec,
                       flg_has_comments,
                       universal_desc_clob,
                       dt_last_update,
                       id_sample_type,
                       id_sub_group_import,
                       code_desc_sample_type,
                       code_desc_sub_group,
                       flg_relevant,
                       id_analysis_req_det,
                       code_desc_group_parent
                  FROM (SELECT arp.id_analysis_result_par id_task_refid,
                               ares.id_analysis_req_det,
                               epis.id_patient,
                               epis.id_episode,
                               epis.id_visit,
                               ares.id_institution,
                               coalesce(h.dt_harvest_tstz, ares.dt_sample, ares.dt_analysis_result_tstz) dt_req,
                               nvl(arp.id_professional_upd, arp.id_professional) id_prof_req,
                               'ANALYSIS_PARAMETER.CODE_ANALYSIS_PARAMETER.' || arp.id_analysis_parameter code_description,
                               decode(nvl(ares.flg_status, pk_lab_tests_constant.g_active),
                                      pk_lab_tests_constant.g_active,
                                      decode(rs.value,
                                             l_analy_res_status_final_f,
                                             l_flg_outdated,
                                             l_analy_res_status_fix_final_c,
                                             l_flg_outdated,
                                             l_flg_not_outdated),
                                      l_flg_outdated) flg_outdated,
                               ares.id_exam_cat id_group_import,
                               'EXAM_CAT.CODE_EXAM_CAT.' || ares.id_exam_cat code_desc_group,
                               h.dt_harvest_tstz dt_execution,
                               h.flg_status flg_status_harvest,
                               ares.flg_status flg_status_res,
                               rs.value flg_status_res_arp,
                               decode(nvl(ares.flg_status, pk_lab_tests_constant.g_active),
                                      pk_lab_tests_constant.g_active,
                                      decode(rs.value,
                                             l_analy_res_status_final_f,
                                             pk_prog_notes_constants.g_task_finalized_f,
                                             l_analy_res_status_fix_final_c,
                                             pk_prog_notes_constants.g_task_finalized_f,
                                             pk_prog_notes_constants.g_task_ongoing_o),
                                      pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                               CASE
                                    WHEN dbms_lob.getlength(arp.desc_analysis_result) < 4000
                                         AND pk_utils.is_number(arp.desc_analysis_result) = pk_lab_tests_constant.g_yes THEN
                                     CASE
                                         WHEN pk_lab_tests_external_api_db.is_lab_result_outside_params(NULL,
                                                                                                        NULL,
                                                                                                        'I',
                                                                                                        arp.desc_analysis_result,
                                                                                                        arp.analysis_result_value,
                                                                                                        arp.ref_val_min) =
                                              pk_alert_constant.g_yes THEN
                                          pk_alert_constant.g_no
                                         WHEN pk_lab_tests_external_api_db.is_lab_result_outside_params(NULL,
                                                                                                        NULL,
                                                                                                        'A',
                                                                                                        arp.desc_analysis_result,
                                                                                                        arp.analysis_result_value,
                                                                                                        arp.ref_val_max) =
                                              pk_alert_constant.g_yes THEN
                                          pk_alert_constant.g_no
                                         ELSE
                                          pk_alert_constant.g_yes
                                     END
                                    ELSE
                                     pk_alert_constant.g_yes
                                END flg_normal,
                               coalesce(arp.id_professional_upd, arp.id_professional, ares.id_professional) id_prof_exec,
                               CASE
                                    WHEN arp.notes_doctor_registry IS NULL
                                         OR dbms_lob.compare(arp.notes_doctor_registry, empty_clob()) = 0 THEN
                                     pk_alert_constant.g_no
                                    ELSE
                                     pk_alert_constant.g_yes
                                END flg_has_comments,
                               arp.notes_doctor_registry universal_desc_clob,
                               coalesce(arp.dt_doctor_registry_tstz,
                                        arp.dt_analysis_result_par_upd,
                                        ares.dt_analysis_result_tstz) dt_last_update,
                               ares.id_sample_type id_sample_type,
                               'SAMPLE_TYPE.CODE_SAMPLE_TYPE.' || ares.id_sample_type code_desc_sample_type,
                               ares.id_analysis id_sub_group_import,
                               'ANALYSIS.CODE_ANALYSIS.' || ares.id_analysis code_desc_sub_group,
                               arp.flg_relevant,
                               CASE
                                    WHEN pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ares.id_exam_cat) IS NOT NULL THEN
                                     'EXAM_CAT.CODE_EXAM_CAT.' ||
                                     pk_lab_tests_utils.get_lab_test_category(l_lang, l_prof, ares.id_exam_cat)
                                    ELSE
                                     NULL
                                END code_desc_group_parent
                          FROM analysis_result_par arp
                         INNER JOIN analysis_result ares
                            ON ares.id_analysis_result = arp.id_analysis_result
                         INNER JOIN result_status rs
                            ON arp.id_result_status = rs.id_result_status
                          LEFT OUTER JOIN harvest h
                            ON ares.id_harvest = h.id_harvest
                         INNER JOIN episode epis
                            ON ares.id_episode_orig = epis.id_episode
                           AND epis.flg_status != pk_alert_constant.g_epis_status_cancel
                         WHERE nvl(ares.flg_status, pk_lab_tests_constant.g_active) = pk_lab_tests_constant.g_active
                           AND arp.id_professional_cancel IS NULL
                           AND epis.id_episode = i_episode) log errors
                  INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
        END IF;
    
    END admin_task_tl_analysis_res_ea;

    PROCEDURE admin_task_tl_exams_ea(i_episode IN NUMBER DEFAULT NULL) IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        l_flg_outdated     task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_not_outdated task_timeline_ea.flg_outdated%TYPE := 0;
    
    BEGIN
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_img_exams_req and g_task_other_exams_req',
                              object_name     => g_package_name,
                              sub_object_name => 'ADMIN_TASK_TL_EXAMS_EA');
        IF NOT
            pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => NULL,
                                                          i_episode     => i_episode,
                                                          i_institution => NULL,
                                                          i_start_dt    => NULL,
                                                          i_end_dt      => NULL,
                                                          i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_img_exams_req,
                                                                                        pk_prog_notes_constants.g_task_other_exams_req)) -- EXAMS TASKS ONLY
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_episode IS NULL
        THEN
            FOR i IN (SELECT id_episode
                        FROM episode)
            LOOP
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     dt_dg_last_update,
                     id_group_import,
                     code_desc_group,
                     rank,
                     id_ref_group,
                     flg_sos,
                     flg_outdated,
                     id_task_aggregator,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_technical,
                     id_task_related)
                    SELECT id_exam_req_det,
                           id_tl_task, -- EXAMS TASKS TYPE
                           id_patient,
                           id_episode,
                           id_visit,
                           id_institution,
                           dt_req_tstz,
                           id_prof_req,
                           nvl(dt_pend_req_tstz, dt_begin_tstz),
                           dt_end,
                           flg_status_erd,
                           pk_ea_logic_exams.get_exam_status_str_det(l_lang,
                                                                     l_prof,
                                                                     id_episode,
                                                                     flg_time,
                                                                     flg_status_erd,
                                                                     flg_referral,
                                                                     NULL,
                                                                     dt_req_tstz,
                                                                     dt_pend_req_tstz,
                                                                     dt_begin_tstz) status_str,
                           pk_ea_logic_exams.get_exam_status_msg_det(l_lang,
                                                                     l_prof,
                                                                     id_episode,
                                                                     flg_time,
                                                                     flg_status_erd,
                                                                     flg_referral,
                                                                     NULL,
                                                                     dt_req_tstz,
                                                                     dt_pend_req_tstz,
                                                                     dt_begin_tstz) status_msg,
                           pk_ea_logic_exams.get_exam_status_icon_det(l_lang,
                                                                      l_prof,
                                                                      id_episode,
                                                                      flg_time,
                                                                      flg_status_erd,
                                                                      flg_referral,
                                                                      NULL,
                                                                      dt_req_tstz,
                                                                      dt_pend_req_tstz,
                                                                      dt_begin_tstz) status_icon,
                           pk_ea_logic_exams.get_exam_status_flg_det(l_lang,
                                                                     l_prof,
                                                                     id_episode,
                                                                     flg_time,
                                                                     flg_status_erd,
                                                                     flg_referral,
                                                                     NULL,
                                                                     dt_req_tstz,
                                                                     dt_pend_req_tstz,
                                                                     dt_begin_tstz) status_flg,
                           code_exam,
                           universal_desc_clob,
                           pk_alert_constant.g_tl_table_name_exams,
                           pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                           flg_type_viewer,
                           l_current_timestamp,
                           id_exam_cat,
                           code_group,
                           rank,
                           id_ref_group,
                           flg_sos,
                           flg_outdated,
                           id_task_aggregator,
                           flg_ongoing,
                           flg_normal,
                           id_prof_exec,
                           flg_has_comments,
                           dt_last_update,
                           flg_technical,
                           id_exam_req_det
                      FROM (SELECT /*+ use_nl(erd er ex) */
                             erd.id_exam_req_det,
                             er.dt_req_tstz,
                             nvl(er.dt_pend_req_tstz, er.dt_begin_tstz) dt_begin_tstz,
                             er.flg_time,
                             erd.flg_status flg_status_erd,
                             erd.flg_referral,
                             er.id_prof_req,
                             er.id_episode_origin,
                             er.dt_pend_req_tstz,
                             ep.id_patient,
                             er.id_episode,
                             v.id_visit,
                             er.id_prev_episode,
                             er.priority,
                             er.id_exam_group,
                             pk_alert_constant.g_flg_type_viewer_exams flg_type_viewer,
                             
                             NULL dt_end,
                             er.id_institution,
                             ex.code_exam code_exam,
                             NULL universal_desc_clob,
                             ex.id_exam_cat,
                             'EXAM_CAT.CODE_EXAM_CAT.' || ex.id_exam_cat code_group,
                             NULL rank,
                             decode(erd.id_order_recurrence, NULL, NULL, erd.id_exam) id_ref_group,
                             nvl(erd.flg_prn, pk_alert_constant.g_no) flg_sos,
                             decode(erd.flg_status,
                                    pk_exam_constant.g_exam_result,
                                    l_flg_outdated,
                                    pk_exam_constant.g_exam_read,
                                    l_flg_outdated,
                                    pk_alert_constant.g_exam_det_pend, -- pendent ('D')
                                    l_flg_outdated,
                                    pk_alert_constant.g_exam_det_tosched, -- not yet schedule ('PA')
                                    l_flg_outdated,
                                    l_flg_not_outdated) flg_outdated,
                             erd.id_order_recurrence id_task_aggregator,
                             CASE
                                  WHEN erd.flg_status IN (pk_exam_constant.g_exam_result, pk_exam_constant.g_exam_read) THEN
                                   pk_prog_notes_constants.g_task_finalized_f
                                  WHEN erd.flg_status IN (pk_grid.g_exam_req_tosched, pk_grid.g_exam_req_sched) THEN
                                   pk_prog_notes_constants.g_task_pending_d
                                  WHEN erd.flg_status = pk_alert_constant.g_exam_det_pend THEN
                                   CASE
                                       WHEN er.flg_time = pk_alert_constant.g_flg_time_e THEN
                                        pk_prog_notes_constants.g_task_ongoing_o
                                       ELSE
                                        pk_prog_notes_constants.g_task_pending_d
                                   END
                                  ELSE
                                   pk_prog_notes_constants.g_task_ongoing_o
                              END flg_ongoing,
                             pk_alert_constant.g_yes flg_normal,
                             decode(erd.id_order_recurrence, NULL, erd.id_prof_performed, NULL) id_prof_exec,
                             pk_alert_constant.g_no flg_has_comments,
                             nvl(erd.dt_performed_reg, er.dt_req_tstz) dt_last_update,
                             CASE
                                  WHEN ex.flg_type = pk_exam_constant.g_type_img THEN
                                   pk_prog_notes_constants.g_task_img_exams_req
                                  ELSE
                                   pk_prog_notes_constants.g_task_other_exams_req
                              END id_tl_task,
                             ex.flg_technical
                              FROM exam_req_det erd
                              JOIN exam_req er
                                ON erd.id_exam_req = er.id_exam_req
                             INNER JOIN episode ep
                                ON ((coalesce(er.id_episode, er.id_episode_origin, er.id_episode_destination) =
                                   ep.id_episode) AND ep.flg_status != pk_alert_constant.g_epis_status_cancel)
                              JOIN visit v
                                ON ep.id_visit = v.id_visit
                              JOIN exam ex
                                ON erd.id_exam = ex.id_exam
                             WHERE erd.flg_status NOT IN (pk_exam_constant.g_exam_predefined,
                                                          pk_exam_constant.g_exam_cancel,
                                                          pk_exam_constant.g_exam_nr)
                               AND ep.id_episode = i.id_episode) log errors
                      INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
            END LOOP;
        ELSE
            INSERT INTO task_timeline_ea
                (id_task_refid,
                 id_tl_task,
                 id_patient,
                 id_episode,
                 id_visit,
                 id_institution,
                 dt_req,
                 id_prof_req,
                 dt_begin,
                 dt_end,
                 flg_status_req,
                 status_str,
                 status_msg,
                 status_icon,
                 status_flg,
                 code_description,
                 universal_desc_clob,
                 table_name,
                 flg_show_method,
                 flg_type_viewer,
                 dt_dg_last_update,
                 id_group_import,
                 code_desc_group,
                 rank,
                 id_ref_group,
                 flg_sos,
                 flg_outdated,
                 id_task_aggregator,
                 flg_ongoing,
                 flg_normal,
                 id_prof_exec,
                 flg_has_comments,
                 dt_last_update,
                 flg_technical,
                 id_task_related)
                SELECT id_exam_req_det,
                       id_tl_task, -- EXAMS TASKS TYPE
                       id_patient,
                       id_episode,
                       id_visit,
                       id_institution,
                       dt_req_tstz,
                       id_prof_req,
                       nvl(dt_pend_req_tstz, dt_begin_tstz),
                       dt_end,
                       flg_status_erd,
                       pk_ea_logic_exams.get_exam_status_str_det(l_lang,
                                                                 l_prof,
                                                                 id_episode,
                                                                 flg_time,
                                                                 flg_status_erd,
                                                                 flg_referral,
                                                                 NULL,
                                                                 dt_req_tstz,
                                                                 dt_pend_req_tstz,
                                                                 dt_begin_tstz) status_str,
                       pk_ea_logic_exams.get_exam_status_msg_det(l_lang,
                                                                 l_prof,
                                                                 id_episode,
                                                                 flg_time,
                                                                 flg_status_erd,
                                                                 flg_referral,
                                                                 NULL,
                                                                 dt_req_tstz,
                                                                 dt_pend_req_tstz,
                                                                 dt_begin_tstz) status_msg,
                       pk_ea_logic_exams.get_exam_status_icon_det(l_lang,
                                                                  l_prof,
                                                                  id_episode,
                                                                  flg_time,
                                                                  flg_status_erd,
                                                                  flg_referral,
                                                                  NULL,
                                                                  dt_req_tstz,
                                                                  dt_pend_req_tstz,
                                                                  dt_begin_tstz) status_icon,
                       pk_ea_logic_exams.get_exam_status_flg_det(l_lang,
                                                                 l_prof,
                                                                 id_episode,
                                                                 flg_time,
                                                                 flg_status_erd,
                                                                 flg_referral,
                                                                 NULL,
                                                                 dt_req_tstz,
                                                                 dt_pend_req_tstz,
                                                                 dt_begin_tstz) status_flg,
                       code_exam,
                       universal_desc_clob,
                       pk_alert_constant.g_tl_table_name_exams,
                       pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                       flg_type_viewer,
                       l_current_timestamp,
                       id_exam_cat,
                       code_group,
                       rank,
                       id_ref_group,
                       flg_sos,
                       flg_outdated,
                       id_task_aggregator,
                       flg_ongoing,
                       flg_normal,
                       id_prof_exec,
                       flg_has_comments,
                       dt_last_update,
                       flg_technical,
                       id_exam_req_det
                  FROM (SELECT erd.id_exam_req_det,
                               er.dt_req_tstz,
                               nvl(er.dt_pend_req_tstz, er.dt_begin_tstz) dt_begin_tstz,
                               er.flg_time,
                               erd.flg_status flg_status_erd,
                               erd.flg_referral,
                               er.id_prof_req,
                               er.id_episode_origin,
                               er.dt_pend_req_tstz,
                               ep.id_patient,
                               er.id_episode,
                               v.id_visit,
                               er.id_prev_episode,
                               er.priority,
                               er.id_exam_group,
                               pk_alert_constant.g_flg_type_viewer_exams flg_type_viewer,
                               
                               NULL dt_end,
                               er.id_institution,
                               ex.code_exam code_exam,
                               NULL universal_desc_clob,
                               ex.id_exam_cat,
                               'EXAM_CAT.CODE_EXAM_CAT.' || ex.id_exam_cat code_group,
                               NULL rank,
                               decode(erd.id_order_recurrence, NULL, NULL, erd.id_exam) id_ref_group,
                               nvl(erd.flg_prn, pk_alert_constant.g_no) flg_sos,
                               decode(erd.flg_status,
                                      pk_exam_constant.g_exam_result,
                                      l_flg_outdated,
                                      pk_exam_constant.g_exam_read,
                                      l_flg_outdated,
                                      pk_alert_constant.g_exam_det_pend, -- pendent ('D')
                                      l_flg_outdated,
                                      pk_alert_constant.g_exam_det_tosched, -- not yet schedule ('PA')
                                      l_flg_outdated,
                                      l_flg_not_outdated) flg_outdated,
                               erd.id_order_recurrence id_task_aggregator,
                               CASE
                                    WHEN erd.flg_status IN (pk_exam_constant.g_exam_result, pk_exam_constant.g_exam_read) THEN
                                     pk_prog_notes_constants.g_task_finalized_f
                                    WHEN erd.flg_status IN (pk_grid.g_exam_req_tosched, pk_grid.g_exam_req_sched) THEN
                                     pk_prog_notes_constants.g_task_pending_d
                                    WHEN erd.flg_status = pk_alert_constant.g_exam_det_pend THEN
                                     CASE
                                         WHEN er.flg_time = pk_alert_constant.g_flg_time_e THEN
                                          pk_prog_notes_constants.g_task_ongoing_o
                                         ELSE
                                          pk_prog_notes_constants.g_task_pending_d
                                     END
                                    ELSE
                                     pk_prog_notes_constants.g_task_ongoing_o
                                END flg_ongoing,
                               pk_alert_constant.g_yes flg_normal,
                               decode(erd.id_order_recurrence, NULL, erd.id_prof_performed, NULL) id_prof_exec,
                               pk_alert_constant.g_no flg_has_comments,
                               nvl(erd.dt_performed_reg, er.dt_req_tstz) dt_last_update,
                               CASE
                                    WHEN ex.flg_type = pk_exam_constant.g_type_img THEN
                                     pk_prog_notes_constants.g_task_img_exams_req
                                    ELSE
                                     pk_prog_notes_constants.g_task_other_exams_req
                                END id_tl_task,
                               ex.flg_technical
                          FROM exam_req_det erd
                          JOIN exam_req er
                            ON erd.id_exam_req = er.id_exam_req
                         INNER JOIN episode ep
                            ON ((coalesce(er.id_episode, er.id_episode_origin, er.id_episode_destination) =
                               ep.id_episode) AND ep.flg_status != pk_alert_constant.g_epis_status_cancel)
                          JOIN visit v
                            ON ep.id_visit = v.id_visit
                          JOIN exam ex
                            ON erd.id_exam = ex.id_exam
                         WHERE erd.flg_status NOT IN (pk_exam_constant.g_exam_predefined,
                                                      pk_exam_constant.g_exam_cancel,
                                                      pk_exam_constant.g_exam_nr)
                           AND (ep.id_episode = i_episode)) log errors
                  INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
        END IF;
    END admin_task_tl_exams_ea;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with exams results tasks
    *
    * @param       i_patient                  Patient identifier
    * @param       i_episode                  Episode identifier
    * @value       i_schedule                 Shcedule identifier
    * @param       i_external_request         P1 (referral) identifier
    * @param       i_institution              Institution identifier
    * @param       i_start_dt                 Start date to be consider to the validation/reconstruction of data
    * @param       i_end_dt                   End date to be consider to the validation/reconstruction of data
    * @param       i_validate_table           Indicates necessary to validate data existent in easy access table
    * @param       i_output_invalid_records   Show final (resumed) information about updated statistics
    * @param       i_recreate_table           Indicates necessary to rebuild data existent in easy access table
    * @param       i_commit_step              Number of registries between commit's
    *
    * @return                                 TRUE if sucess, FALSE otherwise
    *
    * @author                                 António Neto
    * @version                                2.6.2
    * @since                                  09-Jan-2012
    ********************************************************************************************/
    PROCEDURE admin_task_tl_exams_res_ea
    (
        i_episode        IN NUMBER DEFAULT NULL,
        i_flg_split_task VARCHAR2 DEFAULT 'N'
    ) IS
    
        l_lang language.id_language%TYPE := 1;
        l_prof profissional := get_prof;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
    
        l_flg_outdated     task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_not_outdated task_timeline_ea.flg_outdated%TYPE := 0;
    
        l_count_invalid NUMBER := 0;
    
        l_res_status_final_f CONSTANT result_status.value%TYPE := 'F';
    
    BEGIN
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_exam_results',
                              object_name     => g_package_name,
                              sub_object_name => 'ADMIN_TASK_TL_EXAMS_RES_EA');
        IF NOT
            pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => NULL,
                                                          i_episode     => i_episode,
                                                          i_institution => NULL,
                                                          i_start_dt    => NULL,
                                                          i_end_dt      => NULL,
                                                          i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_exam_results,
                                                                                        pk_prog_notes_constants.g_task_img_exam_results,
                                                                                        pk_prog_notes_constants.g_task_oth_exam_results)) -- EXAMS RESULTS TASKS ONLY
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_episode IS NULL
        THEN
            FOR i IN (SELECT id_episode
                        FROM episode)
            LOOP
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_type_viewer,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     dt_execution,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     universal_desc_clob,
                     dt_last_update,
                     flg_technical,
                     id_task_related)
                    SELECT id_exam_result,
                           CASE
                               WHEN i_flg_split_task = pk_prog_notes_constants.g_yes THEN
                                CASE
                                    WHEN flg_type = pk_exam_constant.g_type_img THEN
                                     pk_prog_notes_constants.g_task_img_exam_results
                                    ELSE
                                     pk_prog_notes_constants.g_task_oth_exam_results
                                END
                               ELSE
                                alert.pk_prog_notes_constants.g_task_exam_results
                           END,
                           id_patient,
                           id_episode,
                           id_visit,
                           id_institution,
                           dt_exam_result_tstz,
                           id_professional,
                           flg_status_res,
                           pk_alert_constant.g_tl_table_name_exams_res,
                           pk_alert_constant.g_tl_oriented_visit, -- visit oriented 
                           l_current_timestamp,
                           flg_type_viewer,
                           flg_outdated,
                           id_exam_cat,
                           code_group,
                           pk_alert_constant.g_no, -- prn / sos 
                           start_time,
                           flg_ongoing,
                           flg_normal,
                           id_prof_exec,
                           flg_has_comments,
                           universal_desc_clob,
                           dt_last_update,
                           flg_technical,
                           id_exam_req_det
                      FROM (SELECT /*+ use_nl(erd erq er e) */
                             row_number() over(PARTITION BY er.id_exam_result ORDER BY er.dt_exam_result_tstz DESC) rn,
                             er.id_exam_result,
                             er.id_exam_req_det,
                             er.dt_exam_result_tstz,
                             rs.value flg_status_res,
                             nvl(er.id_prof_read, er.id_professional) id_professional,
                             decode(rs.value,
                                    l_res_status_final_f,
                                    pk_ea_logic_tasktimeline.g_flg_outdated,
                                    pk_exam_constant.g_exam_result_cancel,
                                    pk_ea_logic_tasktimeline.g_flg_outdated,
                                    pk_ea_logic_tasktimeline.g_flg_not_outdated) flg_outdated,
                             er.id_prof_cancel,
                             ep.id_patient,
                             ep.id_episode,
                             ep.id_visit,
                             pk_alert_constant.g_flg_type_viewer_exams flg_type_viewer,
                             er.id_institution,
                             e.id_exam_cat,
                             'EXAM_CAT.CODE_EXAM_CAT.' || e.id_exam_cat code_group,
                             e.id_exam,
                             'EXAM.CODE_EXAM.' || e.id_exam code_desc_sub_group,
                             erd.start_time,
                             decode(nvl(er.flg_status, pk_exam_constant.g_exam_result_active),
                                    pk_exam_constant.g_exam_result_active,
                                    decode(rs.value,
                                           l_res_status_final_f,
                                           pk_prog_notes_constants.g_task_finalized_f,
                                           pk_exam_constant.g_exam_result_cancel,
                                           pk_prog_notes_constants.g_task_finalized_f,
                                           pk_prog_notes_constants.g_task_ongoing_o),
                                    pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                             pk_alert_constant.g_yes flg_normal,
                             er.id_professional id_prof_exec,
                             CASE
                                  WHEN er.notes_result IS NULL
                                       OR dbms_lob.compare(er.notes_result, empty_clob()) = 0 THEN
                                   pk_alert_constant.g_no
                                  ELSE
                                   pk_alert_constant.g_yes
                              END flg_has_comments,
                             er.notes_result universal_desc_clob,
                             nvl(er.dt_prof_read_tstz, er.dt_exam_result_tstz) dt_last_update,
                             e.flg_technical,
                             e.flg_type
                              FROM exam_result er
                             INNER JOIN exam e
                                ON (er.id_exam = e.id_exam)
                             INNER JOIN exam_req_det erd
                                ON erd.id_exam_req_det = er.id_exam_req_det
                             INNER JOIN exam_req erq
                                ON erd.id_exam_req = erq.id_exam_req
                              LEFT JOIN result_status rs
                                ON rs.id_result_status = er.id_result_status
                             INNER JOIN episode ep
                                ON nvl(erq.id_episode_origin, erq.id_episode) = ep.id_episode
                               AND ep.flg_status != pk_alert_constant.g_epis_status_cancel
                             INNER JOIN visit v
                                ON (ep.id_visit = v.id_visit)
                             WHERE nvl(er.flg_status, pk_exam_constant.g_exam_result_active) =
                                   pk_exam_constant.g_exam_result_active
                               AND erd.id_prof_cancel IS NULL
                               AND ep.id_episode = i.id_episode)
                     WHERE rn = 1 log errors INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
            END LOOP;
        ELSE
            INSERT INTO task_timeline_ea
                (id_task_refid,
                 id_tl_task,
                 id_patient,
                 id_episode,
                 id_visit,
                 id_institution,
                 dt_req,
                 id_prof_req,
                 flg_status_req,
                 table_name,
                 flg_show_method,
                 dt_dg_last_update,
                 flg_type_viewer,
                 flg_outdated,
                 id_group_import,
                 code_desc_group,
                 flg_sos,
                 dt_execution,
                 flg_ongoing,
                 flg_normal,
                 id_prof_exec,
                 flg_has_comments,
                 universal_desc_clob,
                 dt_last_update,
                 flg_technical,
                 id_task_related)
                SELECT id_exam_result,
                       CASE
                           WHEN i_flg_split_task = pk_prog_notes_constants.g_yes THEN
                            CASE
                                WHEN flg_type = pk_exam_constant.g_type_img THEN
                                 pk_prog_notes_constants.g_task_img_exam_results
                                ELSE
                                 pk_prog_notes_constants.g_task_oth_exam_results
                            END
                           ELSE
                            pk_prog_notes_constants.g_task_exam_results
                       END,
                       id_patient,
                       id_episode,
                       id_visit,
                       id_institution,
                       dt_exam_result_tstz,
                       id_professional,
                       flg_status_res,
                       pk_alert_constant.g_tl_table_name_exams_res,
                       pk_alert_constant.g_tl_oriented_visit, -- visit oriented 
                       l_current_timestamp,
                       flg_type_viewer,
                       flg_outdated,
                       id_exam_cat,
                       code_group,
                       pk_alert_constant.g_no, -- prn / sos 
                       start_time,
                       flg_ongoing,
                       flg_normal,
                       id_prof_exec,
                       flg_has_comments,
                       universal_desc_clob,
                       dt_last_update,
                       flg_technical,
                       id_exam_req_det
                  FROM (SELECT row_number() over(PARTITION BY er.id_exam_result ORDER BY er.dt_exam_result_tstz DESC) rn,
                               er.id_exam_result,
                               er.id_exam_req_det,
                               er.dt_exam_result_tstz,
                               rs.value flg_status_res,
                               nvl(er.id_prof_read, er.id_professional) id_professional,
                               decode(rs.value,
                                      l_res_status_final_f,
                                      pk_ea_logic_tasktimeline.g_flg_outdated,
                                      pk_exam_constant.g_exam_result_cancel,
                                      pk_ea_logic_tasktimeline.g_flg_outdated,
                                      pk_ea_logic_tasktimeline.g_flg_not_outdated) flg_outdated,
                               er.id_prof_cancel,
                               ep.id_patient,
                               ep.id_episode,
                               ep.id_visit,
                               pk_alert_constant.g_flg_type_viewer_exams flg_type_viewer,
                               er.id_institution,
                               e.id_exam_cat,
                               'EXAM_CAT.CODE_EXAM_CAT.' || e.id_exam_cat code_group,
                               e.id_exam,
                               'EXAM.CODE_EXAM.' || e.id_exam code_desc_sub_group,
                               erd.start_time,
                               decode(nvl(er.flg_status, pk_exam_constant.g_exam_result_active),
                                      pk_exam_constant.g_exam_result_active,
                                      decode(rs.value,
                                             l_res_status_final_f,
                                             pk_prog_notes_constants.g_task_finalized_f,
                                             pk_exam_constant.g_exam_result_cancel,
                                             pk_prog_notes_constants.g_task_finalized_f,
                                             pk_prog_notes_constants.g_task_ongoing_o),
                                      pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                               pk_alert_constant.g_yes flg_normal,
                               er.id_professional id_prof_exec,
                               CASE
                                    WHEN er.notes_result IS NULL
                                         OR dbms_lob.compare(er.notes_result, empty_clob()) = 0 THEN
                                     pk_alert_constant.g_no
                                    ELSE
                                     pk_alert_constant.g_yes
                                END flg_has_comments,
                               er.notes_result universal_desc_clob,
                               nvl(er.dt_prof_read_tstz, er.dt_exam_result_tstz) dt_last_update,
                               e.flg_technical,
                               e.flg_type
                          FROM exam_result er
                         INNER JOIN exam e
                            ON (er.id_exam = e.id_exam)
                         INNER JOIN exam_req_det erd
                            ON erd.id_exam_req_det = er.id_exam_req_det
                         INNER JOIN exam_req erq
                            ON erd.id_exam_req = erq.id_exam_req
                          LEFT JOIN result_status rs
                            ON rs.id_result_status = er.id_result_status
                         INNER JOIN episode ep
                            ON nvl(erq.id_episode_origin, erq.id_episode) = ep.id_episode
                           AND ep.flg_status != pk_alert_constant.g_epis_status_cancel
                         INNER JOIN visit v
                            ON (ep.id_visit = v.id_visit)
                         WHERE nvl(er.flg_status, pk_exam_constant.g_exam_result_active) =
                               pk_exam_constant.g_exam_result_active
                           AND erd.id_prof_cancel IS NULL
                           AND ep.id_episode = i_episode)
                 WHERE rn = 1 log errors INTO err$_task_timeline_ea(to_char(SYSDATE)) reject LIMIT unlimited;
        END IF;
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_task_timeline_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001, 'Unspecified errors. Check table err$_task_timeline_ea.');
    END admin_task_tl_exams_res_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with procedure tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.2
    * @since    2009/04/20
    ********************************************************************************************/
    FUNCTION admin_task_tl_proced_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROCED_EA';
        l_count                NUMBER := 0;
        l_count_invalid        NUMBER := 0;
        l_notes                procedures_ea.flg_notes%TYPE;
        l_id_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
        l_flg_status_ipp       interv_presc_plan.flg_status%TYPE;
        l_dt_plan_tstz         interv_presc_plan.dt_plan_tstz%TYPE;
        l_id_speciality        spec_sys_appar.id_speciality%TYPE;
        l_id_system_apparati   spec_sys_appar.id_system_apparati%TYPE;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_lang             language.id_language%TYPE := 1;
        l_status_str       task_timeline_ea.status_str%TYPE;
        l_status_msg       task_timeline_ea.status_msg%TYPE;
        l_status_icon      task_timeline_ea.status_icon%TYPE;
        l_status_flg       task_timeline_ea.status_flg%TYPE;
        l_flg_outdated     task_timeline_ea.flg_outdated%TYPE;
        l_flg_has_comments VARCHAR2(1 CHAR);
        l_error            t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_procedures',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_procedures)) -- PROCEDURES TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT ip.id_interv_prescription,
                           ipd.id_interv_presc_det,
                           ipd.id_intervention,
                           ip.flg_status flg_status_ip,
                           ipd.flg_status flg_status_ipd,
                           ip.flg_time,
                           ipd.flg_prn,
                           ip.dt_begin_tstz dt_begin_tstz_ip,
                           nvl(ipp.dt_plan_tstz, ipd.dt_begin_tstz) dt_begin_tstz_ipd,
                           ip.dt_interv_prescription_tstz,
                           ip.id_professional id_prof_requested,
                           ipd.code_intervention_alias,
                           ip.id_episode_origin,
                           e.id_visit,
                           ip.id_episode,
                           nvl(ip.id_patient, e.id_patient) id_patient,
                           ipd.flg_referral,
                           nvl(cs.dt_ordered_by, ipd.dt_interv_presc_det) dt_order,
                           pk_alert_constant.g_flg_type_viewer_proced flg_type_viewer,
                           orp.id_order_recurr_option,
                           --
                           ip.id_institution,
                           ipd.dt_end_tstz,
                           i.code_intervention,
                           NULL universal_desc_clob,
                           decode(ipd.flg_status,
                                  pk_alert_constant.g_interv_det_fin,
                                  pk_prog_notes_constants.g_task_finalized_f,
                                  pk_alert_constant.g_interv_det_cancel,
                                  pk_prog_notes_constants.g_task_finalized_f,
                                  pk_prog_notes_constants.g_task_ongoing_o) flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           ipp.id_prof_take id_prof_exec,
                           nvl((SELECT MAX(ea.dt_dg_last_update)
                                 FROM procedures_ea ea
                                WHERE ea.id_interv_presc_det = ipd.id_interv_presc_det),
                               ip.dt_interv_prescription_tstz) dt_last_update,
                           decode(ipd.flg_prn, pk_alert_constant.g_yes, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_sos,
                           (SELECT MAX(ippp.start_time)
                              FROM interv_presc_plan ippp
                             WHERE ippp.flg_status IN
                                   (pk_alert_constant.g_interv_plan_admt, pk_alert_constant.g_interv_det_fin)
                               AND ippp.id_interv_presc_det = ipd.id_interv_presc_det) dt_last_execution,
                           i.flg_technical,
                           ipd.dt_end_tstz dt_execution,
                           1 rank,
                           i.flg_category_type
                      FROM interv_presc_det ipd
                      JOIN intervention i
                        ON ipd.id_intervention = i.id_intervention
                      JOIN interv_prescription ip
                        ON ipd.id_interv_prescription = ip.id_interv_prescription
                      LEFT JOIN interv_presc_plan ipp
                        ON ipp.id_interv_presc_det = ipd.id_interv_presc_det
                     INNER JOIN episode e
                        ON ((nvl(ip.id_episode, nvl(ip.id_episode_destination, ip.id_episode_origin)) = e.id_episode) AND
                           e.flg_status <> pk_alert_constant.g_epis_status_cancel)
                      LEFT JOIN order_recurr_plan orp
                        ON ipd.id_order_recurrence = orp.id_order_recurr_plan
                      LEFT JOIN co_sign_hist cs
                        ON ipd.id_co_sign_order = cs.id_co_sign_hist
                     WHERE (ipp.id_interv_presc_plan IS NULL OR
                           ipp.id_interv_presc_plan =
                           (SELECT MAX(ipp1.id_interv_presc_plan)
                               FROM interv_presc_plan ipp1
                              WHERE ipp1.id_interv_presc_det = ipd.id_interv_presc_det))
                       AND ((i_institution IS NOT NULL AND ip.id_institution = i_institution) OR i_institution IS NULL)
                       AND e.flg_status NOT IN
                           (pk_alert_constant.g_epis_status_cancel, pk_alert_constant.g_epis_status_inactive)
                       AND ((i_patient IS NOT NULL AND ip.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND ip.id_episode = i_episode) OR i_episode IS NULL)
                       AND (ipd.dt_begin_tstz >= i_start_dt OR i_start_dt IS NULL)
                       AND (ipd.dt_begin_tstz <= i_end_dt OR i_end_dt IS NULL)
                       AND ipd.flg_status NOT IN (pk_procedures_constant.g_interv_cancel, -- Cancelled ('C')
                                                  pk_procedures_constant.g_interv_expired,
                                                  pk_procedures_constant.g_interv_draft,
                                                  pk_procedures_constant.g_interv_not_ordered))
        LOOP
            l_notes                := NULL;
            l_id_interv_presc_plan := NULL;
            l_flg_status_ipp       := NULL;
            l_dt_plan_tstz         := NULL;
            l_id_speciality        := NULL;
            l_id_system_apparati   := NULL;
            l_status_str           := NULL;
            l_status_msg           := NULL;
            l_status_icon          := NULL;
            l_status_flg           := NULL;
        
            BEGIN
                SELECT id_interv_presc_plan, flg_status, dt_plan_tstz
                  INTO l_id_interv_presc_plan, l_flg_status_ipp, l_dt_plan_tstz
                  FROM (SELECT ipp.id_interv_presc_plan, ipp.flg_status, ipp.dt_plan_tstz
                          FROM interv_presc_plan ipp
                         WHERE ipp.id_interv_presc_det = rec.id_interv_presc_det
                           AND ipp.id_interv_presc_plan =
                               (SELECT MAX(ipp1.id_interv_presc_plan)
                                  FROM interv_presc_plan ipp1
                                 WHERE ipp1.id_interv_presc_det = rec.id_interv_presc_det)
                         ORDER BY ipp.id_interv_presc_plan DESC)
                 WHERE rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        
            --check if it has comments
            BEGIN
                SELECT pk_alert_constant.g_yes
                  INTO l_flg_has_comments
                  FROM treatment_management tm
                 WHERE tm.id_treatment = rec.id_interv_presc_det
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_flg_has_comments := pk_alert_constant.g_no;
            END;
        
            --
            BEGIN
                --Obtains status info
                pk_ea_logic_procedures.get_procedure_status(i_lang                   => l_lang,
                                                            i_prof                   => l_prof,
                                                            i_episode                => rec.id_episode,
                                                            i_flg_time               => rec.flg_time,
                                                            i_flg_status_det         => rec.flg_status_ipd,
                                                            i_flg_prn                => rec.flg_prn,
                                                            i_flg_referral           => rec.flg_referral,
                                                            i_dt_interv_prescription => rec.dt_interv_prescription_tstz,
                                                            i_dt_begin_req           => rec.dt_begin_tstz_ip,
                                                            i_dt_plan                => l_dt_plan_tstz,
                                                            i_order_recurr_option    => rec.id_order_recurr_option,
                                                            o_status_str             => l_status_str,
                                                            o_status_msg             => l_status_msg,
                                                            o_status_icon            => l_status_icon,
                                                            o_status_flg             => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    dbms_output.put_line(SQLERRM);
                    RAISE e_external;
            END;
        
            IF rec.flg_status_ipd IN (pk_alert_constant.g_interv_det_req, -- Required ('R')
                                      -- LMAIA 08-06-2009 Comment because this tasks don't have start date (despite they be represented in normal GRID's)
                                      pk_alert_constant.g_interv_det_pend, -- pendent ('D')
                                      pk_alert_constant.g_interv_det_exec, -- in execution ('E')
                                      pk_alert_constant.g_interv_det_schedule, -- schedule ('A')
                                      pk_alert_constant.g_interv_det_ext, -- exterior ('X')
                                      pk_alert_constant.g_interv_det_partial) -- Partial results ('P')
            THEN
                l_flg_outdated := 0;
            ELSE
                l_flg_outdated := 1;
            END IF;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_sos,
                     dt_last_execution,
                     flg_technical,
                     dt_execution,
                     rank,
                     flg_type)
                VALUES
                    (rec.id_interv_presc_det,
                     pk_prog_notes_constants.g_task_procedures, -- PROCEDURES TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     nvl(rec.dt_order, rec.dt_interv_prescription_tstz),
                     rec.id_prof_requested,
                     rec.dt_begin_tstz_ipd,
                     rec.dt_end_tstz,
                     rec.flg_status_ipd,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_intervention,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_procedur,
                     pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                     rec.flg_type_viewer,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     l_flg_has_comments,
                     rec.dt_last_update,
                     rec.flg_sos,
                     rec.dt_last_execution,
                     rec.flg_technical,
                     rec.dt_execution,
                     rec.rank,
                     rec.flg_category_type);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_sos,
                     dt_last_execution,
                     flg_technical,
                     dt_execution,
                     rank,
                     flg_type)
                VALUES
                    (rec.id_interv_presc_det,
                     pk_prog_notes_constants.g_task_procedures, -- PROCEDURES TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     nvl(rec.dt_order, rec.dt_interv_prescription_tstz),
                     rec.id_prof_requested,
                     rec.dt_begin_tstz_ipd,
                     rec.dt_end_tstz,
                     rec.flg_status_ipd,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_intervention,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_procedur,
                     pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                     rec.flg_type_viewer,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     l_flg_has_comments,
                     rec.dt_last_update,
                     rec.flg_sos,
                     rec.dt_last_execution,
                     rec.flg_technical,
                     rec.dt_execution,
                     rec.rank,
                     rec.flg_category_type);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (a.flg_type_viewer <> b.flg_type_viewer OR
                                (a.flg_type_viewer IS NULL AND b.flg_type_viewer IS NOT NULL) OR
                                (a.flg_type_viewer IS NOT NULL AND b.flg_type_viewer IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                                --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                                --
                                (a.flg_technical <> b.flg_technical OR
                                (a.flg_technical IS NULL AND b.flg_technical IS NOT NULL) OR
                                (a.flg_technical IS NOT NULL AND b.flg_technical IS NULL)) OR
                                --
                                (a.dt_execution <> b.dt_execution OR
                                (a.dt_execution IS NULL AND b.dt_execution IS NOT NULL) OR
                                (a.dt_execution IS NOT NULL AND b.dt_execution IS NULL))))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_procedures
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.flg_type_viewer     = t.flg_type_viewer,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_outdated        = t.flg_outdated,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update,
                       tt_ea.flg_sos             = t.flg_sos,
                       tt_ea.dt_last_execution   = t.dt_last_execution,
                       tt_ea.flg_technical       = t.flg_technical,
                       tt_ea.dt_execution        = t.dt_execution,
                       tt_ea.rank                = t.rank,
                       tt_ea.flg_type            = t.flg_type
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_sos,
                     dt_last_execution,
                     flg_technical,
                     dt_execution,
                     rank,
                     flg_type)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     t.flg_type_viewer,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.flg_sos,
                     t.dt_last_execution,
                     t.flg_technical,
                     t.dt_execution,
                     t.rank,
                     t.flg_type);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_proced_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_proced_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROCED_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROCED_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROCED_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_proced_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with monitorizations tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.2
    * @since    2009/04/21
    ********************************************************************************************/
    FUNCTION admin_task_tl_monit_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_MONIT_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid             NUMBER := 0;
        l_count                     NUMBER := 0;
        l_id_monitorization_vs_plan monitorization_vs_plan.id_monitorization_vs_plan%TYPE;
        l_flg_status_plan           monitorization_vs_plan.flg_status%TYPE;
        l_dt_plan_tstz              monitorization_vs_plan.dt_plan_tstz%TYPE;
        l_current_timestamp         TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type           data_gov_invalid_recs.validation_type%TYPE;
    
        --        l_prof        profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_monitoring',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_monitoring)) -- MONITORIZATIONS TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT mvs.id_monitorization_vs,
                           mvs.flg_status           flg_status_det,
                           m.flg_time,
                           m.dt_monitorization_tstz,
                           m.id_episode_origin,
                           mvsp.dt_plan_tstz        dt_begin,
                           m.dt_end_tstz            dt_end,
                           e.id_visit,
                           m.id_episode,
                           e.id_patient,
                           --
                           m.id_professional,
                           mvs.dt_order,
                           mvs.dt_monitorization_vs_tstz,
                           e.id_institution id_institution,
                           vs.code_vital_sign,
                           NULL universal_desc_clob,
                           m.id_monitorization,
                           CASE mvs.flg_status
                               WHEN pk_alert_constant.g_monitor_vs_fini THEN
                                pk_prog_notes_constants.g_task_finalized_f
                               WHEN pk_alert_constant.g_monitor_vs_pend THEN
                                pk_prog_notes_constants.g_task_pending_d
                               ELSE
                                pk_prog_notes_constants.g_task_ongoing_o
                           END flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           pk_alert_constant.g_no flg_has_comments,
                           coalesce((SELECT MAX(mvp_tstz.end_time)
                                      FROM monitorization_vs_plan mvp_tstz
                                     WHERE mvp_tstz.id_monitorization_vs = mvs.id_monitorization_vs
                                       AND mvp_tstz.end_time IS NOT NULL),
                                    mvs.dt_monitorization_vs_tstz,
                                    m.dt_monitorization_tstz) dt_last_update
                      FROM monitorization m
                      JOIN monitorization_vs mvs
                        ON mvs.id_monitorization = m.id_monitorization
                      JOIN episode e
                        ON e.id_episode = m.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                      JOIN vital_sign vs
                        ON vs.id_vital_sign = mvs.id_vital_sign
                      JOIN monitorization_vs_plan mvsp
                        ON mvsp.id_monitorization_vs = mvs.id_monitorization_vs
                       AND mvsp.id_monitorization_vs_plan =
                           (SELECT MAX(id_monitorization_vs_plan)
                              FROM monitorization_vs_plan mvp1
                             WHERE mvp1.id_monitorization_vs = mvs.id_monitorization_vs
                               AND mvp1.flg_status IN
                                   (pk_alert_constant.g_monitor_vs_exec, pk_alert_constant.g_monitor_vs_pend))
                     WHERE ((i_patient IS NOT NULL AND e.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND m.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND e.id_institution = i_institution) OR i_institution IS NULL)
                       AND EXISTS (SELECT 1
                              FROM monitorization_vs_plan mvp
                             WHERE mvp.id_monitorization_vs = mvs.id_monitorization_vs
                               AND (mvp.dt_plan_tstz >= i_start_dt OR i_start_dt IS NULL)
                               AND (mvp.dt_plan_tstz <= i_end_dt OR i_end_dt IS NULL))
                          --
                       AND mvs.flg_status IN (pk_alert_constant.g_monitor_vs_pend, -- pendent ('D')
                                              pk_alert_constant.g_monitor_vs_exec) -- in execution ('A')
                    --AND m.flg_time IN (pk_alert_constant.g_flg_time_e)
                    )
        LOOP
            -- Get details
            g_error := 'GET DETAILS';
            BEGIN
                SELECT id_monitorization_vs_plan, dt_plan_tstz, flg_status
                  INTO l_id_monitorization_vs_plan, l_dt_plan_tstz, l_flg_status_plan
                  FROM (SELECT mvp.id_monitorization_vs_plan, mvp.dt_plan_tstz, mvp.flg_status
                          FROM monitorization_vs_plan mvp
                         WHERE mvp.id_monitorization_vs = rec.id_monitorization_vs
                           AND mvp.dt_plan_tstz =
                               (SELECT MAX(mvp1.dt_plan_tstz)
                                  FROM monitorization_vs_plan mvp1
                                 WHERE mvp1.id_monitorization_vs = rec.id_monitorization_vs)
                         ORDER BY mvp.id_monitorization_vs_plan DESC)
                 WHERE rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    dbms_output.put_line(rec.id_monitorization_vs || '-' || SQLERRM);
                    NULL;
            END;
        
            g_error := 'GET_LOGIC_STATUS';
            BEGIN
                --Obtains status info
                pk_ea_logic_monitorizations.get_monitorizations_status(i_prof            => l_prof,
                                                                       i_episode_origin  => rec.id_episode_origin,
                                                                       i_flg_time        => rec.flg_time,
                                                                       i_dt_begin        => rec.dt_begin,
                                                                       i_flg_status_det  => rec.flg_status_det,
                                                                       i_flg_status_plan => l_flg_status_plan,
                                                                       i_dt_plan         => l_dt_plan_tstz,
                                                                       o_status_str      => l_status_str,
                                                                       o_status_msg      => l_status_msg,
                                                                       o_status_icon     => l_status_icon,
                                                                       o_status_flg      => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_ref_group,
                     rank,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_monitorization_vs,
                     pk_prog_notes_constants.g_task_monitoring, -- MONITORIZATIONS TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     nvl(rec.dt_order, rec.dt_monitorization_vs_tstz),
                     rec.id_professional,
                     nvl(rec.dt_begin, rec.dt_monitorization_tstz),
                     rec.dt_end,
                     rec.flg_status_det,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_vital_sign,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_monitor,
                     pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                     current_timestamp,
                     rec.id_monitorization,
                     NULL,
                     NULL,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.flg_has_comments,
                     rec.dt_last_update);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_ref_group,
                     rank,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_monitorization_vs,
                     pk_prog_notes_constants.g_task_monitoring, -- MONITORIZATIONS TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     nvl(rec.dt_order, rec.dt_monitorization_vs_tstz),
                     rec.id_professional,
                     nvl(rec.dt_begin, rec.dt_monitorization_tstz),
                     rec.dt_end,
                     rec.flg_status_det,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_vital_sign,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_monitor,
                     pk_alert_constant.g_tl_oriented_visit, -- VISIT ORIENTED
                     current_timestamp,
                     rec.id_monitorization,
                     NULL,
                     NULL,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.flg_has_comments,
                     rec.dt_last_update);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.id_ref_group <> b.id_ref_group OR
                                (a.id_ref_group IS NULL AND b.id_ref_group IS NOT NULL) OR
                                (a.id_ref_group IS NOT NULL AND b.id_ref_group IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_monitoring
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.id_ref_group        = t.id_ref_group,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_ref_group,
                     rank,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.id_ref_group,
                     NULL,
                     NULL,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_monit_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_monit_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MONIT_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MONIT_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MONIT_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_monit_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with monitorizations tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.2
    * @since    2009/04/22
    ********************************************************************************************/
    FUNCTION admin_task_tl_mov_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_MOV_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid     NUMBER := 0;
        l_count             NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_transports',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_transports)) -- MOVEMENTS TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     mov.id_episode,
                     mov.id_movement,
                     mov.dt_req_tstz dt_req,
                     mov.dt_begin_tstz dt_begin,
                     mov.dt_end_tstz dt_end,
                     mov.flg_status,
                     mov.id_prof_request,
                     epi.id_patient,
                     epi.id_visit,
                     epi.id_institution,
                     NULL universal_desc_clob,
                     'TL_TASK.CODE_TL_TASK.9' code_task,
                     decode(mov.flg_status,
                            pk_alert_constant.g_mov_status_finish,
                            pk_prog_notes_constants.g_task_finalized_f,
                            pk_prog_notes_constants.g_task_ongoing_o) flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     coalesce(mov.id_prof_receive, mov.id_prof_move, mov.id_prof_request) id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments,
                     nvl(mov.dt_end_tstz, mov.dt_req_tstz) dt_last_update
                      FROM movement mov
                     INNER JOIN episode epi
                        ON (epi.id_episode = mov.id_episode AND epi.flg_status <> pk_alert_constant.g_epis_status_cancel)
                     INNER JOIN room ro
                        ON (ro.id_room = mov.id_room_to)
                     INNER JOIN department dep
                        ON (dep.id_department = ro.id_department)
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epi.id_episode
                     WHERE mov.dt_req_tstz >= nvl(i_start_dt, mov.dt_req_tstz)
                       AND mov.dt_req_tstz <= nvl(i_end_dt, mov.dt_req_tstz)
                       AND mov.flg_status IN (pk_alert_constant.g_mov_status_req, -- Required ('R') 
                                              pk_alert_constant.g_mov_status_pend, -- pendent ('P') 
                                              pk_alert_constant.g_mov_status_transp)) -- In Transport ('T')
        LOOP
        
            g_error := 'GET_LOGIC_STATUS';
        
            BEGIN
                --Obtains status info
                pk_logic_movements.get_movement_status(i_prof        => l_prof,
                                                       i_dt_req      => rec.dt_req,
                                                       i_dt_begin    => rec.dt_begin,
                                                       i_dt_end      => rec.dt_end,
                                                       i_flg_status  => rec.flg_status,
                                                       o_status_str  => l_status_str,
                                                       o_status_msg  => l_status_msg,
                                                       o_status_icon => l_status_icon,
                                                       o_status_flg  => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_movement,
                     pk_prog_notes_constants.g_task_transports, -- MOVEMENTS TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_transp,
                     pk_alert_constant.g_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_last_update);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_movement,
                     pk_prog_notes_constants.g_task_transports, -- MOVEMENTS TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_transp,
                     pk_alert_constant.g_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_last_update);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_transports
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_mov_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_mov_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MOV_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MOV_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MOV_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_mov_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with discharge schedule information
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.3
    * @since    2009/05/25
    ********************************************************************************************/
    FUNCTION admin_task_tl_dischar_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_DISCHAR_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid     NUMBER := 0;
        l_count             NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_prev_dischage_dt',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_prev_dischage_dt)) -- DISCHARGE SCHEDULE TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     ds.id_episode,
                     ds.id_discharge_schedule,
                     ds.create_time dt_req,
                     ds.dt_discharge_schedule dt_begin,
                     NULL dt_end,
                     ds.flg_status,
                     ds.id_prof_req id_prof_request,
                     ds.id_patient,
                     epi.id_visit,
                     epi.id_institution,
                     NULL universal_desc_clob,
                     'TL_TASK.CODE_TL_TASK.12' code_task,
                     pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments
                      FROM discharge_schedule ds
                     INNER JOIN episode epi
                        ON (epi.id_episode = ds.id_episode AND
                           epi.flg_status NOT IN
                           (pk_alert_constant.g_epis_status_cancel, pk_alert_constant.g_epis_status_inactive))
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epi.id_episode
                     WHERE ds.dt_req >= nvl(i_start_dt, ds.dt_req)
                       AND ds.dt_req <= nvl(i_end_dt, ds.dt_req)
                       AND ds.flg_status IN (pk_alert_constant.g_disch_sched_status_yes)) -- Active date ('A')
        
        LOOP
        
            g_error := 'GET_LOGIC_STATUS';
        
            BEGIN
                --Obtains status info
                pk_logic_discharge_sched.get_sched_disch_status(i_prof        => l_prof,
                                                                i_dt_req      => rec.dt_req,
                                                                i_dt_begin    => rec.dt_begin,
                                                                i_flg_status  => rec.flg_status,
                                                                o_status_str  => l_status_str,
                                                                o_status_msg  => l_status_msg,
                                                                o_status_icon => l_status_icon,
                                                                o_status_flg  => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_discharge_schedule,
                     pk_prog_notes_constants.g_task_prev_dischage_dt, -- DICHARGE SCHEDULE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_disch,
                     pk_alert_constant.g_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_begin);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_discharge_schedule,
                     pk_prog_notes_constants.g_task_prev_dischage_dt, -- DICHARGE SCHEDULE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_disch,
                     pk_alert_constant.g_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_begin);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_prev_dischage_dt
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        
            --COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
        --COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        --COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_dischar_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_dischar_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DISCHAR_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DISCHAR_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DISCHAR_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_dischar_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with surgery episode information
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.3
    * @since    2009/05/25
    ********************************************************************************************/
    FUNCTION admin_task_tl_surgery_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_SURGERY_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid     NUMBER := 0;
        l_count             NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_surgery',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_surgery)) -- SURGERY EPISODE TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT epi.id_episode,
                           epi.dt_creation dt_req,
                           ss.dt_target_tstz dt_begin,
                           epi.dt_end_tstz dt_end,
                           epi.flg_status,
                           nvl(ei.id_prof_schedules, ei.id_professional) id_prof_request,
                           epi.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           epi.id_epis_type,
                           NULL universal_desc_clob,
                           'TL_TASK.CODE_TL_TASK.10' code_task,
                           pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           NULL id_prof_exec,
                           pk_alert_constant.g_no flg_has_comments
                      FROM episode epi
                     INNER JOIN schedule_sr ss
                        ON (ss.id_episode = epi.id_episode)
                     INNER JOIN epis_info ei
                        ON (ei.id_episode = epi.id_episode)
                     WHERE ((i_patient IS NOT NULL AND epi.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND (epi.dt_creation >= i_start_dt OR i_start_dt IS NULL)
                       AND (epi.dt_creation <= i_end_dt OR i_end_dt IS NULL)
                          --
                       AND epi.flg_status NOT IN
                           (pk_alert_constant.g_epis_status_cancel, pk_alert_constant.g_epis_status_inactive)
                       AND (ss.dt_target_tstz IS NOT NULL AND
                           ss.dt_target_tstz >= pk_date_utils.trunc_insttimezone(l_prof, current_timestamp, NULL))
                       AND epi.id_epis_type = pk_alert_constant.g_epis_type_operating) -- Surgery episodes
        LOOP
        
            g_error := 'GET_LOGIC_STATUS';
        
            BEGIN
                --Obtains status info
                pk_logic_episode.get_episode_status(i_prof         => l_prof,
                                                    i_dt_req       => rec.dt_req,
                                                    i_dt_begin     => rec.dt_begin,
                                                    i_flg_status   => rec.flg_status,
                                                    i_id_epis_type => pk_alert_constant.g_epis_type_operating,
                                                    o_status_str   => l_status_str,
                                                    o_status_msg   => l_status_msg,
                                                    o_status_icon  => l_status_icon,
                                                    o_status_flg   => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_episode,
                     pk_prog_notes_constants.g_task_surgery, -- SURGERY EPISODE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_surg,
                     pk_alert_constant.g_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_begin);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_episode,
                     pk_prog_notes_constants.g_task_surgery, -- SURGERY EPISODE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_surg,
                     pk_alert_constant.g_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_begin);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_surgery
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        
            --COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
        --COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        --COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_surgery_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_surgery_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SURGERY_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SURGERY_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SURGERY_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_surgery_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with inpatient episode information
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.3
    * @since    2009/05/25
    ********************************************************************************************/
    FUNCTION admin_task_tl_inp_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_INP_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid     NUMBER := 0;
        l_count             NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
        l_prof profissional := get_prof;
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline pk_prog_notes_constants.g_task_schedule_inp',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_schedule_inp)) -- INPATIENT EPISODE TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT epi.id_episode,
                           epi.dt_creation dt_req,
                           decode(epi.flg_ehr,
                                  pk_alert_constant.g_epis_ehr_normal,
                                  epi.dt_begin_tstz,
                                  nvl(pk_schedule_inp.get_sch_dt_begin(NULL, NULL, epi.id_episode), epi.dt_begin_tstz)) dt_begin,
                           NULL dt_end,
                           epi.flg_status,
                           nvl(ei.id_prof_schedules, ei.id_professional) id_prof_request,
                           epi.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           epi.id_epis_type,
                           NULL universal_desc_clob,
                           'TL_TASK.CODE_TL_TASK.11' code_task,
                           pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           NULL id_prof_exec,
                           pk_alert_constant.g_no flg_has_comments
                      FROM episode epi
                     INNER JOIN epis_info ei
                        ON (ei.id_episode = epi.id_episode)
                     WHERE ((i_patient IS NOT NULL AND epi.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND (epi.dt_creation >= i_start_dt OR i_start_dt IS NULL)
                       AND (epi.dt_creation <= i_end_dt OR i_end_dt IS NULL)
                          --
                       AND epi.id_prev_episode IS NOT NULL -- Main episodes should not be visible in Task Timeline
                       AND epi.id_epis_type = pk_alert_constant.g_epis_type_inpatient -- Inpatient episodes
                       AND epi.flg_status = pk_alert_constant.g_epis_status_active -- Active ('A')
                       AND ((epi.flg_ehr = pk_alert_constant.g_epis_ehr_normal AND
                           epi.dt_begin_tstz >= pk_date_utils.trunc_insttimezone(l_prof, current_timestamp, NULL)) OR
                           (epi.flg_ehr = pk_alert_constant.g_epis_ehr_schedule AND
                           pk_schedule_inp.get_sch_dt_begin(NULL, NULL, epi.id_episode) >=
                           pk_date_utils.trunc_insttimezone(l_prof, current_timestamp, NULL))))
        LOOP
        
            g_error := 'GET_LOGIC_STATUS';
        
            BEGIN
                --Obtains status info
                pk_logic_episode.get_episode_status(i_prof         => l_prof,
                                                    i_dt_req       => rec.dt_req,
                                                    i_dt_begin     => rec.dt_begin,
                                                    i_flg_status   => rec.flg_status,
                                                    i_id_epis_type => pk_alert_constant.g_epis_type_inpatient,
                                                    o_status_str   => l_status_str,
                                                    o_status_msg   => l_status_msg,
                                                    o_status_icon  => l_status_icon,
                                                    o_status_flg   => l_status_flg);
            
            EXCEPTION
                WHEN OTHERS THEN
                    RAISE e_external;
            END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments)
                VALUES
                    (rec.id_episode,
                     pk_prog_notes_constants.g_task_schedule_inp, -- INPATIENT EPISODE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_sche_inp,
                     pk_alert_constant.g_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments)
                VALUES
                    (rec.id_episode,
                     pk_prog_notes_constants.g_task_schedule_inp, -- INPATIENT EPISODE TASKS TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     nvl(rec.dt_begin, rec.dt_req),
                     rec.dt_end,
                     rec.flg_status,
                     l_status_str,
                     l_status_msg,
                     l_status_icon,
                     l_status_flg,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_alert_constant.g_tl_table_name_sche_inp,
                     pk_alert_constant.g_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL))))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_schedule_inp
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments);
        
            --COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
        --COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        --COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_inp_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_inp_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INP_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INP_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INP_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_inp_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with medication tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Pedro Teixeira
    * @version  2.6.1.2
    * @since    2011/08/26
    ********************************************************************************************/
    FUNCTION admin_task_tl_medication_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_MEDICATION_EA';
        l_count             NUMBER := 0;
        l_count_skiped      NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_lang    language.id_language%TYPE := g_log_lang;
        l_id_prof professional.id_professional%TYPE := pk_sysconfig.get_config(i_code_cf   => 'ID_PROF_BACKGROUND',
                                                                               i_prof_inst => i_institution,
                                                                               i_prof_soft => 0);
        l_prof    profissional := profissional(l_id_prof, i_institution, 0);
    
        l_error t_error_out;
    
        -- new implementation variables
        c_presc_data pk_types.cursor_type;
        l_func_proc_name CONSTANT user_objects.object_name%TYPE := 'ADMIN_TASK_TL_MEDICATION_EA';
    
        l_new_ttea_rec task_timeline_ea%ROWTYPE;
    
        l_id_presc          table_number := table_number();
        l_id_patient        table_number := table_number();
        l_id_episode        table_number := table_number();
        l_id_institution    table_number := table_number();
        l_dt_req            table_timestamp_tstz := table_timestamp_tstz();
        l_id_prof_req       table_number := table_number();
        l_dt_begin          table_timestamp_tstz := table_timestamp_tstz();
        l_dt_end            table_timestamp_tstz := table_timestamp_tstz();
        l_id_workflow       table_number := table_number();
        l_id_status         table_number := table_number();
        l_universal_desc    table_varchar := table_varchar();
        l_flg_sos           table_varchar := table_varchar();
        l_flg_active        table_varchar := table_varchar();
        l_dt_last_execution table_timestamp_tstz := table_timestamp_tstz();
        l_flg_has_comments  table_varchar := table_varchar();
        l_dt_last_update    table_timestamp_tstz := table_timestamp_tstz();
        l_id_presc_parent   table_number := table_number();
    
        l_flg_calc_active  VARCHAR2(1);
        l_flg_not_outdated task_timeline_ea.flg_outdated%TYPE := 0;
        l_flg_outdated     task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_ongoing      task_timeline_ea.flg_ongoing%TYPE;
        l_flg_chinese      table_varchar := table_varchar();
        l_flg_stat         table_varchar := table_varchar();
        l_flg_type         table_varchar := table_varchar();
    BEGIN
    
        g_error := '***LMAIA inside medication';
        pk_alertlog.log_info(text            => g_error,
                             object_name     => g_package_name,
                             sub_object_name => 'ADMIN_TASK_TL_MEDICATION_EA');
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_id_tl_task_medication and g_task_reported_medic and g_task_amb_medication',
                              object_name     => g_package_name,
                              sub_object_name => l_func_name);
        IF NOT
            pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                          i_episode     => i_episode,
                                                          i_institution => NULL,
                                                          i_start_dt    => i_start_dt,
                                                          i_end_dt      => i_end_dt,
                                                          i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_medic_here,
                                                                                        pk_prog_notes_constants.g_task_reported_medic,
                                                                                        pk_prog_notes_constants.g_task_amb_medication,
                                                                                        pk_prog_notes_constants.g_task_home_med_chinese)) -- MEDICATION TASKS ONLY
        THEN
            RAISE e_internal;
        END IF;
        --END IF;
    
        g_error := 'Before LOOP';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
    
        -- obtain medication prescription data
        /* log: to delete */
        pk_alertlog.log_debug('BEFORE pk_api_pfh_in.get_presc_time_task_line', g_package_name, l_func_proc_name);
    
        pk_api_pfh_in.get_presc_time_task_line(i_lang       => l_lang,
                                               i_prof       => l_prof, --the i_prof is not used in this function, so there is no problem if the sys_config is not defined.
                                               i_id_patient => i_patient,
                                               i_id_episode => i_episode,
                                               o_presc_data => c_presc_data,
                                               o_error      => l_error);
        /* log: to delete */
        pk_alertlog.log_debug('AFTER pk_api_pfh_in.get_presc_time_task_line', g_package_name, l_func_proc_name);
    
        -- fetch presc_data cursor elements
        BEGIN
            g_error := ' FETCH c_presc_data ';
            FETCH c_presc_data BULK COLLECT
                INTO --
                     l_id_presc,
                     l_id_patient,
                     l_id_episode,
                     l_id_institution,
                     l_dt_req,
                     l_id_prof_req,
                     l_dt_begin,
                     l_dt_end,
                     l_id_workflow,
                     l_id_status,
                     l_universal_desc,
                     l_flg_sos,
                     l_flg_active,
                     l_dt_last_execution,
                     l_flg_has_comments,
                     l_dt_last_update,
                     l_id_presc_parent,
                     l_flg_chinese,
                     l_flg_type,
                     l_flg_stat;
            CLOSE c_presc_data;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        IF l_id_presc.count = 0
        THEN
            /* log: to delete */
            pk_alertlog.log_debug('l_id_presc.count = 0 ; no presc found meeting the necessary requirements, so exiting function',
                                  g_package_name,
                                  l_func_proc_name);
            RETURN TRUE;
        END IF;
    
        -- loop through returned presc data
        FOR i IN 1 .. l_id_presc.last
        LOOP
            --pk_alertlog.log_debug('inside loop ' || l_id_presc(i), g_package_name, l_func_proc_name);
            pk_alertlog.log_debug('l_id_presc = ' || l_id_presc(i) || ',l_id_patient = ' || l_id_patient(i) ||
                                  ',l_id_episode = ' || l_id_episode(i),
                                  g_package_name,
                                  l_func_proc_name);
        
            IF l_id_workflow(i) = pk_api_pfh_in.g_wf_report
            THEN
                --Home Medication
            
                --Only Active and Unknown status are to include
                IF l_id_status(i) IN
                   (pk_rt_med_pfh.st_active, pk_rt_med_pfh.st_active_gen_auto, pk_rt_med_pfh.st_unknown)
                THEN
                    l_flg_calc_active           := pk_alert_constant.g_yes;
                    l_new_ttea_rec.flg_outdated := CASE
                                                       WHEN l_flg_active(i) = pk_alert_constant.g_no THEN
                                                        l_flg_outdated
                                                       ELSE
                                                        l_flg_not_outdated
                                                   END;
                ELSE
                    -- if cancelled or discontinued then it's not active
                    l_flg_calc_active           := pk_alert_constant.g_no;
                    l_new_ttea_rec.flg_outdated := l_flg_outdated;
                END IF;
            ELSIF l_id_workflow(i) IN (pk_api_pfh_in.g_wf_institution, pk_api_pfh_in.g_wf_iv)
            THEN
                --Medication and other
            
                --Only status Active (always), Hold, inactive  and Discontinued
                IF l_id_status(i) IN (pk_rt_med_pfh.st_on_going,
                                      pk_rt_med_pfh.st_prescribed_pharm_req,
                                      pk_rt_med_pfh.st_prescribed,
                                      pk_rt_med_pfh.st_suspended,
                                      pk_rt_med_pfh.st_suspended_ongoing,
                                      pk_rt_med_pfh.st_suspended_pharm_req,
                                      pk_rt_med_pfh.st_ongoing_pharm_req,
                                      pk_rt_med_pfh.st_suspended_ongoing_pharm_req,
                                      pk_rt_med_pfh.st_requested,
                                      pk_rt_med_pfh.g_wf_presc_concluded)
                THEN
                    l_flg_calc_active           := pk_alert_constant.g_yes;
                    l_new_ttea_rec.flg_outdated := CASE
                                                       WHEN l_flg_active(i) = pk_alert_constant.g_no THEN
                                                        l_flg_outdated
                                                       ELSE
                                                        l_flg_not_outdated
                                                   END;
                ELSE
                    -- otherwise
                    l_flg_calc_active           := pk_alert_constant.g_no;
                    l_new_ttea_rec.flg_outdated := l_flg_outdated;
                END IF;
            ELSE
                -- Exterior (Ambulatory) Medication
                IF l_id_status(i) <> pk_rt_med_pfh.st_cancelled
                THEN
                    l_flg_calc_active           := pk_alert_constant.g_yes;
                    l_new_ttea_rec.flg_outdated := CASE
                                                       WHEN l_flg_active(i) = pk_alert_constant.g_no THEN
                                                        l_flg_outdated
                                                       ELSE
                                                        l_flg_not_outdated
                                                   END;
                ELSE
                    -- otherwise
                    l_flg_calc_active           := pk_alert_constant.g_no;
                    l_new_ttea_rec.flg_outdated := l_flg_outdated;
                END IF;
            END IF;
        
            IF l_flg_calc_active = pk_alert_constant.g_no
               OR (i_start_dt IS NOT NULL AND l_dt_begin(i) <= i_start_dt)
               OR (i_end_dt IS NOT NULL AND l_dt_end(i) >= i_end_dt)
            THEN
                l_count_skiped := l_count_skiped + 1;
            ELSE
            
                IF l_id_workflow(i) = pk_api_pfh_in.g_wf_report
                THEN
                    IF (l_flg_chinese(i) = pk_alert_constant.g_yes)
                    THEN
                        l_new_ttea_rec.id_tl_task := pk_prog_notes_constants.g_task_home_med_chinese;
                    ELSE
                        l_new_ttea_rec.id_tl_task := pk_prog_notes_constants.g_task_reported_medic;
                    END IF;
                
                    l_flg_ongoing := CASE
                                         WHEN l_id_status(i) IN (pk_rt_med_pfh.st_inactive, pk_rt_med_pfh.st_inactive_gen_auto) THEN
                                          pk_prog_notes_constants.g_task_inactive_i
                                         WHEN l_id_status(i) IN
                                              (pk_rt_med_pfh.st_active, pk_rt_med_pfh.st_active_gen_auto, pk_rt_med_pfh.st_unknown) THEN
                                          pk_prog_notes_constants.g_task_ongoing_o
                                         ELSE
                                          pk_prog_notes_constants.g_task_ongoing_o
                                     END;
                ELSIF l_id_workflow(i) IN (pk_api_pfh_in.g_wf_institution, pk_api_pfh_in.g_wf_iv)
                THEN
                    l_new_ttea_rec.id_tl_task := pk_prog_notes_constants.g_task_medic_here;
                
                    l_flg_ongoing := CASE l_id_status(i)
                                         WHEN pk_rt_med_pfh.st_on_going THEN
                                          pk_prog_notes_constants.g_task_ongoing_o
                                         WHEN pk_rt_med_pfh.st_prescribed THEN
                                          pk_prog_notes_constants.g_task_ongoing_o
                                         WHEN pk_rt_med_pfh.g_wf_presc_concluded THEN
                                          pk_prog_notes_constants.g_task_finalized_f
                                         WHEN pk_rt_med_pfh.st_inactive THEN
                                          pk_prog_notes_constants.g_task_inactive_i
                                         ELSE
                                          pk_prog_notes_constants.g_task_ongoing_o
                                     END;
                ELSE
                    -- Exterior (Ambulatory) Medication
                    l_new_ttea_rec.id_tl_task := pk_prog_notes_constants.g_task_amb_medication;
                
                    l_flg_ongoing := CASE l_id_status(i)
                                         WHEN pk_rt_med_pfh.st_concluded THEN
                                          pk_prog_notes_constants.g_task_finalized_f
                                         ELSE
                                          pk_prog_notes_constants.g_task_ongoing_o
                                     END;
                
                END IF;
                l_new_ttea_rec.id_task_refid        := l_id_presc(i);
                l_new_ttea_rec.id_parent_task_refid := l_id_presc_parent(i);
                l_new_ttea_rec.id_patient           := l_id_patient(i);
                l_new_ttea_rec.id_episode           := l_id_episode(i);
                l_new_ttea_rec.id_visit             := pk_visit.get_visit(l_id_episode(i), l_error);
                l_new_ttea_rec.id_institution       := l_id_institution(i);
                l_new_ttea_rec.dt_req               := l_dt_req(i);
                l_new_ttea_rec.id_prof_req          := l_id_prof_req(i);
                l_new_ttea_rec.dt_begin             := l_dt_begin(i);
                l_new_ttea_rec.dt_end               := l_dt_end(i);
                l_new_ttea_rec.flg_status_req       := l_id_status(i); --l_id_workflow(i) || ' . ' || l_id_status(i);
                l_new_ttea_rec.status_str           := NULL;
                l_new_ttea_rec.status_msg           := NULL;
                l_new_ttea_rec.status_icon          := NULL;
                l_new_ttea_rec.status_flg           := NULL;
                l_new_ttea_rec.code_description     := NULL;
                l_new_ttea_rec.universal_desc_clob  := to_clob(l_universal_desc(i));
                l_new_ttea_rec.table_name           := 'PRESC';
                l_new_ttea_rec.flg_show_method      := pk_alert_constant.g_tl_oriented_visit;
                l_new_ttea_rec.flg_type_viewer      := 'DP';
                l_new_ttea_rec.dt_dg_last_update    := l_current_timestamp;
                l_new_ttea_rec.dt_last_execution    := l_dt_last_execution(i);
                l_new_ttea_rec.flg_has_comments     := l_flg_has_comments(i);
                l_new_ttea_rec.dt_last_update       := l_dt_last_update(i);
            
                l_new_ttea_rec.code_status := 'WF_STATUS.CODE_STATUS.' || l_id_status(i);
                l_new_ttea_rec.flg_sos     := l_flg_sos(i);
                l_new_ttea_rec.flg_ongoing := l_flg_ongoing;
                l_new_ttea_rec.flg_normal  := pk_alert_constant.g_yes;
                l_new_ttea_rec.flg_stat    := l_flg_stat(i);
                l_new_ttea_rec.flg_type    := l_flg_type(i);
            
                --insert in temporary table
                IF i_validate_table
                THEN
                    g_error := 'INSERT INTO task_timeline_ea_tmp with id_task_refid = ' || l_new_ttea_rec.id_task_refid;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => 'ADMIN_TASK_TL_MEDICATION_EA');
                    INSERT INTO task_timeline_ea_tmp
                        (id_task_refid,
                         id_tl_task,
                         id_patient,
                         id_episode,
                         id_visit,
                         id_institution,
                         dt_req,
                         id_prof_req,
                         dt_begin,
                         dt_end,
                         flg_status_req,
                         status_str,
                         status_msg,
                         status_icon,
                         status_flg,
                         code_description,
                         universal_desc_clob,
                         table_name,
                         flg_show_method,
                         flg_type_viewer,
                         dt_dg_last_update,
                         code_status,
                         flg_sos,
                         flg_ongoing,
                         flg_normal,
                         dt_last_execution,
                         flg_has_comments,
                         dt_last_update,
                         id_parent_task_refid)
                    VALUES
                        (l_new_ttea_rec.id_task_refid,
                         l_new_ttea_rec.id_tl_task,
                         l_new_ttea_rec.id_patient,
                         l_new_ttea_rec.id_episode,
                         l_new_ttea_rec.id_visit,
                         l_new_ttea_rec.id_institution,
                         l_new_ttea_rec.dt_req,
                         l_new_ttea_rec.id_prof_req,
                         l_new_ttea_rec.dt_begin,
                         l_new_ttea_rec.dt_end,
                         l_new_ttea_rec.flg_status_req,
                         l_new_ttea_rec.status_str,
                         l_new_ttea_rec.status_msg,
                         l_new_ttea_rec.status_icon,
                         l_new_ttea_rec.status_flg,
                         l_new_ttea_rec.code_description,
                         l_new_ttea_rec.universal_desc_clob,
                         l_new_ttea_rec.table_name,
                         l_new_ttea_rec.flg_show_method,
                         l_new_ttea_rec.flg_type_viewer,
                         l_new_ttea_rec.dt_dg_last_update,
                         l_new_ttea_rec.code_status,
                         l_new_ttea_rec.flg_sos,
                         l_new_ttea_rec.flg_ongoing,
                         l_new_ttea_rec.flg_normal,
                         l_new_ttea_rec.dt_last_execution,
                         l_new_ttea_rec.flg_has_comments,
                         l_new_ttea_rec.dt_last_update,
                         l_new_ttea_rec.id_parent_task_refid);
                END IF;
            
                -- Insert into Easy Access table
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    g_error := 'INSERT INTO task_timeline_ea with id_task_refid = ' || l_new_ttea_rec.id_task_refid;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => 'ADMIN_TASK_TL_MEDICATION_EA');
                    INSERT INTO task_timeline_ea
                        (id_task_refid,
                         id_tl_task,
                         id_patient,
                         id_episode,
                         id_visit,
                         id_institution,
                         dt_req,
                         id_prof_req,
                         dt_begin,
                         dt_end,
                         flg_status_req,
                         status_str,
                         status_msg,
                         status_icon,
                         status_flg,
                         code_description,
                         universal_desc_clob,
                         table_name,
                         flg_show_method,
                         flg_type_viewer,
                         dt_dg_last_update,
                         code_status,
                         flg_sos,
                         flg_ongoing,
                         flg_normal,
                         dt_last_execution,
                         flg_has_comments,
                         dt_last_update,
                         id_parent_task_refid,
                         flg_stat,
                         flg_type)
                    VALUES
                        (l_new_ttea_rec.id_task_refid,
                         l_new_ttea_rec.id_tl_task,
                         l_new_ttea_rec.id_patient,
                         l_new_ttea_rec.id_episode,
                         l_new_ttea_rec.id_visit,
                         l_new_ttea_rec.id_institution,
                         l_new_ttea_rec.dt_req,
                         l_new_ttea_rec.id_prof_req,
                         l_new_ttea_rec.dt_begin,
                         l_new_ttea_rec.dt_end,
                         l_new_ttea_rec.flg_status_req,
                         l_new_ttea_rec.status_str,
                         l_new_ttea_rec.status_msg,
                         l_new_ttea_rec.status_icon,
                         l_new_ttea_rec.status_flg,
                         l_new_ttea_rec.code_description,
                         l_new_ttea_rec.universal_desc_clob,
                         l_new_ttea_rec.table_name,
                         l_new_ttea_rec.flg_show_method,
                         l_new_ttea_rec.flg_type_viewer,
                         l_new_ttea_rec.dt_dg_last_update,
                         l_new_ttea_rec.code_status,
                         l_new_ttea_rec.flg_sos,
                         l_new_ttea_rec.flg_ongoing,
                         l_new_ttea_rec.flg_normal,
                         l_new_ttea_rec.dt_last_execution,
                         l_new_ttea_rec.flg_has_comments,
                         l_new_ttea_rec.dt_last_update,
                         l_new_ttea_rec.id_parent_task_refid,
                         l_new_ttea_rec.flg_stat,
                         l_new_ttea_rec.flg_type);
                END IF;
            
                l_count := l_count + 1;
            END IF;
        END LOOP;
    
        g_error := 'After LOOP';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            g_error := 'The ones that are different';
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (a.flg_type_viewer <> b.flg_type_viewer OR
                                (a.flg_type_viewer IS NULL AND b.flg_type_viewer IS NOT NULL) OR
                                (a.flg_type_viewer IS NOT NULL AND b.flg_type_viewer IS NULL)) OR
                                --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                (a.code_status <> b.code_status OR
                                (a.code_status IS NULL AND b.code_status IS NOT NULL) OR
                                (a.code_status IS NOT NULL AND b.code_status IS NULL)) OR
                                --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_parent_task_refid <> b.id_parent_task_refid OR
                                (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                                (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
                g_error           := 'Recording the ones that are different';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --COMMIT;
        
            g_error := 'The ones that are missing';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                g_error := 'Recording the ones that are missing';
                pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
        
            g_error := 'Merging invalid records';
            pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN
                                  (pk_prog_notes_constants.g_task_medic_here,
                                   pk_prog_notes_constants.g_task_reported_medic,
                                   pk_prog_notes_constants.g_task_amb_medication)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.dt_begin             = t.dt_begin,
                       tt_ea.dt_end               = t.dt_end,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.status_str           = t.status_str,
                       tt_ea.status_msg           = t.status_msg,
                       tt_ea.status_icon          = t.status_icon,
                       tt_ea.status_flg           = t.status_flg,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.flg_type_viewer      = t.flg_type_viewer,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.code_status          = t.code_status,
                       tt_ea.flg_sos              = t.flg_sos,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.dt_last_execution    = t.dt_last_execution,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     flg_type_viewer,
                     dt_dg_last_update,
                     code_status,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     dt_last_execution,
                     flg_has_comments,
                     dt_last_update,
                     id_parent_task_refid)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     t.flg_type_viewer,
                     l_current_timestamp,
                     t.code_status,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.dt_last_execution,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_parent_task_refid);
        END IF;
    
        g_error := 'Deleting temporary and last validation records';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
        --COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        --COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_medication_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_medication_ea - OK: ' || l_count_skiped || ' skiped records');
            dbms_output.put_line('admin_task_tl_medication_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        g_error := 'Leaving function admin_task_tl_medication_ea';
        pk_alertlog.log_debug(g_error, g_package_name, l_func_proc_name);
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MEDICATION_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MEDICATION_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_MEDICATION_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_medication_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with medication recon tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Pedro Teixeira
    * @since    09/06/2017
    ********************************************************************************************/
    FUNCTION admin_task_tl_med_recon_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_MED_RECON_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid     NUMBER := 0;
        l_count             NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --        l_prof              profissional := profissional(142, 1, 1);
    
        l_status_str  task_timeline_ea.status_str%TYPE;
        l_status_msg  task_timeline_ea.status_msg%TYPE;
        l_status_icon task_timeline_ea.status_icon%TYPE;
        l_status_flg  task_timeline_ea.status_flg%TYPE;
    
        l_error t_error_out;
    
        ---------------------------------------------------
        l_lang language.id_language%TYPE := g_log_lang;
        l_prof profissional := get_prof;
    
        l_id_episode     table_number := table_number(); -- ID_EPISODE
        l_id_patient     table_number := table_number(); -- ID_PATIENT
        l_id_presc       table_number := table_number(); -- ID_PRESC
        l_dt_req         table_timestamp_tstz := table_timestamp_tstz(); -- DT_REQ
        l_id_prof_req    table_number := table_number(); -- ID_PROF_REQ
        l_id_institution table_number := table_number(); -- ID_INSTITUTION
        l_id_tl_task     table_number := table_number(); -- ID_TL_TASK
    
        l_error_out  t_error_out;
        c_recon_data pk_types.cursor_type;
        l_ea_row     task_timeline_ea%ROWTYPE;
    
        l_counter NUMBER;
    
    BEGIN
        -------------------------------------------------------
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        SELECT COUNT(1)
          INTO l_counter
          FROM task_timeline_ea tte
         WHERE (tte.id_patient = i_patient OR tte.id_episode = i_episode)
           AND tte.id_tl_task IN (pk_prog_notes_constants.g_task_medrec_cont_home_hm, -- 74
                                  pk_prog_notes_constants.g_task_medrec_mod_cont_home_hm, -- 139
                                  pk_prog_notes_constants.g_task_medrec_cont_hospital_hm, -- 76
                                  pk_prog_notes_constants.g_task_medrec_discontinue_hm, -- 77
                                  pk_prog_notes_constants.g_task_medrec_cont_home_lm, -- 102
                                  pk_prog_notes_constants.g_task_medrec_cont_hospital_lm, -- 103
                                  pk_prog_notes_constants.g_task_medrec_discontinue_lm -- 104
                                  );
    
        pk_alertlog.log_debug('l_counter before: ' || l_counter, g_package_name, l_func_name);
    
        -------------------------------------------------------    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline med_recon_ea id_tl_tasks',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                                 i_episode     => i_episode,
                                                                 i_institution => i_institution,
                                                                 i_start_dt    => i_start_dt,
                                                                 i_end_dt      => i_end_dt,
                                                                 i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_medrec_cont_home_hm, -- 74
                                                                                               pk_prog_notes_constants.g_task_medrec_mod_cont_home_hm, -- 139
                                                                                               pk_prog_notes_constants.g_task_medrec_cont_hospital_hm, -- 76
                                                                                               pk_prog_notes_constants.g_task_medrec_discontinue_hm, -- 77
                                                                                               pk_prog_notes_constants.g_task_medrec_cont_home_lm, -- 102
                                                                                               pk_prog_notes_constants.g_task_medrec_cont_hospital_lm, -- 103
                                                                                               pk_prog_notes_constants.g_task_medrec_discontinue_lm -- 104
                                                                                               ))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        -------------------------------------------------------
        pk_alertlog.log_debug('BEFORE pk_api_pfh_in.get_recon_time_task_line', g_package_name, l_func_name);
    
        pk_api_pfh_in.get_recon_time_task_line(i_lang       => l_lang,
                                               i_prof       => l_prof, --the i_prof is not used in this function, so there is no problem if the sys_config is not defined.
                                               i_id_patient => i_patient,
                                               i_id_episode => i_episode,
                                               o_recon_data => c_recon_data,
                                               o_error      => l_error);
    
        pk_alertlog.log_debug('AFTER pk_api_pfh_in.get_recon_time_task_line', g_package_name, l_func_name);
    
        -------------------------------------------------------
        -- fetch presc_data cursor elements
        BEGIN
            g_error := ' FETCH c_presc_data ';
            FETCH c_recon_data BULK COLLECT
                INTO --
                     l_id_episode,
                     l_id_patient,
                     l_id_presc,
                     l_dt_req,
                     l_id_prof_req,
                     l_id_institution,
                     l_id_tl_task;
            CLOSE c_recon_data;
        EXCEPTION
            WHEN OTHERS THEN
                RAISE e_external;
        END;
    
        SELECT COUNT(1)
          INTO l_counter
          FROM task_timeline_ea tte
         WHERE tte.id_patient = i_patient
           AND tte.id_tl_task IN (pk_prog_notes_constants.g_task_medrec_cont_home_hm, -- 74
                                  pk_prog_notes_constants.g_task_medrec_mod_cont_home_hm, -- 139
                                  pk_prog_notes_constants.g_task_medrec_cont_hospital_hm, -- 76
                                  pk_prog_notes_constants.g_task_medrec_discontinue_hm, -- 77
                                  pk_prog_notes_constants.g_task_medrec_cont_home_lm, -- 102
                                  pk_prog_notes_constants.g_task_medrec_cont_hospital_lm, -- 103
                                  pk_prog_notes_constants.g_task_medrec_discontinue_lm -- 104
                                  );
    
        pk_alertlog.log_debug('l_counter after: ' || l_counter, g_package_name, l_func_name);
    
        IF l_id_presc IS NOT NULL
           AND l_id_presc.count > 0
        THEN
            -------------------------------------------------------
            FOR i IN l_id_presc.first .. l_id_presc.last
            LOOP
                l_ea_row.id_task_refid     := l_id_presc(i);
                l_ea_row.id_tl_task        := l_id_tl_task(i);
                l_ea_row.table_name        := 'PRESC';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_visit;
                l_ea_row.dt_dg_last_update := current_timestamp;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
                l_ea_row.id_patient        := l_id_patient(i);
                l_ea_row.id_episode        := l_id_episode(i);
                l_ea_row.id_visit          := pk_visit.get_visit(l_id_episode(i), l_error_out);
                l_ea_row.id_institution    := l_id_institution(i);
                l_ea_row.dt_req            := l_dt_req(i);
                l_ea_row.id_prof_req       := l_id_prof_req(i);
                l_ea_row.dt_last_update    := l_dt_req(i);
                l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_not_outdated;
            
                IF i_validate_table
                THEN
                    --insert in temporary table
                    INSERT INTO task_timeline_ea_tmp
                        (id_task_refid,
                         id_tl_task,
                         table_name,
                         flg_show_method,
                         dt_dg_last_update,
                         flg_sos,
                         flg_ongoing,
                         flg_normal,
                         flg_has_comments,
                         id_patient,
                         id_episode,
                         id_visit,
                         id_institution,
                         dt_req,
                         id_prof_req,
                         dt_last_update,
                         flg_outdated)
                    VALUES
                        (l_ea_row.id_task_refid,
                         l_ea_row.id_tl_task,
                         l_ea_row.table_name,
                         l_ea_row.flg_show_method,
                         l_ea_row.dt_dg_last_update,
                         l_ea_row.flg_sos,
                         l_ea_row.flg_ongoing,
                         l_ea_row.flg_normal,
                         l_ea_row.flg_has_comments,
                         l_ea_row.id_patient,
                         l_ea_row.id_episode,
                         l_ea_row.id_visit,
                         l_ea_row.id_institution,
                         l_ea_row.dt_req,
                         l_ea_row.id_prof_req,
                         l_ea_row.dt_last_update,
                         l_ea_row.flg_outdated);
                
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                
                    -- Insert into Easy Access table
                    INSERT INTO task_timeline_ea
                        (id_task_refid,
                         id_tl_task,
                         table_name,
                         flg_show_method,
                         dt_dg_last_update,
                         flg_sos,
                         flg_ongoing,
                         flg_normal,
                         flg_has_comments,
                         id_patient,
                         id_episode,
                         id_visit,
                         id_institution,
                         dt_req,
                         id_prof_req,
                         dt_last_update,
                         flg_outdated)
                    VALUES
                        (l_ea_row.id_task_refid,
                         l_ea_row.id_tl_task,
                         l_ea_row.table_name,
                         l_ea_row.flg_show_method,
                         l_ea_row.dt_dg_last_update,
                         l_ea_row.flg_sos,
                         l_ea_row.flg_ongoing,
                         l_ea_row.flg_normal,
                         l_ea_row.flg_has_comments,
                         l_ea_row.id_patient,
                         l_ea_row.id_episode,
                         l_ea_row.id_visit,
                         l_ea_row.id_institution,
                         l_ea_row.dt_req,
                         l_ea_row.id_prof_req,
                         l_ea_row.dt_last_update,
                         l_ea_row.flg_outdated);
                
                END IF;
            
                l_count := l_count + 1;
            
            END LOOP;
        END IF;
        -------------------------------------------------------
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            -------------------------------------------
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            -------------------------------------------
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        -------------------------------------------------------
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN
                                  (pk_prog_notes_constants.g_task_medrec_cont_home_hm, -- 74
                                   pk_prog_notes_constants.g_task_medrec_mod_cont_home_hm, -- 139
                                   pk_prog_notes_constants.g_task_medrec_cont_hospital_hm, -- 76
                                   pk_prog_notes_constants.g_task_medrec_discontinue_hm, -- 77
                                   pk_prog_notes_constants.g_task_medrec_cont_home_lm, -- 102
                                   pk_prog_notes_constants.g_task_medrec_cont_hospital_lm, -- 103
                                   pk_prog_notes_constants.g_task_medrec_discontinue_lm) -- 104
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_last_update,
                     flg_outdated)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_last_update,
                     t.flg_outdated);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line('admin_task_tl_med_recon_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_med_recon_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            dbms_output.put_line(SQLCODE);
            dbms_output.put_line(SQLERRM);
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_med_recon_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with past history encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Sofia Mendes
    * @version  2.6.1.2
    * @since    22-Sep-2011
    ********************************************************************************************/
    FUNCTION admin_task_tl_past_hist_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PAST_HIST_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Past history encoded tasks',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_ph_medical_hist,
                                                                                            pk_prog_notes_constants.g_task_ph_surgical_hist,
                                                                                            pk_prog_notes_constants.g_task_ph_cong_anomalies,
                                                                                            pk_prog_notes_constants.g_task_ph_treatments,
                                                                                            pk_prog_notes_constants.g_task_ph_gynec_diag,
                                                                                            pk_prog_notes_constants.g_task_ph_family_diag)) -- Past history encoded tasks
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT t.*
                      FROM (SELECT phd.id_episode,
                                   phd.id_pat_history_diagnosis,
                                   phd.dt_pat_history_diagnosis_tstz dt_req,
                                   phd.flg_status,
                                   phd.id_professional,
                                   nvl(epi.id_patient, phd.id_patient) id_patient,
                                   epi.id_visit,
                                   nvl(epi.id_institution, phd.id_institution) id_institution,
                                   NULL universal_desc_clob,
                                   NULL code_task,
                                   phd.flg_type,
                                   phd.id_pat_history_diagnosis_new,
                                   CASE
                                        WHEN phd.flg_status IN (pk_past_history.g_past_history_flg_resolved) THEN
                                         pk_prog_notes_constants.g_task_finalized_f
                                        WHEN phd.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                                         pk_prog_notes_constants.g_task_inactive_i
                                        ELSE
                                         pk_prog_notes_constants.g_task_ongoing_o
                                    END flg_ongoing,
                                   pk_alert_constant.g_yes flg_normal,
                                   NULL id_prof_exec,
                                   pk_alert_constant.g_no flg_has_comments,
                                   ei.id_software,
                                   phd.flg_area,
                                   pk_sysconfig.get_config(i_code_cf   => pk_alert_constant.g_diag_area_sys_config,
                                                           i_prof_inst => epi.id_institution,
                                                           i_prof_soft => ei.id_software) area_cfg,
                                   pk_review.get_last_review_prof(i_lang           => NULL,
                                                                  i_prof           => NULL,
                                                                  i_id_episode     => phd.id_episode,
                                                                  i_id_record_area => phd.id_pat_history_diagnosis,
                                                                  i_flg_context    => pk_review.get_past_history_context()) id_prof_review,
                                   pk_review.get_last_review_date(i_lang           => NULL,
                                                                  i_prof           => NULL,
                                                                  i_id_episode     => phd.id_episode,
                                                                  i_id_record_area => phd.id_pat_history_diagnosis,
                                                                  i_flg_context    => pk_review.get_past_history_context()) dt_review,
                                   phd.dt_diagnosed,
                                   phd.dt_diagnosed_precision
                              FROM pat_history_diagnosis phd
                              LEFT JOIN episode epi
                                ON (epi.id_episode = phd.id_episode)
                              LEFT JOIN epis_info ei
                                ON ei.id_episode = epi.id_episode
                              LEFT JOIN alert_diagnosis ad
                                ON phd.id_alert_diagnosis = ad.id_alert_diagnosis
                              LEFT JOIN diagnosis d
                                ON ad.id_diagnosis = d.id_diagnosis
                            --ALERT-293824 - START CHANGE
                             WHERE ((i_patient IS NULL) OR (i_patient IS NOT NULL AND epi.id_patient = i_patient))
                               AND ((i_episode IS NULL) OR (i_episode IS NOT NULL AND epi.id_episode = i_episode))
                               AND ((i_institution IS NULL) OR
                                   (i_institution IS NOT NULL AND epi.id_institution = i_institution))
                               AND ((i_start_dt IS NULL) OR
                                   (i_start_dt IS NOT NULL AND phd.dt_pat_history_diagnosis_tstz >= i_start_dt))
                               AND ((i_end_dt IS NULL) OR
                                   (i_end_dt IS NOT NULL AND phd.dt_pat_history_diagnosis_tstz <= i_end_dt))
                                  --ALERT-293824 - END CHANGE
                               AND phd.id_pat_history_diagnosis_new IS NULL
                               AND (phd.flg_status <> pk_past_history.g_pat_hist_diag_canceled OR phd.flg_status IS NULL)
                               AND (ad.flg_type = phd.flg_type OR ad.flg_type = pk_past_history.g_alert_diag_type_med OR
                                   phd.id_alert_diagnosis IN
                                   (pk_past_history.g_diag_unknown,
                                     pk_past_history.g_diag_none,
                                     pk_past_history.g_diag_non_remark) OR
                                   phd.flg_type = pk_past_history.g_alert_type_treatments)
                               AND rownum > 0 --ALERT-293824
                            ) t
                    
                     WHERE ((t.area_cfg LIKE pk_alert_constant.g_diag_area_config_show_all) OR
                           (t.area_cfg LIKE pk_alert_constant.g_diag_area_config_show_own AND
                           t.flg_area IN
                           (pk_alert_constant.g_diag_area_past_history, pk_alert_constant.g_diag_area_not_defined))))
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_history_diagnosis;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_history_diagnosis,
                     CASE rec.flg_type WHEN pk_past_history.g_alert_diag_type_med THEN
                     pk_prog_notes_constants.g_task_ph_medical_hist WHEN pk_past_history.g_alert_diag_type_surg THEN
                     pk_prog_notes_constants.g_task_ph_surgical_hist WHEN pk_past_history.g_alert_diag_type_cong_anom THEN
                     pk_prog_notes_constants.g_task_ph_cong_anomalies WHEN pk_past_history.g_alert_type_treatments THEN
                     pk_prog_notes_constants.g_task_ph_treatments WHEN pk_past_history.g_alert_diag_type_gyneco THEN
                     pk_prog_notes_constants.g_task_ph_gynec_diag WHEN pk_past_history.g_alert_diag_type_family THEN
                     pk_prog_notes_constants.g_task_ph_family_diag END, -- PAST HISTORY ENCODED TASK TYPES
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.dt_diagnosed_precision IN
                     (pk_past_history.g_date_precision_hour, pk_past_history.g_date_precision_day) THEN
                     rec.dt_diagnosed ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_prog_notes_constants.g_tl_table_name_ph_diag,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     CASE WHEN(rec.id_pat_history_diagnosis_new IS NULL) THEN
                     pk_ea_logic_tasktimeline.g_flg_not_outdated ELSE pk_ea_logic_tasktimeline.g_flg_outdated END,
                     rec.id_pat_history_diagnosis_new,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_history_diagnosis;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_history_diagnosis,
                     CASE rec.flg_type WHEN pk_past_history.g_alert_diag_type_med THEN
                     pk_prog_notes_constants.g_task_ph_medical_hist WHEN pk_past_history.g_alert_diag_type_surg THEN
                     pk_prog_notes_constants.g_task_ph_surgical_hist WHEN pk_past_history.g_alert_diag_type_cong_anom THEN
                     pk_prog_notes_constants.g_task_ph_cong_anomalies WHEN pk_past_history.g_alert_type_treatments THEN
                     pk_prog_notes_constants.g_task_ph_treatments WHEN pk_past_history.g_alert_diag_type_gyneco THEN
                     pk_prog_notes_constants.g_task_ph_gynec_diag WHEN pk_past_history.g_alert_diag_type_family THEN
                     pk_prog_notes_constants.g_task_ph_family_diag END, -- PAST HISTORY ENCODED TASK TYPES
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.dt_diagnosed_precision IN
                     (pk_past_history.g_date_precision_hour, pk_past_history.g_date_precision_day) THEN
                     rec.dt_diagnosed ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_prog_notes_constants.g_tl_table_name_ph_diag,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     CASE WHEN(rec.id_pat_history_diagnosis_new IS NULL) THEN
                     pk_ea_logic_tasktimeline.g_flg_not_outdated ELSE pk_ea_logic_tasktimeline.g_flg_outdated END,
                     rec.id_pat_history_diagnosis_new,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.id_parent_task_refid <> b.id_parent_task_refid OR
                                (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                                (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL)) OR
                                --
                                (a.id_ref_group <> b.id_ref_group OR
                                (a.id_ref_group IS NULL AND b.id_ref_group IS NOT NULL) OR
                                (a.id_ref_group IS NOT NULL AND b.id_ref_group IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN
                                  (pk_prog_notes_constants.g_task_ph_medical_hist,
                                   pk_prog_notes_constants.g_task_ph_surgical_hist,
                                   pk_prog_notes_constants.g_task_ph_cong_anomalies,
                                   pk_prog_notes_constants.g_task_ph_treatments,
                                   pk_prog_notes_constants.g_task_ph_gynec_diag,
                                   pk_prog_notes_constants.g_task_ph_family_diag)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.dt_begin             = t.dt_begin,
                       tt_ea.dt_end               = t.dt_end,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.status_str           = t.status_str,
                       tt_ea.status_msg           = t.status_msg,
                       tt_ea.status_icon          = t.status_icon,
                       tt_ea.status_flg           = t.status_flg,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update,
                       tt_ea.id_prof_review       = t.id_prof_review,
                       tt_ea.dt_review            = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_past_hist_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_past_hist_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PAST_HIST_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PAST_HIST_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PAST_HIST_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_past_hist_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with past history free text records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Sofia Mendes
    * @version  2.6.1.2
    * @since    22-Sep-2011
    ********************************************************************************************/
    FUNCTION admin_task_tl_ph_ftxt_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PH_FTXT_EA';
    
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Past history free text tasks',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_ph_free_txt)) -- Past history free text tasks
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT pphfth.id_episode,
                           pphfth.id_pat_ph_ft,
                           pphfth.dt_register dt_req,
                           pphfth.flg_status,
                           pphfth.id_professional,
                           epi.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           pphfth.text universal_desc_clob,
                           NULL code_task,
                           pphfth.flg_type,
                           pphfth.id_doc_area,
                           pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           NULL id_prof_exec,
                           pk_alert_constant.g_no flg_has_comments,
                           pk_review.get_last_review_prof(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => pphfth.id_episode,
                                                          i_id_record_area => pphfth.id_pat_ph_ft,
                                                          i_flg_context    => pk_review.get_past_history_ft_context()) id_prof_review,
                           pk_review.get_last_review_date(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => pphfth.id_episode,
                                                          i_id_record_area => pphfth.id_pat_ph_ft,
                                                          i_flg_context    => pk_review.get_past_history_ft_context()) dt_review
                      FROM pat_past_hist_free_text pphfth
                     INNER JOIN episode epi
                        ON (epi.id_episode = pphfth.id_episode AND
                           epi.flg_status <> pk_alert_constant.g_epis_status_cancel)
                     WHERE ((i_patient IS NOT NULL AND epi.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND pphfth.dt_register >= nvl(i_start_dt, pphfth.dt_register)
                       AND pphfth.dt_register <= nvl(i_end_dt, pphfth.dt_register)
                       AND pphfth.flg_status NOT IN
                           (pk_past_history.g_flg_status_cancel_free_text, pk_past_history.g_flg_status_outdtd_free_text))
        LOOP
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_ph_ft,
                     pk_prog_notes_constants.g_task_ph_free_txt, -- PAST HISTORY free text TASK TYPES
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL, --TODO!!!
                     NULL, --TODO!!!
                     rec.flg_status,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_prog_notes_constants.g_tl_table_name_ph_ftxt,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     rec.id_doc_area,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_ph_ft,
                     pk_prog_notes_constants.g_task_ph_free_txt, -- PAST HISTORY free text TASK TYPES
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL, --TODO!!!
                     NULL, --TODO!!!
                     rec.flg_status,
                     NULL,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_task,
                     rec.universal_desc_clob,
                     pk_prog_notes_constants.g_tl_table_name_ph_ftxt,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     rec.id_doc_area,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                                --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                                --
                                (a.status_icon <> b.status_icon OR
                                (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                                --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0
                                
                                OR (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.id_doc_area <> b.id_doc_area OR
                                (a.id_doc_area IS NULL AND b.id_doc_area IS NOT NULL) OR
                                (a.id_doc_area IS NOT NULL AND b.id_doc_area IS NULL)) OR
                                --
                                (a.id_ref_group <> b.id_ref_group OR
                                (a.id_ref_group IS NULL AND b.id_ref_group IS NOT NULL) OR
                                (a.id_ref_group IS NOT NULL AND b.id_ref_group IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_ph_free_txt
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.status_str          = t.status_str,
                       tt_ea.status_msg          = t.status_msg,
                       tt_ea.status_icon         = t.status_icon,
                       tt_ea.status_flg          = t.status_flg,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.id_doc_area         = t.id_doc_area,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update,
                       tt_ea.id_prof_review      = t.id_prof_review,
                       tt_ea.dt_review           = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     code_description,
                     universal_desc_clob,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     id_doc_area,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.code_description,
                     t.universal_desc_clob,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.id_doc_area,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_ph_ftxt_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_ph_ftxt_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PH_FTXT_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PH_FTXT_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PH_FTXT_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_ph_ftxt_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with all EPISODE related tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.7.6
    * @since    2009/12/23
    ********************************************************************************************/
    FUNCTION admin_epi_task_tl_tables
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
    BEGIN
        --
        g_error := 'admin_task_tl_surgery_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_task_tl_surgery_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RETURN FALSE;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --
        g_error := 'admin_task_tl_inp_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_task_tl_inp_ea(i_patient,
                                    i_episode,
                                    i_schedule,
                                    i_external_request,
                                    i_institution,
                                    i_start_dt,
                                    i_end_dt,
                                    i_validate_table,
                                    i_output_invalid_records,
                                    i_recreate_table,
                                    i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RETURN FALSE;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            dbms_output.put_line('ADMIN_EPI_TASK_TL_TABLES -> ' || g_error || ' - ' || SQLERRM);
            ROLLBACK;
            RETURN FALSE;
    END admin_epi_task_tl_tables;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with complaints tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          14-Feb-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_complaints_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_COMPLAINTS_EA';
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_complaint_act           CONSTANT VARCHAR2(1 CHAR) := pk_complaint.g_complaint_act;
        l_anamnesis_act           CONSTANT VARCHAR2(1 CHAR) := pk_clinical_info.g_epis_active;
        l_type_complaint          CONSTANT VARCHAR2(1 CHAR) := pk_clinical_info.g_complaint;
        l_id_tl_task_complaint    CONSTANT PLS_INTEGER := pk_prog_notes_constants.g_task_chief_complaint;
        l_id_tl_task_anamnesis    CONSTANT PLS_INTEGER := pk_prog_notes_constants.g_task_chief_complaint_anm;
        l_epis_status_cancel      CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_tl_table_name_complaint CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_complaint;
        l_tl_table_name_anamnesis CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_anamnesis;
        l_tl_oriented_visit       CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_visit;
        l_id_doc_area             CONSTANT task_timeline_ea.id_doc_area%TYPE := 20;
    
        l_flg_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := 1;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline COMPLAINTS AND ANAMNESIS TASK',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(l_id_tl_task_complaint,
                                                                                            l_id_tl_task_anamnesis)) -- COMPLAINTS AND ANAMNESIS TASK ONLY
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        FOR rec IN ( --COMPLAINT 
                    SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     ec.id_epis_complaint id_task_refid,
                      epis.id_patient,
                      epis.id_episode,
                      epis.id_visit,
                      epis.id_institution,
                      ec.adw_last_update_tstz dt_req,
                      ec.id_professional id_prof_req,
                      decode(ec.id_complaint, NULL, NULL, 'COMPLAINT.CODE_COMPLAINT.' || ec.id_complaint) code_description,
                      CASE
                           WHEN ec.flg_status = l_complaint_act THEN
                            pk_ea_logic_tasktimeline.g_flg_not_outdated
                           ELSE
                            l_flg_outdated
                       END flg_outdated,
                      ec.flg_status flg_status_req,
                      l_id_tl_task_complaint id_tl_task,
                      l_tl_table_name_complaint table_name,
                      to_clob(ec.patient_complaint) universal_desc_clob,
                      ec.id_epis_complaint_parent id_parent_task_refid,
                      pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                      pk_alert_constant.g_yes flg_normal,
                      ec.id_professional id_prof_exec,
                      pk_alert_constant.g_no flg_has_comments
                      FROM epis_complaint ec
                     INNER JOIN episode epis
                        ON ec.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE ec.adw_last_update_tstz >= nvl(i_start_dt, ec.adw_last_update_tstz)
                       AND ec.adw_last_update_tstz <= nvl(i_end_dt, ec.adw_last_update_tstz)
                       AND nvl(ec.flg_status, l_complaint_act) IN (l_complaint_act)
                       AND ec.id_cancel_info_det IS NULL
                       AND ec.id_epis_complaint_root IS NULL
                    UNION ALL
                    --ANAMNESIS 
                    SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     ea.id_epis_anamnesis id_task_refid,
                      epis.id_patient,
                      epis.id_episode,
                      epis.id_visit,
                      epis.id_institution,
                      ea.dt_epis_anamnesis_tstz dt_req,
                      ea.id_professional id_prof_req,
                      NULL code_description,
                      CASE
                          WHEN ea.flg_status = l_anamnesis_act THEN
                           pk_ea_logic_tasktimeline.g_flg_not_outdated
                          ELSE
                           l_flg_outdated
                      END flg_outdated,
                      ea.flg_status flg_status_req,
                      l_id_tl_task_anamnesis id_tl_task,
                      l_tl_table_name_anamnesis table_name,
                      ea.desc_epis_anamnesis universal_desc_clob,
                      ea.id_epis_anamnesis_parent id_parent_task_refid,
                      pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                      pk_alert_constant.g_yes flg_normal,
                      ea.id_professional id_prof_exec,
                      pk_alert_constant.g_no flg_has_comments
                    
                      FROM epis_anamnesis ea
                     INNER JOIN episode epis
                        ON ea.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE ea.dt_epis_anamnesis_tstz >= nvl(i_start_dt, ea.dt_epis_anamnesis_tstz)
                       AND ea.dt_epis_anamnesis_tstz <= nvl(i_end_dt, ea.dt_epis_anamnesis_tstz)
                       AND nvl(ea.flg_status, l_anamnesis_act) IN (l_anamnesis_act)
                       AND ea.id_cancel_info_det IS NULL
                       AND ea.flg_type = l_type_complaint)
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_doc_area,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- COMPLAINTS AND ANAMNESIS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.code_description,
                     rec.table_name,
                     l_tl_oriented_visit, -- VISIT ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.universal_desc_clob,
                     l_id_doc_area,
                     rec.id_parent_task_refid,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_doc_area,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- COMPLAINTS AND ANAMNESIS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.code_description,
                     rec.table_name,
                     l_tl_oriented_visit, -- VISIT ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.universal_desc_clob,
                     l_id_doc_area,
                     rec.id_parent_task_refid,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.id_doc_area <> b.id_doc_area OR (a.id_doc_area IS NULL AND b.id_doc_area IS NOT NULL) OR
                                 (a.id_doc_area IS NOT NULL AND b.id_doc_area IS NULL)) OR
                                --
                                 (a.id_parent_task_refid <> b.id_parent_task_refid OR
                                 (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                                 (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (l_id_tl_task_complaint, l_id_tl_task_anamnesis)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_doc_area          = t.id_doc_area,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_doc_area,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_doc_area,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_complaints_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_complaints_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_COMPLAINTS_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_COMPLAINTS_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_COMPLAINTS_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_complaints_ea;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Plan's tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          21-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_plan_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'ADMIN_TASK_TL_PLAN_EA';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_recomend_act           CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_active;
        l_epis_status_cancel     CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_tl_table_name_recomend CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_recomend;
        l_tl_oriented_episode    CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
        --l_flg_type_l             CONSTANT VARCHAR2(1 CHAR) := pk_discharge.g_type_l;
        l_flg_temp_def     CONSTANT VARCHAR2(1 CHAR) := pk_discharge.g_flg_def;
        l_flg_not_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_not_outdated;
        l_flg_outdated     CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_outdated;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline PLAN TASKS ONLY',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_plan_notes,
                                                                                            pk_prog_notes_constants.g_task_subjective,
                                                                                            pk_prog_notes_constants.g_task_objective,
                                                                                            pk_prog_notes_constants.g_task_assessment)) -- PLAN TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     er.id_epis_recomend id_task_refid,
                     epis.id_patient,
                     epis.id_episode,
                     epis.id_visit,
                     epis.id_institution,
                     er.dt_epis_recomend_tstz dt_req,
                     er.id_professional id_prof_req,
                     NULL code_description,
                     CASE
                          WHEN er.flg_status = l_recomend_act THEN
                           l_flg_not_outdated
                          ELSE
                           l_flg_outdated
                      END flg_outdated,
                     nvl(er.flg_status, l_recomend_act) flg_status_req,
                     CASE
                          WHEN er.flg_type = pk_progress_notes.g_type_plan THEN
                           pk_prog_notes_constants.g_task_plan_notes
                          WHEN er.flg_type = pk_progress_notes.g_type_subjective THEN
                           pk_prog_notes_constants.g_task_subjective
                          WHEN er.flg_type = pk_progress_notes.g_type_objective THEN
                           pk_prog_notes_constants.g_task_objective
                          WHEN er.flg_type = pk_progress_notes.g_type_assessment THEN
                           pk_prog_notes_constants.g_task_assessment
                          ELSE
                           NULL
                      END id_tl_task,
                     l_tl_table_name_recomend table_name,
                     er.desc_epis_recomend_clob universal_description_clob,
                     er.flg_type,
                     epis.flg_status flg_status_epis,
                     er.id_cancel_info_det,
                     er.id_epis_recomend_parent,
                     pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments
                      FROM epis_recomend er
                     INNER JOIN episode epis
                        ON er.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE er.dt_epis_recomend_tstz >= nvl(i_start_dt, er.dt_epis_recomend_tstz)
                       AND er.dt_epis_recomend_tstz <= nvl(i_end_dt, er.dt_epis_recomend_tstz)
                       AND nvl(er.flg_status, l_recomend_act) IN (l_recomend_act)
                       AND er.id_cancel_info_det IS NULL
                       AND er.flg_type IN (pk_progress_notes.g_type_plan,
                                           pk_progress_notes.g_type_subjective,
                                           pk_progress_notes.g_type_objective,
                                           pk_progress_notes.g_type_assessment)
                       AND er.flg_temp = l_flg_temp_def)
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- PLAN TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.code_description,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.universal_description_clob,
                     rec.id_epis_recomend_parent,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- PLAN TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.code_description,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.universal_description_clob,
                     rec.id_epis_recomend_parent,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS
                    (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_plan_notes,
                                                         pk_prog_notes_constants.g_task_subjective,
                                                         pk_prog_notes_constants.g_task_objective,
                                                         pk_prog_notes_constants.g_task_assessment)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_plan_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_plan_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PLAN_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PLAN_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PLAN_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_plan_ea;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Diagnosis tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          22-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_diag_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_DIAG_EA';
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_id_tl_task_diag_dif     CONSTANT PLS_INTEGER := pk_prog_notes_constants.g_task_diagnosis;
        l_id_tl_task_diag_fin     CONSTANT PLS_INTEGER := pk_prog_notes_constants.g_task_final_diag;
        l_epis_status_cancel      CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_tl_table_name_diagnosis CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_diagnosis;
        l_tl_oriented_episode     CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
    
        l_flg_diag_final CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_diag_flg_type_d;
        l_flg_diag_dif   CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_diag_flg_type_p;
    
        l_flg_not_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_not_outdated;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Diagnosis TASKS ONLY',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(l_id_tl_task_diag_dif,
                                                                                            l_id_tl_task_diag_fin)) -- Diagnosis TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT *
                      FROM (SELECT t_d.id_task_refid,
                                   t_d.id_patient,
                                   t_d.id_episode,
                                   t_d.id_visit,
                                   t_d.id_institution,
                                   t_d.id_prof_req,
                                   t_d.flg_status_req,
                                   t_d.id_tl_task,
                                   CASE
                                        WHEN ((t_d.dt_hist > t_d.dt_req_diag) OR t_d.dt_req_diag IS NULL) THEN
                                         t_d.dt_hist
                                        ELSE
                                         t_d.dt_req_diag
                                    END dt_req,
                                   t_d.flg_normal,
                                   t_d.id_prof_exec,
                                   t_d.flg_has_comments,
                                   t_d.flg_ongoing,
                                   t_d.rank
                              FROM (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                                     ed.id_epis_diagnosis id_task_refid,
                                     epis.id_patient,
                                     epis.id_episode,
                                     epis.id_visit,
                                     epis.id_institution,
                                     nvl(ed.id_professional_diag, nvl(ed.id_prof_confirmed, ed.id_prof_rulled_out)) id_prof_req,
                                     ed.flg_status flg_status_req,
                                     decode(ed.flg_type, l_flg_diag_final, l_id_tl_task_diag_fin, l_id_tl_task_diag_dif) id_tl_task,
                                     pk_diagnosis.get_diag_hist_creation_dt(i_lang              => NULL,
                                                                            i_prof              => NULL,
                                                                            i_id_epis_diagnosis => ed.id_epis_diagnosis) dt_hist,
                                     pk_diagnosis_core.get_dt_diagnosis(i_lang              => il.id_language,
                                                                        i_prof              => profissional(0,
                                                                                                            ei.id_software,
                                                                                                            epis.id_institution),
                                                                        i_flg_status        => ed.flg_status,
                                                                        i_dt_epis_diagnosis => ed.dt_epis_diagnosis_tstz,
                                                                        i_dt_confirmed      => ed.dt_confirmed_tstz,
                                                                        i_dt_cancel         => ed.dt_cancel_tstz,
                                                                        i_dt_base           => ed.dt_base_tstz,
                                                                        i_dt_rulled_out     => ed.dt_rulled_out_tstz) dt_req_diag,
                                     pk_alert_constant.g_yes flg_normal,
                                     ed.id_professional_diag id_prof_exec,
                                     pk_alert_constant.g_no flg_has_comments,
                                     CASE
                                          WHEN ed.flg_status IN
                                               (pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_r) THEN
                                           pk_prog_notes_constants.g_task_finalized_f
                                          ELSE
                                           pk_prog_notes_constants.g_task_ongoing_o
                                      END flg_ongoing,
                                     decode(ed.flg_final_type,
                                            pk_diagnosis.g_flg_final_type_p,
                                            -1,
                                            pk_sysdomain.get_rank(g_log_lang, 'EPIS_DIAGNOSIS.FLG_STATUS', ed.flg_status)) rank
                                      FROM epis_diagnosis ed
                                     INNER JOIN episode epis
                                        ON ed.id_episode = epis.id_episode
                                       AND epis.flg_status <> l_epis_status_cancel
                                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                                        ON tf_e.id_episode = epis.id_episode
                                     INNER JOIN diagnosis d
                                        ON ed.id_diagnosis = d.id_diagnosis
                                     INNER JOIN epis_info ei
                                        ON epis.id_episode = ei.id_episode
                                     INNER JOIN institution_language il
                                        ON epis.id_institution = il.id_institution
                                     WHERE ed.flg_status IN ('A', /*Activo*/
                                                             'D', /*Despiste*/
                                                             'F', /*Confirmado*/
                                                             'B', /*Base*/
                                                             'R' /*ruled out*/)
                                       AND ed.id_professional_cancel IS NULL
                                       AND ed.flg_type IN (l_flg_diag_final, l_flg_diag_dif)) t_d) t
                     WHERE t.dt_req >= nvl(i_start_dt, t.dt_req)
                       AND t.dt_req <= nvl(i_end_dt, t.dt_req))
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- DIAGNOSIS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     l_tl_table_name_diagnosis,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.rank);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- DIAGNOSIS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     l_tl_table_name_diagnosis,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.rank);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                 (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (l_id_tl_task_diag_dif, l_id_tl_task_diag_fin)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.rank);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_diag_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_diag_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_diag_ea;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Diagnosis Note tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          23-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_diag_notes_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_DIAG_NOTES_EA';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_id_tl_task_diag_notes    CONSTANT PLS_INTEGER := pk_prog_notes_constants.g_task_diag_notes;
        l_epis_status_cancel       CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_note_active              CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_active;
        l_tl_table_name_diag_notes CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_diag_notes;
        l_tl_oriented_episode      CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
    
        l_flg_not_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_not_outdated;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Diagnosis Notes TASKS ONLY',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(l_id_tl_task_diag_notes)) -- Diagnosis Notes TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     en.id_epis_diagnosis_notes               id_task_refid,
                     epis.id_patient,
                     epis.id_episode,
                     epis.id_visit,
                     epis.id_institution,
                     en.id_prof_create                        id_prof_req,
                     en.dt_epis_diagnosis_notes               dt_req,
                     en.notes                                 universal_desc_clob,
                     en.dt_create                             dt_execution,
                     pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                     pk_alert_constant.g_yes                  flg_normal,
                     en.id_prof_create                        id_prof_exec,
                     pk_alert_constant.g_no                   flg_has_comments
                      FROM epis_diagnosis_notes en
                     INNER JOIN episode epis
                        ON en.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE en.dt_epis_diagnosis_notes >= nvl(i_start_dt, en.dt_epis_diagnosis_notes)
                       AND en.dt_epis_diagnosis_notes <= nvl(i_end_dt, en.dt_epis_diagnosis_notes)
                       AND en.id_cancel_reason IS NULL)
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     dt_execution,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     l_id_tl_task_diag_notes, -- DIAGNOSIS NOTES TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     l_note_active,
                     l_tl_table_name_diag_notes,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.universal_desc_clob,
                     rec.dt_execution,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     dt_execution,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     l_id_tl_task_diag_notes, -- DIAGNOSIS NOTES TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     l_note_active,
                     l_tl_table_name_diag_notes,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.universal_desc_clob,
                     rec.dt_execution,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.dt_execution <> b.dt_execution OR
                                 (a.dt_execution IS NULL AND b.dt_execution IS NOT NULL) OR
                                 (a.dt_execution IS NOT NULL AND b.dt_execution IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = l_id_tl_task_diag_notes
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.flg_show_method     = t.flg_show_method,
                       tt_ea.dt_dg_last_update   = l_current_timestamp,
                       tt_ea.flg_outdated        = t.flg_outdated,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.dt_execution        = t.dt_execution,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     dt_execution,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.dt_execution,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_diag_notes_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_diag_notes_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_NOTES_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_NOTES_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DIAG_NOTES_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_diag_notes_ea;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Habits tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       Task identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          27-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_habits
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'ADMIN_TASK_TL_HABITS';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_tl_table_name_habits CONSTANT VARCHAR2(1000 CHAR) := pk_prog_notes_constants.g_tl_table_name_pat_hab;
        l_tl_oriented_patient  CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_patient;
    
        l_flg_not_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_not_outdated;
    
        l_error t_error_out;
    
        l_id_visit visit.id_visit%TYPE;
    
    BEGIN
        g_error := 'HABITS';
        pk_alertlog.log_debug(g_error);
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Habits TASKS ONLY ',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_habits)) -- Habits TASKS ONLY 
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        g_error := 'LOOP HABITS records';
        pk_alertlog.log_debug(g_error);
    
        FOR rec IN (SELECT ph.id_pat_habit id_task_refid,
                           ph.id_patient,
                           ph.id_episode,
                           ph.flg_status,
                           ph.id_prof_writes id_prof_request,
                           ph.dt_pat_habit_tstz dt_req,
                           ph.id_institution,
                           h.code_habit code_description,
                           NULL dt_begin,
                           CASE
                                WHEN ph.flg_status IN (pk_patient.g_flg_status_r) THEN -- Resolved
                                 pk_prog_notes_constants.g_task_finalized_f
                                WHEN ph.flg_status IN (pk_patient.g_flg_status_p) THEN -- passive
                                 pk_prog_notes_constants.g_task_inactive_i
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           NULL id_prof_exec,
                           pk_alert_constant.g_no flg_has_comments,
                           pk_review.get_last_review_prof(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => ph.id_episode,
                                                          i_id_record_area => ph.id_pat_habit,
                                                          i_flg_context    => pk_review.get_habits_context()) id_prof_review,
                           pk_review.get_last_review_date(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => ph.id_episode,
                                                          i_id_record_area => ph.id_pat_habit,
                                                          i_flg_context    => pk_review.get_habits_context()) dt_review
                      FROM pat_habit ph
                     INNER JOIN habit h
                        ON h.id_habit = ph.id_habit
                     INNER JOIN episode e
                        ON ph.id_episode = e.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE ph.flg_status NOT IN (pk_patient.g_pat_habit_canc, 'U')
                       AND ((i_patient IS NOT NULL AND ph.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND ph.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND ph.id_institution = i_institution) OR i_institution IS NULL)
                       AND ph.dt_pat_habit_tstz >= nvl(i_start_dt, ph.dt_pat_habit_tstz)
                       AND ph.dt_pat_habit_tstz <= nvl(i_start_dt, ph.dt_pat_habit_tstz))
        LOOP
        
            IF (rec.id_episode IS NOT NULL)
            THEN
                l_id_visit := pk_episode.get_id_visit(i_episode => rec.id_episode);
            ELSE
                l_id_visit := NULL;
            END IF;
        
            IF i_validate_table
            THEN
                g_error := 'INSERT into task_timeline_ea_tmp. ' || rec.id_task_refid;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     code_description,
                     dt_begin,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_task_refid,
                     pk_prog_notes_constants.g_task_habits, -- HABITS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     l_id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     rec.flg_status,
                     l_tl_table_name_habits,
                     l_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.code_description,
                     rec.dt_begin,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'INSERT into task_timeline_ea. ' || rec.id_task_refid;
                pk_alertlog.log_debug(g_error);
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     code_description,
                     dt_begin,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_task_refid,
                     pk_prog_notes_constants.g_task_habits, -- HABITS TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     l_id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_request,
                     rec.flg_status,
                     l_tl_table_name_habits,
                     l_tl_oriented_patient, -- PATIENT ORIENTED
                     current_timestamp,
                     l_flg_not_outdated,
                     rec.code_description,
                     rec.dt_begin,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            g_error := 'Validate the one that are different ';
            pk_alertlog.log_debug(g_error);
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.dt_execution <> b.dt_execution OR
                                 (a.dt_execution IS NULL AND b.dt_execution IS NOT NULL) OR
                                 (a.dt_execution IS NOT NULL AND b.dt_execution IS NULL)) OR
                                
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                 (a.id_prof_review <> b.id_prof_review OR
                                 (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                 (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                 (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                 (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --                            
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            g_error := 'Validate the ones that are missing';
            pk_alertlog.log_debug(g_error);
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_habits
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     code_description,
                     dt_begin,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.code_description,
                     t.dt_begin,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_diag_notes_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_diag_notes_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_HABITS',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_HABITS',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_HABITS',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_habits;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Documentation tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          21-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_doc_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'ADMIN_TASK_TL_DOC_EA';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_doc_act                     CONSTANT VARCHAR2(1 CHAR) := pk_touch_option.g_epis_doc_active;
        l_tl_table_name_documentation CONSTANT VARCHAR2(1000 CHAR) := pk_alert_constant.g_tl_table_name_documentation;
        l_tl_oriented_episode         CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
        l_epis_status_cancel          CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
    
        l_yes CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
    
        l_gynecological_pelvic_1044 epis_documentation.id_doc_area%TYPE := 1044;
    
        l_id_tl_task_doc_all tl_task.id_tl_task%TYPE := pk_prog_notes_constants.g_task_templates;
        l_id_tl_task_doc_ph  tl_task.id_tl_task%TYPE := pk_prog_notes_constants.g_task_ph_templ;
    
        l_flg_not_outdated CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_not_outdated;
        l_flg_outdated     CONSTANT task_timeline_ea.flg_outdated%TYPE := pk_ea_logic_tasktimeline.g_flg_outdated;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline DOCUMENTATION TASKS ONLY',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                                 i_episode     => i_episode,
                                                                 i_institution => i_institution,
                                                                 i_start_dt    => i_start_dt,
                                                                 i_end_dt      => i_end_dt,
                                                                 i_id_tl_task  => table_number(l_id_tl_task_doc_all,
                                                                                               l_id_tl_task_doc_ph)) -- DOCUMENTATION TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     ed.id_epis_documentation id_task_refid,
                     epis.id_patient,
                     epis.id_episode,
                     epis.id_visit,
                     epis.id_institution,
                     ed.dt_creation_tstz dt_req,
                     ed.dt_last_update_tstz dt_execution,
                     ed.id_professional id_prof_req,
                     decode(ed.flg_status, l_doc_act, l_flg_not_outdated, l_flg_outdated) flg_outdated,
                     nvl(ed.flg_status, l_doc_act) flg_status_req,
                     ed.id_doc_area,
                     ed.id_epis_documentation_parent id_parent_task_refid,
                     CASE
                      --Past History areas (Past history: templates)
                          WHEN ed.id_doc_area IN
                               (45, 1052, 52, 49, 48, 46, 47, 1050, 1054, 6753, 36054, 36084, 36079, 36085, 36140) THEN
                           l_id_tl_task_doc_ph
                      --All other areas
                          ELSE
                           l_id_tl_task_doc_all
                      END id_tl_task,
                     pk_alert_constant.g_no flg_has_comments,
                     nvl(ed.dt_last_update_tstz, ed.dt_creation_tstz) dt_last_update,
                     CASE
                          WHEN ed.flg_status = pk_alert_constant.g_inactive THEN
                           pk_prog_notes_constants.g_task_inactive_i
                          ELSE
                           pk_prog_notes_constants.g_task_ongoing_o
                      END flg_ongoing,
                     pk_review.get_last_review_prof(i_lang           => NULL,
                                                    i_prof           => NULL,
                                                    i_id_episode     => ed.id_episode,
                                                    i_id_record_area => ed.id_epis_documentation,
                                                    i_flg_context    => pk_review.get_template_context()) id_prof_review,
                     pk_review.get_last_review_date(i_lang           => NULL,
                                                    i_prof           => NULL,
                                                    i_id_episode     => ed.id_episode,
                                                    i_id_record_area => ed.id_epis_documentation,
                                                    i_flg_context    => pk_review.get_template_context()) dt_review
                      FROM epis_documentation ed
                     INNER JOIN episode epis
                        ON ed.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE ed.id_doc_area <> l_gynecological_pelvic_1044
                       AND ed.dt_creation_tstz >= nvl(i_start_dt, ed.dt_creation_tstz)
                       AND ed.dt_creation_tstz <= nvl(i_end_dt, ed.dt_creation_tstz)
                       AND nvl(ed.flg_status, l_doc_act) = l_doc_act
                       AND ed.id_prof_cancel IS NULL)
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     id_doc_area,
                     dt_execution,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     id_group_import)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- DOCUMENTATION TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     l_tl_table_name_documentation,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.id_parent_task_refid,
                     rec.flg_ongoing,
                     l_yes,
                     NULL,
                     rec.id_doc_area,
                     rec.dt_execution,
                     rec.flg_has_comments,
                     rec.dt_last_update,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.id_doc_area);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     id_doc_area,
                     dt_execution,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     id_group_import)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task, -- DOCUMENTATION TASK TYPE
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     l_tl_table_name_documentation,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.id_parent_task_refid,
                     rec.flg_ongoing,
                     l_yes,
                     NULL,
                     rec.id_doc_area,
                     rec.dt_execution,
                     rec.flg_has_comments,
                     rec.dt_last_update,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.id_doc_area);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_doc_area <> b.id_doc_area OR (a.id_doc_area IS NULL AND b.id_doc_area IS NOT NULL) OR
                                 (a.id_doc_area IS NOT NULL AND b.id_doc_area IS NULL)) OR
                                --
                                 (a.id_parent_task_refid <> b.id_parent_task_refid OR
                                 (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                                 (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL)) OR
                                --
                                 (a.dt_execution <> b.dt_execution OR
                                 (a.dt_execution IS NULL AND b.dt_execution IS NOT NULL) OR
                                 (a.dt_execution IS NOT NULL AND b.dt_execution IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                 (a.id_prof_review <> b.id_prof_review OR
                                 (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                 (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                 (a.id_group_import <> b.id_group_import OR
                                 (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                 (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                                --
                                 (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                 (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (l_id_tl_task_doc_all, l_id_tl_task_doc_ph)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.id_doc_area          = t.id_doc_area,
                       tt_ea.dt_execution         = t.dt_execution,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update,
                       tt_ea.id_prof_review       = t.id_prof_review,
                       tt_ea.id_group_import      = t.id_group_import
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     id_doc_area,
                     dt_execution,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     id_group_import)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.id_doc_area,
                     t.dt_execution,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.id_group_import);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_doc_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_doc_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DOC_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DOC_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_DOC_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_doc_ea;

    /********************************************************************************************
    * Update diet tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Pedro Carneiro
    * @version  2.6.2
    * @since    2012/04/26
    ********************************************************************************************/
    FUNCTION admin_task_tl_diet_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_DIET_EA';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_diet IS
            SELECT *
              FROM (SELECT edr.id_epis_diet_req,
                           edr.id_patient,
                           edr.id_episode,
                           e.id_visit,
                           e.id_institution,
                           CASE
                                WHEN edr.flg_status IN (pk_diet.g_flg_diet_status_s, pk_diet.g_flg_diet_status_c) THEN
                                 edr.dt_cancel
                                ELSE
                                 edr.dt_creation
                            END dt_creation,
                           edr.id_professional,
                           edr.dt_inicial,
                           edr.dt_end,
                           edr.flg_status,
                           CASE
                                WHEN edr.flg_status IN (pk_diet.g_flg_diet_status_s,
                                                        pk_diet.g_flg_diet_status_c,
                                                        pk_diet.g_flg_diet_status_x) THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated -- diet is suspended, cancelled or expired
                                WHEN edr.dt_end < g_sysdate_tstz THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated -- diet is complete
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated -- otherwise, diet is pending or ongoing
                            END flg_outdated,
                           CASE
                                WHEN edr.flg_status = pk_diet.g_flg_diet_status_s THEN
                                 3
                                WHEN edr.flg_status = pk_diet.g_flg_diet_status_c THEN
                                 5
                                WHEN edr.dt_inicial > g_sysdate_tstz THEN
                                 2
                                WHEN edr.dt_end < g_sysdate_tstz THEN
                                 4
                                ELSE
                                 1
                            END rank,
                           edr.id_diet_type id_group_import,
                           dt.code_diet_type code_desc_group,
                           edr.id_epis_diet_req_parent,
                           CASE
                                WHEN edr.flg_status IN (pk_diet.g_flg_diet_status_s,
                                                        pk_diet.g_flg_diet_status_c,
                                                        pk_diet.g_flg_diet_status_x) THEN
                                 pk_prog_notes_constants.g_task_finalized_f -- diet is suspended, cancelled or expired
                                WHEN edr.dt_end < g_sysdate_tstz THEN
                                 pk_prog_notes_constants.g_task_finalized_f -- diet is complete
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o -- diet is ongoing or pending
                            END flg_ongoing,
                           ei.id_software,
                           nvl((SELECT 1
                                 FROM epis_diet_req e
                                WHERE e.id_epis_diet_req_parent = edr.id_epis_diet_req
                                  AND rownum = 1),
                               0) flg_is_inactive
                      FROM epis_diet_req edr
                      JOIN diet_type dt
                        ON edr.id_diet_type = dt.id_diet_type
                     INNER JOIN episode e
                        ON edr.id_episode = e.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     INNER JOIN epis_info ei
                        ON edr.id_episode = ei.id_episode
                     WHERE (edr.id_patient = i_patient OR i_patient IS NULL)
                       AND (edr.id_episode = i_episode OR i_episode IS NULL)
                       AND (e.id_institution = i_institution OR i_institution IS NULL)
                       AND (edr.dt_inicial >= i_start_dt OR i_start_dt IS NULL)
                       AND (edr.dt_inicial <= i_end_dt OR i_end_dt IS NULL)
                          -- exclude draft and temporary diets
                       AND edr.flg_status NOT IN (pk_diet.g_flg_diet_status_t,
                                                  pk_diet.g_flg_diet_status_o,
                                                  pk_diet.g_flg_diet_status_c,
                                                  pk_diet.g_flg_diet_status_x))
             WHERE flg_is_inactive = 0;
    
        TYPE t_coll_diet IS TABLE OF c_diet%ROWTYPE;
        l_diet_rows t_coll_diet;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline Diets',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_diets))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_diet;
        LOOP
            -- get diet data
            FETCH c_diet BULK COLLECT
                INTO l_diet_rows LIMIT l_limit;
        
            IF l_diet_rows IS NOT NULL
               AND l_diet_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_diets;
                l_ea_row.table_name        := 'EPIS_DIET_REQ';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_diet_rows.first .. l_diet_rows.last
                LOOP
                    pk_diet.build_status_str(i_lang        => g_log_lang,
                                             i_prof        => profissional(NULL,
                                                                           l_diet_rows(i).id_institution,
                                                                           l_diet_rows(i).id_software),
                                             i_flg_status  => l_diet_rows(i).flg_status,
                                             i_dt_inicial  => l_diet_rows(i).dt_inicial,
                                             i_sys_date    => g_sysdate_tstz,
                                             o_status_str  => l_ea_row.status_str,
                                             o_status_msg  => l_ea_row.status_msg,
                                             o_status_icon => l_ea_row.status_icon,
                                             o_status_flg  => l_ea_row.status_flg);
                
                    l_ea_row.id_task_refid        := l_diet_rows(i).id_epis_diet_req;
                    l_ea_row.id_patient           := l_diet_rows(i).id_patient;
                    l_ea_row.id_episode           := l_diet_rows(i).id_episode;
                    l_ea_row.id_visit             := l_diet_rows(i).id_visit;
                    l_ea_row.id_institution       := l_diet_rows(i).id_institution;
                    l_ea_row.dt_req               := l_diet_rows(i).dt_creation;
                    l_ea_row.id_prof_req          := l_diet_rows(i).id_professional;
                    l_ea_row.dt_begin             := l_diet_rows(i).dt_inicial;
                    l_ea_row.dt_end               := l_diet_rows(i).dt_end;
                    l_ea_row.flg_status_req       := l_diet_rows(i).flg_status;
                    l_ea_row.flg_outdated := CASE
                                                 WHEN l_diet_rows(i).flg_is_inactive = 1 THEN
                                                  pk_ea_logic_tasktimeline.g_flg_outdated
                                                 ELSE
                                                  l_diet_rows(i).flg_outdated
                                             END;
                    l_ea_row.rank                 := l_diet_rows(i).rank;
                    l_ea_row.id_group_import      := l_diet_rows(i).id_group_import;
                    l_ea_row.code_desc_group      := l_diet_rows(i).code_desc_group;
                    l_ea_row.id_parent_task_refid := l_diet_rows(i).id_epis_diet_req_parent;
                    l_ea_row.flg_ongoing          := l_diet_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update       := l_diet_rows(i).dt_creation;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             status_str,
                             status_msg,
                             status_icon,
                             status_flg,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             id_parent_task_refid,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).status_str,
                             l_ea_rows(i).status_msg,
                             l_ea_rows(i).status_icon,
                             l_ea_rows(i).status_flg,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).id_parent_task_refid,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_diet%NOTFOUND;
        END LOOP;
    
        CLOSE c_diet;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND ((a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                               (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                               (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                               (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                               (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                               (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                               (a.id_institution <> b.id_institution OR
                               (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                               (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                               (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                               (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                               (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                               (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                               (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                               (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                               (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                               (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                               (a.flg_status_req <> b.flg_status_req OR
                               (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                               (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                               (a.flg_show_method <> b.flg_show_method OR
                               (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                               (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                               (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                               (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                               --
                               (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                               (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                               --
                               (a.status_icon <> b.status_icon OR (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                               (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                               --
                               (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                               (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                               --
                               (a.flg_outdated <> b.flg_outdated OR
                               (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                               (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                               (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                               (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                               (a.id_group_import <> b.id_group_import OR
                               (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                               (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                               (a.code_desc_group <> b.code_desc_group OR
                               (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                               (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                               (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                               (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                               (a.id_parent_task_refid <> b.id_parent_task_refid OR
                               (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                               (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL)) OR
                               --
                               (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                               (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                               (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                               (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                               (a.flg_has_comments <> b.flg_has_comments OR
                               (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                               (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                               (a.dt_last_update <> b.dt_last_update OR
                               (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                               (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_diets
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.dt_begin             = t.dt_begin,
                       tt_ea.dt_end               = t.dt_end,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.status_str           = t.status_str,
                       tt_ea.status_msg           = t.status_msg,
                       tt_ea.status_icon          = t.status_icon,
                       tt_ea.status_flg           = t.status_flg,
                       tt_ea.dt_dg_last_update    = t.dt_dg_last_update,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.rank                 = t.rank,
                       tt_ea.id_group_import      = t.id_group_import,
                       tt_ea.code_desc_group      = t.code_desc_group,
                       tt_ea.flg_sos              = t.flg_sos,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_diet_ea;
    /********************************************************************************************
    * Update positioning tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Paulo teixeira
    * @version  2.6.2
    * @since    2012/04/26
    ********************************************************************************************/
    FUNCTION admin_task_tl_posit_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_POSIT_EA';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_posit IS
            SELECT id_epis_positioning,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_request,
                   dt_req,
                   id_institution,
                   dt_epis_positioning,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   id_software,
                   dt_last_update
              FROM (SELECT ep.id_epis_positioning id_epis_positioning,
                           epi.id_patient id_patient,
                           ep.id_episode id_episode,
                           ep.flg_status flg_status,
                           ep.id_professional id_prof_request,
                           ep.dt_creation_tstz dt_req,
                           epi.id_institution id_institution,
                           ep.dt_epis_positioning,
                           epi.id_visit id_visit,
                           CASE
                                WHEN ep.flg_status IN
                                     (pk_timeline.g_epis_posit_flg_statu_e, pk_timeline.g_epis_posit_flg_statu_r) THEN
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_outdated
                            END flg_outdated,
                           CASE
                                WHEN ep.flg_status IN
                                     (pk_timeline.g_epis_posit_flg_statu_i, pk_inp_positioning.g_epis_posit_f) THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           ei.id_software,
                           (SELECT MAX(coalesce(epp.dt_epis_positioning_plan,
                                                epd.dt_epis_positioning_det,
                                                ep.dt_epis_positioning))
                              FROM epis_positioning_det epd
                              LEFT OUTER JOIN epis_positioning_plan epp
                                ON epd.id_epis_positioning_det = epp.id_epis_positioning_det
                             WHERE epd.id_epis_positioning = ep.id_epis_positioning
                               AND epp.dt_epis_positioning_plan IS NOT NULL) dt_last_update
                      FROM epis_positioning ep
                      JOIN episode epi
                        ON epi.id_episode = ep.id_episode
                       AND epi.flg_status <> pk_alert_constant.g_epis_status_cancel
                      LEFT JOIN epis_info ei
                        ON epi.id_episode = ei.id_episode
                     WHERE ep.flg_status IN (pk_timeline.g_epis_posit_flg_statu_e,
                                             pk_timeline.g_epis_posit_flg_statu_r,
                                             pk_timeline.g_epis_posit_flg_statu_i,
                                             pk_inp_positioning.g_epis_posit_f)
                       AND (epi.id_patient = i_patient OR i_patient IS NULL)
                       AND (ep.id_episode = i_episode OR i_episode IS NULL)
                       AND (epi.id_institution = i_institution OR i_institution IS NULL)
                       AND (ep.dt_epis_positioning >= i_start_dt OR i_start_dt IS NULL)
                       AND (ep.dt_epis_positioning <= i_end_dt OR i_end_dt IS NULL));
    
        TYPE t_coll_posit IS TABLE OF c_posit%ROWTYPE;
        l_posit_rows t_coll_posit;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_positioning',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_positioning))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_posit;
        LOOP
            -- get g_task_positioning data
            FETCH c_posit BULK COLLECT
                INTO l_posit_rows LIMIT l_limit;
        
            IF l_posit_rows IS NOT NULL
               AND l_posit_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_positioning;
                l_ea_row.table_name        := 'EPIS_POSITIONING';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_posit_rows.first .. l_posit_rows.last
                LOOP
                    l_ea_row.id_task_refid  := l_posit_rows(i).id_epis_positioning;
                    l_ea_row.dt_begin       := l_posit_rows(i).dt_epis_positioning;
                    l_ea_row.flg_status_req := l_posit_rows(i).flg_status;
                    l_ea_row.id_prof_req    := l_posit_rows(i).id_prof_request;
                    l_ea_row.dt_req         := l_posit_rows(i).dt_req;
                    l_ea_row.id_patient     := l_posit_rows(i).id_patient;
                    l_ea_row.id_episode     := l_posit_rows(i).id_episode;
                    l_ea_row.id_visit       := l_posit_rows(i).id_visit;
                    l_ea_row.id_institution := l_posit_rows(i).id_institution;
                    l_ea_row.flg_outdated   := l_posit_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing    := l_posit_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update := l_posit_rows(i).dt_last_update;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_posit%NOTFOUND;
        END LOOP;
    
        CLOSE c_posit;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_positioning
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.rank              = t.rank,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_posit_ea;

    /********************************************************************************************
    * Update future events tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Paulo teixeira
    * @version  2.6.2
    * @since    2012/04/26
    ********************************************************************************************/
    FUNCTION admin_task_tl_fe_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_FE_EA';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_fe IS
            SELECT id_consult_req,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_request,
                   dt_req,
                   id_institution,
                   code_description,
                   id_prof_exec,
                   dt_prev_plan_tstz,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   status_str,
                   status_msg,
                   status_flg,
                   status_icon,
                   id_tl_task
              FROM (SELECT cr.id_consult_req id_consult_req,
                           cr.id_patient id_patient,
                           cr.id_episode id_episode,
                           cr.flg_status flg_status,
                           cr.id_prof_req id_prof_request,
                           nvl(cr.dt_last_update, cr.dt_consult_req_tstz) dt_req,
                           cr.id_instit_requests id_institution,
                           CASE
                                WHEN fet.action = 'APPOINTMENT_NURSING' THEN
                                 'TL_TASK.CODE_TL_TASK.82'
                                WHEN fet.action = 'APPOINTMENT_NUTRITION' THEN
                                 'TL_TASK.CODE_TL_TASK.83'
                                WHEN fet.action = 'APPOINTMENT_REHABILITATION' THEN
                                 'TL_TASK.CODE_TL_TASK.84'
                                WHEN fet.action = 'APPOINTMENT_SOCIAL_WORKER' THEN
                                 'TL_TASK.CODE_TL_TASK.85'
                                ELSE
                                 'TL_TASK.CODE_TL_TASK.81'
                            END code_description,
                           cr.id_prof_last_update id_prof_exec,
                           cr.dt_begin_event dt_prev_plan_tstz,
                           e.id_visit id_visit,
                           CASE
                                WHEN cr.flg_status IN (pk_consult_req.g_consult_req_stat_proc) THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated
                            END flg_outdated,
                           CASE
                                WHEN cr.flg_status IN (pk_consult_req.g_consult_req_stat_proc) THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           status_str,
                           status_msg,
                           status_icon status_icon,
                           status_flg,
                           CASE
                                WHEN fet.action = 'APPOINTMENT_NURSING' THEN
                                 pk_prog_notes_constants.g_task_nursing_appointment
                                WHEN fet.action = 'APPOINTMENT_NUTRITION' THEN
                                 pk_prog_notes_constants.g_task_nutrition_appointment
                                WHEN fet.action = 'APPOINTMENT_REHABILITATION' THEN
                                 pk_prog_notes_constants.g_task_rehabilitation
                                WHEN fet.action = 'APPOINTMENT_SOCIAL_WORKER' THEN
                                 pk_prog_notes_constants.g_task_social_service
                                ELSE
                                 pk_prog_notes_constants.g_task_medical_appointment
                            END id_tl_task
                      FROM consult_req cr
                      JOIN future_event_type fet
                        ON fet.id_epis_type =
                           nvl(cr.id_epis_type, pk_events.get_epis_type_consult_req(cr.id_consult_req))
                       AND fet.action IN ('APPOINTMENT_MEDICAL',
                                          'APPOINTMENT_NURSING',
                                          'APPOINTMENT_NUTRITION',
                                          'APPOINTMENT_REHABILITATION',
                                          'APPOINTMENT_SOCIAL_WORKER')
                      LEFT JOIN episode e
                        ON e.id_episode = cr.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE (e.id_patient = i_patient OR i_patient IS NULL)
                       AND (cr.id_episode = i_episode OR i_episode IS NULL)
                       AND (e.id_institution = i_institution OR i_institution IS NULL)
                       AND (cr.dt_begin_event >= i_start_dt OR i_start_dt IS NULL)
                       AND (cr.dt_begin_event <= i_end_dt OR i_end_dt IS NULL)
                       AND cr.flg_status <> pk_consult_req.g_consult_req_stat_cancel);
    
        TYPE t_coll_fe IS TABLE OF c_fe%ROWTYPE;
        l_fe_rows t_coll_fe;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline 82, 83, 84, 85, 81',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                                 i_episode     => i_episode,
                                                                 i_institution => i_institution,
                                                                 i_start_dt    => i_start_dt,
                                                                 i_end_dt      => i_end_dt,
                                                                 i_id_tl_task  => table_number(82, 83, 84, 85, 81))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        OPEN c_fe;
        LOOP
            -- get g_task_positioning data
            FETCH c_fe BULK COLLECT
                INTO l_fe_rows LIMIT l_limit;
        
            IF l_fe_rows IS NOT NULL
               AND l_fe_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := 'CONSULT_REQ';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_fe_rows.first .. l_fe_rows.last
                LOOP
                    l_ea_row.id_tl_task       := l_fe_rows(i).id_tl_task;
                    l_ea_row.id_task_refid    := l_fe_rows(i).id_consult_req;
                    l_ea_row.dt_begin         := l_fe_rows(i).dt_prev_plan_tstz;
                    l_ea_row.flg_status_req   := l_fe_rows(i).flg_status;
                    l_ea_row.id_prof_req      := l_fe_rows(i).id_prof_request;
                    l_ea_row.dt_req           := l_fe_rows(i).dt_req;
                    l_ea_row.id_patient       := l_fe_rows(i).id_patient;
                    l_ea_row.id_episode       := l_fe_rows(i).id_episode;
                    l_ea_row.id_visit         := l_fe_rows(i).id_visit;
                    l_ea_row.id_institution   := l_fe_rows(i).id_institution;
                    l_ea_row.code_description := l_fe_rows(i).code_description;
                    l_ea_row.id_prof_exec     := l_fe_rows(i).id_prof_exec;
                    l_ea_row.status_str       := l_fe_rows(i).status_str;
                    l_ea_row.status_msg       := l_fe_rows(i).status_msg;
                    l_ea_row.status_icon      := l_fe_rows(i).status_icon;
                    l_ea_row.status_flg       := l_fe_rows(i).status_flg;
                    l_ea_row.flg_outdated     := l_fe_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing      := l_fe_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update   := l_fe_rows(i).dt_req;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             status_str,
                             status_msg,
                             status_icon,
                             status_flg,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).status_str,
                             l_ea_rows(i).status_msg,
                             l_ea_rows(i).status_icon,
                             l_ea_rows(i).status_flg,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                --COMMIT;
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_fe%NOTFOUND;
        END LOOP;
    
        CLOSE c_fe;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                               --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                               --
                                (a.status_icon <> b.status_icon OR (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                               --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (82, 83, 84, 85, 81)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.rank              = t.rank,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.status_str        = t.status_str,
                       tt_ea.status_msg        = t.status_msg,
                       tt_ea.status_icon       = t.status_icon,
                       tt_ea.status_flg        = t.status_flg,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_fe_ea;

    /********************************************************************************************
    * Update procedure notes tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Pedro Carneiro
    * @version  2.6.2
    * @since    2012/05/03
    ********************************************************************************************/
    FUNCTION admin_task_tl_proc_notes_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROC_NOTES_EA';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_notes IS
            SELECT n.*
              FROM (SELECT tm.id_treatment_management,
                           coalesce(ip.id_patient, e1.id_patient, e2.id_patient) id_patient,
                           nvl(e1.id_episode, e2.id_episode) id_episode,
                           nvl(e1.id_visit, e2.id_visit) id_visit,
                           nvl(e1.id_institution, e2.id_institution) id_institution,
                           tm.dt_creation_tstz,
                           tm.id_professional,
                           tm.desc_treatment_management,
                           ipd.id_interv_presc_det
                      FROM treatment_management tm
                      JOIN interv_presc_det ipd
                        ON tm.id_treatment = ipd.id_interv_presc_det
                      JOIN interv_prescription ip
                        ON ipd.id_interv_prescription = ip.id_interv_prescription
                      LEFT JOIN episode e1
                        ON ip.id_episode = e1.id_episode
                      LEFT JOIN episode e2
                        ON ip.id_episode_origin = e2.id_episode
                     WHERE tm.flg_type = pk_medical_decision.g_treat_type_interv
                       AND nvl(e1.flg_status, e2.flg_status) <> pk_alert_constant.g_epis_status_cancel) n
             WHERE (n.id_patient = i_patient OR i_patient IS NULL)
               AND (n.id_episode = i_episode OR i_episode IS NULL)
               AND (n.id_institution = i_institution OR i_institution IS NULL)
               AND (n.dt_creation_tstz >= i_start_dt OR i_start_dt IS NULL)
               AND (n.dt_creation_tstz <= i_end_dt OR i_end_dt IS NULL);
    
        TYPE t_coll_notes IS TABLE OF c_notes%ROWTYPE;
        l_notes_rows t_coll_notes;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_procedures_comments',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_procedures_comments))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        OPEN c_notes;
        LOOP
            -- get diet data
            FETCH c_notes BULK COLLECT
                INTO l_notes_rows LIMIT l_limit;
        
            IF l_notes_rows IS NOT NULL
               AND l_notes_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_procedures_comments;
                l_ea_row.table_name        := 'TREATMENT_MANAGEMENT';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_outdated;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_notes_rows.first .. l_notes_rows.last
                LOOP
                    l_ea_row.id_task_refid       := l_notes_rows(i).id_treatment_management;
                    l_ea_row.id_patient          := l_notes_rows(i).id_patient;
                    l_ea_row.id_episode          := l_notes_rows(i).id_episode;
                    l_ea_row.id_visit            := l_notes_rows(i).id_visit;
                    l_ea_row.id_institution      := l_notes_rows(i).id_institution;
                    l_ea_row.dt_req              := l_notes_rows(i).dt_creation_tstz;
                    l_ea_row.id_prof_req         := l_notes_rows(i).id_professional;
                    l_ea_row.universal_desc_clob := to_clob(l_notes_rows(i).desc_treatment_management);
                    l_ea_row.id_parent_comments  := l_notes_rows(i).id_interv_presc_det;
                    l_ea_row.dt_last_update      := l_notes_rows(i).dt_creation_tstz;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             flg_sos,
                             universal_desc_clob,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             id_parent_comments,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).universal_desc_clob,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).id_parent_comments,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_notes%NOTFOUND;
        END LOOP;
    
        CLOSE c_notes;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND ((a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                               (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                               (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                               (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                               (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                               (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                               (a.id_institution <> b.id_institution OR
                               (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                               (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                               (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                               (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                               (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                               (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                               (a.flg_show_method <> b.flg_show_method OR
                               (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                               (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                               (a.dt_dg_last_update <> b.dt_dg_last_update OR
                               (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                               (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                               (a.flg_outdated <> b.flg_outdated OR
                               (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                               (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                               (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                               (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                               (pk_string_utils.clob_to_sqlvarchar2(a.universal_desc_clob) <>
                               pk_string_utils.clob_to_sqlvarchar2(b.universal_desc_clob) OR
                               (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                               (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                               --
                               (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                               (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                               (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                               (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                               (a.flg_has_comments <> b.flg_has_comments OR
                               (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                               (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                               (a.id_parent_comments <> b.id_parent_comments OR
                               (a.id_parent_comments IS NULL AND b.id_parent_comments IS NOT NULL) OR
                               (a.id_parent_comments IS NOT NULL AND b.id_parent_comments IS NULL)) OR
                               --
                               (a.dt_last_update <> b.dt_last_update OR
                               (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                               (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_procedures_comments
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.flg_show_method     = t.flg_show_method,
                       tt_ea.dt_dg_last_update   = t.dt_dg_last_update,
                       tt_ea.flg_outdated        = t.flg_outdated,
                       tt_ea.flg_sos             = t.flg_sos,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.id_parent_comments  = t.id_parent_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_sos,
                     universal_desc_clob,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     id_parent_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.flg_sos,
                     t.universal_desc_clob,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.id_parent_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_proc_notes_ea;

    /********************************************************************************************
    * Update prescription notes tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Pedro Carneiro
    * @version  2.6.2
    * @since    2012/05/08
    ********************************************************************************************/
    FUNCTION admin_task_tl_presc_notes
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PRESC_NOTES';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_cursor        pk_types.cursor_type;
        l_presc_tbl     table_number;
        l_pat_tbl       table_number;
        l_epis_tbl      table_number;
        l_inst_tbl      table_number;
        l_pnotes_tbl    table_number;
        l_pnitem_tbl    table_number;
        l_dt_req_tbl    table_timestamp_tz;
        l_prof_tbl      table_number;
        l_notes_tbl     table_varchar;
        l_error         t_error_out;
        l_id_visit      episode.id_visit%TYPE;
        l_idx           PLS_INTEGER := 1;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_medication_comments',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_medication_comments))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
        IF i_patient IS NOT NULL
           OR i_episode IS NOT NULL
        THEN
            g_error := 'CALL pk_api_pfh_in.get_presc_notes_ttl';
            pk_api_pfh_in.get_presc_notes_ttl(i_lang       => g_log_lang,
                                              i_prof       => profissional(NULL, NULL, NULL),
                                              i_id_patient => i_patient,
                                              i_id_episode => i_episode,
                                              o_notes_info => l_cursor);
        
            LOOP
                -- get notes data
                FETCH l_cursor BULK COLLECT
                    INTO l_presc_tbl,
                         l_pat_tbl,
                         l_epis_tbl,
                         l_inst_tbl,
                         l_pnotes_tbl,
                         l_pnitem_tbl,
                         l_dt_req_tbl,
                         l_prof_tbl,
                         l_notes_tbl LIMIT l_limit;
            
                IF l_presc_tbl IS NOT NULL
                   AND l_presc_tbl.count > 0
                THEN
                    -- set constant fields
                    l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_medication_comments;
                    l_ea_row.table_name        := 'PRESC_NOTES_ITEM';
                    l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                    l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                    l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_outdated;
                    l_ea_row.flg_sos           := pk_alert_constant.g_no;
                    l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                    l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                    l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
                
                    -- set variable fields
                    FOR i IN l_presc_tbl.first .. l_presc_tbl.last
                    LOOP
                        BEGIN
                            l_id_visit := pk_episode.get_id_visit(i_episode => l_epis_tbl(i));
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_id_visit := NULL;
                        END;
                    
                        IF (l_id_visit IS NOT NULL)
                        THEN
                            l_ea_row.id_task_refid := l_pnitem_tbl(i);
                            l_ea_row.id_patient    := l_pat_tbl(i);
                            l_ea_row.id_episode    := l_epis_tbl(i);
                        
                            l_ea_row.id_visit            := l_id_visit;
                            l_ea_row.id_institution      := l_inst_tbl(i);
                            l_ea_row.dt_req              := l_dt_req_tbl(i);
                            l_ea_row.id_prof_req         := l_prof_tbl(i);
                            l_ea_row.universal_desc_clob := to_clob(l_notes_tbl(i));
                            l_ea_row.id_parent_comments  := l_presc_tbl(i);
                            l_ea_row.dt_last_update      := l_dt_req_tbl(i);
                            -- add row to rows collection
                            l_ea_rows(l_idx) := l_ea_row;
                            l_idx := l_idx + 1;
                        END IF;
                    END LOOP;
                
                    IF i_validate_table
                    THEN
                        -- add rows collection to temporary ea
                        FORALL i IN l_ea_rows.first .. l_ea_rows.last
                            INSERT INTO task_timeline_ea_tmp
                                (id_task_refid,
                                 id_tl_task,
                                 id_patient,
                                 id_episode,
                                 id_visit,
                                 id_institution,
                                 dt_req,
                                 id_prof_req,
                                 table_name,
                                 flg_show_method,
                                 dt_dg_last_update,
                                 flg_outdated,
                                 flg_sos,
                                 universal_desc_clob,
                                 flg_ongoing,
                                 flg_normal,
                                 flg_has_comments,
                                 id_parent_comments,
                                 dt_last_update)
                            VALUES
                                (l_ea_rows(i).id_task_refid,
                                 l_ea_rows(i).id_tl_task,
                                 l_ea_rows(i).id_patient,
                                 l_ea_rows(i).id_episode,
                                 l_ea_rows(i).id_visit,
                                 l_ea_rows(i).id_institution,
                                 l_ea_rows(i).dt_req,
                                 l_ea_rows(i).id_prof_req,
                                 l_ea_rows(i).table_name,
                                 l_ea_rows(i).flg_show_method,
                                 l_ea_rows(i).dt_dg_last_update,
                                 l_ea_rows(i).flg_outdated,
                                 l_ea_rows(i).flg_sos,
                                 l_ea_rows(i).universal_desc_clob,
                                 l_ea_rows(i).flg_ongoing,
                                 l_ea_rows(i).flg_normal,
                                 l_ea_rows(i).flg_has_comments,
                                 l_ea_rows(i).id_parent_comments,
                                 l_ea_rows(i).dt_last_update);
                    END IF;
                
                    IF i_recreate_table
                       AND NOT i_validate_table
                    THEN
                        -- add rows collection to ea
                        ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                    END IF;
                
                    l_count := l_count + l_ea_rows.count;
                
                    l_ea_rows.delete;
                
                END IF;
            
                EXIT WHEN l_cursor%NOTFOUND;
            END LOOP;
        
            CLOSE l_cursor;
        ELSE
            FOR i IN (SELECT id_patient, id_episode
                        FROM episode)
            LOOP
                pk_api_pfh_in.get_presc_notes_ttl(i_lang       => g_log_lang,
                                                  i_prof       => profissional(NULL, NULL, NULL),
                                                  i_id_patient => i.id_patient,
                                                  i_id_episode => i.id_episode,
                                                  o_notes_info => l_cursor);
                LOOP
                    --get notes data
                    FETCH l_cursor BULK COLLECT
                        INTO l_presc_tbl,
                             l_pat_tbl,
                             l_epis_tbl,
                             l_inst_tbl,
                             l_pnotes_tbl,
                             l_pnitem_tbl,
                             l_dt_req_tbl,
                             l_prof_tbl,
                             l_notes_tbl LIMIT l_limit;
                    IF l_presc_tbl IS NOT NULL
                       AND l_presc_tbl.count > 0
                    THEN
                        -- set constant fields
                        l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_medication_comments;
                        l_ea_row.table_name        := 'PRESC_NOTES_ITEM';
                        l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                        l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                        l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_outdated;
                        l_ea_row.flg_sos           := pk_alert_constant.g_no;
                        l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                        l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                        l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
                        -- set variable fields
                        FOR i IN l_presc_tbl.first .. l_presc_tbl.last
                        LOOP
                            BEGIN
                                l_id_visit := pk_episode.get_id_visit(i_episode => l_epis_tbl(i));
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_id_visit := NULL;
                            END;
                            IF (l_id_visit IS NOT NULL)
                            THEN
                                l_ea_row.id_task_refid       := l_pnitem_tbl(i);
                                l_ea_row.id_patient          := l_pat_tbl(i);
                                l_ea_row.id_episode          := l_epis_tbl(i);
                                l_ea_row.id_visit            := l_id_visit;
                                l_ea_row.id_institution      := l_inst_tbl(i);
                                l_ea_row.dt_req              := l_dt_req_tbl(i);
                                l_ea_row.id_prof_req         := l_prof_tbl(i);
                                l_ea_row.universal_desc_clob := to_clob(l_notes_tbl(i));
                                l_ea_row.id_parent_comments  := l_presc_tbl(i);
                                l_ea_row.dt_last_update      := l_dt_req_tbl(i);
                                -- add row to rows collection
                                l_ea_rows(l_idx) := l_ea_row;
                                l_idx := l_idx + 1;
                            END IF;
                        END LOOP;
                        IF i_validate_table
                        THEN
                            --add rows collection to temporary ea
                            FORALL i IN l_ea_rows.first .. l_ea_rows.last
                                INSERT INTO task_timeline_ea_tmp
                                    (id_task_refid,
                                     id_tl_task,
                                     id_patient,
                                     id_episode,
                                     id_visit,
                                     id_institution,
                                     dt_req,
                                     id_prof_req,
                                     table_name,
                                     flg_show_method,
                                     dt_dg_last_update,
                                     flg_outdated,
                                     flg_sos,
                                     universal_desc_clob,
                                     flg_ongoing,
                                     flg_normal,
                                     flg_has_comments,
                                     id_parent_comments,
                                     dt_last_update)
                                VALUES
                                    (l_ea_rows(i).id_task_refid,
                                     l_ea_rows(i).id_tl_task,
                                     l_ea_rows(i).id_patient,
                                     l_ea_rows(i).id_episode,
                                     l_ea_rows(i).id_visit,
                                     l_ea_rows(i).id_institution,
                                     l_ea_rows(i).dt_req,
                                     l_ea_rows(i).id_prof_req,
                                     l_ea_rows(i).table_name,
                                     l_ea_rows(i).flg_show_method,
                                     l_ea_rows(i).dt_dg_last_update,
                                     l_ea_rows(i).flg_outdated,
                                     l_ea_rows(i).flg_sos,
                                     l_ea_rows(i).universal_desc_clob,
                                     l_ea_rows(i).flg_ongoing,
                                     l_ea_rows(i).flg_normal,
                                     l_ea_rows(i).flg_has_comments,
                                     l_ea_rows(i).id_parent_comments,
                                     l_ea_rows(i).dt_last_update);
                        END IF;
                        IF i_recreate_table
                           AND NOT i_validate_table
                        THEN
                            -- add rows collection to ea
                            ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                        END IF;
                        l_count := l_count + l_ea_rows.count;
                        l_ea_rows.delete;
                    END IF;
                    EXIT WHEN l_cursor%NOTFOUND;
                END LOOP;
                CLOSE l_cursor;
            END LOOP;
        END IF;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (pk_string_utils.clob_to_sqlvarchar2(a.universal_desc_clob) <>
                                pk_string_utils.clob_to_sqlvarchar2(b.universal_desc_clob) OR
                                (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.id_parent_comments <> b.id_parent_comments OR
                                (a.id_parent_comments IS NULL AND b.id_parent_comments IS NOT NULL) OR
                                (a.id_parent_comments IS NOT NULL AND b.id_parent_comments IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_medication_comments
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.flg_show_method     = t.flg_show_method,
                       tt_ea.dt_dg_last_update   = t.dt_dg_last_update,
                       tt_ea.flg_outdated        = t.flg_outdated,
                       tt_ea.flg_sos             = t.flg_sos,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.flg_has_comments    = t.flg_has_comments,
                       tt_ea.id_parent_comments  = t.id_parent_comments,
                       tt_ea.dt_last_update      = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_sos,
                     universal_desc_clob,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     id_parent_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.flg_sos,
                     t.universal_desc_clob,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.id_parent_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_presc_notes;

    /********************************************************************************************
    * Update intake and output tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Pedro Carneiro
    * @version  2.6.2
    * @since    2012/05/10
    ********************************************************************************************/
    FUNCTION admin_task_tl_hidrics
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_HIDRICS';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_hidric IS
            SELECT eh.id_epis_hidrics,
                   e.id_patient,
                   eh.id_episode,
                   e.id_visit,
                   e.id_institution,
                   eh.dt_creation_tstz,
                   eh.id_professional,
                   eh.dt_initial_tstz,
                   eh.dt_end_tstz,
                   eh.flg_status,
                   CASE
                        WHEN eh.flg_status IN
                             (pk_inp_hidrics_constant.g_epis_hidric_r, pk_inp_hidrics_constant.g_epis_hidric_e) THEN
                         pk_ea_logic_tasktimeline.g_flg_not_outdated
                        ELSE
                         pk_ea_logic_tasktimeline.g_flg_outdated
                    END flg_outdated,
                   eh.id_hidrics_type,
                   ht.code_hidrics_type,
                   CASE
                        WHEN eh.flg_status IN
                             (pk_inp_hidrics_constant.g_epis_hidric_f, pk_inp_hidrics_constant.g_epis_hidric_i) THEN
                         pk_prog_notes_constants.g_task_finalized_f
                        ELSE
                         pk_prog_notes_constants.g_task_ongoing_o
                    END flg_ongoing,
                   (SELECT MAX(ehd.dt_execution_tstz)
                      FROM epis_hidrics_det ehd
                     WHERE ehd.id_epis_hidrics = eh.id_epis_hidrics) dt_last_execution,
                   eh.dt_epis_hidrics,
                   coalesce(eh.dt_epis_hidrics, eh.dt_inter_tstz, eh.dt_creation_tstz) dt_last_update
              FROM epis_hidrics eh
              JOIN episode e
                ON eh.id_episode = e.id_episode
               AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
              JOIN hidrics_type ht
                ON eh.id_hidrics_type = ht.id_hidrics_type
             WHERE (eh.id_patient = i_patient OR i_patient IS NULL)
               AND (eh.id_episode = i_episode OR i_episode IS NULL)
               AND (e.id_institution = i_institution OR i_institution IS NULL)
               AND (eh.dt_initial_tstz >= i_start_dt OR i_start_dt IS NULL)
               AND (eh.dt_initial_tstz <= i_end_dt OR i_end_dt IS NULL)
               AND eh.flg_status NOT IN (pk_inp_hidrics_constant.g_epis_hidric_d,
                                         pk_inp_hidrics_constant.g_epis_hidric_l,
                                         pk_inp_hidrics_constant.g_epis_hidric_c,
                                         pk_inp_hidrics_constant.g_epis_hidric_o);
    
        TYPE t_coll_hidric IS TABLE OF c_hidric%ROWTYPE;
        l_hidric_rows t_coll_hidric;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_intake_output',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_intake_output))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_hidric;
        LOOP
        
            -- get notes data
            FETCH c_hidric BULK COLLECT
                INTO l_hidric_rows LIMIT l_limit;
        
            IF l_hidric_rows IS NOT NULL
               AND l_hidric_rows.count > 0
            THEN
            
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_intake_output;
                l_ea_row.table_name        := 'EPIS_HIDRICS';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_hidric_rows.first .. l_hidric_rows.last
                LOOP
                    l_ea_row.id_task_refid     := l_hidric_rows(i).id_epis_hidrics;
                    l_ea_row.id_patient        := l_hidric_rows(i).id_patient;
                    l_ea_row.id_episode        := l_hidric_rows(i).id_episode;
                    l_ea_row.id_visit          := l_hidric_rows(i).id_visit;
                    l_ea_row.id_institution    := l_hidric_rows(i).id_institution;
                    l_ea_row.dt_req            := l_hidric_rows(i).dt_creation_tstz;
                    l_ea_row.id_prof_req       := l_hidric_rows(i).id_professional;
                    l_ea_row.dt_begin          := l_hidric_rows(i).dt_initial_tstz;
                    l_ea_row.dt_end            := l_hidric_rows(i).dt_end_tstz;
                    l_ea_row.flg_status_req    := l_hidric_rows(i).flg_status;
                    l_ea_row.flg_outdated      := l_hidric_rows(i).flg_outdated;
                    l_ea_row.id_group_import   := l_hidric_rows(i).id_hidrics_type;
                    l_ea_row.code_desc_group   := l_hidric_rows(i).code_hidrics_type;
                    l_ea_row.flg_ongoing       := l_hidric_rows(i).flg_ongoing;
                    l_ea_row.dt_last_execution := l_hidric_rows(i).dt_last_execution;
                    l_ea_row.dt_last_update    := l_hidric_rows(i).dt_last_update;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_hidric%NOTFOUND;
        END LOOP;
    
        CLOSE c_hidric;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_intake_output
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_hidrics;

    /********************************************************************************************
    * Update consult tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Sérgio Santos
    * @version  2.6.2
    * @since    2012/08/22
    ********************************************************************************************/
    FUNCTION admin_task_tl_consults
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_CONSULTS';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'OPINION';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_disch_instr IS
            SELECT o.id_opinion,
                   o.id_opinion_type,
                   o.id_patient,
                   o.id_episode,
                   e.id_visit,
                   e.id_institution,
                   o.dt_problem_tstz,
                   o.id_prof_questions,
                   o.flg_state,
                   pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated,
                   CASE
                        WHEN o.flg_state = pk_opinion.g_opinion_reply_read
                             OR o.flg_state = pk_opinion.g_opinion_over THEN
                         pk_prog_notes_constants.g_task_finalized_f
                        ELSE
                         pk_prog_notes_constants.g_task_ongoing_o
                    END flg_ongoing,
                   nvl(o.dt_last_update,
                       (SELECT MAX(op.dt_opinion_prof_tstz)
                          FROM opinion_prof op
                         WHERE op.id_opinion = o.id_opinion)) dt_last_update,
                   e.flg_status flg_status_epis
              FROM opinion o
              JOIN episode e
                ON e.id_episode = o.id_episode
             WHERE (o.id_patient = i_patient OR i_patient IS NULL)
               AND (o.id_episode = i_episode OR i_episode IS NULL)
               AND (e.id_institution = i_institution OR i_institution IS NULL)
               AND (o.dt_last_update >= i_start_dt OR i_start_dt IS NULL)
               AND (o.dt_last_update <= i_end_dt OR i_end_dt IS NULL)
               AND o.flg_state <> pk_opinion.g_status_cancel;
    
        TYPE t_coll_disch_instr IS TABLE OF c_disch_instr%ROWTYPE;
        l_disch_instr_rows t_coll_disch_instr;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline consults',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_opinion,
                                                                                            pk_prog_notes_constants.g_task_opinion_die,
                                                                                            pk_prog_notes_constants.g_task_opinion_sw,
                                                                                            pk_prog_notes_constants.g_task_opinion_cm,
                                                                                            pk_prog_notes_constants.g_task_opinion_at))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_disch_instr;
        LOOP
            -- get notes data
            FETCH c_disch_instr BULK COLLECT
                INTO l_disch_instr_rows LIMIT l_limit;
        
            IF l_disch_instr_rows IS NOT NULL
               AND l_disch_instr_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := l_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_disch_instr_rows.first .. l_disch_instr_rows.last
                LOOP
                    l_ea_row.id_task_refid   := l_disch_instr_rows(i).id_opinion;
                    l_ea_row.id_task_related := l_disch_instr_rows(i).id_opinion;
                    l_ea_row.id_tl_task      := pk_ea_logic_opinion.get_id_tt_from_id_op_type(l_disch_instr_rows(i).id_opinion_type);
                    l_ea_row.id_patient      := l_disch_instr_rows(i).id_patient;
                    l_ea_row.id_episode      := l_disch_instr_rows(i).id_episode;
                    l_ea_row.id_visit        := l_disch_instr_rows(i).id_visit;
                    l_ea_row.id_institution  := l_disch_instr_rows(i).id_institution;
                    l_ea_row.dt_req          := l_disch_instr_rows(i).dt_problem_tstz;
                    l_ea_row.id_prof_req     := l_disch_instr_rows(i).id_prof_questions;
                    --del--l_ea_row.dt_begin          := l_disch_instr_rows(i).dt_initial_tstz;
                    --del--l_ea_row.dt_end            := l_disch_instr_rows(i).dt_end_tstz;
                    l_ea_row.flg_status_req := l_disch_instr_rows(i).flg_state;
                    l_ea_row.flg_outdated   := l_disch_instr_rows(i).flg_outdated;
                    --del--l_ea_row.id_group_import   := l_disch_instr_rows(i).id_hidrics_type;
                    --del--l_ea_row.code_desc_group   := l_disch_instr_rows(i).code_hidrics_type;
                    l_ea_row.flg_ongoing       := l_disch_instr_rows(i).flg_ongoing;
                    l_ea_row.dt_last_execution := l_disch_instr_rows(i).dt_last_update;
                    l_ea_row.dt_last_update    := l_disch_instr_rows(i).dt_last_update;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                --COMMIT;
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_disch_instr%NOTFOUND;
        END LOOP;
    
        CLOSE c_disch_instr;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)))
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS
                    (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_opinion,
                                                         pk_prog_notes_constants.g_task_opinion_die,
                                                         pk_prog_notes_constants.g_task_opinion_sw,
                                                         pk_prog_notes_constants.g_task_opinion_cm,
                                                         pk_prog_notes_constants.g_task_opinion_at)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_consults;

    /********************************************************************************************
    * Update CITS records in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Sofia Mendes
    * @version  2.6.3
    * @since    11-Jul-2013
    ********************************************************************************************/
    FUNCTION admin_task_tl_cit
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_CIT';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        -- TYPE t_coll_cits IS TABLE OF pk_ea_logic_triage.c_triage%ROWTYPE;
        l_cits_rows pk_ea_logic_cit.t_coll_cits;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_cits',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_cits))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_cit.c_cits',
                              object_name     => g_package_name,
                              sub_object_name => l_func_name);
        OPEN pk_ea_logic_cit.c_cits(i_rowids          => NULL,
                                    i_patient         => i_patient,
                                    i_episode         => i_episode,
                                    i_institution     => i_institution,
                                    i_start_dt        => i_start_dt,
                                    i_end_dt          => i_end_dt,
                                    i_excluded_status => table_varchar(pk_cit.g_flg_status_canceled,
                                                                       pk_cit.g_flg_status_expired));
        LOOP
        
            -- get cits data
            FETCH pk_ea_logic_cit.c_cits BULK COLLECT
                INTO l_cits_rows LIMIT l_limit;
        
            IF l_cits_rows IS NOT NULL
               AND l_cits_rows.count > 0
            THEN
            
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_cits;
                l_ea_row.table_name        := pk_ea_logic_cit.g_cits_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_patient;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_cits_rows.first .. l_cits_rows.last
                LOOP
                    l_ea_row.id_task_refid     := l_cits_rows(i).id_pat_cit;
                    l_ea_row.id_patient        := l_cits_rows(i).id_patient;
                    l_ea_row.id_episode        := l_cits_rows(i).id_episode;
                    l_ea_row.id_visit          := l_cits_rows(i).id_visit;
                    l_ea_row.id_institution    := l_cits_rows(i).id_institution;
                    l_ea_row.dt_req            := l_cits_rows(i).dt_begin;
                    l_ea_row.id_prof_req       := l_cits_rows(i).id_professional;
                    l_ea_row.dt_begin          := l_cits_rows(i).dt_begin;
                    l_ea_row.dt_end            := l_cits_rows(i).dt_end;
                    l_ea_row.flg_status_req    := pk_alert_constant.g_active;
                    l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_not_outdated;
                    l_ea_row.id_group_import   := NULL;
                    l_ea_row.code_desc_group   := NULL;
                    l_ea_row.flg_ongoing       := l_cits_rows(i).flg_ongoing;
                    l_ea_row.dt_last_execution := NULL;
                    l_ea_row.dt_last_update    := l_cits_rows(i).dt_last_update;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN pk_ea_logic_cit.c_cits%NOTFOUND;
        END LOOP;
    
        CLOSE pk_ea_logic_cit.c_cits;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_cits
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_cit;

    /********************************************************************************************
    * Update discharge instructions tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Sérgio Santos
    * @version  2.6.2
    * @since    2012/08/22
    ********************************************************************************************/
    FUNCTION admin_task_tl_disch_instruc
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_DISCH_INSTRUC';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'DISCHARGE_NOTES';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_disch_instr IS
            SELECT /*+ opt_estimate(table tf_e rows=1)*/
             dn.id_discharge_notes,
             dn.id_patient,
             dn.id_episode,
             e.id_visit,
             e.id_institution,
             dn.dt_creation_tstz,
             dn.id_professional,
             dn.flg_status,
             pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated,
             pk_prog_notes_constants.g_task_finalized_f  flg_ongoing,
             e.flg_status                                flg_status_epis
              FROM discharge_notes dn
              JOIN episode e
                ON e.id_episode = dn.id_episode
              JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                ON tf_e.id_episode = e.id_episode
             WHERE (dn.dt_creation_tstz >= i_start_dt OR i_start_dt IS NULL)
               AND (dn.dt_creation_tstz <= i_end_dt OR i_end_dt IS NULL)
               AND dn.flg_status <> pk_discharge.g_disch_notes_c
               AND dn.dt_creation_tstz = (SELECT MAX(dn2.dt_creation_tstz)
                                            FROM discharge_notes dn2
                                           WHERE dn2.id_episode = dn.id_episode);
    
        TYPE t_coll_disch_instr IS TABLE OF c_disch_instr%ROWTYPE;
        l_disch_instr_rows t_coll_disch_instr;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_disch_instructions',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_disch_instructions))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_disch_instr;
        LOOP
            -- get notes data
            FETCH c_disch_instr BULK COLLECT
                INTO l_disch_instr_rows LIMIT l_limit;
        
            IF l_disch_instr_rows IS NOT NULL
               AND l_disch_instr_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := l_src_table;
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_disch_instructions;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_disch_instr_rows.first .. l_disch_instr_rows.last
                LOOP
                    l_ea_row.id_task_refid     := l_disch_instr_rows(i).id_discharge_notes;
                    l_ea_row.id_patient        := l_disch_instr_rows(i).id_patient;
                    l_ea_row.id_episode        := l_disch_instr_rows(i).id_episode;
                    l_ea_row.id_visit          := l_disch_instr_rows(i).id_visit;
                    l_ea_row.id_institution    := l_disch_instr_rows(i).id_institution;
                    l_ea_row.dt_req            := l_disch_instr_rows(i).dt_creation_tstz;
                    l_ea_row.id_prof_req       := l_disch_instr_rows(i).id_professional;
                    l_ea_row.flg_status_req    := l_disch_instr_rows(i).flg_status;
                    l_ea_row.flg_outdated      := l_disch_instr_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing       := l_disch_instr_rows(i).flg_ongoing;
                    l_ea_row.dt_last_execution := l_disch_instr_rows(i).dt_creation_tstz;
                    l_ea_row.dt_last_update    := l_disch_instr_rows(i).dt_creation_tstz;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_disch_instr%NOTFOUND;
        END LOOP;
    
        CLOSE c_disch_instr;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_disch_instructions
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_disch_instruc;

    /********************************************************************************************
    * Update consult tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Jorge Silva
    * @version  2.6.2
    * @since    2012/09/05
    ********************************************************************************************/
    FUNCTION admin_task_tl_inp_surg
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_INP_SURG';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'ADM_REQUEST';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        l_id_prof professional.id_professional%TYPE := pk_sysconfig.get_config(i_code_cf   => 'ID_PROF_BACKGROUND',
                                                                               i_prof_inst => i_institution,
                                                                               i_prof_soft => 0);
        --l_prof    profissional := profissional(l_id_prof, i_institution, 0);
    
        CURSOR c_admission IS
            SELECT *
              FROM (SELECT ar.id_adm_request,
                           ar.id_upd_episode id_episode,
                           epi_o.id_patient,
                           decode(pk_surgery_request.get_epis_done_state(g_log_lang,
                                                                         wl.id_waiting_list,
                                                                         pk_alert_constant.g_epis_type_inpatient),
                                  pk_alert_constant.g_yes,
                                  pk_alert_constant.g_adm_req_status_done,
                                  decode(pk_surgery_request.get_epis_done_state(g_log_lang,
                                                                                wl.id_waiting_list,
                                                                                pk_alert_constant.g_epis_type_operating),
                                         pk_alert_constant.g_yes,
                                         pk_alert_constant.g_adm_req_status_done,
                                         wl.flg_status)) flg_status,
                           
                           ar.id_dest_prof,
                           ar.id_upd_prof,
                           pk_surgery_request.get_wl_status_date_dtz(g_log_lang,
                                                                     profissional(l_id_prof, il.id_institution, 0),
                                                                     ar.id_dest_episode,
                                                                     wl.id_waiting_list,
                                                                     pk_surgery_request.get_wl_status_flg(g_log_lang,
                                                                                                          profissional(l_id_prof,
                                                                                                                       il.id_institution,
                                                                                                                       0),
                                                                                                          wl.id_waiting_list,
                                                                                                          decode(wl.flg_type,
                                                                                                                 pk_alert_constant.g_wl_status_a,
                                                                                                                 pk_alert_constant.g_yes,
                                                                                                                 pk_alert_constant.g_no), --ssr.adm_needed,
                                                                                                          pos.id_sr_pos_status,
                                                                                                          pk_alert_constant.g_epis_type_inpatient,
                                                                                                          wl.flg_type)) dt_req,
                           ar.id_dest_inst,
                           epi_o.id_visit id_visit,
                           ar.dt_upd dt_last_update,
                           CASE
                                WHEN pos.id_schedule_sr IS NOT NULL THEN
                                 row_number() over(PARTITION BY pos.id_schedule_sr ORDER BY pos.dt_reg DESC)
                                ELSE
                                 1
                            END rn_pos
                      FROM adm_request ar
                      JOIN wtl_epis we
                        ON we.id_episode = ar.id_dest_episode
                      JOIN episode epi_o
                        ON epi_o.id_episode = ar.id_upd_episode
                       AND epi_o.flg_status <> pk_alert_constant.g_epis_status_cancel
                     INNER JOIN institution_language il
                        ON epi_o.id_institution = il.id_institution
                      JOIN waiting_list wl
                        ON (wl.id_waiting_list = we.id_waiting_list)
                      LEFT JOIN schedule_sr ssr
                        ON (ssr.id_waiting_list = wl.id_waiting_list)
                      LEFT JOIN sr_pos_schedule pos
                        ON (pos.id_schedule_sr = ssr.id_schedule_sr)
                     WHERE (epi_o.id_patient = i_patient OR i_patient IS NULL)
                       AND (epi_o.id_episode = i_episode OR i_episode IS NULL)
                       AND (epi_o.id_institution = i_institution OR i_institution IS NULL)
                       AND (ar.dt_upd >= i_start_dt OR i_start_dt IS NULL)
                       AND (ar.dt_upd <= i_end_dt OR i_end_dt IS NULL))
             WHERE flg_status NOT IN (pk_alert_constant.g_adm_req_status_done, 'C')
               AND rn_pos = 1;
    
        TYPE t_coll_admission IS TABLE OF c_admission%ROWTYPE;
        l_admission_rows t_coll_admission;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_inp_surg',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_inp_surg))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_admission;
        LOOP
            -- get notes data
            FETCH c_admission BULK COLLECT
                INTO l_admission_rows LIMIT l_limit;
        
            IF l_admission_rows IS NOT NULL
               AND l_admission_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := l_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_admission_rows.first .. l_admission_rows.last
                LOOP
                    l_ea_row.id_task_refid     := l_admission_rows(i).id_adm_request;
                    l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_inp_surg;
                    l_ea_row.id_patient        := l_admission_rows(i).id_patient;
                    l_ea_row.id_episode        := l_admission_rows(i).id_episode;
                    l_ea_row.id_visit          := l_admission_rows(i).id_visit;
                    l_ea_row.id_institution    := l_admission_rows(i).id_dest_inst;
                    l_ea_row.dt_req            := l_admission_rows(i).dt_req;
                    l_ea_row.id_prof_req       := l_admission_rows(i).id_upd_prof;
                    l_ea_row.flg_status_req    := l_admission_rows(i).flg_status;
                    l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_not_outdated;
                    l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                    l_ea_row.dt_last_execution := l_admission_rows(i).dt_last_update;
                    l_ea_row.dt_last_update    := l_admission_rows(i).dt_last_update;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_admission%NOTFOUND;
        END LOOP;
    
        CLOSE c_admission;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)))
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_inp_surg)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_inp_surg;

    /********************************************************************************************
    * Update surgery tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Vanessa Barsottelli
    * @version  2.6.5
    * @since    22/02/2016
    ********************************************************************************************/
    FUNCTION admin_task_tl_surgery
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_SURGERY';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'SCHEDULE_SR';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
        l_sysdate_tstz  TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_id_prof       professional.id_professional%TYPE := pk_sysconfig.get_config(i_code_cf   => 'ID_PROF_BACKGROUND',
                                                                                     i_prof_inst => i_institution,
                                                                                     i_prof_soft => 0);
    
        CURSOR c_surgery IS
            SELECT t.id_schedule_sr,
                   t.id_episode,
                   t.id_visit,
                   t.id_patient,
                   t.id_prof,
                   t.id_institution,
                   t.flg_status_surgery,
                   t.dt_req,
                   t.dt_begin,
                   t.dt_end,
                   t.id_waiting_list,
                   nvl(t.dt_req, l_sysdate_tstz) dt_last_update
              FROM (SELECT sr.id_schedule_sr,
                           sr.id_episode,
                           epi.id_visit,
                           sr.id_patient,
                           wl.id_waiting_list,
                           nvl(sr.adm_needed, pk_alert_constant.g_no) adm_needed,
                           sr.id_institution,
                           sr.id_prof_reg id_prof,
                           pk_surgery_request.get_wl_status_date_dtz(g_log_lang,
                                                                     profissional(l_id_prof, sr.id_institution, 0),
                                                                     sr.id_episode,
                                                                     wl.id_waiting_list,
                                                                     pk_surgery_request.get_wl_status_flg(g_log_lang,
                                                                                                          profissional(l_id_prof,
                                                                                                                       sr.id_institution,
                                                                                                                       0),
                                                                                                          wl.id_waiting_list,
                                                                                                          decode(wl.flg_type,
                                                                                                                 pk_alert_constant.g_wl_status_a,
                                                                                                                 pk_alert_constant.g_yes,
                                                                                                                 pk_alert_constant.g_no),
                                                                                                          pos.id_sr_pos_status,
                                                                                                          pk_alert_constant.g_epis_type_operating,
                                                                                                          wl.flg_type)) dt_req,
                           decode(sr.flg_sched,
                                  pk_alert_constant.g_schedule_sr_sched_a,
                                  sr.dt_target_tstz,
                                  decode(wl.id_waiting_list, NULL, sr.dt_target_tstz, nvl(wl.dt_surgery, wl.dt_dpb))) dt_begin,
                           decode(sr.flg_sched,
                                  pk_alert_constant.g_schedule_sr_sched_a,
                                  s.dt_end_tstz,
                                  decode(wl.id_waiting_list, NULL, NULL, wl.dt_dpa)) dt_end,
                           decode(sr.flg_status,
                                  pk_alert_constant.g_cancelled,
                                  pk_alert_constant.g_cancelled,
                                  decode(pk_surgery_request.get_epis_done_state(g_log_lang,
                                                                                wl.id_waiting_list,
                                                                                pk_alert_constant.g_epis_type_operating),
                                         pk_alert_constant.g_yes,
                                         pk_alert_constant.g_surgery_record_status_f,
                                         wl.flg_status)) flg_status_surgery,
                           
                           CASE
                                WHEN pos.id_schedule_sr IS NOT NULL THEN
                                 row_number() over(PARTITION BY pos.id_schedule_sr ORDER BY pos.dt_reg DESC)
                                ELSE
                                 1
                            END rn_pos,
                           (SELECT COUNT(1)
                              FROM sr_epis_interv sei
                             WHERE sei.id_episode_context = sr.id_episode
                               AND sei.flg_status NOT IN (pk_sr_planning.g_cancel)
                               AND rownum = 1) exists_sei
                      FROM schedule_sr sr
                      JOIN schedule s
                        ON s.id_schedule = sr.id_schedule
                      LEFT JOIN sr_pos_schedule pos
                        ON pos.id_schedule_sr = sr.id_schedule_sr
                      JOIN waiting_list wl
                        ON wl.id_waiting_list = sr.id_waiting_list
                      JOIN episode epi
                        ON epi.id_episode = sr.id_episode
                       AND epi.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE (epi.id_patient = i_patient OR i_patient IS NULL)
                       AND (epi.id_episode = i_episode OR i_episode IS NULL)
                       AND (epi.id_institution = i_institution OR i_institution IS NULL)) t
             WHERE t.flg_status_surgery NOT IN
                   (pk_alert_constant.g_surgery_record_status_f, pk_alert_constant.g_surgery_record_status_c)
               AND rn_pos = 1
               AND t.adm_needed = pk_alert_constant.g_no
               AND t.exists_sei > 0
               AND (t.dt_req >= i_start_dt OR i_start_dt IS NULL)
               AND (t.dt_req <= i_end_dt OR i_end_dt IS NULL);
    
        TYPE t_coll_surgery IS TABLE OF c_surgery%ROWTYPE;
        l_surgery_rows t_coll_surgery;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_surg',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_surg))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_surgery;
        LOOP
            -- get notes data
            FETCH c_surgery BULK COLLECT
                INTO l_surgery_rows LIMIT l_limit;
        
            IF l_surgery_rows IS NOT NULL
               AND l_surgery_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := l_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_patient;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_surgery_rows.first .. l_surgery_rows.last
                LOOP
                    l_ea_row.id_task_refid  := l_surgery_rows(i).id_schedule_sr;
                    l_ea_row.id_tl_task     := pk_prog_notes_constants.g_task_surg;
                    l_ea_row.id_patient     := l_surgery_rows(i).id_patient;
                    l_ea_row.id_episode     := l_surgery_rows(i).id_episode;
                    l_ea_row.id_visit       := l_surgery_rows(i).id_visit;
                    l_ea_row.id_institution := l_surgery_rows(i).id_institution;
                    l_ea_row.dt_req         := l_surgery_rows(i).dt_req;
                    l_ea_row.dt_begin       := l_surgery_rows(i).dt_begin;
                    l_ea_row.dt_end         := l_surgery_rows(i).dt_end;
                    l_ea_row.id_prof_req    := l_surgery_rows(i).id_prof;
                    l_ea_row.flg_status_req := l_surgery_rows(i).flg_status_surgery;
                    l_ea_row.flg_outdated   := pk_ea_logic_tasktimeline.g_flg_not_outdated;
                
                    IF l_surgery_rows(i).id_waiting_list IS NULL
                    THEN
                        l_ea_row.flg_ongoing := pk_prog_notes_constants.g_task_finalized_f;
                    ELSE
                        l_ea_row.flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
                    END IF;
                
                    l_ea_row.dt_last_execution := l_surgery_rows(i).dt_last_update;
                    l_ea_row.dt_last_update    := l_surgery_rows(i).dt_last_update;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_surgery%NOTFOUND;
        END LOOP;
    
        CLOSE c_surgery;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)))
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_surg)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_surgery;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with all tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.2
    * @since    2009/04/19
    ********************************************************************************************/
    FUNCTION admin_all_task_tl_tables
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
    
        l_count_invalid NUMBER := 0;
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        IF i_episode IS NULL
        THEN
            EXECUTE IMMEDIATE 'truncate table err$_task_timeline_ea';
        ELSE
            DELETE err$_task_timeline_ea;
        END IF;
    
        g_error := 'admin_task_tl_analysis_ea'; --Lab Orders
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        admin_task_tl_analysis_ea(i_episode);
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_analysis_res_ea'; --Results of Lab or from Lab Orders
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        admin_task_tl_analysis_res_ea(i_episode);
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_exams_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        admin_task_tl_exams_ea(i_episode);
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_exams_res_ea i_flg_split_task = N';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        admin_task_tl_exams_res_ea(i_episode, 'N');
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_exams_res_ea i_flg_split_task = Y';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        admin_task_tl_exams_res_ea(i_episode, 'Y');
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        SELECT COUNT(1)
          INTO l_count_invalid
          FROM err$_task_timeline_ea;
    
        IF l_count_invalid > 0
        THEN
            RAISE e_unspecified;
        END IF;
    
        g_error := 'admin_task_tl_proced_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_proced_ea(i_patient,
                                       i_episode,
                                       i_schedule,
                                       i_external_request,
                                       i_institution,
                                       i_start_dt,
                                       i_end_dt,
                                       i_validate_table,
                                       i_output_invalid_records,
                                       i_recreate_table,
                                       i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_monit_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_monit_ea(i_patient,
                                      i_episode,
                                      i_schedule,
                                      i_external_request,
                                      i_institution,
                                      i_start_dt,
                                      i_end_dt,
                                      i_validate_table,
                                      i_output_invalid_records,
                                      i_recreate_table,
                                      i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_mov_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_mov_ea(i_patient,
                                    i_episode,
                                    i_schedule,
                                    i_external_request,
                                    i_institution,
                                    i_start_dt,
                                    i_end_dt,
                                    i_validate_table,
                                    i_output_invalid_records,
                                    i_recreate_table,
                                    i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_dischar_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_dischar_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_surgery_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_surgery_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_inp_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_inp_ea(i_patient,
                                    i_episode,
                                    i_schedule,
                                    i_external_request,
                                    i_institution,
                                    i_start_dt,
                                    i_end_dt,
                                    i_validate_table,
                                    i_output_invalid_records,
                                    i_recreate_table,
                                    i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_medication_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_medication_ea(i_patient,
                                           i_episode,
                                           i_schedule,
                                           i_external_request,
                                           i_institution,
                                           i_start_dt,
                                           i_end_dt,
                                           i_validate_table,
                                           i_output_invalid_records,
                                           i_recreate_table,
                                           i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_med_recon_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_med_recon_ea(i_patient,
                                          i_episode,
                                          i_schedule,
                                          i_external_request,
                                          i_institution,
                                          i_start_dt,
                                          i_end_dt,
                                          i_validate_table,
                                          i_output_invalid_records,
                                          i_recreate_table,
                                          i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_past_hist_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_past_hist_ea(i_patient,
                                          i_episode,
                                          i_schedule,
                                          i_external_request,
                                          i_institution,
                                          i_start_dt,
                                          i_end_dt,
                                          i_validate_table,
                                          i_output_invalid_records,
                                          i_recreate_table,
                                          i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_ph_ftxt_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_ph_ftxt_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_complaints_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_complaints_ea(i_patient,
                                           i_episode,
                                           i_schedule,
                                           i_external_request,
                                           i_institution,
                                           i_start_dt,
                                           i_end_dt,
                                           i_validate_table,
                                           i_output_invalid_records,
                                           i_recreate_table,
                                           i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_plan_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_plan_ea(i_patient,
                                     i_episode,
                                     i_schedule,
                                     i_external_request,
                                     i_institution,
                                     i_start_dt,
                                     i_end_dt,
                                     i_validate_table,
                                     i_output_invalid_records,
                                     i_recreate_table,
                                     i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_epis_reason_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_epis_reason_ea(i_patient,
                                            i_episode,
                                            i_schedule,
                                            i_external_request,
                                            i_institution,
                                            i_start_dt,
                                            i_end_dt,
                                            i_validate_table,
                                            i_output_invalid_records,
                                            i_recreate_table,
                                            i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_er_law_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_er_law_ea(i_patient,
                                       i_episode,
                                       i_schedule,
                                       i_external_request,
                                       i_institution,
                                       i_start_dt,
                                       i_end_dt,
                                       i_validate_table,
                                       i_output_invalid_records,
                                       i_recreate_table,
                                       i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_body_diagram_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_body_diagram_ea(i_patient,
                                             i_episode,
                                             i_schedule,
                                             i_external_request,
                                             i_institution,
                                             i_start_dt,
                                             i_end_dt,
                                             i_validate_table,
                                             i_output_invalid_records,
                                             i_recreate_table,
                                             i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_diag_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_diag_ea(i_patient,
                                     i_episode,
                                     i_schedule,
                                     i_external_request,
                                     i_institution,
                                     i_start_dt,
                                     i_end_dt,
                                     i_validate_table,
                                     i_output_invalid_records,
                                     i_recreate_table,
                                     i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_diag_notes_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_diag_notes_ea(i_patient,
                                           i_episode,
                                           i_schedule,
                                           i_external_request,
                                           i_institution,
                                           i_start_dt,
                                           i_end_dt,
                                           i_validate_table,
                                           i_output_invalid_records,
                                           i_recreate_table,
                                           i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_habits';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_habits(i_patient,
                                    i_episode,
                                    i_schedule,
                                    i_external_request,
                                    i_institution,
                                    i_start_dt,
                                    i_end_dt,
                                    i_validate_table,
                                    i_output_invalid_records,
                                    i_recreate_table,
                                    i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_doc_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_doc_ea(i_patient,
                                    i_episode,
                                    i_schedule,
                                    i_external_request,
                                    i_institution,
                                    i_start_dt,
                                    i_end_dt,
                                    i_validate_table,
                                    i_output_invalid_records,
                                    i_recreate_table,
                                    i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_diet_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_diet_ea(i_patient                => i_patient,
                                     i_episode                => i_episode,
                                     i_schedule               => i_schedule,
                                     i_external_request       => i_external_request,
                                     i_institution            => i_institution,
                                     i_start_dt               => i_start_dt,
                                     i_end_dt                 => i_end_dt,
                                     i_validate_table         => i_validate_table,
                                     i_output_invalid_records => i_output_invalid_records,
                                     i_recreate_table         => i_recreate_table,
                                     i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_posit_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_posit_ea(i_patient                => i_patient,
                                      i_episode                => i_episode,
                                      i_schedule               => i_schedule,
                                      i_external_request       => i_external_request,
                                      i_institution            => i_institution,
                                      i_start_dt               => i_start_dt,
                                      i_end_dt                 => i_end_dt,
                                      i_validate_table         => i_validate_table,
                                      i_output_invalid_records => i_output_invalid_records,
                                      i_recreate_table         => i_recreate_table,
                                      i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_mtos_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_mtos_ea(i_patient                => i_patient,
                                     i_episode                => i_episode,
                                     i_schedule               => i_schedule,
                                     i_external_request       => i_external_request,
                                     i_institution            => i_institution,
                                     i_start_dt               => i_start_dt,
                                     i_end_dt                 => i_end_dt,
                                     i_validate_table         => i_validate_table,
                                     i_output_invalid_records => i_output_invalid_records,
                                     i_recreate_table         => i_recreate_table,
                                     i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_problems_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_problems_ea(i_patient                => i_patient,
                                         i_episode                => i_episode,
                                         i_schedule               => i_schedule,
                                         i_external_request       => i_external_request,
                                         i_institution            => i_institution,
                                         i_start_dt               => i_start_dt,
                                         i_end_dt                 => i_end_dt,
                                         i_validate_table         => i_validate_table,
                                         i_output_invalid_records => i_output_invalid_records,
                                         i_recreate_table         => i_recreate_table,
                                         i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        -- allergy
        g_error := 'admin_task_tl_allergy_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_allergy_ea(i_patient                => i_patient,
                                        i_episode                => i_episode,
                                        i_schedule               => i_schedule,
                                        i_external_request       => i_external_request,
                                        i_institution            => i_institution,
                                        i_start_dt               => i_start_dt,
                                        i_end_dt                 => i_end_dt,
                                        i_validate_table         => i_validate_table,
                                        i_output_invalid_records => i_output_invalid_records,
                                        i_recreate_table         => i_recreate_table,
                                        i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        -- allergy unaware
        g_error := 'admin_task_tl_al_unaware_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_al_unaware_ea(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        -- prob unaware
        g_error := 'admin_task_tl_prob_unaware_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_prob_unaware_ea(i_patient                => i_patient,
                                             i_episode                => i_episode,
                                             i_schedule               => i_schedule,
                                             i_external_request       => i_external_request,
                                             i_institution            => i_institution,
                                             i_start_dt               => i_start_dt,
                                             i_end_dt                 => i_end_dt,
                                             i_validate_table         => i_validate_table,
                                             i_output_invalid_records => i_output_invalid_records,
                                             i_recreate_table         => i_recreate_table,
                                             i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_prob_diag_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_prob_diag_ea(i_patient                => i_patient,
                                          i_episode                => i_episode,
                                          i_schedule               => i_schedule,
                                          i_external_request       => i_external_request,
                                          i_institution            => i_institution,
                                          i_start_dt               => i_start_dt,
                                          i_end_dt                 => i_end_dt,
                                          i_validate_table         => i_validate_table,
                                          i_output_invalid_records => i_output_invalid_records,
                                          i_recreate_table         => i_recreate_table,
                                          i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_fe_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_fe_ea(i_patient                => i_patient,
                                   i_episode                => i_episode,
                                   i_schedule               => i_schedule,
                                   i_external_request       => i_external_request,
                                   i_institution            => i_institution,
                                   i_start_dt               => i_start_dt,
                                   i_end_dt                 => i_end_dt,
                                   i_validate_table         => i_validate_table,
                                   i_output_invalid_records => i_output_invalid_records,
                                   i_recreate_table         => i_recreate_table,
                                   i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_proc_notes_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_proc_notes_ea(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_presc_notes';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_presc_notes(i_patient                => i_patient,
                                         i_episode                => i_episode,
                                         i_schedule               => i_schedule,
                                         i_external_request       => i_external_request,
                                         i_institution            => i_institution,
                                         i_start_dt               => i_start_dt,
                                         i_end_dt                 => i_end_dt,
                                         i_validate_table         => i_validate_table,
                                         i_output_invalid_records => i_output_invalid_records,
                                         i_recreate_table         => i_recreate_table,
                                         i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_hidrics';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_hidrics(i_patient                => i_patient,
                                     i_episode                => i_episode,
                                     i_schedule               => i_schedule,
                                     i_external_request       => i_external_request,
                                     i_institution            => i_institution,
                                     i_start_dt               => i_start_dt,
                                     i_end_dt                 => i_end_dt,
                                     i_validate_table         => i_validate_table,
                                     i_output_invalid_records => i_output_invalid_records,
                                     i_recreate_table         => i_recreate_table,
                                     i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_iah_special_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_iah_special_ea(i_patient,
                                            i_episode,
                                            i_schedule,
                                            i_external_request,
                                            i_institution,
                                            i_start_dt,
                                            i_end_dt,
                                            i_validate_table,
                                            i_output_invalid_records,
                                            i_recreate_table,
                                            i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_consults';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_consults(i_patient                => i_patient,
                                      i_episode                => i_episode,
                                      i_schedule               => i_schedule,
                                      i_external_request       => i_external_request,
                                      i_institution            => i_institution,
                                      i_start_dt               => i_start_dt,
                                      i_end_dt                 => i_end_dt,
                                      i_validate_table         => i_validate_table,
                                      i_output_invalid_records => i_output_invalid_records,
                                      i_recreate_table         => i_recreate_table,
                                      i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_disch_instruc';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_disch_instruc(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_inp_surg';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_inp_surg(i_patient                => i_patient,
                                      i_episode                => i_episode,
                                      i_schedule               => i_schedule,
                                      i_external_request       => i_external_request,
                                      i_institution            => i_institution,
                                      i_start_dt               => i_start_dt,
                                      i_end_dt                 => i_end_dt,
                                      i_validate_table         => i_validate_table,
                                      i_output_invalid_records => i_output_invalid_records,
                                      i_recreate_table         => i_recreate_table,
                                      i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_surgery';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_surgery(i_patient                => i_patient,
                                     i_episode                => i_episode,
                                     i_schedule               => i_schedule,
                                     i_external_request       => i_external_request,
                                     i_institution            => i_institution,
                                     i_start_dt               => i_start_dt,
                                     i_end_dt                 => i_end_dt,
                                     i_validate_table         => i_validate_table,
                                     i_output_invalid_records => i_output_invalid_records,
                                     i_recreate_table         => i_recreate_table,
                                     i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_surgery';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_surgery(i_patient                => i_patient,
                                     i_episode                => i_episode,
                                     i_schedule               => i_schedule,
                                     i_external_request       => i_external_request,
                                     i_institution            => i_institution,
                                     i_start_dt               => i_start_dt,
                                     i_end_dt                 => i_end_dt,
                                     i_validate_table         => i_validate_table,
                                     i_output_invalid_records => i_output_invalid_records,
                                     i_recreate_table         => i_recreate_table,
                                     i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_nurse_tea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_nurse_tea(i_patient                => i_patient,
                                       i_episode                => i_episode,
                                       i_schedule               => i_schedule,
                                       i_external_request       => i_external_request,
                                       i_institution            => i_institution,
                                       i_start_dt               => i_start_dt,
                                       i_end_dt                 => i_end_dt,
                                       i_validate_table         => i_validate_table,
                                       i_output_invalid_records => i_output_invalid_records,
                                       i_recreate_table         => i_recreate_table,
                                       i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_triage';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_triage(i_patient                => i_patient,
                                    i_episode                => i_episode,
                                    i_schedule               => i_schedule,
                                    i_external_request       => i_external_request,
                                    i_institution            => i_institution,
                                    i_start_dt               => i_start_dt,
                                    i_end_dt                 => i_end_dt,
                                    i_validate_table         => i_validate_table,
                                    i_output_invalid_records => i_output_invalid_records,
                                    i_recreate_table         => i_recreate_table,
                                    i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_cit';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_cit(i_patient                => i_patient,
                                 i_episode                => i_episode,
                                 i_schedule               => i_schedule,
                                 i_external_request       => i_external_request,
                                 i_institution            => i_institution,
                                 i_start_dt               => i_start_dt,
                                 i_end_dt                 => i_end_dt,
                                 i_validate_table         => i_validate_table,
                                 i_output_invalid_records => i_output_invalid_records,
                                 i_recreate_table         => i_recreate_table,
                                 i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_interv_p_plan';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_interv_p_plan(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'admin_task_tl_comm_orders';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_comm_orders(i_patient                => i_patient,
                                         i_episode                => i_episode,
                                         i_schedule               => i_schedule,
                                         i_external_request       => i_external_request,
                                         i_institution            => i_institution,
                                         i_start_dt               => i_start_dt,
                                         i_end_dt                 => i_end_dt,
                                         i_validate_table         => i_validate_table,
                                         i_output_invalid_records => i_output_invalid_records,
                                         i_recreate_table         => i_recreate_table,
                                         i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        --referrals
        g_error := 'admin_task_tl_ref_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_ref_ea(i_patient                => i_patient,
                                    i_episode                => i_episode,
                                    i_schedule               => i_schedule,
                                    i_external_request       => i_external_request,
                                    i_institution            => i_institution,
                                    i_start_dt               => i_start_dt,
                                    i_end_dt                 => i_end_dt,
                                    i_validate_table         => i_validate_table,
                                    i_output_invalid_records => i_output_invalid_records,
                                    i_recreate_table         => i_recreate_table,
                                    i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        --episode problem list
        g_error := 'admin_task_tl_prob_epis_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_task_tl_prob_epis_ea(i_patient                => i_patient,
                                          i_episode                => i_episode,
                                          i_schedule               => i_schedule,
                                          i_external_request       => i_external_request,
                                          i_institution            => i_institution,
                                          i_start_dt               => i_start_dt,
                                          i_end_dt                 => i_end_dt,
                                          i_validate_table         => i_validate_table,
                                          i_output_invalid_records => i_output_invalid_records,
                                          i_recreate_table         => i_recreate_table,
                                          i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        --episode problem group
        g_error := 'admin_task_tl_prob_epis_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_prob_group_ea(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        --supply
        g_error := 'admin_task_tl_supply_ea';
        pk_alertlog.log_debug(text            => g_error,
                              object_name     => g_package_name,
                              sub_object_name => 'admin_all_task_tl_tables',
                              owner           => g_package_owner);
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_supply_ea(i_patient                => i_patient,
                                       i_episode                => i_episode,
                                       i_schedule               => i_schedule,
                                       i_external_request       => i_external_request,
                                       i_institution            => i_institution,
                                       i_start_dt               => i_start_dt,
                                       i_end_dt                 => i_end_dt,
                                       i_validate_table         => i_validate_table,
                                       i_output_invalid_records => i_output_invalid_records,
                                       i_recreate_table         => i_recreate_table,
                                       i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --NURSE DIAGNOSIS
        g_error := 'admin_task_tl_supply_ea';
        pk_alertlog.log_debug(text            => g_error,
                              object_name     => g_package_name,
                              sub_object_name => 'admin_all_task_tl_tables',
                              owner           => g_package_owner);
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_task_tl_supply_ea(i_patient                => i_patient,
                                       i_episode                => i_episode,
                                       i_schedule               => i_schedule,
                                       i_external_request       => i_external_request,
                                       i_institution            => i_institution,
                                       i_start_dt               => i_start_dt,
                                       i_end_dt                 => i_end_dt,
                                       i_validate_table         => i_validate_table,
                                       i_output_invalid_records => i_output_invalid_records,
                                       i_recreate_table         => i_recreate_table,
                                       i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF NOT admin_task_tl_nurse_diag_ea(i_patient                => i_patient,
                                           i_episode                => i_episode,
                                           i_schedule               => i_schedule,
                                           i_external_request       => i_external_request,
                                           i_institution            => i_institution,
                                           i_start_dt               => i_start_dt,
                                           i_end_dt                 => i_end_dt,
                                           i_validate_table         => i_validate_table,
                                           i_output_invalid_records => i_output_invalid_records,
                                           i_recreate_table         => i_recreate_table,
                                           i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF NOT admin_task_tl_nurse_interv_ea(i_patient                => i_patient,
                                             i_episode                => i_episode,
                                             i_schedule               => i_schedule,
                                             i_external_request       => i_external_request,
                                             i_institution            => i_institution,
                                             i_start_dt               => i_start_dt,
                                             i_end_dt                 => i_end_dt,
                                             i_validate_table         => i_validate_table,
                                             i_output_invalid_records => i_output_invalid_records,
                                             i_recreate_table         => i_recreate_table,
                                             i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
        g_error := 'admin_task_tl_rehab_presc';
        IF NOT admin_task_tl_rehab_presc(i_patient                => i_patient,
                                         i_episode                => i_episode,
                                         i_schedule               => i_schedule,
                                         i_external_request       => i_external_request,
                                         i_institution            => i_institution,
                                         i_start_dt               => i_start_dt,
                                         i_end_dt                 => i_end_dt,
                                         i_validate_table         => i_validate_table,
                                         i_output_invalid_records => i_output_invalid_records,
                                         i_recreate_table         => i_recreate_table,
                                         i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
        g_error := 'admin_task_tl_rehab_diag';
        IF NOT admin_task_tl_rehab_diag(i_patient                => i_patient,
                                        i_episode                => i_episode,
                                        i_schedule               => i_schedule,
                                        i_external_request       => i_external_request,
                                        i_institution            => i_institution,
                                        i_start_dt               => i_start_dt,
                                        i_end_dt                 => i_end_dt,
                                        i_validate_table         => i_validate_table,
                                        i_output_invalid_records => i_output_invalid_records,
                                        i_recreate_table         => i_recreate_table,
                                        i_commit_step            => i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        IF i_episode IS NULL
        THEN
            COMMIT;
        END IF;
    
        g_error := 'Leaving function admin_all_task_tl_tables';
        pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_TASK_TL_TABLES');
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN e_unspecified THEN
            raise_application_error(-20001,
                                    'Unspecified errors. Check table err$_task_timeline_ea. ADMIN_ALL_TASK_TL_TABLES -> ' ||
                                    g_error);
        WHEN OTHERS THEN
            dbms_output.put_line('ADMIN_ALL_TASK_TL_TABLES -> ' || g_error || ' - ' || SQLERRM);
            pk_alert_exceptions.process_error(1,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_DATA_GOV_ADMIN',
                                              'ADMIN_ALL_TASK_TL_TABLES',
                                              l_error);
            RETURN FALSE;
    END admin_all_task_tl_tables;

    PROCEDURE admin_71_all_task_tl_tables IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        l_raise EXCEPTION;
    
    BEGIN
    
        g_error := 'admin_all_task_tl_tables';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
    
        IF NOT admin_all_task_tl_tables(i_patient                => i_patient,
                                        i_episode                => i_episode,
                                        i_schedule               => i_schedule,
                                        i_external_request       => i_external_request,
                                        i_institution            => i_institution,
                                        i_start_dt               => i_start_dt,
                                        i_end_dt                 => i_end_dt,
                                        i_validate_table         => i_validate_table,
                                        i_output_invalid_records => i_output_invalid_records,
                                        i_recreate_table         => i_recreate_table,
                                        i_commit_step            => i_commit_step)
        THEN
            RAISE l_raise;
        END IF;
    
        g_error := 'Leaving function admin_71_all_task_tl_tables';
        pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_71_ALL_TASK_TL_TABLES');
    
        COMMIT;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alertlog.log_error(SQLERRM, g_package_name, 'ADMIN_71_ALL_TASK_TL_TABLES');
            raise_application_error(-20001,
                                    'Error updating admin_71_all_task_tl_tables. Please see alertlog.tlog for more details');
    END admin_71_all_task_tl_tables;

    /********************************************************************************************
    * ADMIN_BMNG_BED_EA               Actualize Easy Access table BMNG_BED_EA
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.5
    * @since    2009/07/28
    ********************************************************************************************/
    FUNCTION admin_bmng_bed_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_dt_end            bmng_bed_ea.dt_end%TYPE;
        --
        l_error t_error_out;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            -- DELETE BMNG_BED_EA
            DELETE FROM bmng_bed_ea
             WHERE (id_patient = i_patient OR i_patient IS NULL)
               AND (id_episode = i_episode OR i_episode IS NULL)
               AND (i_institution IS NULL OR
                   (id_department IN (SELECT dep.id_department
                                         FROM department dep
                                        WHERE dep.id_institution = i_institution)))
               AND (dt_begin >= i_start_dt OR i_start_dt IS NULL)
               AND (dt_begin <= i_end_dt OR i_end_dt IS NULL);
        
            --     COMMIT;
        
        END IF;
    
        FOR rec IN (SELECT ba.id_bmng_action,
                           bed.id_bed,
                           ba.dt_begin_action dt_begin,
                           ba.dt_end_action dt_end,
                           ba.id_bmng_reason_type,
                           ba.id_bmng_reason,
                           bab.id_episode,
                           bab.id_patient,
                           roo.id_room,
                           dep.id_admission_type,
                           roo.id_room_type,
                           bab.id_bmng_allocation_bed,
                           bed.id_bed_type,
                           dep.id_department,
                           ds.dt_discharge_schedule,
                           nvl(en.flg_type,
                               decode(nl.id_nch_level, NULL, NULL, pk_bmng_constant.g_bmng_bed_ea_flg_nch_u)) flg_type,
                           ai.id_nch_level,
                           CASE
                                WHEN bab.id_bmng_allocation_bed IS NULL
                                     AND
                                     ba.flg_bed_status IN
                                     (pk_bmng_constant.g_bmng_act_flg_bed_sta_n, pk_bmng_constant.g_bmng_act_flg_bed_sta_r) THEN
                                 pk_bmng_constant.g_bmng_act_flg_ocupaci_v
                                ELSE
                                 nvl(ba.flg_bed_ocupacity_status, bed.flg_status)
                            END flg_bed_ocupacity_status,
                           CASE
                                WHEN bab.id_bmng_allocation_bed IS NULL
                                     AND
                                     ba.flg_bed_status IN
                                     (pk_bmng_constant.g_bmng_act_flg_bed_sta_n, pk_bmng_constant.g_bmng_act_flg_bed_sta_r) THEN
                                 pk_bmng_constant.g_bmng_act_flg_bed_sta_n
                                ELSE
                                 ba.flg_bed_status
                            END flg_bed_status,
                           ba.flg_bed_cleaning_status,
                           bed.flg_type flg_bed_type,
                           decode(ba.action_notes, NULL, get_no(), get_yes()) has_notes,
                           ba.flg_action
                      FROM bmng_action ba
                      LEFT JOIN bmng_allocation_bed bab
                        ON (bab.id_bmng_allocation_bed = ba.id_bmng_allocation_bed AND bab.flg_outdated = get_no())
                      LEFT JOIN epis_nch en
                        ON (en.id_epis_nch = bab.id_epis_nch AND en.flg_status = pk_alert_constant.g_active)
                      LEFT JOIN bed bed
                        ON (ba.id_bed = bed.id_bed AND bed.flg_available = get_yes())
                      LEFT JOIN room roo
                        ON (roo.id_room = bed.id_room AND roo.flg_available = get_yes())
                     INNER JOIN department dep
                        ON (dep.id_department = ba.id_department AND dep.flg_available = get_yes())
                      LEFT JOIN discharge_schedule ds
                        ON (ds.id_episode = bab.id_episode AND ds.flg_status = get_yes())
                      LEFT JOIN adm_request ar
                        ON (ar.id_dest_episode = bab.id_episode)
                      LEFT JOIN adm_indication ai
                        ON (ai.id_adm_indication = ar.id_adm_indication)
                      LEFT JOIN nch_level nl
                        ON nl.id_previous = ai.id_nch_level
                     WHERE ba.flg_status = pk_alert_constant.g_active
                       AND instr(dep.flg_type, 'I') > 0)
        LOOP
            --
            IF rec.flg_action = pk_bmng_constant.g_bmng_flg_origin_ux_b
               OR rec.flg_action = pk_bmng_constant.g_bmng_flg_origin_ux_u
               OR rec.flg_action = pk_bmng_constant.g_bmng_flg_origin_ux_bt
               OR rec.flg_action = pk_bmng_constant.g_bmng_flg_origin_ux_ut
            THEN
                l_dt_end := rec.dt_end;
            ELSE
                l_dt_end := NULL;
            END IF;
        
            --
            IF i_validate_table
            THEN
                --insert in temporary table
                INSERT INTO bmng_bed_ea_tmp
                    (id_bmng_action,
                     id_bed,
                     dt_begin,
                     dt_end,
                     id_bmng_reason_type,
                     id_bmng_reason,
                     id_episode,
                     id_patient,
                     id_room,
                     id_admission_type,
                     id_room_type,
                     id_bmng_allocation_bed,
                     id_bed_type,
                     dt_discharge_schedule,
                     flg_allocation_nch,
                     id_nch_level,
                     flg_bed_ocupacity_status,
                     flg_bed_status,
                     flg_bed_cleaning_status,
                     has_notes,
                     flg_bed_type,
                     id_department,
                     dt_dg_last_update)
                VALUES
                    (rec.id_bmng_action,
                     rec.id_bed,
                     rec.dt_begin,
                     l_dt_end,
                     rec.id_bmng_reason_type,
                     rec.id_bmng_reason,
                     rec.id_episode,
                     rec.id_patient,
                     rec.id_room,
                     rec.id_admission_type,
                     rec.id_room_type,
                     rec.id_bmng_allocation_bed,
                     rec.id_bed_type,
                     rec.dt_discharge_schedule,
                     rec.flg_type,
                     rec.id_nch_level,
                     rec.flg_bed_ocupacity_status,
                     rec.flg_bed_status,
                     rec.flg_bed_cleaning_status,
                     rec.has_notes,
                     rec.flg_bed_type,
                     rec.id_department,
                     current_timestamp);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                g_error := 'INSERT INTO bmng_bed_ea id_bmng_action:' || rec.id_bmng_action || ' ID_BED:' || rec.id_bed;
                -- Insert into Easy Access table
                INSERT INTO bmng_bed_ea
                    (id_bmng_action,
                     id_bed,
                     dt_begin,
                     dt_end,
                     id_bmng_reason_type,
                     id_bmng_reason,
                     id_episode,
                     id_patient,
                     id_room,
                     id_admission_type,
                     id_room_type,
                     id_bmng_allocation_bed,
                     id_bed_type,
                     dt_discharge_schedule,
                     flg_allocation_nch,
                     id_nch_level,
                     flg_bed_ocupacity_status,
                     flg_bed_status,
                     flg_bed_cleaning_status,
                     has_notes,
                     flg_bed_type,
                     id_department,
                     dt_dg_last_update)
                VALUES
                    (rec.id_bmng_action,
                     rec.id_bed,
                     rec.dt_begin,
                     l_dt_end,
                     rec.id_bmng_reason_type,
                     rec.id_bmng_reason,
                     rec.id_episode,
                     rec.id_patient,
                     rec.id_room,
                     rec.id_admission_type,
                     rec.id_room_type,
                     rec.id_bmng_allocation_bed,
                     rec.id_bed_type,
                     rec.dt_discharge_schedule,
                     rec.flg_type,
                     rec.id_nch_level,
                     rec.flg_bed_ocupacity_status,
                     rec.flg_bed_status,
                     rec.flg_bed_cleaning_status,
                     rec.has_notes,
                     rec.flg_bed_type,
                     rec.id_department,
                     current_timestamp);
            
            END IF;
        
            IF MOD(l_count, i_commit_step) = 0
            THEN
                COMMIT;
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_bmng_action id_bmng_action_tmp
                           FROM bmng_bed_ea a
                           JOIN bmng_bed_ea_tmp b
                             ON a.id_bmng_action = b.id_bmng_action
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.id_bed <> b.id_bed OR (a.id_bed IS NULL AND b.id_bed IS NOT NULL) OR
                                (a.id_bed IS NOT NULL AND b.id_bed IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.id_bmng_reason_type <> b.id_bmng_reason_type OR
                                (a.id_bmng_reason_type IS NULL AND b.id_bmng_reason_type IS NOT NULL) OR
                                (a.id_bmng_reason_type IS NOT NULL AND b.id_bmng_reason_type IS NULL)) OR
                                --
                                (a.id_bmng_reason <> b.id_bmng_reason OR
                                (a.id_bmng_reason IS NULL AND b.id_bmng_reason IS NOT NULL) OR
                                (a.id_bmng_reason IS NOT NULL AND b.id_bmng_reason IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_room <> b.id_room OR (a.id_room IS NULL AND b.id_room IS NOT NULL) OR
                                (a.id_room IS NOT NULL AND b.id_room IS NULL)) OR
                                --
                                (a.id_admission_type <> b.id_admission_type OR
                                (a.id_admission_type IS NULL AND b.id_admission_type IS NOT NULL) OR
                                (a.id_admission_type IS NOT NULL AND b.id_admission_type IS NULL)) OR
                                --
                                (a.id_room_type <> b.id_room_type OR
                                (a.id_room_type IS NULL AND b.id_room_type IS NOT NULL) OR
                                (a.id_room_type IS NOT NULL AND b.id_room_type IS NULL)) OR
                                --
                                (a.id_bmng_allocation_bed <> b.id_bmng_allocation_bed OR
                                (a.id_bmng_allocation_bed IS NULL AND b.id_bmng_allocation_bed IS NOT NULL) OR
                                (a.id_bmng_allocation_bed IS NOT NULL AND b.id_bmng_allocation_bed IS NULL)) OR
                                --
                                (a.id_bed_type <> b.id_bed_type OR
                                (a.id_bed_type IS NULL AND b.id_bed_type IS NOT NULL) OR
                                (a.id_bed_type IS NOT NULL AND b.id_bed_type IS NULL)) OR
                                --
                                (a.dt_discharge_schedule <> b.dt_discharge_schedule OR
                                (a.dt_discharge_schedule IS NULL AND b.dt_discharge_schedule IS NOT NULL) OR
                                (a.dt_discharge_schedule IS NOT NULL AND b.dt_discharge_schedule IS NULL)) OR
                                --
                                (a.flg_allocation_nch <> b.flg_allocation_nch OR
                                (a.flg_allocation_nch IS NULL AND b.flg_allocation_nch IS NOT NULL) OR
                                (a.flg_allocation_nch IS NOT NULL AND b.flg_allocation_nch IS NULL)) OR
                                --
                                (a.id_nch_level <> b.id_nch_level OR
                                (a.id_nch_level IS NULL AND b.id_nch_level IS NOT NULL) OR
                                (a.id_nch_level IS NOT NULL AND b.id_nch_level IS NULL)) OR
                                --
                                (a.flg_bed_ocupacity_status <> b.flg_bed_ocupacity_status OR
                                (a.flg_bed_ocupacity_status IS NULL AND b.flg_bed_ocupacity_status IS NOT NULL) OR
                                (a.flg_bed_ocupacity_status IS NOT NULL AND b.flg_bed_ocupacity_status IS NULL)) OR
                                --
                                (a.flg_bed_status <> b.flg_bed_status OR
                                (a.flg_bed_status IS NULL AND b.flg_bed_status IS NOT NULL) OR
                                (a.flg_bed_status IS NOT NULL AND b.flg_bed_status IS NULL)) OR
                                --
                                (a.flg_bed_type <> b.flg_bed_type OR
                                (a.flg_bed_type IS NULL AND b.flg_bed_type IS NOT NULL) OR
                                (a.flg_bed_type IS NOT NULL AND b.flg_bed_type IS NULL)) OR
                                --
                                (a.flg_bed_cleaning_status <> b.flg_bed_cleaning_status OR
                                (a.flg_bed_cleaning_status IS NULL AND b.flg_bed_cleaning_status IS NOT NULL) OR
                                (a.flg_bed_cleaning_status IS NOT NULL AND b.flg_bed_cleaning_status IS NULL)) OR
                                --
                                (a.has_notes <> b.has_notes OR (a.has_notes IS NULL AND b.has_notes IS NOT NULL) OR
                                (a.has_notes IS NOT NULL AND b.has_notes IS NULL)) OR
                                --
                                (a.id_department <> b.id_department OR
                                (a.id_department IS NULL AND b.id_department IS NOT NULL) OR
                                (a.id_department IS NOT NULL AND b.id_department IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_bmng_table_name,
                                          i_id_pk_1_value       => rec1.id_bmng_action_tmp,
                                          i_id_pk_1_col_name    => g_bmng_column_pk1,
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --          COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT bb_ea_t.id_bmng_action id_bmng_action_tmp
                           FROM bmng_bed_ea_tmp bb_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM bmng_bed_ea bb_ea
                                  WHERE bb_ea.id_bmng_action = bb_ea_t.id_bmng_action))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_bmng_table_name,
                                          i_id_pk_1_value       => rec2.id_bmng_action_tmp,
                                          i_id_pk_1_col_name    => g_bmng_column_pk1,
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO bmng_bed_ea bb_ea
            USING (SELECT *
                     FROM bmng_bed_ea_tmp bb_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = bb_ea_tmp.id_bmng_action
                              AND dgir.ea_table_name = g_bmng_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (bb_ea.id_bmng_action = t.id_bmng_action)
            WHEN MATCHED THEN
                UPDATE
                   SET bb_ea.id_bed                   = t.id_bed,
                       bb_ea.dt_begin                 = t.dt_begin,
                       bb_ea.dt_end                   = t.dt_end,
                       bb_ea.id_bmng_reason_type      = t.id_bmng_reason_type,
                       bb_ea.id_bmng_reason           = t.id_bmng_reason,
                       bb_ea.id_episode               = t.id_episode,
                       bb_ea.id_patient               = t.id_patient,
                       bb_ea.id_room                  = t.id_room,
                       bb_ea.id_admission_type        = t.id_admission_type,
                       bb_ea.id_room_type             = t.id_room_type,
                       bb_ea.id_bmng_allocation_bed   = t.id_bmng_allocation_bed,
                       bb_ea.id_bed_type              = t.id_bed_type,
                       bb_ea.dt_discharge_schedule    = t.dt_discharge_schedule,
                       bb_ea.flg_allocation_nch       = t.flg_allocation_nch,
                       bb_ea.id_nch_level             = t.id_nch_level,
                       bb_ea.flg_bed_ocupacity_status = t.flg_bed_ocupacity_status,
                       bb_ea.flg_bed_status           = t.flg_bed_status,
                       bb_ea.flg_bed_cleaning_status  = t.flg_bed_cleaning_status,
                       bb_ea.has_notes                = t.has_notes,
                       bb_ea.flg_bed_type             = t.flg_bed_type,
                       bb_ea.id_department            = t.id_department,
                       bb_ea.dt_dg_last_update        = l_current_timestamp
                 WHERE bb_ea.id_bmng_action = t.id_bmng_action
            WHEN NOT MATCHED THEN
                INSERT
                    (id_bmng_action,
                     id_bed,
                     dt_begin,
                     dt_end,
                     id_bmng_reason_type,
                     id_bmng_reason,
                     id_episode,
                     id_patient,
                     id_room,
                     id_admission_type,
                     id_room_type,
                     id_bmng_allocation_bed,
                     id_bed_type,
                     dt_discharge_schedule,
                     flg_allocation_nch,
                     id_nch_level,
                     flg_bed_ocupacity_status,
                     flg_bed_status,
                     flg_bed_cleaning_status,
                     has_notes,
                     flg_bed_type,
                     id_department,
                     dt_dg_last_update)
                VALUES
                    (t.id_bmng_action,
                     t.id_bed,
                     t.dt_begin,
                     t.dt_end,
                     t.id_bmng_reason_type,
                     t.id_bmng_reason,
                     t.id_episode,
                     t.id_patient,
                     t.id_room,
                     t.id_admission_type,
                     t.id_room_type,
                     t.id_bmng_allocation_bed,
                     t.id_bed_type,
                     t.dt_discharge_schedule,
                     t.flg_allocation_nch,
                     t.id_nch_level,
                     t.flg_bed_ocupacity_status,
                     t.flg_bed_status,
                     t.flg_bed_cleaning_status,
                     t.has_notes,
                     t.flg_bed_type,
                     t.id_department,
                     l_current_timestamp);
        
            COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM bmng_bed_ea_tmp;
        --      COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_bmng_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        --        COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_bmng_bed_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_bmng_bed_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
        
            --delete records from temporary table
            DELETE FROM bmng_bed_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_BED_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
        
            --delete records from temporary table
            DELETE FROM bmng_bed_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_BED_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            ROLLBACK;
        
            --delete records from temporary table
            DELETE FROM bmng_bed_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_BED_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_bmng_bed_ea;

    /********************************************************************************************
    * ADMIN_BMNG_DEPARTMENT_EA        Actualize Easy Access table BMNG_DEPARTMENT_EA
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Pedro Teixeira
    * @version  2.5.0.5
    * @since    2009/07/30
    ********************************************************************************************/
    FUNCTION admin_bmng_department_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        --
        l_error           t_error_out;
        l_prof            profissional := get_prof;
        l_count_temp_beds sys_config.value%TYPE := nvl(pk_sysconfig.get_config(i_code_cf => 'BMNG_COUNT_TEMP_BEDS',
                                                                               i_prof    => profissional(NULL,
                                                                                                         i_institution,
                                                                                                         11)),
                                                       get_yes());
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            -- DELETE BMNG_BED_EA
            DELETE FROM bmng_department_ea;
        
            --     COMMIT;
        
        END IF;
    
        FOR rec IN (SELECT dep1.id_department id_department,
                           nvl(nch_numbers.num_total_ocupied_nch_hours, 0) total_ocuppied_nch_hours,
                           nvl(beds_numbers.num_beds_blocked, 0) beds_blocked,
                           nvl(beds_numbers.num_beds_reserved, 0) beds_reserved,
                           nvl(beds_numbers.num_beds_occupied, 0) beds_ocuppied,
                           nch_numbers.num_total_avail_nch_hours total_avail_nch_hours,
                           nvl(beds_avail.num_avail_beds, 0) total_available_beds,
                           nvl(beds_occup.num_occup_beds + beds_numbers.num_beds_reserved,
                               nvl(beds_numbers.num_beds_reserved, 0)) total_unavailable_beds
                      FROM department dep1
                      LEFT JOIN (SELECT dep.id_department,
                                       nvl(COUNT(ba_blocked.flg_bed_status), 0) num_beds_blocked,
                                       COUNT(ba_reserved.flg_bed_status) num_beds_reserved,
                                       COUNT(ba_ocupied.flg_bed_status) num_beds_occupied
                                  FROM department dep
                                 INNER JOIN room roo
                                    ON (roo.id_department = dep.id_department AND roo.flg_available = get_yes())
                                 INNER JOIN bed bed
                                    ON (bed.id_room = roo.id_room AND bed.flg_available = get_yes())
                                  LEFT JOIN bmng_allocation_bed bab
                                    ON (bab.id_bed = bed.id_bed AND bab.flg_outdated = get_no())
                                  LEFT JOIN bmng_action ba_blocked
                                    ON (ba_blocked.id_bed = bed.id_bed AND ba_blocked.id_room = roo.id_room AND
                                       ba_blocked.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a AND
                                       ba_blocked.flg_bed_status = pk_bmng_constant.g_bmng_act_flg_bed_sta_b AND
                                       ba_blocked.flg_bed_ocupacity_status = pk_bmng_constant.g_bmng_act_flg_ocupaci_v)
                                  LEFT JOIN (SELECT a.id_bmng_allocation_bed,
                                                   a.id_bed,
                                                   row_number() over(PARTITION BY a.id_bed ORDER BY a.dt_creation DESC, a.dt_release DESC) rn
                                              FROM bmng_allocation_bed a
                                             WHERE a.flg_outdated = get_yes()) bab_rvd
                                    ON bab_rvd.id_bed = bed.id_bed
                                   AND bab_rvd.rn = 1
                                  LEFT JOIN bmng_action ba_reserved
                                    ON (ba_reserved.id_bed = bed.id_bed AND
                                       ba_reserved.id_bmng_allocation_bed = bab_rvd.id_bmng_allocation_bed AND
                                       ba_reserved.id_room = roo.id_room AND
                                       ba_reserved.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a AND
                                       ba_reserved.flg_bed_status = pk_bmng_constant.g_bmng_act_flg_bed_sta_r AND
                                       ba_reserved.flg_bed_ocupacity_status = pk_bmng_constant.g_bmng_act_flg_ocupaci_o)
                                  LEFT JOIN bmng_action ba_ocupied
                                    ON (ba_ocupied.id_bed = bed.id_bed AND
                                       ba_ocupied.id_bmng_allocation_bed = bab.id_bmng_allocation_bed AND
                                       ba_ocupied.id_room = roo.id_room AND
                                       ba_ocupied.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a AND
                                       ba_ocupied.flg_bed_status = pk_bmng_constant.g_bmng_act_flg_bed_sta_n AND
                                       ba_ocupied.flg_bed_ocupacity_status = pk_bmng_constant.g_bmng_act_flg_ocupaci_o)
                                 WHERE dep.flg_available = get_yes()
                                   AND ((l_count_temp_beds = get_no() AND
                                       bed.flg_type = pk_bmng_constant.g_bmng_bed_flg_type_p) OR
                                       l_count_temp_beds = get_yes())
                                 GROUP BY dep.id_department) beds_numbers
                        ON (beds_numbers.id_department = dep1.id_department)
                      LEFT JOIN (
                                
                                SELECT data.id_department,
                                        data.num_total_ocupied_nch_hours,
                                        SUM(data.nch_capacity) num_total_avail_nch_hours
                                  FROM (SELECT dep2.id_department,
                                                pk_bmng_core.get_nch_service_level(g_log_lang,
                                                                                   profissional(l_prof.id,
                                                                                                dep2.id_institution,
                                                                                                nvl(dep2.id_software,
                                                                                                    pk_alert_constant.g_soft_inpatient)),
                                                                                   dep2.id_department) num_total_ocupied_nch_hours,
                                                
                                                ba_avail_nch.nch_capacity
                                           FROM department dep2
                                          INNER JOIN bmng_action ba_avail_nch
                                             ON (ba_avail_nch.id_department = dep2.id_department AND
                                                ba_avail_nch.flg_target_action = pk_bmng_constant.g_bmng_act_flg_target_s AND
                                                ba_avail_nch.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a AND
                                                ba_avail_nch.flg_origin_action IN
                                                (pk_bmng_constant.g_bmng_act_flg_origin_nb,
                                                  pk_bmng_constant.g_bmng_act_flg_origin_nt,
                                                  pk_bmng_constant.g_bmng_act_flg_origin_nd))
                                            AND ba_avail_nch.dt_begin_action <= l_current_timestamp
                                            AND (ba_avail_nch.dt_end_action >= l_current_timestamp OR
                                                ba_avail_nch.dt_end_action IS NULL)
                                          WHERE dep2.flg_available = get_yes()) data
                                 GROUP BY data.id_department, data.num_total_ocupied_nch_hours) nch_numbers
                        ON (nch_numbers.id_department = dep1.id_department)
                      LEFT JOIN (SELECT COUNT(b1.id_bed) num_avail_beds, r1.id_department
                                  FROM bed b1
                                  LEFT JOIN bmng_action ba
                                    ON (b1.id_bed = ba.id_bed AND
                                       ba.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a AND
                                       ba.flg_bed_ocupacity_status <> pk_bmng_constant.g_bmng_act_flg_ocupaci_o AND
                                       ba.flg_bed_status = pk_bmng_constant.g_bmng_act_flg_bed_sta_n)
                                 INNER JOIN room r1
                                    ON (r1.id_room = b1.id_room AND r1.flg_available = get_yes())
                                 WHERE b1.flg_type = pk_bmng_constant.g_bmng_bed_flg_type_p
                                   AND b1.flg_status = pk_bmng_constant.g_bmng_bed_flg_status_v
                                   AND b1.flg_available = get_yes()
                                 GROUP BY r1.id_department) beds_avail
                        ON (beds_avail.id_department = dep1.id_department)
                      LEFT JOIN (SELECT COUNT(b2.id_bed) num_occup_beds, r2.id_department
                                  FROM bmng_action ba
                                 INNER JOIN bed b2
                                    ON (b2.id_bed = ba.id_bed AND b2.flg_available = get_yes())
                                 INNER JOIN room r2
                                    ON (r2.id_room = b2.id_room AND r2.flg_available = get_yes())
                                  LEFT JOIN bmng_allocation_bed bab
                                    ON (bab.id_bed = b2.id_bed AND bab.flg_outdated = get_no())
                                 WHERE ba.flg_status = pk_bmng_constant.g_bmng_act_flg_status_a
                                   AND ((ba.flg_bed_ocupacity_status = pk_bmng_constant.g_bmng_act_flg_ocupaci_o AND
                                       bab.id_bmng_allocation_bed = ba.id_bmng_allocation_bed) OR
                                       ba.flg_bed_status = pk_bmng_constant.g_bmng_act_flg_bed_sta_b)
                                 GROUP BY r2.id_department) beds_occup
                        ON (beds_occup.id_department = dep1.id_department)
                     WHERE dep1.flg_available = get_yes()
                       AND instr(dep1.flg_type, 'I') > 0)
        
        LOOP
            --
            IF i_validate_table
            THEN
                --insert in temporary table
                INSERT INTO bmng_department_ea_tmp
                    (id_department,
                     total_ocuppied_nch_hours,
                     total_unavailable_beds,
                     beds_blocked,
                     beds_reserved,
                     beds_ocuppied,
                     total_available_beds,
                     total_avail_nch_hours,
                     dt_dg_last_update)
                VALUES
                    (rec.id_department,
                     rec.total_ocuppied_nch_hours,
                     rec.total_unavailable_beds,
                     rec.beds_blocked,
                     rec.beds_reserved,
                     rec.beds_ocuppied,
                     rec.total_available_beds,
                     rec.total_avail_nch_hours,
                     current_timestamp);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO bmng_department_ea
                    (id_department,
                     total_ocuppied_nch_hours,
                     total_unavailable_beds,
                     beds_blocked,
                     beds_reserved,
                     beds_ocuppied,
                     total_available_beds,
                     total_avail_nch_hours,
                     dt_dg_last_update)
                VALUES
                    (rec.id_department,
                     rec.total_ocuppied_nch_hours,
                     rec.total_unavailable_beds,
                     rec.beds_blocked,
                     rec.beds_reserved,
                     rec.beds_ocuppied,
                     rec.total_available_beds,
                     rec.total_avail_nch_hours,
                     current_timestamp);
            
            END IF;
        
            IF MOD(l_count, i_commit_step) = 0
            THEN
                COMMIT;
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_department id_department
                           FROM bmng_department_ea a
                           JOIN bmng_department_ea_tmp b
                             ON a.id_department = b.id_department
                          WHERE a.dt_dg_last_update < l_current_timestamp
                               --
                            AND ((a.total_ocuppied_nch_hours <> b.total_ocuppied_nch_hours) OR
                                (a.total_ocuppied_nch_hours IS NULL AND b.total_ocuppied_nch_hours IS NOT NULL) OR
                                (a.total_ocuppied_nch_hours IS NOT NULL AND b.total_ocuppied_nch_hours IS NULL) OR
                                --
                                (a.total_unavailable_beds <> b.total_unavailable_beds) OR
                                (a.total_unavailable_beds IS NULL AND b.total_unavailable_beds IS NOT NULL) OR
                                (a.total_unavailable_beds IS NOT NULL AND b.total_unavailable_beds IS NULL) OR
                                --
                                (a.beds_blocked <> b.beds_blocked) OR
                                (a.beds_blocked IS NULL AND b.beds_blocked IS NOT NULL) OR
                                (a.beds_blocked IS NOT NULL AND b.beds_blocked IS NULL) OR
                                --
                                (a.beds_reserved <> b.beds_reserved) OR
                                (a.beds_reserved IS NULL AND b.beds_reserved IS NOT NULL) OR
                                (a.beds_reserved IS NOT NULL AND b.beds_reserved IS NULL) OR
                                --
                                (a.beds_ocuppied <> b.beds_ocuppied) OR
                                (a.beds_ocuppied IS NULL AND b.beds_ocuppied IS NOT NULL) OR
                                (a.beds_ocuppied IS NOT NULL AND b.beds_ocuppied IS NULL) OR
                                --
                                (a.total_available_beds <> b.total_available_beds) OR
                                (a.total_available_beds IS NULL AND b.total_available_beds IS NOT NULL) OR
                                (a.total_available_beds IS NOT NULL AND b.total_available_beds IS NULL) OR
                                --
                                (a.total_avail_nch_hours <> b.total_avail_nch_hours) OR
                                (a.total_avail_nch_hours IS NULL AND b.total_avail_nch_hours IS NOT NULL) OR
                                (a.total_avail_nch_hours IS NOT NULL AND b.total_avail_nch_hours IS NULL)
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_bmng_dep_table_name,
                                          i_id_pk_1_value       => rec1.id_department,
                                          i_id_pk_1_col_name    => g_bmng_dep_column_pk1,
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --          COMMIT;
        
            --the ones that are missing
            FOR rec2 IN (SELECT a.id_department id_department
                           FROM bmng_department_ea_tmp a
                          WHERE NOT EXISTS (SELECT 0
                                   FROM bmng_department_ea b
                                  WHERE a.id_department = a.id_department))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_bmng_dep_table_name,
                                          i_id_pk_1_value       => rec2.id_department,
                                          i_id_pk_1_col_name    => g_bmng_dep_column_pk1,
                                          i_id_pk_2_value       => NULL,
                                          i_id_pk_2_col_name    => NULL,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO bmng_department_ea bb_ea
            USING (SELECT *
                     FROM bmng_department_ea_tmp bb_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = bb_ea_tmp.id_department
                              AND dgir.ea_table_name = g_bmng_dep_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (bb_ea.id_department = t.id_department)
            WHEN MATCHED THEN
                UPDATE
                   SET bb_ea.total_ocuppied_nch_hours = t.total_ocuppied_nch_hours,
                       bb_ea.total_unavailable_beds   = t.total_unavailable_beds,
                       bb_ea.beds_blocked             = t.beds_blocked,
                       bb_ea.beds_reserved            = t.beds_reserved,
                       bb_ea.beds_ocuppied            = t.beds_ocuppied,
                       bb_ea.total_available_beds     = t.total_available_beds,
                       bb_ea.total_avail_nch_hours    = t.total_avail_nch_hours,
                       bb_ea.dt_dg_last_update        = l_current_timestamp
                 WHERE bb_ea.id_department = t.id_department
            WHEN NOT MATCHED THEN
                INSERT
                    (id_department,
                     total_ocuppied_nch_hours,
                     total_unavailable_beds,
                     beds_blocked,
                     beds_reserved,
                     beds_ocuppied,
                     total_available_beds,
                     total_avail_nch_hours,
                     dt_dg_last_update)
                VALUES
                    (t.id_department,
                     t.total_ocuppied_nch_hours,
                     t.total_unavailable_beds,
                     t.beds_blocked,
                     t.beds_reserved,
                     t.beds_ocuppied,
                     t.total_available_beds,
                     t.total_avail_nch_hours,
                     l_current_timestamp);
        
            COMMIT;
        END IF;
    
        --delete records from temporary table
        DELETE FROM bmng_department_ea_tmp;
        --    COMMIT;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_bmng_dep_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        --     COMMIT;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_bmng_department_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_bmng_department_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
    
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM bmng_department_ea_tmp;
            --    COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_DEPARTMENT_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
        
            --delete records from temporary table
            DELETE FROM bmng_department_ea_tmp;
            --       COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_DEPARTMENT_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
            dbms_output.put_line(SQLERRM);
            ROLLBACK;
        
            --delete records from temporary table
            DELETE FROM bmng_department_ea_tmp;
            COMMIT;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_BMNG_DEPARTMENT_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_bmng_department_ea;

    /********************************************************************************************
    * Actualize Easy Access table BMNG_BED_EA and BMNG_DAPERTMENT_EA with all tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.6.1.0.1
    * @since    2011/05/09
    ********************************************************************************************/
    FUNCTION admin_all_bmng_tables
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
    
        l_error     t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
        g_error := 'admin_bmng_bed_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_bmng_bed_ea(i_patient,
                                 i_episode,
                                 i_schedule,
                                 i_external_request,
                                 i_institution,
                                 i_start_dt,
                                 i_end_dt,
                                 i_validate_table,
                                 i_output_invalid_records,
                                 i_recreate_table,
                                 i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --
        g_error := 'admin_bmng_department_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_bmng_department_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE l_exception;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            dbms_output.put_line('ADMIN_ALL_BMNG_TABLES -> ' || g_error || ' - ' || SQLERRM);
            pk_alert_exceptions.process_error(1,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_DATA_GOV_ADMIN',
                                              'ADMIN_ALL_BMNG_TABLES',
                                              l_error);
            RETURN FALSE;
    END admin_all_bmng_tables;

    /********************************************************************************************
    * ADMIN_ALL_BMNG_TABLES           Actualize all Easy Access tables associated with functionality Bed Management
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Luís Maia
    * @version  2.5.0.5
    * @since    2009/07/28
    ********************************************************************************************/
    PROCEDURE admin_70_all_bmng_tables IS
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    BEGIN
        --
        g_error := 'admin_bmng_bed_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_bmng_bed_ea(i_patient,
                                 i_episode,
                                 i_schedule,
                                 i_external_request,
                                 i_institution,
                                 i_start_dt,
                                 i_end_dt,
                                 i_validate_table,
                                 i_output_invalid_records,
                                 i_recreate_table,
                                 i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE e_internal;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --
        g_error := 'admin_bmng_department_ea';
        dbms_output.put_line('');
        dbms_output.put_line(g_error);
        IF NOT admin_bmng_department_ea(i_patient,
                                        i_episode,
                                        i_schedule,
                                        i_external_request,
                                        i_institution,
                                        i_start_dt,
                                        i_end_dt,
                                        i_validate_table,
                                        i_output_invalid_records,
                                        i_recreate_table,
                                        i_commit_step)
        THEN
            dbms_output.put_line(g_error || ' - ' || SQLERRM);
            RAISE e_internal;
        ELSE
            dbms_output.put_line(g_error || ' - Ok');
        END IF;
    
        --
        COMMIT;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
        
    END admin_70_all_bmng_tables;

    PROCEDURE admin_all_datagov_tables
    (
        i_mode IN NUMBER DEFAULT 0,
        i_inst IN NUMBER DEFAULT 0
    ) IS
    
        i_patient                NUMBER(24) := NULL;
        i_episode                NUMBER(24) := NULL;
        i_schedule               NUMBER(24) := NULL;
        i_external_request       NUMBER(24) := NULL;
        i_institution            NUMBER(24) := NULL;
        i_start_dt               TIMESTAMP WITH TIME ZONE;
        i_end_dt                 TIMESTAMP WITH TIME ZONE;
        i_validate_table         BOOLEAN := FALSE;
        i_output_invalid_records BOOLEAN := FALSE;
        i_recreate_table         BOOLEAN := TRUE;
        i_commit_step            NUMBER(24) := pk_data_gov_admin.get_commit_limit;
    
        l_ret                    BOOLEAN;
        l_validate_table         BOOLEAN;
        l_output_invalid_records BOOLEAN;
        l_recreate_table         BOOLEAN;
        l_commit_step            NUMBER(24);
        l_error                  t_error_out;
        e_admin_update           EXCEPTION;
        g_upd_pat_in_episode CONSTANT VARCHAR2(2 CHAR) := '00';
        g_episode            CONSTANT VARCHAR2(2 CHAR) := '01';
        g_upd_episode        CONSTANT VARCHAR2(2 CHAR) := '02';
        g_upd_patient        CONSTANT VARCHAR2(2 CHAR) := '03';
        g_epis_info          CONSTANT VARCHAR2(2 CHAR) := '04';
    
        CURSOR c_admin_procedures IS
            SELECT COUNT(0) c, aa.procedure_name object_name, aa.subprogram_id
              FROM all_procedures aa
             WHERE aa.owner = upper(g_package_owner)
               AND aa.object_name = upper(g_package_name)
               AND aa.procedure_name != 'ADMIN_98_VIEWER_EHR_EA'
               AND regexp_like(aa.procedure_name, '^ADMIN_([[:digit:]]{2})_')
             GROUP BY aa.procedure_name, aa.object_name, aa.subprogram_id
            HAVING COUNT(0) IN(1)
             ORDER BY aa.procedure_name, aa.object_name, aa.subprogram_id;
    
        PROCEDURE call_procedure(i_procedure IN VARCHAR2) IS
        
            l_code VARCHAR2(4000 CHAR);
        
        BEGIN
        
            l_code := 'BEGIN ' || --
                      ' ' || g_package_name || '.' || i_procedure || '; ' || --
                      '    pk_control_ea_run.unmark_ea_to_run(''' || i_procedure || '''); ' || --
                      '    pk_control_ea_run.log_ea_run(''' || i_procedure || '''); ' || --
                      'END ';
        
            pk_frmw.execute_parallel(l_code, i_procedure);
        
        END call_procedure;
    
    BEGIN
    
        set_inst(i_inst => i_inst);
    
        l_validate_table         := nvl(i_validate_table, TRUE);
        l_output_invalid_records := nvl(i_output_invalid_records, FALSE);
        l_recreate_table         := nvl(i_recreate_table, FALSE);
        l_commit_step            := nvl(i_commit_step, k_default_limit);
    
        g_error := 'CLEANING ERROR TABLES';
        clean_err00_tables;
    
        pk_frmw.init_parallel_execution;
    
        FOR r IN c_admin_procedures
        LOOP
            IF ((regexp_replace(r.object_name, '^ADMIN_([[:digit:]]{2})_.*$', '\1') IN
               (g_upd_pat_in_episode, g_episode, g_upd_episode, g_upd_patient, g_epis_info) AND i_mode = 1) OR
               (regexp_replace(r.object_name, '^ADMIN_([[:digit:]]{2})_.*$', '\1') NOT IN
               (g_upd_pat_in_episode, g_episode, g_upd_episode, g_upd_patient, g_epis_info) AND i_mode = 2) OR
               i_mode = 0)
            THEN
                g_error := r.object_name;
                dbms_output.put_line('');
                dbms_output.put_line(g_error);
                pk_alertlog.log_debug(g_error);
            
                IF pk_control_ea_run.is_to_run(r.object_name) = 1
                THEN
                    IF r.c = 1
                    THEN
                        BEGIN
                            call_procedure(r.object_name);
                        EXCEPTION
                            WHEN OTHERS THEN
                                dbms_output.put_line('ADMIN_ALL_DATAGOV_TABLES -> ' || g_error || ' - ' || SQLERRM);
                                l_ret := pk_alert_exceptions.process_error_short(i_sqlerrm => SQLERRM,
                                                                                 i_sqlcode => SQLCODE,
                                                                                 o_error   => l_error);
                        END;
                    END IF;
                END IF;
            END IF;
        END LOOP;
    
        g_error := 'CALL pk_frmw.wait_signals_complete';
        pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
        pk_frmw.wait_signals_complete;
    
        IF pk_control_ea_run.is_to_run(k_process_stats) = 1
        THEN
            g_error := 'CALL process_statistics()';
            pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
            process_statistics();
            pk_control_ea_run.unmark_ea_to_run(k_process_stats);
            pk_control_ea_run.log_ea_run(k_process_stats);
        END IF;
    
        IF pk_control_ea_run.is_to_run(k_viewer_ea_proc) = 1
        THEN
            g_error := 'CALL admin_98_viewer_ehr_ea()';
            pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
            admin_98_viewer_ehr_ea(i_inst => i_inst);
            pk_control_ea_run.unmark_ea_to_run(k_viewer_ea_proc);
            pk_control_ea_run.log_ea_run(k_viewer_ea_proc);
        END IF;
    
        g_error := 'Leaving function admin_all_datagov_tables';
        pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
    
    EXCEPTION
        WHEN OTHERS THEN
            g_error := 'ADMIN_ALL_DATAGOV_TABLES -> ' || g_error || ' - ' || SQLERRM;
            pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
        
            dbms_output.put_line('ADMIN_ALL_DATAGOV_TABLES -> ' || g_error || ' - ' || SQLERRM);
            raise_application_error(-20001,
                                    'Error updating admin_all_datagov_tables. Please see alertlog.tlog for more details');
    END admin_all_datagov_tables;

    PROCEDURE admin_all_datagov_tables(i_mode IN NUMBER DEFAULT 0) IS
    
    BEGIN
    
        admin_all_datagov_tables(i_mode, 0);
    
    EXCEPTION
        WHEN OTHERS THEN
            g_error := 'ADMIN_ALL_DATAGOV_TABLES -> ' || g_error || ' - ' || SQLERRM;
            pk_alertlog.log_debug(g_error, g_package_name, 'ADMIN_ALL_DATAGOV_TABLES');
        
            dbms_output.put_line('ADMIN_ALL_DATAGOV_TABLES -> ' || g_error || ' - ' || SQLERRM);
            raise_application_error(-20001,
                                    'Error updating admin_all_datagov_tables. Please see alertlog.tlog for more details');
    END admin_all_datagov_tables;

    PROCEDURE admin_50_grids_ea IS
    
        i_patient          NUMBER(24) := NULL;
        i_episode          NUMBER(24) := NULL;
        i_schedule         NUMBER(24) := NULL;
        i_external_request NUMBER(24) := NULL;
        i_institution      NUMBER(24) := NULL;
        i_start_dt         TIMESTAMP WITH TIME ZONE;
        i_end_dt           TIMESTAMP WITH TIME ZONE;
        i_validate_table   BOOLEAN := FALSE;
        i_recreate_table   BOOLEAN := TRUE;
    
        l_current_timestamp TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        CURSOR c_invalid_records IS
            SELECT decode(gea.id_episode, temp.id_episode, 2, 1) validation_type,
                   nvl(gea.id_episode, temp.id_episode) id_episode
              FROM grids_ea gea
              FULL OUTER JOIN (SELECT epis.id_episode,
                                      epis.id_visit,
                                      epis.id_clinical_service,
                                      epis.flg_status episode_flg_status,
                                      epis.id_epis_type,
                                      epis.companion episode_companion,
                                      epis.barcode,
                                      epis.id_prof_cancel,
                                      epis.flg_type,
                                      epis.id_prev_episode,
                                      epis.dt_begin_tstz,
                                      epis.dt_end_tstz,
                                      epis.dt_cancel_tstz,
                                      epis.id_fast_track,
                                      epis.flg_ehr,
                                      epis.id_patient,
                                      epis.id_department,
                                      epis.id_institution,
                                      ei.id_bed,
                                      ei.id_room,
                                      ei.id_professional,
                                      ei.norton,
                                      ei.flg_hydric,
                                      ei.flg_wound,
                                      ei.companion epis_info_companion,
                                      ei.flg_unknown,
                                      ei.desc_info,
                                      ei.id_schedule,
                                      ei.id_first_nurse_resp,
                                      ei.flg_status epis_info_flg_status,
                                      ei.id_dep_clin_serv,
                                      ei.id_first_dep_clin_serv,
                                      ei.dt_first_obs_tstz,
                                      ei.dt_first_nurse_obs_tstz,
                                      ei.dt_first_inst_obs_tstz,
                                      ei.triage_acuity,
                                      ei.triage_color_text,
                                      ei.triage_rank_acuity,
                                      ei.triage_flg_letter,
                                      ei.id_triage_color,
                                      ei.id_software,
                                      pk_announced_arrival.get_ann_arrival_id(epis.id_institution,
                                                                              ei.id_software,
                                                                              epis.id_episode,
                                                                              ei.flg_unknown) id_announced_arrival
                                 FROM episode epis
                                 JOIN epis_info ei
                                   ON (epis.id_episode = ei.id_episode)
                                WHERE epis.flg_ehr != 'E'
                                  AND epis.flg_status IN (pk_alert_constant.g_active, pk_alert_constant.g_pending)) temp
                ON (temp.id_episode = gea.id_episode)
             WHERE (temp.id_episode IS NULL OR gea.id_episode IS NULL OR temp.id_visit != gea.id_visit OR
                   temp.id_clinical_service != gea.id_clinical_service OR
                   temp.episode_flg_status != gea.episode_flg_status OR temp.id_epis_type != gea.id_epis_type OR
                   temp.episode_companion != gea.episode_companion OR temp.barcode != gea.barcode OR
                   temp.id_prof_cancel != gea.id_prof_cancel OR temp.flg_type != gea.flg_type OR
                   temp.id_prev_episode != gea.id_prev_episode OR temp.dt_begin_tstz != gea.dt_begin_tstz OR
                   temp.dt_end_tstz != gea.dt_end_tstz OR temp.dt_cancel_tstz != gea.dt_cancel_tstz OR
                   temp.id_fast_track != gea.id_fast_track OR temp.flg_ehr != gea.flg_ehr OR
                   temp.id_patient != gea.id_patient OR temp.id_department != gea.id_department OR
                   temp.id_institution != gea.id_institution OR temp.id_bed != gea.id_bed OR
                   temp.id_room != gea.id_room OR temp.id_professional != gea.id_professional OR
                   temp.norton != gea.norton OR temp.flg_hydric != gea.flg_hydric OR temp.flg_wound != gea.flg_wound OR
                   temp.epis_info_companion != gea.epis_info_companion OR temp.flg_unknown != gea.flg_unknown OR
                   temp.desc_info != gea.desc_info OR temp.id_schedule != gea.id_schedule OR
                   temp.id_first_nurse_resp != gea.id_first_nurse_resp OR
                   temp.epis_info_flg_status != gea.epis_info_flg_status OR
                   temp.id_dep_clin_serv != gea.id_dep_clin_serv OR
                   temp.id_first_dep_clin_serv != gea.id_first_dep_clin_serv OR
                   temp.dt_first_obs_tstz != gea.dt_first_obs_tstz OR
                   temp.dt_first_nurse_obs_tstz != gea.dt_first_nurse_obs_tstz OR
                   temp.dt_first_inst_obs_tstz != gea.dt_first_inst_obs_tstz OR
                   temp.triage_acuity != gea.triage_acuity OR temp.triage_color_text != gea.triage_color_text OR
                   temp.triage_rank_acuity != gea.triage_rank_acuity OR
                   temp.triage_flg_letter != gea.triage_flg_letter OR temp.id_triage_color != gea.id_triage_color OR
                   temp.id_software != gea.id_software OR temp.id_announced_arrival != gea.id_announced_arrival);
        TYPE t_invalid_records IS TABLE OF c_invalid_records%ROWTYPE;
        l_invalid_records t_invalid_records;
    BEGIN
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            OPEN c_invalid_records;
            FETCH c_invalid_records BULK COLLECT
                INTO l_invalid_records;
            CLOSE c_invalid_records;
        
            IF l_invalid_records.exists(1)
            THEN
                FOR i IN l_invalid_records.first .. l_invalid_records.last
                LOOP
                    IF NOT ins_invalid_record(i_ea_table_name       => 'GRIDS_EA',
                                              i_id_pk_1_value       => l_invalid_records(i).id_episode,
                                              i_id_pk_1_col_name    => 'ID_EPISODE',
                                              i_id_pk_2_value       => NULL,
                                              i_id_pk_2_col_name    => NULL,
                                              i_id_pk_3_value       => NULL,
                                              i_id_pk_3_col_name    => NULL,
                                              i_id_pk_4_value       => NULL,
                                              i_id_pk_4_col_name    => NULL,
                                              i_dt_validation       => l_current_timestamp,
                                              i_validation_type     => l_invalid_records(i).validation_type,
                                              i_in_patient          => i_patient,
                                              i_in_episode          => i_episode,
                                              i_in_schedule         => i_schedule,
                                              i_in_external_request => i_external_request,
                                              i_in_institution      => i_institution,
                                              i_in_start_dt         => i_start_dt,
                                              i_in_end_dt           => i_end_dt)
                    THEN
                    
                        RAISE e_internal;
                    END IF;
                
                    IF i = l_invalid_records.last
                    THEN
                        dbms_output.put_line('OK: ' || i || ' inserted invalid records');
                    END IF;
                END LOOP;
            
                --delete last validation's records
                DELETE FROM data_gov_invalid_recs dgir
                 WHERE dgir.ea_table_name = 'GRIDS_EA'
                   AND dgir.dt_validation < l_current_timestamp;
            
                COMMIT;
            END IF;
        END IF;
    
        IF i_recreate_table
        THEN
            DELETE FROM grids_ea gea;
        
            INSERT INTO grids_ea
                (id_episode,
                 id_visit,
                 id_clinical_service,
                 episode_flg_status,
                 id_epis_type,
                 episode_companion,
                 barcode,
                 id_prof_cancel,
                 flg_type,
                 id_prev_episode,
                 dt_begin_tstz,
                 dt_end_tstz,
                 dt_cancel_tstz,
                 id_fast_track,
                 flg_ehr,
                 id_patient,
                 id_department,
                 id_institution,
                 id_bed,
                 id_room,
                 id_professional,
                 norton,
                 flg_hydric,
                 flg_wound,
                 epis_info_companion,
                 flg_unknown,
                 desc_info,
                 id_schedule,
                 id_first_nurse_resp,
                 epis_info_flg_status,
                 id_dep_clin_serv,
                 id_first_dep_clin_serv,
                 dt_first_obs_tstz,
                 dt_first_nurse_obs_tstz,
                 dt_first_inst_obs_tstz,
                 triage_acuity,
                 triage_color_text,
                 triage_rank_acuity,
                 triage_flg_letter,
                 id_triage_color,
                 id_software,
                 id_announced_arrival)
                SELECT epis.id_episode,
                       epis.id_visit,
                       epis.id_clinical_service,
                       epis.flg_status episode_flg_status,
                       epis.id_epis_type,
                       epis.companion episode_companion,
                       epis.barcode,
                       epis.id_prof_cancel,
                       epis.flg_type,
                       epis.id_prev_episode,
                       epis.dt_begin_tstz,
                       epis.dt_end_tstz,
                       epis.dt_cancel_tstz,
                       epis.id_fast_track,
                       epis.flg_ehr,
                       epis.id_patient,
                       epis.id_department,
                       epis.id_institution,
                       ei.id_bed,
                       ei.id_room,
                       ei.id_professional,
                       ei.norton,
                       ei.flg_hydric,
                       ei.flg_wound,
                       ei.companion epis_info_companion,
                       ei.flg_unknown,
                       ei.desc_info,
                       ei.id_schedule,
                       ei.id_first_nurse_resp,
                       ei.flg_status epis_info_flg_status,
                       ei.id_dep_clin_serv,
                       ei.id_first_dep_clin_serv,
                       ei.dt_first_obs_tstz,
                       ei.dt_first_nurse_obs_tstz,
                       ei.dt_first_inst_obs_tstz,
                       ei.triage_acuity,
                       ei.triage_color_text,
                       ei.triage_rank_acuity,
                       ei.triage_flg_letter,
                       ei.id_triage_color,
                       ei.id_software,
                       pk_announced_arrival.get_ann_arrival_id(epis.id_institution,
                                                               ei.id_software,
                                                               epis.id_episode,
                                                               ei.flg_unknown)
                  FROM episode epis
                  JOIN epis_info ei
                    ON (epis.id_episode = ei.id_episode)
                 WHERE epis.flg_ehr != 'E'
                   AND epis.flg_status IN (pk_alert_constant.g_active, pk_alert_constant.g_pending);
        
            dbms_output.put_line('OK: ' || SQL%ROWCOUNT || ' inserted records');
            COMMIT;
        END IF;
    
    EXCEPTION
        WHEN e_internal THEN
            raise_application_error(-20001, 'Internal error. Check table alertlog.tlog for error details.');
    END admin_50_grids_ea;
    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Paulo teixeira
    * @version  2.6.1.2
    * @since    19/07/2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_problems_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROBLEMS_EA';
    
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_problems',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_problems))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM (SELECT phd.id_episode,
                                   phd.id_pat_history_diagnosis,
                                   phd.dt_pat_history_diagnosis_tstz dt_req,
                                   phd.flg_status,
                                   phd.id_professional,
                                   phd.id_patient,
                                   epi.id_visit,
                                   epi.id_institution,
                                   CASE
                                        WHEN phd.flg_status IN (pk_problems.g_pat_probl_active) THEN
                                         pk_prog_notes_constants.g_task_ongoing_o
                                        WHEN phd.flg_status IN (pk_problems.g_pat_probl_resolved) THEN
                                         pk_prog_notes_constants.g_task_finalized_f
                                        WHEN phd.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                                         pk_prog_notes_constants.g_task_inactive_i
                                        ELSE
                                         pk_prog_notes_constants.g_task_ongoing_o
                                    END flg_ongoing,
                                   pk_alert_constant.g_yes flg_normal,
                                   NULL id_prof_exec,
                                   pk_alert_constant.g_no flg_has_comments,
                                   pk_sysdomain.get_rank(g_log_lang, 'PAT_HISTORY_DIAGNOSIS.FLG_STATUS', phd.flg_status) rank,
                                   pk_review.get_last_review_prof(i_lang           => NULL,
                                                                  i_prof           => NULL,
                                                                  i_id_episode     => phd.id_episode,
                                                                  i_id_record_area => phd.id_pat_history_diagnosis,
                                                                  i_flg_context    => pk_review.get_problems_context()) id_prof_review,
                                   pk_review.get_last_review_date(i_lang           => NULL,
                                                                  i_prof           => NULL,
                                                                  i_id_episode     => phd.id_episode,
                                                                  i_id_record_area => phd.id_pat_history_diagnosis,
                                                                  i_flg_context    => pk_review.get_problems_context()) dt_review,
                                   phd.flg_area,
                                   pk_sysconfig.get_config(i_code_cf   => pk_alert_constant.g_diag_area_sys_config,
                                                           i_prof_inst => epi.id_institution,
                                                           i_prof_soft => ei.id_software) area_cfg,
                                   phd.dt_diagnosed,
                                   phd.dt_diagnosed_precision
                              FROM pat_history_diagnosis phd
                              LEFT JOIN episode epi
                                ON epi.id_episode = phd.id_episode
                              LEFT JOIN epis_info ei
                                ON ei.id_episode = epi.id_episode
                              LEFT JOIN alert_diagnosis ad
                                ON phd.id_alert_diagnosis = ad.id_alert_diagnosis
                              LEFT JOIN diagnosis d
                                ON phd.id_diagnosis = d.id_diagnosis
                             WHERE ((i_patient IS NOT NULL AND phd.id_patient = i_patient) OR i_patient IS NULL)
                               AND ((i_episode IS NOT NULL AND phd.id_episode = i_episode) OR i_episode IS NULL)
                               AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR
                                   i_institution IS NULL)
                               AND phd.dt_pat_history_diagnosis_tstz >=
                                   nvl(i_start_dt, phd.dt_pat_history_diagnosis_tstz)
                               AND phd.dt_pat_history_diagnosis_tstz <= nvl(i_end_dt, phd.dt_pat_history_diagnosis_tstz)
                               AND phd.id_pat_history_diagnosis_new IS NULL
                               AND (phd.flg_status NOT IN
                                   (pk_past_history.g_pat_hist_diag_none,
                                     pk_past_history.g_pat_hist_diag_non_remark,
                                     pk_past_history.g_pat_hist_diag_unknown,
                                     pk_past_history.g_pat_hist_diag_canceled) OR phd.flg_status IS NULL)
                               AND phd.flg_type = pk_problems.g_flg_type_med
                               AND phd.id_pat_history_diagnosis =
                                   pk_problems.get_most_recent_phd_id(phd.id_pat_history_diagnosis)
                               AND NOT EXISTS
                             (SELECT 1
                                      FROM pat_problem pp
                                      LEFT JOIN epis_diagnosis ed
                                        ON ed.id_epis_diagnosis = pp.id_epis_diagnosis
                                      LEFT JOIN diagnosis d1
                                        ON pp.id_diagnosis = d1.id_diagnosis
                                     WHERE pp.id_diagnosis = d.id_diagnosis
                                       AND pp.id_patient = phd.id_patient
                                       AND pp.id_habit IS NULL
                                       AND nvl(d1.flg_other, pk_alert_constant.g_no) <> pk_alert_constant.g_yes
                                       AND ( --final diagnosis 
                                            (ed.flg_type = pk_diagnosis.g_diag_type_d) --                             
                                            OR -- differencial diagnosis only 
                                            (ed.flg_type = pk_diagnosis.g_diag_type_p AND
                                            ed.id_diagnosis NOT IN
                                            (SELECT ed3.id_diagnosis
                                                FROM epis_diagnosis ed3
                                               WHERE ed3.id_diagnosis = ed.id_diagnosis
                                                 AND ed3.id_patient = pp.id_patient
                                                 AND ed3.flg_type = pk_diagnosis.g_diag_type_d)) --
                                            OR -- não é um diagnóstico
                                            (pp.id_habit IS NOT NULL))
                                       AND pp.flg_status <> pk_problems.g_pat_probl_invest
                                       AND pp.dt_pat_problem_tstz > phd.dt_pat_history_diagnosis_tstz
                                       AND rownum = 1)) t
                     WHERE ((t.area_cfg LIKE pk_alert_constant.g_diag_area_config_show_all) OR
                           (t.area_cfg LIKE pk_alert_constant.g_diag_area_config_show_own AND
                           t.flg_area IN
                           (pk_alert_constant.g_diag_area_past_history, pk_alert_constant.g_diag_area_not_defined))))
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_history_diagnosis;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_history_diagnosis,
                     pk_prog_notes_constants.g_task_problems,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.dt_diagnosed_precision IN
                     (pk_past_history.g_date_precision_hour, pk_past_history.g_date_precision_day) THEN
                     rec.dt_diagnosed ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_ph_diag,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.rank,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_history_diagnosis;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_history_diagnosis,
                     pk_prog_notes_constants.g_task_problems,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.dt_diagnosed_precision IN
                     (pk_past_history.g_date_precision_hour, pk_past_history.g_date_precision_day) THEN
                     rec.dt_diagnosed ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_ph_diag,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.rank,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.rank              = t.rank,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     rank,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.rank,
                     t.id_prof_review,
                     t.dt_review);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_problems_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_problems_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_problems_ea',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_problems_ea',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_problems_ea',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_problems_ea;
    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Paulo teixeira
    * @version  2.6.1.2
    * @since    19/07/2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_allergy_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_ALLERGY_EA';
    
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_id_task           tl_task.id_tl_task%TYPE;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_allergies',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_allergies,
                                                                                            pk_prog_notes_constants.g_task_allergies_allergy,
                                                                                            pk_prog_notes_constants.g_task_allergies_adverse,
                                                                                            pk_prog_notes_constants.g_task_allergies_intolerance,
                                                                                            pk_prog_notes_constants.g_task_allergies_propensity))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT pa.id_episode,
                           pa.id_pat_allergy,
                           pa.dt_pat_allergy_tstz dt_req,
                           pa.flg_status,
                           pa.id_prof_write id_professional,
                           pa.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           pa.year_begin,
                           pa.month_begin,
                           pa.day_begin,
                           pa.year_end,
                           pa.month_end,
                           pa.day_end,
                           CASE
                                WHEN pa.flg_status IN (pk_allergy.g_pat_allergy_flg_active) THEN
                                 pk_prog_notes_constants.g_task_ongoing_o
                                WHEN pa.flg_status IN (pk_allergy.g_pat_allergy_flg_resolved) THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                WHEN pa.flg_status IN (pk_allergy.g_pat_allergy_flg_passive) THEN
                                 pk_prog_notes_constants.g_task_inactive_i
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           NULL id_prof_exec,
                           pk_alert_constant.g_no flg_has_comments,
                           pk_review.get_last_review_prof(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => pa.id_episode,
                                                          i_id_record_area => pa.id_pat_allergy,
                                                          i_flg_context    => pk_review.get_allergies_context()) id_prof_review,
                           pk_review.get_last_review_date(i_lang           => NULL,
                                                          i_prof           => NULL,
                                                          i_id_episode     => pa.id_episode,
                                                          i_id_record_area => pa.id_pat_allergy,
                                                          i_flg_context    => pk_review.get_allergies_context()) dt_review,
                           pa.flg_type
                    
                      FROM pat_allergy pa
                      LEFT JOIN episode epi
                        ON epi.id_episode = pa.id_episode
                     WHERE ((i_patient IS NOT NULL AND pa.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND pa.dt_pat_allergy_tstz >= nvl(i_start_dt, pa.dt_pat_allergy_tstz)
                       AND pa.dt_pat_allergy_tstz <= nvl(i_end_dt, pa.dt_pat_allergy_tstz)
                       AND (pa.flg_status <> pk_allergy.g_pat_allergy_flg_cancelled OR pa.flg_status IS NULL)
                    --
                    )
        LOOP
            g_error   := 'BEGIN LOOP';
            g_error   := 'GET TASK TYPE';
            l_id_task := CASE
                             WHEN rec.flg_type = pk_allergy.g_flg_type_allergy THEN
                              pk_prog_notes_constants.g_task_allergies_allergy
                             WHEN rec.flg_type = pk_allergy.g_flg_type_adv_react THEN
                              pk_prog_notes_constants.g_task_allergies_adverse
                             WHEN rec.flg_type = pk_allergy.g_flg_type_intolerance THEN
                              pk_prog_notes_constants.g_task_allergies_intolerance
                             WHEN rec.flg_type = pk_allergy.g_flg_type_propensity THEN
                              pk_prog_notes_constants.g_task_allergies_propensity
                             ELSE
                              pk_prog_notes_constants.g_task_allergies
                         END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_allergy;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_allergy,
                     pk_prog_notes_constants.g_task_allergies,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.year_begin IS NOT NULL AND (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND
                     rec.day_begin IS NOT NULL THEN
                     to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                  'YYYYMMDD') ELSE NULL END,
                     CASE WHEN rec.year_end IS NOT NULL AND (rec.month_end IS NOT NULL AND rec.month_end <> 0) AND
                     rec.day_end IS NOT NULL THEN
                     to_timestamp(rec.year_end || lpad(rec.month_end, 2, '0') || lpad(rec.day_end, 2, '0'), 'YYYYMMDD') ELSE NULL END,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pa,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_allergy,
                     l_id_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.year_begin IS NOT NULL AND (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND
                     rec.day_begin IS NOT NULL THEN
                     to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                  'YYYYMMDD') ELSE NULL END,
                     CASE WHEN rec.year_end IS NOT NULL AND (rec.month_end IS NOT NULL AND rec.month_end <> 0) AND
                     rec.day_end IS NOT NULL THEN
                     to_timestamp(rec.year_end || lpad(rec.month_end, 2, '0') || lpad(rec.day_end, 2, '0'), 'YYYYMMDD') ELSE NULL END,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pa,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_allergy;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_allergy,
                     l_id_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.year_begin IS NOT NULL AND (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND
                     rec.day_begin IS NOT NULL THEN
                     to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                  'YYYYMMDD') ELSE NULL END,
                     CASE WHEN rec.year_end IS NOT NULL AND (rec.month_end IS NOT NULL AND rec.month_end <> 0) AND
                     rec.day_end IS NOT NULL THEN
                     to_timestamp(rec.year_end || lpad(rec.month_end, 2, '0') || lpad(rec.day_end, 2, '0'), 'YYYYMMDD') ELSE NULL END,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pa,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
                IF l_id_task <> pk_prog_notes_constants.g_task_allergies
                THEN
                    INSERT INTO task_timeline_ea
                        (id_task_refid,
                         id_tl_task,
                         id_patient,
                         id_episode,
                         id_visit,
                         id_institution,
                         dt_req,
                         id_prof_req,
                         dt_begin,
                         dt_end,
                         flg_status_req,
                         table_name,
                         flg_show_method,
                         dt_dg_last_update,
                         flg_outdated,
                         flg_ongoing,
                         flg_normal,
                         id_prof_exec,
                         flg_has_comments,
                         dt_last_update,
                         id_prof_review,
                         dt_review)
                    VALUES
                        (rec.id_pat_allergy,
                         pk_prog_notes_constants.g_task_allergies,
                         rec.id_patient,
                         rec.id_episode,
                         rec.id_visit,
                         rec.id_institution,
                         rec.dt_req,
                         rec.id_professional,
                         CASE WHEN rec.year_begin IS NOT NULL AND
                         (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND rec.day_begin IS NOT NULL THEN
                         to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                      'YYYYMMDD') ELSE NULL END,
                         CASE WHEN rec.year_end IS NOT NULL AND (rec.month_end IS NOT NULL AND rec.month_end <> 0) AND
                         rec.day_end IS NOT NULL THEN
                         to_timestamp(rec.year_end || lpad(rec.month_end, 2, '0') || lpad(rec.day_end, 2, '0'),
                                      'YYYYMMDD') ELSE NULL END,
                         rec.flg_status,
                         pk_prog_notes_constants.g_tl_table_name_pa,
                         pk_alert_constant.g_tl_oriented_patient,
                         current_timestamp,
                         pk_ea_logic_tasktimeline.g_flg_not_outdated,
                         rec.flg_ongoing,
                         rec.flg_normal,
                         rec.id_prof_exec,
                         rec.flg_has_comments,
                         rec.dt_req,
                         rec.id_prof_review,
                         rec.dt_review);
                END IF;
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = tt_ea_tmp.id_tl_task -- pk_prog_notes_constants.g_task_allergies
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_allergy_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_allergy_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_allergy_ea',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_allergy_ea',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_allergy_ea',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_allergy_ea;
    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Paulo teixeira
    * @version  2.6.1.2
    * @since    19/07/2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_al_unaware_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_AL_UNAWARE_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_no_known_allergies',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_no_known_allergies))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT pa.id_episode,
                           pa.id_pat_allergy_unawareness,
                           pa.dt_creation                           dt_req,
                           pa.flg_status,
                           pa.id_professional                       id_professional,
                           pa.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                           pk_alert_constant.g_yes                  flg_normal,
                           NULL                                     id_prof_exec,
                           pk_alert_constant.g_no                   flg_has_comments
                      FROM pat_allergy_unawareness pa
                      LEFT JOIN episode epi
                        ON epi.id_episode = pa.id_episode
                     WHERE ((i_patient IS NOT NULL AND pa.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND pa.dt_creation >= nvl(i_start_dt, pa.dt_creation)
                       AND pa.dt_creation <= nvl(i_end_dt, pa.dt_creation)
                       AND (pa.flg_status NOT IN (pk_allergy.g_unawareness_outdated, pk_allergy.g_unawareness_cancelled) OR
                           pa.flg_status IS NULL)
                    --
                    )
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_allergy_unawareness;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_pat_allergy_unawareness,
                     pk_prog_notes_constants.g_task_no_known_allergies,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pa_unaware,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_allergy_unawareness;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_pat_allergy_unawareness,
                     pk_prog_notes_constants.g_task_no_known_allergies,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pa_unaware,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_no_known_allergies
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_al_unaware_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_al_unaware_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_al_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_al_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_al_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_al_unaware_ea;
    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Paulo teixeira
    * @version  2.6.1.2
    * @since    19/07/2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_prob_unaware_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROB_UNAWARE_EA';
    
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_no_known_prob',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_no_known_prob))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT ppu.id_episode,
                           ppu.id_pat_prob_unaware,
                           ppu.dt_last_update                       dt_req,
                           ppu.flg_status,
                           ppu.id_prof_last_update                  id_professional,
                           ppu.id_patient,
                           epi.id_visit,
                           epi.id_institution,
                           pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                           pk_alert_constant.g_yes                  flg_normal,
                           NULL                                     id_prof_exec,
                           pk_alert_constant.g_no                   flg_has_comments
                      FROM pat_prob_unaware ppu
                      LEFT JOIN episode epi
                        ON epi.id_episode = ppu.id_episode
                     WHERE ((i_patient IS NOT NULL AND ppu.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND epi.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND epi.id_institution = i_institution) OR i_institution IS NULL)
                       AND ppu.dt_last_update >= nvl(i_start_dt, ppu.dt_last_update)
                       AND ppu.dt_last_update <= nvl(i_end_dt, ppu.dt_last_update)
                       AND (ppu.flg_status NOT IN (pk_problems.g_status_ppu_outdated, pk_problems.g_status_ppu_cancel) OR
                           ppu.flg_status IS NULL)
                    --
                    )
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_prob_unaware;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_pat_prob_unaware,
                     pk_prog_notes_constants.g_task_no_known_prob,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pp_unaware,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_prob_unaware;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_pat_prob_unaware,
                     pk_prog_notes_constants.g_task_no_known_prob,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pp_unaware,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_no_known_prob
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_unaware_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_unaware_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_unaware_ea',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_prob_unaware_ea;
    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Paulo teixeira
    * @version  2.6.1.2
    * @since    19/07/2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_prob_diag_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROB_DIAG_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_problems_diag',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_problems_diag))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     pp.id_episode,
                     pp.id_pat_problem,
                     pp.dt_pat_problem_tstz dt_req,
                     pp.flg_status,
                     pp.id_professional_ins id_professional,
                     pp.id_patient,
                     epi.id_visit,
                     epi.id_institution,
                     pp.year_begin,
                     pp.month_begin,
                     pp.day_begin,
                     CASE
                          WHEN pp.flg_status IN (pk_problems.g_pat_probl_active) THEN
                           pk_prog_notes_constants.g_task_ongoing_o
                          WHEN pp.flg_status IN (pk_problems.g_pat_probl_resolved) THEN
                           pk_prog_notes_constants.g_task_finalized_f
                          WHEN pp.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                           pk_prog_notes_constants.g_task_inactive_i
                          ELSE
                           pk_prog_notes_constants.g_task_ongoing_o
                      END flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments,
                     pk_review.get_last_review_prof(i_lang           => NULL,
                                                    i_prof           => NULL,
                                                    i_id_episode     => pp.id_episode,
                                                    i_id_record_area => pp.id_pat_problem,
                                                    i_flg_context    => pk_review.get_problems_context()) id_prof_review,
                     pk_review.get_last_review_date(i_lang           => NULL,
                                                    i_prof           => NULL,
                                                    i_id_episode     => pp.id_episode,
                                                    i_id_record_area => pp.id_pat_problem,
                                                    i_flg_context    => pk_review.get_problems_context()) dt_review
                      FROM pat_problem pp
                      LEFT JOIN diagnosis d
                        ON pp.id_diagnosis = d.id_diagnosis
                      JOIN epis_diagnosis ed
                        ON ed.id_epis_diagnosis = pp.id_epis_diagnosis
                      LEFT JOIN episode epi
                        ON epi.id_episode = pp.id_episode
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epi.id_episode
                     WHERE pp.dt_pat_problem_tstz >= nvl(i_start_dt, pp.dt_pat_problem_tstz)
                       AND pp.dt_pat_problem_tstz <= nvl(i_end_dt, pp.dt_pat_problem_tstz)
                       AND (pp.flg_status NOT IN (pk_problems.g_pat_probl_cancel,
                                                  pk_problems.g_pat_probl_invest,
                                                  pk_diagnosis.g_pat_prob_excluded) OR pp.flg_status IS NULL)
                       AND ( --final diagnosis 
                            (ed.flg_type = pk_diagnosis.g_diag_type_d) -- 
                            OR -- differencial diagnosis only 
                            (ed.flg_type = pk_diagnosis.g_diag_type_p AND
                            ed.id_diagnosis NOT IN
                            (SELECT ed3.id_diagnosis
                                FROM epis_diagnosis ed3
                               WHERE ed3.id_diagnosis = ed.id_diagnosis
                                 AND ed3.id_patient = pp.id_patient
                                 AND ed3.flg_type = pk_diagnosis.g_diag_type_d)))
                       AND NOT EXISTS
                     (SELECT 1
                              FROM pat_history_diagnosis phd
                              LEFT JOIN diagnosis d2
                                ON d2.id_diagnosis = phd.id_diagnosis
                             WHERE phd.id_patient = pp.id_patient
                               AND phd.flg_type = pk_problems.g_flg_type_med
                               AND nvl(d2.flg_other, pk_alert_constant.g_no) <> pk_alert_constant.g_yes
                               AND phd.id_diagnosis = pp.id_diagnosis
                               AND phd.id_pat_history_diagnosis =
                                   pk_problems.get_most_recent_phd_id(phd.id_pat_history_diagnosis)
                               AND pp.dt_pat_problem_tstz < phd.dt_pat_history_diagnosis_tstz
                               AND phd.flg_area IN
                                   (pk_alert_constant.g_diag_area_problems, pk_alert_constant.g_diag_area_not_defined)
                               AND rownum = 1))
        
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_pat_problem;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_problem,
                     pk_prog_notes_constants.g_task_problems_diag,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.year_begin IS NOT NULL AND rec.year_begin <> pk_past_history.g_year_unknown AND
                     (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND rec.day_begin IS NOT NULL THEN
                     to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                  'YYYYMMDD') ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pp,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_pat_problem;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (rec.id_pat_problem,
                     pk_prog_notes_constants.g_task_problems_diag,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     CASE WHEN rec.year_begin IS NOT NULL AND rec.year_begin <> pk_past_history.g_year_unknown AND
                     (rec.month_begin IS NOT NULL AND rec.month_begin <> 0) AND rec.day_begin IS NOT NULL THEN
                     to_timestamp(rec.year_begin || lpad(rec.month_begin, 2, '0') || lpad(rec.day_begin, 2, '0'),
                                  'YYYYMMDD') ELSE NULL END,
                     NULL,
                     rec.flg_status,
                     pk_prog_notes_constants.g_tl_table_name_pp,
                     pk_alert_constant.g_tl_oriented_patient,
                     current_timestamp,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems_diag
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_diag_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_diag_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_diag_ea',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_diag_ea',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'admin_task_tl_prob_diag_ea',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_prob_diag_ea;

    /********************************************************************************************
    * Update intake and output tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Nuno Neves
    * @version  2.6.2
    * @since    2012/059/14
    ********************************************************************************************/
    FUNCTION admin_task_tl_nurse_tea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_NURSE_TEA';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'NURSE_TEA_REQ';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_nurse_tea IS
            SELECT ntr.id_nurse_tea_req,
                   ntr.id_patient,
                   ntr.id_episode,
                   ntr.id_visit,
                   e.id_institution,
                   ntr.dt_nurse_tea_req_tstz dt_creation_tstz,
                   ntr.id_prof_req id_professional,
                   ntr.dt_begin_tstz dt_initial_tstz,
                   ntr.dt_close_tstz dt_end_tstz,
                   ntr.flg_status,
                   CASE
                        WHEN ntr.flg_status IN (pk_patient_education_constant.g_nurse_tea_req_act,
                                                pk_patient_education_constant.g_nurse_tea_req_pend) THEN
                         pk_ea_logic_tasktimeline.g_flg_not_outdated --active
                        ELSE
                         pk_ea_logic_tasktimeline.g_flg_outdated
                    END flg_outdated,
                   CASE
                        WHEN ntr.flg_status IN (pk_patient_education_constant.g_nurse_tea_req_fin,
                                                pk_patient_education_constant.g_nurse_tea_req_expired) THEN
                         pk_prog_notes_constants.g_task_finalized_f
                        ELSE
                         pk_prog_notes_constants.g_task_ongoing_o
                    END flg_ongoing,
                   e.flg_status flg_status_epis,
                   coalesce(ntr.dt_close_tstz, ntr.dt_begin_tstz, ntr.dt_nurse_tea_req_tstz) dt_last_update
              FROM nurse_tea_req ntr
              JOIN episode e
                ON ntr.id_episode = e.id_episode
             WHERE (ntr.id_patient = i_patient OR i_patient IS NULL)
               AND (ntr.id_episode = i_episode OR i_episode IS NULL)
               AND (e.id_institution = i_institution OR i_institution IS NULL)
               AND (ntr.dt_begin_tstz >= i_start_dt OR i_start_dt IS NULL)
               AND (ntr.dt_begin_tstz <= i_end_dt OR i_end_dt IS NULL) --
               AND ntr.flg_status NOT IN
                   (pk_patient_education_constant.g_nurse_tea_req_draft,
                    pk_patient_education_constant.g_nurse_tea_req_ign,
                    pk_patient_education_constant.g_nurse_tea_req_sug,
                    pk_patient_education_constant.g_nurse_tea_req_canc,
                    pk_patient_education_constant.g_nurse_tea_req_not_ord_reas);
    
        TYPE t_coll_nurse_tea IS TABLE OF c_nurse_tea%ROWTYPE;
        l_nurse_tea_rows t_coll_nurse_tea;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_pat_education',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_pat_education))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_nurse_tea;
        LOOP
        
            -- get notes data
            FETCH c_nurse_tea BULK COLLECT
                INTO l_nurse_tea_rows LIMIT l_limit;
        
            IF l_nurse_tea_rows IS NOT NULL
               AND l_nurse_tea_rows.count > 0
            THEN
            
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_pat_education;
                l_ea_row.table_name        := l_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_nurse_tea_rows.first .. l_nurse_tea_rows.last
                LOOP
                    l_ea_row.id_task_refid  := l_nurse_tea_rows(i).id_nurse_tea_req;
                    l_ea_row.id_patient     := l_nurse_tea_rows(i).id_patient;
                    l_ea_row.id_episode     := l_nurse_tea_rows(i).id_episode;
                    l_ea_row.id_visit       := l_nurse_tea_rows(i).id_visit;
                    l_ea_row.id_institution := l_nurse_tea_rows(i).id_institution;
                    l_ea_row.dt_req         := l_nurse_tea_rows(i).dt_creation_tstz;
                    l_ea_row.id_prof_req    := l_nurse_tea_rows(i).id_professional;
                    l_ea_row.dt_begin       := l_nurse_tea_rows(i).dt_initial_tstz;
                    l_ea_row.dt_end         := l_nurse_tea_rows(i).dt_end_tstz;
                    l_ea_row.flg_status_req := l_nurse_tea_rows(i).flg_status;
                    l_ea_row.flg_outdated   := l_nurse_tea_rows(i).flg_outdated;
                    --l_ea_row.id_group_import   := l_hidric_rows(i).id_hidrics_type;
                    --l_ea_row.code_desc_group   := l_hidric_rows(i).code_hidrics_type;
                    l_ea_row.flg_ongoing := l_nurse_tea_rows(i).flg_ongoing;
                    --l_ea_row.dt_last_execution := l_hidric_rows(i).dt_last_execution;
                    l_ea_row.dt_last_update := l_nurse_tea_rows(i).dt_last_update;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             --id_group_import,
                             --code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             --dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             --l_ea_rows(i).id_group_import,
                             --l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             --l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_nurse_tea%NOTFOUND;
        END LOOP;
    
        CLOSE c_nurse_tea;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)))
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_pat_education
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       --tt_ea.id_group_import   = t.id_group_import,
                       --tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos          = t.flg_sos,
                       tt_ea.flg_ongoing      = t.flg_ongoing,
                       tt_ea.flg_normal       = t.flg_normal,
                       tt_ea.flg_has_comments = t.flg_has_comments,
                       --tt_ea.dt_last_execution = t.dt_last_execution,
                       tt_ea.dt_last_update = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     --id_group_import,
                     --code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     --dt_last_execution,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     --t.id_group_import,
                     --t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     --t.dt_last_execution,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_nurse_tea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with procedure tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Nuno Neves
    * @version  2.6.3
    * @since    2012/11/19
    ********************************************************************************************/
    FUNCTION admin_task_tl_interv_p_plan
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_INTERV_P_PLAN';
    
        l_count         NUMBER := 0;
        l_count_invalid NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_flg_outdated      task_timeline_ea.flg_outdated%TYPE := 1;
        l_flg_sos           task_timeline_ea.flg_sos%TYPE;
        l_table_name        VARCHAR(30) := 'INTERV_PRESC_PLAN';
        l_flg_has_comments  VARCHAR2(1 CHAR);
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline interv_presc_plan TASKS ONLY',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_procedures_exec)) -- interv_presc_plan TASKS ONLY
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT ipp.id_interv_presc_plan id_task_refid,
                           ipp.start_time dt_begin,
                           ipp.end_time dt_end,
                           ipp.flg_status flg_status_req,
                           ipp.id_prof_take id_prof_exec,
                           i.code_intervention code_description,
                           v.id_visit,
                           ip.id_episode,
                           v.id_patient,
                           ip.id_institution,
                           ipd.id_interv_presc_det,
                           ipp.id_epis_documentation,
                           ipp.notes universal_desc_clob,
                           decode(ipp.flg_status,
                                  pk_procedures_constant.g_interv_plan_pending,
                                  pk_prog_notes_constants.g_task_ongoing_o,
                                  pk_procedures_constant.g_interv_req,
                                  pk_prog_notes_constants.g_task_ongoing_o,
                                  pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                           pk_alert_constant.g_yes flg_normal,
                           nvl((SELECT MAX(ea.dt_dg_last_update)
                                 FROM procedures_ea ea
                                WHERE ea.id_interv_presc_det = ipd.id_interv_presc_det),
                               ip.dt_interv_prescription_tstz) dt_last_update,
                           'INTERV_PRESC_PLAN.FLG_STATUS' code_status,
                           ipd.flg_prn,
                           ipp.dt_interv_presc_plan,
                           coalesce(ipp.dt_plan_tstz, ipd.dt_interv_presc_det) dt_plan_tstz
                      FROM interv_presc_det    ipd,
                           interv_prescription ip,
                           intervention        i,
                           spec_sys_appar      ssa,
                           interv_presc_plan   ipp,
                           visit               v,
                           episode             e,
                           episode             ep_origin
                     WHERE ip.id_interv_prescription = ipd.id_interv_prescription
                       AND ipd.id_intervention = i.id_intervention
                       AND i.id_spec_sys_appar = ssa.id_spec_sys_appar(+)
                       AND ipp.id_interv_presc_det = ipd.id_interv_presc_det
                       AND ip.id_episode = e.id_episode(+)
                       AND ip.id_episode_origin = ep_origin.id_episode(+)
                       AND e.id_visit = v.id_visit
                       AND ((i_patient IS NOT NULL AND e.id_patient = i_patient) OR i_patient IS NULL)
                       AND ((i_episode IS NOT NULL AND e.id_episode = i_episode) OR i_episode IS NULL)
                       AND ((i_institution IS NOT NULL AND e.id_institution = i_institution) OR i_institution IS NULL)
                       AND ipp.flg_status IN (pk_procedures_constant.g_interv_plan_executed,
                                              pk_procedures_constant.g_interv_plan_not_executed,
                                              pk_procedures_constant.g_interv_plan_req,
                                              pk_procedures_constant.g_interv_plan_pending))
        LOOP
            --check if it has comments
            BEGIN
                SELECT pk_alert_constant.g_yes
                  INTO l_flg_has_comments
                  FROM treatment_management tm
                 WHERE tm.id_treatment = rec.id_interv_presc_det
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_flg_has_comments := pk_alert_constant.g_no;
            END;
        
            IF rec.flg_prn = pk_alert_constant.g_yes
            THEN
                l_flg_sos := pk_alert_constant.g_yes;
            ELSE
                l_flg_sos := pk_alert_constant.g_no;
            END IF;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_dg_last_update,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     code_description,
                     universal_desc_clob,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     dt_last_update,
                     flg_outdated,
                     id_ref_group,
                     code_status,
                     id_task_notes,
                     flg_sos,
                     flg_has_comments)
                VALUES
                    (rec.id_task_refid,
                     pk_prog_notes_constants.g_task_procedures_exec,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     l_current_timestamp,
                     nvl(rec.dt_plan_tstz, l_current_timestamp),
                     rec.id_prof_exec,
                     rec.dt_begin,
                     rec.dt_end,
                     rec.flg_status_req,
                     l_table_name,
                     pk_alert_constant.g_tl_oriented_visit,
                     rec.code_description,
                     rec.universal_desc_clob,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.dt_last_update,
                     l_flg_outdated,
                     rec.id_interv_presc_det,
                     rec.code_status,
                     rec.id_epis_documentation,
                     l_flg_sos,
                     l_flg_has_comments);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_dg_last_update,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     code_description,
                     universal_desc_clob,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     dt_last_update,
                     flg_outdated,
                     id_ref_group,
                     code_status,
                     id_task_notes,
                     flg_sos,
                     flg_has_comments)
                VALUES
                    (rec.id_task_refid,
                     pk_prog_notes_constants.g_task_procedures_exec,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     l_current_timestamp,
                     nvl(rec.dt_plan_tstz, l_current_timestamp),
                     rec.id_prof_exec,
                     rec.dt_begin,
                     rec.dt_end,
                     rec.flg_status_req,
                     l_table_name,
                     pk_alert_constant.g_tl_oriented_visit,
                     rec.code_description,
                     rec.universal_desc_clob,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.dt_last_update,
                     l_flg_outdated,
                     rec.id_interv_presc_det,
                     rec.code_status,
                     rec.id_epis_documentation,
                     l_flg_sos,
                     l_flg_has_comments);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                (dbms_lob.compare(a.universal_desc_clob, b.universal_desc_clob) <> 0 OR
                                (a.universal_desc_clob IS NULL AND b.universal_desc_clob IS NOT NULL) OR
                                (a.universal_desc_clob IS NOT NULL AND b.universal_desc_clob IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                                --
                                (a.code_status <> b.code_status OR
                                (a.code_status IS NULL AND b.code_status IS NOT NULL) OR
                                (a.code_status IS NOT NULL AND b.code_status IS NULL)) OR
                                --
                                (a.id_task_notes <> b.id_task_notes OR
                                (a.id_task_notes IS NULL AND b.id_task_notes IS NOT NULL) OR
                                (a.id_task_notes IS NOT NULL AND b.id_task_notes IS NULL)) OR
                                --
                                (a.table_name <> b.table_name OR (a.table_name IS NULL AND b.table_name IS NOT NULL) OR
                                (a.table_name IS NOT NULL AND b.table_name IS NULL)) OR
                                --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL))))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_procedures_exec
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient          = t.id_patient,
                       tt_ea.id_episode          = t.id_episode,
                       tt_ea.id_visit            = t.id_visit,
                       tt_ea.id_institution      = t.id_institution,
                       tt_ea.dt_dg_last_update   = t.dt_dg_last_update,
                       tt_ea.dt_req              = t.dt_req,
                       tt_ea.id_prof_req         = t.id_prof_req,
                       tt_ea.dt_begin            = t.dt_begin,
                       tt_ea.dt_end              = t.dt_end,
                       tt_ea.flg_status_req      = t.flg_status_req,
                       tt_ea.table_name          = t.table_name,
                       tt_ea.flg_show_method     = t.flg_show_method,
                       tt_ea.code_description    = t.code_description,
                       tt_ea.universal_desc_clob = t.universal_desc_clob,
                       tt_ea.flg_ongoing         = t.flg_ongoing,
                       tt_ea.flg_normal          = t.flg_normal,
                       tt_ea.id_prof_exec        = t.id_prof_exec,
                       tt_ea.dt_last_update      = t.dt_last_update,
                       tt_ea.flg_outdated        = t.flg_outdated,
                       tt_ea.id_ref_group        = t.id_ref_group,
                       tt_ea.code_status         = t.code_status,
                       tt_ea.id_task_notes       = t.id_task_notes,
                       tt_ea.flg_sos             = t.flg_sos,
                       tt_ea.flg_has_comments    = t.flg_has_comments
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_dg_last_update,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     code_description,
                     universal_desc_clob,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     dt_last_update,
                     flg_outdated,
                     id_ref_group,
                     code_status,
                     id_task_notes,
                     flg_sos,
                     flg_has_comments)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_dg_last_update,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.code_description,
                     t.universal_desc_clob,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.dt_last_update,
                     t.flg_outdated,
                     t.id_ref_group,
                     t.code_status,
                     t.id_task_notes,
                     t.flg_sos,
                     t.flg_has_comments);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_proced_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_proced_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INTERV_P_PLAN',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INTERV_P_PLAN',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_INTERV_P_PLAN',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_interv_p_plan;

    /********************************************************************************************
    * Update tasks in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Paulo teixeira
    * @version  2.6.3
    * @since    2013/05/13
    ********************************************************************************************/
    FUNCTION admin_task_tl_mtos_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_MTOS_EA';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_mtos IS
            SELECT id_epis_mtos_score,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_request,
                   dt_req,
                   id_institution,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   id_software,
                   id_mtos_score,
                   id_parent
              FROM (SELECT ems.id_epis_mtos_score id_epis_mtos_score,
                           epi.id_patient id_patient,
                           ems.id_episode id_episode,
                           ems.flg_status flg_status,
                           ems.id_prof_create id_prof_request,
                           ems.dt_create dt_req,
                           epi.id_institution id_institution,
                           epi.id_visit id_visit,
                           pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated,
                           decode(ems.id_mtos_score,
                                  pk_sev_scores_constant.g_id_score_isstw,
                                  pk_prog_notes_constants.g_task_ongoing_o,
                                  pk_prog_notes_constants.g_task_finalized_f) flg_ongoing,
                           ei.id_software,
                           ems.id_mtos_score,
                           ems.id_epis_mtos_score_parent id_parent
                      FROM epis_mtos_score ems
                      JOIN episode epi
                        ON epi.id_episode = ems.id_episode
                       AND epi.flg_status <> pk_alert_constant.g_epis_status_cancel
                      LEFT JOIN epis_info ei
                        ON epi.id_episode = ei.id_episode
                     WHERE ems.flg_status IN (pk_sev_scores_constant.g_flg_status_a)
                       AND (epi.id_patient = i_patient OR i_patient IS NULL)
                       AND (ems.id_episode = i_episode OR i_episode IS NULL)
                       AND (epi.id_institution = i_institution OR i_institution IS NULL)
                       AND (ems.dt_create >= i_start_dt OR i_start_dt IS NULL)
                       AND (ems.dt_create <= i_end_dt OR i_end_dt IS NULL));
    
        TYPE t_coll_mtos IS TABLE OF c_mtos%ROWTYPE;
        l_mtos_rows t_coll_mtos;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_mtos_score',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_mtos_score))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_mtos;
        LOOP
            -- get g_task data
            FETCH c_mtos BULK COLLECT
                INTO l_mtos_rows LIMIT l_limit;
        
            IF l_mtos_rows IS NOT NULL
               AND l_mtos_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_mtos_score;
                l_ea_row.table_name        := 'EPIS_MTOS_SCORE';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_mtos_rows.first .. l_mtos_rows.last
                LOOP
                    l_ea_row.id_task_refid        := l_mtos_rows(i).id_epis_mtos_score;
                    l_ea_row.dt_begin             := l_mtos_rows(i).dt_req;
                    l_ea_row.flg_status_req       := l_mtos_rows(i).flg_status;
                    l_ea_row.id_prof_req          := l_mtos_rows(i).id_prof_request;
                    l_ea_row.dt_req               := l_mtos_rows(i).dt_req;
                    l_ea_row.id_patient           := l_mtos_rows(i).id_patient;
                    l_ea_row.id_episode           := l_mtos_rows(i).id_episode;
                    l_ea_row.id_visit             := l_mtos_rows(i).id_visit;
                    l_ea_row.id_institution       := l_mtos_rows(i).id_institution;
                    l_ea_row.flg_outdated         := l_mtos_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing          := l_mtos_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update       := l_mtos_rows(i).dt_req;
                    l_ea_row.id_group_import      := pk_ea_logic_mtos.mtos_score_has_parent(i_id_mtos_score => l_mtos_rows(i).id_mtos_score);
                    l_ea_row.id_parent_task_refid := l_mtos_rows(i).id_parent;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             dt_last_update,
                             id_group_import,
                             id_parent_task_refid)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_update,
                             l_ea_rows(i).id_group_import,
                             l_mtos_rows(i).id_parent);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_mtos%NOTFOUND;
        END LOOP;
    
        CLOSE c_mtos;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.id_parent_task_refid <> b.id_parent_task_refid OR
                                (a.id_parent_task_refid IS NULL AND b.id_parent_task_refid IS NOT NULL) OR
                                (a.id_parent_task_refid IS NOT NULL AND b.id_parent_task_refid IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_mtos_score
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.dt_begin             = t.dt_begin,
                       tt_ea.dt_end               = t.dt_end,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = t.dt_dg_last_update,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.rank                 = t.rank,
                       tt_ea.flg_sos              = t.flg_sos,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update,
                       tt_ea.id_group_import      = t.id_group_import,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_group_import,
                     id_parent_task_refid)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_group_import,
                     t.id_parent_task_refid);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_mtos_ea;

    /********************************************************************************************
    * Update triage records in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Sofia Mendes
    * @version  2.6.3
    * @since    30-Apr-2013
    ********************************************************************************************/
    FUNCTION admin_task_tl_triage
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_TRIAGE';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        TYPE t_coll_triage IS TABLE OF pk_ea_logic_triage.c_triage%ROWTYPE;
        l_triage_rows t_coll_triage;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_triage',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_triage))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN pk_ea_logic_triage.c_triage(i_rowids      => NULL,
                                         i_patient     => i_patient,
                                         i_episode     => i_episode,
                                         i_institution => i_institution,
                                         i_start_dt    => i_start_dt,
                                         i_end_dt      => i_end_dt);
        LOOP
        
            -- get triage data
            FETCH pk_ea_logic_triage.c_triage BULK COLLECT
                INTO l_triage_rows LIMIT l_limit;
        
            IF l_triage_rows IS NOT NULL
               AND l_triage_rows.count > 0
            THEN
            
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_triage;
                l_ea_row.table_name        := pk_ea_logic_triage.g_triage_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_triage_rows.first .. l_triage_rows.last
                LOOP
                    l_ea_row.id_task_refid     := l_triage_rows(i).id_epis_triage;
                    l_ea_row.id_patient        := l_triage_rows(i).id_patient;
                    l_ea_row.id_episode        := l_triage_rows(i).id_episode;
                    l_ea_row.id_visit          := l_triage_rows(i).id_visit;
                    l_ea_row.id_institution    := l_triage_rows(i).id_institution;
                    l_ea_row.dt_req            := l_triage_rows(i).dt_begin_tstz;
                    l_ea_row.id_prof_req       := l_triage_rows(i).id_professional;
                    l_ea_row.dt_begin          := l_triage_rows(i).dt_begin_tstz;
                    l_ea_row.dt_end            := l_triage_rows(i).dt_end_tstz;
                    l_ea_row.flg_status_req    := pk_alert_constant.g_active;
                    l_ea_row.flg_outdated      := pk_ea_logic_tasktimeline.g_flg_not_outdated;
                    l_ea_row.id_group_import   := NULL;
                    l_ea_row.code_desc_group   := NULL;
                    l_ea_row.flg_ongoing       := pk_prog_notes_constants.g_task_ongoing_o;
                    l_ea_row.dt_last_execution := NULL;
                    l_ea_row.dt_last_update    := l_triage_rows(i).dt_last_update;
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             id_group_import,
                             code_desc_group,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_execution,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).id_group_import,
                             l_ea_rows(i).code_desc_group,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_execution,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN pk_ea_logic_triage.c_triage%NOTFOUND;
        END LOOP;
    
        CLOSE pk_ea_logic_triage.c_triage;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.id_group_import <> b.id_group_import OR
                                (a.id_group_import IS NULL AND b.id_group_import IS NOT NULL) OR
                                (a.id_group_import IS NOT NULL AND b.id_group_import IS NULL)) OR
                               --
                                (a.code_desc_group <> b.code_desc_group OR
                                (a.code_desc_group IS NULL AND b.code_desc_group IS NOT NULL) OR
                                (a.code_desc_group IS NOT NULL AND b.code_desc_group IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_execution <> b.dt_last_execution OR
                                (a.dt_last_execution IS NULL AND b.dt_last_execution IS NOT NULL) OR
                                (a.dt_last_execution IS NOT NULL AND b.dt_last_execution IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_triage
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.id_group_import   = t.id_group_import,
                       tt_ea.code_desc_group   = t.code_desc_group,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     id_group_import,
                     code_desc_group,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.id_group_import,
                     t.code_desc_group,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_triage;

    /********************************************************************************************    
    * Update Easy Access table TASK_TIMELINE_EA with communication orders info
      *
      * @param i_patient                Patient identifier
      * @param i_episode                Episode identifier
      * @value i_schedule               Shcedule identifier
      * @param i_external_request       P1 (referral) identifier
      * @param i_institution            Institution identifier
      * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
      * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
      * @param i_validate_table         Indicates necessary to validate data existent in easy access table
      * @param i_output_invalid_records Show final (resumed) information about updated statistics
      * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
      * @param i_commit_step            Number of registries between commit's
      *
      * @return  TRUE if sucess, FALSE otherwise
      *
      * @author   Ana Monteiro
      * @version  2.6.3
      * @since    2014/03/06
      ********************************************************************************************/
    FUNCTION admin_task_tl_comm_orders
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'admin_task_tl_comm_orders';
        l_src_table CONSTANT VARCHAR2(30 CHAR) := 'COMM_ORDER_REQ';
        l_count_invalid PLS_INTEGER := 0;
        l_count         PLS_INTEGER := 0;
        l_limit         PLS_INTEGER;
        l_ea_row        task_timeline_ea%ROWTYPE;
        l_ea_rows       ts_task_timeline_ea.task_timeline_ea_tc;
        l_error         t_error_out;
    
        CURSOR c_comm_order_r IS
            SELECT cor.id_comm_order_req,
                   cor.id_patient,
                   cor.id_episode,
                   e.id_visit,
                   cor.id_institution,
                   cor.dt_req,
                   cor.id_prof_req,
                   cor.dt_begin,
                   cor.id_status,
                   cor.dt_status,
                   CASE --dt_end
                        WHEN cor.id_status = pk_comm_orders.g_id_sts_completed THEN
                         cor.dt_status
                        ELSE
                         NULL
                    END dt_end, -- todo: confirmar                   
                   CASE --flg_outdated
                        WHEN cor.id_status = pk_comm_orders.g_id_sts_ongoing THEN
                         pk_ea_logic_tasktimeline.g_flg_not_outdated --active                        
                        ELSE
                         pk_ea_logic_tasktimeline.g_flg_outdated
                    END flg_outdated, -- todo: confirmar                   
                   CASE --flg_ongoing
                        WHEN cor.id_status = pk_comm_orders.g_id_sts_completed THEN
                         pk_prog_notes_constants.g_task_finalized_f
                        ELSE
                         pk_prog_notes_constants.g_task_ongoing_o
                    END flg_ongoing, -- todo: confirmar
                   e.flg_status flg_status_epis
              FROM comm_order_req cor
              JOIN episode e
                ON cor.id_episode = e.id_episode
             WHERE (cor.id_patient = i_patient OR i_patient IS NULL)
               AND (cor.id_episode = i_episode OR i_episode IS NULL)
               AND (e.id_institution = i_institution OR i_institution IS NULL)
               AND (cor.dt_begin >= i_start_dt OR i_start_dt IS NULL)
               AND (cor.dt_begin <= i_end_dt OR i_end_dt IS NULL) --
               AND cor.id_status NOT IN (pk_comm_orders.g_id_sts_predf, pk_comm_orders.g_id_sts_draft); -- todo: confirmar      
    
        TYPE t_coll_comm_order_r IS TABLE OF c_comm_order_r%ROWTYPE;
        l_comm_order_r_rows t_coll_comm_order_r;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_communications',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_communications))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        OPEN c_comm_order_r;
        LOOP
        
            -- get data
            FETCH c_comm_order_r BULK COLLECT
                INTO l_comm_order_r_rows LIMIT l_limit;
        
            IF l_comm_order_r_rows IS NOT NULL
               AND l_comm_order_r_rows.count > 0
            THEN
            
                -- set constant fields
                l_ea_row.id_tl_task        := pk_prog_notes_constants.g_task_communications;
                l_ea_row.table_name        := l_src_table;
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN 1 .. l_comm_order_r_rows.count
                LOOP
                    l_ea_row.id_task_refid := l_comm_order_r_rows(i).id_comm_order_req;
                
                    l_ea_row.id_patient     := l_comm_order_r_rows(i).id_patient;
                    l_ea_row.id_episode     := l_comm_order_r_rows(i).id_episode;
                    l_ea_row.id_visit       := l_comm_order_r_rows(i).id_visit;
                    l_ea_row.id_institution := l_comm_order_r_rows(i).id_institution;
                    l_ea_row.dt_req         := l_comm_order_r_rows(i).dt_req;
                    l_ea_row.id_prof_req    := l_comm_order_r_rows(i).id_prof_req;
                    l_ea_row.dt_begin       := l_comm_order_r_rows(i).dt_begin;
                    l_ea_row.dt_end         := l_comm_order_r_rows(i).dt_end;
                    l_ea_row.flg_status_req := l_comm_order_r_rows(i).id_status;
                    l_ea_row.flg_outdated   := l_comm_order_r_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing    := l_comm_order_r_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update := l_comm_order_r_rows(i).dt_status;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN 1 .. l_ea_rows.count
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             flg_has_comments,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_comm_order_r%NOTFOUND;
        END LOOP;
    
        CLOSE c_comm_order_r;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT NULL
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT NULL
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_communications -- todo: rever
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_comm_orders;

    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Plan's tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          21-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_epis_reason_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(40 CHAR) := 'ADMIN_TASK_TL_EPIS_REASON_EA';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_epis_status_cancel     CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_tl_table_name_recomend CONSTANT VARCHAR2(1000 CHAR) := 'PN_EPIS_REASON';
        l_tl_oriented_episode    CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_chief_complaint_out))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     per.id_pn_epis_reason id_task_refid,
                     epis.id_patient,
                     epis.id_episode,
                     epis.id_visit,
                     epis.id_institution,
                     nvl(ec.adw_last_update_tstz, ea.dt_epis_anamnesis_tstz) dt_req,
                     nvl(ec.id_professional, ea.id_professional) id_prof_req,
                     CASE
                          WHEN per.flg_status = pk_alert_constant.g_active THEN
                           pk_ea_logic_tasktimeline.g_flg_not_outdated
                          ELSE
                           pk_ea_logic_tasktimeline.g_flg_outdated
                      END flg_outdated,
                     per.flg_status flg_status_req,
                     epis.flg_status flg_status_epis,
                     pk_prog_notes_constants.g_task_chief_complaint_out id_tl_task,
                     'PN_EPIS_REASON' table_name,
                     pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments,
                     per.id_parent id_parent_task_refid
                      FROM pn_epis_reason per
                      JOIN episode epis
                        ON per.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                      LEFT JOIN epis_complaint ec
                        ON ec.id_epis_complaint = per.id_epis_complaint
                      LEFT JOIN epis_anamnesis ea
                        ON ea.id_epis_anamnesis = per.id_epis_anamnesis
                     WHERE nvl(ec.adw_last_update_tstz, ea.dt_epis_anamnesis_tstz) >=
                           nvl(i_start_dt, nvl(ec.adw_last_update_tstz, ea.dt_epis_anamnesis_tstz))
                       AND nvl(ec.adw_last_update_tstz, ea.dt_epis_anamnesis_tstz) <=
                           nvl(i_end_dt, nvl(ec.adw_last_update_tstz, ea.dt_epis_anamnesis_tstz))
                       AND per.flg_status = pk_alert_constant.g_active)
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_parent_task_refid)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_parent_task_refid);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_parent_task_refid)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_parent_task_refid);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_chief_complaint_out)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('ADMIN_TASK_TL_EPIS_REASON_EA - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('ADMIN_TASK_TL_EPIS_REASON_EA - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_EPIS_REASON_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_EPIS_REASON_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_EPIS_REASON_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_epis_reason_ea;
    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with Plan's tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         António Neto
    * @version                        2.6.2
    * @since                          21-Mar-2012
    ********************************************************************************************/
    FUNCTION admin_task_tl_er_law_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(40 CHAR) := 'ADMIN_TASK_TL_ER_LAW_EA';
    
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
    
        l_epis_status_cancel     CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_epis_status_cancel;
        l_tl_table_name_recomend CONSTANT VARCHAR2(1000 CHAR) := 'EPIS_ER_LAW';
        l_tl_oriented_episode    CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
        
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_emergency_law))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     eel.id_epis_er_law id_task_refid,
                     epis.id_patient,
                     epis.id_episode,
                     epis.id_visit,
                     epis.id_institution,
                     eel.dt_create dt_req,
                     eel.id_prof_create id_prof_req,
                     CASE
                          WHEN eel.id_cancel_reason IS NULL THEN
                           pk_ea_logic_tasktimeline.g_flg_not_outdated
                          ELSE
                           pk_ea_logic_tasktimeline.g_flg_outdated
                      END flg_outdated,
                     eel.flg_er_law_status flg_status_req,
                     epis.flg_status flg_status_epis,
                     pk_prog_notes_constants.g_task_emergency_law id_tl_task,
                     'EPIS_ER_LAW' table_name,
                     pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     pk_alert_constant.g_no flg_has_comments
                      FROM epis_er_law eel
                      JOIN episode epis
                        ON eel.id_episode = epis.id_episode
                       AND epis.flg_status <> l_epis_status_cancel
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = epis.id_episode
                     WHERE eel.dt_create >= nvl(i_start_dt, eel.dt_create)
                       AND eel.dt_create <= nvl(i_end_dt, eel.dt_create)
                       AND eel.id_cancel_reason IS NULL)
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_emergency_law)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_er_law_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_er_law_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_ER_LAW_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_ER_LAW_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_ER_LAW_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_er_law_ea;
    --
    /********************************************************************************************
    * Updates Easy Access table TASK_TIMELINE_EA with body diagram's tasks
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Schedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         Paulo Teixeira
    * @version                        2.6.5
    * @since                          05-Jul-2016
    ********************************************************************************************/
    FUNCTION admin_task_tl_body_diagram_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(40 CHAR) := 'ADMIN_TASK_TL_BODY_DIAGRAM_EA';
        l_count             NUMBER := 0;
        l_count_invalid     NUMBER := 0;
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_tl_oriented_episode CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_tl_oriented_episode;
        l_error t_error_out;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_body_diagram))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        FOR rec IN (SELECT *
                      FROM (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                             ed.id_epis_diagram id_task_refid,
                             epis.id_patient,
                             epis.id_episode,
                             epis.id_visit,
                             epis.id_institution,
                             edl.dt_creation_tstz dt_req,
                             edl.id_professional id_prof_req,
                             pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated,
                             edl.flg_status flg_status_req,
                             epis.flg_status flg_status_epis,
                             pk_prog_notes_constants.g_task_body_diagram id_tl_task,
                             'EPIS_DIAGRAM' table_name,
                             pk_prog_notes_constants.g_task_ongoing_o flg_ongoing,
                             pk_alert_constant.g_yes flg_normal,
                             NULL id_prof_exec,
                             pk_alert_constant.g_no flg_has_comments,
                             dl.flg_type,
                             row_number() over(PARTITION BY ed.id_epis_diagram ORDER BY edl.dt_creation_tstz DESC, edl.id_diagram_layout DESC) rn
                              FROM epis_diagram ed
                              JOIN epis_diagram_layout edl
                                ON edl.id_epis_diagram = ed.id_epis_diagram
                               AND edl.flg_status NOT IN
                                   (pk_diagram_new.g_diag_lay_removed, pk_diagram_new.g_diag_lay_cancelled)
                              JOIN diagram_layout dl
                                ON edl.id_diagram_layout = dl.id_diagram_layout
                              JOIN episode epis
                                ON epis.id_episode = ed.id_episode
                              JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                                ON tf_e.id_episode = epis.id_episode
                             WHERE edl.dt_creation_tstz >= nvl(i_start_dt, edl.dt_creation_tstz)
                               AND edl.dt_creation_tstz <= nvl(i_end_dt, edl.dt_creation_tstz)) aux
                     WHERE aux.rn = 1)
        
        LOOP
            IF i_validate_table
            THEN
            
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_type)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.flg_type);
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
            
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_type)
                VALUES
                    (rec.id_task_refid,
                     rec.id_tl_task,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.flg_status_req,
                     rec.table_name,
                     l_tl_oriented_episode, -- EPISODE ORIENTED
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.flg_type);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND (
                                --
                                 (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                 (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                 (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                 (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                 (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                 (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                 (a.id_institution <> b.id_institution OR
                                 (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                 (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                 (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                 (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                 (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                 (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                 (a.flg_status_req <> b.flg_status_req OR
                                 (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                 (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                 (a.code_description <> b.code_description OR
                                 (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                 (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                                --
                                 (a.flg_show_method <> b.flg_show_method OR
                                 (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                 (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                                --
                                 (a.flg_outdated <> b.flg_outdated OR
                                 (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                 (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                 (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                 (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                 (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                 (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                 (a.id_prof_exec <> b.id_prof_exec OR
                                 (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                 (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                 (a.flg_has_comments <> b.flg_has_comments OR
                                 (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                 (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                 (a.dt_last_update <> b.dt_last_update OR
                                 (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                 (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_body_diagram)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient           = t.id_patient,
                       tt_ea.id_episode           = t.id_episode,
                       tt_ea.id_visit             = t.id_visit,
                       tt_ea.id_institution       = t.id_institution,
                       tt_ea.dt_req               = t.dt_req,
                       tt_ea.id_prof_req          = t.id_prof_req,
                       tt_ea.flg_status_req       = t.flg_status_req,
                       tt_ea.code_description     = t.code_description,
                       tt_ea.flg_show_method      = t.flg_show_method,
                       tt_ea.dt_dg_last_update    = l_current_timestamp,
                       tt_ea.flg_outdated         = t.flg_outdated,
                       tt_ea.universal_desc_clob  = t.universal_desc_clob,
                       tt_ea.id_parent_task_refid = t.id_parent_task_refid,
                       tt_ea.flg_ongoing          = t.flg_ongoing,
                       tt_ea.flg_normal           = t.flg_normal,
                       tt_ea.id_prof_exec         = t.id_prof_exec,
                       tt_ea.flg_has_comments     = t.flg_has_comments,
                       tt_ea.dt_last_update       = t.dt_last_update,
                       tt_ea.flg_type             = t.flg_type
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     code_description,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     universal_desc_clob,
                     id_parent_task_refid,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     flg_type)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.flg_status_req,
                     t.code_description,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.universal_desc_clob,
                     t.id_parent_task_refid,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.flg_type);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = 'TASK_TIMELINE_EA'
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_body_diagram_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_body_diagram_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_body_diagram_ea;
    --
    PROCEDURE grid_task_positioning IS
    BEGIN
        pk_ea_logic_positioning.ins_grid_task_positionings(i_lang => g_log_lang, i_prof => NULL, i_rowids => NULL);
    END grid_task_positioning;
    --
    PROCEDURE grid_task_monitorizations IS
    BEGIN
        pk_ea_logic_monitorizations.ins_grid_task_monitorizations(i_lang   => g_log_lang,
                                                                  i_prof   => NULL,
                                                                  i_rowids => NULL);
    END grid_task_monitorizations;
    ---
    PROCEDURE grid_task_movements IS
    BEGIN
        pk_logic_movements.ins_grid_task_movements(i_lang => g_log_lang, i_prof => NULL, i_rowids => NULL);
    END grid_task_movements;
    --
    PROCEDURE grid_task_hidrics IS
    BEGIN
        pk_ea_logic_hidrics.ins_grid_task_hidrics(i_lang => g_log_lang, i_prof => NULL, i_rowids => NULL);
    END grid_task_hidrics;
    --
    PROCEDURE grid_task_discharge_pend IS
    BEGIN
        pk_ea_logic_discharge.ins_grid_task_discharge_pend(i_lang => g_log_lang, i_prof => NULL, i_rowids => NULL);
    END grid_task_discharge_pend;

    /********************************************************************************************
    * Update referrals task in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Elisabete Bugalho
    * @version  2.7.1.
    * @since    2017/06/26
    ********************************************************************************************/
    FUNCTION admin_task_tl_ref_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_REF_EA';
        l_count_invalid     PLS_INTEGER := 0;
        l_count             PLS_INTEGER := 0;
        l_limit             PLS_INTEGER;
        l_ea_row            task_timeline_ea%ROWTYPE;
        l_ea_rows           ts_task_timeline_ea.task_timeline_ea_tc;
        l_error             t_error_out;
        l_nutrition_content VARCHAR2(200 CHAR) := 'TMP166.2654';
    
        CURSOR c_ref IS
            SELECT id_external_request,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_requested,
                   dt_requested,
                   id_inst_orig,
                   code_description,
                   dt_last_interaction_tstz,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   id_tl_task,
                   flg_status_epis
              FROM (SELECT p.id_external_request,
                           p.id_patient,
                           p.id_episode,
                           p.flg_status,
                           p.id_prof_requested,
                           p.dt_requested,
                           p.id_inst_orig,
                           CASE
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_a THEN
                                 'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_lab
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_i THEN
                                 'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_img_exams
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_e THEN
                                 'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_other_exams
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_p THEN
                                 'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_proc
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_f THEN
                                 'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_rehab
                                ELSE
                                 CASE
                                     WHEN (SELECT id_content
                                             FROM p1_speciality s
                                            WHERE s.id_speciality = p.id_speciality) = l_nutrition_content THEN
                                      'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral_nutrition
                                     ELSE
                                      'TL_TASK.CODE_TL_TASK.' || pk_prog_notes_constants.g_task_referral
                                 END
                            END code_description,
                           p.id_prof_redirected,
                           e.id_visit id_visit,
                           CASE
                                WHEN p.flg_status IN (pk_ref_constant.g_p1_status_d, pk_ref_constant.g_p1_status_x) THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated
                            END flg_outdated,
                           CASE
                                WHEN p.flg_status IN (pk_ref_constant.g_p1_status_p) THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           CASE
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_a THEN
                                 pk_prog_notes_constants.g_task_referral_lab
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_i THEN
                                 pk_prog_notes_constants.g_task_referral_img_exams
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_e THEN
                                 pk_prog_notes_constants.g_task_referral_other_exams
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_p THEN
                                 pk_prog_notes_constants.g_task_referral_proc
                                WHEN p.flg_type = pk_ref_constant.g_p1_type_f THEN
                                 pk_prog_notes_constants.g_task_referral_rehab
                                ELSE
                                 CASE
                                     WHEN (SELECT id_content
                                             FROM p1_speciality s
                                            WHERE s.id_speciality = p.id_speciality) = l_nutrition_content THEN
                                      pk_prog_notes_constants.g_task_referral_nutrition
                                     ELSE
                                      pk_prog_notes_constants.g_task_referral
                                 END
                            END id_tl_task,
                           e.flg_status flg_status_epis,
                           p.dt_last_interaction_tstz
                      FROM p1_external_request p
                      LEFT JOIN episode e
                        ON p.id_episode = e.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE (e.id_patient = i_patient OR i_patient IS NULL)
                       AND (p.id_episode = i_episode OR i_episode IS NULL)
                       AND (e.id_institution = i_institution OR i_institution IS NULL)
                       AND (p.dt_requested >= i_start_dt OR i_start_dt IS NULL)
                       AND (p.dt_requested <= i_end_dt OR i_end_dt IS NULL)
                       AND p.flg_status <> pk_ref_constant.g_p1_status_c);
    
        TYPE t_coll_ref IS TABLE OF c_ref%ROWTYPE;
        l_ref_rows t_coll_ref;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline 140,141,142,143,144,145',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(140, 141, 142, 143, 144, 145))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        OPEN c_ref;
        LOOP
            -- get g_task_positioning data
            FETCH c_ref BULK COLLECT
                INTO l_ref_rows LIMIT l_limit;
        
            IF l_ref_rows IS NOT NULL
               AND l_ref_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := 'P1_EXTERNAL_REQUEST';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_ref_rows.first .. l_ref_rows.last
                LOOP
                    l_ea_row.id_tl_task       := l_ref_rows(i).id_tl_task;
                    l_ea_row.id_task_refid    := l_ref_rows(i).id_external_request;
                    l_ea_row.dt_begin         := l_ref_rows(i).dt_requested;
                    l_ea_row.flg_status_req   := l_ref_rows(i).flg_status;
                    l_ea_row.id_prof_req      := l_ref_rows(i).id_prof_requested;
                    l_ea_row.dt_req           := l_ref_rows(i).dt_requested;
                    l_ea_row.id_patient       := l_ref_rows(i).id_patient;
                    l_ea_row.id_episode       := l_ref_rows(i).id_episode;
                    l_ea_row.id_visit         := l_ref_rows(i).id_visit;
                    l_ea_row.id_institution   := l_ref_rows(i).id_inst_orig;
                    l_ea_row.code_description := l_ref_rows(i).code_description;
                    l_ea_row.id_prof_exec     := l_ref_rows(i).id_prof_requested;
                    l_ea_row.flg_outdated     := l_ref_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing      := l_ref_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update   := l_ref_rows(i).dt_last_interaction_tstz;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             status_str,
                             status_msg,
                             status_icon,
                             status_flg,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).status_str,
                             l_ea_rows(i).status_msg,
                             l_ea_rows(i).status_icon,
                             l_ea_rows(i).status_flg,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                --COMMIT;
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_ref%NOTFOUND;
        END LOOP;
    
        CLOSE c_ref;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                               --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                               --
                                (a.status_icon <> b.status_icon OR (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                               --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (140, 141, 142, 143, 144)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.rank              = t.rank,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.status_str        = t.status_str,
                       tt_ea.status_msg        = t.status_msg,
                       tt_ea.status_icon       = t.status_icon,
                       tt_ea.status_flg        = t.status_flg,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_ref_ea;

    FUNCTION tf_list_episode
    (
        i_id_patient     IN episode.id_patient%TYPE DEFAULT NULL,
        i_id_episode     IN episode.id_episode%TYPE DEFAULT NULL,
        i_id_institution IN episode.id_institution%TYPE DEFAULT NULL
    ) RETURN table_t_episode IS
        l_out_rec        table_t_episode := table_t_episode(NULL);
        l_sql_header     VARCHAR2(1000 CHAR);
        l_sql_inner      VARCHAR2(1000 CHAR);
        l_sql_footer     VARCHAR2(1000 CHAR);
        l_sql_stmt       CLOB;
        l_curid          INTEGER;
        l_ret            INTEGER;
        l_cursor         pk_types.cursor_type;
        l_db_object_name VARCHAR2(30 CHAR) := 'TF_LIST_EPISODE';
    BEGIN
        l_curid := dbms_sql.open_cursor;
    
        l_sql_header := 'select t_rec_episode(id_episode) from (SELECT e.id_episode FROM episode e WHERE 1 = 1 ';
    
        --i_id_patient        
        IF i_id_patient IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND  e.id_patient = :i_id_patient ';
        END IF;
    
        --i_id_episode
        IF i_id_episode IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND e.id_episode = :i_id_episode';
        END IF;
    
        --i_id_institution
        IF i_id_institution IS NOT NULL
        THEN
            l_sql_inner := l_sql_inner || ' AND e.id_institution = :i_id_institution';
        END IF;
    
        l_sql_footer := ')';
    
        l_sql_stmt := to_clob(l_sql_header || l_sql_inner || l_sql_footer);
    
        pk_alertlog.log_debug(object_name     => g_package_name,
                              sub_object_name => l_db_object_name,
                              text            => dbms_lob.substr(l_sql_stmt, 4000, 1));
    
        dbms_sql.parse(l_curid, l_sql_stmt, dbms_sql.native);
    
        IF i_id_patient IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_patient', i_id_patient);
        END IF;
    
        IF i_id_episode IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_episode', i_id_episode);
        END IF;
    
        IF i_id_institution IS NOT NULL
        THEN
            dbms_sql.bind_variable(l_curid, 'i_id_institution', i_id_institution);
        END IF;
    
        l_ret := dbms_sql.execute(l_curid);
    
        l_cursor := dbms_sql.to_refcursor(l_curid);
    
        FETCH l_cursor BULK COLLECT
            INTO l_out_rec;
    
        RETURN l_out_rec;
    END tf_list_episode;

    /********************************************************************************************
    * Update IAH task in TASK_TIMELINE_EA.
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_id_aih                 P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author   Pedro Henriques
    * @version  2.7.1.4
    * @since    2017/08/30
    ********************************************************************************************/
    FUNCTION admin_task_tl_iah_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_IAH_EA';
        l_count_invalid     PLS_INTEGER := 0;
        l_count             PLS_INTEGER := 0;
        l_limit             PLS_INTEGER;
        l_ea_row            task_timeline_ea%ROWTYPE;
        l_ea_rows           ts_task_timeline_ea.task_timeline_ea_tc;
        l_error             t_error_out;
        l_nutrition_content VARCHAR2(200 CHAR) := 'TMP166.2654';
    
        CURSOR c_ref IS
            SELECT id_external_request,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_requested,
                   dt_requested,
                   id_inst_orig,
                   code_description,
                   dt_last_interaction_tstz,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   id_tl_task,
                   flg_status_epis
              FROM (SELECT aih.id_aih_simple id_external_request,
                           aih.id_patient,
                           aih.id_episode,
                           aih.flg_status,
                           aih.id_professional id_prof_requested,
                           aih.dt_order_tstz dt_requested,
                           aih.id_institution id_inst_orig,
                           'TL_TASK.CODE_TL_TASK.62' code_description,
                           aih.dt_last_update_tstz dt_last_interaction_tstz,
                           e.id_visit id_visit,
                           CASE
                                WHEN aih.flg_status IN ('C') THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated
                            END flg_outdated,
                           CASE
                                WHEN aih.flg_status IN ('A') THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           pk_prog_notes_constants.g_task_cits_procedures id_tl_task,
                           e.flg_status flg_status_epis
                    
                      FROM aih_simple aih
                      LEFT JOIN episode e
                        ON aih.id_episode = e.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE (e.id_patient = i_patient OR i_patient IS NULL)
                       AND (aih.id_episode = i_episode OR i_episode IS NULL)
                       AND (e.id_institution = i_institution OR i_institution IS NULL)
                       AND (aih.dt_order_tstz >= i_start_dt OR i_start_dt IS NULL)
                       AND (aih.dt_order_tstz <= i_end_dt OR i_end_dt IS NULL)
                       AND aih.flg_status <> pk_ref_constant.g_p1_status_c);
    
        TYPE t_coll_ref IS TABLE OF c_ref%ROWTYPE;
        l_ref_rows t_coll_ref;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline 140,141,142,143,144,145',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_cits_procedures))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        OPEN c_ref;
        LOOP
            -- get g_task_positioning data
            FETCH c_ref BULK COLLECT
                INTO l_ref_rows LIMIT l_limit;
        
            IF l_ref_rows IS NOT NULL
               AND l_ref_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := 'AIH_SIMPLE';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_ref_rows.first .. l_ref_rows.last
                LOOP
                    l_ea_row.id_tl_task       := l_ref_rows(i).id_tl_task;
                    l_ea_row.id_task_refid    := l_ref_rows(i).id_external_request;
                    l_ea_row.dt_begin         := l_ref_rows(i).dt_requested;
                    l_ea_row.flg_status_req   := l_ref_rows(i).flg_status;
                    l_ea_row.id_prof_req      := l_ref_rows(i).id_prof_requested;
                    l_ea_row.dt_req           := l_ref_rows(i).dt_requested;
                    l_ea_row.id_patient       := l_ref_rows(i).id_patient;
                    l_ea_row.id_episode       := l_ref_rows(i).id_episode;
                    l_ea_row.id_visit         := l_ref_rows(i).id_visit;
                    l_ea_row.id_institution   := l_ref_rows(i).id_inst_orig;
                    l_ea_row.code_description := l_ref_rows(i).code_description;
                    l_ea_row.id_prof_exec     := l_ref_rows(i).id_prof_requested;
                    l_ea_row.flg_outdated     := l_ref_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing      := l_ref_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update   := l_ref_rows(i).dt_last_interaction_tstz;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             status_str,
                             status_msg,
                             status_icon,
                             status_flg,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).status_str,
                             l_ea_rows(i).status_msg,
                             l_ea_rows(i).status_icon,
                             l_ea_rows(i).status_flg,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                --COMMIT;
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_ref%NOTFOUND;
        END LOOP;
    
        CLOSE c_ref;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                               --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                               --
                                (a.status_icon <> b.status_icon OR (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                               --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN (pk_prog_notes_constants.g_task_cits_procedures)
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.rank              = t.rank,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.status_str        = t.status_str,
                       tt_ea.status_msg        = t.status_msg,
                       tt_ea.status_icon       = t.status_icon,
                       tt_ea.status_flg        = t.status_flg,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_iah_ea;

    FUNCTION admin_task_tl_iah_special_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_IAH_EA';
        l_count_invalid     PLS_INTEGER := 0;
        l_count             PLS_INTEGER := 0;
        l_limit             PLS_INTEGER;
        l_ea_row            task_timeline_ea%ROWTYPE;
        l_ea_rows           ts_task_timeline_ea.task_timeline_ea_tc;
        l_error             t_error_out;
        l_nutrition_content VARCHAR2(200 CHAR) := 'TMP166.2654';
    
        CURSOR c_ref IS
            SELECT id_external_request,
                   id_patient,
                   id_episode,
                   flg_status,
                   id_prof_requested,
                   dt_requested,
                   id_inst_orig,
                   code_description,
                   dt_last_interaction_tstz,
                   id_visit,
                   flg_outdated,
                   flg_ongoing,
                   id_tl_task,
                   flg_status_epis
              FROM (SELECT aih.id_aih_special id_external_request,
                           aih.id_patient,
                           aih.id_episode,
                           aih.flg_status,
                           aih.id_professional id_prof_requested,
                           aih.dt_order_tstz dt_requested,
                           aih.id_institution id_inst_orig,
                           'TL_TASK.CODE_TL_TASK.62' code_description,
                           aih.dt_last_update_tstz dt_last_interaction_tstz,
                           e.id_visit id_visit,
                           CASE
                                WHEN aih.flg_status IN ('C') THEN
                                 pk_ea_logic_tasktimeline.g_flg_outdated
                                ELSE
                                 pk_ea_logic_tasktimeline.g_flg_not_outdated
                            END flg_outdated,
                           CASE
                                WHEN aih.flg_status IN ('A') THEN
                                 pk_prog_notes_constants.g_task_finalized_f
                                ELSE
                                 pk_prog_notes_constants.g_task_ongoing_o
                            END flg_ongoing,
                           pk_prog_notes_constants.g_task_cits_procedures_special id_tl_task,
                           e.flg_status flg_status_epis
                    
                      FROM aih_special aih
                      LEFT JOIN episode e
                        ON aih.id_episode = e.id_episode
                       AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                     WHERE (e.id_patient = i_patient OR i_patient IS NULL)
                       AND (aih.id_episode = i_episode OR i_episode IS NULL)
                       AND (e.id_institution = i_institution OR i_institution IS NULL)
                       AND (aih.dt_order_tstz >= i_start_dt OR i_start_dt IS NULL)
                       AND (aih.dt_order_tstz <= i_end_dt OR i_end_dt IS NULL)
                       AND aih.flg_status <> pk_ref_constant.g_p1_status_c);
    
        TYPE t_coll_ref IS TABLE OF c_ref%ROWTYPE;
        l_ref_rows t_coll_ref;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            pk_alertlog.log_error(text            => 'i_validate_table and i_recreate_table cannot be both false!',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            RAISE e_internal;
        END IF;
    
        -- set record limit
        IF i_commit_step IS NULL
           OR i_commit_step < 1
        THEN
            l_limit := k_default_limit;
        ELSE
            l_limit := i_commit_step;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline 140,141,142,143,144,145',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_cits_procedures_special))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
    
        OPEN c_ref;
        LOOP
            -- get g_task_positioning data
            FETCH c_ref BULK COLLECT
                INTO l_ref_rows LIMIT l_limit;
        
            IF l_ref_rows IS NOT NULL
               AND l_ref_rows.count > 0
            THEN
                -- set constant fields
                l_ea_row.table_name        := 'P1_EXTERNAL_REQUEST';
                l_ea_row.flg_show_method   := pk_alert_constant.g_tl_oriented_episode;
                l_ea_row.dt_dg_last_update := g_sysdate_tstz;
                l_ea_row.flg_sos           := pk_alert_constant.g_no;
                l_ea_row.flg_normal        := pk_alert_constant.g_yes;
                l_ea_row.flg_has_comments  := pk_alert_constant.g_no;
            
                -- set variable fields
                FOR i IN l_ref_rows.first .. l_ref_rows.last
                LOOP
                    l_ea_row.id_tl_task       := l_ref_rows(i).id_tl_task;
                    l_ea_row.id_task_refid    := l_ref_rows(i).id_external_request;
                    l_ea_row.dt_begin         := l_ref_rows(i).dt_requested;
                    l_ea_row.flg_status_req   := l_ref_rows(i).flg_status;
                    l_ea_row.id_prof_req      := l_ref_rows(i).id_prof_requested;
                    l_ea_row.dt_req           := l_ref_rows(i).dt_requested;
                    l_ea_row.id_patient       := l_ref_rows(i).id_patient;
                    l_ea_row.id_episode       := l_ref_rows(i).id_episode;
                    l_ea_row.id_visit         := l_ref_rows(i).id_visit;
                    l_ea_row.id_institution   := l_ref_rows(i).id_inst_orig;
                    l_ea_row.code_description := l_ref_rows(i).code_description;
                    l_ea_row.id_prof_exec     := l_ref_rows(i).id_prof_requested;
                    l_ea_row.flg_outdated     := l_ref_rows(i).flg_outdated;
                    l_ea_row.flg_ongoing      := l_ref_rows(i).flg_ongoing;
                    l_ea_row.dt_last_update   := l_ref_rows(i).dt_last_interaction_tstz;
                
                    -- add row to rows collection
                    l_ea_rows(i) := l_ea_row;
                END LOOP;
            
                IF i_validate_table
                THEN
                    -- add rows collection to temporary ea
                    FORALL i IN l_ea_rows.first .. l_ea_rows.last
                        INSERT INTO task_timeline_ea_tmp
                            (id_task_refid,
                             id_tl_task,
                             id_patient,
                             id_episode,
                             id_visit,
                             id_institution,
                             dt_req,
                             id_prof_req,
                             dt_begin,
                             dt_end,
                             flg_status_req,
                             table_name,
                             flg_show_method,
                             dt_dg_last_update,
                             flg_outdated,
                             rank,
                             flg_sos,
                             flg_ongoing,
                             flg_normal,
                             code_description,
                             id_prof_exec,
                             flg_has_comments,
                             status_str,
                             status_msg,
                             status_icon,
                             status_flg,
                             dt_last_update)
                        VALUES
                            (l_ea_rows(i).id_task_refid,
                             l_ea_rows(i).id_tl_task,
                             l_ea_rows(i).id_patient,
                             l_ea_rows(i).id_episode,
                             l_ea_rows(i).id_visit,
                             l_ea_rows(i).id_institution,
                             l_ea_rows(i).dt_req,
                             l_ea_rows(i).id_prof_req,
                             l_ea_rows(i).dt_begin,
                             l_ea_rows(i).dt_end,
                             l_ea_rows(i).flg_status_req,
                             l_ea_rows(i).table_name,
                             l_ea_rows(i).flg_show_method,
                             l_ea_rows(i).dt_dg_last_update,
                             l_ea_rows(i).flg_outdated,
                             l_ea_rows(i).rank,
                             l_ea_rows(i).flg_sos,
                             l_ea_rows(i).flg_ongoing,
                             l_ea_rows(i).flg_normal,
                             l_ea_rows(i).code_description,
                             l_ea_rows(i).id_prof_exec,
                             l_ea_rows(i).flg_has_comments,
                             l_ea_rows(i).status_str,
                             l_ea_rows(i).status_msg,
                             l_ea_rows(i).status_icon,
                             l_ea_rows(i).status_flg,
                             l_ea_rows(i).dt_last_update);
                END IF;
            
                IF i_recreate_table
                   AND NOT i_validate_table
                THEN
                    -- add rows collection to ea
                    ts_task_timeline_ea.ins(rows_in => l_ea_rows);
                END IF;
            
                --COMMIT;
                l_count := l_count + l_ea_rows.count;
            
                l_ea_rows.delete;
            
            END IF;
        
            EXIT WHEN c_ref%NOTFOUND;
        END LOOP;
    
        CLOSE c_ref;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
            INSERT INTO data_gov_invalid_recs
                (ea_table_name,
                 id_pk_1_value,
                 id_pk_1_col_name,
                 id_pk_2_value,
                 id_pk_2_col_name,
                 dt_validation,
                 validation_type,
                 i_patient,
                 i_episode,
                 i_schedule,
                 i_external_request,
                 i_institution,
                 i_start_dt,
                 i_end_dt)
                SELECT *
                  FROM ( --the ones that are diferent
                        SELECT g_task_tl_table_name,
                                b.id_task_refid,
                                g_task_tl_column_pk1,
                                b.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                2,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea a
                          JOIN task_timeline_ea_tmp b
                            ON a.id_task_refid = b.id_task_refid
                           AND a.id_tl_task = b.id_tl_task
                           AND a.table_name = b.table_name
                         WHERE a.dt_dg_last_update < g_sysdate_tstz
                           AND (
                               --                               
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                               --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                               --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                               --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                               --
                                (a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                               --
                                (a.id_prof_req <> b.id_prof_req OR (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                               --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                               --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                               --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                               --
                                (a.flg_show_method <> b.flg_show_method OR
                                (a.flg_show_method IS NULL AND b.flg_show_method IS NOT NULL) OR
                                (a.flg_show_method IS NOT NULL AND b.flg_show_method IS NULL)) OR
                               --
                                (a.dt_dg_last_update <> b.dt_dg_last_update OR
                                (a.dt_dg_last_update IS NULL AND b.dt_dg_last_update IS NOT NULL) OR
                                (a.dt_dg_last_update IS NOT NULL AND b.dt_dg_last_update IS NULL)) OR
                               --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                               --
                                (a.rank <> b.rank OR (a.rank IS NULL AND b.rank IS NOT NULL) OR
                                (a.rank IS NOT NULL AND b.rank IS NULL)) OR
                               --
                                (a.flg_sos <> b.flg_sos OR (a.flg_sos IS NULL AND b.flg_sos IS NOT NULL) OR
                                (a.flg_sos IS NOT NULL AND b.flg_sos IS NULL)) OR
                               --
                                (a.flg_ongoing <> b.flg_ongoing OR (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                               --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                               --
                                (a.code_description <> b.code_description OR
                                (a.code_description IS NULL AND b.code_description IS NOT NULL) OR
                                (a.code_description IS NOT NULL AND b.code_description IS NULL)) OR
                               --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                               --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                               --
                                (a.status_str <> b.status_str OR (a.status_str IS NULL AND b.status_str IS NOT NULL) OR
                                (a.status_str IS NOT NULL AND b.status_str IS NULL)) OR
                               --
                                (a.status_msg <> b.status_msg OR (a.status_msg IS NULL AND b.status_msg IS NOT NULL) OR
                                (a.status_msg IS NOT NULL AND b.status_msg IS NULL)) OR
                               --
                                (a.status_icon <> b.status_icon OR (a.status_icon IS NULL AND b.status_icon IS NOT NULL) OR
                                (a.status_icon IS NOT NULL AND b.status_icon IS NULL)) OR
                               --
                                (a.status_flg <> b.status_flg OR (a.status_flg IS NULL AND b.status_flg IS NOT NULL) OR
                                (a.status_flg IS NOT NULL AND b.status_flg IS NULL)) OR
                               --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL))
                               --
                               )
                        UNION ALL
                        --the ones that are missing
                        SELECT g_task_tl_table_name,
                                tt_ea_t.id_task_refid,
                                g_task_tl_column_pk1,
                                tt_ea_t.id_tl_task,
                                g_task_tl_column_pk2,
                                g_sysdate_tstz,
                                1,
                                i_patient,
                                i_episode,
                                i_schedule,
                                i_external_request,
                                i_institution,
                                i_start_dt,
                                i_end_dt
                          FROM task_timeline_ea_tmp tt_ea_t
                         WHERE NOT EXISTS (SELECT 0
                                  FROM task_timeline_ea tt_ea
                                 WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                   AND tt_ea.id_tl_task = tt_ea_t.id_tl_task));
        
            l_count_invalid := SQL%ROWCOUNT;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value IN pk_prog_notes_constants.g_task_cits_procedures_special
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = g_sysdate_tstz)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.flg_show_method   = t.flg_show_method,
                       tt_ea.dt_dg_last_update = t.dt_dg_last_update,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.rank              = t.rank,
                       tt_ea.flg_sos           = t.flg_sos,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.code_description  = t.code_description,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.status_str        = t.status_str,
                       tt_ea.status_msg        = t.status_msg,
                       tt_ea.status_icon       = t.status_icon,
                       tt_ea.status_flg        = t.status_flg,
                       tt_ea.dt_last_update    = t.dt_last_update
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     rank,
                     flg_sos,
                     flg_ongoing,
                     flg_normal,
                     code_description,
                     id_prof_exec,
                     flg_has_comments,
                     status_str,
                     status_msg,
                     status_icon,
                     status_flg,
                     dt_last_update)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     t.dt_dg_last_update,
                     t.flg_outdated,
                     t.rank,
                     t.flg_sos,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.code_description,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.status_str,
                     t.status_msg,
                     t.status_icon,
                     t.status_flg,
                     t.dt_last_update);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < g_sysdate_tstz;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count || ' inserted records');
            dbms_output.put_line(l_func_name || ' - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => '-20001',
                                              i_sqlerrm  => 'Internal error. Check log for details.',
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => g_log_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => NULL,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            RETURN FALSE;
    END admin_task_tl_iah_special_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with episode problems encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Elisabete Bugalho
    * @version  2.7.2.2
    * @since    13/12/2017
    ********************************************************************************************/
    FUNCTION admin_task_tl_prob_epis_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROB_EPIS_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_problems_episode',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_problems_episode))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     ep.id_epis_problem,
                     epg.id_epis_prob_group,
                     epg.id_episode,
                     ep.dt_epis_prob_tstz dt_req,
                     ep.flg_status,
                     ep.id_professional,
                     e.id_patient,
                     e.id_visit,
                     e.id_institution,
                     CASE
                          WHEN ep.flg_status IN (pk_problems.g_pat_probl_active) THEN
                           pk_prog_notes_constants.g_task_ongoing_o
                          WHEN ep.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                           pk_prog_notes_constants.g_task_inactive_i
                          ELSE
                           pk_prog_notes_constants.g_task_ongoing_o
                      END flg_ongoing,
                     pk_alert_constant.g_yes flg_normal,
                     NULL id_prof_exec,
                     ep.rank rank,
                     pk_alert_constant.g_no flg_has_comments,
                     NULL id_prof_review,
                     NULL dt_review,
                     decode(ep.id_problem_new,
                            
                            NULL,
                            pk_ea_logic_tasktimeline.g_flg_not_outdated,
                            pk_ea_logic_tasktimeline.g_flg_outdated) flg_outdated
                      FROM epis_prob ep
                      JOIN epis_prob_group epg
                        ON ep.id_epis_prob_group = epg.id_epis_prob_group
                      JOIN episode e
                        ON e.id_episode = epg.id_episode
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = e.id_episode
                     WHERE ep.dt_epis_prob_tstz >= nvl(i_start_dt, ep.dt_epis_prob_tstz)
                       AND ep.dt_epis_prob_tstz <= nvl(i_end_dt, ep.dt_epis_prob_tstz)
                       AND (ep.flg_status NOT IN (pk_problems.g_pat_probl_cancel,
                                                  pk_problems.g_pat_probl_invest,
                                                  pk_diagnosis.g_pat_prob_excluded))
                       AND ep.id_problem_new IS NULL)
        
        LOOP
        
            g_error := 'BEGIN LOOP';
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_epis_problem;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_problem,
                     pk_prog_notes_constants.g_task_problems_episode,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_epis_problem;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_problem,
                     pk_prog_notes_constants.g_task_problems_episode,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems_episode
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_EPIS_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_EPIS_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_EPIS_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_prob_epis_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with episode problems GROUP encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Elisabete Bugalho
    * @version  2.7.2.2
    * @since    13/12/2017
    ********************************************************************************************/
    FUNCTION admin_task_tl_prob_group_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_PROB_GROUP_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_problems_groups',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_problems_groups))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     epg.id_epis_prob_group,
                     epg.id_episode,
                     epg.dt_epis_prob_group_tstz dt_req,
                     epg.id_professional,
                     e.id_patient,
                     e.id_visit,
                     e.id_institution,
                     (SELECT flg_status
                        FROM epis_prob ep
                       WHERE ep.id_epis_prob_group = epg.id_epis_prob_group
                         AND rownum = 1) flg_status,
                     
                     pk_alert_constant.g_yes flg_normal,
                     NULL                    id_prof_exec,
                     -- epg.id_epis_prob_group  rank,
                     pk_alert_constant.g_no                      flg_has_comments,
                     NULL                                        id_prof_review,
                     NULL                                        dt_review,
                     epg.prob_group                              rank,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated
                      FROM epis_prob_group epg
                      JOIN episode e
                        ON e.id_episode = epg.id_episode
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = e.id_episode
                     WHERE epg.dt_epis_prob_group_tstz >= nvl(i_start_dt, epg.dt_epis_prob_group_tstz)
                       AND epg.dt_epis_prob_group_tstz <= nvl(i_end_dt, epg.dt_epis_prob_group_tstz))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := CASE
                                 WHEN rec.flg_status IN (pk_problems.g_pat_probl_active) THEN
                                  pk_prog_notes_constants.g_task_ongoing_o
                                 WHEN rec.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                                  pk_prog_notes_constants.g_task_inactive_i
                                 ELSE
                                  pk_prog_notes_constants.g_task_ongoing_o
                             END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_epis_prob_group;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_prob_group,
                     pk_prog_notes_constants.g_task_problems_groups,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB_GROUP',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     l_flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_epis_prob_group;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_prob_group,
                     pk_prog_notes_constants.g_task_problems_groups,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB_GROUP',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     l_flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems_groups
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_prob_group_ea;

    /********************************************************************************************
    * Actualize Easy Access table TASK_TIMELINE_EA with episode problems GROUP encoded records
    *
    * @param i_patient                Patient identifier
    * @param i_episode                Episode identifier
    * @value i_schedule               Shcedule identifier
    * @param i_external_request       P1 (referral) identifier
    * @param i_institution            Institution identifier
    * @param i_start_dt               Start date to be consider to the validation/reconstruction of data
    * @param i_end_dt                 End date to be consider to the validation/reconstruction of data
    * @param i_validate_table         Indicates necessary to validate data existent in easy access table
    * @param i_output_invalid_records Show final (resumed) information about updated statistics
    * @param i_recreate_table         Indicates necessary to rebuild data existent in easy access table
    * @param i_commit_step            Number of registries between commit's
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author   Elisabete Bugalho
    * @version  2.7.2.2
    * @since    19/12/2017
    ********************************************************************************************/
    FUNCTION admin_task_tl_prob_grp_ass_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'admin_task_tl_prob_grp_ass_ea';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_problems_group_ass',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_problems_group_ass))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
    
        FOR rec IN (SELECT /*+ opt_estimate(table tf_e rows=1)*/
                     pga.id_epis_prob_group_ass,
                     epg.id_episode,
                     pga.dt_create              dt_req,
                     pga.id_prof_create         id_professional,
                     e.id_patient,
                     e.id_visit,
                     e.id_institution,
                     pga.flg_status,
                     
                     pk_alert_constant.g_yes                     flg_normal,
                     NULL                                        id_prof_exec,
                     pk_alert_constant.g_no                      flg_has_comments,
                     NULL                                        id_prof_review,
                     NULL                                        dt_review,
                     epg.prob_group                              rank,
                     pk_ea_logic_tasktimeline.g_flg_not_outdated flg_outdated
                      FROM epis_prob_group_assess pga
                      JOIN epis_prob_group epg
                        ON pga.id_epis_prob_group = epg.id_epis_prob_group
                      JOIN episode e
                        ON e.id_episode = epg.id_episode
                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                        ON tf_e.id_episode = e.id_episode
                     WHERE pga.dt_last_update >= nvl(i_start_dt, pga.dt_last_update)
                       AND pga.dt_last_update <= nvl(i_end_dt, pga.dt_last_update)
                       AND pga.flg_status NOT IN (pk_problems.g_status_prog_group_ass_c))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := CASE
                                 WHEN rec.flg_status IN (pk_problems.g_pat_probl_active) THEN
                                  pk_prog_notes_constants.g_task_ongoing_o
                                 WHEN rec.flg_status IN (pk_problems.g_pat_probl_passive) THEN
                                  pk_prog_notes_constants.g_task_inactive_i
                                 ELSE
                                  pk_prog_notes_constants.g_task_ongoing_o
                             END;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_epis_prob_group_ass;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_prob_group_ass,
                     pk_prog_notes_constants.g_task_problems_group_ass,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB_GROUP_ASSESS',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     pk_prog_notes_constants.g_task_ongoing_o,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_epis_prob_group_ass;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_epis_prob_group_ass,
                     pk_prog_notes_constants.g_task_problems_group_ass,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_professional,
                     NULL,
                     NULL,
                     rec.flg_status,
                     'EPIS_PROB_GROUP_ASSESS',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     pk_prog_notes_constants.g_task_ongoing_o,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     rec.flg_has_comments,
                     rec.dt_req,
                     rec.id_prof_review,
                     rec.dt_review,
                     rec.rank);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems_groups
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_grp_ass_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_grp_ass_ea - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_ASS_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_ASS_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_PROB_GROUP_ASS_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_prob_grp_ass_ea;

    FUNCTION admin_task_tl_supply_ea
    (
        i_patient                IN NUMBER := NULL,
        i_episode                IN NUMBER := NULL,
        i_schedule               IN NUMBER := NULL,
        i_external_request       IN NUMBER := NULL,
        i_institution            IN NUMBER := NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE := NULL,
        i_validate_table         IN BOOLEAN := TRUE,
        i_output_invalid_records IN BOOLEAN := FALSE,
        i_recreate_table         IN BOOLEAN := FALSE,
        i_commit_step            IN NUMBER := pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_SUPPLY_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_supply',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_supply))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM (SELECT sw.id_supply_workflow,
                                   e.id_patient,
                                   sw.id_episode,
                                   e.id_visit,
                                   e.id_institution,
                                   sw.dt_request,
                                   sw.id_professional,
                                   sw.flg_status,
                                   s.code_supply,
                                   sw.id_sup_workflow_parent,
                                   sa.code_supply_area,
                                   sa.id_supply_area,
                                   sw.dt_supply_workflow,
                                   CASE
                                        WHEN sw.flg_status IN (pk_alert_constant.g_cancelled) THEN
                                         pk_ea_logic_tasktimeline.g_flg_outdated -- supply cancelled
                                        WHEN sw.dt_returned < g_sysdate_tstz THEN
                                         pk_ea_logic_tasktimeline.g_flg_outdated -- 
                                        WHEN sw.dt_expiration < g_sysdate_tstz THEN
                                         pk_ea_logic_tasktimeline.g_flg_outdated
                                        ELSE
                                         pk_ea_logic_tasktimeline.g_flg_not_outdated -- 
                                    END flg_outdated,
                                   CASE
                                        WHEN sw.dt_returned < g_sysdate_tstz THEN
                                         pk_prog_notes_constants.g_task_finalized_f -- 
                                        WHEN sw.dt_expiration < g_sysdate_tstz THEN
                                         pk_prog_notes_constants.g_task_finalized_f
                                        ELSE
                                         pk_prog_notes_constants.g_task_ongoing_o
                                    END flg_ongoing,
                                   pk_alert_constant.g_yes flg_normal,
                                   pk_alert_constant.g_no flg_has_comments
                              FROM supply_workflow sw
                              JOIN episode e
                                ON sw.id_episode = e.id_episode
                               AND e.flg_status <> pk_alert_constant.g_epis_status_cancel
                              JOIN epis_info ei
                                ON sw.id_episode = ei.id_episode
                               AND e.id_episode = ei.id_episode
                              LEFT OUTER JOIN supply s
                                ON sw.id_supply = s.id_supply
                              LEFT OUTER JOIN supply_area sa
                                ON sw.id_supply_area = sa.id_supply_area) n
                     WHERE (n.id_patient = i_patient OR i_patient IS NULL)
                       AND (n.id_episode = i_episode OR i_episode IS NULL)
                       AND (n.id_institution = i_institution OR i_institution IS NULL))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        
            IF i_validate_table
            THEN
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_supply_workflow;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_supply_workflow,
                     pk_prog_notes_constants.g_task_supply,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_supply_workflow,
                     rec.id_professional,
                     rec.code_supply,
                     rec.id_supply_area,
                     rec.code_supply_area,
                     rec.dt_supply_workflow,
                     rec.dt_supply_workflow,
                     rec.flg_status,
                     'SUPPLY_WORKFLOW',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     l_flg_ongoing,
                     rec.flg_normal,
                     NULL,
                     rec.flg_has_comments,
                     rec.dt_request,
                     NULL,
                     NULL,
                     NULL);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_supply_workflow;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_supply_workflow,
                     pk_prog_notes_constants.g_task_supply,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_supply_workflow,
                     rec.id_professional,
                     rec.code_supply,
                     rec.id_supply_area,
                     rec.code_supply_area,
                     rec.dt_supply_workflow,
                     rec.dt_supply_workflow,
                     rec.flg_status,
                     'SUPPLY_WORKFLOW',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     rec.flg_outdated,
                     l_flg_ongoing,
                     rec.flg_normal,
                     NULL,
                     rec.flg_has_comments,
                     rec.dt_request,
                     NULL,
                     NULL,
                     NULL);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_problems_groups
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SUPPLY_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SUPPLY_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_SUPPLY_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_supply_ea;

    FUNCTION admin_task_tl_nurse_diag_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_NURSE_DIAG_EA';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
        l_flg_outdated      task_timeline_ea.flg_outdated%TYPE := 1;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_nurse_diagnosis',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_nurse_diagnosis))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM (SELECT itv.id_icnp_epis_diag,
                                   itv.dt_icnp_epis_diag,
                                   itv.dt_close dt_end,
                                   itv.flg_status flg_status_det,
                                   itv.id_prof_take,
                                   'ICNP_COMPOSITION.CODE_ICNP_COMPOSITION.' || itv.id_composition_diag code_diagnosis,
                                   itv.id_visit,
                                   itv.id_episode,
                                   itv.id_patient,
                                   itv.id_institution,
                                   --ipd.id_interv_presc_det,
                                   --                               ipp.id_epis_documentation,
                                   itv.notes,
                                   pk_alert_constant.g_yes flg_normal,
                                   itv.dt_last_update dt_last_update,
                                   'ICNP_EPIS_DIAGNOSIS.FLG_STATUS' code_status,
                                   itv.flg_prn,
                                   --  ipp.dt_interv_presc_plan,
                                   itv.id_professional,
                                   --itv.dt_plan,
                                   decode(itv.flg_status,
                                          pk_icnp_constant.g_epis_diag_status_active,
                                          pk_prog_notes_constants.g_task_ongoing_o,
                                          pk_icnp_constant.g_epis_diag_status_in_progress,
                                          pk_prog_notes_constants.g_task_ongoing_o,
                                          pk_icnp_constant.g_epis_diag_status_revaluated,
                                          pk_prog_notes_constants.g_task_ongoing_o,
                                          pk_icnp_constant.g_epis_diag_status_suspended,
                                          pk_prog_notes_constants.g_task_inactive_i,
                                          pk_icnp_constant.g_epis_diag_status_discontinue,
                                          pk_prog_notes_constants.g_task_inactive_i,
                                          pk_icnp_constant.g_epis_diag_status_resolved,
                                          pk_prog_notes_constants.g_task_finalized_f) flg_ongoing
                              FROM (SELECT /*+opt_estimate(table ied rows=1)*/
                                     ied.id_icnp_epis_diag,
                                     ied.id_composition id_composition_diag,
                                     ied.flg_status,
                                     ied.id_prof_close,
                                     ied.dt_close_tstz dt_close,
                                     ied.dt_icnp_epis_diag_tstz dt_icnp_epis_diag,
                                     ied.id_professional,
                                     ied.id_episode,
                                     ied.id_patient,
                                     e.id_visit,
                                     e.id_institution,
                                     nvl(ied.id_prof_close, ied.id_prof_last_update) id_prof_take,
                                     ied.notes,
                                     ied.notes_close,
                                     pk_alert_constant.g_no flg_prn,
                                     ied.dt_last_update,
                                     row_number() over(PARTITION BY ied.id_icnp_epis_diag ORDER BY --
                                     decode(ied.flg_status, pk_icnp_constant.g_interv_plan_status_pending, 1, pk_icnp_constant.g_interv_plan_status_requested, 1, 2), ied.dt_icnp_epis_diag_tstz) rn
                                      FROM icnp_epis_diagnosis ied
                                      JOIN icnp_composition ici
                                        ON ied.id_composition = ici.id_composition
                                      JOIN episode e
                                        ON ied.id_episode = e.id_episode
                                     WHERE ied.flg_status NOT IN (pk_icnp_constant.g_epis_diag_status_cancelled)) itv
                             WHERE itv.rn = 1) n
                     WHERE (n.id_patient = i_patient OR i_patient IS NULL)
                       AND (n.id_episode = i_episode OR i_episode IS NULL)
                       AND (n.id_institution = i_institution OR i_institution IS NULL))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        
            IF i_validate_table
            THEN
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_icnp_epis_diag;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_icnp_epis_diag,
                     pk_prog_notes_constants.g_task_nurse_diagnosis,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_icnp_epis_diag,
                     rec.id_prof_take,
                     rec.code_diagnosis,
                     NULL,
                     NULL,
                     rec.dt_icnp_epis_diag,
                     rec.dt_end,
                     rec.flg_status_det,
                     'ICNP_EPIS_DIAGNOSIS',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_take,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_icnp_epis_diag;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_icnp_epis_diag,
                     pk_prog_notes_constants.g_task_nurse_diagnosis,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_icnp_epis_diag,
                     rec.id_prof_take,
                     rec.code_diagnosis,
                     NULL,
                     NULL,
                     rec.dt_icnp_epis_diag,
                     rec.dt_end,
                     rec.flg_status_det,
                     'ICNP_EPIS_DIAGNOSIS',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_take,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL);
            
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_nurse_diagnosis
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('admin_task_tl_prob_epis_ea - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_DIAG_EA',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_nurse_diag_ea;

    FUNCTION admin_task_tl_nurse_interv_ea
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
    
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
        l_flg_outdated      task_timeline_ea.flg_outdated%TYPE := 1;
    
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_nurse_intervention',
                                  object_name     => g_package_name,
                                  sub_object_name => 'ADMIN_TASK_TL_NURSE_INTERV_EA');
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_nurse_intervention))
            THEN
                RAISE e_internal;
            END IF;
        END IF;
    
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM (SELECT itv.id_icnp_epis_interv,
                                   itv.dt_begin,
                                   itv.dt_close dt_end,
                                   itv.flg_status flg_status_det,
                                   itv.id_prof_take,
                                   'ICNP_COMPOSITION.CODE_ICNP_COMPOSITION.' || itv.id_composition_interv code_intervention,
                                   itv.id_visit,
                                   itv.id_episode,
                                   itv.id_patient,
                                   itv.id_institution,
                                   --ipd.id_interv_presc_det,
                                   --ipp.id_epis_documentation,
                                   itv.notes,
                                   pk_alert_constant.g_yes flg_normal,
                                   itv.dt_last_update dt_last_update,
                                   'ICNP_EPIS_INTERVENTION.FLG_STATUS' code_status,
                                   itv.flg_prn,
                                   --ipp.dt_interv_presc_plan,
                                   itv.id_prof,
                                   itv.dt_plan,
                                   decode(itv.flg_status,
                                          pk_icnp_constant.g_epis_interv_status_ongoing,
                                          pk_prog_notes_constants.g_task_ongoing_o,
                                          pk_icnp_constant.g_epis_interv_status_requested,
                                          pk_prog_notes_constants.g_task_ongoing_o,
                                          pk_icnp_constant.g_epis_interv_status_suspended,
                                          pk_prog_notes_constants.g_task_inactive_i,
                                          pk_icnp_constant.g_epis_interv_status_discont,
                                          pk_prog_notes_constants.g_task_inactive_i,
                                          pk_icnp_constant.g_epis_interv_status_executed,
                                          pk_prog_notes_constants.g_task_finalized_f) flg_ongoing
                              FROM (SELECT /*+ opt_estimate(table tf_e rows=1) */
                                     iei.id_icnp_epis_interv,
                                     iei.id_composition id_composition_interv,
                                     ied.id_icnp_epis_diag,
                                     ied.id_composition id_composition_diag,
                                     iei.flg_time,
                                     iei.flg_status,
                                     iei.flg_type,
                                     iei.dt_next_tstz dt_next,
                                     decode((SELECT 1
                                              FROM icnp_interv_plan i
                                             WHERE i.id_icnp_epis_interv = iei.id_icnp_epis_interv
                                               AND rownum = 1
                                               AND i.flg_status NOT IN
                                                   (pk_icnp_constant.g_epis_interv_status_requested,
                                                    pk_icnp_constant.g_epis_interv_status_cancelled,
                                                    pk_icnp_constant.g_epis_interv_status_modified)),
                                            1,
                                            decode(iip.dt_plan_tstz, NULL, iei.dt_icnp_epis_interv_tstz, iip.dt_plan_tstz),
                                            iip.dt_plan_tstz) dt_plan,
                                     (ici.flg_task || ici.id_vs) id_vs,
                                     iei.id_prof_close,
                                     iei.dt_close_tstz dt_close,
                                     iei.dt_icnp_epis_interv_tstz dt_icnp_epis_interv,
                                     iei.id_prof,
                                     iei.id_episode_origin,
                                     iei.id_episode,
                                     iei.id_patient,
                                     e.id_visit,
                                     e.id_institution,
                                     iip.flg_status flg_status_plan,
                                     nvl(iei.id_prof_close, iip.id_prof_take) id_prof_take,
                                     iei.freq,
                                     iei.notes,
                                     iei.notes_close,
                                     iei.dt_begin_tstz dt_begin,
                                     iei.dt_last_update,
                                     iei.flg_duration_unit,
                                     iei.duration,
                                     iei.num_take,
                                     iei.flg_interval_unit,
                                     iei.interval,
                                     nvl(iei.dt_close_tstz, iip.dt_take_tstz) dt_take_ea,
                                     iei.flg_prn,
                                     orp.id_order_recurr_option recurr_option,
                                     row_number() over(PARTITION BY iei.id_icnp_epis_interv ORDER BY --
                                     decode(iip.flg_status, pk_icnp_constant.g_interv_plan_status_pending, 1, pk_icnp_constant.g_interv_plan_status_requested, 1, 2), iip.dt_plan_tstz) rn
                                      FROM icnp_epis_intervention iei
                                      JOIN icnp_composition ici
                                        ON iei.id_composition = ici.id_composition
                                      JOIN episode e
                                        ON iei.id_episode = e.id_episode
                                      JOIN TABLE(tf_list_episode(i_patient, i_episode, i_institution)) tf_e
                                        ON tf_e.id_episode = e.id_episode
                                      LEFT JOIN order_recurr_plan orp
                                        ON orp.id_order_recurr_plan = iei.id_order_recurr_plan
                                      LEFT JOIN icnp_epis_diag_interv iedi
                                        ON iei.id_icnp_epis_interv = iedi.id_icnp_epis_interv
                                      LEFT JOIN icnp_epis_diagnosis ied
                                        ON iedi.id_icnp_epis_diag = ied.id_icnp_epis_diag
                                      LEFT JOIN icnp_interv_plan iip
                                        ON iei.id_icnp_epis_interv = iip.id_icnp_epis_interv
                                       AND iip.flg_status IN
                                           (pk_icnp_constant.g_interv_plan_status_pending,
                                            pk_icnp_constant.g_interv_plan_status_requested,
                                            pk_icnp_constant.g_interv_plan_status_executed,
                                            pk_icnp_constant.g_interv_plan_status_suspended)
                                       AND iei.id_episode_destination IS NULL
                                       AND iei.forward_interv IS NULL
                                     WHERE iei.flg_status NOT IN (pk_icnp_constant.g_epis_interv_status_cancelled)) itv
                             WHERE itv.rn = 1) n)
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        
            IF i_validate_table
            THEN
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_icnp_epis_interv;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_icnp_epis_interv,
                     pk_prog_notes_constants.g_task_nurse_intervention,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_plan,
                     rec.id_prof_take,
                     rec.code_intervention,
                     NULL,
                     NULL,
                     rec.dt_begin,
                     rec.dt_end,
                     rec.flg_status_det,
                     'ICNP_EPIS_INTERVENTION',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_take,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_icnp_epis_interv;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (rec.id_icnp_epis_interv,
                     pk_prog_notes_constants.g_task_nurse_intervention,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_plan,
                     rec.id_prof_take,
                     rec.code_intervention,
                     NULL,
                     NULL,
                     rec.dt_begin,
                     rec.dt_end,
                     rec.flg_status_det,
                     'ICNP_EPIS_INTERVENTION',
                     pk_alert_constant.g_tl_oriented_episode,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_take,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL);
            END IF;
        
            l_count := l_count + 1;
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            END LOOP;
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_nurse_intervention
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank);
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
            dbms_output.put_line('ADMIN_TASK_TL_NURSE_INTERV_EA - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('ADMIN_TASK_TL_NURSE_INTERV_EA - OK: ' || l_count_invalid ||
                                 ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_INTERV_EA',
                                              l_error);
            RETURN FALSE;
        
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_INTERV_EA',
                                              l_error);
            RETURN FALSE;
        
        WHEN OTHERS THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_NURSE_INTERV_EA',
                                              l_error);
            RETURN FALSE;
    END admin_task_tl_nurse_interv_ea;

    FUNCTION admin_task_tl_rehab_presc
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_REHAB_PRESC';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
        l_flg_outdated      task_timeline_ea.flg_outdated%TYPE := 1;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_rehab_treatments',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_rehab_treatments))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM ((SELECT rtt.id_rehab_presc,
                                    rtt.dt_req,
                                    --               rs.dt_begin as dt_begin,
                                    rtt.dt_last_execution,
                                    rtt.flg_status,
                                    rtt.id_prof_req,
                                    rtt.code_intervention,
                                    rtt.code_area,
                                    rtt.id_episode,
                                    rtt.id_visit,
                                    rtt.id_patient,
                                    rtt.id_institution,
                                    pk_alert_constant.g_yes  flg_normal,
                                    pk_alert_constant.g_no   flg_prn,
                                    rtt.id_rehab_area_interv,
                                    rtt.flg_priority,
                                    -- pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_PRIORITY', rsn.flg_priority, 8) AS piority,
                                    -- rsn.frequency,
                                    -- rsn.flg_frequency,
                                    -- pk_sysdomain.get_domain('REHAB_SCH_NEED.FLG_FREQUENCY', rsn.flg_frequency, 8) AS freq,
                                    -- rsn.sessions,
                                    --rp.exec_per_session,
                                    rtt.id_prof_exec,
                                    'REHAB_PRESC.FLG_STATUS' code_status,
                                    decode(rtt.flg_status,
                                           pk_rehab.g_rehab_presc_begin,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_susp_prop,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_edit_prop,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_ongoing_prop,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_ongoing,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_suspend,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_presc_disc_prop,
                                           pk_prog_notes_constants.g_task_inactive_i,
                                           pk_rehab.g_rehab_presc_discontinued,
                                           pk_prog_notes_constants.g_task_inactive_i,
                                           pk_rehab.g_rehab_presc_cancel,
                                           pk_prog_notes_constants.g_task_inactive_i,
                                           pk_rehab.g_rehab_presc_finished,
                                           pk_prog_notes_constants.g_task_finalized_f) flg_ongoing
                               FROM (SELECT /*+opt_estimate(table rp rows=1)*/
                                      rp.id_rehab_presc,
                                      rsn.dt_begin AS dt_req,
                                      rs.dt_end dt_last_execution,
                                      rp.flg_status,
                                      rp.id_professional id_prof_req,
                                      i.code_intervention,
                                      ra.code_rehab_area code_area,
                                      e.id_episode,
                                      e.id_visit,
                                      e.id_patient,
                                      e.id_institution,
                                      rp.id_rehab_area_interv,
                                      rsn.flg_priority,
                                      rs.id_professional id_prof_exec,
                                      row_number() over(PARTITION BY rp.id_rehab_presc ORDER BY rs.id_rehab_session DESC) rn
                                       FROM rehab_presc rp
                                       JOIN rehab_sch_need rsn
                                         ON rsn.id_rehab_sch_need = rp.id_rehab_sch_need
                                       JOIN rehab_area_interv rai
                                         ON rai.id_rehab_area_interv = rp.id_rehab_area_interv
                                       JOIN rehab_area ra
                                         ON ra.id_rehab_area = rai.id_rehab_area
                                       JOIN episode e
                                         ON e.id_episode = rsn.id_episode_origin
                                       JOIN intervention i
                                         ON i.id_intervention = rai.id_intervention
                                       LEFT JOIN rehab_session rs
                                         ON rs.id_rehab_presc = rp.id_rehab_presc
                                      WHERE rp.flg_status NOT IN ('C')) rtt
                              WHERE rtt.rn = 1) n)
                     WHERE (n.id_patient = i_patient OR i_patient IS NULL)
                       AND (n.id_episode = i_episode OR i_episode IS NULL)
                       AND (n.id_institution = i_institution OR i_institution IS NULL))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_rehab_presc;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     --   dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_status,
                     flg_sos,
                     dt_last_execution)
                VALUES
                    (rec.id_rehab_presc,
                     pk_prog_notes_constants.g_task_rehab_treatments,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.code_intervention,
                     NULL,
                     rec.code_area,
                     rec.dt_req,
                     --      rec.dt_end,
                     rec.flg_status,
                     'REHAB_PRESC',
                     pk_alert_constant.g_tl_oriented_visit,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     pk_alert_constant.g_no,
                     rec.dt_last_execution,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_status,
                     rec.flg_prn,
                     rec.dt_last_execution);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_rehab_presc;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     code_description,
                     id_group_import,
                     code_desc_group,
                     dt_begin,
                     --   dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_status,
                     flg_sos,
                     dt_last_execution)
                VALUES
                    (rec.id_rehab_presc,
                     pk_prog_notes_constants.g_task_rehab_treatments,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_req,
                     rec.id_prof_req,
                     rec.code_intervention,
                     NULL,
                     rec.code_area,
                     rec.dt_req,
                     --      rec.dt_end,
                     rec.flg_status,
                     'REHAB_PRESC',
                     pk_alert_constant.g_tl_oriented_visit,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     rec.id_prof_exec,
                     pk_alert_constant.g_no,
                     rec.dt_last_execution,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_status,
                     rec.flg_prn,
                     rec.dt_last_execution);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_rehab_treatments
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_desc_group,
                     code_status,
                     flg_sos,
                     dt_last_execution)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank,
                     t.code_desc_group,
                     t.code_status,
                     t.flg_sos,
                     t.dt_last_execution);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('ADMIN_TASK_TL_REHAB_PRESC - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('ADMIN_TASK_TL_REHAB_PRESC - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_PRESC',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_PRESC',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_PRESC',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_rehab_presc;

    FUNCTION admin_task_tl_rehab_diag
    (
        i_patient                IN NUMBER DEFAULT NULL,
        i_episode                IN NUMBER DEFAULT NULL,
        i_schedule               IN NUMBER DEFAULT NULL,
        i_external_request       IN NUMBER DEFAULT NULL,
        i_institution            IN NUMBER DEFAULT NULL,
        i_start_dt               IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_end_dt                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_validate_table         IN BOOLEAN DEFAULT TRUE,
        i_output_invalid_records IN BOOLEAN DEFAULT FALSE,
        i_recreate_table         IN BOOLEAN DEFAULT FALSE,
        i_commit_step            IN NUMBER DEFAULT pk_data_gov_admin.get_commit_limit
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'ADMIN_TASK_TL_REHAB_DIAG';
        -- Migration script for TASK_TIMELINE_EA
        l_count_invalid NUMBER := 0;
        l_count         NUMBER := 0;
    
        l_current_timestamp TIMESTAMP WITH TIME ZONE := current_timestamp;
        l_validation_type   data_gov_invalid_recs.validation_type%TYPE;
        l_error             t_error_out;
        l_flg_ongoing       VARCHAR2(1 CHAR);
        l_flg_outdated      task_timeline_ea.flg_outdated%TYPE := 1;
    BEGIN
    
        IF NOT i_validate_table
           AND NOT i_recreate_table
        THEN
            RAISE e_internal;
        END IF;
    
        IF i_recreate_table
           AND NOT i_validate_table
        THEN
            pk_alertlog.log_debug(text            => 'CALL pk_ea_logic_tasktimeline.delete_task_timeline g_task_icf',
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name);
            IF NOT
                pk_ea_logic_tasktimeline.delete_task_timeline(i_patient     => i_patient,
                                                              i_episode     => i_episode,
                                                              i_institution => i_institution,
                                                              i_start_dt    => i_start_dt,
                                                              i_end_dt      => i_end_dt,
                                                              i_id_tl_task  => table_number(pk_prog_notes_constants.g_task_icf))
            THEN
                RAISE e_internal;
            END IF;
        
        END IF;
        g_error := 'LOOP';
        FOR rec IN (SELECT *
                      FROM ((SELECT rd.id_rehab_diagnosis,
                                    rd.dt_last_update,
                                    rd.id_episode,
                                    rd.flg_status,
                                    rd.id_prof_last_update id_prof_req,
                                    e.id_visit,
                                    e.id_patient,
                                    e.id_institution,
                                    'REHAB_DIAGNOSIS.FLG_STATUS' code_status,
                                    rd.notes,
                                    pk_alert_constant.g_yes flg_normal,
                                    pk_alert_constant.g_no flg_prn,
                                    decode(rd.flg_status,
                                           pk_rehab.g_rehab_diag_flg_status_e,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_diag_flg_status_t,
                                           pk_prog_notes_constants.g_task_ongoing_o,
                                           pk_rehab.g_rehab_diag_flg_status_c,
                                           pk_prog_notes_constants.g_task_inactive_i,
                                           pk_rehab.g_rehab_diag_flg_status_r,
                                           pk_prog_notes_constants.g_task_finalized_f) flg_ongoing
                               FROM rehab_diagnosis rd
                               JOIN episode e
                                 ON e.id_episode = rd.id_episode
                              WHERE rd.flg_status NOT IN ('C')) n)
                     WHERE (n.id_patient = i_patient OR i_patient IS NULL)
                       AND (n.id_episode = i_episode OR i_episode IS NULL)
                       AND (n.id_institution = i_institution OR i_institution IS NULL))
        
        LOOP
        
            g_error       := 'BEGIN LOOP';
            l_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        
            IF i_validate_table
            THEN
            
                --insert in temporary table
                g_error := 'Insert task ' || rec.id_rehab_diagnosis;
                pk_alertlog.log_debug(g_error);
                INSERT INTO task_timeline_ea_tmp
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_status,
                     flg_sos)
                VALUES
                    (rec.id_rehab_diagnosis,
                     pk_prog_notes_constants.g_task_icf,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_last_update,
                     rec.id_prof_req,
                     rec.flg_status,
                     'REHAB_DIAGNOSIS',
                     pk_alert_constant.g_tl_oriented_visit,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_status,
                     rec.flg_prn);
            
            END IF;
        
            IF i_recreate_table
               AND NOT i_validate_table
            THEN
                g_error := 'Insert task2: ' || rec.id_rehab_diagnosis;
                -- Insert into Easy Access table
                INSERT INTO task_timeline_ea
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_status,
                     flg_sos)
                VALUES
                    (rec.id_rehab_diagnosis,
                     pk_prog_notes_constants.g_task_icf,
                     rec.id_patient,
                     rec.id_episode,
                     rec.id_visit,
                     rec.id_institution,
                     rec.dt_last_update,
                     rec.id_prof_req,
                     rec.flg_status,
                     'REHAB_DIAGNOSIS',
                     pk_alert_constant.g_tl_oriented_visit,
                     current_timestamp,
                     l_flg_outdated,
                     rec.flg_ongoing,
                     rec.flg_normal,
                     pk_alert_constant.g_no,
                     rec.dt_last_update,
                     NULL,
                     NULL,
                     NULL,
                     rec.code_status,
                     rec.flg_prn);
            END IF;
        
            l_count := l_count + 1;
        
        END LOOP;
    
        IF i_validate_table
        THEN
            --compares and saves on table DATA_GOV_INVALID_RECS
        
            --the ones that are diferent
            FOR rec1 IN (SELECT b.id_task_refid id_task_refid_tmp, b.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea a
                           JOIN task_timeline_ea_tmp b
                             ON a.id_task_refid = b.id_task_refid
                            AND a.id_tl_task = b.id_tl_task
                            AND a.table_name = b.table_name
                          WHERE a.dt_dg_last_update < l_current_timestamp
                            AND ((a.dt_req <> b.dt_req OR (a.dt_req IS NULL AND b.dt_req IS NOT NULL) OR
                                (a.dt_req IS NOT NULL AND b.dt_req IS NULL)) OR
                                --
                                (a.dt_begin <> b.dt_begin OR (a.dt_begin IS NULL AND b.dt_begin IS NOT NULL) OR
                                (a.dt_begin IS NOT NULL AND b.dt_begin IS NULL)) OR
                                --
                                (a.dt_end <> b.dt_end OR (a.dt_end IS NULL AND b.dt_end IS NOT NULL) OR
                                (a.dt_end IS NOT NULL AND b.dt_end IS NULL)) OR
                                --
                                (a.flg_status_req <> b.flg_status_req OR
                                (a.flg_status_req IS NULL AND b.flg_status_req IS NOT NULL) OR
                                (a.flg_status_req IS NOT NULL AND b.flg_status_req IS NULL)) OR
                                --
                                (a.id_prof_req <> b.id_prof_req OR
                                (a.id_prof_req IS NULL AND b.id_prof_req IS NOT NULL) OR
                                (a.id_prof_req IS NOT NULL AND b.id_prof_req IS NULL)) OR
                                --
                                (a.id_patient <> b.id_patient OR (a.id_patient IS NULL AND b.id_patient IS NOT NULL) OR
                                (a.id_patient IS NOT NULL AND b.id_patient IS NULL)) OR
                                --
                                (a.id_episode <> b.id_episode OR (a.id_episode IS NULL AND b.id_episode IS NOT NULL) OR
                                (a.id_episode IS NOT NULL AND b.id_episode IS NULL)) OR
                                --
                                (a.id_visit <> b.id_visit OR (a.id_visit IS NULL AND b.id_visit IS NOT NULL) OR
                                (a.id_visit IS NOT NULL AND b.id_visit IS NULL)) OR
                                --
                                (a.id_institution <> b.id_institution OR
                                (a.id_institution IS NULL AND b.id_institution IS NOT NULL) OR
                                (a.id_institution IS NOT NULL AND b.id_institution IS NULL)) OR
                                --
                                (a.flg_outdated <> b.flg_outdated OR
                                (a.flg_outdated IS NULL AND b.flg_outdated IS NOT NULL) OR
                                (a.flg_outdated IS NOT NULL AND b.flg_outdated IS NULL)) OR
                                --
                                (a.flg_ongoing <> b.flg_ongoing OR
                                (a.flg_ongoing IS NULL AND b.flg_ongoing IS NOT NULL) OR
                                (a.flg_ongoing IS NOT NULL AND b.flg_ongoing IS NULL)) OR
                                --
                                (a.flg_normal <> b.flg_normal OR (a.flg_normal IS NULL AND b.flg_normal IS NOT NULL) OR
                                (a.flg_normal IS NOT NULL AND b.flg_normal IS NULL)) OR
                                --
                                (a.id_prof_exec <> b.id_prof_exec OR
                                (a.id_prof_exec IS NULL AND b.id_prof_exec IS NOT NULL) OR
                                (a.id_prof_exec IS NOT NULL AND b.id_prof_exec IS NULL)) OR
                                --
                                (a.flg_has_comments <> b.flg_has_comments OR
                                (a.flg_has_comments IS NULL AND b.flg_has_comments IS NOT NULL) OR
                                (a.flg_has_comments IS NOT NULL AND b.flg_has_comments IS NULL)) OR
                                --
                                (a.dt_last_update <> b.dt_last_update OR
                                (a.dt_last_update IS NULL AND b.dt_last_update IS NOT NULL) OR
                                (a.dt_last_update IS NOT NULL AND b.dt_last_update IS NULL)) OR
                                --
                                (a.id_prof_review <> b.id_prof_review OR
                                (a.id_prof_review IS NULL AND b.id_prof_review IS NOT NULL) OR
                                (a.id_prof_review IS NOT NULL AND b.id_prof_review IS NULL)) OR
                                --
                                (a.dt_review <> b.dt_review OR (a.dt_review IS NULL AND b.dt_review IS NOT NULL) OR
                                (a.dt_review IS NOT NULL AND b.dt_review IS NULL))
                                --
                                ))
            LOOP
            
                l_validation_type := 2;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec1.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec1.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
            --the ones that are missing
            FOR rec2 IN (SELECT tt_ea_t.id_task_refid id_task_refid_tmp, tt_ea_t.id_tl_task id_tl_task_tmp
                           FROM task_timeline_ea_tmp tt_ea_t
                          WHERE NOT EXISTS (SELECT 0
                                   FROM task_timeline_ea tt_ea
                                  WHERE tt_ea.id_task_refid = tt_ea_t.id_task_refid
                                    AND tt_ea.id_tl_task = tt_ea_t.id_tl_task))
            LOOP
            
                l_validation_type := 1;
            
                IF NOT ins_invalid_record(i_ea_table_name       => g_task_tl_table_name,
                                          i_id_pk_1_value       => rec2.id_task_refid_tmp,
                                          i_id_pk_1_col_name    => g_task_tl_column_pk1,
                                          i_id_pk_2_value       => rec2.id_tl_task_tmp,
                                          i_id_pk_2_col_name    => g_task_tl_column_pk2,
                                          i_id_pk_3_value       => NULL,
                                          i_id_pk_3_col_name    => NULL,
                                          i_id_pk_4_value       => NULL,
                                          i_id_pk_4_col_name    => NULL,
                                          i_dt_validation       => l_current_timestamp,
                                          i_validation_type     => l_validation_type,
                                          i_in_patient          => i_patient,
                                          i_in_episode          => i_episode,
                                          i_in_schedule         => i_schedule,
                                          i_in_external_request => i_external_request,
                                          i_in_institution      => i_institution,
                                          i_in_start_dt         => i_start_dt,
                                          i_in_end_dt           => i_end_dt)
                THEN
                
                    RAISE e_internal;
                END IF;
            
                l_count_invalid := l_count_invalid + 1;
            
            END LOOP;
        
        END IF;
    
        IF i_recreate_table
           AND i_validate_table
        THEN
            --merge of invalid records
            MERGE INTO task_timeline_ea tt_ea
            USING (SELECT *
                     FROM task_timeline_ea_tmp tt_ea_tmp
                    WHERE EXISTS (SELECT 0
                             FROM data_gov_invalid_recs dgir
                            WHERE dgir.id_pk_1_value = tt_ea_tmp.id_task_refid
                              AND dgir.id_pk_2_value = pk_prog_notes_constants.g_task_icf
                              AND dgir.ea_table_name = g_task_tl_table_name
                              AND dgir.dt_validation = l_current_timestamp)) t
            ON (tt_ea.id_task_refid = t.id_task_refid AND tt_ea.id_tl_task = t.id_tl_task AND tt_ea.table_name = t.table_name)
            WHEN MATCHED THEN
                UPDATE
                   SET tt_ea.id_patient        = t.id_patient,
                       tt_ea.id_episode        = t.id_episode,
                       tt_ea.id_visit          = t.id_visit,
                       tt_ea.id_institution    = t.id_institution,
                       tt_ea.dt_req            = t.dt_req,
                       tt_ea.id_prof_req       = t.id_prof_req,
                       tt_ea.dt_begin          = t.dt_begin,
                       tt_ea.dt_end            = t.dt_end,
                       tt_ea.flg_status_req    = t.flg_status_req,
                       tt_ea.dt_dg_last_update = l_current_timestamp,
                       tt_ea.flg_outdated      = t.flg_outdated,
                       tt_ea.flg_ongoing       = t.flg_ongoing,
                       tt_ea.flg_normal        = t.flg_normal,
                       tt_ea.id_prof_exec      = t.id_prof_exec,
                       tt_ea.flg_has_comments  = t.flg_has_comments,
                       tt_ea.dt_last_update    = t.dt_last_update,
                       tt_ea.id_prof_review    = t.id_prof_review,
                       tt_ea.dt_review         = t.dt_review,
                       tt_ea.rank              = t.rank
                 WHERE tt_ea.id_task_refid = t.id_task_refid
                   AND tt_ea.id_tl_task = t.id_tl_task
                   AND tt_ea.table_name = t.table_name
            WHEN NOT MATCHED THEN
                INSERT
                    (id_task_refid,
                     id_tl_task,
                     id_patient,
                     id_episode,
                     id_visit,
                     id_institution,
                     dt_req,
                     id_prof_req,
                     dt_begin,
                     dt_end,
                     flg_status_req,
                     table_name,
                     flg_show_method,
                     dt_dg_last_update,
                     flg_outdated,
                     flg_ongoing,
                     flg_normal,
                     id_prof_exec,
                     flg_has_comments,
                     dt_last_update,
                     id_prof_review,
                     dt_review,
                     rank,
                     code_desc_group,
                     code_status,
                     flg_sos,
                     dt_last_execution)
                VALUES
                    (t.id_task_refid,
                     t.id_tl_task,
                     t.id_patient,
                     t.id_episode,
                     t.id_visit,
                     t.id_institution,
                     t.dt_req,
                     t.id_prof_req,
                     t.dt_begin,
                     t.dt_end,
                     t.flg_status_req,
                     t.table_name,
                     t.flg_show_method,
                     l_current_timestamp,
                     t.flg_outdated,
                     t.flg_ongoing,
                     t.flg_normal,
                     t.id_prof_exec,
                     t.flg_has_comments,
                     t.dt_last_update,
                     t.id_prof_review,
                     t.dt_review,
                     t.rank,
                     t.code_desc_group,
                     t.code_status,
                     t.flg_sos,
                     t.dt_last_execution);
        
        END IF;
    
        --delete records from temporary table
        DELETE FROM task_timeline_ea_tmp;
    
        --delete last validation's records
        DELETE FROM data_gov_invalid_recs dgir
         WHERE dgir.ea_table_name = g_task_tl_table_name
           AND dgir.dt_validation < l_current_timestamp;
    
        IF i_output_invalid_records
        THEN
        
            dbms_output.put_line('ADMIN_TASK_TL_REHAB_DIAG - OK: ' || l_count || ' inserted records');
            dbms_output.put_line('ADMIN_TASK_TL_REHAB_DIAG - OK: ' || l_count_invalid || ' inserted invalid records');
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN e_internal THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'Internal error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_DIAG',
                                              l_error);
        
            RETURN FALSE;
        WHEN e_external THEN
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
            pk_alert_exceptions.process_error(g_log_lang,
                                              '-20001',
                                              'External error. Check table alertlog.tlog for error details.',
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_DIAG',
                                              l_error);
        
            RETURN FALSE;
        
        WHEN OTHERS THEN
        
            --delete records from temporary table
            DELETE FROM task_timeline_ea_tmp;
        
            pk_alert_exceptions.process_error(g_log_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              NULL,
                                              g_package_owner,
                                              g_package_name,
                                              'ADMIN_TASK_TL_REHAB_DIAG',
                                              l_error);
        
            RETURN FALSE;
    END admin_task_tl_rehab_diag;

BEGIN
    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);
END pk_data_gov_admin;
/
