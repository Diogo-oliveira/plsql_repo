/*-- Last Change Revision: $Rev: 2005972 $*/
/*-- Last Change by: $Author: diogo.oliveira $*/
/*-- Date of last change: $Date: 2022-01-20 16:59:36 +0000 (qui, 20 jan 2022) $*/

CREATE OR REPLACE PACKAGE BODY pk_nnn_api_db IS

    -- Private type declarations

    -- Private constant declarations

    --Adjust a recurrence plan by recalculating the planned date for the upcoming executions/evaluations according to a configuration.
    g_adjust_current_plan_by_date CONSTANT VARCHAR2(1 CHAR) := 'C';

    --Adjust a recurrence by creating the upcoming executions/evaluations according a new plan.
    g_adjust_new_plan CONSTANT VARCHAR2(1 CHAR) := 'N';

    k_bullet_char CONSTANT VARCHAR2(10 CHAR) := '&#8226; ';

    g_vital_sign_read_list_delim CONSTANT VARCHAR2(1 CHAR) := '|';
    -- Private variable declarations

    /* CAN'T TOUCH THIS */
    g_error   VARCHAR2(1000 CHAR);
    g_owner   VARCHAR2(30 CHAR);
    g_package VARCHAR2(30 CHAR);

    -- Function and procedure implementations

    PROCEDURE create_outcome_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_outcome_recurrence';
    
        -- returns outdated outcome evaluation plans
        CURSOR c_epis_outcome_plan_outdated(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT t.id_order_recurrence_plan
              FROM nnn_epis_outcome eo
             RIGHT JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = eo.id_order_recurr_plan)
             WHERE eo.flg_req_status NOT IN -- plans that are NOT ordered nor in-progress (are outdated)
                   (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing);
    
        -- returns outcome evaluation plans that are ordered or active 
        CURSOR c_epis_outcome_plan_active(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT eo.id_nnn_epis_outcome,
                   eo.id_patient,
                   eo.id_professional,
                   eo.id_episode,
                   eo.id_episode_destination,
                   eo.flg_time,
                   t.id_order_recurrence_plan,
                   t.exec_number,
                   t.exec_timestamp dt_plan
              FROM nnn_epis_outcome eo
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = eo.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = eo.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE eo.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        CURSOR c_state_visit(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT v.flg_status
              FROM nnn_epis_outcome eo
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = eo.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = eo.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE eo.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        TYPE t_epis_outcome_plans_active IS TABLE OF c_epis_outcome_plan_active%ROWTYPE;
        l_epis_outcome_plans_active t_epis_outcome_plans_active;
        l_plans_outdated            table_number := table_number();
        l_plans_processed           table_number := table_number();
        l_lst_rowid                 table_varchar;
    
        l_rec       nnn_epis_outcome_eval%ROWTYPE;
        l_lst_rec   ts_nnn_epis_outcome_eval.nnn_epis_outcome_eval_tc;
        l_error     t_error_out;
        l_timestamp TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_status_visit visit.flg_status%TYPE;
    
    BEGIN
        l_timestamp := coalesce(i_timestamp, current_timestamp);
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            RETURN;
        END IF;
    
        OPEN c_state_visit(i_exec_tab);
        FETCH c_state_visit
            INTO l_status_visit;
        CLOSE c_state_visit;
    
        IF l_status_visit != pk_visit.g_active
        THEN
            RETURN;
        END IF;
    
        g_error := 'i_exec_tab.COUNT=' || i_exec_tab.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        -- Getting outdated plans
        OPEN c_epis_outcome_plan_outdated(i_exec_tab);
        FETCH c_epis_outcome_plan_outdated BULK COLLECT
            INTO l_plans_outdated;
        CLOSE c_epis_outcome_plan_outdated;
    
        -- Getting active plans
        OPEN c_epis_outcome_plan_active(i_exec_tab);
        FETCH c_epis_outcome_plan_active BULK COLLECT
            INTO l_epis_outcome_plans_active;
        CLOSE c_epis_outcome_plan_active;
    
        <<req>>
        FOR req_idx IN 1 .. l_epis_outcome_plans_active.count
        LOOP
            g_error := 'Processing ';
            g_error := g_error || ' id_nnn_epis_outcome = ' || l_epis_outcome_plans_active(req_idx).id_nnn_epis_outcome;
            g_error := g_error || ' i_num_order = ' || l_epis_outcome_plans_active(req_idx).exec_number;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            l_rec.id_nnn_epis_outcome_eval := ts_nnn_epis_outcome_eval.next_key();
            l_rec.id_nnn_epis_outcome      := l_epis_outcome_plans_active(req_idx).id_nnn_epis_outcome;
            l_rec.id_patient               := l_epis_outcome_plans_active(req_idx).id_patient;
            l_rec.id_episode := CASE
                                    WHEN l_epis_outcome_plans_active(req_idx).flg_time = pk_nnn_constant.g_time_performed_episode THEN
                                     l_epis_outcome_plans_active(req_idx).id_episode
                                    ELSE
                                     l_epis_outcome_plans_active(req_idx).id_episode_destination
                                END;
            l_rec.id_visit                 := pk_visit.get_visit(i_episode => l_rec.id_episode, o_error => l_error);
            l_rec.id_professional := CASE
                                         WHEN i_prof.id IS NULL THEN
                                          l_epis_outcome_plans_active(req_idx).id_professional
                                         ELSE
                                          i_prof.id
                                     END;
            l_rec.dt_plan                  := l_epis_outcome_plans_active(req_idx).dt_plan;
            l_rec.id_order_recurr_plan     := l_epis_outcome_plans_active(req_idx).id_order_recurrence_plan;
            l_rec.flg_status               := pk_nnn_constant.g_task_status_ordered;
            l_rec.dt_trs_time_start        := l_timestamp;
            l_rec.dt_trs_time_end          := NULL;
            l_rec.exec_number              := l_epis_outcome_plans_active(req_idx).exec_number;
        
            l_lst_rec(req_idx) := l_rec;
        
            -- plans processed
            l_plans_processed.extend;
            l_plans_processed(l_plans_processed.count) := l_epis_outcome_plans_active(req_idx).id_order_recurrence_plan;
        
        END LOOP req;
    
        g_error := 'Inserting in NNN_EPIS_OUTCOME_EVAL ' || to_char(l_lst_rec.count()) || ' rows';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        ts_nnn_epis_outcome_eval.ins(rows_in => l_lst_rec, rows_out => l_lst_rowid);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'NNN_EPIS_OUTCOME_EVAL',
                                      i_rowids     => l_lst_rowid,
                                      o_error      => l_error);
    
        g_error := 'Processed ';
        g_error := g_error || ' l_plans_oudated.count = ' || l_plans_outdated.count;
        g_error := g_error || ' l_plans_processed.count = ' || l_plans_processed.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        SELECT t_rec_order_recurr_plan_sts(column_value, flg_status)
          BULK COLLECT
          INTO o_exec_to_process
          FROM (
                -- plans processed
                SELECT column_value, pk_alert_constant.g_yes flg_status
                  FROM TABLE(CAST(l_plans_processed AS table_number))
                UNION
                -- plans outdated minus (plans processed intersect plans outdated)
                SELECT t.*, pk_alert_constant.g_no flg_status
                  FROM (SELECT *
                           FROM TABLE(CAST(l_plans_outdated AS table_number))
                         MINUS (SELECT *
                                 FROM TABLE(CAST(l_plans_outdated AS table_number))
                               INTERSECT
                               SELECT *
                                 FROM TABLE(CAST(l_plans_processed AS table_number)))) t);
    
    END create_outcome_recurrence;

    FUNCTION create_outcome_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_outcome_recurrence';
    
    BEGIN
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            DECLARE
                l_err_id PLS_INTEGER;
            BEGIN
                g_error := 'The table with the recurrence information (i_exec_tab) given as input argument is empty';
                pk_alert_exceptions.register_error(error_name_in       => 'e_invalid_argument',
                                                   err_instance_id_out => l_err_id,
                                                   text_in             => g_error,
                                                   name1_in            => 'function_name',
                                                   value1_in           => k_function_name);
                RAISE pk_nnn_constant.e_invalid_argument;
            END;
        END IF;
    
        create_outcome_recurrence(i_lang            => i_lang,
                                  i_prof            => i_prof,
                                  i_exec_tab        => i_exec_tab,
                                  i_timestamp       => i_timestamp,
                                  o_exec_to_process => o_exec_to_process);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              k_function_name,
                                              o_error);
            RETURN FALSE;
    END create_outcome_recurrence;

    PROCEDURE create_indicator_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_indicator_recurrence';
    
        -- returns outdated indicator evaluation plans
        CURSOR c_epis_ind_plan_outdated(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT t.id_order_recurrence_plan
              FROM nnn_epis_indicator ei
             RIGHT JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ei.id_order_recurr_plan)
             WHERE ei.flg_req_status NOT IN -- plans that are NOT ordered nor in-progress (are outdated)
                   (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing);
    
        -- returns indicator evaluation plans that are ordered or active 
        CURSOR c_epis_ind_plan_active(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT ei.id_nnn_epis_indicator,
                   ei.id_patient,
                   ei.id_professional,
                   ei.id_episode,
                   ei.id_episode_destination,
                   ei.flg_time,
                   t.id_order_recurrence_plan,
                   t.exec_number,
                   t.exec_timestamp dt_plan
              FROM nnn_epis_indicator ei
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ei.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = ei.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE ei.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        CURSOR c_state_visit(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT v.flg_status
              FROM nnn_epis_indicator ei
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ei.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = ei.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE ei.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        TYPE t_epis_indicator_plans_active IS TABLE OF c_epis_ind_plan_active%ROWTYPE;
        l_epis_indicator_plans_active t_epis_indicator_plans_active;
        l_error                       t_error_out;
        l_plans_outdated              table_number := table_number();
        l_plans_processed             table_number := table_number();
        l_lst_rowid                   table_varchar;
        l_rec                         nnn_epis_ind_eval %ROWTYPE;
        l_lst_rec                     ts_nnn_epis_ind_eval.nnn_epis_ind_eval_tc;
        l_timestamp                   TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_status_visit visit.flg_status%TYPE;
    
    BEGIN
        l_timestamp := coalesce(i_timestamp, current_timestamp);
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            RETURN;
        END IF;
    
        OPEN c_state_visit(i_exec_tab);
        FETCH c_state_visit
            INTO l_status_visit;
        CLOSE c_state_visit;
    
        IF l_status_visit != pk_visit.g_active
        THEN
            RETURN;
        END IF;
    
        g_error := 'i_exec_tab.COUNT=' || i_exec_tab.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        -- Getting outdated plans
        OPEN c_epis_ind_plan_outdated(i_exec_tab);
        FETCH c_epis_ind_plan_outdated BULK COLLECT
            INTO l_plans_outdated;
        CLOSE c_epis_ind_plan_outdated;
    
        -- Getting active plans
        OPEN c_epis_ind_plan_active(i_exec_tab);
        FETCH c_epis_ind_plan_active BULK COLLECT
            INTO l_epis_indicator_plans_active;
        CLOSE c_epis_ind_plan_active;
    
        <<req>>
        FOR req_idx IN 1 .. l_epis_indicator_plans_active.count
        LOOP
            g_error := 'Processing ';
            g_error := g_error || ' id_nnn_epis_indicator = ' || l_epis_indicator_plans_active(req_idx).id_nnn_epis_indicator;
            g_error := g_error || ' i_num_order = ' || l_epis_indicator_plans_active(req_idx).exec_number;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            l_rec.id_nnn_epis_ind_eval  := ts_nnn_epis_ind_eval.next_key();
            l_rec.id_nnn_epis_indicator := l_epis_indicator_plans_active(req_idx).id_nnn_epis_indicator;
            l_rec.id_patient            := l_epis_indicator_plans_active(req_idx).id_patient;
            l_rec.id_episode := CASE
                                    WHEN l_epis_indicator_plans_active(req_idx)
                                     .flg_time = pk_nnn_constant.g_time_performed_episode THEN
                                     l_epis_indicator_plans_active(req_idx).id_episode
                                    ELSE
                                     l_epis_indicator_plans_active(req_idx).id_episode_destination
                                END;
            l_rec.id_visit              := pk_visit.get_visit(i_episode => l_rec.id_episode, o_error => l_error);
        
            l_rec.id_professional := CASE
                                         WHEN i_prof.id IS NULL THEN
                                          l_epis_indicator_plans_active(req_idx).id_professional
                                         ELSE
                                          i_prof.id
                                     END;
            l_rec.dt_plan              := l_epis_indicator_plans_active(req_idx).dt_plan;
            l_rec.id_order_recurr_plan := l_epis_indicator_plans_active(req_idx).id_order_recurrence_plan;
            l_rec.flg_status           := pk_nnn_constant.g_task_status_ordered;
            l_rec.dt_trs_time_start    := l_timestamp;
            l_rec.dt_trs_time_end      := NULL;
            l_rec.exec_number          := l_epis_indicator_plans_active(req_idx).exec_number;
        
            l_lst_rec(req_idx) := l_rec;
        
            -- plans processed
            l_plans_processed.extend;
            l_plans_processed(l_plans_processed.count) := l_epis_indicator_plans_active(req_idx).id_order_recurrence_plan;
        
        END LOOP req;
    
        g_error := 'Inserting in NNN_EPIS_IND_EVAL ' || to_char(l_lst_rec.count()) || ' rows';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        ts_nnn_epis_ind_eval.ins(rows_in => l_lst_rec, rows_out => l_lst_rowid);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'NNN_EPIS_IND_EVAL',
                                      i_rowids     => l_lst_rowid,
                                      o_error      => l_error);
    
        g_error := 'Processed ';
        g_error := g_error || ' l_plans_oudated.count = ' || l_plans_outdated.count;
        g_error := g_error || ' l_plans_processed.count = ' || l_plans_processed.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        SELECT t_rec_order_recurr_plan_sts(column_value, flg_status)
          BULK COLLECT
          INTO o_exec_to_process
          FROM (
                -- plans processed
                SELECT column_value, pk_alert_constant.g_yes flg_status
                  FROM TABLE(CAST(l_plans_processed AS table_number))
                UNION
                -- plans outdated minus (plans processed intersect plans outdated)
                SELECT t.*, pk_alert_constant.g_no flg_status
                  FROM (SELECT *
                           FROM TABLE(CAST(l_plans_outdated AS table_number))
                         MINUS (SELECT *
                                 FROM TABLE(CAST(l_plans_outdated AS table_number))
                               INTERSECT
                               SELECT *
                                 FROM TABLE(CAST(l_plans_processed AS table_number)))) t);
    
    END create_indicator_recurrence;

    FUNCTION create_indicator_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_indicator_recurrence';
    
    BEGIN
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            DECLARE
                l_err_id PLS_INTEGER;
            BEGIN
                g_error := 'The table with the recurrence information (i_exec_tab) given as input argument is empty';
                pk_alert_exceptions.register_error(error_name_in       => 'e_invalid_argument',
                                                   err_instance_id_out => l_err_id,
                                                   text_in             => g_error,
                                                   name1_in            => 'function_name',
                                                   value1_in           => k_function_name);
                RAISE pk_nnn_constant.e_invalid_argument;
            END;
        END IF;
    
        create_indicator_recurrence(i_lang            => i_lang,
                                    i_prof            => i_prof,
                                    i_exec_tab        => i_exec_tab,
                                    i_timestamp       => i_timestamp,
                                    o_exec_to_process => o_exec_to_process);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              k_function_name,
                                              o_error);
            RETURN FALSE;
    END create_indicator_recurrence;

    PROCEDURE create_activity_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_activity_recurrence';
    
        -- returns outdated activity execution plans
        CURSOR c_epis_activity_plan_outdated(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT t.id_order_recurrence_plan
              FROM nnn_epis_activity ea
             RIGHT JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ea.id_order_recurr_plan)
             WHERE ea.flg_req_status NOT IN -- plans that are NOT ordered nor in-progress (are outdated)
                   (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing);
    
        -- returns indicator evaluation plans that are ordered or active 
        CURSOR c_epis_activity_plan_active(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT ea.id_nnn_epis_activity,
                   ea.id_patient,
                   ea.id_professional,
                   ea.id_episode,
                   ea.id_episode_destination,
                   ea.flg_time,
                   t.id_order_recurrence_plan,
                   t.exec_number,
                   t.exec_timestamp dt_plan
              FROM nnn_epis_activity ea
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ea.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = ea.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE ea.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        CURSOR c_state_visit(x_exec_tab IN t_tbl_order_recurr_plan) IS
            SELECT DISTINCT v.flg_status
              FROM nnn_epis_activity ea
              JOIN TABLE(CAST(x_exec_tab AS t_tbl_order_recurr_plan)) t
                ON (t.id_order_recurrence_plan = ea.id_order_recurr_plan)
              JOIN episode e
                ON e.id_episode = ea.id_episode
              JOIN visit v
                ON v.id_visit = e.id_visit
             WHERE ea.flg_req_status IN (pk_nnn_constant.g_req_status_ordered, pk_nnn_constant.g_req_status_ongoing)
               AND v.flg_status = pk_visit.g_active;
    
        TYPE t_epis_activity_plans_active IS TABLE OF c_epis_activity_plan_active%ROWTYPE;
        l_epis_activity_plans_active t_epis_activity_plans_active;
        l_error                      t_error_out;
        l_plans_outdated             table_number := table_number();
        l_plans_processed            table_number := table_number();
        l_lst_rowid                  table_varchar;
        l_rec                        nnn_epis_activity_det%ROWTYPE;
        l_lst_rec                    ts_nnn_epis_activity_det.nnn_epis_activity_det_tc;
        l_timestamp                  TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_status_visit visit.flg_status%TYPE;
    BEGIN
        l_timestamp := coalesce(i_timestamp, current_timestamp);
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            DECLARE
                l_err_id PLS_INTEGER;
            BEGIN
                g_error := 'The table with the recurrence information (i_exec_tab) given as input argument is empty';
                pk_alert_exceptions.register_error(error_name_in       => 'e_invalid_argument',
                                                   err_instance_id_out => l_err_id,
                                                   text_in             => g_error,
                                                   name1_in            => 'function_name',
                                                   value1_in           => k_function_name);
                RAISE pk_nnn_constant.e_invalid_argument;
            END;
        END IF;
    
        OPEN c_state_visit(i_exec_tab);
        FETCH c_state_visit
            INTO l_status_visit;
        CLOSE c_state_visit;
    
        IF l_status_visit != pk_visit.g_active
        THEN
            RETURN;
        END IF;
    
        g_error := 'i_exec_tab.COUNT=' || i_exec_tab.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        -- Getting outdated plans
        OPEN c_epis_activity_plan_outdated(i_exec_tab);
        FETCH c_epis_activity_plan_outdated BULK COLLECT
            INTO l_plans_outdated;
        CLOSE c_epis_activity_plan_outdated;
    
        -- Getting active plans
        OPEN c_epis_activity_plan_active(i_exec_tab);
        FETCH c_epis_activity_plan_active BULK COLLECT
            INTO l_epis_activity_plans_active;
        CLOSE c_epis_activity_plan_active;
    
        <<req>>
        FOR req_idx IN 1 .. l_epis_activity_plans_active.count
        LOOP
            g_error := 'Processing ';
            g_error := g_error || ' id_nnn_epis_activity = ' || l_epis_activity_plans_active(req_idx).id_nnn_epis_activity;
            g_error := g_error || ' i_num_order = ' || l_epis_activity_plans_active(req_idx).exec_number;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            l_rec.id_nnn_epis_activity_det := ts_nnn_epis_activity_det.next_key();
            l_rec.id_nnn_epis_activity     := l_epis_activity_plans_active(req_idx).id_nnn_epis_activity;
            l_rec.id_patient               := l_epis_activity_plans_active(req_idx).id_patient;
            l_rec.id_episode := CASE
                                    WHEN l_epis_activity_plans_active(req_idx)
                                     .flg_time = pk_nnn_constant.g_time_performed_episode THEN
                                     l_epis_activity_plans_active(req_idx).id_episode
                                    ELSE
                                     l_epis_activity_plans_active(req_idx).id_episode_destination
                                END;
            l_rec.id_visit                 := pk_visit.get_visit(i_episode => l_rec.id_episode, o_error => l_error);
        
            l_rec.id_professional := CASE
                                         WHEN i_prof.id IS NULL THEN
                                          l_epis_activity_plans_active(req_idx).id_professional
                                         ELSE
                                          i_prof.id
                                     END;
            l_rec.dt_plan              := l_epis_activity_plans_active(req_idx).dt_plan;
            l_rec.id_order_recurr_plan := l_epis_activity_plans_active(req_idx).id_order_recurrence_plan;
            l_rec.flg_status           := pk_nnn_constant.g_task_status_ordered;
            l_rec.dt_trs_time_start    := l_timestamp;
            l_rec.dt_trs_time_end      := NULL;
            l_rec.exec_number          := l_epis_activity_plans_active(req_idx).exec_number;
        
            l_lst_rec(req_idx) := l_rec;
        
            -- plans processed
            l_plans_processed.extend;
            l_plans_processed(l_plans_processed.count) := l_epis_activity_plans_active(req_idx).id_order_recurrence_plan;
        
        END LOOP req;
    
        g_error := 'Inserting in NNN_EPIS_ACTIVITY_DET ' || to_char(l_lst_rec.count()) || ' rows';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        ts_nnn_epis_activity_det.ins(rows_in => l_lst_rec, rows_out => l_lst_rowid);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'NNN_EPIS_ACTIVITY_DET',
                                      i_rowids     => l_lst_rowid,
                                      o_error      => l_error);
    
        g_error := 'Processed ';
        g_error := g_error || ' l_plans_oudated.count = ' || l_plans_outdated.count;
        g_error := g_error || ' l_plans_processed.count = ' || l_plans_processed.count;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        SELECT t_rec_order_recurr_plan_sts(column_value, flg_status)
          BULK COLLECT
          INTO o_exec_to_process
          FROM (
                -- plans processed
                SELECT column_value, pk_alert_constant.g_yes flg_status
                  FROM TABLE(CAST(l_plans_processed AS table_number))
                UNION
                -- plans outdated minus (plans processed intersect plans outdated)
                SELECT t.*, pk_alert_constant.g_no flg_status
                  FROM (SELECT *
                           FROM TABLE(CAST(l_plans_outdated AS table_number))
                         MINUS (SELECT *
                                 FROM TABLE(CAST(l_plans_outdated AS table_number))
                               INTERSECT
                               SELECT *
                                 FROM TABLE(CAST(l_plans_processed AS table_number)))) t);
    
    END create_activity_recurrence;

    FUNCTION create_activity_recurrence
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_exec_tab        IN t_tbl_order_recurr_plan,
        i_timestamp       IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp,
        o_exec_to_process OUT t_tbl_order_recurr_plan_sts,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_activity_recurrence';
    
    BEGIN
        -- Check the input parameters
        IF i_exec_tab IS NULL
           OR i_exec_tab.count = 0
        THEN
            DECLARE
                l_err_id PLS_INTEGER;
            BEGIN
                g_error := 'The table with the recurrence information (i_exec_tab) given as input argument is empty';
                pk_alert_exceptions.register_error(error_name_in       => 'e_invalid_argument',
                                                   err_instance_id_out => l_err_id,
                                                   text_in             => g_error,
                                                   name1_in            => 'function_name',
                                                   value1_in           => k_function_name);
                RAISE pk_nnn_constant.e_invalid_argument;
            END;
        END IF;
    
        create_activity_recurrence(i_lang            => i_lang,
                                   i_prof            => i_prof,
                                   i_exec_tab        => i_exec_tab,
                                   i_timestamp       => i_timestamp,
                                   o_exec_to_process => o_exec_to_process);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              k_function_name,
                                              o_error);
            RETURN FALSE;
    END create_activity_recurrence;

    PROCEDURE create_next_outcome_eval
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_outcome  IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_order_recurr_plan IN nnn_epis_indicator.id_order_recurr_plan%TYPE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_next_outcome_eval';
        l_planned_evals_count PLS_INTEGER;
        l_error               t_error_out;
    
    BEGIN
        IF i_order_recurr_plan IS NOT NULL
        THEN
            -- Gets the number of evaluations currently planned for this NOC Outcome
            l_planned_evals_count := pk_nnn_core.get_outcome_planned_eval_count(i_nnn_epis_outcome => i_nnn_epis_outcome);
        
            -- Creates a next evaluation in the plan table (if needed)
            IF NOT pk_order_recurrence_api_db.set_active_executions(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => i_order_recurr_plan,
                                                                    i_active_executions => l_planned_evals_count,
                                                                    o_error             => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ACTIVE_EXECUTIONS';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END create_next_outcome_eval;

    PROCEDURE create_next_indicator_eval
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE,
        i_order_recurr_plan  IN nnn_epis_indicator.id_order_recurr_plan%TYPE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_next_indicator_eval';
        l_planned_execs_count PLS_INTEGER;
        l_error               t_error_out;
    
    BEGIN
        IF i_order_recurr_plan IS NOT NULL
        THEN
            -- Gets the number of evaluations currently planned for this NOC Indicator
            l_planned_execs_count := pk_nnn_core.get_ind_planned_eval_count(i_nnn_epis_indicator => i_nnn_epis_indicator);
        
            -- Creates a next execution in the plan table (if needed)
            IF NOT pk_order_recurrence_api_db.set_active_executions(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => i_order_recurr_plan,
                                                                    i_active_executions => l_planned_execs_count,
                                                                    o_error             => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ACTIVE_EXECUTIONS';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END create_next_indicator_eval;

    PROCEDURE create_next_activity_eval
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_order_recurr_plan IN nnn_epis_activity.id_order_recurr_plan%TYPE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_next_activity_eval';
        l_planned_execs_count PLS_INTEGER;
        l_error               t_error_out;
    
    BEGIN
        IF i_order_recurr_plan IS NOT NULL
        THEN
            -- Gets the number of evaluations currently planned for this NOC Indicator
            l_planned_execs_count := pk_nnn_core.get_activity_planned_exe_count(i_nnn_epis_activity => i_nnn_epis_activity);
        
            -- Creates a next execution in the plan table (if needed)
            IF NOT pk_order_recurrence_api_db.set_active_executions(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => i_order_recurr_plan,
                                                                    i_active_executions => l_planned_execs_count,
                                                                    o_error             => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ACTIVE_EXECUTIONS';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END create_next_activity_eval;

    -- Prepares the order recurrence plans for NOC Outcomes and creates the first set of planned evaluations
    PROCEDURE prepare_create_outcome_plan
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_lst_order_rec_plan IN table_number,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'prepare_and_create_outcome_evl';
        l_error           t_error_out;
        l_order_plan_exec t_tbl_order_recurr_plan;
        l_exec_to_process t_tbl_order_recurr_plan_sts;
    BEGIN
        -----
        -- Create the executions for all the requests that have a recurrence plan
        IF i_lst_order_rec_plan IS NOT empty
        THEN
            -- Prepare the order plan executions
            IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang            => i_lang,
                                                                        i_prof            => i_prof,
                                                                        i_order_plan      => i_lst_order_rec_plan,
                                                                        o_order_plan_exec => l_order_plan_exec,
                                                                        o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
            -- Create the first set of executions the set is determined by the recurrence mechanism
            IF NOT pk_nnn_api_db.create_outcome_recurrence(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_exec_tab        => l_order_plan_exec,
                                                           i_timestamp       => i_timestamp,
                                                           o_exec_to_process => l_exec_to_process,
                                                           o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_NNN_API_DB.CREATE_OUTCOME_RECURRENCE';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END prepare_create_outcome_plan;

    -- Prepares the order recurrence plans for NOC Indicators and creates the first set of planned evaluations
    PROCEDURE prepare_create_indicator_plan
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_lst_order_rec_plan IN table_number,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'prepare_and_create_outcome_evl';
        l_error           t_error_out;
        l_order_plan_exec t_tbl_order_recurr_plan;
        l_exec_to_process t_tbl_order_recurr_plan_sts;
    BEGIN
        -----
        -- Create the executions for all the requests that have a recurrence plan
        IF i_lst_order_rec_plan IS NOT empty
        THEN
            -- Prepare the order plan executions
            IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang            => i_lang,
                                                                        i_prof            => i_prof,
                                                                        i_order_plan      => i_lst_order_rec_plan,
                                                                        o_order_plan_exec => l_order_plan_exec,
                                                                        o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
            -- Create the first set of executions the set is determined by the recurrence mechanism
            IF NOT pk_nnn_api_db.create_indicator_recurrence(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_exec_tab        => l_order_plan_exec,
                                                             i_timestamp       => i_timestamp,
                                                             o_exec_to_process => l_exec_to_process,
                                                             o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_NNN_API_DB.CREATE_INDICATOR_RECURRENCE';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END prepare_create_indicator_plan;

    --Prepares the order recurrence plans for NIC Activities and creates the first set of planned executions
    PROCEDURE prepare_create_activity_plan
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_lst_order_rec_plan IN table_number,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'prepare_and_create_outcome_evl';
        l_error           t_error_out;
        l_order_plan_exec t_tbl_order_recurr_plan;
        l_exec_to_process t_tbl_order_recurr_plan_sts;
    BEGIN
        -----
        -- Create the executions for all the requests that have a recurrence plan
        IF i_lst_order_rec_plan IS NOT empty
        THEN
            -- Prepare the order plan executions
            IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang            => i_lang,
                                                                        i_prof            => i_prof,
                                                                        i_order_plan      => i_lst_order_rec_plan,
                                                                        o_order_plan_exec => l_order_plan_exec,
                                                                        o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
            -- Create the first set of executions the set is determined by the recurrence mechanism
            IF NOT pk_nnn_api_db.create_activity_recurrence(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_exec_tab        => l_order_plan_exec,
                                                            i_timestamp       => i_timestamp,
                                                            o_exec_to_process => l_exec_to_process,
                                                            o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_NNN_API_DB.CREATE_ACTITY_RECURRENCE';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END prepare_create_activity_plan;

    /**
    * Recalculates the plan of evaluations/executions of a given item request (Outcome/Indicator/Activity)
    *
    * @param    i_lang                     Professional preferred language
    * @param    i_prof                     Professional identification and its context (institution and software)
    * @param    i_flg_type                 Item type to with refer the i_req_item_id
    * @param    i_flg_adjust_mode          Approach to adjust the plan: adjust the remain plan by execution date or use a new plan.
    * @param    i_req_item_id              Item request ID (id_nnn_epis_outcome, id_nnn_epis_indicator, id_nnn_epis_activity)
    * @param    i_order_recurr_plan        Order recurrence plan ID
    * @param    i_execution_timestamp      When i_flg_adjust_mode = g_adjust_current_plan_by_date, timestamp that identifies the moment in time when the planned evaluation/execution was effectively performed
    * @param    i_timestamp                Timestamp that should be used across all the functions invoked from this one. Default to use current_timestamp
    *
    * @value    i_flg_type {*} pk_nnn_constant.g_type_outcome  
    *                      {*} pk_nnn_constant.g_type_indicator  
    *                      {*} pk_nnn_constant.g_type_activity
    *                       
    * @value    i_flg_adjust_mode {*} g_adjust_current_plan_by_date 
    *                              Evaluates the configuration 'NURSING_CARE_PLAN_NEXT_START_DATE' to adjust the planned date and the execution number of all of them that weren't yet executed.
    *                              This configuration can take two possible values
    *                              PLANNED_DATE: when an evaluation/execution is made, the plan remains as planned (no changes are made).
    *                              SYSTEM_DATE: when an evaluation/execution is made, the plan is reajusted; the next executions are recalculated based on the evaluation/execution date.
    *                             {*} g_adjust_new_plan 
    *                             Adjust by creating the executions of a new recurrence plan.
    *
    * @author   ARIEL.MACHADO
    * @version  2.6.4.3  
    * @since    5/12/2014
    */
    PROCEDURE recalculate_plan
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_flg_type            IN VARCHAR2,
        i_flg_adjust_mode     IN VARCHAR2,
        i_req_item_id         IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_order_recurr_plan   IN nnn_epis_activity.id_order_recurr_plan%TYPE,
        i_execution_timestamp IN nnn_epis_activity_det.dt_val_time_start%TYPE,
        i_timestamp           IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'recalculate_plan';
        l_plan_calc_mode    sys_config.value%TYPE;
        l_exec_num_recurr   nnn_epis_activity_det.exec_number%TYPE;
        l_order_recurr_plan order_recurr_plan.id_order_recurr_plan%TYPE;
        l_exec_to_process   t_tbl_order_recurr_plan_sts;
        l_exec_plan_all     t_tbl_order_recurr_plan;
        l_lst_rowid         table_varchar;
        l_error             t_error_out;
    BEGIN
    
        CASE i_flg_adjust_mode
        
            WHEN g_adjust_current_plan_by_date THEN
            
                -- We only need to make changes to the plan when the calc mode is based
                -- in the execution date and there is a recurrence plan 
                l_plan_calc_mode := pk_sysconfig.get_config(i_code_cf => pk_nnn_constant.g_config_plan_calc_mode,
                                                            i_prof    => i_prof);
                IF l_plan_calc_mode = pk_nnn_constant.g_plan_calc_mode_planned_date
                   OR i_order_recurr_plan IS NULL
                THEN
                    RETURN;
                END IF;
            
                -- Count the number of performed and cancelled evaluations/executions.
                CASE i_flg_type
                    WHEN pk_nnn_constant.g_type_outcome THEN
                        BEGIN
                            SELECT COUNT(1)
                              INTO l_exec_num_recurr
                              FROM nnn_epis_outcome_eval neoe
                             WHERE neoe.id_nnn_epis_outcome = i_req_item_id
                               AND neoe.id_order_recurr_plan = i_order_recurr_plan
                               AND neoe.flg_status IN
                                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_finished);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exec_num_recurr := 0;
                        END;
                    WHEN pk_nnn_constant.g_type_indicator THEN
                        BEGIN
                            SELECT COUNT(1)
                              INTO l_exec_num_recurr
                              FROM nnn_epis_ind_eval neie
                             WHERE neie.id_nnn_epis_indicator = i_req_item_id
                               AND neie.id_order_recurr_plan = i_order_recurr_plan
                               AND neie.flg_status IN
                                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_finished);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exec_num_recurr := 0;
                        END;
                    WHEN pk_nnn_constant.g_type_activity THEN
                        BEGIN
                            SELECT COUNT(1)
                              INTO l_exec_num_recurr
                              FROM nnn_epis_activity_det nead
                             WHERE nead.id_nnn_epis_activity = i_req_item_id
                               AND nead.id_order_recurr_plan = i_order_recurr_plan
                               AND nead.flg_status IN
                                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_finished);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_exec_num_recurr := 0;
                        END;
                    ELSE
                        RAISE pk_nnn_constant.e_invalid_argument;
                END CASE;
            
                -- Get the updated plan
                IF NOT pk_order_recurrence_api_db.update_execution_plan(i_lang                => i_lang,
                                                                        i_prof                => i_prof,
                                                                        i_order_recurr_plan   => i_order_recurr_plan,
                                                                        i_execution_number    => l_exec_num_recurr,
                                                                        i_execution_timestamp => i_execution_timestamp,
                                                                        i_flg_need_new_plan   => pk_alert_constant.g_no,
                                                                        o_order_plan_exec     => l_exec_plan_all,
                                                                        o_order_recurr_plan   => l_order_recurr_plan,
                                                                        o_error               => l_error)
                THEN
                    g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.UPDATE_EXECUTION_PLAN';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
            WHEN g_adjust_new_plan THEN
                -- Prepare the executions of a new recurrence plan
                IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang            => i_lang,
                                                                            i_prof            => i_prof,
                                                                            i_order_plan      => table_number(i_order_recurr_plan),
                                                                            o_order_plan_exec => l_exec_plan_all,
                                                                            o_error           => l_error)
                THEN
                    g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
            ELSE
                g_error := 'The input parameter i_adjust_mode has an unexpected value: ' || i_flg_adjust_mode;
                RAISE pk_nnn_constant.e_invalid_argument;
        END CASE;
    
        -- Recreate the evaluations/executions using the new settings
        CASE i_flg_type
            WHEN pk_nnn_constant.g_type_outcome THEN
            
                -- Delete all the planned Outcome evaluations with the status "ordered"; they will be recreated
                ts_nnn_epis_outcome_eval.del_by(where_clause_in => 'id_nnn_epis_outcome = ' || i_req_item_id ||
                                                                   ' AND flg_status = ''' ||
                                                                   pk_nnn_constant.g_task_status_ordered || '''',
                                                rows_out        => l_lst_rowid);
            
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'NNN_EPIS_OUTCOME_EVAL',
                                              i_rowids     => l_lst_rowid,
                                              o_error      => l_error);
            
                -- Recreate the outcome evaluations with the new settings
                create_outcome_recurrence(i_lang            => i_lang,
                                          i_prof            => i_prof,
                                          i_exec_tab        => l_exec_plan_all,
                                          i_timestamp       => i_timestamp,
                                          o_exec_to_process => l_exec_to_process);
            
            WHEN pk_nnn_constant.g_type_indicator THEN
            
                -- Delete all the planned Indicator evaluations with the status "ordered"; they will be recreated
                ts_nnn_epis_ind_eval.del_by(where_clause_in => 'id_nnn_epis_indicator = ' || i_req_item_id ||
                                                               ' AND flg_status = ''' ||
                                                               pk_nnn_constant.g_task_status_ordered || '''',
                                            rows_out        => l_lst_rowid);
            
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'NNN_EPIS_IND_EVAL',
                                              i_rowids     => l_lst_rowid,
                                              o_error      => l_error);
            
                -- Recreate the indicator evaluations with the new settings
                create_indicator_recurrence(i_lang            => i_lang,
                                            i_prof            => i_prof,
                                            i_exec_tab        => l_exec_plan_all,
                                            i_timestamp       => i_timestamp,
                                            o_exec_to_process => l_exec_to_process);
            
            WHEN pk_nnn_constant.g_type_activity THEN
            
                -- Delete all the planned Activity executions with the status "ordered"; they will be recreated
                ts_nnn_epis_activity_det.del_by(where_clause_in => 'id_nnn_epis_activity = ' || i_req_item_id ||
                                                                   ' AND flg_status = ''' ||
                                                                   pk_nnn_constant.g_task_status_ordered || '''',
                                                rows_out        => l_lst_rowid);
            
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'NNN_EPIS_ACTIVITY_DET',
                                              i_rowids     => l_lst_rowid,
                                              o_error      => l_error);
            
                -- Recreate the indicator evaluations with the new settings
                create_activity_recurrence(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_exec_tab        => l_exec_plan_all,
                                           i_timestamp       => i_timestamp,
                                           o_exec_to_process => l_exec_to_process);
            
            ELSE
                g_error := 'The input parameter i_flg_type has an unexpected value: ' || i_flg_type;
                RAISE pk_nnn_constant.e_invalid_argument;
            
        END CASE;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_invalid_argument THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_invalid_argument',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END recalculate_plan;

    PROCEDURE create_care_plan
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_jsn_careplan IN CLOB
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'create_care_plan';
        l_json_document json_object_t;
        --Hashmap implementation for careplan items.
        -- The ID property as key is used to establish link relationships between careplan's items.
        l_diagnosis    pk_nnn_type.t_nnn_ux_epis_diagnosis_rec;
        l_diag_eval    pk_nnn_type.t_nnn_ux_epis_diag_eval_rec;
        l_outcome      pk_nnn_type.t_nnn_ux_epis_outcome_rec;
        l_outcome_eval pk_nnn_type.t_nnn_ux_epis_outcome_eval_rec;
        l_indicator    pk_nnn_type.t_nnn_ux_epis_indicator_rec;
        l_ind_eval     pk_nnn_type.t_nnn_ux_epis_ind_eval_rec;
        l_intervention pk_nnn_type.t_nnn_ux_epis_intervention_rec;
        l_activity     pk_nnn_type.t_nnn_ux_epis_activity_rec;
        l_instructions pk_nnn_type.t_nnn_ux_instructions_rec;
    
        l_map_diagnoses     pk_nnn_type.t_map_epis_diagnosis;
        l_map_outcomes      pk_nnn_type.t_map_epis_outcome;
        l_map_indicators    pk_nnn_type.t_map_epis_indicator;
        l_map_interventions pk_nnn_type.t_map_epis_intervention;
        l_map_activities    pk_nnn_type.t_map_epis_activity;
    
        l_map_key             pk_nnn_type.t_map_key;
        l_timestamp           TIMESTAMP WITH LOCAL TIME ZONE;
        l_order_recurr_option order_recurr_plan.id_order_recurr_option%TYPE;
        /**
        * set a temporary order recurrence plan as definitive (final status)
        */
        PROCEDURE set_order_recurr_plan
        (
            i_lang                    IN language.id_language%TYPE,
            i_prof                    IN profissional,
            i_order_recurr_plan       IN order_recurr_plan.id_order_recurr_plan%TYPE,
            o_order_recurr_option     OUT order_recurr_plan.id_order_recurr_option%TYPE,
            o_final_order_recurr_plan OUT order_recurr_plan.id_order_recurr_plan%TYPE
        ) IS
            k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_order_recurr_plan';
            l_error t_error_out;
        BEGIN
            IF i_order_recurr_plan IS NOT NULL
            THEN
            
                IF NOT pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                        i_prof                    => i_prof,
                                                                        i_order_recurr_plan       => i_order_recurr_plan,
                                                                        o_order_recurr_option     => o_order_recurr_option,
                                                                        o_final_order_recurr_plan => o_final_order_recurr_plan,
                                                                        o_error                   => l_error)
                THEN
                
                    g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                    pk_alert_exceptions.raise_error(error_name_in => 'e_invalid_rec_plan',
                                                    text_in       => g_error,
                                                    name1_in      => 'function_name',
                                                    value1_in     => k_function_name,
                                                    name2_in      => 'i_order_recurr_plan',
                                                    value2_in     => coalesce(i_order_recurr_plan, '<null>'));
                
                END IF;
            END IF;
        END set_order_recurr_plan;
    BEGIN
        /** Hypothetical example of a patient's nursing care plan (in JSON)
        {
          "DIAGNOSES": [
            {
              "ID": 0,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 46,
              "NANDA_CODE": 46,
              "DIAGNOSIS_NAME": "Impaired Skin Integrity",
              "NOTES": "lcera de presso no cotovelo direito",
              "DT_DIAGNOSIS": "20111101110000",              
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "0"
              ],
              "LINKED_INTERVENTIONS": [
                "2"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  278,
                  279,
                  280,
                  281
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  402,
                  403
                ],
                "NOTES": "This is a note for the evaluation"
              }
            },
            {
              "ID": 1,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 46,
              "NANDA_CODE": 46,
              "DIAGNOSIS_NAME": "Impaired Skin Integrity",
              "NOTES": "lcera de presso no calcneo esquerdo",
              "DT_DIAGNOSIS": "20111101110000",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "0"
              ],
              "LINKED_INTERVENTIONS": [
                "2"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  282,
                  283,
                  284,
                  285,
                  286
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  404
                ],
                "NOTES": "This is a note for the evaluation"
              }
            },
            {
              "ID": 2,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 11,
              "NANDA_CODE": 11,
              "DIAGNOSIS_NAME": "Constipation",
              "NOTES": "",
              "DT_DIAGNOSIS": "20111101110000",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [],
              "LINKED_INTERVENTIONS": [
                "2"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  31,
                  32,
                  33,
                  34
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  73,
                  74,
                  75,
                  76,
                  77,
                  78,
                  79,
                  80,
                  81,
                  82
                ],
                "NOTES": "This is a note for the evaluation"
              }
            },
            {
              "ID": 3,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 31,
              "NANDA_CODE": 31,
              "DIAGNOSIS_NAME": "Ineffective airway clearance",
              "NOTES": "",
              "DT_DIAGNOSIS": "20111101110000",              
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [],
              "LINKED_INTERVENTIONS": [
                "3"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  178,
                  179,
                  180,
                  181,
                  182
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  271,
                  272,
                  273,
                  274
                ],
                "NOTES": "This is a note for the evaluation"
              }
            },
            {
              "ID": 4,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 46,
              "NANDA_CODE": 46,
              "DIAGNOSIS_NAME": "Impaired Skin Integrity",
              "NOTES": "Ferida cirrgica no abdmen",
              "DT_DIAGNOSIS": "20111101110000",              
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [],
              "LINKED_INTERVENTIONS": [
                "4"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  812
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  919,
                  920,
                  921,
                  922
                ],
                "NOTES": "This is a evaluation note of surgical wound located on the abdomen."
              }
            },
            {
              "ID": 5,
              "ID_NNN_EPIS_DIAGNOSIS": null,
              "ID_NAN_DIAGNOSIS": 46,
              "NANDA_CODE": 46,
              "DIAGNOSIS_NAME": "Impaired Skin Integrity",
              "NOTES": "Ferida cirrgica na perna direita",
              "DT_DIAGNOSIS": "20111101110000",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "2"
              ],
              "LINKED_INTERVENTIONS": [
                "4"
              ],
              "DIAGNOSIS_EVALUATION": {
                "ID_NNN_EPIS_DIAG_EVAL": null,
                "FLG_STATUS": "A",
                "DT_EVALUATION": "20111101110000",
                "LST_RELATED_FACTOR": [
                  812
                ],
                "LST_RISK_FACTOR": [],
                "LST_DEFINING_CHARACTERISTIC": [
                  923,
                  924,
                  925,
                  926
                ],
                "NOTES": "This is a evaluation note of surgical wound located on the right leg."
              }
            }
          ],
          "OUTCOMES": [
            {
              "ID": 0,
              "ID_NNN_EPIS_OUTCOME": null,
              "ID_NOC_OUTCOME": 131,
              "NOC_CODE": "1103",
              "OUTCOME_NAME": "Wound Healing: Secondary Intention",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "0"
              ],
              "LINKED_INDICATORS": [
                "0",
                "1"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "OUTCOME_EVALUATION": {
                "ID_NNN_EPIS_OUTCOME_EVAL": null,
                "DT_EVALUATION": "20111101111100",
                "TARGET_VALUE": 3,
                "OUTCOME_VALUE": null,
                "NOTES": ""
              }
            },
            {
              "ID": 1,
              "ID_NNN_EPIS_OUTCOME": null,
              "ID_NOC_OUTCOME": 129,
              "NOC_CODE": "1101",
              "OUTCOME_NAME": "Tissue Integrity: Skin & Mucous Membranes",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "1"
              ],
              "LINKED_INDICATORS": [
                "0",
                "2"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "OUTCOME_EVALUATION": {
                "ID_NNN_EPIS_OUTCOME_EVAL": null,
                "DT_EVALUATION": "20111101111100",
                "TARGET_VALUE": 3,
                "OUTCOME_VALUE": null,
                "NOTES": ""
              }
            },
            {
              "ID": 2,
              "ID_NNN_EPIS_OUTCOME": null,
              "ID_NOC_OUTCOME": 130,
              "NOC_CODE": "1102",
              "OUTCOME_NAME": "Wound Healing: Primary Intention",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "5"
              ],
              "LINKED_INDICATORS": [
                "0",
                "2"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "OUTCOME_EVALUATION": {
                "ID_NNN_EPIS_OUTCOME_EVAL": null,
                "DT_EVALUATION": "20111101111100",
                "TARGET_VALUE": 3,
                "OUTCOME_VALUE": null,
                "NOTES": ""
              }
            },
            {
              "ID": 3,
              "ID_NNN_EPIS_OUTCOME": null,
              "ID_NOC_OUTCOME": 73,
              "NOC_CODE": "410",
              "OUTCOME_NAME": "Respiratory Status: Airway Patency",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "3"
              ],
              "LINKED_INDICATORS": [
                "6",
                "7",
                "8"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "OUTCOME_EVALUATION": {
                "ID_NNN_EPIS_OUTCOME_EVAL": null,
                "DT_EVALUATION": "20111101111100",
                "TARGET_VALUE": 3,
                "OUTCOME_VALUE": null,
                "NOTES": ""
              }
            }
          ],
          "INDICATORS": [
            {
              "ID": 0,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 953,
              "INDICATOR_NAME": "Necrosis",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "0",
                "1"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101091500",
                "TARGET_VALUE": 4,
                "INDICATOR_VALUE": 2,
                "NOTES": ""
              }
            },
            {
              "ID": 1,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 1943,
              "INDICATOR_NAME": "Decreased wound size",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "0"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 2,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 1902,
              "INDICATOR_NAME": "Skin intactness",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "1"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 3,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 1921,
              "INDICATOR_NAME": "Periwound edema",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "2"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 4,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 1916,
              "INDICATOR_NAME": "Sanguineous drainage",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "2"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 5,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 1924,
              "INDICATOR_NAME": "Wound edge approximation",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "2"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 6,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 837,
              "INDICATOR_NAME": "Ease of breathing",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "3"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 7,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 851,
              "INDICATOR_NAME": "Respiratory rhythm",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "3"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            },
            {
              "ID": 8,
              "ID_NNN_EPIS_INDICATOR": null,
              "ID_NOC_INDICATOR": 855,
              "INDICATOR_NAME": "Moves sputum out of airway",
              "FLG_REQ_STATUS": "R",
              "LINKED_OUTCOMES": [
                "3"
              ],
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "Priority: Normal; To be performed: In current episode; PRN: No; Frequency: Once; Start date: 09:59h Nov-21-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "INDICATOR_EVALUATION": {
                "ID_NNN_EPIS_IND_EVAL": null,
                "DT_EVALUATION": "20111101101400",
                "TARGET_VALUE": 5,
                "INDICATOR_VALUE": 3,
                "NOTES": ""
              }
            }
          ],
          "INTERVENTIONS": [
            {
              "ID": 0,
              "ID_NNN_EPIS_INTERVENTION": null,
              "ID_NIC_INTERVENTION": 249,
              "NIC_CODE": "3520",
              "INTERVENTION_NAME": "Pressure Ulcer Care",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "0"
              ],
              "LINKED_ACTIVITIES": [
                "0"
              ]
            },
            {
              "ID": 1,
              "ID_NNN_EPIS_INTERVENTION": null,
              "ID_NIC_INTERVENTION": 249,
              "NIC_CODE": "3520",
              "INTERVENTION_NAME": "Pressure Ulcer Care",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "1"
              ],
              "LINKED_ACTIVITIES": [
                "1"
              ]
            },
            {
              "ID": 2,
              "ID_NNN_EPIS_INTERVENTION": null,
              "ID_NIC_INTERVENTION": 59,
              "NIC_CODE": "0450",
              "INTERVENTION_NAME": "Constipation/Impaction Management",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "2"
              ],
              "LINKED_ACTIVITIES": [
                "2"
              ]
            },
            {
              "ID": 3,
              "ID_NNN_EPIS_INTERVENTION": null,
              "ID_NIC_INTERVENTION": 237,
              "NIC_CODE": "3250",
              "INTERVENTION_NAME": "Cough Enhancement",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "3"
              ],
              "LINKED_ACTIVITIES": [
                "3",
                "4"
              ]
            },
            {
              "ID": 4,
              "ID_NNN_EPIS_INTERVENTION": null,
              "ID_NIC_INTERVENTION": 245,
              "NIC_CODE": "3440",
              "INTERVENTION_NAME": "Incision Site Care",
              "FLG_REQ_STATUS": "R",
              "LINKED_DIAGNOSES": [
                "4",
                "5"
              ],
              "LINKED_ACTIVITIES": [
                "5"
              ]
            }
          ],
          "ACTIVITIES": [
            {
              "ID": 0,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 18211,
              "ACTIVITY_NAME": "Cleanse the ulcer with the appropriate nontoxic solution, working in a circular motion from the center",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121095900",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: 3 daily executions (8h (08:00h) - 14h (14:00h) - 22h (22:00h)); Repeat every: 1 day(s); End after: 5 execution(s); Start date: 22:00h 21-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "0"
              ]
            },
            {
              "ID": 1,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 18207,
              "ACTIVITY_NAME": "Apply moist heat to ulcer to improve blood perfusion and oxygen supply to area",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121220000",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: Daily (a.m.); No end date; Start date: 06:30h 22-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "1"
              ]
            },
            {
              "ID": 2,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 1231,
              "ACTIVITY_NAME": "Encourage increased fluid intake, unless contraindicated",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121220000",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: 2 times each Shift; No end date; Start date: 06:30h 22-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "2"
              ]
            },
            {
              "ID": 3,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 17920,
              "ACTIVITY_NAME": "Assist patient to a sitting position with head slightly flexed, shoulders relaxed, and knees flexed",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121220000",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: 2 times each Shift; No end date; Start date: 06:30h 22-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "3"
              ]
            },
            {
              "ID": 4,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 17930,
              "ACTIVITY_NAME": "Monitor results of pulmonary function tests, particularly vital capacity, maximal inspiratory force, forced expiratory volume in 1 second (FEV1), and FEV1/FVC, as appropriate",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121220000",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: 2 times each Shift; No end date; Start date: 06:30h 22-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "3"
              ]
            },
            {
              "ID": 5,
              "ID_NNN_EPIS_ACTIVITY": null,
              "ID_NIC_ACTIVITY": 18122,
              "ACTIVITY_NAME": "Monitor the healing process in the incision site",
              "FLG_REQ_STATUS": "R",
              "INSTRUCTIONS": {
                "FLG_PRIORITY": "N",
                "PRIORITY": "Normal",
                "FLG_PRN": "N",
                "PRN": "No",
                "NOTES_PRN": "",
                "FLG_TIME": "E",
                "TO_BE_PERFORMED": "In current episode",
                "START_DATE": "20131121220000",
                "DESC_INSTRUCTIONS": "To be executed: In current episode; Frequency: Daily (a.m.); No end date; Start date: 06:30h 22-Nov-2013",
                "ID_ORDER_RECURR_PLAN": null
              },
              "LINKED_INTERVENTIONS": [
                "4"
              ]
            }
          ]
        }
                 **/
    
        l_timestamp := current_timestamp;
    
        g_error := 'Input arguments:';
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_patient = ' || coalesce(to_char(i_patient), '<null>');
        g_error := g_error || ' i_episode = ' || coalesce(to_char(i_episode), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        g_error := 'Creating an instance of JSON type using the json document passed as argument in i_jsn_careplan';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_json_document := json_object_t(i_jsn_careplan);
    
        /*
        We extract and convert the JSON into data structures in order to handle data more easily.
        Each item has an identifier (ID) that allows it to be used to represent relationships between them in collection properties named "linked_...".
        So the collections of itens are returned as maps using this identifier as the key.
        As example, an outcome can be associated with multiple diagnoses, then the property outcome.linked_diagnoses is the collection of keys (ID) of diagnoses map.        
        These IDs are not necessarily primary keys of records in a database, can be generated IDs like GUIDs,
        for example, to represent a relationship between content that has not yet been recorded on BD.
        */
    
        g_error := 'Extract and deserialize from JSON object the nested collection of NANDA diagnoses';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_diagnoses := pk_nnn_type.get_map_ux_epis_diagnosis(i_lang => i_lang,
                                                                 i_prof => i_prof,
                                                                 i_json => l_json_document);
    
        g_error := 'Extract and deserialize from JSON object the nested collection of NOC outcomes';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_outcomes := pk_nnn_type.get_map_ux_epis_outcome(i_lang => i_lang,
                                                              i_prof => i_prof,
                                                              i_json => l_json_document);
    
        g_error := 'Extract and deserialize from JSON object the nested collection of NOC indicators';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_indicators := pk_nnn_type.get_map_ux_epis_indicator(i_lang => i_lang,
                                                                  i_prof => i_prof,
                                                                  i_json => l_json_document);
    
        g_error := 'Extract and deserialize from JSON object the nested collection of NIC interventions';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_interventions := pk_nnn_type.get_map_ux_epis_intervention(i_lang => i_lang,
                                                                        i_prof => i_prof,
                                                                        i_json => l_json_document);
    
        g_error := 'Extract and deserialize from JSON object the nested collection of NIC activities';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_activities := pk_nnn_type.get_map_ux_epis_activity(i_lang => i_lang,
                                                                 i_prof => i_prof,
                                                                 i_json => l_json_document);
    
        g_error := '# of NANDA diagnoses: ' || l_map_diagnoses.count();
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        g_error := '# of NOC outcomes: ' || l_map_outcomes.count();
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        g_error := '# of NOC indicators: ' || l_map_indicators.count();
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        g_error := '# of NIC interventions: ' || l_map_interventions.count();
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        g_error := '# of NIC activities: ' || l_map_activities.count();
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        -- We're using some local variables to retrieve records from map in order to enable IDE Code Assistant(auto-complete)
    
        -- NANDA Diagnoses
        g_error := 'Saving/Updating the collection of NANDA diagnoses';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_key := l_map_diagnoses.first;
        WHILE l_map_key IS NOT NULL
        LOOP
            l_diagnosis := l_map_diagnoses(l_map_key);
        
            /*
            If l_diagnosis.id_nnn_epis_diagnosis is not NULL then the diagnosis already exists in the care plan.
            Because this method is only intended to add items into the care plan, no operation is performed in such cases.
            This approach allow us to add new items to the care plan that will be linked to existing diagnoses. 
            */
            IF l_diagnosis.id_nnn_epis_diagnosis IS NULL
            THEN
                -- Save diagnosis            
                g_error := 'Saving NANDA diagnosis with id_nan_diagnosis: ' || to_char(l_diagnosis.id_nan_diagnosis);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                l_diagnosis.id_nnn_epis_diagnosis := pk_nnn_core.set_epis_nan_diagnosis(i_lang               => i_lang,
                                                                                        i_prof               => i_prof,
                                                                                        i_patient            => i_patient,
                                                                                        i_episode            => i_episode,
                                                                                        i_nan_diagnosis      => l_diagnosis.id_nan_diagnosis,
                                                                                        i_nnn_epis_diagnosis => l_diagnosis.id_nnn_epis_diagnosis,
                                                                                        i_notes              => l_diagnosis.notes,
                                                                                        i_dt_diagnosis       => l_diagnosis.dt_diagnosis,
                                                                                        i_flg_req_status     => l_diagnosis.flg_req_status,
                                                                                        i_timestamp          => l_timestamp);
            
                -- Update entry in map with the new epis diagnosis ID (if it's a new entry)
                l_map_diagnoses(l_map_key).id_nnn_epis_diagnosis := l_diagnosis.id_nnn_epis_diagnosis;
            
                -- Save 1st evaluation
                l_diag_eval := l_diagnosis.diagnosis_evaluation;
                IF l_diag_eval.dt_evaluation IS NOT NULL
                THEN
                    g_error := 'Saving NANDA diagnosis evaluation';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                
                    l_diag_eval.id_nnn_epis_diag_eval := pk_nnn_core.set_epis_nan_diagnosis_eval(i_lang               => i_lang,
                                                                                                 i_prof               => i_prof,
                                                                                                 i_patient            => i_patient,
                                                                                                 i_episode            => i_episode,
                                                                                                 i_nnn_epis_diagnosis => l_diagnosis.id_nnn_epis_diagnosis,
                                                                                                 i_nnn_epis_diag_eval => l_diag_eval.id_nnn_epis_diag_eval,
                                                                                                 i_flg_status         => l_diag_eval.flg_status,
                                                                                                 i_dt_evaluation      => l_diag_eval.dt_evaluation,
                                                                                                 i_notes              => l_diag_eval.notes,
                                                                                                 i_lst_nan_relf       => l_diag_eval.lst_related_factor,
                                                                                                 i_lst_nan_riskf      => l_diag_eval.lst_risk_factor,
                                                                                                 i_lst_nan_defc       => l_diag_eval.lst_defining_characteristic,
                                                                                                 i_timestamp          => l_timestamp);
                    -- Update entry in map with the new epis diagnosis evaluation ID (if it's a new entry)
                    l_map_diagnoses(l_map_key).diagnosis_evaluation.id_nnn_epis_diag_eval := l_diag_eval.id_nnn_epis_diag_eval;
                END IF;
            END IF;
        
            l_map_key := l_map_diagnoses.next(l_map_key);
        END LOOP;
    
        -- NOC Outcomes
        g_error := 'Saving/Updating the collection of NOC outcomes';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_key := l_map_outcomes.first;
        WHILE l_map_key IS NOT NULL
        LOOP
            l_outcome := l_map_outcomes(l_map_key);
        
            /*
            If l_outcome.id_nnn_epis_outcome is not NULL then the outcome already exists in the care plan.
            Because this method is only intended to add items into the care plan, no operation is performed in such cases.
            This approach allow us to add new items to the care plan that will be linked to existing outcomes. 
            */
            IF l_outcome.id_nnn_epis_outcome IS NULL
            THEN
            
                l_instructions := l_outcome.instructions;
            
                IF l_outcome.flg_req_status = pk_nnn_constant.g_req_status_draft
                THEN
                    -- TODO: Set a temporary order recurrence plan as Draft (waiting API from recurrence to do that)
                    NULL;
                ELSE
                    -- Set a temporary order recurrence plan as definitive (final status)
                    g_error := 'Set temporary order recurrence plan for NOC outcome as definitive. id_order_recurr_plan: ' ||
                               coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                    set_order_recurr_plan(i_lang                    => i_lang,
                                          i_prof                    => i_prof,
                                          i_order_recurr_plan       => l_instructions.id_order_recurr_plan,
                                          o_order_recurr_option     => l_order_recurr_option,
                                          o_final_order_recurr_plan => l_instructions.id_order_recurr_plan);
                END IF;
            
                -- Save outcome              
                g_error := 'Saving NOC outcome with id_noc_outcome: ' || to_char(l_outcome.id_noc_outcome);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                l_outcome.id_nnn_epis_outcome := pk_nnn_core.set_epis_noc_outcome(i_lang                => i_lang,
                                                                                  i_prof                => i_prof,
                                                                                  i_patient             => i_patient,
                                                                                  i_episode             => i_episode,
                                                                                  i_noc_outcome         => l_outcome.id_noc_outcome,
                                                                                  i_nnn_epis_outcome    => l_outcome.id_nnn_epis_outcome,
                                                                                  i_episode_origin      => NULL,
                                                                                  i_episode_destination => NULL,
                                                                                  i_flg_prn             => l_instructions.flg_prn,
                                                                                  i_notes_prn           => l_instructions.notes_prn,
                                                                                  i_flg_time            => l_instructions.flg_time,
                                                                                  i_flg_priority        => l_instructions.flg_priority,
                                                                                  i_order_recurr_plan   => l_instructions.id_order_recurr_plan,
                                                                                  i_flg_req_status      => l_outcome.flg_req_status,
                                                                                  i_timestamp           => l_timestamp);
            
                -- Update entry in map with the new epis outcome ID (if it's a new entry)
                l_map_outcomes(l_map_key).id_nnn_epis_outcome := l_outcome.id_nnn_epis_outcome;
            
                -- Prepare the order plan and also creates the initial set of planned evaluations for the Outcome
                -- Draft requests cannot prepare plans because the recurrence plan is also draft.
                IF l_instructions.id_order_recurr_plan IS NOT NULL
                   AND l_outcome.flg_req_status != pk_nnn_constant.g_req_status_draft
                THEN
                    g_error := 'Prepare the order plan and creates the initial set of planned evaluations for the Outcome. id_order_recurr_plan: ' ||
                               coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                
                    prepare_create_outcome_plan(i_lang               => i_lang,
                                                i_prof               => i_prof,
                                                i_lst_order_rec_plan => table_number(l_instructions.id_order_recurr_plan),
                                                i_timestamp          => l_timestamp);
                END IF;
            
                -- Save 1st outcome evaluation        
                l_outcome_eval := l_outcome.outcome_evaluation;
                IF l_outcome_eval.dt_evaluation IS NOT NULL
                THEN
                    IF l_outcome_eval.id_nnn_epis_outcome_eval IS NULL
                    THEN
                        -- If a new evaluation, retrieves the ID of next planned outcome evaluation ID to use it
                        g_error := 'Get next planned NOC outcome evaluation ID';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => k_function_name);
                        l_outcome_eval.id_nnn_epis_outcome_eval := pk_nnn_core.get_next_outcome_eval(i_nnn_epis_outcome => l_outcome.id_nnn_epis_outcome);
                    END IF;
                    g_error := 'Saving NOC outcome evaluation';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                
                    l_outcome_eval.id_nnn_epis_outcome_eval := pk_nnn_api_db.set_outcome_evaluate(i_lang                  => i_lang,
                                                                                                  i_prof                  => i_prof,
                                                                                                  i_patient               => i_patient,
                                                                                                  i_episode               => i_episode,
                                                                                                  i_nnn_epis_outcome      => l_outcome.id_nnn_epis_outcome,
                                                                                                  i_nnn_epis_outcome_eval => l_outcome_eval.id_nnn_epis_outcome_eval,
                                                                                                  i_dt_evaluation         => l_outcome_eval.dt_evaluation,
                                                                                                  i_target_value          => l_outcome_eval.target_value,
                                                                                                  i_outcome_value         => l_outcome_eval.outcome_value,
                                                                                                  i_notes                 => l_outcome_eval.notes,
                                                                                                  i_timestamp             => l_timestamp);
                
                    -- Update entry in map with the new epis outcome evaluation ID (if it's a new entry)
                    l_map_outcomes(l_map_key).outcome_evaluation.id_nnn_epis_outcome_eval := l_outcome_eval.id_nnn_epis_outcome_eval;
                END IF;
            END IF;
        
            --Link Outcome and Diagnoses
            IF l_outcome.linked_diagnoses IS NOT empty
            THEN
                g_error := 'Saving linkages to NANDA diagnoses for NOC outcome with id_nnn_epis_outcome:' ||
                           to_char(l_outcome.id_nnn_epis_outcome);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                FOR idx IN 1 .. l_outcome.linked_diagnoses.count()
                LOOP
                    pk_nnn_core.set_lnk_diagnosis_outcome(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_episode            => i_episode,
                                                          i_nnn_epis_diagnosis => l_map_diagnoses(l_outcome.linked_diagnoses(idx)).id_nnn_epis_diagnosis,
                                                          i_nnn_epis_outcome   => l_outcome.id_nnn_epis_outcome,
                                                          i_flg_lnk_status     => pk_alert_constant.g_active,
                                                          i_timestamp          => l_timestamp);
                END LOOP;
            END IF;
        
            l_map_key := l_map_outcomes.next(l_map_key);
        END LOOP;
    
        -- NOC Indicators
        g_error := 'Saving/Updating the collection of NOC indicators';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_key := l_map_indicators.first;
        WHILE l_map_key IS NOT NULL
        LOOP
            l_indicator    := l_map_indicators(l_map_key);
            l_instructions := l_indicator.instructions;
            IF l_indicator.flg_req_status = pk_nnn_constant.g_req_status_draft
            THEN
                -- TODO: Set a temporary order recurrence plan as Draft (waiting API from recurrence to do that)
                NULL;
            ELSE
                -- Set a temporary order recurrence plan as definitive (final status)
                g_error := 'Set temporary order recurrence plan for NOC indicator as definitive. id_order_recurr_plan: ' ||
                           coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                set_order_recurr_plan(i_lang                    => i_lang,
                                      i_prof                    => i_prof,
                                      i_order_recurr_plan       => l_instructions.id_order_recurr_plan,
                                      o_order_recurr_option     => l_order_recurr_option,
                                      o_final_order_recurr_plan => l_instructions.id_order_recurr_plan);
            
            END IF;
            -- Save/update NOC indicator  
            g_error := 'Saving NOC indicator with id_noc_indicator: ' || to_char(l_indicator.id_noc_indicator);
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            l_indicator.id_nnn_epis_indicator := pk_nnn_core.set_epis_noc_indicator(i_lang                => i_lang,
                                                                                    i_prof                => i_prof,
                                                                                    i_patient             => i_patient,
                                                                                    i_episode             => i_episode,
                                                                                    i_noc_indicator       => l_indicator.id_noc_indicator,
                                                                                    i_nnn_epis_indicator  => l_indicator.id_nnn_epis_indicator,
                                                                                    i_episode_origin      => NULL,
                                                                                    i_episode_destination => NULL,
                                                                                    i_flg_prn             => l_instructions.flg_prn,
                                                                                    i_notes_prn           => l_instructions.notes_prn,
                                                                                    i_flg_time            => l_instructions.flg_time,
                                                                                    i_flg_priority        => l_instructions.flg_priority,
                                                                                    i_order_recurr_plan   => l_instructions.id_order_recurr_plan,
                                                                                    i_flg_req_status      => l_indicator.flg_req_status,
                                                                                    i_timestamp           => l_timestamp);
            -- Update entry in map with the new epis indicator ID (if it's a new entry)
            l_map_indicators(l_map_key).id_nnn_epis_indicator := l_indicator.id_nnn_epis_indicator;
        
            -- Prepare the order plan and also creates the initial set of planned evaluations for the Indicator
            -- Draft requests cannot prepare plans because the recurrence plan is also draft.
            IF l_instructions.id_order_recurr_plan IS NOT NULL
               AND l_indicator.flg_req_status != pk_nnn_constant.g_req_status_draft
            THEN
                g_error := 'Prepare the order plan and creates the initial set of planned evaluations for the Indicator. id_order_recurr_plan: ' ||
                           coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                prepare_create_indicator_plan(i_lang               => i_lang,
                                              i_prof               => i_prof,
                                              i_lst_order_rec_plan => table_number(l_instructions.id_order_recurr_plan),
                                              i_timestamp          => l_timestamp);
            END IF;
        
            -- Save 1st evaluation
            l_ind_eval := l_indicator.indicator_evaluation;
            IF l_ind_eval.dt_evaluation IS NOT NULL
            THEN
                IF l_ind_eval.id_nnn_epis_ind_eval IS NULL
                THEN
                    -- If a new evaluation, retrieves the ID of next planned indicator evaluation ID to use it
                    g_error := 'Get next planned NOC indicator evaluation ID';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                    l_ind_eval.id_nnn_epis_ind_eval := pk_nnn_core.get_next_indicator_eval(i_nnn_epis_indicator => l_indicator.id_nnn_epis_indicator);
                END IF;
                g_error := 'Saving NOC indicator evaluation';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_ind_eval.id_nnn_epis_ind_eval := pk_nnn_api_db.set_indicator_evaluate(i_lang               => i_lang,
                                                                                        i_prof               => i_prof,
                                                                                        i_patient            => i_patient,
                                                                                        i_episode            => i_episode,
                                                                                        i_nnn_epis_indicator => l_indicator.id_nnn_epis_indicator,
                                                                                        i_nnn_epis_ind_eval  => l_ind_eval.id_nnn_epis_ind_eval,
                                                                                        i_dt_evaluation      => l_ind_eval.dt_evaluation,
                                                                                        i_target_value       => l_ind_eval.target_value,
                                                                                        i_indicator_value    => l_ind_eval.indicator_value,
                                                                                        i_notes              => l_ind_eval.notes,
                                                                                        i_timestamp          => l_timestamp);
            
                -- Update entry in map with the new epis indicator evaluation ID (if it's a new entry)                                                                                                                                                                                     
                l_map_indicators(l_map_key).indicator_evaluation.id_nnn_epis_ind_eval := l_ind_eval.id_nnn_epis_ind_eval;
            END IF;
        
            -- Linked Indicator and Outcomes
            IF l_indicator.linked_outcomes IS NOT empty
            THEN
                g_error := 'Saving linkages to NOC outcomes for NOC indicator with id_nnn_epis_indicator:' ||
                           to_char(l_indicator.id_nnn_epis_indicator);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                FOR idx IN 1 .. l_indicator.linked_outcomes.count()
                LOOP
                    pk_nnn_core.set_lnk_outcome_indicator(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_episode            => i_episode,
                                                          i_nnn_epis_outcome   => l_map_outcomes(l_indicator.linked_outcomes(idx)).id_nnn_epis_outcome,
                                                          i_nnn_epis_indicator => l_indicator.id_nnn_epis_indicator,
                                                          i_flg_lnk_status     => pk_alert_constant.g_active,
                                                          i_timestamp          => l_timestamp);
                END LOOP;
            END IF;
        
            l_map_key := l_map_indicators.next(l_map_key);
        END LOOP;
    
        -- NIC Interventions
        g_error := 'Saving/Updating the collection of NIC interventions';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_key := l_map_interventions.first;
        WHILE l_map_key IS NOT NULL
        LOOP
            l_intervention := l_map_interventions(l_map_key);
        
            /*
            If l_intervention.id_nnn_epis_intervention is not NULL then the intervention already exists in the care plan.
            Because this method is only intended to add items into the care plan, no operation is performed in such cases.
            This approach allow us to add new items to the care plan that will be linked to existing interventions. 
            */
            IF l_intervention.id_nnn_epis_intervention IS NULL
            THEN
                -- Save intervention         
                g_error := 'Saving NIC intervention with id_nic_intervention: ' ||
                           to_char(l_intervention.id_nic_intervention);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                l_intervention.id_nnn_epis_intervention := pk_nnn_core.set_epis_nic_intervention(i_lang                  => i_lang,
                                                                                                 i_prof                  => i_prof,
                                                                                                 i_patient               => i_patient,
                                                                                                 i_episode               => i_episode,
                                                                                                 i_nic_intervention      => l_intervention.id_nic_intervention,
                                                                                                 i_nnn_epis_intervention => l_intervention.id_nnn_epis_intervention,
                                                                                                 i_flg_req_status        => l_intervention.flg_req_status,
                                                                                                 i_timestamp             => l_timestamp);
            
                -- Update entry in map with the new epis intervention ID (if it's a new entry)
                l_map_interventions(l_map_key).id_nnn_epis_intervention := l_intervention.id_nnn_epis_intervention;
            END IF;
        
            -- Link Intervention and Diagnoses                                                                                         
            IF l_intervention.linked_diagnoses IS NOT empty
            THEN
                g_error := 'Saving linkages to NANDA diagnoses for NIC intervention with id_nnn_epis_intervention:' ||
                           to_char(l_intervention.id_nnn_epis_intervention);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                FOR idx IN 1 .. l_intervention.linked_diagnoses.count()
                LOOP
                    pk_nnn_core.set_lnk_diagnosis_intervention(i_lang                  => i_lang,
                                                               i_prof                  => i_prof,
                                                               i_episode               => i_episode,
                                                               i_nnn_epis_diagnosis    => l_map_diagnoses(l_intervention.linked_diagnoses(idx)).id_nnn_epis_diagnosis,
                                                               i_nnn_epis_intervention => l_intervention.id_nnn_epis_intervention,
                                                               i_flg_lnk_status        => pk_alert_constant.g_active,
                                                               i_timestamp             => l_timestamp);
                END LOOP;
            END IF;
            l_map_key := l_map_interventions.next(l_map_key);
        END LOOP;
    
        -- NIC Activities
        g_error := 'Saving/Updating the collection of NIC activities';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_map_key := l_map_activities.first;
        WHILE l_map_key IS NOT NULL
        LOOP
            l_activity     := l_map_activities(l_map_key);
            l_instructions := l_activity.instructions;
            IF l_activity.flg_req_status = pk_nnn_constant.g_req_status_draft
            THEN
                -- TODO: Set a temporary order recurrence plan as Draft (waiting API from recurrence to do that)
                NULL;
            ELSE
                -- Set a temporary order recurrence plan as definitive (final status)
                g_error := 'Set temporary order recurrence plan for NIC activity as definitive. id_order_recurr_plan: ' ||
                           coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                set_order_recurr_plan(i_lang                    => i_lang,
                                      i_prof                    => i_prof,
                                      i_order_recurr_plan       => l_instructions.id_order_recurr_plan,
                                      o_order_recurr_option     => l_order_recurr_option,
                                      o_final_order_recurr_plan => l_instructions.id_order_recurr_plan);
            
            END IF;
            -- Save/update activity
            g_error := 'Saving NIC activity with id_nic_activity: ' || to_char(l_activity.id_nic_activity);
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            l_activity.id_nnn_epis_activity := pk_nnn_core.set_epis_nic_activity(i_lang                => i_lang,
                                                                                 i_prof                => i_prof,
                                                                                 i_patient             => i_patient,
                                                                                 i_episode             => i_episode,
                                                                                 i_nic_activity        => l_activity.id_nic_activity,
                                                                                 i_nnn_epis_activity   => l_activity.id_nnn_epis_activity,
                                                                                 i_episode_origin      => NULL,
                                                                                 i_episode_destination => NULL,
                                                                                 i_flg_prn             => l_instructions.flg_prn,
                                                                                 i_notes_prn           => l_instructions.notes_prn,
                                                                                 i_flg_time            => l_instructions.flg_time,
                                                                                 i_flg_priority        => l_instructions.flg_priority,
                                                                                 i_order_recurr_plan   => l_instructions.id_order_recurr_plan,
                                                                                 i_flg_req_status      => l_activity.flg_req_status,
                                                                                 i_timestamp           => l_timestamp);
            -- Update entry in map with the new epis activity ID (if it's a new entry)
            l_map_activities(l_map_key).id_nnn_epis_activity := l_activity.id_nnn_epis_activity;
        
            -- Prepare the order plan and also creates the initial set of planned executions for the Activity
            -- Draft requests cannot prepare plans because the recurrence plan is also draft.
            IF l_instructions.id_order_recurr_plan IS NOT NULL
               AND l_activity.flg_req_status != pk_nnn_constant.g_req_status_draft
            THEN
                g_error := 'Prepare the order plan and creates the initial set of planned executions for the Activity. id_order_recurr_plan: ' ||
                           coalesce(to_char(l_instructions.id_order_recurr_plan), '<null>');
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                prepare_create_activity_plan(i_lang               => i_lang,
                                             i_prof               => i_prof,
                                             i_lst_order_rec_plan => table_number(l_instructions.id_order_recurr_plan),
                                             i_timestamp          => l_timestamp);
            
                -- Updates the alerts associated to the given activity
                pk_nnn_core.refresh_activity_alert(i_lang              => i_lang,
                                                   i_prof              => i_prof,
                                                   i_episode           => i_episode,
                                                   i_nnn_epis_activity => l_activity.id_nnn_epis_activity);
            END IF;
        
            -- Link Activity and Interventions 
            IF l_activity.linked_interventions IS NOT empty
            THEN
                g_error := 'Saving linkages to NIC interventions for NIC activity with id_nnn_epis_activity:' ||
                           to_char(l_activity.id_nnn_epis_activity);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                FOR idx IN 1 .. l_activity.linked_interventions.count()
                LOOP
                    pk_nnn_core.set_lnk_intervention_activity(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_episode               => i_episode,
                                                              i_nnn_epis_intervention => l_map_interventions(l_activity.linked_interventions(idx)).id_nnn_epis_intervention,
                                                              i_nnn_epis_activity     => l_activity.id_nnn_epis_activity,
                                                              i_flg_lnk_status        => pk_alert_constant.g_active,
                                                              i_timestamp             => l_timestamp);
                END LOOP;
            END IF;
        
            l_map_key := l_map_activities.next(l_map_key);
        END LOOP;
    
    EXCEPTION
        WHEN OTHERS THEN
            -- In order to log the g_error variable that can be useful to detect the step where error was raised
            pk_alert_exceptions.raise_error(error_name_in => 'e_create_care_plan',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
        
    END create_care_plan;

    FUNCTION set_diagnosis_update
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_nan_diagnosis      IN nnn_epis_diagnosis.id_nan_diagnosis%TYPE,
        i_dt_diagnosis       IN nnn_epis_diagnosis.dt_diagnosis%TYPE,
        i_nnn_epis_diagnosis IN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE,
        i_notes              IN nnn_epis_diagnosis.edited_diagnosis_name%TYPE,
        i_flg_req_status     IN nnn_epis_diagnosis.flg_req_status%TYPE,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_diagnosis_update';
        l_id    nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE;
        l_error t_error_out;
    BEGIN
        l_id := pk_nnn_core.set_epis_nan_diagnosis(i_lang               => i_lang,
                                                   i_prof               => i_prof,
                                                   i_patient            => i_patient,
                                                   i_episode            => i_episode,
                                                   i_nan_diagnosis      => i_nan_diagnosis,
                                                   i_dt_diagnosis       => i_dt_diagnosis,
                                                   i_nnn_epis_diagnosis => i_nnn_epis_diagnosis,
                                                   i_notes              => i_notes,
                                                   i_flg_req_status     => i_flg_req_status);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_diagnosis_update;

    FUNCTION set_diagnosis_evaluate
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_nnn_epis_diagnosis IN nnn_epis_diag_eval.id_nnn_epis_diagnosis%TYPE,
        i_nnn_epis_diag_eval IN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE,
        i_flg_status         IN nnn_epis_diag_eval.flg_status%TYPE,
        i_dt_evaluation      IN nnn_epis_diag_eval.dt_evaluation%TYPE,
        i_notes              IN CLOB,
        i_lst_nan_relf       IN table_number,
        i_lst_nan_riskf      IN table_number,
        i_lst_nan_defc       IN table_number,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_diagnosis_evaluate';
        l_id    nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE;
        l_error t_error_out;
    BEGIN
        -- Saves the evaluation
        l_id := pk_nnn_core.set_epis_nan_diagnosis_eval(i_lang               => i_lang,
                                                        i_prof               => i_prof,
                                                        i_patient            => i_patient,
                                                        i_episode            => i_episode,
                                                        i_nnn_epis_diagnosis => i_nnn_epis_diagnosis,
                                                        i_nnn_epis_diag_eval => i_nnn_epis_diag_eval,
                                                        i_flg_status         => i_flg_status,
                                                        i_dt_evaluation      => i_dt_evaluation,
                                                        i_notes              => i_notes,
                                                        i_lst_nan_relf       => i_lst_nan_relf,
                                                        i_lst_nan_riskf      => i_lst_nan_riskf,
                                                        i_lst_nan_defc       => i_lst_nan_defc,
                                                        i_timestamp          => i_timestamp);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_diagnosis_evaluate;

    FUNCTION set_diagnosis_evaluate_st
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_nnn_epis_diagnosis IN nnn_epis_diag_eval.id_nnn_epis_diagnosis%TYPE,
        i_flg_status         IN nnn_epis_diag_eval.flg_status%TYPE,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_diagnosis_evaluate_st';
        l_id    nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE;
        l_error t_error_out;
    BEGIN
        -- Saves the evaluation      
        l_id := pk_nnn_core.set_epis_nan_diagnosis_eval_st(i_lang               => i_lang,
                                                           i_prof               => i_prof,
                                                           i_patient            => i_patient,
                                                           i_episode            => i_episode,
                                                           i_nnn_epis_diagnosis => i_nnn_epis_diagnosis,
                                                           i_flg_status         => i_flg_status);
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_diagnosis_evaluate_st;

    PROCEDURE set_diagnosis_cancel
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN nnn_epis_diagnosis.id_patient%TYPE,
        i_episode       IN nnn_epis_diagnosis.id_episode%TYPE,
        i_lst_epis_diag IN table_number,
        i_cancel_reason IN nnn_epis_diagnosis.id_cancel_reason%TYPE,
        i_cancel_notes  IN nnn_epis_diagnosis.cancel_notes%TYPE DEFAULT NULL,
        i_timestamp     IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_diagnosis_cancel';
    
        l_lst_epis_diag             table_number;
        l_lst_nnn_epis_outcome      table_number;
        l_lst_nnn_epis_intervention table_number;
    
        l_epis_lnk_dg_outc_rows   ts_nnn_epis_lnk_dg_outc.nnn_epis_lnk_dg_outc_tc;
        l_epis_lnk_dg_outc_rows1  ts_nnn_epis_lnk_dg_outc.nnn_epis_lnk_dg_outc_tc;
        l_epis_lnk_dg_intrv_rows  ts_nnn_epis_lnk_dg_intrv.nnn_epis_lnk_dg_intrv_tc;
        l_epis_lnk_dg_intrv_rows1 ts_nnn_epis_lnk_dg_intrv.nnn_epis_lnk_dg_intrv_tc;
    
        l_epis_lnk_dg_outc_row  nnn_epis_lnk_dg_outc%ROWTYPE;
        l_epis_lnk_dg_intrv_row nnn_epis_lnk_dg_intrv%ROWTYPE;
        l_nnn_epis_diagnosis    nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE;
        l_idx                   PLS_INTEGER;
        l_idx1                  PLS_INTEGER;
        l_can_cancel            BOOLEAN;
        l_error                 t_error_out;
    
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_epis_diag = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_epis_diag, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_epis_diag := coalesce(i_lst_epis_diag, table_number());
    
        FOR l_idx IN 1 .. l_lst_epis_diag.count
        LOOP
            l_nnn_epis_diagnosis := l_lst_epis_diag(l_idx);
        
            -- Cancel a NANDA diagnosis    
            pk_nnn_core.cancel_epis_nan_diagnosis(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_nnn_epis_diagnosis => l_nnn_epis_diagnosis,
                                                  i_cancel_reason      => i_cancel_reason,
                                                  i_cancel_notes       => i_cancel_notes,
                                                  i_timestamp          => i_timestamp);
        
            -- Cancel the NOC Outcomes linked to this NANDA Diagnosis
        
            -- Get the Links between NANDA Diagnosis and NOC Outcomes associated one NANDA Diagnosis
            l_epis_lnk_dg_outc_rows := pk_nnn_core.get_lnk_dg_outc_by_diag(i_nnn_epis_diagnosis => l_nnn_epis_diagnosis,
                                                                           i_fltr_status        => pk_nnn_constant.g_req_status_ordered ||
                                                                                                   pk_nnn_constant.g_req_status_ongoing ||
                                                                                                   pk_nnn_constant.g_req_status_suspended);
        
            l_lst_nnn_epis_outcome := table_number();
            FOR i IN 1 .. l_epis_lnk_dg_outc_rows.count()
            LOOP
                l_epis_lnk_dg_outc_row := l_epis_lnk_dg_outc_rows(i);
            
                -- Check if NOC Outcome  is linked with more than one NANDA Diagnosis, if so we cannot cancel it            
                l_epis_lnk_dg_outc_rows1 := pk_nnn_core.get_lnk_dg_outc_by_outc(i_nnn_epis_outcome => l_epis_lnk_dg_outc_row.id_nnn_epis_outcome,
                                                                                i_fltr_status      => pk_nnn_constant.g_req_status_ordered ||
                                                                                                      pk_nnn_constant.g_req_status_ongoing ||
                                                                                                      pk_nnn_constant.g_req_status_suspended);
            
                l_can_cancel := TRUE;
                l_idx1       := l_epis_lnk_dg_outc_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_dg_outc_rows1(l_idx1).id_nnn_epis_diagnosis != l_nnn_epis_diagnosis
                    THEN
                        -- This outcome can not be canceled because it is also linked to another diagnosis
                        l_can_cancel := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_dg_outc_rows1.next(l_idx1);
                END LOOP;
            
                IF l_can_cancel
                THEN
                    -- Add this outcome to the list of outcomes that will effectively being canceled
                    l_lst_nnn_epis_outcome.extend();
                    l_lst_nnn_epis_outcome(l_lst_nnn_epis_outcome.last) := l_epis_lnk_dg_outc_row.id_nnn_epis_outcome;
                END IF;
            END LOOP;
        
            IF l_lst_nnn_epis_outcome.count > 0
            THEN
                -- Cancel only NOC Outcomes that are exclusively associated with this NANDA Diagnosis
                pk_nnn_api_db.set_outcome_cancel(i_lang                 => i_lang,
                                                 i_prof                 => i_prof,
                                                 i_patient              => i_patient,
                                                 i_episode              => i_episode,
                                                 i_lst_nnn_epis_outcome => l_lst_nnn_epis_outcome,
                                                 i_cancel_reason        => i_cancel_reason,
                                                 i_cancel_notes         => i_cancel_notes,
                                                 i_timestamp            => i_timestamp);
            
            END IF;
        
            -- Cancel the NIC Interventions linked to this NANDA Diagnosis
        
            -- Get the NIC Interventions for this NANDA Diagnosis
            l_epis_lnk_dg_intrv_rows := pk_nnn_core.get_lnk_dg_intrv_by_diag(i_nnn_epis_diagnosis => l_nnn_epis_diagnosis,
                                                                             i_fltr_status        => pk_nnn_constant.g_req_status_ordered ||
                                                                                                     pk_nnn_constant.g_req_status_ongoing ||
                                                                                                     pk_nnn_constant.g_req_status_suspended);
        
            l_lst_nnn_epis_intervention := table_number();
            FOR i IN 1 .. l_epis_lnk_dg_intrv_rows.count()
            LOOP
                l_epis_lnk_dg_intrv_row := l_epis_lnk_dg_intrv_rows(i);
            
                -- Check if NIC Intervention exists in more than one NANDA Diagnosis, if yes no cancel                           
                l_epis_lnk_dg_intrv_rows1 := pk_nnn_core.get_lnk_dg_intrv_by_intrv(i_nnn_epis_intervention => l_epis_lnk_dg_intrv_row.id_nnn_epis_intervention,
                                                                                   i_fltr_status           => pk_nnn_constant.g_req_status_ordered ||
                                                                                                              pk_nnn_constant.g_req_status_ongoing ||
                                                                                                              pk_nnn_constant.g_req_status_suspended);
            
                l_can_cancel := TRUE;
                l_idx1       := l_epis_lnk_dg_intrv_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_dg_intrv_rows1(l_idx1).id_nnn_epis_diagnosis != l_nnn_epis_diagnosis
                    THEN
                        -- This intervention cannot be canceled because it is linked to another diagnosis
                        l_can_cancel := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_dg_intrv_rows1.next(l_idx1);
                END LOOP;
            
                IF l_can_cancel
                THEN
                    -- Add this intervention to the list of interventions that will effectively being canceled
                    l_lst_nnn_epis_intervention.extend();
                    l_lst_nnn_epis_intervention(l_lst_nnn_epis_intervention.last) := l_epis_lnk_dg_intrv_row.id_nnn_epis_intervention;
                END IF;
            END LOOP;
        
            IF l_lst_nnn_epis_intervention.count > 0
            THEN
                -- Cancel only NIC Interventions that are exclusively associated with this NANDA Diagnosis
                pk_nnn_api_db.set_intervention_cancel(i_lang                      => i_lang,
                                                      i_prof                      => i_prof,
                                                      i_patient                   => i_patient,
                                                      i_episode                   => i_episode,
                                                      i_lst_nnn_epis_intervention => l_lst_nnn_epis_intervention,
                                                      i_cancel_reason             => i_cancel_reason,
                                                      i_cancel_notes              => i_cancel_notes,
                                                      i_timestamp                 => i_timestamp);
            END IF;
        
        END LOOP;
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_diagnosis_cancel;

    PROCEDURE set_diagnosis_eval_cancel
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN patient.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_lst_epis_diag_eval IN table_number,
        i_cancel_reason      IN nnn_epis_diag_eval.id_cancel_reason%TYPE,
        i_cancel_notes       IN nnn_epis_diag_eval.cancel_notes%TYPE,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_diagnosis_eval_cancel';
    
        l_lst_epis_diag_eval table_number;
        l_idx                PLS_INTEGER;
        l_error              t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_epis_diag = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_epis_diag_eval, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_epis_diag_eval := coalesce(i_lst_epis_diag_eval, table_number());
    
        FOR l_idx IN 1 .. l_lst_epis_diag_eval.count
        LOOP
            -- Cancel a NANDA diagnosis evaluation
            pk_nnn_core.cancel_epis_nan_diag_eval(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_nnn_epis_diag_eval => l_lst_epis_diag_eval(l_idx),
                                                  i_cancel_reason      => i_cancel_reason,
                                                  i_cancel_notes       => i_cancel_notes,
                                                  i_timestamp          => i_timestamp);
        END LOOP;
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_diagnosis_eval_cancel;

    FUNCTION set_outcome_update
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_patient             IN nnn_epis_outcome.id_patient%TYPE,
        i_episode             IN nnn_epis_outcome.id_episode%TYPE,
        i_noc_outcome         IN nnn_epis_outcome.id_noc_outcome%TYPE,
        i_nnn_epis_outcome    IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_episode_origin      IN nnn_epis_outcome.id_episode_origin%TYPE,
        i_episode_destination IN nnn_epis_outcome.id_episode_destination%TYPE,
        i_flg_prn             IN nnn_epis_outcome.flg_prn%TYPE,
        i_notes_prn           IN CLOB,
        i_flg_time            IN nnn_epis_outcome.flg_time%TYPE,
        i_flg_priority        IN nnn_epis_outcome.flg_priority%TYPE,
        i_order_recurr_plan   IN nnn_epis_outcome.id_order_recurr_plan%TYPE,
        i_flg_req_status      IN nnn_epis_outcome.flg_req_status%TYPE,
        i_timestamp           IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_outcome.id_nnn_epis_outcome%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_update';
        l_id                    nnn_epis_outcome.id_nnn_epis_outcome%TYPE;
        l_error                 t_error_out;
        l_rec                   nnn_epis_outcome%ROWTYPE;
        l_order_recurr_option   order_recurr_plan.id_order_recurr_option%TYPE;
        l_order_recurr_plan     order_recurr_plan.id_order_recurr_plan%TYPE;
        l_old_order_recurr_plan order_recurr_plan.id_order_recurr_plan%TYPE;
        l_req_status            nnn_epis_outcome.flg_req_status%TYPE;
        l_recurr_plan_changed   BOOLEAN;
        l_draft_to_ordered      BOOLEAN;
    BEGIN
        l_order_recurr_plan := i_order_recurr_plan;
    
        -- Retrieves the row data of NOC Outcome
        l_rec := pk_nnn_core.get_epis_noc_outcome_row(i_nnn_epis_outcome => i_nnn_epis_outcome);
    
        -- Evaluates whether the recurrence plan will be changed by this update
        l_old_order_recurr_plan := l_rec.id_order_recurr_plan;
        l_recurr_plan_changed   := l_old_order_recurr_plan != l_order_recurr_plan;
    
        IF l_recurr_plan_changed
        THEN
            -- Sets the new temporary order recurrence plan as definitive (final status) and set the previous one as deprecated             
            IF NOT pk_order_recurrence_api_db.set_for_edit_order_recurr_plan(i_lang                    => i_lang,
                                                                             i_prof                    => i_prof,
                                                                             i_order_recurr_plan_old   => l_old_order_recurr_plan,
                                                                             i_order_recurr_plan_new   => l_order_recurr_plan,
                                                                             i_flg_discard_old_plan    => pk_alert_constant.g_yes,
                                                                             o_order_recurr_option     => l_order_recurr_option,
                                                                             o_final_order_recurr_plan => l_order_recurr_plan,
                                                                             o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_FOR_EDIT_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
        -- Evaluates whether we are dealing with a state transition from Draft to Ordered
        l_draft_to_ordered := l_rec.flg_req_status = pk_nnn_constant.g_req_status_draft AND
                              i_flg_req_status = pk_nnn_constant.g_req_status_ordered;
    
        IF l_draft_to_ordered
        THEN
            -- The Outcome transitioned from "Draft" to "Ordered"
            l_req_status := pk_nnn_constant.g_req_status_ordered;
        
            -- A draft outcome have associated a draft(temporary) recurrence plan. 
            -- When the draft is converted to ordered, the associated plan also must be converted to.
        
            g_error := 'Set temporary order recurrence plan for a draft NOC outcome as definitive. id_order_recurr_plan: ' ||
                       coalesce(to_char(l_order_recurr_plan), '<null>');
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            IF NOT pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                    i_prof                    => i_prof,
                                                                    i_order_recurr_plan       => l_order_recurr_plan,
                                                                    o_order_recurr_option     => l_order_recurr_option,
                                                                    o_final_order_recurr_plan => l_order_recurr_plan,
                                                                    o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        ELSE
            -- The outcome remains in the same state, ignoring any value passed in the i_flg_req_status
            l_req_status := l_rec.flg_req_status;
        
        END IF;
    
        -- Saves the outcome edition
        l_id := pk_nnn_core.set_epis_noc_outcome(i_lang                => i_lang,
                                                 i_prof                => i_prof,
                                                 i_patient             => i_patient,
                                                 i_episode             => i_episode,
                                                 i_noc_outcome         => i_noc_outcome,
                                                 i_nnn_epis_outcome    => i_nnn_epis_outcome,
                                                 i_episode_origin      => i_episode_origin,
                                                 i_episode_destination => i_episode_destination,
                                                 i_flg_prn             => i_flg_prn,
                                                 i_notes_prn           => i_notes_prn,
                                                 i_flg_time            => i_flg_time,
                                                 i_flg_priority        => i_flg_priority,
                                                 i_order_recurr_plan   => l_order_recurr_plan,
                                                 i_flg_req_status      => l_req_status,
                                                 i_timestamp           => i_timestamp);
    
        IF l_draft_to_ordered
        THEN
            -- Because the NOC Outcome's state has transitioned from "Draft" to "Ordered"
            -- we need to prepare (now, the definitive) order plan and create the initial set of planned evaluations          
            prepare_create_outcome_plan(i_lang               => i_lang,
                                        i_prof               => i_prof,
                                        i_lst_order_rec_plan => table_number(l_order_recurr_plan),
                                        i_timestamp          => i_timestamp);
        
        END IF;
    
        -- Reschedule the plan
        IF l_recurr_plan_changed
           AND l_order_recurr_plan IS NOT NULL
        THEN
            recalculate_plan(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_flg_type            => pk_nnn_constant.g_type_outcome,
                             i_flg_adjust_mode     => g_adjust_new_plan,
                             i_req_item_id         => i_nnn_epis_outcome,
                             i_order_recurr_plan   => l_order_recurr_plan,
                             i_execution_timestamp => NULL,
                             i_timestamp           => i_timestamp);
        
        END IF;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_outcome(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the alerts associated to the given outcome
        pk_nnn_core.refresh_outcome_alert(i_lang             => i_lang,
                                          i_prof             => i_prof,
                                          i_episode          => i_episode,
                                          i_nnn_epis_outcome => i_nnn_epis_outcome);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_outcome_update;

    PROCEDURE get_next_outcome_eval_info
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_nnn_epis_outcome IN nnn_epis_outcome_eval.id_nnn_epis_outcome%TYPE,
        o_eval             OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_next_outcome_eval_info';
        l_obj_epis_outcome      t_obj_nnn_epis_outcome;
        l_obj_last_outcome_eval t_obj_nnn_epis_outcome_eval;
        l_obj_next_outcome_eval t_obj_nnn_epis_outcome_eval;
        l_aux_outcome_eval      nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE;
        l_noc_scale             noc_scale.id_noc_scale%TYPE;
        l_timestamp             TIMESTAMP WITH LOCAL TIME ZONE;
        l_suggest_eval_date     sys_config.value%TYPE;
        l_request_start_date    order_recurr_plan.start_date%TYPE;
    BEGIN
        l_timestamp := current_timestamp;
    
        -- Gets the Outcome request
        l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                 i_prof             => i_prof,
                                                                 i_nnn_epis_outcome => i_nnn_epis_outcome);
    
        -- Get the scale ID used by this Outcome for evaluations
        l_noc_scale := pk_noc_model.get_outcome_scale(i_noc_outcome => l_obj_epis_outcome.id_noc_outcome);
    
        -- Retrieves the ID of next evaluation      
        l_aux_outcome_eval := pk_nnn_core.get_next_outcome_eval(i_nnn_epis_outcome => l_obj_epis_outcome.id_nnn_epis_outcome);
    
        IF l_aux_outcome_eval IS NOT NULL
        THEN
            -- Retrieves the info about next evaluation
            l_obj_next_outcome_eval := get_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_nnn_epis_outcome_eval => l_aux_outcome_eval);
        
        ELSE
            -- There is no planned next evaluation, so will use the current timestamp as date  
            l_obj_next_outcome_eval := t_obj_nnn_epis_outcome_eval(i_id_nnn_epis_outcome => l_obj_epis_outcome.id_nnn_epis_outcome,
                                                                   i_dt_plan             => l_timestamp,
                                                                   i_status              => t_obj_status(i_flg_status      => pk_nnn_constant.g_task_status_ordered,
                                                                                                         i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                                      pk_nnn_constant.g_task_status_ordered,
                                                                                                                                                      i_lang),
                                                                                                         i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                                   i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                                   i_val      => pk_nnn_constant.g_task_status_ordered)));
        END IF;
    
        -- Retrieves the last evaluation in order to use the last Expected Outcome
        BEGIN
            SELECT /*+ opt_estimate(table t rows=1)*/
             t.id_nnn_epis_outcome_eval
              INTO l_aux_outcome_eval
              FROM TABLE(pk_nnn_core.tf_latest_nnn_epis_outc_eval(i_nnn_epis_outcome => l_obj_epis_outcome.id_nnn_epis_outcome)) t;
        
            l_obj_last_outcome_eval := get_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_nnn_epis_outcome_eval => l_aux_outcome_eval);
        EXCEPTION
            WHEN no_data_found THEN
                -- There is no evaluation yet 
                g_error := 'None evaluation has been made yet for this outcome. Assuming as Goal the best Goal''s value in the Exepected Outcome value';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_last_outcome_eval := t_obj_nnn_epis_outcome_eval(i_target_value => t_obj_likert_scale_level(i_scale_level_value      => pk_noc_cfg.k_default_scale_level,
                                                                                                                  i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang              => i_lang,
                                                                                                                                                                                i_noc_scale         => l_noc_scale,
                                                                                                                                                                                i_scale_level_value => pk_noc_cfg.k_default_scale_level)));
        END;
    
        -- Assumes as goal for the next evaluation the same as applied in the last evaluation
        l_obj_next_outcome_eval.target_value := l_obj_last_outcome_eval.target_value;
    
        -- Configuration that indicates which date is displayed by default when an evaluation/execution is made: planned date or current date
        l_suggest_eval_date := pk_sysconfig.get_config(i_code_cf => pk_nnn_constant.g_config_suggest_exec_date,
                                                       i_prof    => i_prof);
    
        -- The request's start date is used as minimum date for evaluations.                                               
        l_request_start_date := coalesce(pk_nnn_core.get_start_date(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => l_obj_epis_outcome.id_order_recurr_plan),
                                         l_timestamp);
    
        -- Returns the fields with the same structure used by get_outcome_evaluate
        OPEN o_eval FOR
            SELECT NULL id_nnn_epis_outcome_eval, -- Is sent as null because the ID of next evaluation will be resolved at saving time 
                   l_obj_next_outcome_eval.id_nnn_epis_outcome id_nnn_epis_outcome,
                   l_obj_epis_outcome.id_noc_outcome id_noc_outcome,
                   pk_noc_model.get_outcome_name(i_noc_outcome => l_obj_epis_outcome.id_noc_outcome,
                                                 i_code_format => pk_noc_model.g_code_format_end) outcome_name,
                   l_obj_next_outcome_eval.status.flg_status flg_status,
                   l_obj_next_outcome_eval.status.desc_flg_status desc_flg_status,
                   pk_date_utils.date_send_tsz(i_lang => i_lang,
                                               i_date => CASE l_suggest_eval_date
                                                             WHEN pk_nnn_constant.g_suggest_exec_planned_date THEN
                                                              coalesce(l_obj_next_outcome_eval.dt_plan, l_timestamp)
                                                             ELSE
                                                              l_timestamp
                                                         END,
                                               i_prof => i_prof) dt_evaluation,
                   pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_request_start_date, i_prof => i_prof) dt_request,
                   l_noc_scale id_noc_scale,
                   l_obj_next_outcome_eval.target_value.scale_level_value target_value,
                   NULL outcome_value,
                   l_obj_next_outcome_eval.target_value.desc_scale_level_value desc_target_value,
                   NULL desc_outcome_value,
                   NULL desc_notes
              FROM dual;
    
    END get_next_outcome_eval_info;

    FUNCTION set_outcome_evaluate
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN nnn_epis_outcome_eval.id_patient%TYPE,
        i_episode               IN nnn_epis_outcome_eval.id_episode%TYPE,
        i_nnn_epis_outcome      IN nnn_epis_outcome_eval.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_outcome_eval IN nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE,
        i_dt_evaluation         IN nnn_epis_outcome_eval.dt_evaluation%TYPE,
        i_target_value          IN nnn_epis_outcome_eval.target_value%TYPE,
        i_outcome_value         IN nnn_epis_outcome_eval.outcome_value%TYPE,
        i_notes                 IN CLOB,
        i_timestamp             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_evaluate';
        l_nnn_epis_outcome_eval nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE;
        l_rec_eval              nnn_epis_outcome_eval%ROWTYPE;
        l_rec                   nnn_epis_outcome%ROWTYPE;
        l_error                 t_error_out;
    BEGIN
    
        IF i_nnn_epis_outcome_eval IS NULL
        THEN
            -- Retrieves the ID of next planned NOC Outcome evaluation
            l_nnn_epis_outcome_eval := pk_nnn_core.get_next_outcome_eval(i_nnn_epis_outcome => i_nnn_epis_outcome);
        ELSE
            l_nnn_epis_outcome_eval := i_nnn_epis_outcome_eval;
        END IF;
    
        IF l_nnn_epis_outcome_eval IS NOT NULL
        THEN
            -- Retrieves the row data in order to get the planned dt_plan and id_recurrence_plan
            l_rec_eval := pk_nnn_core.get_epis_noc_outcome_eval_row(i_nnn_epis_outcome_eval => l_nnn_epis_outcome_eval);
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec_eval.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
            pk_alert_exceptions.assert(condition_in => i_nnn_epis_outcome = l_rec_eval.id_nnn_epis_outcome,
                                       message_in   => 'The i_nnn_epis_outcome / i_nnn_epis_outcome_eval doesn''t match');
        END IF;
    
        l_rec_eval.id_patient               := i_patient;
        l_rec_eval.id_episode               := i_episode;
        l_rec_eval.id_nnn_epis_outcome      := i_nnn_epis_outcome;
        l_rec_eval.id_nnn_epis_outcome_eval := l_nnn_epis_outcome_eval;
        l_rec_eval.dt_evaluation            := i_dt_evaluation;
        l_rec_eval.target_value             := i_target_value;
        l_rec_eval.outcome_value            := i_outcome_value;
        l_rec_eval.flg_status               := pk_nnn_constant.g_task_status_finished;
    
        -- Saves the evaluation
        l_rec_eval.id_nnn_epis_outcome_eval := pk_nnn_core.set_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                                                     i_prof                  => i_prof,
                                                                                     i_patient               => l_rec_eval.id_patient,
                                                                                     i_episode               => l_rec_eval.id_episode,
                                                                                     i_nnn_epis_outcome      => l_rec_eval.id_nnn_epis_outcome,
                                                                                     i_nnn_epis_outcome_eval => l_rec_eval.id_nnn_epis_outcome_eval,
                                                                                     i_dt_evaluation         => l_rec_eval.dt_evaluation,
                                                                                     i_target_value          => l_rec_eval.target_value,
                                                                                     i_outcome_value         => l_rec_eval.outcome_value,
                                                                                     i_notes                 => i_notes,
                                                                                     i_dt_plan               => l_rec_eval.dt_plan,
                                                                                     i_order_recurr_plan     => l_rec_eval.id_order_recurr_plan,
                                                                                     i_exec_number           => l_rec_eval.exec_number,
                                                                                     i_flg_status            => l_rec_eval.flg_status,
                                                                                     i_timestamp             => i_timestamp);
    
        -- Recalculates the planned date for the upcoming outcome evaluations according to a configuration
        -- that determines whether the forthcoming evaluations depend on the date of execution or keeps the initial planning.
        recalculate_plan(i_lang                => i_lang,
                         i_prof                => i_prof,
                         i_flg_type            => pk_nnn_constant.g_type_outcome,
                         i_flg_adjust_mode     => g_adjust_current_plan_by_date,
                         i_req_item_id         => l_rec_eval.id_nnn_epis_outcome,
                         i_order_recurr_plan   => l_rec_eval.id_order_recurr_plan,
                         i_execution_timestamp => l_rec_eval.dt_evaluation,
                         i_timestamp           => i_timestamp);
    
        -- Creates a next evaluation for this Outcome in the plan table (if needed)
        create_next_outcome_eval(i_lang              => i_lang,
                                 i_prof              => i_prof,
                                 i_nnn_epis_outcome  => l_rec_eval.id_nnn_epis_outcome,
                                 i_order_recurr_plan => l_rec_eval.id_order_recurr_plan);
    
        -- Updates the current status of the Outcome that was evaluated
    
        -- Retrieves the row data of NOC Outcome
        l_rec := pk_nnn_core.get_epis_noc_outcome_row(i_nnn_epis_outcome => l_rec_eval.id_nnn_epis_outcome);
    
        -- Evaluates if the outcome change from one state to another according the list of its states and the triggering action for each transition.
        l_rec.flg_req_status := pk_nnn_core.get_fsm_outcome_status(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_nnn_epis_outcome => l_rec_eval.id_nnn_epis_outcome,
                                                                   i_flg_req_status   => l_rec.flg_req_status,
                                                                   i_action           => pk_nnn_constant.g_action_outcome_evaluate);
    
        -- Updates the Outcome's status
        pk_nnn_core.upd_noc_outcome_status(i_lang             => i_lang,
                                           i_prof             => i_prof,
                                           i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                           i_flg_req_status   => l_rec.flg_req_status,
                                           i_timestamp        => i_timestamp);
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_outcome(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the alerts associated to the given outcome
        pk_nnn_core.refresh_outcome_alert(i_lang             => i_lang,
                                          i_prof             => i_prof,
                                          i_episode          => i_episode,
                                          i_nnn_epis_outcome => i_nnn_epis_outcome);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_rec_eval.id_nnn_epis_outcome_eval;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
        
    END set_outcome_evaluate;

    PROCEDURE set_outcome_cancel
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN nnn_epis_outcome.id_patient%TYPE,
        i_episode              IN nnn_epis_outcome.id_episode%TYPE,
        i_lst_nnn_epis_outcome IN table_number,
        i_cancel_reason        IN nnn_epis_outcome.id_cancel_reason%TYPE,
        i_cancel_notes         IN nnn_epis_outcome.cancel_notes%TYPE DEFAULT NULL,
        i_timestamp            IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_cancel';
    
        l_lst_nnn_epis_outcome    table_number;
        l_lst_nnn_epis_indicator  table_number;
        l_idx                     PLS_INTEGER;
        l_idx1                    PLS_INTEGER;
        l_rec                     nnn_epis_outcome%ROWTYPE;
        l_epis_lnk_outc_ind_rows  ts_nnn_epis_lnk_outc_ind.nnn_epis_lnk_outc_ind_tc;
        l_epis_lnk_outc_ind_rows1 ts_nnn_epis_lnk_outc_ind.nnn_epis_lnk_outc_ind_tc;
        l_epis_lnk_outc_ind_row   nnn_epis_lnk_outc_ind%ROWTYPE;
        l_can_cancel              BOOLEAN;
        l_error                   t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_outcome = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_outcome, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_outcome := coalesce(i_lst_nnn_epis_outcome, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_outcome.count
        LOOP
            -- Retrieves the row data of NOC Outcome
            l_rec := pk_nnn_core.get_epis_noc_outcome_row(i_nnn_epis_outcome => l_lst_nnn_epis_outcome(l_idx));
        
            -- Marks as cancelled all the evaluation records that are not yet executed for this Outcome
            pk_nnn_core.cancel_epis_noc_outcome_evals(i_lang             => i_lang,
                                                      i_prof             => i_prof,
                                                      i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                      i_cancel_reason    => i_cancel_reason,
                                                      i_cancel_notes     => i_cancel_notes,
                                                      i_timestamp        => i_timestamp);
        
            -- Cancel the NOC Indicators associated to this NOC Outcome
        
            -- Get linked NOC Indicators 
            l_epis_lnk_outc_ind_rows := pk_nnn_core.get_lnk_outc_ind_by_outc(i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                                             i_fltr_status      => pk_nnn_constant.g_req_status_ordered ||
                                                                                                   pk_nnn_constant.g_req_status_ongoing ||
                                                                                                   pk_nnn_constant.g_req_status_suspended);
        
            l_lst_nnn_epis_indicator := table_number();
            FOR i IN 1 .. l_epis_lnk_outc_ind_rows.count()
            LOOP
                l_epis_lnk_outc_ind_row := l_epis_lnk_outc_ind_rows(i);
            
                -- Check if NOC Indicator is linked with more than one Noc Outcome, if so we cannot cancel it
                l_epis_lnk_outc_ind_rows1 := pk_nnn_core.get_lnk_outc_ind_by_ind(i_nnn_epis_indicator => l_epis_lnk_outc_ind_row.id_nnn_epis_indicator,
                                                                                 i_fltr_status        => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing ||
                                                                                                         pk_nnn_constant.g_req_status_suspended);
            
                l_can_cancel := TRUE;
                l_idx1       := l_epis_lnk_outc_ind_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_outc_ind_rows1(l_idx1).id_nnn_epis_outcome != l_rec.id_nnn_epis_outcome
                    THEN
                        -- This indicator cannot be canceled because it is linked to another outcome
                        l_can_cancel := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_outc_ind_rows1.next(l_idx1);
                END LOOP;
            
                IF l_can_cancel
                THEN
                    -- Add this indicator to the list of indicators that will effectively being canceled
                    l_lst_nnn_epis_indicator.extend();
                    l_lst_nnn_epis_indicator(l_lst_nnn_epis_indicator.last) := l_epis_lnk_outc_ind_row.id_nnn_epis_indicator;
                END IF;
            END LOOP;
            IF l_lst_nnn_epis_indicator.count > 0
            THEN
                -- Cancel only NOC Indicators that are exclusively associated with this NOC Outcome
                pk_nnn_api_db.set_indicator_cancel(i_lang                   => i_lang,
                                                   i_prof                   => i_prof,
                                                   i_patient                => i_patient,
                                                   i_episode                => i_episode,
                                                   i_lst_nnn_epis_indicator => l_lst_nnn_epis_indicator,
                                                   i_cancel_reason          => i_cancel_reason,
                                                   i_cancel_notes           => i_cancel_notes,
                                                   i_timestamp              => i_timestamp);
            END IF;
        
            -- Evaluates the new outcome state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_outcome_status(i_lang             => i_lang,
                                                                       i_prof             => i_prof,
                                                                       i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                                       i_flg_req_status   => l_rec.flg_req_status,
                                                                       i_action           => pk_nnn_constant.g_action_outcome_cancel);
        
            -- Cancel/Discontinue the NOC Outcome
            pk_nnn_core.cancel_epis_noc_outcome(i_lang             => i_lang,
                                                i_prof             => i_prof,
                                                i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                i_cancel_reason    => i_cancel_reason,
                                                i_cancel_notes     => i_cancel_notes,
                                                i_flg_req_status   => l_rec.flg_req_status,
                                                i_timestamp        => i_timestamp);
        
            -- Removes the alerts associated to the given outcome
            IF NOT pk_alerts.delete_sys_alert_event(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_id_sys_alert => pk_nnn_constant.g_sys_alert_outcome,
                                                    i_id_record    => l_rec.id_nnn_epis_outcome,
                                                    o_error        => l_error)
            THEN
                g_error := 'Error found while calling PK_ALERTS.DELETE_SYS_ALERT_EVENT';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_outcome(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_outcome_cancel;

    PROCEDURE set_outcome_eval_cancel
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN patient.id_patient%TYPE,
        i_episode                   IN episode.id_episode%TYPE,
        i_lst_nnn_epis_outcome_eval IN table_number,
        i_cancel_reason             IN nnn_epis_outcome_eval.id_cancel_reason%TYPE,
        i_cancel_notes              IN nnn_epis_outcome_eval.cancel_notes%TYPE,
        i_timestamp                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_eval_cancel';
    
        l_lst_nnn_epis_outcome_eval table_number;
        l_idx                       PLS_INTEGER;
        l_error                     t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_outcome_eval = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_outcome_eval, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_outcome_eval := coalesce(i_lst_nnn_epis_outcome_eval, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_outcome_eval.count
        LOOP
            -- Cancel a NOC Outcome evaluation
            pk_nnn_core.cancel_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                     i_prof                  => i_prof,
                                                     i_nnn_epis_outcome_eval => l_lst_nnn_epis_outcome_eval(l_idx),
                                                     i_cancel_reason         => i_cancel_reason,
                                                     i_cancel_notes          => i_cancel_notes,
                                                     i_timestamp             => i_timestamp);
        
        END LOOP;
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_outcome_eval_cancel;

    PROCEDURE set_outcome_hold
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN nnn_epis_outcome.id_patient%TYPE,
        i_episode              IN nnn_epis_outcome.id_episode%TYPE,
        i_lst_nnn_epis_outcome IN table_number,
        i_timestamp            IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_hold';
        l_lst_nnn_epis_outcome table_number;
        l_idx                  PLS_INTEGER;
        l_rec                  nnn_epis_outcome%ROWTYPE;
        l_error                t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_outcome = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_outcome, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_outcome := coalesce(i_lst_nnn_epis_outcome, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_outcome.count
        LOOP
            -- Retrieves the row data of NOC Outcome
            l_rec := pk_nnn_core.get_epis_noc_outcome_row(i_nnn_epis_outcome => l_lst_nnn_epis_outcome(l_idx));
        
            -- Evaluates the new outcome state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_outcome_status(i_lang             => i_lang,
                                                                       i_prof             => i_prof,
                                                                       i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                                       i_flg_req_status   => l_rec.flg_req_status,
                                                                       i_action           => pk_nnn_constant.g_action_outcome_hold);
            -- Updates the Outcome's status
            pk_nnn_core.upd_noc_outcome_status(i_lang             => i_lang,
                                               i_prof             => i_prof,
                                               i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                               i_flg_req_status   => l_rec.flg_req_status,
                                               i_timestamp        => i_timestamp);
        
            -- Updates the alerts associated to the given outcome
            pk_nnn_core.refresh_outcome_alert(i_lang             => i_lang,
                                              i_prof             => i_prof,
                                              i_episode          => i_episode,
                                              i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_outcome(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    END set_outcome_hold;

    PROCEDURE set_outcome_resume
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN nnn_epis_outcome.id_patient%TYPE,
        i_episode              IN nnn_epis_outcome.id_episode%TYPE,
        i_lst_nnn_epis_outcome IN table_number,
        i_timestamp            IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_outcome_resume';
        l_lst_nnn_epis_outcome table_number;
        l_idx                  PLS_INTEGER;
        l_rec                  nnn_epis_outcome%ROWTYPE;
        l_error                t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_outcome = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_outcome, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_outcome := coalesce(i_lst_nnn_epis_outcome, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_outcome.count
        LOOP
            -- Retrieves the row data of NOC Outcome
            l_rec := pk_nnn_core.get_epis_noc_outcome_row(i_nnn_epis_outcome => l_lst_nnn_epis_outcome(l_idx));
        
            -- Evaluates the new outcome state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_outcome_status(i_lang             => i_lang,
                                                                       i_prof             => i_prof,
                                                                       i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                                                       i_flg_req_status   => l_rec.flg_req_status,
                                                                       i_action           => pk_nnn_constant.g_action_outcome_resume);
            -- Updates the Outcome's status        
            pk_nnn_core.upd_noc_outcome_status(i_lang             => i_lang,
                                               i_prof             => i_prof,
                                               i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome,
                                               i_flg_req_status   => l_rec.flg_req_status,
                                               i_timestamp        => i_timestamp);
        
            -- Updates the alerts associated to the given outcome
            pk_nnn_core.refresh_outcome_alert(i_lang             => i_lang,
                                              i_prof             => i_prof,
                                              i_episode          => i_episode,
                                              i_nnn_epis_outcome => l_rec.id_nnn_epis_outcome);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_outcome(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    END set_outcome_resume;

    FUNCTION set_indicator_update
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_patient             IN nnn_epis_indicator.id_patient%TYPE,
        i_episode             IN nnn_epis_indicator.id_episode%TYPE,
        i_noc_indicator       IN nnn_epis_indicator.id_noc_indicator%TYPE,
        i_nnn_epis_indicator  IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE,
        i_episode_origin      IN nnn_epis_indicator.id_episode_origin%TYPE,
        i_episode_destination IN nnn_epis_indicator.id_episode_destination%TYPE,
        i_flg_prn             IN nnn_epis_indicator.flg_prn%TYPE,
        i_notes_prn           IN CLOB,
        i_flg_time            IN nnn_epis_indicator.flg_time%TYPE,
        i_flg_priority        IN nnn_epis_indicator.flg_priority%TYPE,
        i_order_recurr_plan   IN nnn_epis_indicator.id_order_recurr_plan%TYPE,
        i_flg_req_status      IN nnn_epis_indicator.flg_req_status%TYPE,
        i_timestamp           IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_indicator.id_nnn_epis_indicator%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_update';
        l_id                    nnn_epis_indicator.id_nnn_epis_indicator%TYPE;
        l_error                 t_error_out;
        l_rec                   nnn_epis_indicator%ROWTYPE;
        l_order_recurr_option   order_recurr_plan.id_order_recurr_option%TYPE;
        l_order_recurr_plan     order_recurr_plan.id_order_recurr_plan%TYPE;
        l_old_order_recurr_plan order_recurr_plan.id_order_recurr_plan%TYPE;
        l_req_status            nnn_epis_indicator.flg_req_status%TYPE;
        l_recurr_plan_changed   BOOLEAN;
        l_draft_to_ordered      BOOLEAN;
    BEGIN
        l_order_recurr_plan := i_order_recurr_plan;
    
        -- Retrieves the row data of NOC Indicator
        l_rec := pk_nnn_core.get_epis_noc_indicator_row(i_nnn_epis_indicator => i_nnn_epis_indicator);
    
        -- Evaluates whether the recurrence plan will be changed by this update
        l_old_order_recurr_plan := l_rec.id_order_recurr_plan;
        l_recurr_plan_changed   := l_old_order_recurr_plan != l_order_recurr_plan;
    
        IF l_recurr_plan_changed
        THEN
            -- Sets the new temporary order recurrence plan as definitive (final status) and set the previous one as deprecated             
            IF NOT pk_order_recurrence_api_db.set_for_edit_order_recurr_plan(i_lang                    => i_lang,
                                                                             i_prof                    => i_prof,
                                                                             i_order_recurr_plan_old   => l_old_order_recurr_plan,
                                                                             i_order_recurr_plan_new   => l_order_recurr_plan,
                                                                             i_flg_discard_old_plan    => pk_alert_constant.g_yes,
                                                                             o_order_recurr_option     => l_order_recurr_option,
                                                                             o_final_order_recurr_plan => l_order_recurr_plan,
                                                                             o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_FOR_EDIT_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
        -- Evaluates whether we are dealing with a state transition from Draft to Ordered
        l_draft_to_ordered := l_rec.flg_req_status = pk_nnn_constant.g_req_status_draft AND
                              i_flg_req_status = pk_nnn_constant.g_req_status_ordered;
    
        IF l_draft_to_ordered
        THEN
            -- The Outcome transitioned from "Draft" to "Ordered"
            l_req_status := pk_nnn_constant.g_req_status_ordered;
        
            -- A draft indicator have associated a draft(temporary) recurrence plan. 
            -- When the draft is converted to ordered, the associated plan also must be converted to.
        
            g_error := 'Set temporary order recurrence plan for a draft NOC indicator as definitive. id_order_recurr_plan: ' ||
                       coalesce(to_char(l_order_recurr_plan), '<null>');
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            IF NOT pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                    i_prof                    => i_prof,
                                                                    i_order_recurr_plan       => l_order_recurr_plan,
                                                                    o_order_recurr_option     => l_order_recurr_option,
                                                                    o_final_order_recurr_plan => l_order_recurr_plan,
                                                                    o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        ELSE
            -- The indicator remains in the same state, ignoring any value passed in the i_flg_req_status
            l_req_status := l_rec.flg_req_status;
        END IF;
    
        -- Saves the indicator edition    
        l_id := pk_nnn_core.set_epis_noc_indicator(i_lang                => i_lang,
                                                   i_prof                => i_prof,
                                                   i_patient             => i_patient,
                                                   i_episode             => i_episode,
                                                   i_noc_indicator       => i_noc_indicator,
                                                   i_nnn_epis_indicator  => i_nnn_epis_indicator,
                                                   i_episode_origin      => i_episode_origin,
                                                   i_episode_destination => i_episode_destination,
                                                   i_flg_prn             => i_flg_prn,
                                                   i_notes_prn           => i_notes_prn,
                                                   i_flg_time            => i_flg_time,
                                                   i_flg_priority        => i_flg_priority,
                                                   i_order_recurr_plan   => l_order_recurr_plan,
                                                   i_flg_req_status      => l_req_status,
                                                   i_timestamp           => i_timestamp);
    
        IF l_draft_to_ordered
        THEN
            -- Because the NOC Indicator's state has transitioned from "Draft" to "Ordered"
            -- we need to prepare (now, the definitive) order plan and create the initial set of planned evaluations
            prepare_create_indicator_plan(i_lang               => i_lang,
                                          i_prof               => i_prof,
                                          i_lst_order_rec_plan => table_number(l_order_recurr_plan),
                                          i_timestamp          => i_timestamp);
        
        END IF;
    
        -- Reschedule the plan
        IF l_recurr_plan_changed
           AND l_order_recurr_plan IS NOT NULL
        THEN
            recalculate_plan(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_flg_type            => pk_nnn_constant.g_type_indicator,
                             i_flg_adjust_mode     => g_adjust_new_plan,
                             i_req_item_id         => i_nnn_epis_indicator,
                             i_order_recurr_plan   => l_order_recurr_plan,
                             i_execution_timestamp => NULL,
                             i_timestamp           => i_timestamp);
        
        END IF;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_indicator(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the alerts associated to the given indicator
        pk_nnn_core.refresh_indicator_alert(i_lang               => i_lang,
                                            i_prof               => i_prof,
                                            i_episode            => i_episode,
                                            i_nnn_epis_indicator => i_nnn_epis_indicator);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_indicator_update;

    PROCEDURE get_next_indicator_eval_info
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_outcome   IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_indicator IN nnn_epis_ind_eval.id_nnn_epis_indicator%TYPE,
        o_eval               OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_next_indicator_eval_info;';
        l_obj_epis_outcome        t_obj_nnn_epis_outcome;
        l_obj_epis_indicator      t_obj_nnn_epis_indicator;
        l_obj_last_indicator_eval t_obj_nnn_epis_ind_eval;
        l_obj_next_indicator_eval t_obj_nnn_epis_ind_eval;
        l_aux_indicator_eval      nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE;
        l_noc_scale               noc_scale.id_noc_scale%TYPE;
        l_timestamp               TIMESTAMP WITH LOCAL TIME ZONE;
        l_suggest_eval_date       sys_config.value%TYPE;
        l_request_start_date      order_recurr_plan.start_date%TYPE;
    BEGIN
        l_timestamp := current_timestamp;
    
        -- Gets the Outcome request
        l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                 i_prof             => i_prof,
                                                                 i_nnn_epis_outcome => i_nnn_epis_outcome);
    
        -- Gets the Indicator request
        l_obj_epis_indicator := pk_nnn_api_db.get_epis_noc_indicator(i_lang               => i_lang,
                                                                     i_prof               => i_prof,
                                                                     i_nnn_epis_indicator => i_nnn_epis_indicator);
    
        -- Get the scale ID used by this Indicator for evaluations
        l_noc_scale := pk_noc_model.get_indicator_scale(i_noc_outcome   => l_obj_epis_outcome.id_noc_outcome,
                                                        i_noc_indicator => l_obj_epis_indicator.id_noc_indicator);
    
        -- Retrieves the ID of next evaluation      
        l_aux_indicator_eval := pk_nnn_core.get_next_indicator_eval(i_nnn_epis_indicator => l_obj_epis_indicator.id_nnn_epis_indicator);
    
        IF l_aux_indicator_eval IS NOT NULL
        THEN
            -- Retrieves the info about next evaluation
            l_obj_next_indicator_eval := get_epis_noc_indicator_eval(i_lang              => i_lang,
                                                                     i_prof              => i_prof,
                                                                     i_nnn_epis_outcome  => l_obj_epis_outcome.id_nnn_epis_outcome,
                                                                     i_nnn_epis_ind_eval => l_aux_indicator_eval);
        
        ELSE
            -- There is no planned next evaluation, so will use the current timestamp as date  
            l_obj_next_indicator_eval := t_obj_nnn_epis_ind_eval(i_id_nnn_epis_indicator => l_obj_epis_indicator.id_nnn_epis_indicator,
                                                                 i_dt_plan               => l_timestamp,
                                                                 i_status                => t_obj_status(i_flg_status      => pk_nnn_constant.g_task_status_ordered,
                                                                                                         i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                                      pk_nnn_constant.g_task_status_ordered,
                                                                                                                                                      i_lang),
                                                                                                         i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                                   i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                                   i_val      => pk_nnn_constant.g_task_status_ordered)));
        END IF;
    
        -- Retrieves the last evaluation in order to use the last Expected Outcome
        BEGIN
            SELECT /*+ opt_estimate(table t rows=1)*/
             t.id_nnn_epis_ind_eval
              INTO l_aux_indicator_eval
              FROM TABLE(pk_nnn_core.tf_latest_nnn_epis_ind_eval(i_nnn_epis_indicator => l_obj_epis_indicator.id_nnn_epis_indicator)) t;
        
            l_obj_last_indicator_eval := get_epis_noc_indicator_eval(i_lang              => i_lang,
                                                                     i_prof              => i_prof,
                                                                     i_nnn_epis_outcome  => l_obj_epis_outcome.id_nnn_epis_outcome,
                                                                     i_nnn_epis_ind_eval => l_aux_indicator_eval);
        EXCEPTION
            WHEN no_data_found THEN
                -- There is no evaluation yet 
                g_error := 'None evaluation has been made yet for this indicator. Assuming as Goal the best Goal''s value in the Exepected Outcome value';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_last_indicator_eval := t_obj_nnn_epis_ind_eval(i_target_value => t_obj_likert_scale_level(i_scale_level_value      => pk_noc_cfg.k_default_scale_level,
                                                                                                                i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang              => i_lang,
                                                                                                                                                                              i_noc_scale         => l_noc_scale,
                                                                                                                                                                              i_scale_level_value => pk_noc_cfg.k_default_scale_level)));
        END;
    
        -- Assumes as goal for the next evaluation the same as applied in the last evaluation
        l_obj_next_indicator_eval.target_value := l_obj_last_indicator_eval.target_value;
    
        -- Configuration that indicates which date is displayed by default when an evaluation/execution is made: planned date or current date
        l_suggest_eval_date := pk_sysconfig.get_config(i_code_cf => pk_nnn_constant.g_config_suggest_exec_date,
                                                       i_prof    => i_prof);
    
        -- The request's start date is used as minimum date for evaluations.                                               
        l_request_start_date := coalesce(pk_nnn_core.get_start_date(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => l_obj_epis_indicator.id_order_recurr_plan),
                                         l_timestamp);
    
        -- Returns the fields with the same structure used by get_indicator_evaluate
        OPEN o_eval FOR
            SELECT NULL id_nnn_epis_ind_eval, -- Is sent as null because the ID of next evaluation will be resolved at saving time 
                   l_obj_next_indicator_eval.id_nnn_epis_indicator id_nnn_epis_indicator,
                   l_obj_epis_indicator.id_noc_indicator id_noc_indicator,
                   pk_noc_model.get_indicator_name(i_noc_indicator => l_obj_epis_indicator.id_noc_indicator) indicator_name,
                   l_obj_next_indicator_eval.status.flg_status flg_status,
                   l_obj_next_indicator_eval.status.desc_flg_status desc_flg_status,
                   pk_date_utils.date_send_tsz(i_lang => i_lang,
                                               i_date => CASE l_suggest_eval_date
                                                             WHEN pk_nnn_constant.g_suggest_exec_planned_date THEN
                                                              coalesce(l_obj_next_indicator_eval.dt_plan, l_timestamp)
                                                             ELSE
                                                              l_timestamp
                                                         END,
                                               i_prof => i_prof) dt_evaluation,
                   pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_request_start_date, i_prof => i_prof) dt_request,
                   l_noc_scale id_noc_scale,
                   l_obj_next_indicator_eval.target_value.scale_level_value target_value,
                   NULL indicator_value,
                   l_obj_next_indicator_eval.target_value.desc_scale_level_value desc_target_value,
                   NULL desc_indicator_value,
                   NULL desc_notes
              FROM dual;
    
    END get_next_indicator_eval_info;

    FUNCTION set_indicator_evaluate
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN nnn_epis_ind_eval.id_patient%TYPE,
        i_episode            IN nnn_epis_ind_eval.id_episode%TYPE,
        i_nnn_epis_indicator IN nnn_epis_ind_eval.id_nnn_epis_indicator%TYPE,
        i_nnn_epis_ind_eval  IN nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE,
        i_dt_evaluation      IN nnn_epis_ind_eval.dt_evaluation%TYPE,
        i_target_value       IN nnn_epis_ind_eval.target_value%TYPE,
        i_indicator_value    IN nnn_epis_ind_eval.indicator_value%TYPE,
        i_notes              IN CLOB,
        i_timestamp          IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_evaluate';
        l_nnn_epis_ind_eval nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE;
        l_rec_eval          nnn_epis_ind_eval%ROWTYPE;
        l_rec               nnn_epis_indicator%ROWTYPE;
        l_error             t_error_out;
    BEGIN
    
        IF i_nnn_epis_ind_eval IS NULL
        THEN
            -- Retrieves the ID of next planned NOC Indicator evaluation
            l_nnn_epis_ind_eval := pk_nnn_core.get_next_indicator_eval(i_nnn_epis_indicator => i_nnn_epis_indicator);
        ELSE
            l_nnn_epis_ind_eval := i_nnn_epis_ind_eval;
        END IF;
    
        IF l_nnn_epis_ind_eval IS NOT NULL
        THEN
            -- Retrieves the row data in order to get the planned dt_plan and id_recurrence_plan
            l_rec_eval := pk_nnn_core.get_epis_noc_ind_eval_row(i_nnn_epis_ind_eval => l_nnn_epis_ind_eval);
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec_eval.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
            pk_alert_exceptions.assert(condition_in => i_nnn_epis_indicator = l_rec_eval.id_nnn_epis_indicator,
                                       message_in   => 'The i_nnn_epis_indicator / i_nnn_epis_ind_eval doesn''t match');
        END IF;
    
        l_rec_eval.id_patient            := i_patient;
        l_rec_eval.id_episode            := i_episode;
        l_rec_eval.id_nnn_epis_indicator := i_nnn_epis_indicator;
        l_rec_eval.id_nnn_epis_ind_eval  := l_nnn_epis_ind_eval;
        l_rec_eval.dt_evaluation         := i_dt_evaluation;
        l_rec_eval.target_value          := i_target_value;
        l_rec_eval.indicator_value       := i_indicator_value;
        l_rec_eval.flg_status            := pk_nnn_constant.g_task_status_finished;
    
        -- Saves the evaluation
        l_rec_eval.id_nnn_epis_ind_eval := pk_nnn_core.set_epis_noc_indicator_eval(i_lang               => i_lang,
                                                                                   i_prof               => i_prof,
                                                                                   i_patient            => l_rec_eval.id_patient,
                                                                                   i_episode            => l_rec_eval.id_episode,
                                                                                   i_nnn_epis_indicator => l_rec_eval.id_nnn_epis_indicator,
                                                                                   i_nnn_epis_ind_eval  => l_rec_eval.id_nnn_epis_ind_eval,
                                                                                   i_dt_evaluation      => l_rec_eval.dt_evaluation,
                                                                                   i_target_value       => l_rec_eval.target_value,
                                                                                   i_indicator_value    => l_rec_eval.indicator_value,
                                                                                   i_notes              => i_notes,
                                                                                   i_dt_plan            => l_rec_eval.dt_plan,
                                                                                   i_order_recurr_plan  => l_rec_eval.id_order_recurr_plan,
                                                                                   i_exec_number        => l_rec_eval.exec_number,
                                                                                   i_flg_status         => l_rec_eval.flg_status,
                                                                                   i_timestamp          => i_timestamp);
    
        -- Recalculates the planned date for the upcoming indicator evaluations according to a configuration
        -- that determines whether the forthcoming evaluations depend on the date of execution or keeps the initial planning.
        recalculate_plan(i_lang                => i_lang,
                         i_prof                => i_prof,
                         i_flg_type            => pk_nnn_constant.g_type_indicator,
                         i_flg_adjust_mode     => g_adjust_current_plan_by_date,
                         i_req_item_id         => l_rec_eval.id_nnn_epis_indicator,
                         i_order_recurr_plan   => l_rec_eval.id_order_recurr_plan,
                         i_execution_timestamp => l_rec_eval.dt_evaluation,
                         i_timestamp           => i_timestamp);
    
        -- Creates a next evaluation for this NOC Indicator in the plan table (if needed)
        create_next_indicator_eval(i_lang               => i_lang,
                                   i_prof               => i_prof,
                                   i_nnn_epis_indicator => l_rec_eval.id_nnn_epis_indicator,
                                   i_order_recurr_plan  => l_rec_eval.id_order_recurr_plan);
    
        -- Updates the current status of the Indicator that was evaluated
    
        -- Retrieves the row data of NOC Indicator
        l_rec := pk_nnn_core.get_epis_noc_indicator_row(i_nnn_epis_indicator => l_rec_eval.id_nnn_epis_indicator);
        pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                   message_in   => 'The i_patient doesn''t match');
    
        -- Evaluates if the outcome change from one state to another according the list of its states and the triggering action for each transition.
        l_rec.flg_req_status := pk_nnn_core.get_fsm_indicator_status(i_lang               => i_lang,
                                                                     i_prof               => i_prof,
                                                                     i_nnn_epis_indicator => l_rec_eval.id_nnn_epis_indicator,
                                                                     i_flg_req_status     => l_rec.flg_req_status,
                                                                     i_action             => pk_nnn_constant.g_action_indicator_evaluate);
    
        -- Updates the Indicator's status
        pk_nnn_core.upd_noc_indicator_status(i_lang               => i_lang,
                                             i_prof               => i_prof,
                                             i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                             i_flg_req_status     => l_rec.flg_req_status,
                                             i_timestamp          => i_timestamp);
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_indicator(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the alerts associated to the given indicator
        pk_nnn_core.refresh_indicator_alert(i_lang               => i_lang,
                                            i_prof               => i_prof,
                                            i_episode            => i_episode,
                                            i_nnn_epis_indicator => i_nnn_epis_indicator);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_rec_eval.id_nnn_epis_ind_eval;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
        
    END set_indicator_evaluate;

    PROCEDURE set_indicator_cancel
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_patient                IN nnn_epis_indicator.id_patient%TYPE,
        i_episode                IN nnn_epis_indicator.id_episode%TYPE,
        i_lst_nnn_epis_indicator IN table_number,
        i_cancel_reason          IN nnn_epis_indicator.id_cancel_reason%TYPE,
        i_cancel_notes           IN nnn_epis_indicator.cancel_notes%TYPE DEFAULT NULL,
        i_timestamp              IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_cancel';
    
        l_lst_nnn_epis_indicator table_number;
        l_id_epis_indicator      PLS_INTEGER;
        l_rec                    nnn_epis_indicator%ROWTYPE;
        l_error                  t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_indicator = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_indicator, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_indicator := coalesce(i_lst_nnn_epis_indicator, table_number());
    
        FOR l_id_epis_indicator IN 1 .. l_lst_nnn_epis_indicator.count
        LOOP
            -- Retrieves the row data of NOC Indicator
            l_rec := pk_nnn_core.get_epis_noc_indicator_row(i_nnn_epis_indicator => l_lst_nnn_epis_indicator(l_id_epis_indicator));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Marks as cancelled all the Evaluation Indicators records that are not yet executed                  
            pk_nnn_core.cancel_epis_noc_ind_evals(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                  i_cancel_reason      => i_cancel_reason,
                                                  i_cancel_notes       => i_cancel_notes,
                                                  i_timestamp          => i_timestamp);
        
            -- Evaluates if the indicator change from one state to another according the list of its states and the triggering action for each transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_indicator_status(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                                         i_flg_req_status     => l_rec.flg_req_status,
                                                                         i_action             => pk_nnn_constant.g_action_indicator_cancel);
        
            -- Cancel/Discontinue the NOC Indicator
            pk_nnn_core.cancel_epis_noc_indicator(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                  i_cancel_reason      => i_cancel_reason,
                                                  i_cancel_notes       => i_cancel_notes,
                                                  i_flg_req_status     => l_rec.flg_req_status,
                                                  i_timestamp          => i_timestamp);
        
            -- Removes the alerts associated to the given indicator
            IF NOT pk_alerts.delete_sys_alert_event(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_id_sys_alert => pk_nnn_constant.g_sys_alert_indicator,
                                                    i_id_record    => l_rec.id_nnn_epis_indicator,
                                                    o_error        => l_error)
            THEN
                g_error := 'Error found while calling PK_ALERTS.DELETE_SYS_ALERT_EVENT';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_indicator(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_indicator_cancel;

    PROCEDURE set_indicator_eval_cancel
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN patient.id_patient%TYPE,
        i_episode               IN episode.id_episode%TYPE,
        i_lst_nnn_epis_ind_eval IN table_number,
        i_cancel_reason         IN nnn_epis_ind_eval.id_cancel_reason%TYPE,
        i_cancel_notes          IN nnn_epis_ind_eval.cancel_notes%TYPE,
        i_timestamp             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_eval_cancel';
    
        l_lst_nnn_epis_ind_eval table_number;
        l_idx                   PLS_INTEGER;
        l_error                 t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_ind_eval = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_ind_eval, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_ind_eval := coalesce(i_lst_nnn_epis_ind_eval, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_ind_eval.count
        LOOP
            -- Cancel a NOC Indicator evaluation 
            pk_nnn_core.cancel_epis_noc_ind_eval(i_lang              => i_lang,
                                                 i_prof              => i_prof,
                                                 i_nnn_epis_ind_eval => l_lst_nnn_epis_ind_eval(l_idx),
                                                 i_cancel_reason     => i_cancel_reason,
                                                 i_cancel_notes      => i_cancel_notes,
                                                 i_timestamp         => i_timestamp);
        
        END LOOP;
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_indicator_eval_cancel;

    PROCEDURE set_indicator_hold
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_patient                IN nnn_epis_indicator.id_patient%TYPE,
        i_episode                IN nnn_epis_indicator.id_episode%TYPE,
        i_lst_nnn_epis_indicator IN table_number,
        i_timestamp              IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_hold';
        l_lst_nnn_epis_indicator table_number;
        l_idx                    PLS_INTEGER;
        l_rec                    nnn_epis_indicator%ROWTYPE;
        l_error                  t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_indicator = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_indicator, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_indicator := coalesce(i_lst_nnn_epis_indicator, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_indicator.count
        LOOP
            -- Retrieves the row data of NOC Indicator
            l_rec := pk_nnn_core.get_epis_noc_indicator_row(i_nnn_epis_indicator => l_lst_nnn_epis_indicator(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Evaluates the new indicator state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_indicator_status(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                                         i_flg_req_status     => l_rec.flg_req_status,
                                                                         i_action             => pk_nnn_constant.g_action_indicator_hold);
            -- Updates the Indicator's status        
            pk_nnn_core.upd_noc_indicator_status(i_lang               => i_lang,
                                                 i_prof               => i_prof,
                                                 i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                 i_flg_req_status     => l_rec.flg_req_status,
                                                 i_timestamp          => i_timestamp);
        
            -- Updates the alerts associated to the given indicator
            pk_nnn_core.refresh_indicator_alert(i_lang               => i_lang,
                                                i_prof               => i_prof,
                                                i_episode            => i_episode,
                                                i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_indicator(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    END set_indicator_hold;

    PROCEDURE set_indicator_resume
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_patient                IN nnn_epis_indicator.id_patient%TYPE,
        i_episode                IN nnn_epis_indicator.id_episode%TYPE,
        i_lst_nnn_epis_indicator IN table_number,
        i_timestamp              IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_indicator_resume';
        l_lst_nnn_epis_indicator table_number;
        l_idx                    PLS_INTEGER;
        l_rec                    nnn_epis_indicator%ROWTYPE;
        l_error                  t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_indicator = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_indicator, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_indicator := coalesce(i_lst_nnn_epis_indicator, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_indicator.count
        LOOP
            -- Retrieves the row data of NOC Indicator
            l_rec := pk_nnn_core.get_epis_noc_indicator_row(i_nnn_epis_indicator => l_lst_nnn_epis_indicator(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Evaluates the new indicator state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_indicator_status(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                                         i_flg_req_status     => l_rec.flg_req_status,
                                                                         i_action             => pk_nnn_constant.g_action_indicator_resume);
            -- Updates the Indicator's status        
            pk_nnn_core.upd_noc_indicator_status(i_lang               => i_lang,
                                                 i_prof               => i_prof,
                                                 i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator,
                                                 i_flg_req_status     => l_rec.flg_req_status,
                                                 i_timestamp          => i_timestamp);
        
            -- Updates the alerts associated to the given indicator
            pk_nnn_core.refresh_indicator_alert(i_lang               => i_lang,
                                                i_prof               => i_prof,
                                                i_episode            => i_episode,
                                                i_nnn_epis_indicator => l_rec.id_nnn_epis_indicator);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_indicator(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    END set_indicator_resume;

    PROCEDURE set_intervention_cancel
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN nnn_epis_intervention.id_patient%TYPE,
        i_episode                   IN nnn_epis_intervention.id_episode%TYPE,
        i_lst_nnn_epis_intervention IN table_number,
        i_cancel_reason             IN nnn_epis_intervention.id_cancel_reason%TYPE,
        i_cancel_notes              IN nnn_epis_intervention.cancel_notes%TYPE DEFAULT NULL,
        i_timestamp                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_intervention_cancel';
        l_epis_lnk_int_actv_rows    ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_rows1   ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_row     nnn_epis_lnk_int_actv%ROWTYPE;
        l_lst_nnn_epis_intervention table_number;
        l_lst_nnn_epis_activity     table_number;
        l_error                     t_error_out;
        l_idx                       PLS_INTEGER;
        l_idx1                      PLS_INTEGER;
        l_rec                       nnn_epis_intervention%ROWTYPE;
        l_can_cancel                BOOLEAN;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_intervention = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_intervention, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_intervention := coalesce(i_lst_nnn_epis_intervention, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_intervention.count
        LOOP
            -- Retrieves the row data of NIC Intervention
            l_rec := pk_nnn_core.get_epis_nic_intervention_row(i_nnn_epis_intervention => l_lst_nnn_epis_intervention(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Get linked NIC Activities
            l_epis_lnk_int_actv_rows := pk_nnn_core.get_lnk_int_actv_by_intrv(i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                              i_fltr_status           => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing ||
                                                                                                         pk_nnn_constant.g_req_status_suspended);
        
            l_lst_nnn_epis_activity := table_number();
            FOR i IN 1 .. l_epis_lnk_int_actv_rows.count()
            LOOP
                l_epis_lnk_int_actv_row := l_epis_lnk_int_actv_rows(i);
            
                -- Check if NIC Activity is linked with more than one Nic Intervention, if so we cannot cancel it
                l_epis_lnk_int_actv_rows1 := pk_nnn_core.get_lnk_int_actv_by_actv(i_nnn_epis_activity => l_epis_lnk_int_actv_row.id_nnn_epis_activity,
                                                                                  i_fltr_status       => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing ||
                                                                                                         pk_nnn_constant.g_req_status_suspended);
            
                l_can_cancel := TRUE;
                l_idx1       := l_epis_lnk_int_actv_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_int_actv_rows1(l_idx1).id_nnn_epis_intervention != l_rec.id_nnn_epis_intervention
                    THEN
                        -- This activity can not be canceled because it is also linked to another intervention
                        l_can_cancel := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_int_actv_rows1.next(l_idx1);
                END LOOP;
            
                IF l_can_cancel
                THEN
                    -- Add this activity to the list of activities that will effectively being canceled
                    l_lst_nnn_epis_activity.extend();
                    l_lst_nnn_epis_activity(l_lst_nnn_epis_activity.last) := l_epis_lnk_int_actv_row.id_nnn_epis_activity;
                
                END IF;
            END LOOP;
        
            IF l_lst_nnn_epis_activity.count > 0
            THEN
                -- Cancel only NIC Activities that are exclusively associated with this NIC Intervention
                pk_nnn_api_db.set_activity_cancel(i_lang                  => i_lang,
                                                  i_prof                  => i_prof,
                                                  i_patient               => i_patient,
                                                  i_episode               => i_episode,
                                                  i_lst_nnn_epis_activity => l_lst_nnn_epis_activity,
                                                  i_cancel_reason         => i_cancel_reason,
                                                  i_cancel_notes          => i_cancel_notes,
                                                  i_timestamp             => i_timestamp);
            END IF;
        
            -- Evaluatues the new intervention state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_intervention_status(i_lang                  => i_lang,
                                                                            i_prof                  => i_prof,
                                                                            i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                            i_flg_req_status        => l_rec.flg_req_status,
                                                                            i_action                => pk_nnn_constant.g_action_intervention_cancel);
        
            -- Cancel/Discontinue the NIC Intervention 
            pk_nnn_core.cancel_epis_nic_intervention(i_lang                  => i_lang,
                                                     i_prof                  => i_prof,
                                                     i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                     i_cancel_reason         => i_cancel_reason,
                                                     i_cancel_notes          => i_cancel_notes,
                                                     i_flg_req_status        => l_rec.flg_req_status,
                                                     i_timestamp             => i_timestamp);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_intervention_cancel;

    PROCEDURE set_intervention_hold
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN nnn_epis_intervention.id_patient%TYPE,
        i_episode                   IN nnn_epis_intervention.id_episode%TYPE,
        i_lst_nnn_epis_intervention IN table_number,
        i_timestamp                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_intervention_hold';
        l_epis_lnk_int_actv_rows    ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_rows1   ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_row     nnn_epis_lnk_int_actv%ROWTYPE;
        l_lst_nnn_epis_intervention table_number;
        l_lst_nnn_epis_activity     table_number;
        l_error                     t_error_out;
        l_idx                       PLS_INTEGER;
        l_idx1                      PLS_INTEGER;
        l_rec                       nnn_epis_intervention%ROWTYPE;
        l_can_onhold                BOOLEAN;
    
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_intervention = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_intervention, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_intervention := coalesce(i_lst_nnn_epis_intervention, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_intervention.count
        LOOP
            -- Retrieves the row data of NIC Intervention
            l_rec := pk_nnn_core.get_epis_nic_intervention_row(i_nnn_epis_intervention => l_lst_nnn_epis_intervention(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Get linked NIC Activities
            l_epis_lnk_int_actv_rows := pk_nnn_core.get_lnk_int_actv_by_intrv(i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                              i_fltr_status           => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing);
        
            l_lst_nnn_epis_activity := table_number();
            FOR i IN 1 .. l_epis_lnk_int_actv_rows.count()
            LOOP
                l_epis_lnk_int_actv_row := l_epis_lnk_int_actv_rows(i);
            
                -- Check if NIC Activity is linked with more than one Nic Intervention, if so we cannot put it on hold
                l_epis_lnk_int_actv_rows1 := pk_nnn_core.get_lnk_int_actv_by_actv(i_nnn_epis_activity => l_epis_lnk_int_actv_row.id_nnn_epis_activity,
                                                                                  i_fltr_status       => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing ||
                                                                                                         pk_nnn_constant.g_req_status_suspended);
            
                l_can_onhold := TRUE;
                l_idx1       := l_epis_lnk_int_actv_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_int_actv_rows1(l_idx1).id_nnn_epis_intervention != l_rec.id_nnn_epis_intervention
                    THEN
                        -- This activity can not be put on hold because it is also linked to another intervention
                        l_can_onhold := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_int_actv_rows1.next(l_idx1);
                END LOOP;
                IF l_can_onhold
                THEN
                    -- Add this activity to the list of activities that will effectively being suspended
                    l_lst_nnn_epis_activity.extend();
                    l_lst_nnn_epis_activity(l_lst_nnn_epis_activity.last) := l_epis_lnk_int_actv_row.id_nnn_epis_activity;
                
                END IF;
            END LOOP;
        
            IF l_lst_nnn_epis_activity.count > 0
            THEN
                -- Put on-hold only NIC Activities that are exclusively associated with this NIC Intervention
                pk_nnn_api_db.set_activity_hold(i_lang                  => i_lang,
                                                i_prof                  => i_prof,
                                                i_patient               => i_patient,
                                                i_episode               => i_episode,
                                                i_lst_nnn_epis_activity => l_lst_nnn_epis_activity,
                                                i_timestamp             => i_timestamp);
            END IF;
        
            -- Evaluatues the new intervention state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_intervention_status(i_lang                  => i_lang,
                                                                            i_prof                  => i_prof,
                                                                            i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                            i_flg_req_status        => l_rec.flg_req_status,
                                                                            i_action                => pk_nnn_constant.g_action_intervention_hold);
        
            -- Updates the Intervention's status
            pk_nnn_core.upd_nic_interv_status(i_lang                  => i_lang,
                                              i_prof                  => i_prof,
                                              i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                              i_flg_req_status        => l_rec.flg_req_status,
                                              i_timestamp             => i_timestamp);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_intervention_hold;

    PROCEDURE set_intervention_resume
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN nnn_epis_intervention.id_patient%TYPE,
        i_episode                   IN nnn_epis_intervention.id_episode%TYPE,
        i_lst_nnn_epis_intervention IN table_number,
        i_timestamp                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_intervention_resume';
        l_epis_lnk_int_actv_rows    ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_rows1   ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_row     nnn_epis_lnk_int_actv%ROWTYPE;
        l_lst_nnn_epis_intervention table_number;
        l_lst_nnn_epis_activity     table_number;
        l_error                     t_error_out;
        l_idx                       PLS_INTEGER;
        l_idx1                      PLS_INTEGER;
        l_rec                       nnn_epis_intervention%ROWTYPE;
        l_can_resume                BOOLEAN;
    
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_intervention = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_intervention, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_intervention := coalesce(i_lst_nnn_epis_intervention, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_intervention.count
        LOOP
            -- Retrieves the row data of NIC Intervention
            l_rec := pk_nnn_core.get_epis_nic_intervention_row(i_nnn_epis_intervention => l_lst_nnn_epis_intervention(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Get linked NIC Activities with its state as on-hold
            l_epis_lnk_int_actv_rows := pk_nnn_core.get_lnk_int_actv_by_intrv(i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                              i_fltr_status           => pk_nnn_constant.g_req_status_suspended);
        
            l_lst_nnn_epis_activity := table_number();
            FOR i IN 1 .. l_epis_lnk_int_actv_rows.count()
            LOOP
                l_epis_lnk_int_actv_row := l_epis_lnk_int_actv_rows(i);
            
                -- Check if NIC Activity is linked with more than one Nic Intervention, if so we cannot resume it
                l_epis_lnk_int_actv_rows1 := pk_nnn_core.get_lnk_int_actv_by_actv(i_nnn_epis_activity => l_epis_lnk_int_actv_row.id_nnn_epis_activity,
                                                                                  i_fltr_status       => pk_nnn_constant.g_req_status_ordered ||
                                                                                                         pk_nnn_constant.g_req_status_ongoing ||
                                                                                                         pk_nnn_constant.g_req_status_suspended);
            
                l_can_resume := TRUE;
                l_idx1       := l_epis_lnk_int_actv_rows1.first;
                WHILE l_idx1 IS NOT NULL
                LOOP
                    IF l_epis_lnk_int_actv_rows1(l_idx1).id_nnn_epis_intervention != l_rec.id_nnn_epis_intervention
                    THEN
                        -- This activity can not be resumed because it is also linked to another intervention
                        l_can_resume := FALSE;
                        EXIT;
                    END IF;
                    l_idx1 := l_epis_lnk_int_actv_rows1.next(l_idx1);
                END LOOP;
                IF l_can_resume
                THEN
                    -- Add this activity to the list of activities that will effectively being resumed
                    l_lst_nnn_epis_activity.extend();
                    l_lst_nnn_epis_activity(l_lst_nnn_epis_activity.last) := l_epis_lnk_int_actv_row.id_nnn_epis_activity;
                
                END IF;
            END LOOP;
        
            IF l_lst_nnn_epis_activity.count > 0
            THEN
                -- Resumes only NIC Activities that are exclusively associated with this NIC Intervention
                pk_nnn_api_db.set_activity_resume(i_lang                  => i_lang,
                                                  i_prof                  => i_prof,
                                                  i_patient               => i_patient,
                                                  i_episode               => i_episode,
                                                  i_lst_nnn_epis_activity => l_lst_nnn_epis_activity,
                                                  i_timestamp             => i_timestamp);
            END IF;
        
            -- Evaluatues the new intervention state for this transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_intervention_status(i_lang                  => i_lang,
                                                                            i_prof                  => i_prof,
                                                                            i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                            i_flg_req_status        => l_rec.flg_req_status,
                                                                            i_action                => pk_nnn_constant.g_action_intervention_resume);
        
            -- Updates the Intervention's status
            pk_nnn_core.upd_nic_interv_status(i_lang                  => i_lang,
                                              i_prof                  => i_prof,
                                              i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                              i_flg_req_status        => l_rec.flg_req_status,
                                              i_timestamp             => i_timestamp);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_intervention_resume;

    /**
    * Updates the status of the NIC Interventions that are linked to a given NIC Activity.
    *
    * @param    i_lang                     Professional preferred language
    * @param    i_prof                     Professional identification and its context (institution and software)
    * @param    i_nnn_epis_activity        Careplan's NIC Activity ID
    * @param    i_action                   An action performed by the user that caused the status change
    * @param    i_timestamp                Timestamp that should be used across all the functions invoked from this one. Default to use current_timestamp
    *
    * @author   ARIEL.MACHADO
    * @version  2.6.4.3  
    * @since    5/20/2014
    */
    PROCEDURE refresh_intervention_status
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_action            IN action.internal_name%TYPE,
        i_timestamp         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        l_epis_lnk_int_actv_rows ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
        l_epis_lnk_int_actv_row  nnn_epis_lnk_int_actv%ROWTYPE;
        l_rec                    nnn_epis_intervention%ROWTYPE;
    BEGIN
    
        -- Gets active NIC Interventions that are linked with this Activity
        l_epis_lnk_int_actv_rows := pk_nnn_core.get_lnk_int_actv_by_actv(i_nnn_epis_activity => i_nnn_epis_activity,
                                                                         i_fltr_status       => pk_nnn_constant.g_req_status_ordered ||
                                                                                                pk_nnn_constant.g_req_status_ongoing ||
                                                                                                pk_nnn_constant.g_req_status_suspended);
    
        FOR i IN 1 .. l_epis_lnk_int_actv_rows.count()
        LOOP
            l_epis_lnk_int_actv_row := l_epis_lnk_int_actv_rows(i);
        
            l_rec := pk_nnn_core.get_epis_nic_intervention_row(i_nnn_epis_intervention => l_epis_lnk_int_actv_row.id_nnn_epis_intervention);
        
            l_rec.flg_req_status := pk_nnn_core.get_fsm_intervention_status(i_lang                  => i_lang,
                                                                            i_prof                  => i_prof,
                                                                            i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                                                            i_flg_req_status        => l_rec.flg_req_status,
                                                                            i_action                => i_action);
            pk_nnn_core.upd_nic_interv_status(i_lang                  => i_lang,
                                              i_prof                  => i_prof,
                                              i_nnn_epis_intervention => l_rec.id_nnn_epis_intervention,
                                              i_flg_req_status        => l_rec.flg_req_status,
                                              i_timestamp             => i_timestamp);
        
        END LOOP;
    END refresh_intervention_status;

    FUNCTION set_activity_update
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_patient             IN nnn_epis_activity.id_patient%TYPE,
        i_episode             IN nnn_epis_activity.id_episode%TYPE,
        i_nic_activity        IN nnn_epis_activity.id_nic_activity%TYPE,
        i_nnn_epis_activity   IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_episode_origin      IN nnn_epis_activity.id_episode_origin%TYPE,
        i_episode_destination IN nnn_epis_activity.id_episode_destination%TYPE,
        i_flg_prn             IN nnn_epis_activity.flg_prn%TYPE,
        i_notes_prn           IN CLOB,
        i_flg_time            IN nnn_epis_activity.flg_time%TYPE,
        i_flg_priority        IN nnn_epis_activity.flg_priority%TYPE,
        i_order_recurr_plan   IN nnn_epis_activity.id_order_recurr_plan%TYPE,
        i_flg_req_status      IN nnn_epis_activity.flg_req_status%TYPE,
        i_timestamp           IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_activity.id_nnn_epis_activity%TYPE IS
    
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_update';
        l_id                    nnn_epis_activity.id_nnn_epis_activity%TYPE;
        l_error                 t_error_out;
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_order_recurr_option   order_recurr_plan.id_order_recurr_option%TYPE;
        l_order_recurr_plan     order_recurr_plan.id_order_recurr_plan%TYPE;
        l_old_order_recurr_plan order_recurr_plan.id_order_recurr_plan%TYPE;
        l_req_status            nnn_epis_activity.flg_req_status%TYPE;
        l_recurr_plan_changed   BOOLEAN;
        l_draft_to_ordered      BOOLEAN;
    BEGIN
        l_order_recurr_plan := i_order_recurr_plan;
    
        -- Retrieves the row data of NIC Activity
        l_rec := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => i_nnn_epis_activity);
        pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                   message_in   => 'The i_patient doesn''t match');
    
        -- Evaluates whether the recurrence plan will be changed by this update
        l_old_order_recurr_plan := l_rec.id_order_recurr_plan;
        l_recurr_plan_changed   := l_old_order_recurr_plan != l_order_recurr_plan;
    
        IF l_recurr_plan_changed
        THEN
            -- Sets the new temporary order recurrence plan as definitive (final status) and set the previous one as deprecated             
            IF NOT pk_order_recurrence_api_db.set_for_edit_order_recurr_plan(i_lang                    => i_lang,
                                                                             i_prof                    => i_prof,
                                                                             i_order_recurr_plan_old   => l_old_order_recurr_plan,
                                                                             i_order_recurr_plan_new   => l_order_recurr_plan,
                                                                             i_flg_discard_old_plan    => pk_alert_constant.g_yes,
                                                                             o_order_recurr_option     => l_order_recurr_option,
                                                                             o_final_order_recurr_plan => l_order_recurr_plan,
                                                                             o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_FOR_EDIT_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        END IF;
    
        -- Evaluates whether we are dealing with a state transition from Draft to Ordered
        l_draft_to_ordered := l_rec.flg_req_status = pk_nnn_constant.g_req_status_draft AND
                              i_flg_req_status = pk_nnn_constant.g_req_status_ordered;
    
        IF l_draft_to_ordered
        THEN
            -- The Activity transitioned from "Draft" to "Ordered"
            l_req_status := pk_nnn_constant.g_req_status_ordered;
        
            -- A draft activity have associated a draft(temporary) recurrence plan. 
            -- When the draft is converted to ordered, the associated plan also must be converted to.
        
            g_error := 'Set temporary order recurrence plan for a draft NOC outcome as definitive. id_order_recurr_plan: ' ||
                       coalesce(to_char(l_order_recurr_plan), '<null>');
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            IF NOT pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                    i_prof                    => i_prof,
                                                                    i_order_recurr_plan       => l_order_recurr_plan,
                                                                    o_order_recurr_option     => l_order_recurr_option,
                                                                    o_final_order_recurr_plan => l_order_recurr_plan,
                                                                    o_error                   => l_error)
            THEN
                g_error := 'Error found while calling PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        ELSE
            -- The activity remains in the same state, ignoring any value passed in the i_flg_req_status
            l_req_status := l_rec.flg_req_status;
        
        END IF;
    
        -- Saves the activity edition
        l_id := pk_nnn_core.set_epis_nic_activity(i_lang                => i_lang,
                                                  i_prof                => i_prof,
                                                  i_patient             => i_patient,
                                                  i_episode             => i_episode,
                                                  i_nic_activity        => i_nic_activity,
                                                  i_nnn_epis_activity   => i_nnn_epis_activity,
                                                  i_episode_origin      => i_episode_origin,
                                                  i_episode_destination => i_episode_destination,
                                                  i_flg_prn             => i_flg_prn,
                                                  i_notes_prn           => i_notes_prn,
                                                  i_flg_time            => i_flg_time,
                                                  i_flg_priority        => i_flg_priority,
                                                  i_order_recurr_plan   => i_order_recurr_plan,
                                                  i_flg_req_status      => l_req_status,
                                                  i_timestamp           => i_timestamp);
        IF l_draft_to_ordered
        THEN
            -- Because the NIC Activity's state has transitioned from "Draft" to "Ordered"
            -- we need to prepare (now, the definitive) order plan and create the initial set of planned evaluations          
            prepare_create_activity_plan(i_lang               => i_lang,
                                         i_prof               => i_prof,
                                         i_lst_order_rec_plan => table_number(l_order_recurr_plan),
                                         i_timestamp          => i_timestamp);
        
        END IF;
    
        -- Reschedule the plan
        IF l_recurr_plan_changed
           AND l_order_recurr_plan IS NOT NULL
        THEN
            recalculate_plan(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_flg_type            => pk_nnn_constant.g_type_activity,
                             i_flg_adjust_mode     => g_adjust_new_plan,
                             i_req_item_id         => i_nnn_epis_activity,
                             i_order_recurr_plan   => l_order_recurr_plan,
                             i_execution_timestamp => NULL,
                             i_timestamp           => i_timestamp);
        
        END IF;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the alerts associated to the given activity
        pk_nnn_core.refresh_activity_alert(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_episode           => i_episode,
                                           i_nnn_epis_activity => i_nnn_epis_activity);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_id;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_update;

    PROCEDURE set_activity_cancel
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN nnn_epis_activity.id_patient%TYPE,
        i_episode               IN nnn_epis_activity.id_episode%TYPE,
        i_lst_nnn_epis_activity IN table_number,
        i_cancel_reason         IN nnn_epis_activity.id_cancel_reason%TYPE,
        i_cancel_notes          IN nnn_epis_activity.cancel_notes%TYPE DEFAULT NULL,
        i_timestamp             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_cancel';
    
        l_lst_nnn_epis_activity table_number;
        l_idx                   PLS_INTEGER;
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_error                 t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_activity = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_activity, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_activity := coalesce(i_lst_nnn_epis_activity, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_activity.count
        LOOP
            -- Retrieves the row data of NIC Activity
            l_rec := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => l_lst_nnn_epis_activity(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Marks as cancelled all the planned executions that are not yet executed for this Activity
            pk_nnn_core.cancel_epis_nic_activity_execs(i_lang              => i_lang,
                                                       i_prof              => i_prof,
                                                       i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                       i_cancel_reason     => i_cancel_reason,
                                                       i_cancel_notes      => i_cancel_notes,
                                                       i_timestamp         => i_timestamp);
        
            -- Evaluates the new activity state transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_activity_status(i_lang              => i_lang,
                                                                        i_prof              => i_prof,
                                                                        i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                                        i_flg_req_status    => l_rec.flg_req_status,
                                                                        i_action            => pk_nnn_constant.g_action_activity_cancel);
        
            -- Cancel/Discontinue the NIC Activity
            pk_nnn_core.cancel_epis_nic_activity(i_lang              => i_lang,
                                                 i_prof              => i_prof,
                                                 i_nnn_epis_activity => l_lst_nnn_epis_activity(l_idx),
                                                 i_cancel_reason     => i_cancel_reason,
                                                 i_cancel_notes      => i_cancel_notes,
                                                 i_flg_req_status    => l_rec.flg_req_status,
                                                 i_timestamp         => i_timestamp);
        
            -- Removes the alerts associated to the given activity
            IF NOT pk_alerts.delete_sys_alert_event(i_lang         => i_lang,
                                                    i_prof         => i_prof,
                                                    i_id_sys_alert => pk_nnn_constant.g_sys_alert_activity,
                                                    i_id_record    => l_lst_nnn_epis_activity(l_idx),
                                                    o_error        => l_error)
            THEN
                g_error := 'Error found while calling PK_ALERTS.DELETE_SYS_ALERT_EVENT';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_cancel;

    PROCEDURE set_activity_exec_cancel
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN patient.id_patient%TYPE,
        i_episode                   IN episode.id_episode%TYPE,
        i_lst_nnn_epis_activity_det IN table_number,
        i_cancel_reason             IN nnn_epis_activity_det.id_cancel_reason%TYPE,
        i_cancel_notes              IN nnn_epis_activity_det.cancel_notes%TYPE,
        i_timestamp                 IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_exec_cancel';
    
        l_lst_nnn_epis_activity_det table_number;
        l_idx                       PLS_INTEGER;
        l_error                     t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_activity_det = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_activity_det, i_delim => ','), '<null>');
        g_error := g_error || ' i_cancel_reason = ' || coalesce(to_char(i_cancel_reason), '<null>');
        g_error := g_error || ' i_cancel_notes = ' || coalesce(i_cancel_notes, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_activity_det := coalesce(i_lst_nnn_epis_activity_det, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_activity_det.count
        LOOP
            -- Cancel the NIC Activity execution
            pk_nnn_core.cancel_epis_nic_activity_exec(i_lang                  => i_lang,
                                                      i_prof                  => i_prof,
                                                      i_nnn_epis_activity_det => l_lst_nnn_epis_activity_det(l_idx),
                                                      i_cancel_reason         => i_cancel_reason,
                                                      i_cancel_notes          => i_cancel_notes,
                                                      i_timestamp             => i_timestamp);
        END LOOP;
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_exec_cancel;

    PROCEDURE set_activity_hold
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN nnn_epis_activity.id_patient%TYPE,
        i_episode               IN nnn_epis_activity.id_episode%TYPE,
        i_lst_nnn_epis_activity IN table_number,
        i_timestamp             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_hold';
    
        l_lst_nnn_epis_activity table_number;
        l_idx                   PLS_INTEGER;
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_error                 t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_activity = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_activity, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_activity := coalesce(i_lst_nnn_epis_activity, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_activity.count
        LOOP
            -- Retrieves the row data of NIC Activity
            l_rec := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => l_lst_nnn_epis_activity(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Evaluates the new activity state transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_activity_status(i_lang              => i_lang,
                                                                        i_prof              => i_prof,
                                                                        i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                                        i_flg_req_status    => l_rec.flg_req_status,
                                                                        i_action            => pk_nnn_constant.g_action_activity_hold);
        
            -- Updates the Activity's status
            pk_nnn_core.upd_nic_activity_status(i_lang              => i_lang,
                                                i_prof              => i_prof,
                                                i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                i_flg_req_status    => l_rec.flg_req_status,
                                                i_timestamp         => i_timestamp);
        
            -- Updates the alerts associated to the given activity
            pk_nnn_core.refresh_activity_alert(i_lang              => i_lang,
                                               i_prof              => i_prof,
                                               i_episode           => i_episode,
                                               i_nnn_epis_activity => l_rec.id_nnn_epis_activity);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_hold;

    PROCEDURE set_activity_resume
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN nnn_epis_activity.id_patient%TYPE,
        i_episode               IN nnn_epis_activity.id_episode%TYPE,
        i_lst_nnn_epis_activity IN table_number,
        i_timestamp             IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_resume';
    
        l_lst_nnn_epis_activity table_number;
        l_idx                   PLS_INTEGER;
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_error                 t_error_out;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_lst_nnn_epis_activity = ' ||
                   coalesce(pk_utils.concat_table(i_tab => i_lst_nnn_epis_activity, i_delim => ','), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_lst_nnn_epis_activity := coalesce(i_lst_nnn_epis_activity, table_number());
    
        FOR l_idx IN 1 .. l_lst_nnn_epis_activity.count
        LOOP
            -- Retrieves the row data of NIC Activity
            l_rec := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => l_lst_nnn_epis_activity(l_idx));
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
        
            -- Evaluates the new activity state transition.
            l_rec.flg_req_status := pk_nnn_core.get_fsm_activity_status(i_lang              => i_lang,
                                                                        i_prof              => i_prof,
                                                                        i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                                        i_flg_req_status    => l_rec.flg_req_status,
                                                                        i_action            => pk_nnn_constant.g_action_activity_resume);
        
            -- Updates the Activity's status
            pk_nnn_core.upd_nic_activity_status(i_lang              => i_lang,
                                                i_prof              => i_prof,
                                                i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                i_flg_req_status    => l_rec.flg_req_status,
                                                i_timestamp         => i_timestamp);
        
            -- Updates the alerts associated to the given activity
            pk_nnn_core.refresh_activity_alert(i_lang              => i_lang,
                                               i_prof              => i_prof,
                                               i_episode           => i_episode,
                                               i_nnn_epis_activity => l_rec.id_nnn_epis_activity);
        
            -- Updates the status of linked Interventions
            refresh_intervention_status(i_lang              => i_lang,
                                        i_prof              => i_prof,
                                        i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                        i_action            => pk_nnn_constant.g_action_activity_resume,
                                        i_timestamp         => i_timestamp);
        
        END LOOP;
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_resume;

    PROCEDURE get_activity_info
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_patient                   IN nnn_epis_outcome.id_patient%TYPE,
        i_episode                   IN nnn_epis_outcome.id_episode%TYPE,
        i_lst_nnn_epis_intervention IN table_number,
        i_lst_nnn_epis_activity     IN table_number,
        o_info                      OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_activity_info';
        e_invalid_array_size EXCEPTION;
    BEGIN
    
        --Sanity check: arrays must have same size
        IF i_lst_nnn_epis_intervention.count != i_lst_nnn_epis_activity.count
        THEN
            RAISE e_invalid_array_size;
        END IF;
    
        OPEN o_info FOR
            SELECT lnkia.id_nnn_epis_intervention,
                   lnkia.id_nnn_epis_activity,
                   pk_nic_model.get_activity_name(i_nic_activity => nea.id_nic_activity) activity_name,
                   nea.flg_doc_type,
                   nea.doc_parameter,
                   pk_nic_model.is_tasklist(i_nic_activity => nea.id_nic_activity) flg_tasklist
              FROM (SELECT id_nnn_epis_intervention, id_nnn_epis_activity
                      FROM (SELECT /*+ opt_estimate(table t rows=1)*/
                             rownum rown, t.column_value id_nnn_epis_intervention
                              FROM TABLE(i_lst_nnn_epis_intervention) t) ei
                     INNER JOIN (SELECT /*+ opt_estimate(table t rows=1)*/
                                 rownum rown, t.column_value id_nnn_epis_activity
                                  FROM TABLE(i_lst_nnn_epis_activity) t) ea
                        ON ea.rown = ei.rown) i_params
             INNER JOIN nnn_epis_lnk_int_actv lnkia
                ON lnkia.id_nnn_epis_intervention = i_params.id_nnn_epis_intervention
               AND lnkia.id_nnn_epis_activity = i_params.id_nnn_epis_activity
             INNER JOIN nnn_epis_intervention nei
                ON nei.id_nnn_epis_intervention = lnkia.id_nnn_epis_intervention
             INNER JOIN nnn_epis_activity nea
                ON nea.id_nnn_epis_activity = lnkia.id_nnn_epis_activity
             WHERE nea.id_patient = i_patient
               AND nei.id_patient = i_patient
             ORDER BY activity_name;
    
    EXCEPTION
        WHEN e_invalid_array_size THEN
            g_error := 'Invalid input parameters. Input arrays must have same size';
            pk_alert_exceptions.raise_error(error_name_in => 'e_invalid_array_size',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END get_activity_info;

    PROCEDURE get_next_activity_exec_info
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN patient.id_patient%TYPE,
        i_episode               IN episode.id_episode%TYPE,
        i_nnn_epis_intervention IN nnn_epis_intervention.id_nnn_epis_intervention%TYPE,
        i_nnn_epis_activity     IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        o_exec_info             OUT pk_types.cursor_type,
        o_activity_tasks        OUT pk_types.cursor_type,
        o_vs_info               OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_next_activity_exec_info';
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_rec_interv            nnn_epis_intervention%ROWTYPE;
        l_obj_next_activity_det t_obj_nnn_epis_activity_det;
        l_aux_activity_det      nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE;
        l_timestamp             TIMESTAMP WITH LOCAL TIME ZONE;
        l_start_date            nnn_epis_activity_det.dt_val_time_start%TYPE;
        l_end_date              nnn_epis_activity_det.dt_val_time_end%TYPE;
        l_avg_duration          nic_cfg_activity.avg_duration%TYPE;
        l_avg_uom               nic_cfg_activity.id_unit_measure_duration%TYPE;
        l_avg_duration_desc     pk_types.t_big_byte;
        l_suggest_eval_date     sys_config.value%TYPE;
        l_nic_activity_doctype  pk_nic_cfg.t_nic_activity_doctype;
        l_request_start_date    order_recurr_plan.start_date%TYPE;
        l_error                 t_error_out;
    BEGIN
        l_timestamp := current_timestamp;
    
        -- Gets the Activity request
        -- Retrieves the NIC Activity in order to evaluate the kind of documentation used to register the execution.
        l_rec        := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => i_nnn_epis_activity);
        l_rec_interv := pk_nnn_core.get_epis_nic_intervention_row(i_nnn_epis_intervention => i_nnn_epis_intervention);
    
        -- Retrieves the ID of next execution
        l_aux_activity_det := pk_nnn_core.get_next_activity_det(i_nnn_epis_activity => l_rec.id_nnn_epis_activity);
    
        IF l_aux_activity_det IS NOT NULL
        THEN
            -- Retrieves the info about next evaluation
            l_obj_next_activity_det := get_epis_nic_activity_det(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_nnn_epis_activity_det => l_aux_activity_det);
        
        ELSE
            -- There is no planned next evaluation, so will use the current timestamp as date  
            l_obj_next_activity_det := t_obj_nnn_epis_activity_det(i_id_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                                   i_dt_plan              => l_timestamp,
                                                                   i_status               => t_obj_status(i_flg_status      => pk_nnn_constant.g_task_status_ordered,
                                                                                                          i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                                       pk_nnn_constant.g_task_status_ordered,
                                                                                                                                                       i_lang),
                                                                                                          i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                                    i_code_dom => pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                                    i_val      => pk_nnn_constant.g_task_status_ordered)),
                                                                   i_bitemporal_data      => t_obj_bitemporal_data(NULL,
                                                                                                                   NULL,
                                                                                                                   NULL,
                                                                                                                   NULL));
        END IF;
    
        -- Configuration that indicates which date is displayed by default when an evaluation/execution is made: planned date or current date
        l_suggest_eval_date := pk_sysconfig.get_config(i_code_cf => pk_nnn_constant.g_config_suggest_exec_date,
                                                       i_prof    => i_prof);
    
        -- Start date
        l_start_date := CASE l_suggest_eval_date
                            WHEN pk_nnn_constant.g_suggest_exec_planned_date THEN
                             coalesce(l_obj_next_activity_det.dt_plan, l_timestamp)
                            ELSE
                             l_timestamp
                        END;
        -- When perform an activity the start date cannot be in the future
        IF l_start_date > l_timestamp
        THEN
            l_start_date := l_timestamp;
        END IF;
    
        -- Get average duration for this activity
        pk_nic_cfg.get_activity_avg_duration(i_lang         => i_lang,
                                             i_prof         => i_prof,
                                             i_nic_activity => l_rec.id_nic_activity,
                                             o_avg_duration => l_avg_duration,
                                             o_uom_duration => l_avg_uom);
    
        -- End Date: Start date + duration
        l_avg_duration_desc := l_avg_duration || ' ' ||
                               pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                            i_prof         => i_prof,
                                                                            i_unit_measure => l_avg_uom);
        l_end_date          := pk_order_recurrence_core.add_offset_to_tstz(i_offset    => l_avg_duration,
                                                                           i_timestamp => l_start_date,
                                                                           i_unit      => l_avg_uom);
    
        l_obj_next_activity_det.bitemporal_data.valid_time.dt_val_time_start := l_start_date;
        l_obj_next_activity_det.bitemporal_data.valid_time.dt_val_time_end   := l_end_date;
    
        --  Gets information about type of documentation to be used when executing a NIC Activity
        l_nic_activity_doctype := pk_nic_cfg.get_activity_doctype(i_lang         => i_lang,
                                                                  i_prof         => i_prof,
                                                                  i_nic_activity => l_rec.id_nic_activity);
    
        -- The request's start date is used as minimum date for executions.                                               
        l_request_start_date := coalesce(pk_nnn_core.get_start_date(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_order_recurr_plan => l_rec.id_order_recurr_plan),
                                         l_timestamp);
    
        -- Returns the fields with the same structure used by get_outcome_evaluate
        OPEN o_exec_info FOR
            SELECT NULL id_nnn_epis_activity_det, -- Is sent as null because the ID of next execution will be resolved at saving time 
                   l_obj_next_activity_det.id_nnn_epis_activity id_nnn_epis_activity,
                   l_rec.id_nic_activity id_nic_activity,
                   pk_nic_model.get_activity_name(i_nic_activity => l_rec.id_nic_activity) activity_name,
                   l_obj_next_activity_det.status.flg_status flg_status,
                   l_obj_next_activity_det.status.desc_flg_status desc_flg_status,
                   pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_request_start_date, i_prof => i_prof) dt_request,
                   pk_date_utils.date_send_tsz(i_lang => i_lang,
                                               i_date => l_obj_next_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                               i_prof => i_prof) dt_time_start,
                   pk_date_utils.date_send_tsz(i_lang => i_lang,
                                               i_date => l_obj_next_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                               i_prof => i_prof) dt_time_end,
                   l_avg_duration duration,
                   l_avg_uom unit_meas_duration,
                   l_avg_duration_desc duration_desc,
                   l_nic_activity_doctype.flg_tasklist flg_tasklist,
                   l_nic_activity_doctype.flg_doc_type flg_doc_type,
                   l_nic_activity_doctype.desc_doc_type desc_doc_type,
                   l_nic_activity_doctype.doc_parameter doc_parameter,
                   l_nic_activity_doctype.desc_doc_parameter desc_doc_parameter,
                   l_nic_activity_doctype.id_doc_area id_doc_area
              FROM dual;
    
        -- If this activity was defined as a tasklist, the list of tasks is retrieved
        IF pk_nic_model.is_tasklist(i_nic_activity => l_rec.id_nic_activity) = pk_alert_constant.g_yes
        THEN
            pk_nic_cfg.get_inst_activity_tasks(i_prof             => i_prof,
                                               i_nic_intervention => l_rec_interv.id_nic_intervention,
                                               i_nic_activity     => l_rec.id_nic_activity,
                                               o_activity_tasks   => o_activity_tasks);
        ELSE
            pk_types.open_my_cursor(o_activity_tasks);
        END IF;
    
        IF l_rec.flg_doc_type = pk_nnn_constant.g_doc_type_vital_sign
        THEN
            -- When an Activity was defined to be documented by a vital sign measurement
            -- the DOC_PARAMETER field identifies the associated ID_VITAL_SIGN
            IF NOT pk_api_vital_sign.get_latest_vital_sign_read(i_lang            => i_lang,
                                                                i_prof            => i_prof,
                                                                i_patient         => i_patient,
                                                                i_episode         => i_episode,
                                                                i_flg_view        => NULL,
                                                                i_dt_threshold    => NULL,
                                                                i_tbl_vs          => table_number(l_rec.doc_parameter),
                                                                i_hash_vital_sign => NULL,
                                                                o_vs_info         => o_vs_info,
                                                                o_error           => l_error)
            THEN
                g_error := 'Error found while calling PK_TOUCH_OPTION_TI.GET_VS_INFO';
                RAISE pk_nnn_constant.e_call_error;
            END IF;
        
        ELSE
            pk_types.open_my_cursor(o_vs_info);
        END IF;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END get_next_activity_exec_info;

    FUNCTION set_activity_execute
    (
        i_lang                       IN language.id_language%TYPE,
        i_prof                       IN profissional,
        i_patient                    IN nnn_epis_activity_det.id_patient%TYPE,
        i_episode                    IN nnn_epis_activity_det.id_episode%TYPE,
        i_nnn_epis_activity          IN nnn_epis_activity_det.id_nnn_epis_activity%TYPE,
        i_nnn_epis_activity_det      IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE,
        i_time_start                 IN nnn_epis_activity_det.dt_val_time_start%TYPE,
        i_time_end                   IN nnn_epis_activity_det.dt_trs_time_end%TYPE,
        i_doc_template               IN doc_template.id_doc_template%TYPE,
        i_lst_documentation          IN table_number,
        i_lst_doc_element            IN table_number,
        i_lst_doc_element_crit       IN table_number,
        i_lst_value                  IN table_varchar,
        i_lst_lst_doc_element_qualif IN table_table_number,
        i_lst_vs_element             IN table_number,
        i_lst_vs_save_mode           IN table_varchar,
        i_lst_vs                     IN table_number,
        i_lst_vs_value               IN table_number,
        i_lst_vs_uom                 IN table_number,
        i_lst_vs_scales              IN table_number,
        i_lst_vs_date                IN table_varchar,
        i_lst_vs_read                IN table_number,
        i_notes                      IN CLOB,
        i_lst_task_activity          IN table_number,
        i_lst_task_executed          IN table_varchar,
        i_lst_task_notes             IN table_varchar,
        i_lst_supply_workflow        IN table_number,
        i_lst_supply                 IN table_number,
        i_lst_supply_set             IN table_number,
        i_lst_supply_qty             IN table_number,
        i_lst_supply_type            IN table_varchar,
        i_lst_supply_barcode_scanned IN table_varchar,
        i_lst_supply_deliver_needed  IN table_varchar,
        i_lst_supply_cons_type       IN table_varchar,
        i_lst_supply_dt_expiration   IN table_varchar,
        i_lst_supply_validation      IN table_varchar,
        i_lst_supply_lot             IN table_varchar,
        i_timestamp                  IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT current_timestamp
    ) RETURN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE IS
    
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_execute';
        l_epis_documentation    epis_documentation.id_epis_documentation%TYPE;
        l_vital_sign_read_list  nnn_epis_activity_det.vital_sign_read_list%TYPE;
        l_nnn_epis_activity_det nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE;
        l_prof_cat_type         category.flg_type%TYPE;
        l_activity_det_notes    CLOB;
        l_error                 t_error_out;
        l_lst_vs_read_list      table_number;
        l_rec                   nnn_epis_activity%ROWTYPE;
        l_rec_exec              nnn_epis_activity_det%ROWTYPE;
        l_timestamp             TIMESTAMP WITH LOCAL TIME ZONE;
    
        /**
        * Save vital signs measurements that were documented in the execution of a NIC Activity
        *
        * @return  List of saved vital sign measurement (id_vital_sign_read)   
        *
        * @author   ARIEL.MACHADO
        * @version  2.6.4.3  
        * @since    5/22/2014
        */
        FUNCTION inner_set_vs_activity RETURN table_number IS
            k_function_name          CONSTANT pk_types.t_internal_name_byte := 'inner_set_vs_activity';
            k_vs_save_mode_new       CONSTANT VARCHAR2(1 CHAR) := 'N'; -- Saves a new Vital Sign measurement
            k_vs_save_mode_edit      CONSTANT VARCHAR2(1 CHAR) := 'E'; -- Saves an edition of a Vital Sign measurement
            k_vs_save_mode_review    CONSTANT VARCHAR2(1 CHAR) := 'R'; -- Saves a revision of a Vital Sign measurement
            k_vs_save_mode_associate CONSTANT VARCHAR2(1 CHAR) := 'A'; -- Associate an existent Vital Sign measurement
        
            e_invalid_array_size EXCEPTION;
        
            l_lst_saved_vital_sign_read table_number;
            --New measurements
            l_new_vs_list        table_number := table_number();
            l_new_vs_value_list  table_number := table_number();
            l_new_vs_uom_list    table_number := table_number();
            l_new_vs_scales_list table_number := table_number();
            l_new_vs_date_list   table_varchar := table_varchar();
            l_new_vs_read_list   table_number := table_number();
        
            --Review measurements
            l_rev_vs_list        table_number := table_number();
            l_rev_vs_value_list  table_number := table_number();
            l_rev_vs_uom_list    table_number := table_number();
            l_rev_vs_scales_list table_number := table_number();
            l_rev_vs_date_list   table_varchar := table_varchar();
            l_rev_vs_read_list   table_number := table_number();
            --Edit measurements
            l_edt_vs_list        table_number := table_number();
            l_edt_vs_value_list  table_number := table_number();
            l_edt_vs_uom_list    table_number := table_number();
            l_edt_vs_scales_list table_number := table_number();
            l_edt_vs_date_list   table_varchar := table_varchar();
            l_edt_vs_read_list   table_number := table_number();
            --Association-only measurements
            l_asc_vs_list        table_number := table_number();
            l_asc_vs_value_list  table_number := table_number();
            l_asc_vs_uom_list    table_number := table_number();
            l_asc_vs_scales_list table_number := table_number();
            l_asc_vs_date_list   table_varchar := table_varchar();
            l_asc_vs_read_list   table_number := table_number();
            l_dt_registry        VARCHAR2(20 CHAR);
        BEGIN
            --Sanity check: all arrays must have same size
            IF i_lst_vs_save_mode.count != i_lst_vs.count
               OR i_lst_vs_save_mode.count != i_lst_vs_value.count
               OR i_lst_vs_save_mode.count != i_lst_vs_uom.count
               OR i_lst_vs_save_mode.count != i_lst_vs_scales.count
               OR i_lst_vs_save_mode.count != i_lst_vs_date.count
               OR i_lst_vs_save_mode.count != i_lst_vs_read.count
            THEN
                RAISE e_invalid_array_size;
            END IF;
        
            -- Split the arrays according with the save-mode flag (i_lst_vs_save_mode) into 4 groups of operations:
            -- (1) Create new VS measurements
            -- (2) Review VS measurements
            -- (3) Edit VS measurements
            -- (4) Associate VS measurements
            -- After all operations done we need to return to an array of id_vital_sign_read(VSR)
            -- (are arrays because can be 1 or more VSR for vital signs like blood pressure) that will be associated to the execution of a NIC activity.
            -- This association will be done in the method set_activity_execute, concatenating each VSR with pipes and filling the field NNN_EPIS_ACTIVITY_DET.VITAL_SIGN_READ_LIST.
        
            --Initializes the output resultset
            l_lst_saved_vital_sign_read := table_number();
        
            g_error := 'Split arrays in 4 groups of operations';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            FOR x IN 1 .. i_lst_vs_save_mode.count
            LOOP
                CASE i_lst_vs_save_mode(x)
                    WHEN k_vs_save_mode_new THEN
                        l_new_vs_list.extend();
                        l_new_vs_list(l_new_vs_list.last) := i_lst_vs(x);
                    
                        l_new_vs_value_list.extend();
                        l_new_vs_value_list(l_new_vs_value_list.last) := i_lst_vs_value(x);
                    
                        l_new_vs_uom_list.extend();
                        l_new_vs_uom_list(l_new_vs_uom_list.last) := i_lst_vs_uom(x);
                    
                        l_new_vs_scales_list.extend();
                        l_new_vs_scales_list(l_new_vs_scales_list.last) := i_lst_vs_scales(x);
                    
                        l_new_vs_date_list.extend();
                        l_new_vs_date_list(l_new_vs_date_list.last) := i_lst_vs_date(x);
                    
                        l_new_vs_read_list.extend();
                        l_new_vs_read_list(l_new_vs_read_list.last) := i_lst_vs_read(x);
                    
                    WHEN k_vs_save_mode_review THEN
                        l_rev_vs_list.extend();
                        l_rev_vs_list(l_rev_vs_list.last) := i_lst_vs(x);
                    
                        l_rev_vs_value_list.extend();
                        l_rev_vs_value_list(l_rev_vs_value_list.last) := i_lst_vs_value(x);
                    
                        l_rev_vs_uom_list.extend();
                        l_rev_vs_uom_list(l_rev_vs_uom_list.last) := i_lst_vs_uom(x);
                    
                        l_rev_vs_scales_list.extend();
                        l_rev_vs_scales_list(l_rev_vs_scales_list.last) := i_lst_vs_scales(x);
                    
                        l_rev_vs_date_list.extend();
                        l_rev_vs_date_list(l_rev_vs_date_list.last) := i_lst_vs_date(x);
                    
                        l_rev_vs_read_list.extend();
                        l_rev_vs_read_list(l_rev_vs_read_list.last) := i_lst_vs_read(x);
                    
                    WHEN k_vs_save_mode_edit THEN
                        l_edt_vs_list.extend();
                        l_edt_vs_list(l_edt_vs_list.last) := i_lst_vs(x);
                    
                        l_edt_vs_value_list.extend();
                        l_edt_vs_value_list(l_edt_vs_value_list.last) := i_lst_vs_value(x);
                    
                        l_edt_vs_uom_list.extend();
                        l_edt_vs_uom_list(l_edt_vs_uom_list.last) := i_lst_vs_uom(x);
                    
                        l_edt_vs_scales_list.extend();
                        l_edt_vs_scales_list(l_edt_vs_scales_list.last) := i_lst_vs_scales(x);
                    
                        l_edt_vs_date_list.extend();
                        l_edt_vs_date_list(l_edt_vs_date_list.last) := i_lst_vs_date(x);
                    
                        l_edt_vs_read_list.extend();
                        l_edt_vs_read_list(l_edt_vs_read_list.last) := i_lst_vs_read(x);
                    
                    WHEN k_vs_save_mode_associate THEN
                        l_asc_vs_list.extend();
                        l_asc_vs_list(l_asc_vs_list.last) := i_lst_vs(x);
                    
                        l_asc_vs_value_list.extend();
                        l_asc_vs_value_list(l_asc_vs_value_list.last) := i_lst_vs_value(x);
                    
                        l_asc_vs_uom_list.extend();
                        l_asc_vs_uom_list(l_asc_vs_uom_list.last) := i_lst_vs_uom(x);
                    
                        l_asc_vs_scales_list.extend();
                        l_asc_vs_scales_list(l_asc_vs_scales_list.last) := i_lst_vs_scales(x);
                    
                        l_asc_vs_date_list.extend();
                        l_asc_vs_date_list(l_asc_vs_date_list.last) := i_lst_vs_date(x);
                    
                        l_asc_vs_read_list.extend();
                        l_asc_vs_read_list(l_asc_vs_read_list.last) := i_lst_vs_read(x);
                    
                    ELSE
                        RAISE pk_nnn_constant.e_invalid_argument;
                END CASE;
            
            END LOOP;
        
            -- Saves a list of new Vital Sign measurement
            IF l_new_vs_list.count > 0
            THEN
                g_error := 'Saving new Vital Sign measurements';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                IF NOT pk_vital_sign.set_epis_vital_sign(i_lang               => i_lang,
                                                         i_episode            => i_episode,
                                                         i_prof               => i_prof,
                                                         i_pat                => i_patient,
                                                         i_vs_id              => l_new_vs_list,
                                                         i_vs_val             => l_new_vs_value_list,
                                                         i_id_monit           => NULL,
                                                         i_unit_meas          => l_new_vs_uom_list,
                                                         i_vs_scales_elements => l_new_vs_scales_list,
                                                         i_notes              => NULL,
                                                         i_prof_cat_type      => l_prof_cat_type,
                                                         i_dt_vs_read         => l_new_vs_date_list,
                                                         i_epis_triage        => NULL,
                                                         i_unit_meas_convert  => l_new_vs_uom_list,
                                                         o_vital_sign_read    => l_new_vs_read_list,
                                                         o_dt_registry        => l_dt_registry,
                                                         o_error              => l_error)
                THEN
                    g_error := 'Error found while calling PK_VITAL_SIGN.SET_EPIS_VITAL_SIGN';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
                g_error := 'Creates VS - Number of elements that have been processed: ' || l_new_vs_read_list.count;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                --Append to output resultset the list of vital signs created
                l_lst_saved_vital_sign_read := l_lst_saved_vital_sign_read MULTISET UNION ALL l_new_vs_read_list;
            END IF;
        
            --Reviews VS measurements that have already been made and accepted to be associated to documentation
            IF l_rev_vs_read_list.count > 0
            THEN
                g_error := 'Reviewing a list of Vital Sign measurements';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                IF NOT pk_vital_sign.set_vital_sign_review(i_lang               => i_lang,
                                                           i_prof               => i_prof,
                                                           i_episode            => i_episode,
                                                           i_id_vital_sign_read => l_rev_vs_read_list,
                                                           i_review_notes       => NULL,
                                                           o_error              => l_error)
                THEN
                    g_error := 'Error found while calling PK_VITAL_SIGN.SET_VITAL_SIGN_REVIEW';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
                g_error := 'Reviews VS - Number of elements that have been processed: ' || l_rev_vs_read_list.count;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                --Append to output resultset the list of vital signs reviewed
                l_lst_saved_vital_sign_read := l_lst_saved_vital_sign_read MULTISET UNION ALL l_rev_vs_read_list;
            
            END IF;
        
            -- Edits VS measurements that were changed when correct an entry
            IF l_edt_vs_read_list.count > 0
            THEN
                g_error := 'Editing a list of Vital Sign measurements';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                FOR x IN 1 .. l_edt_vs_read_list.count
                LOOP
                    IF NOT pk_vital_sign.edit_vital_sign(i_lang                    => i_lang,
                                                         i_prof                    => i_prof,
                                                         i_id_vital_sign_read      => l_edt_vs_read_list(x),
                                                         i_value                   => l_edt_vs_value_list(x),
                                                         i_id_unit_measure         => l_edt_vs_uom_list(x),
                                                         i_dt_vital_sign_read_tstz => l_edt_vs_date_list(x),
                                                         i_dt_registry             => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                  l_timestamp,
                                                                                                                  i_prof),
                                                         i_id_unit_measure_sel     => l_edt_vs_uom_list(x),
                                                         i_tb_attribute            => NULL,
                                                         i_tb_free_text            => NULL,
                                                         i_id_edit_reason          => NULL,
                                                         i_notes_edit              => NULL,
                                                         o_error                   => l_error)
                    
                    THEN
                        g_error := 'Error found while calling PK_VITAL_SIGN.EDIT_VITAL_SIGN';
                        RAISE pk_nnn_constant.e_call_error;
                    END IF;
                END LOOP;
            
                g_error := 'Edits VS - Number of elements that have been processed: ' || l_edt_vs_read_list.count;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                --Append to output resultset the list of vital signs edited
                l_lst_saved_vital_sign_read := l_lst_saved_vital_sign_read MULTISET UNION ALL l_edt_vs_read_list;
            END IF;
        
            -- Associates existing VS measurements to the documentation
            IF l_asc_vs_read_list.count > 0
            THEN
                g_error := 'Associating a list of Vital Sign measurements';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                -- In this case just return the list of VSR that was passed by parameter. 
                -- This is used when we only want to associate with a documentation a list of measurements that are already saved,
                -- for example, when we make an edition of a documentation and none vital sign value is changed.
                -- The edited document simply will keep the same list of original measurements.
            
                g_error := 'Associates VS - Number of elements that have been processed: ' || l_asc_vs_read_list.count;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                --Append to output resultset the list of vital signs associated
                l_lst_saved_vital_sign_read := l_lst_saved_vital_sign_read MULTISET UNION ALL l_asc_vs_read_list;
            
            END IF;
        
            g_error := 'Total number of elements that have been processed: ' || l_lst_saved_vital_sign_read.count;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            --Output resultset filled and ready to returns OK.
            RETURN l_lst_saved_vital_sign_read;
        EXCEPTION
            WHEN e_invalid_array_size THEN
                g_error := 'Invalid input parameters. Input arrays must have same size';
                pk_alert_exceptions.raise_error(error_name_in => 'e_invalid_array_size',
                                                text_in       => g_error,
                                                name1_in      => 'function_name',
                                                value1_in     => k_function_name);
            
            WHEN pk_nnn_constant.e_call_error THEN
                pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                                text_in       => g_error,
                                                name1_in      => 'function_name',
                                                value1_in     => k_function_name);
            
        END inner_set_vs_activity;
    
        /**
        * Save supplies that were documented in the execution of a NIC Activity
        *
        * @param        i_old_nnn_epis_activity_det    Careplan's NIC Activity execution ID (not null when updating an existing execution, or null when is a new one)
        * @param        i_new_nnn_epis_activity_det    Generated Careplan's NIC Activity execution ID
        *
        * @author   ARIEL.MACHADO
        * @version  2.6.4.3  
        * @since    10/9/2014
        */
        PROCEDURE inner_save_supplies
        (
            i_old_nnn_epis_activity_det IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE,
            i_new_nnn_epis_activity_det IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE
        ) IS
            l_is_edition              BOOLEAN;
            l_has_supplies            VARCHAR2(1 CHAR);
            l_nnn_epis_activity_det_h nnn_epis_activity_det_h.id_nnn_epis_activity_det_h%TYPE;
            l_id_supply               table_number := table_number();
            l_id_supply_workflow      table_number := table_number();
            l_id_supply_del           table_number := table_number();
            l_lst_empty_array         table_varchar := table_varchar();
        BEGIN
            l_is_edition := (i_old_nnn_epis_activity_det IS NOT NULL);
        
            IF l_is_edition
            THEN
                g_error := 'Checks if the activity execution in edition has supplies workflow (not cancelled)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                IF NOT pk_supplies_external_api_db.get_inf_supply_workflow(i_lang               => i_lang,
                                                                           i_prof               => i_prof,
                                                                           i_id_context         => i_old_nnn_epis_activity_det,
                                                                           i_flg_context        => pk_supplies_constant.g_context_nic_activity_exec,
                                                                           i_id_supply          => table_number(),
                                                                           i_flg_status         => pk_supplies_constant.g_flg_status_can_cancel,
                                                                           o_has_supplies       => l_has_supplies,
                                                                           o_id_supply_workflow => l_id_supply_workflow,
                                                                           o_id_supply          => l_id_supply,
                                                                           o_error              => l_error)
                THEN
                    g_error := 'Error found while calling PK_SUPPLIES_API_DB.GET_INF_SUPPLY_WORKFLOW';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
                IF l_has_supplies = pk_alert_constant.g_yes
                THEN
                
                    -- Is an edition, so the history ID for the last state of this execution is retrieved 
                    -- in order to be used to associate with the supplies already consumed at that time
                    l_nnn_epis_activity_det_h := pk_nnn_core.get_id_hist_epis_activity_det(i_nnn_epis_activity_det => i_old_nnn_epis_activity_det,
                                                                                           i_dt_trs_time_end       => l_timestamp);
                
                    g_error := 'Verifies wich supplies must be removed';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => k_function_name);
                
                    IF i_lst_supply_workflow IS NOT empty
                       AND i_lst_supply IS NOT empty
                    THEN
                        l_id_supply_del := l_id_supply MULTISET except i_lst_supply;
                    ELSE
                        l_id_supply_del := l_id_supply;
                    END IF;
                
                    IF l_id_supply_del IS NOT empty
                    THEN
                        FOR i IN 1 .. l_id_supply_del.count
                        LOOP
                            FOR j IN 1 .. l_id_supply.count
                            LOOP
                                IF l_id_supply_del(i) = l_id_supply(j)
                                THEN
                                    g_error := 'Call PK_SUPPLIES_API_DB.SET_CANCEL_SUPPLY';
                                    IF NOT pk_supplies_api_db.cancel_supply_order(i_lang             => i_lang,
                                                                                  i_prof             => i_prof,
                                                                                  i_supplies         => table_number(l_id_supply_workflow(j)),
                                                                                  i_id_prof_cancel   => i_prof.id,
                                                                                  i_cancel_notes     => NULL,
                                                                                  i_id_cancel_reason => NULL,
                                                                                  i_dt_cancel        => l_timestamp,
                                                                                  o_error            => l_error)
                                    THEN
                                        g_error := 'Error found while calling PK_SUPPLIES_API_DB.SET_CANCEL_SUPPLY';
                                        RAISE pk_nnn_constant.e_call_error;
                                    END IF;
                                
                                    -- Changes the id_context of canceled supplies to id_nnn_epis_activity_det_h
                                    g_error := 'Call PK_SUPPLIES_API_DB.SET_SUPPLY_WORKFLOW_HIST';
                                    pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(j),
                                                                                i_id_context         => l_nnn_epis_activity_det_h,
                                                                                i_flg_context        => pk_supplies_constant.g_context_nic_activity_exec);
                                END IF;
                            END LOOP;
                        END LOOP;
                    END IF;
                END IF;
            
            END IF;
        
            IF i_lst_supply_workflow IS NOT empty
               AND i_lst_supply IS NOT empty
            THEN
                l_lst_empty_array.extend(i_lst_supply_workflow.count);
            
                g_error := 'Saving supplies consumption';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                IF NOT pk_supplies_api_db.set_supply_consumption(i_lang               => i_lang,
                                                                 i_prof               => i_prof,
                                                                 i_id_episode         => i_episode,
                                                                 i_id_context         => i_new_nnn_epis_activity_det,
                                                                 i_flg_context        => pk_supplies_constant.g_context_nic_activity_exec,
                                                                 i_id_supply_workflow => i_lst_supply_workflow,
                                                                 i_supply             => i_lst_supply,
                                                                 i_supply_set         => i_lst_supply_set,
                                                                 i_supply_qty         => i_lst_supply_qty,
                                                                 i_flg_supply_type    => i_lst_supply_type,
                                                                 i_barcode_scanned    => i_lst_supply_barcode_scanned,
                                                                 i_fixed_asset_number => NULL,
                                                                 i_deliver_needed     => i_lst_supply_deliver_needed,
                                                                 i_flg_cons_type      => i_lst_supply_cons_type,
                                                                 i_notes              => l_lst_empty_array,
                                                                 i_dt_expected_date   => NULL,
                                                                 i_check_quantities   => pk_alert_constant.g_no,
                                                                 i_dt_expiration      => i_lst_supply_dt_expiration,
                                                                 i_flg_validation     => i_lst_supply_validation,
                                                                 i_lot                => i_lst_supply_lot,
                                                                 o_error              => l_error)
                THEN
                    g_error := 'Error found while calling PK_SUPPLIES_API_DB.CREATE_SUP_CONSUMPTION';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
            END IF;
        
            IF l_is_edition
               AND l_id_supply_workflow IS NOT empty
            THEN
                -- Changes the id_context of modified supplies to id_nnn_epis_activity_det_h            
                FOR k IN 1 .. l_id_supply_workflow.count
                LOOP
                    pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(k),
                                                                i_id_context         => l_nnn_epis_activity_det_h,
                                                                i_flg_context        => pk_supplies_constant.g_context_nic_activity_exec);
                END LOOP;
            
            END IF;
        
        END inner_save_supplies;
    
    BEGIN
        l_timestamp := coalesce(i_timestamp, current_timestamp);
    
        IF i_nnn_epis_activity_det IS NULL
        THEN
            -- Retrieves the ID of next planned NIC Activity execution
            l_nnn_epis_activity_det := pk_nnn_core.get_next_activity_det(i_nnn_epis_activity => i_nnn_epis_activity);
        ELSE
            l_nnn_epis_activity_det := i_nnn_epis_activity_det;
        END IF;
    
        IF l_nnn_epis_activity_det IS NOT NULL
        THEN
            -- Retrieves the row data in order to get the planned dt_plan and id_recurrence_plan
            l_rec_exec := pk_nnn_core.get_epis_nic_activity_det_row(i_nnn_epis_activity_det => l_nnn_epis_activity_det);
            pk_alert_exceptions.assert(condition_in => i_patient = l_rec_exec.id_patient,
                                       message_in   => 'The i_patient doesn''t match');
            pk_alert_exceptions.assert(condition_in => i_nnn_epis_activity = l_rec_exec.id_nnn_epis_activity,
                                       message_in   => 'The i_nnn_epis_activity / i_nnn_epis_activity_det doesn''t match');
        END IF;
    
        -- Retrieves the NIC Activity in order to evaluate the kind of documentation used to register the execution.
        l_rec := pk_nnn_core.get_epis_nic_activity_row(i_nnn_epis_activity => i_nnn_epis_activity);
    
        pk_alert_exceptions.assert(condition_in => i_patient = l_rec.id_patient,
                                   message_in   => 'The i_patient doesn''t match');
    
        l_prof_cat_type := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        CASE l_rec.flg_doc_type
            WHEN pk_nnn_constant.g_doc_type_free_textnote THEN
                -- Free-text notes are saved using the Touch-option framework
                g_error := 'Saving free-text documentation';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                IF NOT pk_touch_option.set_epis_document_internal(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_prof_cat_type         => l_prof_cat_type,
                                                             i_epis                  => i_episode,
                                                             i_doc_area              => pk_nnn_constant.g_doc_area_nic_activity,
                                                             i_doc_template          => NULL,
                                                             i_epis_documentation    => l_rec_exec.id_epis_documentation,
                                                             i_flg_type              => CASE
                                                                                            WHEN l_rec_exec.id_epis_documentation IS NULL THEN
                                                                                             pk_touch_option.g_flg_edition_type_new
                                                                                            ELSE
                                                                                             pk_touch_option.g_flg_edition_type_edit
                                                                                        END,
                                                             i_dt_creation           => i_timestamp,
                                                             i_id_documentation      => table_number(),
                                                             i_id_doc_element        => table_number(),
                                                             i_id_doc_element_crit   => table_number(),
                                                             i_value                 => table_varchar(),
                                                             i_notes                 => i_notes,
                                                             i_id_epis_complaint     => NULL,
                                                             i_id_doc_element_qualif => table_table_number(),
                                                             i_epis_context          => NULL,
                                                             o_epis_documentation    => l_epis_documentation,
                                                             o_error                 => l_error)
                
                THEN
                    g_error := 'Error found while calling PK_TOUCH_OPTION.SET_EPIS_DOCUMENT_INTERNAL';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
                --The field nnn_epis_activity_det.notes is empty in this case.
                l_activity_det_notes := NULL;
            
            WHEN pk_nnn_constant.g_doc_type_template THEN
                -- Templates are saved using the Touch-option framework
                g_error := 'Saving Touch-option documentation';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                IF NOT pk_touch_option.set_epis_document_internal(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_prof_cat_type         => l_prof_cat_type,
                                                             i_epis                  => i_episode,
                                                             i_doc_area              => pk_nnn_constant.g_doc_area_nic_activity,
                                                             i_doc_template          => i_doc_template,
                                                             i_epis_documentation    => l_rec_exec.id_epis_documentation,
                                                             i_flg_type              => CASE
                                                                                            WHEN l_rec_exec.id_epis_documentation IS NULL THEN
                                                                                             pk_touch_option.g_flg_edition_type_new
                                                                                            ELSE
                                                                                             pk_touch_option.g_flg_edition_type_edit
                                                                                        END,
                                                             i_id_documentation      => i_lst_documentation,
                                                             i_id_doc_element        => i_lst_doc_element,
                                                             i_id_doc_element_crit   => i_lst_doc_element_crit,
                                                             i_value                 => i_lst_value,
                                                             i_notes                 => i_notes,
                                                             i_id_epis_complaint     => NULL,
                                                             i_id_doc_element_qualif => i_lst_lst_doc_element_qualif,
                                                             i_epis_context          => NULL,
                                                             i_episode_context       => NULL,
                                                             i_flg_table_origin      => pk_touch_option.g_flg_tab_origin_epis_doc,
                                                             i_flg_status            => pk_alert_constant.g_active,
                                                             i_dt_creation           => i_timestamp,
                                                             i_vs_element_list       => i_lst_vs_element,
                                                             i_vs_save_mode_list     => i_lst_vs_save_mode,
                                                             i_vs_list               => i_lst_vs,
                                                             i_vs_value_list         => i_lst_vs_value,
                                                             i_vs_uom_list           => i_lst_vs_uom,
                                                             i_vs_scales_list        => i_lst_vs_scales,
                                                             i_vs_date_list          => i_lst_vs_date,
                                                             i_vs_read_list          => i_lst_vs_read,
                                                             o_epis_documentation    => l_epis_documentation,
                                                             o_error                 => l_error)
                THEN
                    g_error := 'Error found while calling PK_TOUCH_OPTION.SET_EPIS_DOCUMENT_INTERNAL';
                    RAISE pk_nnn_constant.e_call_error;
                END IF;
            
                --The field nnn_epis_activity_det.notes is empty in this case.
                l_activity_det_notes := NULL;
            
            WHEN pk_nnn_constant.g_doc_type_vital_sign THEN
                -- Save vital sign measurements
                g_error := 'Saving vital signs measurements by calling inner_set_vs_activity()';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                l_lst_vs_read_list := inner_set_vs_activity();
            
                -- Builds a string that concatenates each id_vital_sign_read associated to this execution with pipes
                l_vital_sign_read_list := pk_utils.concat_table(i_tab   => l_lst_vs_read_list,
                                                                i_delim => g_vital_sign_read_list_delim);
            
                -- When vital signs measurements are documented as an activity
                -- the field nnn_epis_activity_det.notes may be used to save additional notes 
                l_activity_det_notes := i_notes;
            ELSE
                g_error := 'The documentation type(flg_doc_type) for the id_nnn_epis_activity = ' ||
                           to_char(l_rec.id_nnn_epis_activity) || ' has an unexpected value: ' || l_rec.flg_doc_type;
                RAISE pk_nnn_constant.e_invalid_argument;
            
        END CASE;
    
        l_rec_exec.id_patient               := i_patient;
        l_rec_exec.id_episode               := i_episode;
        l_rec_exec.id_nnn_epis_activity     := i_nnn_epis_activity;
        l_rec_exec.id_nnn_epis_activity_det := l_nnn_epis_activity_det;
        l_rec_exec.id_epis_documentation    := l_epis_documentation;
        l_rec_exec.vital_sign_read_list     := l_vital_sign_read_list;
        l_rec_exec.flg_status               := pk_nnn_constant.g_task_status_finished;
        l_rec_exec.dt_val_time_start        := i_time_start;
        l_rec_exec.dt_val_time_end          := i_time_end;
    
        g_error := 'Saving details of activity execution';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        l_nnn_epis_activity_det := pk_nnn_core.set_epis_nic_activity_det(i_lang                  => i_lang,
                                                                         i_prof                  => i_prof,
                                                                         i_patient               => l_rec_exec.id_patient,
                                                                         i_episode               => l_rec_exec.id_episode,
                                                                         i_nnn_epis_activity     => l_rec_exec.id_nnn_epis_activity,
                                                                         i_nnn_epis_activity_det => l_rec_exec.id_nnn_epis_activity_det,
                                                                         i_time_start            => l_rec_exec.dt_val_time_start,
                                                                         i_time_end              => l_rec_exec.dt_val_time_end,
                                                                         i_epis_documentation    => l_rec_exec.id_epis_documentation,
                                                                         i_vital_sign_read_list  => l_rec_exec.vital_sign_read_list,
                                                                         i_notes                 => l_activity_det_notes,
                                                                         i_lst_task_activity     => i_lst_task_activity,
                                                                         i_lst_task_executed     => i_lst_task_executed,
                                                                         i_lst_task_notes        => i_lst_task_notes,
                                                                         i_dt_plan               => l_rec_exec.dt_plan,
                                                                         i_order_recurr_plan     => l_rec_exec.id_order_recurr_plan,
                                                                         i_exec_number           => l_rec_exec.exec_number,
                                                                         i_flg_status            => l_rec_exec.flg_status,
                                                                         i_timestamp             => i_timestamp);
    
        -- Save supplies 
        g_error := 'Saving consumed supplies during activity execution';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        inner_save_supplies(i_old_nnn_epis_activity_det => i_nnn_epis_activity_det,
                            i_new_nnn_epis_activity_det => l_nnn_epis_activity_det);
    
        -- Evaluates the new activity state transition.
        l_rec.flg_req_status := pk_nnn_core.get_fsm_activity_status(i_lang              => i_lang,
                                                                    i_prof              => i_prof,
                                                                    i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                                                    i_flg_req_status    => l_rec.flg_req_status,
                                                                    i_action            => pk_nnn_constant.g_action_activity_execute);
    
        -- Updates the Activity's status
        pk_nnn_core.upd_nic_activity_status(i_lang              => i_lang,
                                            i_prof              => i_prof,
                                            i_nnn_epis_activity => l_rec.id_nnn_epis_activity,
                                            i_flg_req_status    => l_rec.flg_req_status,
                                            i_timestamp         => i_timestamp);
    
        -- Updates the grid task
        pk_nnn_core.set_tasks_activity(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        -- Updates the status of linked Interventions
        refresh_intervention_status(i_lang              => i_lang,
                                    i_prof              => i_prof,
                                    i_nnn_epis_activity => i_nnn_epis_activity,
                                    i_action            => pk_nnn_constant.g_action_activity_execute,
                                    i_timestamp         => i_timestamp);
    
        -- Updates the alerts associated to the given activity
        pk_nnn_core.refresh_activity_alert(i_lang              => i_lang,
                                           i_prof              => i_prof,
                                           i_episode           => i_episode,
                                           i_nnn_epis_activity => i_nnn_epis_activity);
    
        -- Updates the dates of the first and last clinical interactions within this episode
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => i_patient,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => i_timestamp,
                                      i_dt_first_obs        => i_timestamp,
                                      o_error               => l_error)
        THEN
            g_error := 'Error found while calling PK_VISIT.SET_FIRST_OBS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
    
        RETURN l_nnn_epis_activity_det;
    
    EXCEPTION
        WHEN pk_nnn_constant.e_call_error THEN
            pk_alert_exceptions.raise_error(error_name_in => 'e_call_error',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_execute;

    FUNCTION set_activity_execute
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_patient          IN nnn_epis_activity_det.id_patient%TYPE,
        i_episode          IN nnn_epis_activity_det.id_episode%TYPE,
        i_jsn_input_params IN CLOB
    ) RETURN table_number IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'set_activity_execute';
        l_json_document json_object_t;
        l_id            nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE;
        l_lst_id        table_number;
        l_lst_params    pk_nnn_type.t_lst_nnn_ux_set_activity_exec;
        l_params        pk_nnn_type.t_nnn_ux_set_activity_exec_rec;
    
    BEGIN
    
        /*g_error := 'Creating an instance of JSON type using the json document passed as argument in i_jsn_input_params';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            l_json_document := json(i_jsn_input_params);
        
            g_error := 'Extracts and deserializes from JSON object the nested collection of NIC activities and their params';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            l_lst_params := pk_nnn_type.get_lst_ux_set_activity_exec(i_lang => i_lang,
                                                                     i_prof => i_prof,
                                                                     i_json => l_json_document);
        
            g_error := '# of NIC activities executed: ' || l_lst_params.count();
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            l_lst_id := table_number();
        
            g_error := 'Saving/Updating the execution of a collection of NIC Activities';
            FOR i IN 1 .. l_lst_params.count
            LOOP
                l_params := l_lst_params(i);
                g_error  := 'Saving execution of NIC Activity with id_nnn_epis_activity: ' ||
                            to_char(l_params.i_nnn_epis_activity);
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
            
                l_id := pk_nnn_api_db.set_activity_execute(i_lang                       => i_lang,
                                                           i_prof                       => i_prof,
                                                           i_patient                    => i_patient,
                                                           i_episode                    => i_episode,
                                                           i_nnn_epis_activity          => l_params.i_nnn_epis_activity,
                                                           i_nnn_epis_activity_det      => l_params.i_nnn_epis_activity_det,
                                                           i_time_start                 => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                         i_prof      => i_prof,
                                                                                                                         i_timestamp => l_params.i_time_start,
                                                                                                                         i_timezone  => NULL),
                                                           i_time_end                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                         i_prof      => i_prof,
                                                                                                                         i_timestamp => l_params.i_time_end,
                                                                                                                         i_timezone  => NULL),
                                                           i_doc_template               => l_params.i_doc_template,
                                                           i_lst_documentation          => l_params.i_lst_documentation,
                                                           i_lst_doc_element            => l_params.i_lst_doc_element,
                                                           i_lst_doc_element_crit       => l_params.i_lst_doc_element_crit,
                                                           i_lst_value                  => l_params.i_lst_value,
                                                           i_lst_lst_doc_element_qualif => l_params.i_lst_lst_doc_element_qualif,
                                                           i_lst_vs_element             => l_params.i_lst_vs_element,
                                                           i_lst_vs_save_mode           => l_params.i_lst_vs_save_mode,
                                                           i_lst_vs                     => l_params.i_lst_vs,
                                                           i_lst_vs_value               => l_params.i_lst_vs_value,
                                                           i_lst_vs_uom                 => l_params.i_lst_vs_uom,
                                                           i_lst_vs_scales              => l_params.i_lst_vs_scales,
                                                           i_lst_vs_date                => l_params.i_lst_vs_date,
                                                           i_lst_vs_read                => l_params.i_lst_vs_read,
                                                           i_notes                      => l_params.i_notes,
                                                           i_lst_task_activity          => l_params.i_lst_task_activity,
                                                           i_lst_task_executed          => l_params.i_lst_task_executed,
                                                           i_lst_task_notes             => l_params.i_lst_task_notes,
                                                           i_lst_supply_workflow        => l_params.i_lst_supply_workflow,
                                                           i_lst_supply                 => l_params.i_lst_supply,
                                                           i_lst_supply_set             => l_params.i_lst_supply_set,
                                                           i_lst_supply_qty             => l_params.i_lst_supply_qty,
                                                           i_lst_supply_type            => l_params.i_lst_supply_type,
                                                           i_lst_supply_barcode_scanned => l_params.i_lst_supply_barcode_scanned,
                                                           i_lst_supply_deliver_needed  => l_params.i_lst_supply_deliver_needed,
                                                           i_lst_supply_cons_type       => l_params.i_lst_supply_cons_type,
                                                           i_lst_supply_dt_expiration   => l_params.i_lst_supply_dt_expiration,
                                                           i_lst_supply_validation      => l_params.i_lst_supply_validation,
                                                           i_lst_supply_lot             => l_params.i_lst_supply_lot);
            
                -- Appends to the output list the id_nnn_epis_activity_det
                l_lst_id.extend(1);
                l_lst_id(l_lst_id.last) := l_id;
            END LOOP;
        */
        RETURN l_lst_id;
    
    EXCEPTION
        WHEN OTHERS THEN
            -- In order to log the g_error variable that can be useful to detect the step where error was raised
            pk_alert_exceptions.raise_error(error_name_in => 'e_set_activity_execute',
                                            text_in       => g_error,
                                            name1_in      => 'function_name',
                                            value1_in     => k_function_name);
    END set_activity_execute;

    FUNCTION get_indicator_scale
    (
        i_nnn_epis_outcome   IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE
    ) RETURN noc_scale.id_noc_scale%TYPE IS
        l_noc_scale noc_scale.id_noc_scale%TYPE;
    BEGIN
        IF i_nnn_epis_outcome IS NOT NULL
        THEN
            -- The scale descriptions used by NOC indicator depends on the associated NOC outcome        
            SELECT pk_noc_model.get_indicator_scale(i_noc_outcome   => eo.id_noc_outcome,
                                                    i_noc_indicator => ei.id_noc_indicator) id_noc_scale
              INTO l_noc_scale
              FROM nnn_epis_lnk_outc_ind lnkoi
             INNER JOIN nnn_epis_outcome eo
                ON lnkoi.id_nnn_epis_outcome = eo.id_nnn_epis_outcome
             INNER JOIN nnn_epis_indicator ei
                ON lnkoi.id_nnn_epis_indicator = ei.id_nnn_epis_indicator
             WHERE lnkoi.id_nnn_epis_outcome = i_nnn_epis_outcome
               AND lnkoi.id_nnn_epis_indicator = i_nnn_epis_indicator;
        
        ELSE
            -- This is a workaround to retrieve the scale in scenarios where the outcome associated to the indicator is not available to be sent (item-type oriented View).
            -- Evaluates the linked outcomes to this indicator and retrieves the first one. 
            -- This approach, whenever possible, sould be avoided.
            SELECT DISTINCT pk_noc_model.get_indicator_scale(i_noc_outcome   => eo.id_noc_outcome,
                                                             i_noc_indicator => ei.id_noc_indicator) id_noc_scale
              INTO l_noc_scale
            
              FROM nnn_epis_indicator ei
             INNER JOIN nnn_epis_lnk_outc_ind lnkoi
                ON lnkoi.id_nnn_epis_indicator = ei.id_nnn_epis_indicator
               AND lnkoi.flg_lnk_status = pk_alert_constant.g_active
             INNER JOIN nnn_epis_outcome eo
                ON eo.id_nnn_epis_outcome = lnkoi.id_nnn_epis_outcome
             WHERE ei.id_nnn_epis_indicator = i_nnn_epis_indicator
               AND rownum < 2;
        END IF;
    
        RETURN l_noc_scale;
    END get_indicator_scale;

    FUNCTION get_epis_nan_diagnosis
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diagnosis IN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE
    ) RETURN t_obj_nnn_epis_diagnosis IS
        l_obj t_obj_nnn_epis_diagnosis;
    BEGIN
        -- Get information of NANDA diagnosis
        SELECT t_obj_nnn_epis_diagnosis(i_id_nnn_epis_diagnosis => ned.id_nnn_epis_diagnosis,
                                        i_id_nan_diagnosis      => ned.id_nan_diagnosis,
                                        i_context_record        => t_obj_context_record(i_id_episode => ned.id_episode),
                                        i_prof_info             => t_obj_prof_info(i_id_professional => ned.id_professional,
                                                                                   i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => ned.id_professional),
                                                                                   i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => ned.id_professional,
                                                                                                                                         i_dt_reg  => ned.dt_trs_time_start,
                                                                                                                                         i_episode => ned.id_episode)),
                                        
                                        i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                      i_prof             => i_prof,
                                                                                      i_id_cancel_reason => ned.id_cancel_reason,
                                                                                      i_cancel_notes     => ned.cancel_notes),
                                        i_status                 => t_obj_status(i_flg_status      => ned.flg_req_status,
                                                                                 i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_flg_req_status,
                                                                                                                              ned.flg_req_status,
                                                                                                                              i_lang)),
                                        i_dt_diagnosis           => ned.dt_diagnosis,
                                        i_notes                  => ned.edited_diagnosis_name,
                                        i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => ned.dt_val_time_start,
                                                                                          i_val_time_end   => ned.dt_val_time_end,
                                                                                          i_trs_time_start => ned.dt_trs_time_start,
                                                                                          i_trs_time_end   => ned.dt_trs_time_end),
                                        i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                          FROM dual
                                                                         WHERE EXISTS
                                                                         (SELECT 1
                                                                                  FROM nnn_epis_diagnosis_h hst
                                                                                 WHERE hst.id_nnn_epis_diagnosis =
                                                                                       ned.id_nnn_epis_diagnosis)),
                                                                        pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_diagnosis ned
         WHERE ned.id_nnn_epis_diagnosis = i_nnn_epis_diagnosis;
    
        RETURN l_obj;
    END get_epis_nan_diagnosis;

    PROCEDURE get_epis_nan_diagnosis_h
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diagnosis IN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE,
        o_hist               OUT pk_types.cursor_type
    ) IS
    BEGIN
    
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_diagnosis_h, t.obj_nnn_epis_diagnosis
              FROM (SELECT NULL id_nnn_epis_diagnosis_h,
                           t_obj_nnn_epis_diagnosis(i_id_nnn_epis_diagnosis => ned.id_nnn_epis_diagnosis,
                                                    i_id_nan_diagnosis      => ned.id_nan_diagnosis,
                                                    i_context_record        => t_obj_context_record(i_id_episode => ned.id_episode),
                                                    i_prof_info             => t_obj_prof_info(i_id_professional => ned.id_professional,
                                                                                               i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => ned.id_professional),
                                                                                               i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => ned.id_professional,
                                                                                                                                                     i_dt_reg  => ned.dt_trs_time_start,
                                                                                                                                                     i_episode => ned.id_episode)),
                                                    
                                                    i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                  i_prof             => i_prof,
                                                                                                  i_id_cancel_reason => ned.id_cancel_reason,
                                                                                                  i_cancel_notes     => ned.cancel_notes),
                                                    i_status                 => t_obj_status(i_flg_status      => ned.flg_req_status,
                                                                                             i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_flg_req_status,
                                                                                                                                          ned.flg_req_status,
                                                                                                                                          i_lang)),
                                                    i_dt_diagnosis           => ned.dt_diagnosis,
                                                    i_notes                  => ned.edited_diagnosis_name,
                                                    i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => ned.dt_val_time_start,
                                                                                                      i_val_time_end   => ned.dt_val_time_end,
                                                                                                      i_trs_time_start => ned.dt_trs_time_start,
                                                                                                      i_trs_time_end   => ned.dt_trs_time_end),
                                                    i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                      FROM dual
                                                                                     WHERE EXISTS
                                                                                     (SELECT 1
                                                                                              FROM nnn_epis_diagnosis_h hst
                                                                                             WHERE hst.id_nnn_epis_diagnosis =
                                                                                                   ned.id_nnn_epis_diagnosis)),
                                                                                    pk_alert_constant.g_no)) obj_nnn_epis_diagnosis,
                           ned.dt_trs_time_start,
                           ned.dt_trs_time_end
                      FROM nnn_epis_diagnosis ned
                     WHERE ned.id_nnn_epis_diagnosis = i_nnn_epis_diagnosis
                    UNION ALL
                    SELECT nedh.id_nnn_epis_diagnosis_h,
                           t_obj_nnn_epis_diagnosis(i_id_nnn_epis_diagnosis => nedh.id_nnn_epis_diagnosis,
                                                    i_id_nan_diagnosis      => nedh.id_nan_diagnosis,
                                                    i_context_record        => t_obj_context_record(i_id_episode => nedh.id_episode),
                                                    i_prof_info             => t_obj_prof_info(i_id_professional => nedh.id_professional,
                                                                                               i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => nedh.id_professional),
                                                                                               i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => nedh.id_professional,
                                                                                                                                                     i_dt_reg  => nedh.dt_trs_time_start,
                                                                                                                                                     i_episode => nedh.id_episode)),
                                                    
                                                    i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                  i_prof             => i_prof,
                                                                                                  i_id_cancel_reason => nedh.id_cancel_reason,
                                                                                                  i_cancel_notes     => nedh.cancel_notes),
                                                    i_status                 => t_obj_status(i_flg_status      => nedh.flg_req_status,
                                                                                             i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_flg_req_status,
                                                                                                                                          nedh.flg_req_status,
                                                                                                                                          i_lang)),
                                                    i_dt_diagnosis           => nedh.dt_diagnosis,
                                                    i_notes                  => nedh.edited_diagnosis_name,
                                                    i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => nedh.dt_val_time_start,
                                                                                                      i_val_time_end   => nedh.dt_val_time_end,
                                                                                                      i_trs_time_start => nedh.dt_trs_time_start,
                                                                                                      i_trs_time_end   => nedh.dt_trs_time_end),
                                                    i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                      FROM dual
                                                                                     WHERE EXISTS
                                                                                     (SELECT 1
                                                                                              FROM nnn_epis_diagnosis_h hst
                                                                                             WHERE hst.id_nnn_epis_diagnosis =
                                                                                                   nedh.id_nnn_epis_diagnosis)),
                                                                                    pk_alert_constant.g_no)) obj_nnn_epis_diagnosis,
                           nedh.dt_trs_time_start,
                           nedh.dt_trs_time_end
                      FROM nnn_epis_diagnosis_h nedh
                     WHERE nedh.id_nnn_epis_diagnosis = i_nnn_epis_diagnosis) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_nan_diagnosis_h;

    PROCEDURE get_epis_nan_diagnosis_det
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diagnosis IN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE,
        i_flg_detail_type    IN VARCHAR2,
        o_detail             OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_nan_diagnosis_det';
    
        TYPE lt_coll_obj_nnn_epis_diagnosis IS TABLE OF t_obj_nnn_epis_diagnosis;
    
        l_label_edition  sys_message.desc_message%TYPE;
        l_label_creation sys_message.desc_message%TYPE;
        l_label_cancel   sys_message.desc_message%TYPE;
    
        l_flg_call VARCHAR2(1 CHAR);
        l_cursor   pk_types.cursor_type;
    
        l_coll_obj_nnn_epis_diagnosis lt_coll_obj_nnn_epis_diagnosis;
        l_coll_nnn_epis_diagnosis_h   table_number;
    
        l_obj_nnn_epis_diagnosis      t_obj_nnn_epis_diagnosis;
        l_prev_obj_nnn_epis_diagnosis t_obj_nnn_epis_diagnosis;
        l_obj_nan_diagnosis           t_obj_nan_diagnosis;
        l_prev_obj_nan_diagnosis      t_obj_nan_diagnosis;
    
        l_nnn_epis_diagnosis_h nnn_epis_diagnosis_h.id_nnn_epis_diagnosis_h%TYPE;
    
        l_jsn_diag_detail       json_object_t;
        l_jsn_outcome           json_object_t;
        l_jsn_indicator         json_object_t;
        l_jsn_intervention      json_object_t;
        l_jsn_actitivy          json_object_t;
        l_lst_jsn               json_array_t;
        l_lst_jsn_outcomes      json_array_t;
        l_lst_jsn_indicators    json_array_t;
        l_lst_jsn_interventions json_array_t;
        l_lst_jsn_activities    json_array_t;
        l_lst_varchar           table_varchar;
        l_req_status            nnn_epis_diagnosis.flg_req_status%TYPE;
        l_value_string          pk_types.t_huge_byte;
    BEGIN
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_nnn_epis_diagnosis = ' || coalesce(to_char(i_nnn_epis_diagnosis), '<null>');
        g_error := g_error || ' i_flg_detail_type = ' || coalesce(i_flg_detail_type, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
    
        --Initialization of detail table
        /* pk_edis_hist.init_vars;
        
        CASE i_flg_detail_type
        
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details: 
                --     Displays the current Careplan's NANDA Diagnosis info
                --     The last diagnosis' evaluation
                --     An hierachical detail of all current items in the care plan that are linked to this diagnosis
            
                -- Gets an hierachical detail of the Careplan for a NANDA Diagnosis in JSON.
                l_jsn_diag_detail := pk_nnn_api_db.get_epis_diagnosis_hier_detail(i_lang               => i_lang,
                                                                                  i_prof               => i_prof,
                                                                                  i_nnn_epis_diagnosis => i_nnn_epis_diagnosis);
            
                -- Request's status
                l_req_status := json_ext.get_string(l_jsn_diag_detail, 'STATUS.FLG_STATUS');
            
                IF l_req_status IN (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                THEN
                    -- Status of the entry
                    pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                          i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                     i_prof      => i_prof,
                                                                                     i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                        'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                     i_timezone  => NULL),
                                          
                                          i_record_state   => json_ext.get_string(l_jsn_diag_detail, 'STATUS.FLG_STATUS'),
                                          i_desc_rec_state => json_ext.get_string(l_jsn_diag_detail,
                                                                                  'STATUS.DESC_FLG_STATUS'),
                                          i_professional   => json_ext.get_number(l_jsn_diag_detail,
                                                                                  'PROF_INFO.ID_PROFESSIONAL'),
                                          i_episode        => json_ext.get_number(l_jsn_diag_detail,
                                                                                  'CONTEXT_RECORD.ID_EPISODE'));
                
                ELSE
                    -- Status of the last evaluation
                    pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                          i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                     i_prof      => i_prof,
                                                                                     i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                        'LAST_EVALUATION.BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                     i_timezone  => NULL),
                                          
                                          i_record_state   => json_ext.get_string(l_jsn_diag_detail,
                                                                                  'LAST_EVALUATION.STATUS.FLG_STATUS'),
                                          i_desc_rec_state => json_ext.get_string(l_jsn_diag_detail,
                                                                                  'LAST_EVALUATION.STATUS.DESC_FLG_STATUS'),
                                          i_professional   => json_ext.get_number(l_jsn_diag_detail,
                                                                                  'LAST_EVALUATION.PROF_INFO.ID_PROFESSIONAL'),
                                          i_episode        => json_ext.get_number(l_jsn_diag_detail,
                                                                                  'LAST_EVALUATION.CONTEXT_RECORD.ID_EPISODE'));
                
                END IF;
            
                -- Title: NandaDiagnosisName (LastEvaluation.descFlgStatus)
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => pk_nan_model.format_nanda_name(i_label       => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                      'NANDA_DIAGNOSIS.NAME'),
                                                                                 i_nanda_code  => json_ext.get_number(l_jsn_diag_detail,
                                                                                                                      'NANDA_DIAGNOSIS.NANDA_CODE'),
                                                                                 i_code_format => pk_nan_model.g_code_format_end),
                                       i_value => '(' ||
                                                  CASE l_req_status
                                                      WHEN pk_nnn_constant.g_req_status_cancelled THEN
                                                       json_ext.get_string(l_jsn_diag_detail, 'STATUS.DESC_FLG_STATUS')
                                                      WHEN pk_nnn_constant.g_req_status_discontinued THEN
                                                       json_ext.get_string(l_jsn_diag_detail, 'STATUS.DESC_FLG_STATUS')
                                                      ELSE
                                                       json_ext.get_string(l_jsn_diag_detail,
                                                                           'LAST_EVALUATION.STATUS.DESC_FLG_STATUS')
                                                  END || ')',
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: General information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- NandaDiagnosis.name        
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                       i_value    => json_ext.get_string(l_jsn_diag_detail, 'NANDA_DIAGNOSIS.NAME'),
                                       i_type     => pk_edis_hist.g_type_content);
                -- NandaDiagnosis.definition
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M021'), --'NANDA Definition'
                                       i_value    => json_ext.get_string(l_jsn_diag_detail, 'NANDA_DIAGNOSIS.DEFINITION'),
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NandaDiagnosis.domainName (NandaDiagnosis.domainCode)
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M022'), --'NANDA Domain'
                                       i_value    => json_ext.get_string(l_jsn_diag_detail,
                                                                         'NANDA_DIAGNOSIS.CLASS.DOMAIN.NAME') || ' (' ||
                                                     json_ext.get_string(l_jsn_diag_detail,
                                                                         'NANDA_DIAGNOSIS.CLASS.DOMAIN.DOMAIN_CODE') || ')',
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NandaDiagnosis.className (NandaDiagnosis.classCode)
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M023'), --'NANDA Class'
                                       i_value    => json_ext.get_string(l_jsn_diag_detail, 'NANDA_DIAGNOSIS.CLASS.NAME') || ' (' ||
                                                     json_ext.get_string(l_jsn_diag_detail,
                                                                         'NANDA_DIAGNOSIS.CLASS.CLASS_CODE') || ')',
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- DtDiagnosis
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M003'), --'Diagnosis date',
                                                   i_value    => pk_date_utils.date_char_tsz(i_lang,
                                                                                             pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                           i_prof      => i_prof,
                                                                                                                           i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                                                              'DT_DIAGNOSIS'),
                                                                                                                           i_timezone  => NULL),
                                                                                             i_prof.institution,
                                                                                             i_prof.software),
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- DiagnosisNotes
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M004'), --'Diagnosis notes'
                                                   i_value    => json_ext.get_string(l_jsn_diag_detail, 'NOTES'),
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- When diagnosis is canceled, its status and information about the cancel reason is displayed
                IF l_req_status IN (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                THEN
                    -- Status of the entry (not diagnosis status)
                    l_value_string := json_ext.get_string(l_jsn_diag_detail, 'STATUS.DESC_FLG_STATUS');
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value    => l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := json_ext.get_string(l_jsn_diag_detail, 'CANCEL_INFO.CANCEL_REASON_DESC');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    l_value_string := json_ext.get_string(l_jsn_diag_detail, 'CANCEL_INFO.CANCEL_NOTES');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                END IF;
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => json_ext.get_number(l_jsn_diag_detail,
                                                                                                             'CONTEXT_RECORD.ID_EPISODE'),
                                                             i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                       i_prof      => i_prof,
                                                                                                                       i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                                                          'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                       i_timezone  => NULL),
                                                             i_id_prof_last_change    => json_ext.get_number(l_jsn_diag_detail,
                                                                                                             'PROF_INFO.ID_PROFESSIONAL'),
                                                             i_has_historical_changes => json_ext.get_string(l_jsn_diag_detail,
                                                                                                             'HAS_HISTORICAL_CHANGES'));
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
                IF l_req_status NOT IN
                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                THEN
                    -- Subtitle: Last evaluation
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M020'), --'Last evaluation '
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- LastEvaluation.descFlgStatus
                    l_value_string := json_ext.get_string(l_jsn_diag_detail, 'LAST_EVALUATION.STATUS.DESC_FLG_STATUS');
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value    => l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- LastEvaluation.dtEvaluation
                    l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                  pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                i_prof      => i_prof,
                                                                                                i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                                   'LAST_EVALUATION.DT_EVALUATION'),
                                                                                                i_timezone  => NULL),
                                                                  i_prof.institution,
                                                                  i_prof.software);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M007'), --'Evaluation date',
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- LastEvaluation.lstDefiningCharacteristic
                    l_lst_jsn := json_ext.get_json_list(obj  => l_jsn_diag_detail,
                                                        path => 'LAST_EVALUATION.LST_DEFINING_CHARACTERISTIC');
                    IF l_lst_jsn IS NOT NULL
                    THEN
                        l_lst_varchar := table_varchar();
                        FOR i IN 1 .. l_lst_jsn.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => json_ext.get_string(obj  => json(l_lst_jsn.get(i)),
                                                                                                            path => 'DESCRIPTION'));
                        END LOOP;
                    END IF;
                
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_string_utils.get_tab(2) ||
                                                             pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M008'), --'Defining characteristics'
                                               i_value    => chr(10) || l_value_string,
                                               i_type     => pk_edis_hist.g_type_content);
                    END IF;
                
                    -- LastEvaluation.lstRelatedFactor
                    l_lst_jsn := json_ext.get_json_list(obj  => l_jsn_diag_detail,
                                                        path => 'LAST_EVALUATION.LST_RELATED_FACTOR');
                    IF l_lst_jsn IS NOT NULL
                    THEN
                        l_lst_varchar := table_varchar();
                        FOR i IN 1 .. l_lst_jsn.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => json_ext.get_string(obj  => json(l_lst_jsn.get(i)),
                                                                                                            path => 'DESCRIPTION'));
                        END LOOP;
                    END IF;
                
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_string_utils.get_tab(2) ||
                                                             pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M009'), --'Related factors'
                                               i_value    => chr(10) || l_value_string,
                                               i_type     => pk_edis_hist.g_type_content);
                    END IF;
                
                    -- LastEvaluation.lstRiskFactor
                    l_lst_jsn := json_ext.get_json_list(obj  => l_jsn_diag_detail,
                                                        path => 'LAST_EVALUATION.LST_RISK_FACTOR');
                    IF l_lst_jsn IS NOT NULL
                    THEN
                        l_lst_varchar := table_varchar();
                        FOR i IN 1 .. l_lst_jsn.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => json_ext.get_string(obj  => json(l_lst_jsn.get(i)),
                                                                                                            path => 'DESCRIPTION'));
                        END LOOP;
                    END IF;
                
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_string_utils.get_tab(2) ||
                                                             pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M010'), --'Risk factors'
                                               i_value    => chr(10) || l_value_string,
                                               i_type     => pk_edis_hist.g_type_content);
                    END IF;
                
                    -- LastEvaluation.notes                
                    l_value_string := json_ext.get_string(l_jsn_diag_detail, 'LAST_EVALUATION.NOTES');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M011'), --'Notes'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    --Signature for last evaluation
                    l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                                 i_prof                   => i_prof,
                                                                 i_id_episode             => json_ext.get_number(l_jsn_diag_detail,
                                                                                                                 'LAST_EVALUATION.CONTEXT_RECORD.ID_EPISODE'),
                                                                 i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                           i_prof      => i_prof,
                                                                                                                           i_timestamp => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                                                              'LAST_EVALUATION.BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                           i_timezone  => NULL),
                                                                 i_id_prof_last_change    => json_ext.get_number(l_jsn_diag_detail,
                                                                                                                 'LAST_EVALUATION.PROF_INFO.ID_PROFESSIONAL'),
                                                                 i_has_historical_changes => json_ext.get_string(l_jsn_diag_detail,
                                                                                                                 'LAST_EVALUATION.HAS_HISTORICAL_CHANGES'));
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                    -- Nursing outcomes and indicators
                
                    -- Collection of NOC Outcomes linked to the NANDA Diagnosis
                    l_lst_jsn_outcomes := json_ext.get_json_list(l_jsn_diag_detail, 'OUTCOMES');
                    IF l_lst_jsn_outcomes IS NOT NULL
                    THEN
                        IF l_lst_jsn_outcomes.count > 0
                        THEN
                            --Subtitle: Nursing outcomes and indicators
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M012'), --'Nursing outcomes and indicators'
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_subtitle);
                            FOR i IN 1 .. l_lst_jsn_outcomes.count()
                            LOOP
                                l_jsn_outcome := json(l_lst_jsn_outcomes.get(i));
                            
                                -- NocOutcome.name (NocOutcome.NocCode)
                                l_value_string := pk_noc_model.format_noc_name(i_label       => json_ext.get_string(l_jsn_outcome,
                                                                                                                    'NOC_OUTCOME.NAME'),
                                                                               i_noc_code    => json_ext.get_number(l_jsn_outcome,
                                                                                                                    'NOC_OUTCOME.NOC_CODE'),
                                                                               i_code_format => pk_noc_model.g_code_format_end);
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M013'), --'Outcome'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- NocOutcome.descFlgStatus
                                l_value_string := json_ext.get_string(l_jsn_outcome, 'STATUS.DESC_FLG_STATUS');
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M006'), --'Status'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- NocOutcome.lastEvaluation.targetValue.scaleLevelValue - NocOutcome.lastEvaluation.targetValue.descScaleLevelValue
                                l_value_string := json_ext.get_number(l_jsn_outcome,
                                                                      'LAST_EVALUATION.TARGET_VALUE.SCALE_LEVEL_VALUE') ||
                                                  ' - ' ||
                                                  json_ext.get_string(l_jsn_outcome,
                                                                      'LAST_EVALUATION.TARGET_VALUE.DESC_SCALE_LEVEL_VALUE');
                                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                                   i_label    => pk_string_utils.get_tab(4) ||
                                                                                 pk_message.get_message(i_lang,
                                                                                                        i_prof,
                                                                                                        'NNN_DETAIL_M014'), --'Expected outcome'
                                                                   i_value    => l_value_string,
                                                                   i_type     => pk_edis_hist.g_type_content);
                            
                                -- NocOutcome.lastEvaluation.outcomeValue.scaleLevelValue - NocOutcome.lastEvaluation.outcomeValue.descScaleLevelValue
                                l_value_string := json_ext.get_number(l_jsn_outcome,
                                                                      'LAST_EVALUATION.OUTCOME_VALUE.SCALE_LEVEL_VALUE') ||
                                                  ' - ' ||
                                                  json_ext.get_string(l_jsn_outcome,
                                                                      'LAST_EVALUATION.OUTCOME_VALUE.DESC_SCALE_LEVEL_VALUE');
                                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                                   i_label    => pk_string_utils.get_tab(4) ||
                                                                                 pk_message.get_message(i_lang,
                                                                                                        i_prof,
                                                                                                        'NNN_DETAIL_M015'), --'Current evaluation'
                                                                   i_value    => l_value_string,
                                                                   i_type     => pk_edis_hist.g_type_content);
                            
                                -- Collection of NOC Indicators linked to the NOC Outcome
                                l_lst_jsn_indicators := json_ext.get_json_list(l_jsn_outcome, 'INDICATORS');
                                IF l_lst_jsn_indicators IS NOT NULL
                                THEN
                                    FOR x IN 1 .. l_lst_jsn_indicators.count()
                                    LOOP
                                        l_jsn_indicator := json(l_lst_jsn_indicators.get(x));
                                    
                                        -- NocIndicator.description
                                        l_value_string := json_ext.get_string(l_jsn_indicator,
                                                                              'NOC_INDICATOR.DESCRIPTION');
                                        pk_edis_hist.add_value(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(4) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M016'), --'Indicator'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                                    
                                        -- NocIndicator.descFlgStatus
                                        l_value_string := json_ext.get_string(l_jsn_indicator, 'STATUS.DESC_FLG_STATUS');
                                        pk_edis_hist.add_value(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(6) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M006'), --'Status'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                                    
                                        -- NocIndicator.lastEvaluation.targetValue.scaleLevelValue - NocIndicator.lastEvaluation.targetValue.descScaleLevelValue                                    
                                        l_value_string := json_ext.get_number(l_jsn_indicator,
                                                                              'LAST_EVALUATION.TARGET_VALUE.SCALE_LEVEL_VALUE') ||
                                                          ' - ' ||
                                                          json_ext.get_string(l_jsn_indicator,
                                                                              'LAST_EVALUATION.TARGET_VALUE.DESC_SCALE_LEVEL_VALUE');
                                        pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                                           i_label    => pk_string_utils.get_tab(6) ||
                                                                                         pk_message.get_message(i_lang,
                                                                                                                i_prof,
                                                                                                                'NNN_DETAIL_M014'), --'Expected outcome'
                                                                           i_value    => l_value_string,
                                                                           i_type     => pk_edis_hist.g_type_content);
                                    
                                        -- NocIndicator.lastEvaluation.indicatorValue.scaleLevelValue - NocIndicator.lastEvaluation.indicatorValue.descScaleLevelValue                                                                        
                                        l_value_string := json_ext.get_number(l_jsn_indicator,
                                                                              'LAST_EVALUATION.INDICATOR_VALUE.SCALE_LEVEL_VALUE') ||
                                                          ' - ' ||
                                                          json_ext.get_string(l_jsn_indicator,
                                                                              'LAST_EVALUATION.INDICATOR_VALUE.DESC_SCALE_LEVEL_VALUE');
                                        pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                                           i_label    => pk_string_utils.get_tab(6) ||
                                                                                         pk_message.get_message(i_lang,
                                                                                                                i_prof,
                                                                                                                'NNN_DETAIL_M015'), --'Last evaluation'
                                                                           i_value    => l_value_string,
                                                                           i_type     => pk_edis_hist.g_type_content);
                                    
                                    END LOOP;
                                
                                END IF;
                            
                            END LOOP;
                        
                        END IF;
                    END IF;
                
                    -- Empty line
                    pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
                
                    -- Nursing interventions and activities
                
                    -- Collection of NIC Interventions linked to the NANDA Diagnosis
                    l_lst_jsn_interventions := json_ext.get_json_list(l_jsn_diag_detail, 'INTERVENTIONS');
                    IF l_lst_jsn_interventions IS NOT NULL
                    THEN
                        IF l_lst_jsn_interventions.count > 0
                        THEN
                            -- Subtitle: Nursing interventions and activities
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M017'), --'Nursing interventions and activities'
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_subtitle);
                            FOR i IN 1 .. l_lst_jsn_interventions.count()
                            LOOP
                                l_jsn_intervention := json(l_lst_jsn_interventions.get(i));
                            
                                -- NicIntervention.name (NicIntervention.NicCode)
                                l_value_string := pk_nic_model.format_nic_name(i_label       => json_ext.get_string(l_jsn_intervention,
                                                                                                                    'NIC_INTERVENTION.NAME'),
                                                                               i_nic_code    => json_ext.get_number(l_jsn_intervention,
                                                                                                                    'NIC_INTERVENTION.NIC_CODE'),
                                                                               i_code_format => pk_nic_model.g_code_format_end);
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M018'), --'Intervention'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- NicIntervention.descFlgStatus
                                l_value_string := json_ext.get_string(l_jsn_intervention, 'STATUS.DESC_FLG_STATUS');
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M006'), --'Status'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- Collection of NIC Activities linked to the NIC Intervention
                                l_lst_jsn_activities := json_ext.get_json_list(l_jsn_intervention, 'ACTIVITIES');
                                IF l_lst_jsn_activities IS NOT NULL
                                THEN
                                    FOR x IN 1 .. l_lst_jsn_activities.count()
                                    LOOP
                                        l_jsn_actitivy := json(l_lst_jsn_activities.get(x));
                                    
                                        -- NicActivity.description
                                        l_value_string := json_ext.get_string(l_jsn_actitivy,
                                                                              'NIC_ACTIVITY.DESCRIPTION');
                                        pk_edis_hist.add_value(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(4) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M019'), --'Activity'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                                    
                                        -- NicActivity.descFlgStatus
                                        l_value_string := json_ext.get_string(l_jsn_actitivy, 'STATUS.DESC_FLG_STATUS');
                                        pk_edis_hist.add_value(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(6) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M006'), --'Status'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                                    
                                    END LOOP;
                                
                                END IF;
                            
                            END LOOP;
                        
                        END IF;
                    END IF;
                
                END IF;
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                -- History of changes: Displays only editions on Careplan's NANDA Diagnosis (nnn_epis_diagnosis)
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
                --Get history of changes in nnn_epis_diagnosis
                get_epis_nan_diagnosis_h(i_lang               => i_lang,
                                         i_prof               => i_prof,
                                         i_nnn_epis_diagnosis => i_nnn_epis_diagnosis,
                                         o_hist               => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_coll_nnn_epis_diagnosis_h, l_coll_obj_nnn_epis_diagnosis;
                CLOSE l_cursor;
            
                FOR i IN 1 .. l_coll_nnn_epis_diagnosis_h.count()
                LOOP
                    l_nnn_epis_diagnosis_h   := l_coll_nnn_epis_diagnosis_h(i);
                    l_obj_nnn_epis_diagnosis := l_coll_obj_nnn_epis_diagnosis(i);
                    l_obj_nan_diagnosis      := pk_nan_model.get_nan_diagnosis(i_lang          => i_lang,
                                                                               i_nan_diagnosis => l_obj_nnn_epis_diagnosis.id_nan_diagnosis);
                    IF l_coll_obj_nnn_epis_diagnosis.exists(i + 1)
                    THEN
                        l_prev_obj_nnn_epis_diagnosis := l_coll_obj_nnn_epis_diagnosis(i + 1);
                        l_prev_obj_nan_diagnosis      := pk_nan_model.get_nan_diagnosis(i_lang          => i_lang,
                                                                                        i_nan_diagnosis => l_prev_obj_nnn_epis_diagnosis.id_nan_diagnosis);
                        l_flg_call                    := pk_edis_hist.g_call_hist;
                    ELSE
                        l_prev_obj_nnn_epis_diagnosis := NULL;
                        l_prev_obj_nan_diagnosis      := NULL;
                        l_flg_call                    := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history => nvl(l_nnn_epis_diagnosis_h, -1),
                                          i_dt_hist => l_obj_nnn_epis_diagnosis.bitemporal_data.transaction_time.dt_trs_time_start,
                                          
                                          i_record_state   => l_obj_nnn_epis_diagnosis.status.flg_status,
                                          i_desc_rec_state => l_obj_nnn_epis_diagnosis.status.desc_flg_status,
                                          i_professional   => l_obj_nnn_epis_diagnosis.prof_info.id_professional,
                                          i_episode        => l_obj_nnn_epis_diagnosis.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_nnn_epis_diagnosis.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_nnn_epis_diagnosis IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    
                    END IF;
                
                    -- Subtitle: General information
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NandaDiagnosis.name      
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value     => l_obj_nan_diagnosis.name,
                                           i_old_value => CASE
                                                              WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                               l_prev_obj_nan_diagnosis.name
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- NandaDiagnosis.definition
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M021'), --'NANDA Definition'
                                           i_value     => l_obj_nan_diagnosis.definition,
                                           i_old_value => CASE
                                                              WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                               l_prev_obj_nan_diagnosis.definition
                                                              ELSE
                                                               NULL
                                                          END,
                                           
                                           i_type => pk_edis_hist.g_type_content);
                
                    -- NandaDiagnosis.domainName (NandaDiagnosis.domainCode)
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M022'), --'NANDA Domain'
                                           i_value     => l_obj_nan_diagnosis.class.domain.name || ' (' ||
                                                          l_obj_nan_diagnosis.class.domain.domain_code || ')',
                                           i_old_value => CASE
                                                              WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                               l_prev_obj_nan_diagnosis.class.domain.name || ' (' ||
                                                               l_prev_obj_nan_diagnosis.class.domain.domain_code || ')'
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- NandaDiagnosis.className (NandaDiagnosis.classCode)
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M023'), --'NANDA Class'
                                           i_value     => l_obj_nan_diagnosis.class.name || ' (' || l_obj_nan_diagnosis.class.class_code || ')',
                                           i_old_value => CASE
                                                              WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                               l_prev_obj_nan_diagnosis.class.name || ' (' ||
                                                               l_prev_obj_nan_diagnosis.class.class_code || ')'
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- DtDiagnosis
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M003'), --'Diagnosis date',
                                                       i_value     => pk_date_utils.date_char_tsz(i_lang,
                                                                                                  l_obj_nnn_epis_diagnosis.dt_diagnosis,
                                                                                                  i_prof.institution,
                                                                                                  i_prof.software),
                                                       i_old_value => CASE
                                                                          WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                                           pk_date_utils.date_char_tsz(i_lang,
                                                                                                       l_prev_obj_nnn_epis_diagnosis.dt_diagnosis,
                                                                                                       i_prof.institution,
                                                                                                       i_prof.software)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- DiagnosisNotes
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M004'), --'Diagnosis notes'
                                                       i_value     => l_obj_nnn_epis_diagnosis.notes,
                                                       i_old_value => CASE
                                                                          WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                                           l_prev_obj_nnn_epis_diagnosis.notes
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Status of the entry (not diagnosis status):
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_obj_nnn_epis_diagnosis.status.desc_flg_status,
                                           i_old_value => CASE
                                                              WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                               l_prev_obj_nnn_epis_diagnosis.status.desc_flg_status
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_obj_nnn_epis_diagnosis.cancel_info.cancel_reason_desc,
                                                       i_old_value => CASE
                                                                          WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                                           l_prev_obj_nnn_epis_diagnosis.cancel_info.cancel_reason_desc
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_obj_nnn_epis_diagnosis.cancel_info.cancel_notes,
                                                       i_old_value => CASE
                                                                          WHEN l_prev_obj_nnn_epis_diagnosis IS NOT NULL THEN
                                                                           l_prev_obj_nnn_epis_diagnosis.cancel_info.cancel_notes
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Signature 
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_nnn_epis_diagnosis.context_record.id_episode,
                                                                 i_date                => l_obj_nnn_epis_diagnosis.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_nnn_epis_diagnosis.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
        
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;*/
    
    END get_epis_nan_diagnosis_det;

    FUNCTION get_epis_nan_diagnosis_eval
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diag_eval IN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE
    ) RETURN t_obj_nnn_epis_diag_eval IS
        l_obj t_obj_nnn_epis_diag_eval;
    BEGIN
        -- Get information of NANDA diagnosis evaluation  
        SELECT t_obj_nnn_epis_diag_eval(i_id_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                        i_id_nnn_epis_diagnosis => nede.id_nnn_epis_diagnosis,
                                        i_context_record        => t_obj_context_record(i_id_episode => nede.id_episode),
                                        i_prof_info             => t_obj_prof_info(i_id_professional => nede.id_professional,
                                                                                   i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => nede.id_professional),
                                                                                   i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => nede.id_professional,
                                                                                                                                         i_dt_reg  => nede.dt_trs_time_start,
                                                                                                                                         i_episode => nede.id_episode)),
                                        
                                        i_lst_related_factor          => pk_nnn_core.get_epis_nan_diag_relf_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                              i_dt_trs_time_start  => nede.dt_trs_time_start),
                                        i_lst_risk_factor             => pk_nnn_core.get_epis_nan_diag_rskf_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                              i_dt_trs_time_start  => nede.dt_trs_time_start),
                                        i_lst_defining_characteristic => pk_nnn_core.get_epis_nan_diag_defc_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                              i_dt_trs_time_start  => nede.dt_trs_time_start),
                                        i_cancel_info                 => t_obj_cancel_info(i_lang             => i_lang,
                                                                                           i_prof             => i_prof,
                                                                                           i_id_cancel_reason => nede.id_cancel_reason,
                                                                                           i_cancel_notes     => nede.cancel_notes),
                                        i_status                      => t_obj_status(i_flg_status      => nede.flg_status,
                                                                                      i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_evl_flg_status,
                                                                                                                                   nede.flg_status,
                                                                                                                                   i_lang)),
                                        i_dt_evaluation               => nede.dt_evaluation,
                                        i_notes                       => pk_translation.get_translation_trs(nede.code_notes),
                                        i_bitemporal_data             => t_obj_bitemporal_data(i_trs_time_start => nede.dt_trs_time_start,
                                                                                               i_trs_time_end   => nede.dt_trs_time_end),
                                        i_has_historical_changes      => nvl((SELECT pk_alert_constant.g_yes
                                                                               FROM dual
                                                                              WHERE EXISTS
                                                                              (SELECT 1
                                                                                       FROM nnn_epis_diag_eval_h hst
                                                                                      WHERE hst.id_nnn_epis_diag_eval =
                                                                                            nede.id_nnn_epis_diag_eval)),
                                                                             pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_diag_eval nede
         WHERE nede.id_nnn_epis_diag_eval = i_nnn_epis_diag_eval;
    
        RETURN l_obj;
    END get_epis_nan_diagnosis_eval;

    PROCEDURE get_epis_nan_diagnosis_eval_h
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diag_eval IN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE,
        o_hist               OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_diag_eval_h, t.obj_nnn_epis_diagnosis_eval
              FROM (SELECT NULL id_nnn_epis_diag_eval_h,
                           t_obj_nnn_epis_diag_eval(i_id_nnn_epis_diag_eval       => nede.id_nnn_epis_diag_eval,
                                                    i_id_nnn_epis_diagnosis       => nede.id_nnn_epis_diagnosis,
                                                    i_context_record              => t_obj_context_record(i_id_episode => nede.id_episode),
                                                    i_prof_info                   => t_obj_prof_info(i_id_professional => nede.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nede.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nede.id_professional,
                                                                                                                                                           i_dt_reg  => nede.dt_trs_time_start,
                                                                                                                                                           i_episode => nede.id_episode)),
                                                    i_lst_related_factor          => pk_nnn_core.get_epis_nan_diag_relf_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nede.dt_trs_time_start),
                                                    i_lst_risk_factor             => pk_nnn_core.get_epis_nan_diag_rskf_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nede.dt_trs_time_start),
                                                    i_lst_defining_characteristic => pk_nnn_core.get_epis_nan_diag_defc_h(i_nnn_epis_diag_eval => nede.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nede.dt_trs_time_start),
                                                    i_cancel_info                 => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                       i_prof             => i_prof,
                                                                                                       i_id_cancel_reason => nede.id_cancel_reason,
                                                                                                       i_cancel_notes     => nede.cancel_notes),
                                                    i_status                      => t_obj_status(i_flg_status      => nede.flg_status,
                                                                                                  i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_evl_flg_status,
                                                                                                                                               nede.flg_status,
                                                                                                                                               i_lang)),
                                                    i_dt_evaluation               => nede.dt_evaluation,
                                                    i_notes                       => pk_translation.get_translation_trs(nede.code_notes),
                                                    i_bitemporal_data             => t_obj_bitemporal_data(i_trs_time_start => nede.dt_trs_time_start,
                                                                                                           i_trs_time_end   => nede.dt_trs_time_end),
                                                    i_has_historical_changes      => nvl((SELECT pk_alert_constant.g_yes
                                                                                           FROM dual
                                                                                          WHERE EXISTS
                                                                                          (SELECT 1
                                                                                                   FROM nnn_epis_diag_eval_h hst
                                                                                                  WHERE hst.id_nnn_epis_diag_eval =
                                                                                                        nede.id_nnn_epis_diag_eval)),
                                                                                         pk_alert_constant.g_no)) obj_nnn_epis_diagnosis_eval,
                           nede.dt_trs_time_start,
                           nede.dt_trs_time_end
                      FROM nnn_epis_diag_eval nede
                     WHERE nede.id_nnn_epis_diag_eval = i_nnn_epis_diag_eval
                    UNION ALL
                    SELECT nedeh.id_nnn_epis_diag_eval_h,
                           t_obj_nnn_epis_diag_eval(i_id_nnn_epis_diag_eval       => nedeh.id_nnn_epis_diag_eval,
                                                    i_id_nnn_epis_diagnosis       => nedeh.id_nnn_epis_diagnosis,
                                                    i_context_record              => t_obj_context_record(i_id_episode => nedeh.id_episode),
                                                    i_prof_info                   => t_obj_prof_info(i_id_professional => nedeh.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nedeh.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nedeh.id_professional,
                                                                                                                                                           i_dt_reg  => nedeh.dt_trs_time_start,
                                                                                                                                                           i_episode => nedeh.id_episode)),
                                                    i_lst_related_factor          => pk_nnn_core.get_epis_nan_diag_relf_h(i_nnn_epis_diag_eval => nedeh.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nedeh.dt_trs_time_start),
                                                    i_lst_risk_factor             => pk_nnn_core.get_epis_nan_diag_rskf_h(i_nnn_epis_diag_eval => nedeh.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nedeh.dt_trs_time_start),
                                                    i_lst_defining_characteristic => pk_nnn_core.get_epis_nan_diag_defc_h(i_nnn_epis_diag_eval => nedeh.id_nnn_epis_diag_eval,
                                                                                                                          i_dt_trs_time_start  => nedeh.dt_trs_time_start),
                                                    
                                                    i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                  i_prof             => i_prof,
                                                                                                  i_id_cancel_reason => nedeh.id_cancel_reason,
                                                                                                  i_cancel_notes     => nedeh.cancel_notes),
                                                    i_status                 => t_obj_status(i_flg_status      => nedeh.flg_status,
                                                                                             i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_diag_evl_flg_status,
                                                                                                                                          nedeh.flg_status,
                                                                                                                                          i_lang)),
                                                    i_dt_evaluation          => nedeh.dt_evaluation,
                                                    i_notes                  => nedeh.notes,
                                                    i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => nedeh.dt_trs_time_start,
                                                                                                      i_trs_time_end   => nedeh.dt_trs_time_end),
                                                    i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                      FROM dual
                                                                                     WHERE EXISTS
                                                                                     (SELECT 1
                                                                                              FROM nnn_epis_diag_eval_h hst
                                                                                             WHERE hst.id_nnn_epis_diag_eval =
                                                                                                   nedeh.id_nnn_epis_diag_eval)),
                                                                                    pk_alert_constant.g_no)) obj_nnn_epis_diagnosis_eval,
                           
                           nedeh.dt_trs_time_start,
                           nedeh.dt_trs_time_end
                      FROM nnn_epis_diag_eval_h nedeh
                     WHERE nedeh.id_nnn_epis_diag_eval = i_nnn_epis_diag_eval) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_nan_diagnosis_eval_h;

    PROCEDURE get_epis_nan_diagnosis_evl_det
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diag_eval IN nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE,
        i_flg_detail_type    IN VARCHAR2,
        o_detail             OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_nan_diagnosis_evl_det';
        TYPE lt_lst_obj_nnn_epis_diag_eval IS TABLE OF t_obj_nnn_epis_diag_eval;
        l_label_edition  sys_message.desc_message%TYPE;
        l_label_creation sys_message.desc_message%TYPE;
        l_label_cancel   sys_message.desc_message%TYPE;
        l_flg_call       VARCHAR2(1 CHAR);
        l_cursor         pk_types.cursor_type;
    
        l_obj_nan_diagnosis       t_obj_nan_diagnosis;
        l_obj_epis_diagnosis      t_obj_nnn_epis_diagnosis;
        l_obj_epis_diag_eval      t_obj_nnn_epis_diag_eval;
        l_prev_obj_epis_diag_eval t_obj_nnn_epis_diag_eval;
        l_lst_obj_epis_diag_eval  lt_lst_obj_nnn_epis_diag_eval;
        l_lst_varchar             table_varchar;
    
        l_lst_nnn_epis_diag_eval_h table_number;
    
        l_nnn_epis_diag_eval_h nnn_epis_diag_eval_h. id_nnn_epis_diag_eval_h%TYPE;
    
        l_value_string     pk_types.t_huge_byte;
        l_old_value_string pk_types.t_huge_byte;
        l_has_previous     BOOLEAN;
    BEGIN
        --Initialization of detail table
        pk_edis_hist.init_vars;
    
        CASE i_flg_detail_type
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details
            
                -- Careplan NANDA diagnosis's evaluation
                g_error := 'Get the careplan''s NANDA Diagnosis evaluation id_nnn_epis_diag_eval = ' ||
                           to_char(i_nnn_epis_diag_eval);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_epis_diag_eval := pk_nnn_api_db.get_epis_nan_diagnosis_eval(i_lang               => i_lang,
                                                                                  i_prof               => i_prof,
                                                                                  i_nnn_epis_diag_eval => i_nnn_epis_diag_eval);
            
                -- Careplan NANDA diagnosis's request
                g_error := 'Get the careplan''s NANDA Diagnosis id_nnn_epis_diagnosis = ' ||
                           to_char(l_obj_epis_diag_eval.id_nnn_epis_diagnosis);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_epis_diagnosis := pk_nnn_api_db.get_epis_nan_diagnosis(i_lang               => i_lang,
                                                                             i_prof               => i_prof,
                                                                             i_nnn_epis_diagnosis => l_obj_epis_diag_eval.id_nnn_epis_diagnosis);
                -- NANDA Diagnosis info
                g_error := 'Get the NANDA Diagnosis id_nan_diagnosis = ' ||
                           to_char(l_obj_epis_diagnosis.id_nan_diagnosis);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_nan_diagnosis := pk_nan_model.get_nan_diagnosis(i_lang          => i_lang,
                                                                      i_nan_diagnosis => l_obj_epis_diagnosis.id_nan_diagnosis);
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history        => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist        => l_obj_epis_diag_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                      i_record_state   => l_obj_epis_diag_eval.status.flg_status,
                                      i_desc_rec_state => l_obj_epis_diag_eval.status.desc_flg_status,
                                      i_professional   => l_obj_epis_diag_eval.prof_info.id_professional,
                                      i_episode        => l_obj_epis_diag_eval.context_record.id_episode);
            
                -- Title: NandaDiagnosisName
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => pk_nan_model.format_nanda_name(i_label           => l_obj_nan_diagnosis.name,
                                                                                 i_nanda_code      => l_obj_nan_diagnosis.nanda_code,
                                                                                 i_code_format     => pk_nan_model.g_code_format_end,
                                                                                 i_additional_info => l_obj_epis_diagnosis.notes),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: Evaluation information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M005'), --'Evaluation information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- Evaluation.descFlgStatus
                l_value_string := l_obj_epis_diag_eval.status.desc_flg_status;
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := l_obj_epis_diag_eval.cancel_info.cancel_reason_desc;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelNotes
                l_value_string := l_obj_epis_diag_eval.cancel_info.cancel_notes;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Evaluation.dtEvaluation
                l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                              l_obj_epis_diag_eval.dt_evaluation,
                                                              i_prof.institution,
                                                              i_prof.software);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M007'), --'Evaluation date',
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Evaluation.lstDefiningCharacteristic
                l_lst_varchar := table_varchar();
                IF l_obj_epis_diag_eval.lst_defining_characteristic IS NOT NULL
                THEN
                    FOR i IN 1 .. l_obj_epis_diag_eval.lst_defining_characteristic.count
                    LOOP
                        l_lst_varchar.extend(1);
                        l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                            pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_defining_characteristic(i).description);
                    END LOOP;
                END IF;
            
                IF l_lst_varchar IS NOT empty
                THEN
                    l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M008'), --'Defining characteristics'
                                           i_value    => chr(10) || l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                END IF;
            
                -- Evaluation.lstRelatedFactor
                l_lst_varchar := table_varchar();
                IF l_obj_epis_diag_eval.lst_related_factor IS NOT NULL
                THEN
                    FOR i IN 1 .. l_obj_epis_diag_eval.lst_related_factor.count
                    LOOP
                        l_lst_varchar.extend(1);
                        l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                            pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_related_factor(i).description);
                    END LOOP;
                END IF;
            
                IF l_lst_varchar IS NOT empty
                THEN
                    l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M009'), --'Related factors'
                                           i_value    => chr(10) || l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                END IF;
            
                -- Evaluation.lstRiskFactor
                l_lst_varchar := table_varchar();
                IF l_obj_epis_diag_eval.lst_risk_factor IS NOT NULL
                THEN
                    FOR i IN 1 .. l_obj_epis_diag_eval.lst_risk_factor.count
                    LOOP
                        l_lst_varchar.extend(1);
                        l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                            pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_risk_factor(i).description);
                    END LOOP;
                END IF;
            
                IF l_lst_varchar IS NOT empty
                THEN
                    l_value_string := pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M010'), --'Risk factors'
                                           i_value    => chr(10) || l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                END IF;
            
                -- Evaluation.notes                
                l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_diag_eval.notes);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M011'), --'Notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --Signature for evaluation
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => l_obj_epis_diag_eval.context_record.id_episode,
                                                             i_date                   => l_obj_epis_diag_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                             i_id_prof_last_change    => l_obj_epis_diag_eval.prof_info.id_professional,
                                                             i_has_historical_changes => l_obj_epis_diag_eval.has_historical_changes);
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                -- History of changes: Displays only editions in the evaluation of a Careplan's NANDA Diagnosis(nnn_epis_diag_eval)
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
            
                --Get history of changes 
                get_epis_nan_diagnosis_eval_h(i_lang               => i_lang,
                                              i_prof               => i_prof,
                                              i_nnn_epis_diag_eval => i_nnn_epis_diag_eval,
                                              o_hist               => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_lst_nnn_epis_diag_eval_h, l_lst_obj_epis_diag_eval;
                CLOSE l_cursor;
            
                l_obj_nan_diagnosis := NULL;
                FOR i IN 1 .. l_lst_nnn_epis_diag_eval_h.count()
                LOOP
                    l_nnn_epis_diag_eval_h := l_lst_nnn_epis_diag_eval_h(i);
                    l_obj_epis_diag_eval   := l_lst_obj_epis_diag_eval(i);
                    IF l_obj_nan_diagnosis IS NULL
                    THEN
                        -- The requested diagnosis doesn't change with the editions of the evaluation, so these objects are retrieved just once.                        
                    
                        -- Careplan NANDA diagnosis's request
                        l_obj_epis_diagnosis := pk_nnn_api_db.get_epis_nan_diagnosis(i_lang               => i_lang,
                                                                                     i_prof               => i_prof,
                                                                                     i_nnn_epis_diagnosis => l_obj_epis_diag_eval.id_nnn_epis_diagnosis);
                        -- NANDA Diagnosis info                                                                         
                        l_obj_nan_diagnosis := pk_nan_model.get_nan_diagnosis(i_lang          => i_lang,
                                                                              i_nan_diagnosis => l_obj_epis_diagnosis.id_nan_diagnosis);
                    END IF;
                
                    IF l_lst_obj_epis_diag_eval.exists(i + 1)
                    THEN
                        l_has_previous            := TRUE;
                        l_prev_obj_epis_diag_eval := l_lst_obj_epis_diag_eval(i + 1);
                        l_flg_call                := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous            := FALSE;
                        l_prev_obj_epis_diag_eval := NULL;
                        l_flg_call                := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history => nvl(l_nnn_epis_diag_eval_h, -1),
                                          i_dt_hist => l_obj_epis_diag_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                          
                                          i_record_state   => l_obj_epis_diag_eval.status.flg_status,
                                          i_desc_rec_state => l_obj_epis_diag_eval.status.desc_flg_status,
                                          i_professional   => l_obj_epis_diag_eval.prof_info.id_professional,
                                          i_episode        => l_obj_epis_diag_eval.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_epis_diag_eval.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_epis_diag_eval IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    END IF;
                
                    -- NandaDiagnosis.Name
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => l_obj_nan_diagnosis.name,
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- Evaluation.descFlgStatus
                    l_value_string := l_obj_epis_diag_eval.status.desc_flg_status;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_diag_eval.status.desc_flg_status;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_value_string,
                                           i_old_value => l_old_value_string,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := l_obj_epis_diag_eval.cancel_info.cancel_reason_desc;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_diag_eval.cancel_info.cancel_reason_desc;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    l_value_string := l_obj_epis_diag_eval.cancel_info.cancel_notes;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_diag_eval.cancel_info.cancel_notes;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Evaluation.dtEvaluation
                    l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                  l_obj_epis_diag_eval.dt_evaluation,
                                                                  i_prof.institution,
                                                                  i_prof.software);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                          l_prev_obj_epis_diag_eval.dt_evaluation,
                                                                          i_prof.institution,
                                                                          i_prof.software);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M007'), --'Evaluation date',
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Evaluation.lstDefiningCharacteristic
                    l_value_string     := NULL;
                    l_old_value_string := NULL;
                    l_lst_varchar      := table_varchar();
                
                    IF l_obj_epis_diag_eval.lst_defining_characteristic IS NOT NULL
                    THEN
                        FOR i IN 1 .. l_obj_epis_diag_eval.lst_defining_characteristic.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_defining_characteristic(i).description);
                        END LOOP;
                    END IF;
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := chr(10) ||
                                          pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    END IF;
                    IF l_has_previous
                    THEN
                        l_lst_varchar := table_varchar();
                        IF l_prev_obj_epis_diag_eval.lst_defining_characteristic IS NOT NULL
                        THEN
                        
                            FOR i IN 1 .. l_prev_obj_epis_diag_eval.lst_defining_characteristic.count
                            LOOP
                                l_lst_varchar.extend(1);
                                l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                    pk_string_utils.add_full_stop(i_line => l_prev_obj_epis_diag_eval.lst_defining_characteristic(i).description);
                            END LOOP;
                        END IF;
                        IF l_lst_varchar IS NOT empty
                        THEN
                            l_old_value_string := chr(10) ||
                                                  pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        END IF;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M008'), --'Defining characteristics'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Evaluation.lstRelatedFactor
                    l_value_string     := NULL;
                    l_old_value_string := NULL;
                    l_lst_varchar      := table_varchar();
                    IF l_obj_epis_diag_eval.lst_related_factor IS NOT NULL
                    THEN
                        FOR i IN 1 .. l_obj_epis_diag_eval.lst_related_factor.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_related_factor(i).description);
                        END LOOP;
                    END IF;
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := chr(10) ||
                                          pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    END IF;
                    IF l_has_previous
                    THEN
                        l_lst_varchar := table_varchar();
                        IF l_prev_obj_epis_diag_eval.lst_related_factor IS NOT NULL
                        THEN
                        
                            FOR i IN 1 .. l_prev_obj_epis_diag_eval.lst_related_factor.count
                            LOOP
                                l_lst_varchar.extend(1);
                                l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                    pk_string_utils.add_full_stop(i_line => l_prev_obj_epis_diag_eval.lst_related_factor(i).description);
                            END LOOP;
                        END IF;
                        IF l_lst_varchar IS NOT empty
                        THEN
                            l_old_value_string := chr(10) ||
                                                  pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        END IF;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M009'), --'Related factors'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Evaluation.lstRiskFactor
                    l_value_string     := NULL;
                    l_old_value_string := NULL;
                    l_lst_varchar      := table_varchar();
                    IF l_obj_epis_diag_eval.lst_risk_factor IS NOT NULL
                    THEN
                        FOR i IN 1 .. l_obj_epis_diag_eval.lst_risk_factor.count
                        LOOP
                            l_lst_varchar.extend(1);
                            l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                pk_string_utils.add_full_stop(i_line => l_obj_epis_diag_eval.lst_risk_factor(i).description);
                        END LOOP;
                    END IF;
                    IF l_lst_varchar IS NOT empty
                    THEN
                        l_value_string := chr(10) ||
                                          pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                    END IF;
                    IF l_has_previous
                    THEN
                        l_lst_varchar := table_varchar();
                        IF l_prev_obj_epis_diag_eval.lst_risk_factor IS NOT NULL
                        THEN
                        
                            FOR i IN 1 .. l_prev_obj_epis_diag_eval.lst_risk_factor.count
                            LOOP
                                l_lst_varchar.extend(1);
                                l_lst_varchar(i) := pk_string_utils.get_tab(4) || k_bullet_char ||
                                                    pk_string_utils.add_full_stop(i_line => l_prev_obj_epis_diag_eval.lst_risk_factor(i).description);
                            END LOOP;
                        END IF;
                        IF l_lst_varchar IS NOT empty
                        THEN
                            l_old_value_string := chr(10) ||
                                                  pk_utils.concat_table_l(i_tab => l_lst_varchar, i_delim => chr(10));
                        END IF;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M010'), --'Risk factors'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Evaluation.notes                
                    l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_diag_eval.notes);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_prev_obj_epis_diag_eval.notes);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M011'), --'Notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Signature for evaluation
                    l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                                 i_prof                   => i_prof,
                                                                 i_id_episode             => l_obj_epis_diag_eval.context_record.id_episode,
                                                                 i_date                   => l_obj_epis_diag_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change    => l_obj_epis_diag_eval.prof_info.id_professional,
                                                                 i_has_historical_changes => l_obj_epis_diag_eval.has_historical_changes);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
    
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    END get_epis_nan_diagnosis_evl_det;
    FUNCTION get_epis_noc_outcome
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_nnn_epis_outcome IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE
    ) RETURN t_obj_nnn_epis_outcome IS
        l_obj t_obj_nnn_epis_outcome;
    BEGIN
        -- Get information of NOC outcome in the care plan 
        SELECT t_obj_nnn_epis_outcome(i_id_nnn_epis_outcome => neo.id_nnn_epis_outcome,
                                      i_id_noc_outcome      => neo.id_noc_outcome,
                                      i_context_record      => t_obj_context_record(i_id_episode => neo.id_episode),
                                      i_prof_info           => t_obj_prof_info(i_id_professional => neo.id_professional,
                                                                               i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                     i_prof    => i_prof,
                                                                                                                                     i_prof_id => neo.id_professional),
                                                                               i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                     i_prof    => i_prof,
                                                                                                                                     i_prof_id => neo.id_professional,
                                                                                                                                     i_dt_reg  => neo.dt_trs_time_start,
                                                                                                                                     i_episode => neo.id_episode)),
                                      
                                      i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                    i_prof             => i_prof,
                                                                                    i_id_cancel_reason => neo.id_cancel_reason,
                                                                                    i_cancel_notes     => neo.cancel_notes),
                                      i_status                 => t_obj_status(i_flg_status      => neo.flg_req_status,
                                                                               i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_flg_req_status,
                                                                                                                            neo.flg_req_status,
                                                                                                                            i_lang)),
                                      i_id_episode_origin      => neo.id_episode_origin,
                                      i_id_episode_destination => neo.id_episode_destination,
                                      i_flg_prn                => neo.flg_prn,
                                      i_notes_prn              => pk_translation.get_translation_trs(neo.code_notes_prn),
                                      i_flg_time               => neo.flg_time,
                                      i_flg_priority           => neo.flg_priority,
                                      i_id_order_recurr_plan   => neo.id_order_recurr_plan,
                                      i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                               i_prof              => i_prof,
                                                                                               i_flg_priority      => neo.flg_priority,
                                                                                               i_flg_prn           => neo.flg_prn,
                                                                                               i_notes_prn         => pk_translation.get_translation_trs(neo.code_notes_prn),
                                                                                               i_flg_time          => neo.flg_time,
                                                                                               i_order_recurr_plan => neo.id_order_recurr_plan),
                                      i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => neo.dt_val_time_start,
                                                                                        i_val_time_end   => neo.dt_val_time_end,
                                                                                        i_trs_time_start => neo.dt_trs_time_start,
                                                                                        i_trs_time_end   => neo.dt_trs_time_end),
                                      i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                        FROM dual
                                                                       WHERE EXISTS
                                                                       (SELECT 1
                                                                                FROM nnn_epis_outcome_h hst
                                                                               WHERE hst.id_nnn_epis_outcome =
                                                                                     neo.id_nnn_epis_outcome)),
                                                                      pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_outcome neo
         WHERE neo.id_nnn_epis_outcome = i_nnn_epis_outcome;
    
        RETURN l_obj;
    
    END get_epis_noc_outcome;

    PROCEDURE get_epis_noc_outcome_h
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_nnn_epis_outcome IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        o_hist             OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_outcome_h, t.obj_nnn_epis_outcome
              FROM (SELECT NULL id_nnn_epis_outcome_h,
                           t_obj_nnn_epis_outcome(i_id_nnn_epis_outcome => neo.id_nnn_epis_outcome,
                                                  i_id_noc_outcome      => neo.id_noc_outcome,
                                                  i_context_record      => t_obj_context_record(i_id_episode => neo.id_episode),
                                                  i_prof_info           => t_obj_prof_info(i_id_professional => neo.id_professional,
                                                                                           i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                 i_prof    => i_prof,
                                                                                                                                                 i_prof_id => neo.id_professional),
                                                                                           i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                 i_prof    => i_prof,
                                                                                                                                                 i_prof_id => neo.id_professional,
                                                                                                                                                 i_dt_reg  => neo.dt_trs_time_start,
                                                                                                                                                 i_episode => neo.id_episode)),
                                                  
                                                  i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                i_prof             => i_prof,
                                                                                                i_id_cancel_reason => neo.id_cancel_reason,
                                                                                                i_cancel_notes     => neo.cancel_notes),
                                                  i_status                 => t_obj_status(i_flg_status      => neo.flg_req_status,
                                                                                           i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_flg_req_status,
                                                                                                                                        neo.flg_req_status,
                                                                                                                                        i_lang)),
                                                  i_id_episode_origin      => neo.id_episode_origin,
                                                  i_id_episode_destination => neo.id_episode_destination,
                                                  i_flg_prn                => neo.flg_prn,
                                                  i_notes_prn              => pk_translation.get_translation_trs(neo.code_notes_prn),
                                                  i_flg_time               => neo.flg_time,
                                                  i_flg_priority           => neo.flg_priority,
                                                  i_id_order_recurr_plan   => neo.id_order_recurr_plan,
                                                  i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                           i_prof              => i_prof,
                                                                                                           i_flg_priority      => neo.flg_priority,
                                                                                                           i_flg_prn           => neo.flg_prn,
                                                                                                           i_notes_prn         => pk_translation.get_translation_trs(neo.code_notes_prn),
                                                                                                           i_flg_time          => neo.flg_time,
                                                                                                           i_order_recurr_plan => neo.id_order_recurr_plan),
                                                  i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => neo.dt_val_time_start,
                                                                                                    i_val_time_end   => neo.dt_val_time_end,
                                                                                                    i_trs_time_start => neo.dt_trs_time_start,
                                                                                                    i_trs_time_end   => neo.dt_trs_time_end),
                                                  i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                    FROM dual
                                                                                   WHERE EXISTS
                                                                                   (SELECT 1
                                                                                            FROM nnn_epis_outcome_h hst
                                                                                           WHERE hst.id_nnn_epis_outcome =
                                                                                                 neo.id_nnn_epis_outcome)),
                                                                                  pk_alert_constant.g_no)) obj_nnn_epis_outcome,
                           neo.dt_trs_time_start,
                           neo.dt_trs_time_end
                      FROM nnn_epis_outcome neo
                     WHERE neo.id_nnn_epis_outcome = i_nnn_epis_outcome
                    UNION ALL
                    SELECT neoh.id_nnn_epis_outcome_h,
                           t_obj_nnn_epis_outcome(i_id_nnn_epis_outcome => neoh.id_nnn_epis_outcome,
                                                  i_id_noc_outcome      => neoh.id_noc_outcome,
                                                  i_context_record      => t_obj_context_record(i_id_episode => neoh.id_episode),
                                                  i_prof_info           => t_obj_prof_info(i_id_professional => neoh.id_professional,
                                                                                           i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                 i_prof    => i_prof,
                                                                                                                                                 i_prof_id => neoh.id_professional),
                                                                                           i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                 i_prof    => i_prof,
                                                                                                                                                 i_prof_id => neoh.id_professional,
                                                                                                                                                 i_dt_reg  => neoh.dt_trs_time_start,
                                                                                                                                                 i_episode => neoh.id_episode)),
                                                  
                                                  i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                i_prof             => i_prof,
                                                                                                i_id_cancel_reason => neoh.id_cancel_reason,
                                                                                                i_cancel_notes     => neoh.cancel_notes),
                                                  i_status                 => t_obj_status(i_flg_status      => neoh.flg_req_status,
                                                                                           i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_flg_req_status,
                                                                                                                                        neoh.flg_req_status,
                                                                                                                                        i_lang)),
                                                  i_id_episode_origin      => neoh.id_episode_origin,
                                                  i_id_episode_destination => neoh.id_episode_destination,
                                                  i_flg_prn                => neoh.flg_prn,
                                                  i_notes_prn              => neoh.notes_prn,
                                                  i_flg_time               => neoh.flg_time,
                                                  i_flg_priority           => neoh.flg_priority,
                                                  i_id_order_recurr_plan   => neoh.id_order_recurr_plan,
                                                  i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                           i_prof              => i_prof,
                                                                                                           i_flg_priority      => neoh.flg_priority,
                                                                                                           i_flg_prn           => neoh.flg_prn,
                                                                                                           i_notes_prn         => neoh.notes_prn,
                                                                                                           i_flg_time          => neoh.flg_time,
                                                                                                           i_order_recurr_plan => neoh.id_order_recurr_plan),
                                                  i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => neoh.dt_val_time_start,
                                                                                                    i_val_time_end   => neoh.dt_val_time_end,
                                                                                                    i_trs_time_start => neoh.dt_trs_time_start,
                                                                                                    i_trs_time_end   => neoh.dt_trs_time_end),
                                                  i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                    FROM dual
                                                                                   WHERE EXISTS
                                                                                   (SELECT 1
                                                                                            FROM nnn_epis_outcome_h hst
                                                                                           WHERE hst.id_nnn_epis_outcome =
                                                                                                 neoh.id_nnn_epis_outcome)),
                                                                                  pk_alert_constant.g_no)) obj_nnn_epis_outcome,
                           neoh.dt_trs_time_start,
                           neoh.dt_trs_time_end
                      FROM nnn_epis_outcome_h neoh
                     WHERE neoh.id_nnn_epis_outcome = i_nnn_epis_outcome) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_noc_outcome_h;

    PROCEDURE get_epis_noc_outcome_det
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_nnn_epis_outcome IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_flg_detail_type  IN VARCHAR2,
        o_detail           OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_noc_outcome_det';
    
        TYPE lt_coll_obj_nnn_epis_outcome IS TABLE OF t_obj_nnn_epis_outcome;
    
        l_label_edition  sys_message.desc_message%TYPE;
        l_label_creation sys_message.desc_message%TYPE;
        l_label_cancel   sys_message.desc_message%TYPE;
    
        l_flg_call VARCHAR2(1 CHAR);
        l_cursor   pk_types.cursor_type;
    
        l_coll_obj_nnn_epis_outcome lt_coll_obj_nnn_epis_outcome;
        l_coll_nnn_epis_outcome_h   table_number;
    
        l_obj_nnn_epis_outcome      t_obj_nnn_epis_outcome;
        l_prev_obj_nnn_epis_outcome t_obj_nnn_epis_outcome;
        l_obj_noc_outcome           t_obj_noc_outcome;
        l_prev_obj_noc_outcome      t_obj_noc_outcome;
    
        l_nnn_epis_outcome_h nnn_epis_outcome_h.id_nnn_epis_outcome_h%TYPE;
    
        l_jsn_outcome_detal json_object_t;
    
        l_jsn_indicator      json_object_t;
        l_lst_jsn_indicators json_array_t;
        l_req_status         nnn_epis_outcome.flg_req_status%TYPE;
        l_order_recurr_plan  nnn_epis_outcome.id_order_recurr_plan%TYPE;
        l_value_string       pk_types.t_huge_byte;
        l_old_value_string   pk_types.t_huge_byte;
        l_has_evaluation     BOOLEAN;
        l_has_previous       BOOLEAN;
    
    BEGIN
        /*g_error := 'Input arguments:';
            g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
            g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
            g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
            g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
            g_error := g_error || ' i_nnn_epis_outcome = ' || coalesce(to_char(i_nnn_epis_outcome), '<null>');
            g_error := g_error || ' i_flg_detail_type = ' || coalesce(i_flg_detail_type, '<null>');
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
            --Initialization of detail table
            pk_edis_hist.init_vars;
        
            CASE i_flg_detail_type
            
                WHEN pk_nnn_constant.g_detail_type_current_info THEN
                    -- Current information details: 
                    --     Displays the current Careplan's NOC Outcome info
                    --     The last diagnosis' evaluation
                    --     An hierachical detail of all current items in the care plan that are linked to this outcome
                
                    -- Gets an hierachical detail of the Careplan for a NOC Outcome in JSON.
                    l_jsn_outcome_detal := pk_nnn_api_db.get_epis_outcome_hier_detail(i_lang             => i_lang,
                                                                                      i_prof             => i_prof,
                                                                                      i_nnn_epis_outcome => i_nnn_epis_outcome);
                
                    -- Request's status
                    l_req_status     := json_ext.get_string(l_jsn_outcome_detal, 'STATUS.FLG_STATUS');
                    l_has_evaluation := json_ext.get_string(l_jsn_outcome_detal, 'LAST_EVALUATION.STATUS.FLG_STATUS') IS
                                        NOT NULL;
                
                    -- Status of the entry
                    pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                          i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                     i_prof      => i_prof,
                                                                                     i_timestamp => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                        'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                     i_timezone  => NULL),
                                          
                                          i_record_state   => json_ext.get_string(l_jsn_outcome_detal, 'STATUS.FLG_STATUS'),
                                          i_desc_rec_state => json_ext.get_string(l_jsn_outcome_detal,
                                                                                  'STATUS.DESC_FLG_STATUS'),
                                          i_professional   => json_ext.get_number(l_jsn_outcome_detal,
                                                                                  'PROF_INFO.ID_PROFESSIONAL'),
                                          i_episode        => json_ext.get_number(l_jsn_outcome_detal,
                                                                                  'CONTEXT_RECORD.ID_EPISODE'));
                
                    -- Title: NocOutcomeName
                    pk_edis_hist.add_value(i_lang  => i_lang,
                                           i_label => pk_noc_model.format_noc_name(i_label       => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                        'NOC_OUTCOME.NAME'),
                                                                                   i_noc_code    => json_ext.get_number(l_jsn_outcome_detal,
                                                                                                                        'NOC_OUTCOME.NOC_CODE'),
                                                                                   i_code_format => pk_nan_model.g_code_format_end),
                                           i_value => NULL,
                                           i_type  => pk_edis_hist.g_type_title);
                
                    -- Empty line
                    pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
                
                    -- Subtitle: General information
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NocOutcome.name        
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value    => json_ext.get_string(l_jsn_outcome_detal, 'NOC_OUTCOME.NAME'),
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- NocOutcome.definition
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M024'), --'NOC Definition'
                                           i_value    => json_ext.get_string(l_jsn_outcome_detal, 'NOC_OUTCOME.DEFINITION'),
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- NocOutcome.domainName (NocOutcome.domainCode)
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M025'), --'NOC Domain'
                                           i_value    => json_ext.get_string(l_jsn_outcome_detal,
                                                                             'NOC_OUTCOME.CLASS.DOMAIN.NAME') || ' (' ||
                                                         json_ext.get_string(l_jsn_outcome_detal,
                                                                             'NOC_OUTCOME.CLASS.DOMAIN.DOMAIN_CODE') || ')',
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- NocOutcome.className (NocOutcome.classCode)
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M026'), --'NOC Class'
                                           i_value    => json_ext.get_string(l_jsn_outcome_detal, 'NOC_OUTCOME.CLASS.NAME') || ' (' ||
                                                         json_ext.get_string(l_jsn_outcome_detal,
                                                                             'NOC_OUTCOME.CLASS.CLASS_CODE') || ')',
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- Subtitle: Instructions
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T001'), --'Instructions'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- descInstructions  (we split the instructions to one property by row instead of use the string DESC_INSTRUCTIONS)
                    l_order_recurr_plan := json_ext.get_number(l_jsn_outcome_detal, 'ID_ORDER_RECURR_PLAN');
                
                    -- flgPriority
                    l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_priority,
                                                              i_val      => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                'FLG_PRIORITY'),
                                                              i_lang     => i_lang);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T002'),
                                                                             ':'), --'Priority'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- flgTime
                    l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_time,
                                                              i_val      => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                'FLG_TIME'),
                                                              i_lang     => i_lang);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T003'),
                                                                             ':'), --'To be performed'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- flgPRN
                    l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_prn,
                                                              i_val      => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                'FLG_PRN'),
                                                              i_lang     => i_lang);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T004'),
                                                                             ':'), --'PRN'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- notesPRN
                    l_value_string := json_ext.get_string(l_jsn_outcome_detal, 'NOTES_PRN');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T005'),
                                                                             ':'), --'PRN Condition'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    --frequency
                    l_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                     i_prof                 => i_prof,
                                                                     i_id_order_recurr_plan => l_order_recurr_plan,
                                                                     i_order_recurr_option  => NULL);
                
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T006'),
                                                                             ':'), --'Frequency'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    --startDate
                    l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                      i_prof              => i_prof,
                                                                      i_order_recurr_plan => l_order_recurr_plan);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     REPLACE(pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_INSTRUCT_T007'),
                                                                             ':'), --'Start Date'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- NocOutcome.descStatus
                    l_value_string := json_ext.get_string(l_jsn_outcome_detal, 'STATUS.DESC_FLG_STATUS');
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value    => l_value_string,
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := json_ext.get_string(l_jsn_outcome_detal, 'CANCEL_INFO.CANCEL_REASON_DESC');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    l_value_string := json_ext.get_string(l_jsn_outcome_detal, 'CANCEL_INFO.CANCEL_NOTES');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- Signature
                    l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                                 i_prof                   => i_prof,
                                                                 i_id_episode             => json_ext.get_number(l_jsn_outcome_detal,
                                                                                                                 'CONTEXT_RECORD.ID_EPISODE'),
                                                                 i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                           i_prof      => i_prof,
                                                                                                                           i_timestamp => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                                                              'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                           i_timezone  => NULL),
                                                                 i_id_prof_last_change    => json_ext.get_number(l_jsn_outcome_detal,
                                                                                                                 'PROF_INFO.ID_PROFESSIONAL'),
                                                                 i_has_historical_changes => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                 'HAS_HISTORICAL_CHANGES'));
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                    IF l_req_status NOT IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        IF l_has_evaluation
                        THEN
                            -- Subtitle: Last evaluation
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M020'), --'Last evaluation '
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_subtitle);
                        
                            -- LastEvaluation.dtEvaluation
                            l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                          pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                        i_prof      => i_prof,
                                                                                                        i_timestamp => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                                           'LAST_EVALUATION.DT_EVALUATION'),
                                                                                                        i_timezone  => NULL),
                                                                          i_prof.institution,
                                                                          i_prof.software);
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(2) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M007'), --'Evaluation date',
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                            -- NocOutcome.lastEvaluation.targetValue.scaleLevelValue - NocOutcome.lastEvaluation.targetValue.descScaleLevelValue
                            l_value_string := json_ext.get_number(l_jsn_outcome_detal,
                                                                  'LAST_EVALUATION.TARGET_VALUE.SCALE_LEVEL_VALUE') ||
                                              ' - ' ||
                                              json_ext.get_string(l_jsn_outcome_detal,
                                                                  'LAST_EVALUATION.TARGET_VALUE.DESC_SCALE_LEVEL_VALUE');
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(2) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M014'), --'Expected outcome'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                            -- NocOutcome.lastEvaluation.outcomeValue.scaleLevelValue - NocOutcome.lastEvaluation.outcomeValue.descScaleLevelValue
                            l_value_string := json_ext.get_number(l_jsn_outcome_detal,
                                                                  'LAST_EVALUATION.OUTCOME_VALUE.SCALE_LEVEL_VALUE') ||
                                              ' - ' ||
                                              json_ext.get_string(l_jsn_outcome_detal,
                                                                  'LAST_EVALUATION.OUTCOME_VALUE.DESC_SCALE_LEVEL_VALUE');
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(2) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M015'), --'Current evaluation'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                            --  NocOutcome.lastEvaluation.notes                                                       
                            l_value_string := json_ext.get_string(l_jsn_outcome_detal, 'LAST_EVALUATION.NOTES');
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(2) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M011'), --'Notes'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                            -- Signature of last evaluation
                            l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                                         i_prof                   => i_prof,
                                                                         i_id_episode             => json_ext.get_number(l_jsn_outcome_detal,
                                                                                                                         'LAST_EVALUATION.CONTEXT_RECORD.ID_EPISODE'),
                                                                         i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                                   i_prof      => i_prof,
                                                                                                                                   i_timestamp => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                                                                      'LAST_EVALUATION.BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                                   i_timezone  => NULL),
                                                                         i_id_prof_last_change    => json_ext.get_number(l_jsn_outcome_detal,
                                                                                                                         'LAST_EVALUATION.PROF_INFO.ID_PROFESSIONAL'),
                                                                         i_has_historical_changes => json_ext.get_string(l_jsn_outcome_detal,
                                                                                                                         'LAST_EVALUATION.HAS_HISTORICAL_CHANGES'));
                            pk_edis_hist.add_value(i_label => NULL,
                                                   i_value => l_value_string,
                                                   i_type  => pk_edis_hist.g_type_signature,
                                                   i_code  => 'SIGNATURE');
                        END IF;
                    
                        -- Collection of NOC Indicators linked to the NOC Outcome
                        l_lst_jsn_indicators := json_ext.get_json_list(l_jsn_outcome_detal, 'INDICATORS');
                        IF l_lst_jsn_indicators IS NOT NULL
                        THEN
                            IF l_lst_jsn_indicators.count > 0
                            THEN
                                --Subtitle: Indicators
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M030'), --'Indicators'
                                                       i_value    => NULL,
                                                       i_type     => pk_edis_hist.g_type_subtitle);
                                FOR x IN 1 .. l_lst_jsn_indicators.count()
                                LOOP
                                    l_jsn_indicator := json(l_lst_jsn_indicators.get(x));
                                
                                    -- NocIndicator.description
                                    l_value_string := json_ext.get_string(l_jsn_indicator, 'NOC_INDICATOR.DESCRIPTION');
                                    pk_edis_hist.add_value(i_lang     => i_lang,
                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                           i_label    => pk_string_utils.get_tab(2) ||
                                                                         pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_DETAIL_M016'), --'Indicator'
                                                           i_value    => l_value_string,
                                                           i_type     => pk_edis_hist.g_type_content);
                                
                                    -- NocIndicator.descFlgStatus
                                    l_value_string := json_ext.get_string(l_jsn_indicator, 'STATUS.DESC_FLG_STATUS');
                                    pk_edis_hist.add_value(i_lang     => i_lang,
                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                           i_label    => pk_string_utils.get_tab(4) ||
                                                                         pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_DETAIL_M006'), --'Status'
                                                           i_value    => l_value_string,
                                                           i_type     => pk_edis_hist.g_type_content);
                                
                                    IF json_ext.get_number(l_jsn_indicator, 'LAST_EVALUATION.ID_NNN_EPIS_IND_EVAL') IS NOT NULL
                                    THEN
                                        -- NocIndicator.lastEvaluation.targetValue.scaleLevelValue - NocIndicator.lastEvaluation.targetValue.descScaleLevelValue                                    
                                        l_value_string := json_ext.get_number(l_jsn_indicator,
                                                                              'LAST_EVALUATION.TARGET_VALUE.SCALE_LEVEL_VALUE') ||
                                                          ' - ' ||
                                                          json_ext.get_string(l_jsn_indicator,
                                                                              'LAST_EVALUATION.TARGET_VALUE.DESC_SCALE_LEVEL_VALUE');
                                        pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                                           i_label    => pk_string_utils.get_tab(4) ||
                                                                                         pk_message.get_message(i_lang,
                                                                                                                i_prof,
                                                                                                                'NNN_DETAIL_M014'), --'Expected outcome'
                                                                           i_value    => l_value_string,
                                                                           i_type     => pk_edis_hist.g_type_content);
                                    
                                        -- NocIndicator.lastEvaluation.indicatorValue.scaleLevelValue - NocIndicator.lastEvaluation.indicatorValue.descScaleLevelValue                                                                        
                                        l_value_string := pk_string_utils.concat_if_exists(i_str1 => json_ext.get_number(l_jsn_indicator,
                                                                                                                         'LAST_EVALUATION.INDICATOR_VALUE.SCALE_LEVEL_VALUE'),
                                                                                           i_str2 => json_ext.get_string(l_jsn_indicator,
                                                                                                                         'LAST_EVALUATION.INDICATOR_VALUE.DESC_SCALE_LEVEL_VALUE'),
                                                                                           i_sep  => ' - ');
                                        pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                                           i_label    => pk_string_utils.get_tab(4) ||
                                                                                         pk_message.get_message(i_lang,
                                                                                                                i_prof,
                                                                                                                'NNN_DETAIL_M015'), --'Current evaluation'
                                                                           i_value    => l_value_string,
                                                                           i_type     => pk_edis_hist.g_type_content);
                                    END IF;
                                
                                END LOOP;
                            
                            END IF;
                        END IF;
                    
                    END IF;
                
                    -- Empty line
                    pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
                
                WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                    -- History of changes: Displays only editions on Careplan's NOC Outcome (nnn_epis_outcome)
                    l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                    l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                    l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
                
                    --Get history of changes in nnn_epis_diagnosis
                    get_epis_noc_outcome_h(i_lang             => i_lang,
                                           i_prof             => i_prof,
                                           i_nnn_epis_outcome => i_nnn_epis_outcome,
                                           o_hist             => l_cursor);
                    FETCH l_cursor BULK COLLECT
                        INTO l_coll_nnn_epis_outcome_h, l_coll_obj_nnn_epis_outcome;
                    CLOSE l_cursor;
                
                    FOR i IN 1 .. l_coll_nnn_epis_outcome_h.count()
                    LOOP
                        l_nnn_epis_outcome_h   := l_coll_nnn_epis_outcome_h(i);
                        l_obj_nnn_epis_outcome := l_coll_obj_nnn_epis_outcome(i);
                        l_obj_noc_outcome      := pk_noc_model.get_noc_outcome(i_lang        => i_lang,
                                                                               i_noc_outcome => l_obj_nnn_epis_outcome.id_noc_outcome);
                        IF l_coll_obj_nnn_epis_outcome.exists(i + 1)
                        THEN
                            l_has_previous              := TRUE;
                            l_prev_obj_nnn_epis_outcome := l_coll_obj_nnn_epis_outcome(i + 1);
                            l_prev_obj_noc_outcome      := pk_noc_model.get_noc_outcome(i_lang        => i_lang,
                                                                                        i_noc_outcome => l_prev_obj_nnn_epis_outcome.id_noc_outcome);
                            l_flg_call                  := pk_edis_hist.g_call_hist;
                        ELSE
                            l_has_previous              := FALSE;
                            l_prev_obj_nnn_epis_outcome := NULL;
                            l_prev_obj_noc_outcome      := NULL;
                            l_flg_call                  := pk_edis_hist.g_call_detail;
                        END IF;
                    
                        pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_outcome_h, -1),
                                              i_dt_hist        => l_obj_nnn_epis_outcome.bitemporal_data.transaction_time.dt_trs_time_start,
                                              i_record_state   => l_obj_nnn_epis_outcome.status.flg_status,
                                              i_desc_rec_state => l_obj_nnn_epis_outcome.status.desc_flg_status,
                                              i_professional   => l_obj_nnn_epis_outcome.prof_info.id_professional,
                                              i_episode        => l_obj_nnn_epis_outcome.context_record.id_episode);
                    
                        --Title: {Creation, Edition, Cancel}
                        IF l_obj_nnn_epis_outcome.status.flg_status IN
                           (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                        THEN
                            g_error := 'ADD CANCEL TITLE';
                            pk_edis_hist.add_value(i_lang  => i_lang,
                                                   i_label => l_label_cancel,
                                                   i_value => NULL,
                                                   i_type  => pk_edis_hist.g_type_title);
                        ELSIF l_prev_obj_nnn_epis_outcome IS NULL
                        THEN
                            g_error := 'ADD CREATION TITLE';
                            pk_edis_hist.add_value(i_lang  => i_lang,
                                                   i_label => l_label_creation,
                                                   i_value => NULL,
                                                   i_type  => pk_edis_hist.g_type_title);
                        ELSE
                            g_error := 'ADD EDITION TITLE';
                            pk_edis_hist.add_value(i_lang  => i_lang,
                                                   i_label => l_label_edition,
                                                   i_value => NULL,
                                                   i_type  => pk_edis_hist.g_type_title);
                        
                        END IF;
                    
                        -- Subtitle: General information
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                               i_value    => NULL,
                                               i_type     => pk_edis_hist.g_type_subtitle);
                    
                        -- NocOutcome.name      
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                               i_value     => l_obj_noc_outcome.name,
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_prev_obj_noc_outcome.name
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- NocOutcome.definition
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M024'), --'NOC Definition'
                                               i_value     => l_obj_noc_outcome.definition,
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_prev_obj_noc_outcome.definition
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- NocOutcome.domainName (NocOutcome.domainCode)
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M025'), --'NOC Domain'
                                               i_value     => l_obj_noc_outcome.class.domain.name || ' (' ||
                                                              l_obj_noc_outcome.class.domain.domain_code || ')',
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_prev_obj_noc_outcome.class.domain.name || ' (' ||
                                                                   l_prev_obj_noc_outcome.class.domain.domain_code || ')'
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- NocOutcome.className (NocOutcome.classCode)
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M026'), --'NOC Class'
                                               i_value     => l_obj_noc_outcome.class.name || ' (' || l_obj_noc_outcome.class.class_code || ')',
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_prev_obj_noc_outcome.class.name || ' (' ||
                                                                   l_prev_obj_noc_outcome.class.class_code || ')'
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- flgPriority
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T002'),
                                                                                  ':'), --'Priority'
                                                           i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_priority,
                                                                                                  i_val      => l_obj_nnn_epis_outcome.flg_priority,
                                                                                                  i_lang     => i_lang),
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_priority,
                                                                                                       i_val      => l_prev_obj_nnn_epis_outcome.flg_priority,
                                                                                                       i_lang     => i_lang)
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        -- flgTime
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T003'),
                                                                                  ':'), --'To be performed'
                                                           i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_time,
                                                                                                  i_val      => l_obj_nnn_epis_outcome.flg_time,
                                                                                                  i_lang     => i_lang),
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_time,
                                                                                                       i_val      => l_prev_obj_nnn_epis_outcome.flg_time,
                                                                                                       i_lang     => i_lang)
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        -- flgPRN
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T004'),
                                                                                  ':'), --'PRN'
                                                           i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_prn,
                                                                                                  i_val      => l_obj_nnn_epis_outcome.flg_prn,
                                                                                                  i_lang     => i_lang),
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_out_flg_prn,
                                                                                                       i_val      => l_prev_obj_nnn_epis_outcome.flg_prn,
                                                                                                       i_lang     => i_lang)
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        -- notesPRN
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T005'),
                                                                                  ':'), --'PRN Condition'
                                                           i_value     => l_obj_nnn_epis_outcome.notes_prn,
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               l_prev_obj_nnn_epis_outcome.notes_prn
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        --frequency
                        l_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                         i_prof                 => i_prof,
                                                                         i_id_order_recurr_plan => l_obj_nnn_epis_outcome.id_order_recurr_plan,
                                                                         i_order_recurr_option  => NULL);
                        IF l_has_previous
                        THEN
                            l_old_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                                 i_prof                 => i_prof,
                                                                                 i_id_order_recurr_plan => l_prev_obj_nnn_epis_outcome.id_order_recurr_plan,
                                                                                 i_order_recurr_option  => NULL);
                        ELSE
                            l_old_value_string := NULL;
                        END IF;
                    
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang,
                                                                                                         i_prof,
                                                                                                         'NNN_INSTRUCT_T006'),
                                                                                  ':'), --'Frequency'
                                                           i_value     => l_value_string,
                                                           i_old_value => l_old_value_string,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        --startDate
                        l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                          i_prof              => i_prof,
                                                                          i_order_recurr_plan => l_obj_nnn_epis_outcome.id_order_recurr_plan);
                        IF l_has_previous
                        THEN
                            l_old_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                                  i_prof              => i_prof,
                                                                                  i_order_recurr_plan => l_prev_obj_nnn_epis_outcome.id_order_recurr_plan);
                        ELSE
                            l_old_value_string := NULL;
                        END IF;
                    
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(4) ||
                                                                          REPLACE(pk_message.get_message(i_lang,
                                                                                                         i_prof,
                                                                                                         'NNN_INSTRUCT_T007'),
                                                                                  ':'), --'Start Date'
                                                           i_value     => l_value_string,
                                                           i_old_value => l_old_value_string,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        -- Status of the entry:
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                               i_value     => l_obj_nnn_epis_outcome.status.desc_flg_status,
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_prev_obj_nnn_epis_outcome.status.desc_flg_status
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- CancelInfo.cancelReasonDesc
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(2) ||
                                                                          pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M006'), --'Cancel reason'
                                                           i_value     => l_obj_nnn_epis_outcome.cancel_info.cancel_reason_desc,
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               l_prev_obj_nnn_epis_outcome.cancel_info.cancel_reason_desc
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        -- CancelInfo.cancelNotes
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => pk_string_utils.get_tab(2) ||
                                                                          pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M007'), --'Cancel notes'
                                                           i_value     => l_obj_nnn_epis_outcome.cancel_info.cancel_notes,
                                                           i_old_value => CASE
                                                                              WHEN l_has_previous THEN
                                                                               l_prev_obj_nnn_epis_outcome.cancel_info.cancel_notes
                                                                              ELSE
                                                                               NULL
                                                                          END,
                                                           i_type      => pk_edis_hist.g_type_content);
                    
                        --Signature 
                        l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                     i_prof                => i_prof,
                                                                     i_id_episode          => l_obj_nnn_epis_outcome.context_record.id_episode,
                                                                     i_date                => l_obj_nnn_epis_outcome.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                     i_id_prof_last_change => l_obj_nnn_epis_outcome.prof_info.id_professional);
                        pk_edis_hist.add_value(i_label => NULL,
                                               i_value => l_value_string,
                                               i_type  => pk_edis_hist.g_type_signature,
                                               i_code  => 'SIGNATURE');
                    
                    END LOOP;
                
            END CASE;
        */
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    
    END get_epis_noc_outcome_det;

    FUNCTION get_epis_noc_outcome_eval
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_outcome_eval IN nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE
    ) RETURN t_obj_nnn_epis_outcome_eval IS
        l_obj t_obj_nnn_epis_outcome_eval;
    BEGIN
        --Get information of NOC outcome evaluation
        SELECT t_obj_nnn_epis_outcome_eval(i_id_nnn_epis_outcome_eval => neoe.id_nnn_epis_outcome_eval,
                                           i_id_nnn_epis_outcome      => neoe.id_nnn_epis_outcome,
                                           i_context_record           => t_obj_context_record(i_id_episode => neoe.id_episode),
                                           i_prof_info                => t_obj_prof_info(i_id_professional => neoe.id_professional,
                                                                                         i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => neoe.id_professional),
                                                                                         i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => neoe.id_professional,
                                                                                                                                               i_dt_reg  => neoe.dt_trs_time_start,
                                                                                                                                               i_episode => neoe.id_episode)),
                                           i_target_value             => t_obj_likert_scale_level(i_scale_level_value      => neoe.target_value,
                                                                                                  i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                noc.id_noc_scale,
                                                                                                                                                                neoe.target_value)),
                                           i_outcome_value            => t_obj_likert_scale_level(i_scale_level_value      => neoe.outcome_value,
                                                                                                  i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                noc.id_noc_scale,
                                                                                                                                                                neoe.outcome_value)),
                                           
                                           i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                         i_prof             => i_prof,
                                                                                         i_id_cancel_reason => neoe.id_cancel_reason,
                                                                                         i_cancel_notes     => neoe.cancel_notes),
                                           i_status                 => t_obj_status(i_flg_status      => neoe.flg_status,
                                                                                    i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                 neoe.flg_status,
                                                                                                                                 i_lang),
                                                                                    i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                              i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                              i_val      => neoe.flg_status)),
                                           i_dt_evaluation          => neoe.dt_evaluation,
                                           i_dt_plan                => neoe.dt_plan,
                                           i_notes                  => pk_translation.get_translation_trs(neoe.code_notes),
                                           i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neoe.dt_trs_time_start,
                                                                                             i_trs_time_end   => neoe.dt_trs_time_end),
                                           i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                             FROM dual
                                                                            WHERE EXISTS
                                                                            (SELECT 1
                                                                                     FROM nnn_epis_outcome_eval_h hst
                                                                                    WHERE hst.id_nnn_epis_outcome_eval =
                                                                                          neoe.id_nnn_epis_outcome_eval)),
                                                                           pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_outcome_eval neoe
         INNER JOIN nnn_epis_outcome neo
            ON neo.id_nnn_epis_outcome = neoe.id_nnn_epis_outcome
         INNER JOIN noc_outcome noc
            ON neo.id_noc_outcome = noc.id_noc_outcome
         WHERE neoe.id_nnn_epis_outcome_eval = i_nnn_epis_outcome_eval;
    
        RETURN l_obj;
    END get_epis_noc_outcome_eval;

    PROCEDURE get_epis_noc_outcome_eval_h
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_outcome_eval IN nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE,
        o_hist                  OUT pk_types.cursor_type
    ) IS
    
    BEGIN
        --Get information of NOC outcome evaluation
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_outcome_eval_h, t.obj_nnn_epis_outcome_eval
              FROM (SELECT NULL id_nnn_epis_outcome_eval_h,
                           t_obj_nnn_epis_outcome_eval(i_id_nnn_epis_outcome_eval => neoe.id_nnn_epis_outcome_eval,
                                                       i_id_nnn_epis_outcome      => neoe.id_nnn_epis_outcome,
                                                       i_context_record           => t_obj_context_record(i_id_episode => neoe.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => neoe.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neoe.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neoe.id_professional,
                                                                                                                                                           i_dt_reg  => neoe.dt_trs_time_start,
                                                                                                                                                           i_episode => neoe.id_episode)),
                                                       i_target_value             => t_obj_likert_scale_level(i_scale_level_value      => neoe.target_value,
                                                                                                              i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                            noc.id_noc_scale,
                                                                                                                                                                            neoe.target_value)),
                                                       i_outcome_value            => t_obj_likert_scale_level(i_scale_level_value      => neoe.outcome_value,
                                                                                                              i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                            noc.id_noc_scale,
                                                                                                                                                                            neoe.outcome_value)),
                                                       
                                                       i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                     i_prof             => i_prof,
                                                                                                     i_id_cancel_reason => neoe.id_cancel_reason,
                                                                                                     i_cancel_notes     => neoe.cancel_notes),
                                                       i_status                 => t_obj_status(i_flg_status      => neoe.flg_status,
                                                                                                i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                             neoe.flg_status,
                                                                                                                                             i_lang),
                                                                                                i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                          i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                          i_val      => neoe.flg_status)),
                                                       i_dt_evaluation          => neoe.dt_evaluation,
                                                       i_notes                  => pk_translation.get_translation_trs(neoe.code_notes),
                                                       i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neoe.dt_trs_time_start,
                                                                                                         i_trs_time_end   => neoe.dt_trs_time_end),
                                                       i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                         FROM dual
                                                                                        WHERE EXISTS
                                                                                        (SELECT 1
                                                                                                 FROM nnn_epis_outcome_eval_h hst
                                                                                                WHERE hst.id_nnn_epis_outcome_eval =
                                                                                                      neoe.id_nnn_epis_outcome_eval)),
                                                                                       pk_alert_constant.g_no)) obj_nnn_epis_outcome_eval,
                           neoe.dt_trs_time_start,
                           neoe.dt_trs_time_end
                      FROM nnn_epis_outcome_eval neoe
                     INNER JOIN nnn_epis_outcome neo
                        ON neo.id_nnn_epis_outcome = neoe.id_nnn_epis_outcome
                     INNER JOIN noc_outcome noc
                        ON neo.id_noc_outcome = noc.id_noc_outcome
                     WHERE neoe.id_nnn_epis_outcome_eval = i_nnn_epis_outcome_eval
                    UNION ALL
                    SELECT neoeh.id_nnn_epis_outcome_eval_h,
                           t_obj_nnn_epis_outcome_eval(i_id_nnn_epis_outcome_eval => neoeh.id_nnn_epis_outcome_eval,
                                                       i_id_nnn_epis_outcome      => neoeh.id_nnn_epis_outcome,
                                                       i_context_record           => t_obj_context_record(i_id_episode => neoeh.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => neoeh.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neoeh.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neoeh.id_professional,
                                                                                                                                                           i_dt_reg  => neoeh.dt_trs_time_start,
                                                                                                                                                           i_episode => neoeh.id_episode)),
                                                       i_target_value             => t_obj_likert_scale_level(i_scale_level_value      => neoeh.target_value,
                                                                                                              i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                            noc.id_noc_scale,
                                                                                                                                                                            neoeh.target_value)),
                                                       i_outcome_value            => t_obj_likert_scale_level(i_scale_level_value      => neoeh.outcome_value,
                                                                                                              i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                            noc.id_noc_scale,
                                                                                                                                                                            neoeh.outcome_value)),
                                                       
                                                       i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                     i_prof             => i_prof,
                                                                                                     i_id_cancel_reason => neoeh.id_cancel_reason,
                                                                                                     i_cancel_notes     => neoeh.cancel_notes),
                                                       i_status                 => t_obj_status(i_flg_status      => neoeh.flg_status,
                                                                                                i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                             neoeh.flg_status,
                                                                                                                                             i_lang),
                                                                                                i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                          i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                          i_val      => neoeh.flg_status)),
                                                       i_dt_evaluation          => neoeh.dt_evaluation,
                                                       i_notes                  => neoeh.notes,
                                                       i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neoeh.dt_trs_time_start,
                                                                                                         i_trs_time_end   => neoeh.dt_trs_time_end),
                                                       i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                         FROM dual
                                                                                        WHERE EXISTS
                                                                                        (SELECT 1
                                                                                                 FROM nnn_epis_outcome_eval_h hst
                                                                                                WHERE hst.id_nnn_epis_outcome_eval =
                                                                                                      neoeh.id_nnn_epis_outcome_eval)),
                                                                                       pk_alert_constant.g_no)) obj_nnn_epis_outcome_eval,
                           neoeh.dt_trs_time_start,
                           neoeh.dt_trs_time_end
                      FROM nnn_epis_outcome_eval_h neoeh
                     INNER JOIN nnn_epis_outcome neo
                        ON neo.id_nnn_epis_outcome = neoeh.id_nnn_epis_outcome
                     INNER JOIN noc_outcome noc
                        ON neo.id_noc_outcome = noc.id_noc_outcome
                     WHERE neoeh.id_nnn_epis_outcome_eval = i_nnn_epis_outcome_eval
                    
                    ) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_noc_outcome_eval_h;

    PROCEDURE get_epis_noc_outcome_eval_det
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_outcome_eval IN nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE,
        i_flg_detail_type       IN VARCHAR2,
        o_detail                OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_noc_outcome_eval_det';
        TYPE lt_lst_obj_nnn_epis_outc_eval IS TABLE OF t_obj_nnn_epis_outcome_eval;
        l_label_edition  sys_message.desc_message%TYPE;
        l_label_creation sys_message.desc_message%TYPE;
        l_label_cancel   sys_message.desc_message%TYPE;
        l_flg_call       VARCHAR2(1 CHAR);
        l_cursor         pk_types.cursor_type;
    
        l_obj_noc_outcome            t_obj_noc_outcome;
        l_obj_epis_outcome           t_obj_nnn_epis_outcome;
        l_obj_epis_outcome_eval      t_obj_nnn_epis_outcome_eval;
        l_prev_obj_epis_outcome_eval t_obj_nnn_epis_outcome_eval;
        l_lst_obj_epis_outcome_eval  lt_lst_obj_nnn_epis_outc_eval;
    
        l_lst_nnn_epis_outcome_eval_h table_number;
    
        l_nnn_epis_outcome_eval_h nnn_epis_outcome_eval_h.id_nnn_epis_outcome_eval_h%TYPE;
    
        l_value_string     pk_types.t_huge_byte;
        l_old_value_string pk_types.t_huge_byte;
        l_has_previous     BOOLEAN;
    
    BEGIN
        --Initialization of detail table
        pk_edis_hist.init_vars;
    
        CASE i_flg_detail_type
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details:
                l_obj_epis_outcome_eval := pk_nnn_api_db.get_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                                                   i_prof                  => i_prof,
                                                                                   i_nnn_epis_outcome_eval => i_nnn_epis_outcome_eval);
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history        => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist        => l_obj_epis_outcome_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                      i_record_state   => l_obj_epis_outcome_eval.status.flg_status,
                                      i_desc_rec_state => l_obj_epis_outcome_eval.status.desc_flg_status,
                                      i_professional   => l_obj_epis_outcome_eval.prof_info.id_professional,
                                      i_episode        => l_obj_epis_outcome_eval.context_record.id_episode);
            
                g_error := 'Get the careplan''s NOC Outcome i_nnn_epis_outcome = ' ||
                           to_char(l_obj_epis_outcome_eval.id_nnn_epis_outcome);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_nnn_epis_outcome => l_obj_epis_outcome_eval.id_nnn_epis_outcome);
            
                g_error := 'Get info about this outcome from the NOC Classification';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_noc_outcome := pk_noc_model.get_noc_outcome(i_lang        => i_lang,
                                                                  i_noc_outcome => l_obj_epis_outcome.id_noc_outcome);
            
                -- Title: NocOutcomeName
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => pk_noc_model.format_noc_name(i_label       => l_obj_noc_outcome.name,
                                                                               i_noc_code    => l_obj_noc_outcome.noc_code,
                                                                               i_code_format => pk_nan_model.g_code_format_end),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: General information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- NocOutcome.name        
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                       i_value    => l_obj_noc_outcome.name,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcome.definition
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M024'), --'NOC Definition'
                                       i_value    => l_obj_noc_outcome.definition,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcome.domainName (NocOutcome.domainCode)
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M025'), --'NOC Domain'
                                       i_value    => l_obj_noc_outcome.class.domain.name || ' (' ||
                                                     l_obj_noc_outcome.class.domain.domain_code || ')',
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcome.className (NocOutcome.classCode)
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M026'), --'NOC Class'
                                       i_value    => l_obj_noc_outcome.class.name || ' (' ||
                                                     l_obj_noc_outcome.class.class_code || ')',
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- Subtitle: Evaluation information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M005'), --'Evaluation information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- NocOutcomeEval.Evaluation.targetValue.scaleLevelValue - NocOutcomeEval.Evaluation.targetValue.descScaleLevelValue
                l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_outcome_eval.target_value.scale_level_value,
                                                                   i_str2 => l_obj_epis_outcome_eval.target_value.desc_scale_level_value,
                                                                   i_sep  => ' - ');
            
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M014'), --'Expected outcome'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcomeEval.outcomeValue.scaleLevelValue - NocOutcomeEval.outcomeValue.descScaleLevelValue
                l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_outcome_eval.outcome_value.scale_level_value,
                                                                   i_str2 => l_obj_epis_outcome_eval.outcome_value.desc_scale_level_value,
                                                                   i_sep  => ' - ');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M015'), --'Current evaluation'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcomeEval.dtEvaluation
                l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                              l_obj_epis_outcome_eval.dt_evaluation,
                                                              i_prof.institution,
                                                              i_prof.software);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M007'), --'Evaluation date',
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --  NocOutcomeEval.notes                                                       
                l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_outcome_eval.notes);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M011'), --'Notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocOutcomeEval.descStatus
                l_value_string := l_obj_epis_outcome_eval.status.desc_flg_status;
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := l_obj_epis_outcome_eval.cancel_info.cancel_reason_desc;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelNotes
                l_value_string := l_obj_epis_outcome_eval.cancel_info.cancel_notes;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => l_obj_epis_outcome_eval.context_record.id_episode,
                                                             i_date                   => l_obj_epis_outcome_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                             i_id_prof_last_change    => l_obj_epis_outcome_eval.prof_info.id_professional,
                                                             i_has_historical_changes => l_obj_epis_outcome_eval.has_historical_changes);
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                -- History of changes: Displays only editions in the evaluation of a Careplan's NOC Outcome (nnn_epis_outcome_eval)
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
            
                --Get history of changes in nnn_epis_outcome_eval
                get_epis_noc_outcome_eval_h(i_lang                  => i_lang,
                                            i_prof                  => i_prof,
                                            i_nnn_epis_outcome_eval => i_nnn_epis_outcome_eval,
                                            o_hist                  => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_lst_nnn_epis_outcome_eval_h, l_lst_obj_epis_outcome_eval;
                CLOSE l_cursor;
            
                l_obj_noc_outcome := NULL;
                FOR i IN 1 .. l_lst_nnn_epis_outcome_eval_h.count()
                LOOP
                    l_nnn_epis_outcome_eval_h := l_lst_nnn_epis_outcome_eval_h(i);
                    l_obj_epis_outcome_eval   := l_lst_obj_epis_outcome_eval(i);
                    IF l_obj_noc_outcome IS NULL
                    THEN
                        -- The requested outcome doesn't change with the editions of the evaluation, so these objects are retrieved just once.
                        g_error := 'Get the careplan''s NOC Outcome i_nnn_epis_outcome = ' ||
                                   to_char(l_obj_epis_outcome_eval.id_nnn_epis_outcome);
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package,
                                             sub_object_name => k_function_name);
                        l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                                 i_prof             => i_prof,
                                                                                 i_nnn_epis_outcome => l_obj_epis_outcome_eval.id_nnn_epis_outcome);
                    
                        g_error := 'Get info about this outcome from the NOC Classification';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => k_function_name);
                        l_obj_noc_outcome := pk_noc_model.get_noc_outcome(i_lang        => i_lang,
                                                                          i_noc_outcome => l_obj_epis_outcome.id_noc_outcome);
                    
                    END IF;
                
                    IF l_lst_obj_epis_outcome_eval.exists(i + 1)
                    THEN
                        l_has_previous               := TRUE;
                        l_prev_obj_epis_outcome_eval := l_lst_obj_epis_outcome_eval(i + 1);
                        l_flg_call                   := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous               := FALSE;
                        l_prev_obj_epis_outcome_eval := NULL;
                        l_flg_call                   := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_outcome_eval_h, -1),
                                          i_dt_hist        => l_obj_epis_outcome_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_epis_outcome_eval.status.flg_status,
                                          i_desc_rec_state => l_obj_epis_outcome_eval.status.desc_flg_status,
                                          i_professional   => l_obj_epis_outcome_eval.prof_info.id_professional,
                                          i_episode        => l_obj_epis_outcome_eval.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_epis_outcome_eval.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_epis_outcome_eval IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    END IF;
                
                    -- NocOutcome.name        
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => l_obj_noc_outcome.name, --pk_string_utils.get_tab(2) || pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value    => NULL, --l_obj_noc_outcome.name,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NocOutcomeEval.Evaluation.targetValue.scaleLevelValue - NocOutcomeEval.Evaluation.targetValue.descScaleLevelValue
                    l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_outcome_eval.target_value.scale_level_value,
                                                                       i_str2 => l_obj_epis_outcome_eval.target_value.desc_scale_level_value,
                                                                       i_sep  => ' - ');
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.concat_if_exists(i_str1 => l_prev_obj_epis_outcome_eval.target_value.scale_level_value,
                                                                               i_str2 => l_prev_obj_epis_outcome_eval.target_value.desc_scale_level_value,
                                                                               i_sep  => ' - ');
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M014'), --'Expected outcome'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocOutcomeEval.outcomeValue.scaleLevelValue - NocOutcomeEval.outcomeValue.descScaleLevelValue
                    l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_outcome_eval.outcome_value.scale_level_value,
                                                                       i_str2 => l_obj_epis_outcome_eval.outcome_value.desc_scale_level_value,
                                                                       i_sep  => ' - ');
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.concat_if_exists(i_str1 => l_prev_obj_epis_outcome_eval.outcome_value.scale_level_value,
                                                                               i_str2 => l_prev_obj_epis_outcome_eval.outcome_value.desc_scale_level_value,
                                                                               i_sep  => ' - ');
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M015'), --'Current evaluation'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocOutcomeEval.dtEvaluation
                    l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                  l_obj_epis_outcome_eval.dt_evaluation,
                                                                  i_prof.institution,
                                                                  i_prof.software);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                          l_prev_obj_epis_outcome_eval.dt_evaluation,
                                                                          i_prof.institution,
                                                                          i_prof.software);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M007'), --'Evaluation date',
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --  NocOutcomeEval.notes                                                       
                    l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_outcome_eval.notes);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_prev_obj_epis_outcome_eval.notes);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M011'), --'Notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocOutcomeEval.descStatus
                    l_value_string := l_obj_epis_outcome_eval.status.desc_flg_status;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_outcome_eval.status.desc_flg_status;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_value_string,
                                           i_old_value => l_old_value_string,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := l_obj_epis_outcome_eval.cancel_info.cancel_reason_desc;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_outcome_eval.cancel_info.cancel_reason_desc;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    l_value_string := l_obj_epis_outcome_eval.cancel_info.cancel_notes;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_outcome_eval.cancel_info.cancel_notes;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Signature
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_epis_outcome_eval.context_record.id_episode,
                                                                 i_date                => l_obj_epis_outcome_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_epis_outcome_eval.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
    
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    
    END get_epis_noc_outcome_eval_det;

    FUNCTION get_epis_noc_indicator
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE
    ) RETURN t_obj_nnn_epis_indicator IS
        l_obj t_obj_nnn_epis_indicator;
    BEGIN
        -- Get information of NOC Indicator in the care plan
        SELECT t_obj_nnn_epis_indicator(i_id_nnn_epis_indicator  => nei.id_nnn_epis_indicator,
                                        i_id_noc_indicator       => nei.id_noc_indicator,
                                        i_id_noc_othr_ind_vrsn   => nei.id_noc_othr_ind_vrsn,
                                        i_context_record         => t_obj_context_record(i_id_episode => nei.id_episode),
                                        i_prof_info              => t_obj_prof_info(i_id_professional => nei.id_professional,
                                                                                    i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                          i_prof    => i_prof,
                                                                                                                                          i_prof_id => nei.id_professional),
                                                                                    i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                          i_prof    => i_prof,
                                                                                                                                          i_prof_id => nei.id_professional,
                                                                                                                                          i_dt_reg  => nei.dt_trs_time_start,
                                                                                                                                          i_episode => nei.id_episode)),
                                        i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                      i_prof             => i_prof,
                                                                                      i_id_cancel_reason => nei.id_cancel_reason,
                                                                                      i_cancel_notes     => nei.cancel_notes),
                                        i_status                 => t_obj_status(i_flg_status      => nei.flg_req_status,
                                                                                 i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_ind_flg_req_status,
                                                                                                                              nei.flg_req_status,
                                                                                                                              i_lang)),
                                        i_id_episode_origin      => nei.id_episode_origin,
                                        i_id_episode_destination => nei.id_episode_destination,
                                        i_flg_prn                => nei.flg_prn,
                                        i_notes_prn              => pk_translation.get_translation_trs(nei.code_notes_prn),
                                        i_flg_time               => nei.flg_time,
                                        i_flg_priority           => nei.flg_priority,
                                        i_id_order_recurr_plan   => nei.id_order_recurr_plan,
                                        i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                 i_prof              => i_prof,
                                                                                                 i_flg_priority      => nei.flg_priority,
                                                                                                 i_flg_prn           => nei.flg_prn,
                                                                                                 i_notes_prn         => pk_translation.get_translation_trs(nei.code_notes_prn),
                                                                                                 i_flg_time          => nei.flg_time,
                                                                                                 i_order_recurr_plan => nei.id_order_recurr_plan),
                                        i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => nei.dt_val_time_start,
                                                                                          i_val_time_end   => nei.dt_val_time_end,
                                                                                          i_trs_time_start => nei.dt_trs_time_start,
                                                                                          i_trs_time_end   => nei.dt_trs_time_end),
                                        i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                          FROM dual
                                                                         WHERE EXISTS
                                                                         (SELECT 1
                                                                                  FROM nnn_epis_indicator_h hst
                                                                                 WHERE hst.id_nnn_epis_indicator =
                                                                                       nei.id_nnn_epis_indicator)),
                                                                        pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_indicator nei
         WHERE nei.id_nnn_epis_indicator = i_nnn_epis_indicator;
    
        RETURN l_obj;
    END get_epis_noc_indicator;

    PROCEDURE get_epis_noc_indicator_h
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE,
        o_hist               OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_indicator_h, t.obj_nnn_epis_indicator
              FROM (SELECT NULL id_nnn_epis_indicator_h,
                           t_obj_nnn_epis_indicator(i_id_nnn_epis_indicator  => nei.id_nnn_epis_indicator,
                                                    i_id_noc_indicator       => nei.id_noc_indicator,
                                                    i_id_noc_othr_ind_vrsn   => nei.id_noc_othr_ind_vrsn,
                                                    i_context_record         => t_obj_context_record(i_id_episode => nei.id_episode),
                                                    i_prof_info              => t_obj_prof_info(i_id_professional => nei.id_professional,
                                                                                                i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                      i_prof    => i_prof,
                                                                                                                                                      i_prof_id => nei.id_professional),
                                                                                                i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                      i_prof    => i_prof,
                                                                                                                                                      i_prof_id => nei.id_professional,
                                                                                                                                                      i_dt_reg  => nei.dt_trs_time_start,
                                                                                                                                                      i_episode => nei.id_episode)),
                                                    i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                  i_prof             => i_prof,
                                                                                                  i_id_cancel_reason => nei.id_cancel_reason,
                                                                                                  i_cancel_notes     => nei.cancel_notes),
                                                    i_status                 => t_obj_status(i_flg_status      => nei.flg_req_status,
                                                                                             i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_ind_flg_req_status,
                                                                                                                                          nei.flg_req_status,
                                                                                                                                          i_lang)),
                                                    i_id_episode_origin      => nei.id_episode_origin,
                                                    i_id_episode_destination => nei.id_episode_destination,
                                                    i_flg_prn                => nei.flg_prn,
                                                    i_notes_prn              => pk_translation.get_translation_trs(nei.code_notes_prn),
                                                    i_flg_time               => nei.flg_time,
                                                    i_flg_priority           => nei.flg_priority,
                                                    i_id_order_recurr_plan   => nei.id_order_recurr_plan,
                                                    i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                             i_prof              => i_prof,
                                                                                                             i_flg_priority      => nei.flg_priority,
                                                                                                             i_flg_prn           => nei.flg_prn,
                                                                                                             i_notes_prn         => pk_translation.get_translation_trs(nei.code_notes_prn),
                                                                                                             i_flg_time          => nei.flg_time,
                                                                                                             i_order_recurr_plan => nei.id_order_recurr_plan),
                                                    i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => nei.dt_val_time_start,
                                                                                                      i_val_time_end   => nei.dt_val_time_end,
                                                                                                      i_trs_time_start => nei.dt_trs_time_start,
                                                                                                      i_trs_time_end   => nei.dt_trs_time_end),
                                                    i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                      FROM dual
                                                                                     WHERE EXISTS
                                                                                     (SELECT 1
                                                                                              FROM nnn_epis_indicator_h hst
                                                                                             WHERE hst.id_nnn_epis_indicator =
                                                                                                   nei.id_nnn_epis_indicator)),
                                                                                    pk_alert_constant.g_no)) obj_nnn_epis_indicator,
                           nei.dt_trs_time_start,
                           nei.dt_trs_time_end
                      FROM nnn_epis_indicator nei
                     WHERE nei.id_nnn_epis_indicator = i_nnn_epis_indicator
                    UNION ALL
                    SELECT neih.id_nnn_epis_indicator_h,
                           t_obj_nnn_epis_indicator(i_id_nnn_epis_indicator  => neih.id_nnn_epis_indicator,
                                                    i_id_noc_indicator       => neih.id_noc_indicator,
                                                    i_id_noc_othr_ind_vrsn   => neih.id_noc_othr_ind_vrsn,
                                                    i_context_record         => t_obj_context_record(i_id_episode => neih.id_episode),
                                                    i_prof_info              => t_obj_prof_info(i_id_professional => neih.id_professional,
                                                                                                i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                      i_prof    => i_prof,
                                                                                                                                                      i_prof_id => neih.id_professional),
                                                                                                i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                      i_prof    => i_prof,
                                                                                                                                                      i_prof_id => neih.id_professional,
                                                                                                                                                      i_dt_reg  => neih.dt_trs_time_start,
                                                                                                                                                      i_episode => neih.id_episode)),
                                                    i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                  i_prof             => i_prof,
                                                                                                  i_id_cancel_reason => neih.id_cancel_reason,
                                                                                                  i_cancel_notes     => neih.cancel_notes),
                                                    i_status                 => t_obj_status(i_flg_status      => neih.flg_req_status,
                                                                                             i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_ind_flg_req_status,
                                                                                                                                          neih.flg_req_status,
                                                                                                                                          i_lang)),
                                                    i_id_episode_origin      => neih.id_episode_origin,
                                                    i_id_episode_destination => neih.id_episode_destination,
                                                    i_flg_prn                => neih.flg_prn,
                                                    i_notes_prn              => neih.notes_prn,
                                                    i_flg_time               => neih.flg_time,
                                                    i_flg_priority           => neih.flg_priority,
                                                    i_id_order_recurr_plan   => neih.id_order_recurr_plan,
                                                    i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                             i_prof              => i_prof,
                                                                                                             i_flg_priority      => neih.flg_priority,
                                                                                                             i_flg_prn           => neih.flg_prn,
                                                                                                             i_notes_prn         => neih.notes_prn,
                                                                                                             i_flg_time          => neih.flg_time,
                                                                                                             i_order_recurr_plan => neih.id_order_recurr_plan),
                                                    i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => neih.dt_val_time_start,
                                                                                                      i_val_time_end   => neih.dt_val_time_end,
                                                                                                      i_trs_time_start => neih.dt_trs_time_start,
                                                                                                      i_trs_time_end   => neih.dt_trs_time_end),
                                                    i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                      FROM dual
                                                                                     WHERE EXISTS
                                                                                     (SELECT 1
                                                                                              FROM nnn_epis_indicator_h hst
                                                                                             WHERE hst.id_nnn_epis_indicator =
                                                                                                   neih.id_nnn_epis_indicator)),
                                                                                    pk_alert_constant.g_no)) obj_nnn_epis_indicator,
                           neih.dt_trs_time_start,
                           neih.dt_trs_time_end
                      FROM nnn_epis_indicator_h neih
                     WHERE neih.id_nnn_epis_indicator = i_nnn_epis_indicator) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_noc_indicator_h;

    PROCEDURE get_epis_noc_indicator_det
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE,
        i_flg_detail_type    IN VARCHAR2,
        o_detail             OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_noc_indicator_det';
    
        TYPE lt_coll_obj_nnn_epis_indicator IS TABLE OF t_obj_nnn_epis_indicator;
    
        l_jsn_indicator               json_object_t;
        l_coll_obj_nnn_epis_indicator lt_coll_obj_nnn_epis_indicator;
        l_coll_nnn_epis_indicator_h   table_number;
        l_obj_nnn_epis_indicator      t_obj_nnn_epis_indicator;
        l_prev_obj_nnn_epis_indicator t_obj_nnn_epis_indicator;
        l_obj_noc_indicator           t_obj_noc_indicator;
        l_prev_obj_noc_indicator      t_obj_noc_indicator;
        l_label_edition               sys_message.desc_message%TYPE;
        l_label_creation              sys_message.desc_message%TYPE;
        l_label_cancel                sys_message.desc_message%TYPE;
        l_req_status                  nnn_epis_indicator.flg_req_status%TYPE;
        l_order_recurr_plan           nnn_epis_indicator.id_order_recurr_plan%TYPE;
        l_nnn_epis_indicator_h        nnn_epis_indicator_h.id_nnn_epis_indicator_h%TYPE;
        l_cursor                      pk_types.cursor_type;
        l_flg_call                    VARCHAR2(1 CHAR);
        l_value_string                pk_types.t_huge_byte;
        l_old_value_string            pk_types.t_huge_byte;
        l_has_evaluation              BOOLEAN;
        l_has_previous                BOOLEAN;
    BEGIN
        /*g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_nnn_epis_indicator = ' || coalesce(to_char(i_nnn_epis_indicator), '<null>');
        g_error := g_error || ' i_flg_detail_type = ' || coalesce(i_flg_detail_type, '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
        --Initialization of detail table
        pk_edis_hist.init_vars;
        
        CASE i_flg_detail_type
        
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details 
            
                -- Get the hierachical detail of the careplan's NOC Indicator
                l_jsn_indicator := get_epis_indicator_hier_detail(i_lang               => i_lang,
                                                                  i_prof               => i_prof,
                                                                  i_nnn_epis_indicator => i_nnn_epis_indicator,
                                                                  i_nnn_epis_outcome   => NULL,
                                                                  i_noc_outcome        => NULL);
            
                -- Request's status
                l_req_status     := json_ext.get_string(l_jsn_indicator, 'STATUS.FLG_STATUS');
                l_has_evaluation := json_ext.get_string(l_jsn_indicator, 'LAST_EVALUATION.STATUS.FLG_STATUS') IS
                                    NOT NULL;
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                 i_prof      => i_prof,
                                                                                 i_timestamp => json_ext.get_string(l_jsn_indicator,
                                                                                                                    'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                 i_timezone  => NULL),
                                      
                                      i_record_state   => json_ext.get_string(l_jsn_indicator, 'STATUS.FLG_STATUS'),
                                      i_desc_rec_state => json_ext.get_string(l_jsn_indicator, 'STATUS.DESC_FLG_STATUS'),
                                      i_professional   => json_ext.get_number(l_jsn_indicator,
                                                                              'PROF_INFO.ID_PROFESSIONAL'),
                                      i_episode        => json_ext.get_number(l_jsn_indicator,
                                                                              'CONTEXT_RECORD.ID_EPISODE'));
            
                -- Title: NocIndicator.Description
                l_value_string := json_ext.get_string(l_jsn_indicator, 'NOC_INDICATOR.DESCRIPTION');
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => l_value_string,
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: Instructions
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T001'), --'Instructions'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- descInstructions  (we split the instructions to one property by row instead of use the string DESC_INSTRUCTIONS)
                l_order_recurr_plan := json_ext.get_number(l_jsn_indicator, 'ID_ORDER_RECURR_PLAN');
            
                -- flgPriority
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_priority,
                                                          i_val      => json_ext.get_string(l_jsn_indicator,
                                                                                            'FLG_PRIORITY'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T002'),
                                                                         ':'), --'Priority'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- flgTime
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_time,
                                                          i_val      => json_ext.get_string(l_jsn_indicator, 'FLG_TIME'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T003'),
                                                                         ':'), --'To be performed'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- flgPRN
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_prn,
                                                          i_val      => json_ext.get_string(l_jsn_indicator, 'FLG_PRN'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T004'),
                                                                         ':'), --'PRN'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- notesPRN
                l_value_string := json_ext.get_string(l_jsn_indicator, 'NOTES_PRN');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T005'),
                                                                         ':'), --'PRN Condition'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --frequency
                l_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                 i_prof                 => i_prof,
                                                                 i_id_order_recurr_plan => l_order_recurr_plan,
                                                                 i_order_recurr_option  => NULL);
            
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T006'),
                                                                         ':'), --'Frequency'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --startDate
                l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_order_recurr_plan => l_order_recurr_plan);
            
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T007'),
                                                                         ':'), --'Start Date'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- status.descFlgStatus
                l_value_string := json_ext.get_string(l_jsn_indicator, 'STATUS.DESC_FLG_STATUS');
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := json_ext.get_string(l_jsn_indicator, 'CANCEL_INFO.CANCEL_REASON_DESC');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- cancelInfo.cancelNotes
                l_value_string := json_ext.get_string(l_jsn_indicator, 'CANCEL_INFO.CANCEL_NOTES');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => json_ext.get_number(l_jsn_indicator,
                                                                                                             'CONTEXT_RECORD.ID_EPISODE'),
                                                             i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                       i_prof      => i_prof,
                                                                                                                       i_timestamp => json_ext.get_string(l_jsn_indicator,
                                                                                                                                                          'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                       i_timezone  => NULL),
                                                             i_id_prof_last_change    => json_ext.get_number(l_jsn_indicator,
                                                                                                             'PROF_INFO.ID_PROFESSIONAL'),
                                                             i_has_historical_changes => json_ext.get_string(l_jsn_indicator,
                                                                                                             'HAS_HISTORICAL_CHANGES'));
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
                IF l_req_status NOT IN
                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                   AND l_has_evaluation
                THEN
                    -- Subtitle: Last evaluation
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M020'), --'Last evaluation '
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- LastEvaluation.dtEvaluation
                    l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                  pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                i_prof      => i_prof,
                                                                                                i_timestamp => json_ext.get_string(l_jsn_indicator,
                                                                                                                                   'LAST_EVALUATION.DT_EVALUATION'),
                                                                                                i_timezone  => NULL),
                                                                  i_prof.institution,
                                                                  i_prof.software);
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M007'), --'Evaluation date',
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- NocIndicator.lastEvaluation.targetValue.scaleLevelValue - NocIndicator.lastEvaluation.targetValue.descScaleLevelValue                                    
                    l_value_string := json_ext.get_number(l_jsn_indicator,
                                                          'LAST_EVALUATION.TARGET_VALUE.SCALE_LEVEL_VALUE') || ' - ' ||
                                      json_ext.get_string(l_jsn_indicator,
                                                          'LAST_EVALUATION.TARGET_VALUE.DESC_SCALE_LEVEL_VALUE');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M014'), --'Expected outcome'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- NocIndicator.lastEvaluation.indicatorValue.scaleLevelValue - NocIndicator.lastEvaluation.indicatorValue.descScaleLevelValue                                                                        
                    l_value_string := json_ext.get_number(l_jsn_indicator,
                                                          'LAST_EVALUATION.INDICATOR_VALUE.SCALE_LEVEL_VALUE') || ' - ' ||
                                      json_ext.get_string(l_jsn_indicator,
                                                          'LAST_EVALUATION.INDICATOR_VALUE.DESC_SCALE_LEVEL_VALUE');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M015'), --'Current evaluation'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    --  NocIndicator.lastEvaluation.notes                                                       
                    l_value_string := json_ext.get_string(l_jsn_indicator, 'LAST_EVALUATION.NOTES');
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(2) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M011'), --'Notes'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                    -- Signature of last evaluation
                    l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                                 i_prof                   => i_prof,
                                                                 i_id_episode             => json_ext.get_number(l_jsn_indicator,
                                                                                                                 'LAST_EVALUATION.CONTEXT_RECORD.ID_EPISODE'),
                                                                 i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                           i_prof      => i_prof,
                                                                                                                           i_timestamp => json_ext.get_string(l_jsn_indicator,
                                                                                                                                                              'LAST_EVALUATION.BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                           i_timezone  => NULL),
                                                                 i_id_prof_last_change    => json_ext.get_number(l_jsn_indicator,
                                                                                                                 'LAST_EVALUATION.PROF_INFO.ID_PROFESSIONAL'),
                                                                 i_has_historical_changes => json_ext.get_string(l_jsn_indicator,
                                                                                                                 'LAST_EVALUATION.HAS_HISTORICAL_CHANGES'));
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                END IF;
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
                -- History of changes: Displays only editions on Careplan's NOC Indicators (nnn_epis_indicator)
                get_epis_noc_indicator_h(i_lang               => i_lang,
                                         i_prof               => i_prof,
                                         i_nnn_epis_indicator => i_nnn_epis_indicator,
                                         o_hist               => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_coll_nnn_epis_indicator_h, l_coll_obj_nnn_epis_indicator;
                CLOSE l_cursor;
            
                FOR i IN 1 .. l_coll_nnn_epis_indicator_h.count()
                LOOP
                
                    l_nnn_epis_indicator_h   := l_coll_nnn_epis_indicator_h(i);
                    l_obj_nnn_epis_indicator := l_coll_obj_nnn_epis_indicator(i);
                    l_obj_noc_indicator      := pk_noc_model.get_noc_indicator(i_lang          => i_lang,
                                                                               i_noc_outcome   => NULL,
                                                                               i_noc_indicator => l_obj_nnn_epis_indicator.id_noc_indicator);
                    IF l_coll_obj_nnn_epis_indicator.exists(i + 1)
                    THEN
                        l_has_previous                := TRUE;
                        l_prev_obj_nnn_epis_indicator := l_coll_obj_nnn_epis_indicator(i + 1);
                        l_prev_obj_noc_indicator      := pk_noc_model.get_noc_indicator(i_lang          => i_lang,
                                                                                        i_noc_outcome   => NULL,
                                                                                        i_noc_indicator => l_prev_obj_nnn_epis_indicator.id_noc_indicator);
                        l_flg_call                    := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous                := FALSE;
                        l_prev_obj_nnn_epis_indicator := NULL;
                        l_prev_obj_noc_indicator      := NULL;
                        l_flg_call                    := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_indicator_h, -1),
                                          i_dt_hist        => l_obj_nnn_epis_indicator.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_nnn_epis_indicator.status.flg_status,
                                          i_desc_rec_state => l_obj_nnn_epis_indicator.status.desc_flg_status,
                                          i_professional   => l_obj_nnn_epis_indicator.prof_info.id_professional,
                                          i_episode        => l_obj_nnn_epis_indicator.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_nnn_epis_indicator.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_nnn_epis_indicator IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    
                    END IF;
                
                    -- Subtitle: General information
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NocIndicator.name      
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value     => l_obj_noc_indicator.description,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_noc_indicator.description
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- flgPriority
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T002'),
                                                                              ':'), --'Priority'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_priority,
                                                                                              i_val      => l_obj_nnn_epis_indicator.flg_priority,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_priority,
                                                                                                   i_val      => l_prev_obj_nnn_epis_indicator.flg_priority,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- flgTime
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T003'),
                                                                              ':'), --'To be performed'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_time,
                                                                                              i_val      => l_obj_nnn_epis_indicator.flg_time,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_time,
                                                                                                   i_val      => l_prev_obj_nnn_epis_indicator.flg_time,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- flgPRN
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T004'),
                                                                              ':'), --'PRN'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_prn,
                                                                                              i_val      => l_obj_nnn_epis_indicator.flg_prn,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_prn,
                                                                                                   i_val      => l_prev_obj_nnn_epis_indicator.flg_prn,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- notesPRN
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T005'),
                                                                              ':'), --'PRN Condition'
                                                       i_value     => l_obj_nnn_epis_indicator.notes_prn,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_indicator.notes_prn
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --frequency
                    l_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                     i_prof                 => i_prof,
                                                                     i_id_order_recurr_plan => l_obj_nnn_epis_indicator.id_order_recurr_plan,
                                                                     i_order_recurr_option  => NULL);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                             i_prof                 => i_prof,
                                                                             i_id_order_recurr_plan => l_prev_obj_nnn_epis_indicator.id_order_recurr_plan,
                                                                             i_order_recurr_option  => NULL);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T006'),
                                                                              ':'), --'Frequency'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --startDate
                    l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                      i_prof              => i_prof,
                                                                      i_order_recurr_plan => l_obj_nnn_epis_indicator.id_order_recurr_plan);
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                              i_prof              => i_prof,
                                                                              i_order_recurr_plan => l_prev_obj_nnn_epis_indicator.id_order_recurr_plan);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(4) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T007'),
                                                                              ':'), --'Start Date'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Status of the entry:
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_obj_nnn_epis_indicator.status.desc_flg_status,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nnn_epis_indicator.status.desc_flg_status
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_obj_nnn_epis_indicator.cancel_info.cancel_reason_desc,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_indicator.cancel_info.cancel_reason_desc
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_obj_nnn_epis_indicator.cancel_info.cancel_notes,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_indicator.cancel_info.cancel_notes
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Signature 
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_nnn_epis_indicator.context_record.id_episode,
                                                                 i_date                => l_obj_nnn_epis_indicator.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_nnn_epis_indicator.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
        */
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    END get_epis_noc_indicator_det;

    FUNCTION get_epis_noc_indicator_eval
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_outcome  IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_ind_eval IN nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE
    ) RETURN t_obj_nnn_epis_ind_eval IS
    
        l_noc_scale noc_scale.id_noc_scale%TYPE;
        l_obj       t_obj_nnn_epis_ind_eval;
    BEGIN
    
        SELECT get_indicator_scale(i_nnn_epis_outcome   => i_nnn_epis_outcome,
                                   i_nnn_epis_indicator => neie.id_nnn_epis_indicator)
          INTO l_noc_scale
          FROM nnn_epis_ind_eval neie
         WHERE neie.id_nnn_epis_ind_eval = i_nnn_epis_ind_eval;
    
        --Get information of NOC outcome evaluation
        SELECT t_obj_nnn_epis_ind_eval(i_id_nnn_epis_ind_eval  => neie.id_nnn_epis_ind_eval,
                                       i_id_nnn_epis_indicator => neie.id_nnn_epis_indicator,
                                       i_context_record        => t_obj_context_record(i_id_episode => neie.id_episode),
                                       i_prof_info             => t_obj_prof_info(i_id_professional => neie.id_professional,
                                                                                  i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                        i_prof    => i_prof,
                                                                                                                                        i_prof_id => neie.id_professional),
                                                                                  i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                        i_prof    => i_prof,
                                                                                                                                        i_prof_id => neie.id_professional,
                                                                                                                                        i_dt_reg  => neie.dt_trs_time_start,
                                                                                                                                        i_episode => neie.id_episode)),
                                       i_target_value          => t_obj_likert_scale_level(i_scale_level_value      => neie.target_value,
                                                                                           i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                         l_noc_scale,
                                                                                                                                                         neie.target_value)),
                                       i_indicator_value       => t_obj_likert_scale_level(i_scale_level_value      => neie.indicator_value,
                                                                                           i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                         l_noc_scale,
                                                                                                                                                         neie.indicator_value)),
                                       
                                       i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                     i_prof             => i_prof,
                                                                                     i_id_cancel_reason => neie.id_cancel_reason,
                                                                                     i_cancel_notes     => neie.cancel_notes),
                                       i_status                 => t_obj_status(i_flg_status      => neie.flg_status,
                                                                                i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                             neie.flg_status,
                                                                                                                             i_lang),
                                                                                i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                          i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                          i_val      => neie.flg_status)),
                                       i_dt_evaluation          => neie.dt_evaluation,
                                       i_dt_plan                => neie.dt_plan,
                                       i_notes                  => pk_translation.get_translation_trs(neie.code_notes),
                                       i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neie.dt_trs_time_start,
                                                                                         i_trs_time_end   => neie.dt_trs_time_end),
                                       i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                         FROM dual
                                                                        WHERE EXISTS
                                                                        (SELECT 1
                                                                                 FROM nnn_epis_ind_eval_h hst
                                                                                WHERE hst.id_nnn_epis_ind_eval =
                                                                                      neie.id_nnn_epis_ind_eval)),
                                                                       pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_ind_eval neie
         INNER JOIN nnn_epis_indicator nei
            ON nei.id_nnn_epis_indicator = neie.id_nnn_epis_indicator
         WHERE neie.id_nnn_epis_ind_eval = i_nnn_epis_ind_eval;
    
        RETURN l_obj;
    END get_epis_noc_indicator_eval;

    PROCEDURE get_epis_noc_indicator_eval_h
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_outcome  IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_ind_eval IN nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE,
        o_hist              OUT pk_types.cursor_type
    ) IS
        l_noc_scale noc_scale.id_noc_scale%TYPE;
    BEGIN
    
        SELECT get_indicator_scale(i_nnn_epis_outcome   => i_nnn_epis_outcome,
                                   i_nnn_epis_indicator => neie.id_nnn_epis_indicator)
          INTO l_noc_scale
          FROM nnn_epis_ind_eval neie
         WHERE neie.id_nnn_epis_ind_eval = i_nnn_epis_ind_eval;
    
        --Get information of NOC outcome evaluation
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_ind_eval_h, t.obj_nnn_epis_ind_eval
              FROM (SELECT NULL id_nnn_epis_ind_eval_h,
                           t_obj_nnn_epis_ind_eval(i_id_nnn_epis_ind_eval  => neie.id_nnn_epis_ind_eval,
                                                   i_id_nnn_epis_indicator => neie.id_nnn_epis_indicator,
                                                   i_context_record        => t_obj_context_record(i_id_episode => neie.id_episode),
                                                   i_prof_info             => t_obj_prof_info(i_id_professional => neie.id_professional,
                                                                                              i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                    i_prof    => i_prof,
                                                                                                                                                    i_prof_id => neie.id_professional),
                                                                                              i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                    i_prof    => i_prof,
                                                                                                                                                    i_prof_id => neie.id_professional,
                                                                                                                                                    i_dt_reg  => neie.dt_trs_time_start,
                                                                                                                                                    i_episode => neie.id_episode)),
                                                   i_target_value          => t_obj_likert_scale_level(i_scale_level_value      => neie.target_value,
                                                                                                       i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                     l_noc_scale,
                                                                                                                                                                     neie.target_value)),
                                                   i_indicator_value       => t_obj_likert_scale_level(i_scale_level_value      => neie.indicator_value,
                                                                                                       i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                     l_noc_scale,
                                                                                                                                                                     neie.indicator_value)),
                                                   
                                                   i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                 i_prof             => i_prof,
                                                                                                 i_id_cancel_reason => neie.id_cancel_reason,
                                                                                                 i_cancel_notes     => neie.cancel_notes),
                                                   i_status                 => t_obj_status(i_flg_status      => neie.flg_status,
                                                                                            i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                         neie.flg_status,
                                                                                                                                         i_lang),
                                                                                            i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                      i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                      i_val      => neie.flg_status)),
                                                   i_dt_evaluation          => neie.dt_evaluation,
                                                   i_dt_plan                => neie.dt_plan,
                                                   i_notes                  => pk_translation.get_translation_trs(neie.code_notes),
                                                   i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neie.dt_trs_time_start,
                                                                                                     i_trs_time_end   => neie.dt_trs_time_end),
                                                   i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                     FROM dual
                                                                                    WHERE EXISTS
                                                                                    (SELECT 1
                                                                                             FROM nnn_epis_ind_eval_h hst
                                                                                            WHERE hst.id_nnn_epis_ind_eval =
                                                                                                  neie.id_nnn_epis_ind_eval)),
                                                                                   pk_alert_constant.g_no)) obj_nnn_epis_ind_eval,
                           neie.dt_trs_time_start,
                           neie.dt_trs_time_end
                      FROM nnn_epis_ind_eval neie
                     INNER JOIN nnn_epis_indicator nei
                        ON nei.id_nnn_epis_indicator = neie.id_nnn_epis_indicator
                     WHERE neie.id_nnn_epis_ind_eval = i_nnn_epis_ind_eval
                    UNION ALL
                    SELECT neieh.id_nnn_epis_ind_eval_h,
                           t_obj_nnn_epis_ind_eval(i_id_nnn_epis_ind_eval  => neieh.id_nnn_epis_ind_eval,
                                                   i_id_nnn_epis_indicator => neieh.id_nnn_epis_indicator,
                                                   i_context_record        => t_obj_context_record(i_id_episode => neieh.id_episode),
                                                   i_prof_info             => t_obj_prof_info(i_id_professional => neieh.id_professional,
                                                                                              i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                    i_prof    => i_prof,
                                                                                                                                                    i_prof_id => neieh.id_professional),
                                                                                              i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                    i_prof    => i_prof,
                                                                                                                                                    i_prof_id => neieh.id_professional,
                                                                                                                                                    i_dt_reg  => neieh.dt_trs_time_start,
                                                                                                                                                    i_episode => neieh.id_episode)),
                                                   i_target_value          => t_obj_likert_scale_level(i_scale_level_value      => neieh.target_value,
                                                                                                       i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                     l_noc_scale,
                                                                                                                                                                     neieh.target_value)),
                                                   i_indicator_value       => t_obj_likert_scale_level(i_scale_level_value      => neieh.indicator_value,
                                                                                                       i_desc_scale_level_value => pk_noc_model.get_scale_level_name(i_lang,
                                                                                                                                                                     l_noc_scale,
                                                                                                                                                                     neieh.indicator_value)),
                                                   
                                                   i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                 i_prof             => i_prof,
                                                                                                 i_id_cancel_reason => neieh.id_cancel_reason,
                                                                                                 i_cancel_notes     => neieh.cancel_notes),
                                                   i_status                 => t_obj_status(i_flg_status      => neieh.flg_status,
                                                                                            i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                         neieh.flg_status,
                                                                                                                                         i_lang),
                                                                                            i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                      i_code_dom => pk_nnn_constant.g_dom_epis_out_evl_flg_status,
                                                                                                                                      i_val      => neieh.flg_status)),
                                                   i_dt_evaluation          => neieh.dt_evaluation,
                                                   i_dt_plan                => neieh.dt_plan,
                                                   i_notes                  => neieh.notes,
                                                   i_bitemporal_data        => t_obj_bitemporal_data(i_trs_time_start => neieh.dt_trs_time_start,
                                                                                                     i_trs_time_end   => neieh.dt_trs_time_end),
                                                   i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                     FROM dual
                                                                                    WHERE EXISTS
                                                                                    (SELECT 1
                                                                                             FROM nnn_epis_ind_eval_h hst
                                                                                            WHERE hst.id_nnn_epis_ind_eval =
                                                                                                  neieh.id_nnn_epis_ind_eval)),
                                                                                   pk_alert_constant.g_no)) obj_nnn_epis_ind_eval,
                           neieh.dt_trs_time_start,
                           neieh.dt_trs_time_end
                      FROM nnn_epis_ind_eval_h neieh
                     INNER JOIN nnn_epis_indicator nei
                        ON nei.id_nnn_epis_indicator = neieh.id_nnn_epis_indicator
                     WHERE neieh.id_nnn_epis_ind_eval = i_nnn_epis_ind_eval) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_noc_indicator_eval_h;

    PROCEDURE get_epis_noc_indicator_evl_det
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_outcome  IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_nnn_epis_ind_eval IN nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE,
        i_flg_detail_type   IN VARCHAR2,
        o_detail            OUT pk_types.cursor_type
    ) IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_noc_indicator_evl_det';
        TYPE lt_lst_obj_nnn_epis_ind_eval IS TABLE OF t_obj_nnn_epis_ind_eval;
        l_label_edition  sys_message.desc_message%TYPE;
        l_label_creation sys_message.desc_message%TYPE;
        l_label_cancel   sys_message.desc_message%TYPE;
        l_flg_call       VARCHAR2(1 CHAR);
        l_cursor         pk_types.cursor_type;
    
        l_obj_noc_indicator t_obj_noc_indicator;
    
        l_obj_epis_indicator     t_obj_nnn_epis_indicator;
        l_obj_epis_outcome       t_obj_nnn_epis_outcome;
        l_obj_epis_ind_eval      t_obj_nnn_epis_ind_eval;
        l_prev_obj_epis_ind_eval t_obj_nnn_epis_ind_eval;
        l_lst_obj_epis_ind_eval  lt_lst_obj_nnn_epis_ind_eval;
    
        l_lst_nnn_epis_indicator_evl_h table_number;
    
        l_nnn_epis_ind_eval_h nnn_epis_ind_eval_h.id_nnn_epis_ind_eval_h%TYPE;
    
        l_value_string     pk_types.t_huge_byte;
        l_old_value_string pk_types.t_huge_byte;
        l_has_previous     BOOLEAN;
    BEGIN
        --Initialization of detail table
        pk_edis_hist.init_vars;
    
        CASE i_flg_detail_type
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details:
                l_obj_epis_ind_eval := pk_nnn_api_db.get_epis_noc_indicator_eval(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_nnn_epis_outcome  => i_nnn_epis_outcome,
                                                                                 i_nnn_epis_ind_eval => i_nnn_epis_ind_eval);
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history        => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist        => l_obj_epis_ind_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                      i_record_state   => l_obj_epis_ind_eval.status.flg_status,
                                      i_desc_rec_state => l_obj_epis_ind_eval.status.desc_flg_status,
                                      i_professional   => l_obj_epis_ind_eval.prof_info.id_professional,
                                      i_episode        => l_obj_epis_ind_eval.context_record.id_episode);
            
                g_error := 'Get the careplan''s NOC Indicator id_nnn_epis_indicator = ' ||
                           to_char(l_obj_epis_ind_eval.id_nnn_epis_indicator);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_epis_indicator := pk_nnn_api_db.get_epis_noc_indicator(i_lang               => i_lang,
                                                                             i_prof               => i_prof,
                                                                             i_nnn_epis_indicator => l_obj_epis_ind_eval.id_nnn_epis_indicator);
            
                g_error := 'Get the careplan''s NOC Outcome i_nnn_epis_outcome = ' || to_char(i_nnn_epis_outcome);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_nnn_epis_outcome => i_nnn_epis_outcome);
            
                g_error := 'Get info about this Indicator from the NOC Classification';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_obj_noc_indicator := pk_noc_model.get_noc_indicator(i_lang          => i_lang,
                                                                      i_noc_outcome   => l_obj_epis_outcome.id_noc_outcome,
                                                                      i_noc_indicator => l_obj_epis_indicator.id_noc_indicator);
            
                -- Title: NocIndicatorDescription
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => pk_noc_model.format_indicator_name(i_label                  => l_obj_noc_indicator.description,
                                                                                     i_outcome_indicator_code => l_obj_noc_indicator.outcome_indicator_code,
                                                                                     i_code_format            => pk_noc_model.g_code_format_start),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: Evaluation information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M005'), --'Evaluation information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- NocIndicatorEval.Evaluation.targetValue.scaleLevelValue - NocIndicatorEval.Evaluation.targetValue.descScaleLevelValue
                l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_ind_eval.target_value.scale_level_value,
                                                                   i_str2 => l_obj_epis_ind_eval.target_value.desc_scale_level_value,
                                                                   i_sep  => ' - ');
            
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M014'), --'Expected outcome'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocIndicatorEval.indicatorValue.scaleLevelValue - NocIndicatorEval.indicatorValue.descScaleLevelValue
                l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_ind_eval.indicator_value.scale_level_value,
                                                                   i_str2 => l_obj_epis_ind_eval.indicator_value.desc_scale_level_value,
                                                                   i_sep  => ' - ');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M015'), --'Current evaluation'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocIndicatorEval.dtEvaluation
                l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                              l_obj_epis_ind_eval.dt_evaluation,
                                                              i_prof.institution,
                                                              i_prof.software);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M007'), --'Evaluation date',
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --  NocIndicatorEval.notes                                                       
                l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_ind_eval.notes);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M011'), --'Notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- NocIndicatorEval.descStatus
                l_value_string := l_obj_epis_ind_eval.status.desc_flg_status;
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := l_obj_epis_ind_eval.cancel_info.cancel_reason_desc;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelNotes
                l_value_string := l_obj_epis_ind_eval.cancel_info.cancel_notes;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => l_obj_epis_ind_eval.context_record.id_episode,
                                                             i_date                   => l_obj_epis_ind_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                             i_id_prof_last_change    => l_obj_epis_ind_eval.prof_info.id_professional,
                                                             i_has_historical_changes => l_obj_epis_ind_eval.has_historical_changes);
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                -- History of changes: Displays only editions in the evaluation of a Careplan's NOC Outcome (nnn_epis_outcome_eval)
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
            
                --Get history of changes in nnn_epis_ind_eval
                get_epis_noc_indicator_eval_h(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_nnn_epis_outcome  => i_nnn_epis_outcome,
                                              i_nnn_epis_ind_eval => i_nnn_epis_ind_eval,
                                              o_hist              => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_lst_nnn_epis_indicator_evl_h, l_lst_obj_epis_ind_eval;
                CLOSE l_cursor;
            
                l_obj_noc_indicator := NULL;
                FOR i IN 1 .. l_lst_nnn_epis_indicator_evl_h.count()
                LOOP
                    l_nnn_epis_ind_eval_h := l_lst_nnn_epis_indicator_evl_h(i);
                    l_obj_epis_ind_eval   := l_lst_obj_epis_ind_eval(i);
                    IF l_obj_noc_indicator IS NULL
                    THEN
                        -- The requested indicator doesn't change with the editions of the evaluation, so these objects are retrieved just once.
                        g_error := 'Get the careplan''s NOC Indicator id_nnn_epis_indicator = ' ||
                                   to_char(l_obj_epis_ind_eval.id_nnn_epis_indicator);
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package,
                                             sub_object_name => k_function_name);
                        l_obj_epis_indicator := pk_nnn_api_db.get_epis_noc_indicator(i_lang               => i_lang,
                                                                                     i_prof               => i_prof,
                                                                                     i_nnn_epis_indicator => l_obj_epis_ind_eval.id_nnn_epis_indicator);
                    
                        g_error := 'Get the careplan''s NOC Outcome i_nnn_epis_outcome = ' ||
                                   to_char(i_nnn_epis_outcome);
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package,
                                             sub_object_name => k_function_name);
                        l_obj_epis_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                                 i_prof             => i_prof,
                                                                                 i_nnn_epis_outcome => i_nnn_epis_outcome);
                    
                        g_error := 'Get info about this Indicator from the NOC Classification';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => k_function_name);
                        l_obj_noc_indicator := pk_noc_model.get_noc_indicator(i_lang          => i_lang,
                                                                              i_noc_outcome   => l_obj_epis_outcome.id_noc_outcome,
                                                                              i_noc_indicator => l_obj_epis_indicator.id_noc_indicator);
                    END IF;
                
                    IF l_lst_obj_epis_ind_eval.exists(i + 1)
                    THEN
                        l_has_previous           := TRUE;
                        l_prev_obj_epis_ind_eval := l_lst_obj_epis_ind_eval(i + 1);
                        l_flg_call               := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous           := FALSE;
                        l_prev_obj_epis_ind_eval := NULL;
                        l_flg_call               := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_ind_eval_h, -1),
                                          i_dt_hist        => l_obj_epis_ind_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_epis_ind_eval.status.flg_status,
                                          i_desc_rec_state => l_obj_epis_ind_eval.status.desc_flg_status,
                                          i_professional   => l_obj_epis_ind_eval.prof_info.id_professional,
                                          i_episode        => l_obj_epis_ind_eval.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_epis_ind_eval.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_epis_ind_eval IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    END IF;
                
                    -- NocIndicatorDescription
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_noc_model.format_indicator_name(i_label                  => l_obj_noc_indicator.description,
                                                                                            i_outcome_indicator_code => l_obj_noc_indicator.outcome_indicator_code,
                                                                                            i_code_format            => pk_noc_model.g_code_format_start), --pk_string_utils.get_tab(2) || pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value    => NULL, --l_obj_noc_outcome.name,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NocIndicatorEval.Evaluation.targetValue.scaleLevelValue - NocIndicatorEval.Evaluation.targetValue.descScaleLevelValue
                    l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_ind_eval.target_value.scale_level_value,
                                                                       i_str2 => l_obj_epis_ind_eval.target_value.desc_scale_level_value,
                                                                       i_sep  => ' - ');
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.concat_if_exists(i_str1 => l_prev_obj_epis_ind_eval.target_value.scale_level_value,
                                                                               i_str2 => l_prev_obj_epis_ind_eval.target_value.desc_scale_level_value,
                                                                               i_sep  => ' - ');
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M014'), --'Expected outcome'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocIndicatorEval.indicatorValue.scaleLevelValue - NocIndicatorEval.indicatorValue.descScaleLevelValue
                    l_value_string := pk_string_utils.concat_if_exists(i_str1 => l_obj_epis_ind_eval.indicator_value.scale_level_value,
                                                                       i_str2 => l_obj_epis_ind_eval.indicator_value.desc_scale_level_value,
                                                                       i_sep  => ' - ');
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.concat_if_exists(i_str1 => l_prev_obj_epis_ind_eval.indicator_value.scale_level_value,
                                                                               i_str2 => l_prev_obj_epis_ind_eval.indicator_value.desc_scale_level_value,
                                                                               i_sep  => ' - ');
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M015'), --'Current evaluation'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocIndicatorEval.dtEvaluation
                    l_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                  l_obj_epis_ind_eval.dt_evaluation,
                                                                  i_prof.institution,
                                                                  i_prof.software);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_date_utils.date_char_tsz(i_lang,
                                                                          l_prev_obj_epis_ind_eval.dt_evaluation,
                                                                          i_prof.institution,
                                                                          i_prof.software);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M007'), --'Evaluation date',
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --  NocIndicatorEval.notes                                                       
                    l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_ind_eval.notes);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_prev_obj_epis_ind_eval.notes);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M011'), --'Notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- NocIndicatorEval.descStatus
                    l_value_string := l_obj_epis_ind_eval.status.desc_flg_status;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_ind_eval.status.desc_flg_status;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_value_string,
                                           i_old_value => l_old_value_string,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := l_obj_epis_ind_eval.cancel_info.cancel_reason_desc;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_ind_eval.cancel_info.cancel_reason_desc;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    l_value_string := l_obj_epis_ind_eval.cancel_info.cancel_notes;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_ind_eval.cancel_info.cancel_notes;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Signature
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_epis_ind_eval.context_record.id_episode,
                                                                 i_date                => l_obj_epis_ind_eval.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_epis_ind_eval.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
    
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    
    END get_epis_noc_indicator_evl_det;
    FUNCTION get_epis_nic_intervention
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_intervention IN nnn_epis_intervention.id_nnn_epis_intervention%TYPE
    ) RETURN t_obj_nnn_epis_intervention IS
        l_obj t_obj_nnn_epis_intervention;
    BEGIN
    
        SELECT t_obj_nnn_epis_intervention(i_id_nnn_epis_intervention => nei.id_nnn_epis_intervention,
                                           i_id_nic_intervention      => nei.id_nic_intervention,
                                           i_context_record           => t_obj_context_record(i_id_episode => nei.id_episode),
                                           i_prof_info                => t_obj_prof_info(i_id_professional => nei.id_professional,
                                                                                         i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => nei.id_professional),
                                                                                         i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => nei.id_professional,
                                                                                                                                               i_dt_reg  => nei.dt_trs_time_start,
                                                                                                                                               i_episode => nei.id_episode)),
                                           i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                           i_prof             => i_prof,
                                                                                           i_id_cancel_reason => nei.id_cancel_reason,
                                                                                           i_cancel_notes     => nei.cancel_notes),
                                           i_status                   => t_obj_status(i_flg_status      => nei.flg_req_status,
                                                                                      i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_int_flg_req_status,
                                                                                                                                   nei.flg_req_status,
                                                                                                                                   i_lang)),
                                           i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => nei.dt_val_time_start,
                                                                                               i_val_time_end   => nei.dt_val_time_end,
                                                                                               i_trs_time_start => nei.dt_trs_time_start,
                                                                                               i_trs_time_end   => nei.dt_trs_time_end),
                                           i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                               FROM dual
                                                                              WHERE EXISTS
                                                                              (SELECT 1
                                                                                       FROM nnn_epis_intervention_h hst
                                                                                      WHERE hst.id_nnn_epis_intervention =
                                                                                            nei.id_nnn_epis_intervention)),
                                                                             pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_intervention nei
         WHERE nei.id_nnn_epis_intervention = i_nnn_epis_intervention;
    
        RETURN l_obj;
    
    END get_epis_nic_intervention;

    PROCEDURE get_epis_nic_intervention_h
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_intervention IN nnn_epis_intervention.id_nnn_epis_intervention%TYPE,
        o_hist                  OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_intervention_h, t.obj_nnn_epis_intervention
              FROM (SELECT NULL id_nnn_epis_intervention_h,
                           t_obj_nnn_epis_intervention(i_id_nnn_epis_intervention => nei.id_nnn_epis_intervention,
                                                       i_id_nic_intervention      => nei.id_nic_intervention,
                                                       i_context_record           => t_obj_context_record(i_id_episode => nei.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => nei.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nei.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nei.id_professional,
                                                                                                                                                           i_dt_reg  => nei.dt_trs_time_start,
                                                                                                                                                           i_episode => nei.id_episode)),
                                                       i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                       i_prof             => i_prof,
                                                                                                       i_id_cancel_reason => nei.id_cancel_reason,
                                                                                                       i_cancel_notes     => nei.cancel_notes),
                                                       i_status                   => t_obj_status(i_flg_status      => nei.flg_req_status,
                                                                                                  i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_int_flg_req_status,
                                                                                                                                               nei.flg_req_status,
                                                                                                                                               i_lang)),
                                                       i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => nei.dt_val_time_start,
                                                                                                           i_val_time_end   => nei.dt_val_time_end,
                                                                                                           i_trs_time_start => nei.dt_trs_time_start,
                                                                                                           i_trs_time_end   => nei.dt_trs_time_end),
                                                       i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                                           FROM dual
                                                                                          WHERE EXISTS
                                                                                          (SELECT 1
                                                                                                   FROM nnn_epis_intervention_h hst
                                                                                                  WHERE hst.id_nnn_epis_intervention =
                                                                                                        nei.id_nnn_epis_intervention)),
                                                                                         pk_alert_constant.g_no)) obj_nnn_epis_intervention,
                           nei.dt_trs_time_start,
                           nei.dt_trs_time_end
                    
                      FROM nnn_epis_intervention nei
                     WHERE nei.id_nnn_epis_intervention = i_nnn_epis_intervention
                    UNION ALL
                    SELECT neih.id_nnn_epis_intervention_h,
                           t_obj_nnn_epis_intervention(i_id_nnn_epis_intervention => neih.id_nnn_epis_intervention,
                                                       i_id_nic_intervention      => neih.id_nic_intervention,
                                                       i_context_record           => t_obj_context_record(i_id_episode => neih.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => neih.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neih.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neih.id_professional,
                                                                                                                                                           i_dt_reg  => neih.dt_trs_time_start,
                                                                                                                                                           i_episode => neih.id_episode)),
                                                       i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                       i_prof             => i_prof,
                                                                                                       i_id_cancel_reason => neih.id_cancel_reason,
                                                                                                       i_cancel_notes     => neih.cancel_notes),
                                                       i_status                   => t_obj_status(i_flg_status      => neih.flg_req_status,
                                                                                                  i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_int_flg_req_status,
                                                                                                                                               neih.flg_req_status,
                                                                                                                                               i_lang)),
                                                       i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => neih.dt_val_time_start,
                                                                                                           i_val_time_end   => neih.dt_val_time_end,
                                                                                                           i_trs_time_start => neih.dt_trs_time_start,
                                                                                                           i_trs_time_end   => neih.dt_trs_time_end),
                                                       i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                                           FROM dual
                                                                                          WHERE EXISTS
                                                                                          (SELECT 1
                                                                                                   FROM nnn_epis_intervention_h hst
                                                                                                  WHERE hst.id_nnn_epis_intervention =
                                                                                                        neih.id_nnn_epis_intervention)),
                                                                                         pk_alert_constant.g_no)) obj_nnn_epis_intervention,
                           neih.dt_trs_time_start,
                           neih.dt_trs_time_end
                      FROM nnn_epis_intervention_h neih
                     WHERE neih.id_nnn_epis_intervention = i_nnn_epis_intervention) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    END get_epis_nic_intervention_h;

    PROCEDURE get_epis_nic_intervention_det
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_intervention IN nnn_epis_intervention.id_nnn_epis_intervention%TYPE,
        i_flg_detail_type       IN VARCHAR2,
        o_detail                OUT pk_types.cursor_type
    ) IS
        TYPE lt_coll_obj_nnn_epis_interv IS TABLE OF t_obj_nnn_epis_intervention;
        l_jsn_intervention         json_object_t;
        l_jsn_nic_class            json_object_t;
        l_lst_jsn_nic_class        json_array_t;
        l_lst_jsn_activities       json_array_t;
        l_jsn_actitivy             json_object_t;
        l_coll_obj_nnn_epis_interv lt_coll_obj_nnn_epis_interv;
        l_coll_obj_nic_class       t_coll_obj_nic_class;
        l_obj_nic_class            t_obj_nic_class;
        l_coll_nnn_epis_interv_h   table_number;
        l_obj_nnn_epis_interv      t_obj_nnn_epis_intervention;
        l_prev_obj_nnn_epis_interv t_obj_nnn_epis_intervention;
        l_obj_nic_interv           t_obj_nic_intervention;
        l_prev_obj_nic_interv      t_obj_nic_intervention;
        l_label_edition            sys_message.desc_message%TYPE;
        l_label_creation           sys_message.desc_message%TYPE;
        l_label_cancel             sys_message.desc_message%TYPE;
        l_req_status               nnn_epis_intervention.flg_req_status%TYPE;
        l_nnn_epis_interv_h        nnn_epis_intervention_h.id_nnn_epis_intervention_h%TYPE;
        l_cursor                   pk_types.cursor_type;
        l_flg_call                 VARCHAR2(1 CHAR);
        l_value_string             pk_types.t_huge_byte;
        l_has_previous             BOOLEAN;
    BEGIN
        /*--Initialization of detail table
        pk_edis_hist.init_vars;
        
        CASE i_flg_detail_type
        
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details 
                l_jsn_intervention := get_epis_interv_hier_detail(i_lang                  => i_lang,
                                                                  i_prof                  => i_prof,
                                                                  i_nnn_epis_intervention => i_nnn_epis_intervention);
            
                -- Request's status
                l_req_status := json_ext.get_string(l_jsn_intervention, 'STATUS.FLG_STATUS');
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                 i_prof      => i_prof,
                                                                                 i_timestamp => json_ext.get_string(l_jsn_intervention,
                                                                                                                    'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                 i_timezone  => NULL),
                                      
                                      i_record_state   => json_ext.get_string(l_jsn_intervention, 'STATUS.FLG_STATUS'),
                                      i_desc_rec_state => json_ext.get_string(l_jsn_intervention,
                                                                              'STATUS.DESC_FLG_STATUS'),
                                      i_professional   => json_ext.get_number(l_jsn_intervention,
                                                                              'PROF_INFO.ID_PROFESSIONAL'),
                                      i_episode        => json_ext.get_number(l_jsn_intervention,
                                                                              'CONTEXT_RECORD.ID_EPISODE'));
            
                -- Title: NicIntervention.name (NicIntervention.NicCode)
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => pk_nic_model.format_nic_name(i_label       => json_ext.get_string(l_jsn_intervention,
                                                                                                                    'NIC_INTERVENTION.NAME'),
                                                                               i_nic_code    => json_ext.get_number(l_jsn_intervention,
                                                                                                                    'NIC_INTERVENTION.NIC_CODE'),
                                                                               i_code_format => pk_nic_model.g_code_format_end),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: General information
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- NicIntervention.name
                l_value_string := json_ext.get_string(l_jsn_intervention, 'NIC_INTERVENTION.NAME');
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                l_value_string := json_ext.get_string(l_jsn_intervention, 'NIC_INTERVENTION.DEFINITION');
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M027'), --'NIC Definition'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- NicIntervention.lstClass (one NIC intervention can belong to more than one NIC class)
                l_lst_jsn_nic_class := json_ext.get_json_list(l_jsn_intervention, 'NIC_INTERVENTION.LST_CLASS');
                FOR x IN 1 .. l_lst_jsn_nic_class.count()
                LOOP
                    l_jsn_nic_class := json(l_lst_jsn_nic_class.get(x));
                    -- NICClass.domainName (NICClass.domainCode)
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M028'), --'NIC Domain'
                                           i_value    => json_ext.get_string(l_jsn_nic_class, 'DOMAIN.NAME') || ' (' ||
                                                         json_ext.get_string(l_jsn_nic_class, 'DOMAIN.DOMAIN_CODE') || ')',
                                           i_type     => pk_edis_hist.g_type_content);
                
                    -- NICClass.className (NICClass.classCode)
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_string_utils.get_tab(2) ||
                                                         pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M029'), --'NIC Class'
                                           i_value    => json_ext.get_string(l_jsn_nic_class, 'NAME') || ' (' ||
                                                         json_ext.get_string(l_jsn_nic_class, 'CLASS_CODE') || ')',
                                           i_type     => pk_edis_hist.g_type_content);
                END LOOP;
            
                -- NicIntervention.descFlgStatus
                l_value_string := json_ext.get_string(l_jsn_intervention, 'STATUS.DESC_FLG_STATUS');
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_string_utils.get_tab(2) ||
                                                     pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := json_ext.get_string(l_jsn_intervention, 'CANCEL_INFO.CANCEL_REASON_DESC');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelNotes
                l_value_string := json_ext.get_string(l_jsn_intervention, 'CANCEL_INFO.CANCEL_NOTES');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => json_ext.get_number(l_jsn_intervention,
                                                                                                             'CONTEXT_RECORD.ID_EPISODE'),
                                                             i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                       i_prof      => i_prof,
                                                                                                                       i_timestamp => json_ext.get_string(l_jsn_intervention,
                                                                                                                                                          'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                       i_timezone  => NULL),
                                                             i_id_prof_last_change    => json_ext.get_number(l_jsn_intervention,
                                                                                                             'PROF_INFO.ID_PROFESSIONAL'),
                                                             i_has_historical_changes => json_ext.get_string(l_jsn_intervention,
                                                                                                             'HAS_HISTORICAL_CHANGES'));
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
                IF l_req_status NOT IN
                   (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                THEN
                
                    -- Collection of NIC Activities linked to the NIC Intervention
                    l_lst_jsn_activities := json_ext.get_json_list(l_jsn_intervention, 'ACTIVITIES');
                    IF l_lst_jsn_activities IS NOT NULL
                    THEN
                        IF l_lst_jsn_activities.count > 0
                        THEN
                            --Subtitle: Activities
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M031'), --'Activities'
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_subtitle);
                            FOR x IN 1 .. l_lst_jsn_activities.count()
                            LOOP
                                l_jsn_actitivy := json(l_lst_jsn_activities.get(x));
                            
                                -- NicActivity.description
                                l_value_string := json_ext.get_string(l_jsn_actitivy, 'NIC_ACTIVITY.DESCRIPTION');
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(4) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M019'), --'Activity'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- NicActivity.descInstructions
                                l_value_string := json_ext.get_string(l_jsn_actitivy, 'DESC_INSTRUCTIONS');
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(6) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_INSTRUCT_T001'), --'Instructions'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                                -- NicActivity.descFlgStatus
                                l_value_string := json_ext.get_string(l_jsn_actitivy, 'STATUS.DESC_FLG_STATUS');
                                pk_edis_hist.add_value(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_string_utils.get_tab(6) ||
                                                                     pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_DETAIL_M006'), --'Status'
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                            
                            END LOOP;
                        END IF;
                    END IF;
                END IF;
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
                -- History of changes: Displays only editions on Careplan's NOC Intervention (nnn_epis_intervention)
            
                --Get history of changes in nnn_epis_intervention
                get_epis_nic_intervention_h(i_lang                  => i_lang,
                                            i_prof                  => i_prof,
                                            i_nnn_epis_intervention => i_nnn_epis_intervention,
                                            o_hist                  => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_coll_nnn_epis_interv_h, l_coll_obj_nnn_epis_interv;
                CLOSE l_cursor;
            
                FOR i IN 1 .. l_coll_nnn_epis_interv_h.count()
                LOOP
                    l_nnn_epis_interv_h   := l_coll_nnn_epis_interv_h(i);
                    l_obj_nnn_epis_interv := l_coll_obj_nnn_epis_interv(i);
                    l_obj_nic_interv      := pk_nic_model.get_nic_intervention(i_lang             => i_lang,
                                                                               i_nic_intervention => l_obj_nnn_epis_interv.id_nic_intervention);
                    IF l_coll_obj_nnn_epis_interv.exists(i + 1)
                    THEN
                        l_has_previous             := TRUE;
                        l_prev_obj_nnn_epis_interv := l_coll_obj_nnn_epis_interv(i + 1);
                        l_prev_obj_nic_interv      := pk_nic_model.get_nic_intervention(i_lang             => i_lang,
                                                                                        i_nic_intervention => l_prev_obj_nnn_epis_interv.id_nic_intervention);
                        l_flg_call                 := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous             := FALSE;
                        l_prev_obj_nnn_epis_interv := NULL;
                        l_prev_obj_nic_interv      := NULL;
                        l_flg_call                 := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_interv_h, -1),
                                          i_dt_hist        => l_obj_nnn_epis_interv.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_nnn_epis_interv.status.flg_status,
                                          i_desc_rec_state => l_obj_nnn_epis_interv.status.desc_flg_status,
                                          i_professional   => l_obj_nnn_epis_interv.prof_info.id_professional,
                                          i_episode        => l_obj_nnn_epis_interv.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_nnn_epis_interv.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_nnn_epis_interv IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    
                    END IF;
                
                    -- Subtitle: General information
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NicIntervention.name      
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value     => l_obj_nic_interv.name,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nic_interv.name
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- NicIntervention.definition
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M027'), --'NIC Definition'
                                           i_value     => l_obj_nic_interv.definition,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nic_interv.definition
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- NicIntervention.lstClass (one NIC intervention can belong to more than one NIC class) 
                    l_coll_obj_nic_class := l_obj_nic_interv.lst_class;
                    FOR x IN 1 .. l_coll_obj_nic_class.count()
                    LOOP
                        l_obj_nic_class := l_coll_obj_nic_class(x);
                        -- NicIntervention.domainName (NicIntervention.domainCode)
                        l_value_string := l_obj_nic_class.domain.name || ' (' || l_obj_nic_class.domain.domain_code || ')';
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M028'), --'NIC Domain'
                                               i_value     => l_value_string,
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_value_string
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    
                        -- NicIntervention.className (NicIntervention.classCode)
                        l_value_string := l_obj_nic_class.name || ' (' || l_obj_nic_class.class_code || ')';
                        pk_edis_hist.add_value(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_string_utils.get_tab(2) ||
                                                              pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M029'), --'NIC Class'
                                               i_value     => l_value_string,
                                               i_old_value => CASE
                                                                  WHEN l_has_previous THEN
                                                                   l_value_string
                                                                  ELSE
                                                                   NULL
                                                              END,
                                               i_type      => pk_edis_hist.g_type_content);
                    END LOOP;
                    -- Status of the entry:
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_obj_nnn_epis_interv.status.desc_flg_status,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nnn_epis_interv.status.desc_flg_status
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_obj_nnn_epis_interv.cancel_info.cancel_reason_desc,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_interv.cancel_info.cancel_reason_desc
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_obj_nnn_epis_interv.cancel_info.cancel_notes,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_interv.cancel_info.cancel_notes
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Signature 
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_nnn_epis_interv.context_record.id_episode,
                                                                 i_date                => l_obj_nnn_epis_interv.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_nnn_epis_interv.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
        END CASE;
        */
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    END get_epis_nic_intervention_det;

    FUNCTION get_epis_nic_activity
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE
    ) RETURN t_obj_nnn_epis_activity IS
        l_obj t_obj_nnn_epis_activity;
    BEGIN
        SELECT t_obj_nnn_epis_activity(i_id_nnn_epis_activity   => nea.id_nnn_epis_activity,
                                       i_id_nic_activity        => nea.id_nic_activity,
                                       i_id_nic_othr_actv_vrsn  => nea.id_nic_othr_actv_vrsn,
                                       i_context_record         => t_obj_context_record(i_id_episode => nea.id_episode),
                                       i_prof_info              => t_obj_prof_info(i_id_professional => nea.id_professional,
                                                                                   i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => nea.id_professional),
                                                                                   i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                         i_prof    => i_prof,
                                                                                                                                         i_prof_id => nea.id_professional,
                                                                                                                                         i_dt_reg  => nea.dt_trs_time_start,
                                                                                                                                         i_episode => nea.id_episode)),
                                       i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                     i_prof             => i_prof,
                                                                                     i_id_cancel_reason => nea.id_cancel_reason,
                                                                                     i_cancel_notes     => nea.cancel_notes),
                                       i_status                 => t_obj_status(i_flg_status      => nea.flg_req_status,
                                                                                i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_flg_req_status,
                                                                                                                             nea.flg_req_status,
                                                                                                                             i_lang)),
                                       i_id_episode_origin      => nea.id_episode_origin,
                                       i_id_episode_destination => nea.id_episode_destination,
                                       i_flg_prn                => nea.flg_prn,
                                       i_notes_prn              => pk_translation.get_translation_trs(nea.code_notes_prn),
                                       i_flg_time               => nea.flg_time,
                                       i_flg_priority           => nea.flg_priority,
                                       i_id_order_recurr_plan   => nea.id_order_recurr_plan,
                                       i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                i_prof              => i_prof,
                                                                                                i_flg_priority      => nea.flg_priority,
                                                                                                i_flg_prn           => nea.flg_prn,
                                                                                                i_notes_prn         => pk_translation.get_translation_trs(nea.code_notes_prn),
                                                                                                i_flg_time          => nea.flg_time,
                                                                                                i_order_recurr_plan => nea.id_order_recurr_plan),
                                       i_flg_doc_type           => nea.flg_doc_type,
                                       i_doc_parameter          => nea.doc_parameter,
                                       i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => nea.dt_val_time_start,
                                                                                         i_val_time_end   => nea.dt_val_time_end,
                                                                                         i_trs_time_start => nea.dt_trs_time_start,
                                                                                         i_trs_time_end   => nea.dt_trs_time_end),
                                       i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                         FROM dual
                                                                        WHERE EXISTS
                                                                        (SELECT 1
                                                                                 FROM nnn_epis_activity_h hst
                                                                                WHERE hst.id_nnn_epis_activity =
                                                                                      nea.id_nnn_epis_activity)),
                                                                       pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_activity nea
         WHERE nea.id_nnn_epis_activity = i_nnn_epis_activity;
    
        RETURN l_obj;
    END get_epis_nic_activity;

    PROCEDURE get_epis_nic_activity_h
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        o_hist              OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_activity_h, t.obj_nnn_epis_activity
              FROM (SELECT NULL id_nnn_epis_activity_h,
                           t_obj_nnn_epis_activity(i_id_nnn_epis_activity   => nea.id_nnn_epis_activity,
                                                   i_id_nic_activity        => nea.id_nic_activity,
                                                   i_id_nic_othr_actv_vrsn  => nea.id_nic_othr_actv_vrsn,
                                                   i_context_record         => t_obj_context_record(i_id_episode => nea.id_episode),
                                                   i_prof_info              => t_obj_prof_info(i_id_professional => nea.id_professional,
                                                                                               i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => nea.id_professional),
                                                                                               i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => nea.id_professional,
                                                                                                                                                     i_dt_reg  => nea.dt_trs_time_start,
                                                                                                                                                     i_episode => nea.id_episode)),
                                                   i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                 i_prof             => i_prof,
                                                                                                 i_id_cancel_reason => nea.id_cancel_reason,
                                                                                                 i_cancel_notes     => nea.cancel_notes),
                                                   i_status                 => t_obj_status(i_flg_status      => nea.flg_req_status,
                                                                                            i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_flg_req_status,
                                                                                                                                         nea.flg_req_status,
                                                                                                                                         i_lang)),
                                                   i_id_episode_origin      => nea.id_episode_origin,
                                                   i_id_episode_destination => nea.id_episode_destination,
                                                   i_flg_prn                => nea.flg_prn,
                                                   i_notes_prn              => pk_translation.get_translation_trs(nea.code_notes_prn),
                                                   i_flg_time               => nea.flg_time,
                                                   i_flg_priority           => nea.flg_priority,
                                                   i_id_order_recurr_plan   => nea.id_order_recurr_plan,
                                                   i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                            i_prof              => i_prof,
                                                                                                            i_flg_priority      => nea.flg_priority,
                                                                                                            i_flg_prn           => nea.flg_prn,
                                                                                                            i_notes_prn         => pk_translation.get_translation_trs(nea.code_notes_prn),
                                                                                                            i_flg_time          => nea.flg_time,
                                                                                                            i_order_recurr_plan => nea.id_order_recurr_plan),
                                                   i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => nea.dt_val_time_start,
                                                                                                     i_val_time_end   => nea.dt_val_time_end,
                                                                                                     i_trs_time_start => nea.dt_trs_time_start,
                                                                                                     i_trs_time_end   => nea.dt_trs_time_end),
                                                   i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                     FROM dual
                                                                                    WHERE EXISTS
                                                                                    (SELECT 1
                                                                                             FROM nnn_epis_activity_h hst
                                                                                            WHERE hst.id_nnn_epis_activity =
                                                                                                  nea.id_nnn_epis_activity)),
                                                                                   pk_alert_constant.g_no)) obj_nnn_epis_activity,
                           nea.dt_trs_time_start,
                           nea.dt_trs_time_end
                    
                      FROM nnn_epis_activity nea
                     WHERE nea.id_nnn_epis_activity = i_nnn_epis_activity
                    UNION ALL
                    SELECT neah.id_nnn_epis_activity_h,
                           t_obj_nnn_epis_activity(i_id_nnn_epis_activity   => neah.id_nnn_epis_activity,
                                                   i_id_nic_activity        => neah.id_nic_activity,
                                                   i_id_nic_othr_actv_vrsn  => neah.id_nic_othr_actv_vrsn,
                                                   i_context_record         => t_obj_context_record(i_id_episode => neah.id_episode),
                                                   i_prof_info              => t_obj_prof_info(i_id_professional => neah.id_professional,
                                                                                               i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => neah.id_professional),
                                                                                               i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                     i_prof    => i_prof,
                                                                                                                                                     i_prof_id => neah.id_professional,
                                                                                                                                                     i_dt_reg  => neah.dt_trs_time_start,
                                                                                                                                                     i_episode => neah.id_episode)),
                                                   i_cancel_info            => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                 i_prof             => i_prof,
                                                                                                 i_id_cancel_reason => neah.id_cancel_reason,
                                                                                                 i_cancel_notes     => neah.cancel_notes),
                                                   i_status                 => t_obj_status(i_flg_status      => neah.flg_req_status,
                                                                                            i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_flg_req_status,
                                                                                                                                         neah.flg_req_status,
                                                                                                                                         i_lang)),
                                                   i_id_episode_origin      => neah.id_episode_origin,
                                                   i_id_episode_destination => neah.id_episode_destination,
                                                   i_flg_prn                => neah.flg_prn,
                                                   i_notes_prn              => neah.notes_prn,
                                                   i_flg_time               => neah.flg_time,
                                                   i_flg_priority           => neah.flg_priority,
                                                   i_id_order_recurr_plan   => neah.id_order_recurr_plan,
                                                   i_desc_instructions      => pk_nnn_core.get_instructions(i_lang              => i_lang,
                                                                                                            i_prof              => i_prof,
                                                                                                            i_flg_priority      => neah.flg_priority,
                                                                                                            i_flg_prn           => neah.flg_prn,
                                                                                                            i_notes_prn         => neah.notes_prn,
                                                                                                            i_flg_time          => neah.flg_time,
                                                                                                            i_order_recurr_plan => neah.id_order_recurr_plan),
                                                   i_bitemporal_data        => t_obj_bitemporal_data(i_val_time_start => neah.dt_val_time_start,
                                                                                                     i_val_time_end   => neah.dt_val_time_end,
                                                                                                     i_trs_time_start => neah.dt_trs_time_start,
                                                                                                     i_trs_time_end   => neah.dt_trs_time_end),
                                                   i_has_historical_changes => nvl((SELECT pk_alert_constant.g_yes
                                                                                     FROM dual
                                                                                    WHERE EXISTS
                                                                                    (SELECT 1
                                                                                             FROM nnn_epis_activity_h hst
                                                                                            WHERE hst.id_nnn_epis_activity =
                                                                                                  neah.id_nnn_epis_activity)),
                                                                                   pk_alert_constant.g_no)) obj_nnn_epis_activity,
                           neah.dt_trs_time_start,
                           neah.dt_trs_time_end
                      FROM nnn_epis_activity_h neah
                     WHERE neah.id_nnn_epis_activity = i_nnn_epis_activity) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    
    END get_epis_nic_activity_h;

    FUNCTION get_epis_nic_activity_det
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_activity_det IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE
    ) RETURN t_obj_nnn_epis_activity_det IS
        l_obj t_obj_nnn_epis_activity_det;
    BEGIN
    
        SELECT t_obj_nnn_epis_activity_det(i_id_nnn_epis_activity_det => nead.id_nnn_epis_activity_det,
                                           i_id_nnn_epis_activity     => nead.id_nnn_epis_activity,
                                           i_context_record           => t_obj_context_record(i_id_episode => nead.id_episode),
                                           i_prof_info                => t_obj_prof_info(i_id_professional => nead.id_professional,
                                                                                         i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => nead.id_professional),
                                                                                         i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                               i_prof    => i_prof,
                                                                                                                                               i_prof_id => nead.id_professional,
                                                                                                                                               i_dt_reg  => nead.dt_trs_time_start,
                                                                                                                                               i_episode => nead.id_episode)),
                                           i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                           i_prof             => i_prof,
                                                                                           i_id_cancel_reason => nead.id_cancel_reason,
                                                                                           i_cancel_notes     => nead.cancel_notes),
                                           i_status                   => t_obj_status(i_flg_status      => nead.flg_status,
                                                                                      i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                   nead.flg_status,
                                                                                                                                   i_lang),
                                                                                      i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                i_code_dom => pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                i_val      => nead.flg_status)),
                                           i_dt_plan                  => nead.dt_plan,
                                           i_id_epis_documentation    => nead.id_epis_documentation,
                                           i_vital_sign_read_list     => pk_utils.str_split_n(i_list  => nead.vital_sign_read_list,
                                                                                              i_delim => g_vital_sign_read_list_delim),
                                           i_lst_activity_task        => pk_nnn_core.get_epis_nic_actv_det_task_h(i_nnn_epis_activity_det => nead.id_nnn_epis_activity_det,
                                                                                                                  i_dt_trs_time_start     => nead.dt_trs_time_start),
                                           i_notes                    => pk_translation.get_translation_trs(nead.code_notes),
                                           i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => nead.dt_val_time_start,
                                                                                               i_val_time_end   => nead.dt_val_time_end,
                                                                                               i_trs_time_start => nead.dt_trs_time_start,
                                                                                               i_trs_time_end   => nead.dt_trs_time_end),
                                           i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                               FROM dual
                                                                              WHERE EXISTS
                                                                              (SELECT 1
                                                                                       FROM nnn_epis_activity_det_h hst
                                                                                      WHERE hst.id_nnn_epis_activity_det =
                                                                                            nead.id_nnn_epis_activity_det)),
                                                                             pk_alert_constant.g_no))
          INTO l_obj
          FROM nnn_epis_activity_det nead
         INNER JOIN nnn_epis_activity nea
            ON nea.id_nnn_epis_activity = nead.id_nnn_epis_activity
         WHERE nead.id_nnn_epis_activity_det = i_nnn_epis_activity_det;
    
        RETURN l_obj;
    END get_epis_nic_activity_det;

    PROCEDURE get_epis_nic_activity_det
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_flg_detail_type   IN VARCHAR2,
        o_detail            OUT pk_types.cursor_type
    ) IS
        TYPE lt_coll_obj_nnn_epis_activity IS TABLE OF t_obj_nnn_epis_activity;
    
        l_jsn_activity               json_object_t;
        l_coll_obj_nnn_epis_activity lt_coll_obj_nnn_epis_activity;
        l_coll_nnn_epis_activity_h   table_number;
        l_obj_nnn_epis_activity      t_obj_nnn_epis_activity;
        l_prev_obj_nnn_epis_activity t_obj_nnn_epis_activity;
        l_obj_nic_activity           t_obj_nic_activity;
        l_prev_obj_nic_activity      t_obj_nic_activity;
        l_label_edition              sys_message.desc_message%TYPE;
        l_label_creation             sys_message.desc_message%TYPE;
        l_label_cancel               sys_message.desc_message%TYPE;
        l_nnn_epis_activity_h        nnn_epis_activity_h.id_nnn_epis_activity_h%TYPE;
        l_order_recurr_plan          nnn_epis_activity.id_order_recurr_plan%TYPE;
        l_cursor                     pk_types.cursor_type;
        l_flg_call                   VARCHAR2(1 CHAR);
        l_value_string               pk_types.t_huge_byte;
        l_old_value_string           pk_types.t_huge_byte;
        l_has_previous               BOOLEAN;
    BEGIN
        /*--Initialization of detail table
        pk_edis_hist.init_vars;
        
        CASE i_flg_detail_type
        
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details 
                l_jsn_activity := get_epis_activity_hier_detail(i_lang              => i_lang,
                                                                i_prof              => i_prof,
                                                                i_nnn_epis_activity => i_nnn_epis_activity,
                                                                i_nic_intervention  => NULL);
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                 i_prof      => i_prof,
                                                                                 i_timestamp => json_ext.get_string(l_jsn_activity,
                                                                                                                    'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                 i_timezone  => NULL),
                                      
                                      i_record_state   => json_ext.get_string(l_jsn_activity, 'STATUS.FLG_STATUS'),
                                      i_desc_rec_state => json_ext.get_string(l_jsn_activity, 'STATUS.DESC_FLG_STATUS'),
                                      i_professional   => json_ext.get_number(l_jsn_activity,
                                                                              'PROF_INFO.ID_PROFESSIONAL'),
                                      i_episode        => json_ext.get_number(l_jsn_activity,
                                                                              'CONTEXT_RECORD.ID_EPISODE'));
            
                -- Title: NicActivity.Description
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => json_ext.get_string(l_jsn_activity, 'NIC_ACTIVITY.DESCRIPTION'),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                -- Subtitle: Instructions
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T001'), --'Instructions'
                                       i_value    => NULL,
                                       i_type     => pk_edis_hist.g_type_subtitle);
            
                -- descInstructions  (we split the instructions to one property by row instead of use the string DESC_INSTRUCTIONS)
                l_order_recurr_plan := json_ext.get_number(l_jsn_activity, 'ID_ORDER_RECURR_PLAN');
            
                -- flgPriority
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_priority,
                                                          i_val      => json_ext.get_string(l_jsn_activity,
                                                                                            'FLG_PRIORITY'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T002'),
                                                                         ':'), --'Priority'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- flgTime
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_time,
                                                          i_val      => json_ext.get_string(l_jsn_activity, 'FLG_TIME'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T003'),
                                                                         ':'), --'To be performed'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- flgPRN
                l_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_ind_flg_prn,
                                                          i_val      => json_ext.get_string(l_jsn_activity, 'FLG_PRN'),
                                                          i_lang     => i_lang);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T004'),
                                                                         ':'), --'PRN'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- notesPRN
                l_value_string := json_ext.get_string(l_jsn_activity, 'NOTES_PRN');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T005'),
                                                                         ':'), --'PRN Condition'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --frequency
                l_value_string := pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                 i_prof                 => i_prof,
                                                                 i_id_order_recurr_plan => l_order_recurr_plan,
                                                                 i_order_recurr_option  => NULL);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T006'),
                                                                         ':'), --'Frequency'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --startDate
                l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_order_recurr_plan => l_order_recurr_plan);
            
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T007'),
                                                                         ':'), --'Start Date'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- status.descFlgStatus
                l_value_string := json_ext.get_string(l_jsn_activity, 'STATUS.DESC_FLG_STATUS');
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := json_ext.get_string(l_jsn_activity, 'CANCEL_INFO.CANCEL_REASON_DESC');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- cancelInfo.cancelNotes
                l_value_string := json_ext.get_string(l_jsn_activity, 'CANCEL_INFO.CANCEL_NOTES');
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => json_ext.get_number(l_jsn_activity,
                                                                                                             'CONTEXT_RECORD.ID_EPISODE'),
                                                             i_date                   => pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                       i_prof      => i_prof,
                                                                                                                       i_timestamp => json_ext.get_string(l_jsn_activity,
                                                                                                                                                          'BITEMPORAL_DATA.TRANSACTION_TIME.DT_TRS_TIME_START'),
                                                                                                                       i_timezone  => NULL),
                                                             i_id_prof_last_change    => json_ext.get_number(l_jsn_activity,
                                                                                                             'PROF_INFO.ID_PROFESSIONAL'),
                                                             i_has_historical_changes => json_ext.get_string(l_jsn_activity,
                                                                                                             'HAS_HISTORICAL_CHANGES'));
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
                -- History of changes: Displays only editions on Careplan's NIC Activity (nnn_epis_activity)
                get_epis_nic_activity_h(i_lang              => i_lang,
                                        i_prof              => i_prof,
                                        i_nnn_epis_activity => i_nnn_epis_activity,
                                        o_hist              => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_coll_nnn_epis_activity_h, l_coll_obj_nnn_epis_activity;
                CLOSE l_cursor;
            
                FOR i IN 1 .. l_coll_nnn_epis_activity_h.count()
                LOOP
                
                    l_nnn_epis_activity_h   := l_coll_nnn_epis_activity_h(i);
                    l_obj_nnn_epis_activity := l_coll_obj_nnn_epis_activity(i);
                    l_obj_nic_activity      := pk_nic_model.get_nic_activity(i_lang             => i_lang,
                                                                             i_nic_intervention => NULL,
                                                                             i_nic_activity     => l_obj_nnn_epis_activity.id_nic_activity);
                    IF l_coll_obj_nnn_epis_activity.exists(i + 1)
                    THEN
                        l_has_previous               := TRUE;
                        l_prev_obj_nnn_epis_activity := l_coll_obj_nnn_epis_activity(i + 1);
                        l_prev_obj_nic_activity      := pk_nic_model.get_nic_activity(i_lang             => i_lang,
                                                                                      i_nic_intervention => NULL,
                                                                                      i_nic_activity     => l_prev_obj_nnn_epis_activity.id_nic_activity);
                        l_flg_call                   := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous               := FALSE;
                        l_prev_obj_nnn_epis_activity := NULL;
                        l_prev_obj_nic_activity      := NULL;
                        l_flg_call                   := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_activity_h, -1),
                                          i_dt_hist        => l_obj_nnn_epis_activity.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_nnn_epis_activity.status.flg_status,
                                          i_desc_rec_state => l_obj_nnn_epis_activity.status.desc_flg_status,
                                          i_professional   => l_obj_nnn_epis_activity.prof_info.id_professional,
                                          i_episode        => l_obj_nnn_epis_activity.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_nnn_epis_activity.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_nnn_epis_activity IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    
                    END IF;
                
                    -- Subtitle: General information
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M001'), --'General information'
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    -- NicActivity.description
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M002'), --'Name'
                                           i_value     => l_obj_nic_activity.description,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nic_activity.description
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- flgPriority
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T002'),
                                                                              ':'), --'Priority'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_priority,
                                                                                              i_val      => l_obj_nnn_epis_activity.flg_priority,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_priority,
                                                                                                   i_val      => l_prev_obj_nnn_epis_activity.flg_priority,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- flgTime
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T003'),
                                                                              ':'), --'To be performed'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_time,
                                                                                              i_val      => l_obj_nnn_epis_activity.flg_time,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_time,
                                                                                                   i_val      => l_prev_obj_nnn_epis_activity.flg_time,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- flgPRN
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T004'),
                                                                              ':'), --'PRN'
                                                       i_value     => pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_prn,
                                                                                              i_val      => l_obj_nnn_epis_activity.flg_prn,
                                                                                              i_lang     => i_lang),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_flg_prn,
                                                                                                   i_val      => l_prev_obj_nnn_epis_activity.flg_prn,
                                                                                                   i_lang     => i_lang)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- notesPRN
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T005'),
                                                                              ':'), --'PRN Condition'
                                                       i_value     => l_obj_nnn_epis_activity.notes_prn,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_activity.notes_prn
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --frequency
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang, i_prof, 'NNN_INSTRUCT_T006'),
                                                                              ':'), --'Frequency'
                                                       i_value     => pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                                                     i_prof                 => i_prof,
                                                                                                     i_id_order_recurr_plan => l_obj_nnn_epis_activity.id_order_recurr_plan,
                                                                                                     i_order_recurr_option  => NULL),
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           pk_nnn_core.get_frequency_desc(i_lang                 => i_lang,
                                                                                                          i_prof                 => i_prof,
                                                                                                          i_id_order_recurr_plan => l_prev_obj_nnn_epis_activity.id_order_recurr_plan,
                                                                                                          i_order_recurr_option  => NULL)
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --startDate
                    l_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                      i_prof              => i_prof,
                                                                      i_order_recurr_plan => l_obj_nnn_epis_activity.id_order_recurr_plan);
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_nnn_core.get_start_date_desc(i_lang              => i_lang,
                                                                              i_prof              => i_prof,
                                                                              i_order_recurr_plan => l_prev_obj_nnn_epis_activity.id_order_recurr_plan);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T007'),
                                                                              ':'), --'Start Date'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Status of the entry:
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_obj_nnn_epis_activity.status.desc_flg_status,
                                           i_old_value => CASE
                                                              WHEN l_has_previous THEN
                                                               l_prev_obj_nnn_epis_activity.status.desc_flg_status
                                                              ELSE
                                                               NULL
                                                          END,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_obj_nnn_epis_activity.cancel_info.cancel_reason_desc,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_activity.cancel_info.cancel_reason_desc
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelNotes
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang, i_prof, 'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_obj_nnn_epis_activity.cancel_info.cancel_notes,
                                                       i_old_value => CASE
                                                                          WHEN l_has_previous THEN
                                                                           l_prev_obj_nnn_epis_activity.cancel_info.cancel_notes
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Signature 
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_nnn_epis_activity.context_record.id_episode,
                                                                 i_date                => l_obj_nnn_epis_activity.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_nnn_epis_activity.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                END LOOP;
            
        END CASE;
        */
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    END get_epis_nic_activity_det;

    PROCEDURE get_epis_nic_activity_det_h
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_activity_det IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE,
        o_hist                  OUT pk_types.cursor_type
    ) IS
    BEGIN
        OPEN o_hist FOR
            SELECT t.id_nnn_epis_activity_det_h, t.obj_nnn_epis_activity_det
              FROM (SELECT NULL id_nnn_epis_activity_det_h,
                           t_obj_nnn_epis_activity_det(i_id_nnn_epis_activity_det => nead.id_nnn_epis_activity_det,
                                                       i_id_nnn_epis_activity     => nead.id_nnn_epis_activity,
                                                       i_context_record           => t_obj_context_record(i_id_episode => nead.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => nead.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nead.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => nead.id_professional,
                                                                                                                                                           i_dt_reg  => nead.dt_trs_time_start,
                                                                                                                                                           i_episode => nead.id_episode)),
                                                       i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                       i_prof             => i_prof,
                                                                                                       i_id_cancel_reason => nead.id_cancel_reason,
                                                                                                       i_cancel_notes     => nead.cancel_notes),
                                                       i_status                   => t_obj_status(i_flg_status      => nead.flg_status,
                                                                                                  i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                               nead.flg_status,
                                                                                                                                               i_lang),
                                                                                                  i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                            i_code_dom => pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                            i_val      => nead.flg_status)),
                                                       i_dt_plan                  => nead.dt_plan,
                                                       i_id_epis_documentation    => nead.id_epis_documentation,
                                                       i_vital_sign_read_list     => pk_utils.str_split_n(i_list  => nead.vital_sign_read_list,
                                                                                                          i_delim => g_vital_sign_read_list_delim),
                                                       i_lst_activity_task        => pk_nnn_core.get_epis_nic_actv_det_task_h(i_nnn_epis_activity_det => nead.id_nnn_epis_activity_det,
                                                                                                                              i_dt_trs_time_start     => nead.dt_trs_time_start),
                                                       i_notes                    => pk_translation.get_translation_trs(nead.code_notes),
                                                       i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => nead.dt_val_time_start,
                                                                                                           i_val_time_end   => nead.dt_val_time_end,
                                                                                                           i_trs_time_start => nead.dt_trs_time_start,
                                                                                                           i_trs_time_end   => nead.dt_trs_time_end),
                                                       i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                                           FROM dual
                                                                                          WHERE EXISTS
                                                                                          (SELECT 1
                                                                                                   FROM nnn_epis_activity_det_h hst
                                                                                                  WHERE hst.id_nnn_epis_activity_det =
                                                                                                        nead.id_nnn_epis_activity_det)),
                                                                                         pk_alert_constant.g_no)) obj_nnn_epis_activity_det,
                           nead.dt_trs_time_start,
                           nead.dt_trs_time_end
                      FROM nnn_epis_activity_det nead
                     INNER JOIN nnn_epis_activity nea
                        ON nea.id_nnn_epis_activity = nead.id_nnn_epis_activity
                     WHERE nead.id_nnn_epis_activity_det = i_nnn_epis_activity_det
                    UNION ALL
                    SELECT neadh.id_nnn_epis_activity_det_h,
                           t_obj_nnn_epis_activity_det(i_id_nnn_epis_activity_det => neadh.id_nnn_epis_activity_det,
                                                       i_id_nnn_epis_activity     => neadh.id_nnn_epis_activity,
                                                       i_context_record           => t_obj_context_record(i_id_episode => neadh.id_episode),
                                                       i_prof_info                => t_obj_prof_info(i_id_professional => neadh.id_professional,
                                                                                                     i_nick_name       => pk_prof_utils.get_name_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neadh.id_professional),
                                                                                                     i_desc_speciality => pk_prof_utils.get_spec_signature(i_lang    => i_lang,
                                                                                                                                                           i_prof    => i_prof,
                                                                                                                                                           i_prof_id => neadh.id_professional,
                                                                                                                                                           i_dt_reg  => neadh.dt_trs_time_start,
                                                                                                                                                           i_episode => neadh.id_episode)),
                                                       i_cancel_info              => t_obj_cancel_info(i_lang             => i_lang,
                                                                                                       i_prof             => i_prof,
                                                                                                       i_id_cancel_reason => neadh.id_cancel_reason,
                                                                                                       i_cancel_notes     => neadh.cancel_notes),
                                                       i_status                   => t_obj_status(i_flg_status      => neadh.flg_status,
                                                                                                  i_desc_flg_status => pk_sysdomain.get_domain(pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                               neadh.flg_status,
                                                                                                                                               i_lang),
                                                                                                  i_icon            => pk_sysdomain.get_img(i_lang     => i_lang,
                                                                                                                                            i_code_dom => pk_nnn_constant.g_dom_epis_act_det_flg_status,
                                                                                                                                            i_val      => neadh.flg_status)),
                                                       i_dt_plan                  => neadh.dt_plan,
                                                       i_id_epis_documentation    => neadh.id_epis_documentation,
                                                       i_vital_sign_read_list     => pk_utils.str_split_n(i_list  => neadh.vital_sign_read_list,
                                                                                                          i_delim => g_vital_sign_read_list_delim),
                                                       i_lst_activity_task        => pk_nnn_core.get_epis_nic_actv_det_task_h(i_nnn_epis_activity_det => neadh.id_nnn_epis_activity_det,
                                                                                                                              i_dt_trs_time_start     => neadh.dt_trs_time_start),
                                                       i_notes                    => neadh.notes,
                                                       i_bitemporal_data          => t_obj_bitemporal_data(i_val_time_start => neadh.dt_val_time_start,
                                                                                                           i_val_time_end   => neadh.dt_val_time_end,
                                                                                                           i_trs_time_start => neadh.dt_trs_time_start,
                                                                                                           i_trs_time_end   => neadh.dt_trs_time_end),
                                                       i_has_historical_changes   => nvl((SELECT pk_alert_constant.g_yes
                                                                                           FROM dual
                                                                                          WHERE EXISTS
                                                                                          (SELECT 1
                                                                                                   FROM nnn_epis_activity_det_h hst
                                                                                                  WHERE hst.id_nnn_epis_activity_det =
                                                                                                        neadh.id_nnn_epis_activity_det)),
                                                                                         pk_alert_constant.g_no)) obj_nnn_epis_activity_det,
                           neadh.dt_trs_time_start,
                           neadh.dt_trs_time_end
                      FROM nnn_epis_activity_det_h neadh
                     INNER JOIN nnn_epis_activity nead
                        ON nead.id_nnn_epis_activity = neadh.id_nnn_epis_activity
                     WHERE neadh.id_nnn_epis_activity_det = i_nnn_epis_activity_det) t
             ORDER BY t.dt_trs_time_start DESC, t.dt_trs_time_end DESC NULLS FIRST;
    END get_epis_nic_activity_det_h;

    PROCEDURE get_epis_nic_activity_det_det
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_activity_det IN nnn_epis_activity_det.id_nnn_epis_activity_det%TYPE,
        i_flg_detail_type       IN VARCHAR2,
        o_detail                OUT pk_types.cursor_type
    ) IS
        TYPE lt_coll_obj_nnn_epis_actv_det IS TABLE OF t_obj_nnn_epis_activity_det;
        TYPE lt_map_obj_epis_activity_task IS TABLE OF t_obj_nnn_epis_activity_task INDEX BY pk_nnn_type.t_map_key;
    
        l_label_edition                sys_message.desc_message%TYPE;
        l_label_creation               sys_message.desc_message%TYPE;
        l_label_cancel                 sys_message.desc_message%TYPE;
        l_nnn_epis_activity_det_h      nnn_epis_activity_det_h.id_nnn_epis_activity_det_h%TYPE;
        l_prev_nnn_epis_activity_det_h nnn_epis_activity_det_h.id_nnn_epis_activity_det_h%TYPE;
    
        l_obj_epis_activity_det      t_obj_nnn_epis_activity_det;
        l_prev_obj_epis_activity_det t_obj_nnn_epis_activity_det;
        l_obj_nnn_epis_activity      t_obj_nnn_epis_activity;
        l_obj_task                   t_obj_nnn_epis_activity_task;
        l_prev_obj_task              t_obj_nnn_epis_activity_task;
        l_coll_obj_executed_tasks    t_coll_obj_nnn_epis_actv_tsk;
        l_coll_obj_notexecuted_tasks t_coll_obj_nnn_epis_actv_tsk;
        l_coll_obj_epis_activity_det lt_coll_obj_nnn_epis_actv_det;
        l_map_obj_tasks              lt_map_obj_epis_activity_task;
        l_prev_map_obj_tasks         lt_map_obj_epis_activity_task;
    
        l_coll_nnn_epis_activity_det_h table_number;
    
        l_cursor           pk_types.cursor_type;
        l_value_string     pk_types.t_huge_byte;
        l_old_value_string pk_types.t_huge_byte;
        l_vs_description   pk_types.t_big_char;
        l_dt_dummy         pk_types.t_timestamp;
        l_num_dummy        pk_types.t_med_num;
        l_map_key          pk_nnn_type.t_map_key;
    
        l_flg_call       VARCHAR2(1 CHAR);
        l_idx            PLS_INTEGER;
        l_has_previous   BOOLEAN;
        l_subtitle_added BOOLEAN;
    
        /**
        * Converts a collection into a map using the ID as key
        *
        * @return  A map of t_obj_nnn_epis_activity_task records using the ID_NIC_ACTIVITY property as key.
        *
        * @author   ARIEL.MACHADO
        * @version  2.6.4.3  
        * @since    10/16/2014
        */
        FUNCTION inner_get_map_activity_task(i_coll_obj_task IN t_coll_obj_nnn_epis_actv_tsk)
            RETURN lt_map_obj_epis_activity_task IS
            l_map           lt_map_obj_epis_activity_task;
            l_activity_task t_obj_nnn_epis_activity_task;
            i               PLS_INTEGER;
        BEGIN
            IF i_coll_obj_task IS NOT empty
            THEN
                i := i_coll_obj_task.first;
                WHILE i IS NOT NULL
                LOOP
                    l_activity_task := i_coll_obj_task(i);
                    l_map(to_char(l_activity_task.id_nic_activity)) := l_activity_task;
                    i := i_coll_obj_task.next(i);
                END LOOP;
            END IF;
            RETURN l_map;
        END inner_get_map_activity_task;
    BEGIN
        --Initialization of detail table
        pk_edis_hist.init_vars;
    
        CASE i_flg_detail_type
        
            WHEN pk_nnn_constant.g_detail_type_current_info THEN
                -- Current information details 
            
                -- Gets information about an execution of a Careplan's NIC Activity                                                                                       
                l_obj_epis_activity_det := pk_nnn_api_db.get_epis_nic_activity_det(i_lang                  => i_lang,
                                                                                   i_prof                  => i_prof,
                                                                                   i_nnn_epis_activity_det => i_nnn_epis_activity_det);
            
                --Gets information about a Careplan's NIC Activity                                                                                       
                l_obj_nnn_epis_activity := pk_nnn_api_db.get_epis_nic_activity(i_lang              => i_lang,
                                                                               i_prof              => i_prof,
                                                                               i_nnn_epis_activity => l_obj_epis_activity_det.id_nnn_epis_activity);
            
                -- Status of the entry
                pk_edis_hist.add_line(i_history        => -1, --ID de contexto com a PK do registo transacional, -1 para order by registo mais recente
                                      i_dt_hist        => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start,
                                      i_record_state   => l_obj_epis_activity_det.status.flg_status,
                                      i_desc_rec_state => l_obj_epis_activity_det.status.desc_flg_status,
                                      i_professional   => l_obj_epis_activity_det.prof_info.id_professional,
                                      i_episode        => l_obj_epis_activity_det.context_record.id_episode);
            
                -- Title: NicActivity.description
                l_value_string := pk_nic_model.get_activity_name(i_nic_activity => l_obj_nnn_epis_activity.id_nic_activity);
                IF l_obj_epis_activity_det.status.flg_status = pk_nnn_constant.g_task_status_cancelled
                THEN
                    l_value_string := l_value_string || '(' || l_obj_epis_activity_det.status.desc_flg_status || ')';
                END IF;
                pk_edis_hist.add_value(i_lang  => i_lang,
                                       i_label => l_value_string,
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title);
            
                -- Empty line
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                --startDate
                l_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                              i_date => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                              i_inst => i_prof.institution,
                                                              i_soft => i_prof.software);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T007'),
                                                                         ':'), --'Start Date'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --duration
                IF l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start IS NOT NULL
                   AND l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end IS NOT NULL
                THEN
                    pk_nnn_core.calculate_duration(i_lang               => i_lang,
                                                   i_prof               => i_prof,
                                                   i_start_date         => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                   i_duration           => NULL,
                                                   i_unit_meas_duration => NULL,
                                                   i_end_date           => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                   o_start_date         => l_dt_dummy,
                                                   o_duration           => l_num_dummy,
                                                   o_duration_desc      => l_value_string,
                                                   o_unit_meas_duration => l_num_dummy,
                                                   o_end_date           => l_dt_dummy);
                
                ELSE
                    l_value_string := NULL;
                END IF;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T009'),
                                                                         ':'), --'Duration'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                --endDate
                l_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                              i_date => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                              i_inst => i_prof.institution,
                                                              i_soft => i_prof.software);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 REPLACE(pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_INSTRUCT_T010'),
                                                                         ':'), --'End Date'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Consumed supplies
                l_value_string := pk_supplies_external_api_db.get_supplies_request(i_lang        => i_lang,
                                                                                   i_prof        => i_prof,
                                                                                   i_id_context  => l_obj_epis_activity_det.id_nnn_epis_activity_det,
                                                                                   i_flg_context => pk_supplies_constant.g_context_nic_activity_exec);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(2) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M034'), --'Supplies'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Documentation using TaskLists                                   
                IF l_obj_epis_activity_det.lst_activity_task IS NOT empty
                THEN
                    -- This activity has tasklists
                    l_coll_obj_executed_tasks    := t_coll_obj_nnn_epis_actv_tsk();
                    l_coll_obj_notexecuted_tasks := t_coll_obj_nnn_epis_actv_tsk();
                
                    l_idx := l_obj_epis_activity_det.lst_activity_task.first;
                    WHILE l_idx IS NOT NULL
                    LOOP
                        IF l_obj_epis_activity_det.lst_activity_task(l_idx).flg_executed = pk_alert_constant.g_yes
                        THEN
                            --Executed tasks
                            l_coll_obj_executed_tasks.extend(1);
                            l_coll_obj_executed_tasks(l_coll_obj_executed_tasks.last) := l_obj_epis_activity_det.lst_activity_task(l_idx);
                        ELSE
                            --Not executed tasks                          
                            l_coll_obj_notexecuted_tasks.extend(1);
                            l_coll_obj_notexecuted_tasks(l_coll_obj_notexecuted_tasks.last) := l_obj_epis_activity_det.lst_activity_task(l_idx);
                        END IF;
                    
                        l_idx := l_obj_epis_activity_det.lst_activity_task.next(l_idx);
                    END LOOP;
                
                    IF l_coll_obj_executed_tasks IS NOT empty
                    THEN
                        --Subtitle: Executed tasks
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M032'), --'Executed tasks'
                                               i_value    => NULL,
                                               i_type     => pk_edis_hist.g_type_subtitle);
                    
                        FOR x IN 1 .. l_coll_obj_executed_tasks.count()
                        LOOP
                            l_obj_task := l_coll_obj_executed_tasks(x);
                            --Task.name
                            l_value_string := l_obj_task.activity_name;
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(4) || l_value_string,
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_content);
                        
                            --Task.notes           
                            l_value_string := l_obj_task.notes;
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(6) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M011'), --'Notes'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                        END LOOP;
                    END IF;
                
                    IF l_coll_obj_notexecuted_tasks IS NOT empty
                    THEN
                        --Subtitle: Not executed tasks
                        pk_edis_hist.add_value(i_lang     => i_lang,
                                               i_flg_call => pk_edis_hist.g_call_detail,
                                               i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M033'), --'Not executed tasks'
                                               i_value    => NULL,
                                               i_type     => pk_edis_hist.g_type_subtitle);
                    
                        FOR x IN 1 .. l_coll_obj_notexecuted_tasks.count()
                        LOOP
                            l_obj_task := l_coll_obj_notexecuted_tasks(x);
                            --Task.name
                            l_value_string := l_obj_task.activity_name;
                            pk_edis_hist.add_value(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(4) || l_value_string,
                                                   i_value    => NULL,
                                                   i_type     => pk_edis_hist.g_type_content);
                        
                            --Task.notes           
                            l_value_string := l_obj_task.notes;
                            pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                               i_flg_call => pk_edis_hist.g_call_detail,
                                                               i_label    => pk_string_utils.get_tab(6) ||
                                                                             pk_message.get_message(i_lang,
                                                                                                    i_prof,
                                                                                                    'NNN_DETAIL_M011'), --'Notes'
                                                               i_value    => l_value_string,
                                                               i_type     => pk_edis_hist.g_type_content);
                        
                        END LOOP;
                    END IF;
                
                END IF;
            
                -- Documentation using Vital Signs
                IF l_obj_nnn_epis_activity.flg_doc_type = pk_nic_cfg.g_activity_doctype_vital_sign
                   AND l_obj_epis_activity_det.vital_sign_read_list IS NOT empty
                THEN
                    -- Retrieves description of the vital sign associated with this NIC activity 
                    -- (flg_doc_type=V then doc_parameter=id_vital_sign)
                    l_vs_description := pk_vital_sign.get_vs_desc(i_lang       => i_lang,
                                                                  i_vital_sign => l_obj_nnn_epis_activity.doc_parameter,
                                                                  i_short_desc => pk_alert_constant.get_no);
                
                    -- Retrieves the formatted value for vital sign measurement
                    -- Composite vital signs like blood pressure have two or more ID_VITAL_SIGN_READ. This method just need one ID.
                    l_value_string := pk_touch_option_ti.get_formatted_vsread(i_lang        => i_lang,
                                                                              i_prof        => i_prof,
                                                                              i_vsread      => l_obj_epis_activity_det.vital_sign_read_list(1),
                                                                              i_dt_creation => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start);
                
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => l_vs_description,
                                                       i_value    => l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                END IF;
            
                -- Documentation using Touch-option Template / Free-Text
                l_value_string := pk_string_utils.clob_to_plsqlvarchar2(i_clob => pk_touch_option_core.get_plain_text_entry(i_lang               => i_lang,
                                                                                                                            i_prof               => i_prof,
                                                                                                                            i_epis_documentation => l_obj_epis_activity_det.id_epis_documentation,
                                                                                                                            i_use_html_format    => pk_alert_constant.g_no));
                IF l_value_string IS NOT NULL
                THEN
                    pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                       i_flg_call => pk_edis_hist.g_call_detail,
                                                       i_label    => pk_message.get_message(i_lang,
                                                                                            i_prof,
                                                                                            'NNN_ACTV_T012'), --'Documentation'
                                                       i_value    => chr(10) || l_value_string,
                                                       i_type     => pk_edis_hist.g_type_content);
                
                END IF;
            
                --Notes
                l_value_string := pk_string_utils.clob_to_plsqlvarchar2(i_clob => l_obj_epis_activity_det.notes);
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_string_utils.get_tab(6) ||
                                                                 pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'NNN_DETAIL_M011'), --'Notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- status.descFlgStatus
                l_value_string := l_obj_epis_activity_det.status.desc_flg_status;
                pk_edis_hist.add_value(i_lang     => i_lang,
                                       i_flg_call => pk_edis_hist.g_call_detail,
                                       i_label    => pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                       i_value    => l_value_string,
                                       i_type     => pk_edis_hist.g_type_content);
            
                -- CancelInfo.cancelReasonDesc
                l_value_string := l_obj_epis_activity_det.cancel_info.cancel_reason_desc;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M006'), --'Cancel reason'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- cancelInfo.cancelNotes
                l_value_string := l_obj_epis_activity_det.cancel_info.cancel_notes;
                pk_edis_hist.add_value_if_not_null(i_lang     => i_lang,
                                                   i_flg_call => pk_edis_hist.g_call_detail,
                                                   i_label    => pk_message.get_message(i_lang,
                                                                                        i_prof,
                                                                                        'DETAIL_COMMON_M007'), --'Cancel notes'
                                                   i_value    => l_value_string,
                                                   i_type     => pk_edis_hist.g_type_content);
            
                -- Signature
                l_value_string := pk_edis_hist.get_signature(i_lang                   => i_lang,
                                                             i_prof                   => i_prof,
                                                             i_id_episode             => l_obj_epis_activity_det.context_record.id_episode,
                                                             i_date                   => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start,
                                                             i_id_prof_last_change    => l_obj_epis_activity_det.prof_info.id_professional,
                                                             i_has_historical_changes => l_obj_epis_activity_det.has_historical_changes);
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_value_string,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            
            WHEN pk_nnn_constant.g_detail_type_history_changes THEN
                -- History of changes: Displays only editions on Careplan's NIC Activity execution (nnn_epis_activity_det)              
                l_label_edition  := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
                l_label_creation := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
                l_label_cancel   := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
            
                --Get history of changes in nnn_epis_activity_det
                get_epis_nic_activity_det_h(i_lang                  => i_lang,
                                            i_prof                  => i_prof,
                                            i_nnn_epis_activity_det => i_nnn_epis_activity_det,
                                            o_hist                  => l_cursor);
                FETCH l_cursor BULK COLLECT
                    INTO l_coll_nnn_epis_activity_det_h, l_coll_obj_epis_activity_det;
                CLOSE l_cursor;
                FOR i IN 1 .. l_coll_nnn_epis_activity_det_h.count()
                LOOP
                    l_nnn_epis_activity_det_h := l_coll_nnn_epis_activity_det_h(i);
                    l_obj_epis_activity_det   := l_coll_obj_epis_activity_det(i);
                
                    IF l_obj_nnn_epis_activity IS NULL
                    THEN
                        -- The requested activity doesn't change with the editions of the executions, so these objects are retrieved just once.
                    
                        --Gets information about a Careplan's NIC Activity                                                                                       
                        l_obj_nnn_epis_activity := pk_nnn_api_db.get_epis_nic_activity(i_lang              => i_lang,
                                                                                       i_prof              => i_prof,
                                                                                       i_nnn_epis_activity => l_obj_epis_activity_det.id_nnn_epis_activity);
                    
                    END IF;
                
                    IF l_coll_obj_epis_activity_det.exists(i + 1)
                    THEN
                        l_has_previous                 := TRUE;
                        l_prev_obj_epis_activity_det   := l_coll_obj_epis_activity_det(i + 1);
                        l_prev_nnn_epis_activity_det_h := l_coll_nnn_epis_activity_det_h(i + 1);
                        l_flg_call                     := pk_edis_hist.g_call_hist;
                    ELSE
                        l_has_previous                 := FALSE;
                        l_prev_obj_epis_activity_det   := NULL;
                        l_prev_nnn_epis_activity_det_h := NULL;
                        l_flg_call                     := pk_edis_hist.g_call_detail;
                    END IF;
                
                    pk_edis_hist.add_line(i_history        => nvl(l_nnn_epis_activity_det_h, -1),
                                          i_dt_hist        => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start,
                                          i_record_state   => l_obj_epis_activity_det.status.flg_status,
                                          i_desc_rec_state => l_obj_epis_activity_det.status.desc_flg_status,
                                          i_professional   => l_obj_epis_activity_det.prof_info.id_professional,
                                          i_episode        => l_obj_epis_activity_det.context_record.id_episode);
                
                    --Title: {Creation, Edition, Cancel}
                    IF l_obj_epis_activity_det.status.flg_status IN
                       (pk_nnn_constant.g_req_status_cancelled, pk_nnn_constant.g_req_status_discontinued)
                    THEN
                        g_error := 'ADD CANCEL TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_cancel,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSIF l_prev_obj_epis_activity_det IS NULL
                    THEN
                        g_error := 'ADD CREATION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_creation,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    ELSE
                        g_error := 'ADD EDITION TITLE';
                        pk_edis_hist.add_value(i_lang  => i_lang,
                                               i_label => l_label_edition,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title);
                    END IF;
                
                    -- NicActivity.description
                    l_value_string := pk_nic_model.get_activity_name(i_nic_activity => l_obj_nnn_epis_activity.id_nic_activity);
                    pk_edis_hist.add_value(i_lang     => i_lang,
                                           i_flg_call => pk_edis_hist.g_call_detail,
                                           i_label    => l_value_string,
                                           i_value    => NULL,
                                           i_type     => pk_edis_hist.g_type_subtitle);
                
                    --startDate
                    l_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                  i_date => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                                  i_inst => i_prof.institution,
                                                                  i_soft => i_prof.software);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                          i_date => l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                                          i_inst => i_prof.institution,
                                                                          i_soft => i_prof.software);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T007'),
                                                                              ':'), --'Start Date'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --duration
                    IF l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start IS NOT NULL
                       AND l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end IS NOT NULL
                    THEN
                        pk_nnn_core.calculate_duration(i_lang               => i_lang,
                                                       i_prof               => i_prof,
                                                       i_start_date         => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                       i_duration           => NULL,
                                                       i_unit_meas_duration => NULL,
                                                       i_end_date           => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                       o_start_date         => l_dt_dummy,
                                                       o_duration           => l_num_dummy,
                                                       o_duration_desc      => l_value_string,
                                                       o_unit_meas_duration => l_num_dummy,
                                                       o_end_date           => l_dt_dummy);
                    ELSE
                        l_value_string := NULL;
                    END IF;
                    IF l_has_previous
                       AND l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start IS NOT NULL
                       AND l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end IS NOT NULL
                    THEN
                        pk_nnn_core.calculate_duration(i_lang               => i_lang,
                                                       i_prof               => i_prof,
                                                       i_start_date         => l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_start,
                                                       i_duration           => NULL,
                                                       i_unit_meas_duration => NULL,
                                                       i_end_date           => l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                       o_start_date         => l_dt_dummy,
                                                       o_duration           => l_num_dummy,
                                                       o_duration_desc      => l_old_value_string,
                                                       o_unit_meas_duration => l_num_dummy,
                                                       o_end_date           => l_dt_dummy);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T009'),
                                                                              ':'), --'Duration'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --endDate
                    l_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                  i_date => l_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                                  i_inst => i_prof.institution,
                                                                  i_soft => i_prof.software);
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                                          i_date => l_prev_obj_epis_activity_det.bitemporal_data.valid_time.dt_val_time_end,
                                                                          i_inst => i_prof.institution,
                                                                          i_soft => i_prof.software);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      REPLACE(pk_message.get_message(i_lang,
                                                                                                     i_prof,
                                                                                                     'NNN_INSTRUCT_T010'),
                                                                              ':'), --'End Date'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Consumed supplies
                    IF l_nnn_epis_activity_det_h IS NULL
                    THEN
                        l_value_string := pk_supplies_external_api_db.get_supplies_request(i_lang        => i_lang,
                                                                                           i_prof        => i_prof,
                                                                                           i_id_context  => l_obj_epis_activity_det.id_nnn_epis_activity_det,
                                                                                           i_flg_context => pk_supplies_constant.g_context_nic_activity_exec);
                    ELSE
                        l_value_string := pk_supplies_external_api_db.get_supplies_request_history(i_lang        => i_lang,
                                                                                                   i_prof        => i_prof,
                                                                                                   i_id_context  => l_nnn_epis_activity_det_h,
                                                                                                   i_flg_context => pk_supplies_constant.g_context_nic_activity_exec);
                    END IF;
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_supplies_external_api_db.get_supplies_request_history(i_lang        => i_lang,
                                                                                                       i_prof        => i_prof,
                                                                                                       i_id_context  => l_prev_nnn_epis_activity_det_h,
                                                                                                       i_flg_context => pk_supplies_constant.g_context_nic_activity_exec);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M034'), --'Supplies'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Documentation using TaskLists                                   
                    IF l_obj_epis_activity_det.lst_activity_task IS NOT empty
                    THEN
                        l_subtitle_added := FALSE;
                    
                        l_map_obj_tasks := inner_get_map_activity_task(l_obj_epis_activity_det.lst_activity_task);
                        IF l_has_previous
                        THEN
                            l_prev_map_obj_tasks := inner_get_map_activity_task(l_prev_obj_epis_activity_det.lst_activity_task);
                        ELSE
                            l_prev_map_obj_tasks.delete();
                        END IF;
                    
                        l_map_key := l_map_obj_tasks.first;
                        WHILE l_map_key IS NOT NULL
                        LOOP
                            l_obj_task := l_map_obj_tasks(l_map_key);
                            IF l_has_previous
                               AND l_prev_map_obj_tasks.exists(l_map_key)
                            THEN
                                l_prev_obj_task := l_prev_map_obj_tasks(l_map_key);
                            ELSE
                                l_prev_obj_task := t_obj_nnn_epis_activity_task();
                            END IF;
                        
                            IF (l_obj_task.flg_executed != l_prev_obj_task.flg_executed)
                               OR (l_obj_task.notes != l_prev_obj_task.notes)
                            THEN
                            
                                IF NOT l_subtitle_added
                                THEN
                                    pk_edis_hist.add_value(i_lang     => i_lang,
                                                           i_flg_call => pk_edis_hist.g_call_detail,
                                                           i_label    => pk_message.get_message(i_lang,
                                                                                                i_prof,
                                                                                                'NNN_ACTV_T005'), -- Tasks
                                                           i_value    => NULL,
                                                           i_type     => pk_edis_hist.g_type_subtitle);
                                    l_subtitle_added := TRUE;
                                END IF;
                            
                                l_value_string     := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_d_tsk_flg_exec,
                                                                              i_val      => l_obj_task.flg_executed,
                                                                              i_lang     => i_lang);
                                l_old_value_string := pk_sysdomain.get_domain(i_code_dom => pk_nnn_constant.g_dom_epis_act_d_tsk_flg_exec,
                                                                              i_val      => l_prev_obj_task.flg_executed,
                                                                              i_lang     => i_lang);
                            
                                pk_edis_hist.add_value(i_lang      => i_lang,
                                                       i_flg_call  => CASE
                                                                          WHEN (l_value_string != l_old_value_string) THEN
                                                                           l_flg_call
                                                                          ELSE
                                                                           pk_edis_hist.g_call_detail
                                                                      END,
                                                       i_label     => pk_string_utils.get_tab(4) || l_obj_task.activity_name,
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                            
                                --Task.notes           
                                l_value_string     := pk_string_utils.clob_to_plsqlvarchar2(i_clob => l_obj_task.notes);
                                l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(i_clob => l_prev_obj_task.notes);
                            
                                pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                                   i_flg_call  => CASE
                                                                                      WHEN (l_value_string != l_old_value_string) THEN
                                                                                       l_flg_call
                                                                                      ELSE
                                                                                       pk_edis_hist.g_call_detail
                                                                                  END,
                                                                   i_label     => pk_string_utils.get_tab(6) ||
                                                                                  pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M011'), --'Notes'
                                                                   i_value     => l_value_string,
                                                                   i_old_value => l_old_value_string,
                                                                   i_type      => pk_edis_hist.g_type_content);
                            
                            END IF;
                            l_map_key := l_map_obj_tasks.next(l_map_key);
                        END LOOP;
                    
                    END IF;
                
                    -- Documentation using Vital Signs
                    IF l_obj_nnn_epis_activity.flg_doc_type = pk_nic_cfg.g_activity_doctype_vital_sign
                       AND l_obj_epis_activity_det.vital_sign_read_list IS NOT empty
                    THEN
                        -- Retrieves description of the vital sign associated with this NIC activity 
                        -- (flg_doc_type=V then doc_parameter=id_vital_sign)
                        l_vs_description := pk_vital_sign.get_vs_desc(i_lang       => i_lang,
                                                                      i_vital_sign => l_obj_nnn_epis_activity.doc_parameter,
                                                                      i_short_desc => pk_alert_constant.get_no);
                    
                        -- Retrieves the formatted value for vital sign measurement
                        -- Composite vital signs like blood pressure have two or more ID_VITAL_SIGN_READ. This method just need one ID.
                        l_value_string := pk_touch_option_ti.get_formatted_vsread(i_lang        => i_lang,
                                                                                  i_prof        => i_prof,
                                                                                  i_vsread      => l_obj_epis_activity_det.vital_sign_read_list(1),
                                                                                  i_dt_creation => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start);
                    
                        IF l_has_previous
                           AND l_prev_obj_epis_activity_det.vital_sign_read_list IS NOT empty
                        THEN
                            l_old_value_string := pk_touch_option_ti.get_formatted_vsread(i_lang        => i_lang,
                                                                                          i_prof        => i_prof,
                                                                                          i_vsread      => l_prev_obj_epis_activity_det.vital_sign_read_list(1),
                                                                                          i_dt_creation => l_prev_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start);
                        ELSE
                            l_old_value_string := NULL;
                        END IF;
                    
                        pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                           i_flg_call  => l_flg_call,
                                                           i_label     => l_vs_description,
                                                           i_value     => l_value_string,
                                                           i_old_value => l_old_value_string,
                                                           i_type      => pk_edis_hist.g_type_content);
                    END IF;
                
                    -- Documentation using Touch-option Template / Free-Text
                    l_value_string := pk_string_utils.clob_to_plsqlvarchar2(i_clob => pk_touch_option_core.get_plain_text_entry(i_lang               => i_lang,
                                                                                                                                i_prof               => i_prof,
                                                                                                                                i_epis_documentation => l_obj_epis_activity_det.id_epis_documentation,
                                                                                                                                i_use_html_format    => pk_alert_constant.g_no));
                
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(i_clob => pk_touch_option_core.get_plain_text_entry(i_lang               => i_lang,
                                                                                                                                        i_prof               => i_prof,
                                                                                                                                        i_epis_documentation => l_prev_obj_epis_activity_det.id_epis_documentation,
                                                                                                                                        i_use_html_format    => pk_alert_constant.g_no));
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_ACTV_T012'), --'Documentation'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    --Notes
                    l_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_obj_epis_activity_det.notes);
                    IF l_has_previous
                    THEN
                        l_old_value_string := pk_string_utils.clob_to_plsqlvarchar2(l_prev_obj_epis_activity_det.notes);
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'NNN_DETAIL_M011'), --'Notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- status.descFlgStatus
                    l_value_string := l_obj_epis_activity_det.status.desc_flg_status;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_activity_det.status.desc_flg_status;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value(i_lang      => i_lang,
                                           i_flg_call  => l_flg_call,
                                           i_label     => pk_string_utils.get_tab(2) ||
                                                          pk_message.get_message(i_lang, i_prof, 'NNN_DETAIL_M006'), --'Status'
                                           i_value     => l_value_string,
                                           i_old_value => l_old_value_string,
                                           i_type      => pk_edis_hist.g_type_content);
                
                    -- CancelInfo.cancelReasonDesc
                    l_value_string := l_obj_epis_activity_det.cancel_info.cancel_reason_desc;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_activity_det.cancel_info.cancel_reason_desc;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M006'), --'Cancel reason'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- cancelInfo.cancelNotes
                    l_value_string := l_obj_epis_activity_det.cancel_info.cancel_notes;
                    IF l_has_previous
                    THEN
                        l_old_value_string := l_prev_obj_epis_activity_det.cancel_info.cancel_notes;
                    ELSE
                        l_old_value_string := NULL;
                    END IF;
                    pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                                       i_flg_call  => l_flg_call,
                                                       i_label     => pk_string_utils.get_tab(2) ||
                                                                      pk_message.get_message(i_lang,
                                                                                             i_prof,
                                                                                             'DETAIL_COMMON_M007'), --'Cancel notes'
                                                       i_value     => l_value_string,
                                                       i_old_value => l_old_value_string,
                                                       i_type      => pk_edis_hist.g_type_content);
                
                    -- Signature
                    l_value_string := pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_episode          => l_obj_epis_activity_det.context_record.id_episode,
                                                                 i_date                => l_obj_epis_activity_det.bitemporal_data.transaction_time.dt_trs_time_start,
                                                                 i_id_prof_last_change => l_obj_epis_activity_det.prof_info.id_professional);
                    pk_edis_hist.add_value(i_label => NULL,
                                           i_value => l_value_string,
                                           i_type  => pk_edis_hist.g_type_signature,
                                           i_code  => 'SIGNATURE');
                
                END LOOP;
            
        END CASE;
    
        OPEN o_detail FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    END get_epis_nic_activity_det_det;

    FUNCTION get_epis_activity_hier_detail
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_nnn_epis_activity IN nnn_epis_activity.id_nnn_epis_activity%TYPE,
        i_nic_intervention  IN nnn_epis_intervention.id_nic_intervention%TYPE
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_activity_hier_detail';
        l_jsn_activity          json_object_t;
        l_obj_nic_activity      t_obj_nic_activity;
        l_obj_epis_nic_activity t_obj_nnn_epis_activity;
    BEGIN
        /*\** Basic structure of the JSON output for a "ACTIVITY":
        {
          "BITEMPORAL_DATA": {},
          "HAS_HISTORICAL_CHANGES": "",
          "ID_NNN_EPIS_ACTIVITY": "",
          "ID_NIC_ACTIVITY": "",
          "ID_NIC_OTHR_ACTV_VRSN": "",
          "CONTEXT_RECORD": {},
          "PROF_INFO": {},
          "CANCEL_INFO": {},
          "STATUS": {},
          "ID_EPISODE_ORIGIN": "",
          "ID_EPISODE_DESTINATION": "",
          "FLG_PRN": "",
          "NOTES_PRN": "",
          "FLG_TIME": "",
          "FLG_PRIORITY": "",
          "ID_ORDER_RECURR_PLAN": "",
          "DESC_INSTRUCTIONS": "",
          "NIC_ACTIVITY": {}
        }
        *\
        
        g_error := 'Get the careplan''s NIC Activity i_nnn_epis_activity = ' || to_char(i_nnn_epis_activity);
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_epis_nic_activity := pk_nnn_api_db.get_epis_nic_activity(i_lang              => i_lang,
                                                                       i_prof              => i_prof,
                                                                       i_nnn_epis_activity => i_nnn_epis_activity);
        
        g_error := 'Get info about the activity from the NIC Classification';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_nic_activity := pk_nic_model.get_nic_activity(i_lang             => i_lang,
                                                            i_nic_intervention => i_nic_intervention,
                                                            i_nic_activity     => l_obj_epis_nic_activity.id_nic_activity);
        
        g_error := 'Initialize a JSON object with the careplan''s activity';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_activity := l_obj_epis_nic_activity.to_json(i_lang => i_lang, i_prof => i_prof);
        -- Add the activity info to the JSON object
        l_jsn_activity.put('NIC_ACTIVITY', l_obj_nic_activity.to_json());
        */
        RETURN l_jsn_activity;
    END get_epis_activity_hier_detail;

    FUNCTION get_epis_interv_hier_detail
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_nnn_epis_intervention IN nnn_epis_intervention.id_nnn_epis_intervention%TYPE
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_interv_hier_detail';
        l_jsn_intervention          json_object_t;
        l_jsn_activity              json_object_t;
        l_lst_jsn_activity          json_array_t;
        l_obj_nic_intervention      t_obj_nic_intervention;
        l_obj_epis_nic_intervention t_obj_nnn_epis_intervention;
        l_nnn_epis_activity         nnn_epis_activity.id_nnn_epis_activity%TYPE;
        l_epis_lnk_int_actv_rows    ts_nnn_epis_lnk_int_actv.nnn_epis_lnk_int_actv_tc;
    BEGIN
        /*\** Basic structure of the JSON output for a "INTERVENTION":      
         {
           "BITEMPORAL_DATA": {},
           "HAS_HISTORICAL_CHANGES": "",
           "ID_NNN_EPIS_INTERVENTION": "",
           "ID_NIC_INTERVENTION": "",
           "CONTEXT_RECORD": {},
           "PROF_INFO": {},
           "CANCEL_INFO": {},
           "STATUS": {},
           "NIC_INTERVENTION": {},
           "ACTIVITIES": []
         }      
         *\
        
         g_error := 'Get the careplan''s NIC Intervention i_nnn_epis_intervention = ' ||
                    to_char(i_nnn_epis_intervention);
         pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
         l_obj_epis_nic_intervention := pk_nnn_api_db.get_epis_nic_intervention(i_lang                  => i_lang,
                                                                                i_prof                  => i_prof,
                                                                                i_nnn_epis_intervention => i_nnn_epis_intervention);
        
         g_error := 'Get info about this intervention from the NIC Classification';
         pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
         l_obj_nic_intervention := pk_nic_model.get_nic_intervention(i_lang             => i_lang,
                                                                     i_nic_intervention => l_obj_epis_nic_intervention.id_nic_intervention);
        
         g_error := 'Initialize JSON object with the careplan''s intervention';
         pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
         l_jsn_intervention := l_obj_epis_nic_intervention.to_json(i_lang => i_lang, i_prof => i_prof);
         l_jsn_intervention.put('NIC_INTERVENTION', l_obj_nic_intervention.to_json());
        
         g_error := 'Get linked NIC activities';
         pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
         l_lst_jsn_activity       := json_list();
         l_epis_lnk_int_actv_rows := pk_nnn_core.get_lnk_int_actv_by_intrv(i_nnn_epis_intervention => l_obj_epis_nic_intervention.id_nnn_epis_intervention,
                                                                           i_fltr_status           => pk_nnn_constant.g_req_status_ordered ||
                                                                                                      pk_nnn_constant.g_req_status_ongoing ||
                                                                                                      pk_nnn_constant.g_req_status_suspended ||
                                                                                                      pk_nnn_constant.g_req_status_finished ||
                                                                                                      pk_nnn_constant.g_req_status_expired);
         FOR x IN 1 .. l_epis_lnk_int_actv_rows.count()
         LOOP
             l_nnn_epis_activity := l_epis_lnk_int_actv_rows(x).id_nnn_epis_activity;
             -- Get the hierachical detail of the careplan's NIC Activity
             l_jsn_activity := get_epis_activity_hier_detail(i_lang              => i_lang,
                                                             i_prof              => i_prof,
                                                             i_nnn_epis_activity => l_nnn_epis_activity,
                                                             i_nic_intervention  => l_obj_nic_intervention.id_nic_intervention);
         
             -- Append to the array of Activities
             l_lst_jsn_activity.append(l_jsn_activity.to_json_value);
         END LOOP;
         -- Add the array of activities to the Intervention object              
         l_jsn_intervention.put('ACTIVITIES', l_lst_jsn_activity);
        */
        RETURN l_jsn_intervention;
    END get_epis_interv_hier_detail;

    FUNCTION get_epis_indicator_hier_detail
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_indicator IN nnn_epis_indicator.id_nnn_epis_indicator%TYPE,
        i_nnn_epis_outcome   IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE,
        i_noc_outcome        IN nnn_epis_outcome.id_noc_outcome%TYPE
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_indicator_hier_detail';
        l_jsn_indicator           json_object_t;
        l_obj_noc_indicator       t_obj_noc_indicator;
        l_obj_epis_noc_indicator  t_obj_nnn_epis_indicator;
        l_obj_epis_noc_ind_eval   t_obj_nnn_epis_ind_eval;
        l_nnn_epis_ind_eval_ltest nnn_epis_ind_eval.id_nnn_epis_ind_eval%TYPE;
    BEGIN
        /*\** Basic structure of the JSON output for a "INDICATOR":
        {
          "BITEMPORAL_DATA": {},
          "HAS_HISTORICAL_CHANGES": "",
          "ID_NNN_EPIS_INDICATOR": "",
          "ID_NOC_INDICATOR": "",
          "ID_NOC_OTHR_IND_VRSN": "",
          "CONTEXT_RECORD": {},
          "PROF_INFO": {},
          "CANCEL_INFO": {},
          "STATUS": {},
          "ID_EPISODE_ORIGIN": "",
          "ID_EPISODE_DESTINATION": "",
          "FLG_PRN": "",
          "NOTES_PRN": "",
          "FLG_TIME": "E",
          "FLG_PRIORITY": "",
          "ID_ORDER_RECURR_PLAN": "",
          "DESC_INSTRUCTIONS": "",
          "NOC_INDICATOR": {},
          "LAST_EVALUATION": {}
        }
        *\
        
        g_error := 'Get the careplan''s NOC Indicator i_nnn_epis_indicator = ' || to_char(i_nnn_epis_indicator);
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_epis_noc_indicator := pk_nnn_api_db.get_epis_noc_indicator(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_nnn_epis_indicator => i_nnn_epis_indicator);
        
        g_error := 'Get info about this indicator from the NOC Classification';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_noc_indicator := pk_noc_model.get_noc_indicator(i_lang          => i_lang,
                                                              i_noc_outcome   => i_noc_outcome,
                                                              i_noc_indicator => l_obj_epis_noc_indicator.id_noc_indicator);
        
        g_error := 'Get the last active evaluation made for this NOC indicator';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        BEGIN
            SELECT \*+ opt_estimate(table t rows=1)*\
             t.id_nnn_epis_ind_eval
              INTO l_nnn_epis_ind_eval_ltest
              FROM TABLE(pk_nnn_core.tf_latest_nnn_epis_ind_eval(i_nnn_epis_indicator => l_obj_epis_noc_indicator.id_nnn_epis_indicator)) t;
        
        EXCEPTION
            WHEN no_data_found THEN
                g_error := 'None evaluation has been made yet for this indicator (or none is active)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_nnn_epis_ind_eval_ltest := NULL;
        END;
        IF l_nnn_epis_ind_eval_ltest IS NOT NULL
        THEN
            l_obj_epis_noc_ind_eval := pk_nnn_api_db.get_epis_noc_indicator_eval(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_nnn_epis_outcome  => i_nnn_epis_outcome,
                                                                                 i_nnn_epis_ind_eval => l_nnn_epis_ind_eval_ltest);
        END IF;
        
        g_error := 'Initialize a JSON object with the careplan''s indicator';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_indicator := l_obj_epis_noc_indicator.to_json(i_lang => i_lang, i_prof => i_prof);
        
        g_error := 'Add the indicator info to the JSON object';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_indicator.put('NOC_INDICATOR', l_obj_noc_indicator.to_json());
        
        g_error := 'Add the last indicator evaluation to the JSON object';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        IF l_obj_epis_noc_ind_eval IS NOT NULL
        THEN
            l_jsn_indicator.put('LAST_EVALUATION', l_obj_epis_noc_ind_eval.to_json(i_lang => i_lang, i_prof => i_prof));
        ELSE
            l_jsn_indicator.put('LAST_EVALUATION', json());
        END IF;
        */
        RETURN l_jsn_indicator;
    END get_epis_indicator_hier_detail;

    FUNCTION get_epis_outcome_hier_detail
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_nnn_epis_outcome IN nnn_epis_outcome.id_nnn_epis_outcome%TYPE
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_outcome_hier_detail';
        l_jsn_outcome                 json_object_t;
        l_jsn_indicator               json_object_t;
        l_lst_jsn_indicator           json_array_t;
        l_obj_noc_outcome             t_obj_noc_outcome;
        l_obj_epis_noc_outcome        t_obj_nnn_epis_outcome;
        l_obj_epis_noc_outcome_eval   t_obj_nnn_epis_outcome_eval;
        l_nnn_epis_outcome_eval_ltest nnn_epis_outcome_eval.id_nnn_epis_outcome_eval%TYPE;
        l_nnn_epis_indicator          nnn_epis_indicator.id_nnn_epis_indicator%TYPE;
        l_epis_lnk_outc_ind_rows      ts_nnn_epis_lnk_outc_ind.nnn_epis_lnk_outc_ind_tc;
    BEGIN
        /*\** Basic structure of the JSON output for a "OUTCOME":
        {
          "BITEMPORAL_DATA": {},
          "HAS_HISTORICAL_CHANGES": "",
          "ID_NNN_EPIS_OUTCOME": "",
          "ID_NOC_OUTCOME": "",
          "CONTEXT_RECORD": {},
          "PROF_INFO": {},
          "CANCEL_INFO": {},
          "STATUS": {},
          "ID_EPISODE_ORIGIN": "",
          "ID_EPISODE_DESTINATION": "",
          "FLG_PRN": "",
          "NOTES_PRN": "",
          "FLG_TIME": "",
          "FLG_PRIORITY": "",
          "ID_ORDER_RECURR_PLAN": "",
          "DESC_INSTRUCTIONS": "",
          "NOC_OUTCOME": {},
          "LAST_EVALUATION": {},
          "INDICATORS": []
        }
        *\
        
        g_error := 'Get the careplan''s NOC Outcome i_nnn_epis_outcome = ' || to_char(i_nnn_epis_outcome);
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_epis_noc_outcome := pk_nnn_api_db.get_epis_noc_outcome(i_lang             => i_lang,
                                                                     i_prof             => i_prof,
                                                                     i_nnn_epis_outcome => i_nnn_epis_outcome);
        
        g_error := 'Get info about this outcome from the NOC Classification';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_noc_outcome := pk_noc_model.get_noc_outcome(i_lang        => i_lang,
                                                          i_noc_outcome => l_obj_epis_noc_outcome.id_noc_outcome);
        
        g_error := 'Get the last active evaluation meade for this NOC outcome';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        BEGIN
            SELECT \*+ opt_estimate(table t rows=1)*\
             t.id_nnn_epis_outcome_eval
              INTO l_nnn_epis_outcome_eval_ltest
              FROM TABLE(pk_nnn_core.tf_latest_nnn_epis_outc_eval(i_nnn_epis_outcome => l_obj_epis_noc_outcome.id_nnn_epis_outcome)) t;
        EXCEPTION
            WHEN no_data_found THEN
                g_error := 'None evaluation has been made yet for this outcome (or none is active)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_nnn_epis_outcome_eval_ltest := NULL;
        END;
        IF l_nnn_epis_outcome_eval_ltest IS NOT NULL
        THEN
            l_obj_epis_noc_outcome_eval := pk_nnn_api_db.get_epis_noc_outcome_eval(i_lang                  => i_lang,
                                                                                   i_prof                  => i_prof,
                                                                                   i_nnn_epis_outcome_eval => l_nnn_epis_outcome_eval_ltest);
        END IF;
        
        g_error := 'Initialize a JSON object with the careplan''s outcome';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_outcome := l_obj_epis_noc_outcome.to_json(i_lang => i_lang, i_prof => i_prof);
        
        g_error := 'Add the outcome info to the JSON object';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_outcome.put('NOC_OUTCOME', l_obj_noc_outcome.to_json());
        
        g_error := 'Add the last outcome evaluation to the JSON object';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        IF l_obj_epis_noc_outcome_eval IS NOT NULL
        THEN
            l_jsn_outcome.put('LAST_EVALUATION',
                              l_obj_epis_noc_outcome_eval.to_json(i_lang => i_lang, i_prof => i_prof));
        ELSE
            l_jsn_outcome.put('LAST_EVALUATION', json());
        END IF;
        
        g_error := 'Get linked NOC indicators';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_lst_jsn_indicator      := json_list();
        l_epis_lnk_outc_ind_rows := pk_nnn_core.get_lnk_outc_ind_by_outc(i_nnn_epis_outcome => l_obj_epis_noc_outcome.id_nnn_epis_outcome,
                                                                         i_fltr_status      => pk_nnn_constant.g_req_status_ordered ||
                                                                                               pk_nnn_constant.g_req_status_ongoing ||
                                                                                               pk_nnn_constant.g_req_status_suspended ||
                                                                                               pk_nnn_constant.g_req_status_finished ||
                                                                                               pk_nnn_constant.g_req_status_expired);
        
        FOR x IN 1 .. l_epis_lnk_outc_ind_rows.count()
        LOOP
            l_nnn_epis_indicator := l_epis_lnk_outc_ind_rows(x).id_nnn_epis_indicator;
            -- Get the hierachical detail of the careplan's NOC Indicator
            l_jsn_indicator := get_epis_indicator_hier_detail(i_lang               => i_lang,
                                                              i_prof               => i_prof,
                                                              i_nnn_epis_indicator => l_nnn_epis_indicator,
                                                              i_nnn_epis_outcome   => l_obj_epis_noc_outcome.id_nnn_epis_outcome,
                                                              i_noc_outcome        => l_obj_epis_noc_outcome.id_noc_outcome);
        
            -- Append to the array of Indicators
            l_lst_jsn_indicator.append(l_jsn_indicator.to_json_value());
        END LOOP;
        -- Add the array of indicator to the Outcome object
        l_jsn_outcome.put('INDICATORS', l_lst_jsn_indicator);
         */
        RETURN l_jsn_outcome;
    END get_epis_outcome_hier_detail;

    FUNCTION get_epis_diagnosis_hier_detail
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_nnn_epis_diagnosis IN nnn_epis_diagnosis.id_nnn_epis_diagnosis%TYPE
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_epis_diagnosis_hier_detail';
        l_jsn_diagnosis            json_object_t;
        l_jsn_outcome              json_object_t;
        l_jsn_intervention         json_object_t;
        l_lst_jsn_outcome          json_array_t;
        l_lst_jsn_intervention     json_array_t;
        l_obj_nan_diagnosis        t_obj_nan_diagnosis;
        l_obj_epis_diagnosis       t_obj_nnn_epis_diagnosis;
        l_obj_epis_diag_eval       t_obj_nnn_epis_diag_eval;
        l_nnn_epis_outcome         nnn_epis_outcome.id_nnn_epis_outcome%TYPE;
        l_nnn_epis_intervention    nnn_epis_intervention.id_nnn_epis_intervention%TYPE;
        l_nnn_epis_diag_eval_ltest nnn_epis_diag_eval.id_nnn_epis_diag_eval%TYPE;
        l_epis_lnk_dg_outc_rows    ts_nnn_epis_lnk_dg_outc.nnn_epis_lnk_dg_outc_tc;
        l_epis_lnk_dg_intrv_rows   ts_nnn_epis_lnk_dg_intrv.nnn_epis_lnk_dg_intrv_tc;
    BEGIN
        /*\** Basic structure of the JSON output for a "DIAGNOSIS":
        {
          "BITEMPORAL_DATA": {},
          "HAS_HISTORICAL_CHANGES": "",
          "ID_NNN_EPIS_DIAGNOSIS": "",
          "ID_NAN_DIAGNOSIS": "",
          "CONTEXT_RECORD": {},
          "PROF_INFO": {},
          "CANCEL_INFO": {},
          "STATUS": {},
          "DT_DIAGNOSIS": "",
          "NOTES": "",
          "NANDA_DIAGNOSIS": {},
          "LAST_EVALUATION": {},
          "OUTCOMES": [],
          "INTERVENTIONS": []
        }
        *\
        
        g_error := 'Get the careplan''s NANDA Diagnosis i_nnn_epis_diagnosis = ' || to_char(i_nnn_epis_diagnosis);
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_epis_diagnosis := pk_nnn_api_db.get_epis_nan_diagnosis(i_lang               => i_lang,
                                                                     i_prof               => i_prof,
                                                                     i_nnn_epis_diagnosis => i_nnn_epis_diagnosis);
        
        g_error := 'Get info about this diagnosis from the NANDA Classification';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_obj_nan_diagnosis := pk_nan_model.get_nan_diagnosis(i_lang          => i_lang,
                                                              i_nan_diagnosis => l_obj_epis_diagnosis.id_nan_diagnosis);
        
        g_error := 'Get the last active evaluation made for this NANDA diagnosis';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        BEGIN
            SELECT \*+ opt_estimate(table t rows=1)*\
             t.id_nnn_epis_diag_eval
              INTO l_nnn_epis_diag_eval_ltest
              FROM TABLE(pk_nnn_core.tf_latest_nnn_epis_diag_eval(i_nnn_epis_diagnosis => l_obj_epis_diagnosis.id_nnn_epis_diagnosis)) t;
        
        EXCEPTION
            WHEN no_data_found THEN
                g_error := 'None evaluation has been made yet for this diagnosis (or none is active)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
                l_nnn_epis_diag_eval_ltest := NULL;
        END;
        IF l_nnn_epis_diag_eval_ltest IS NOT NULL
        THEN
            l_obj_epis_diag_eval := pk_nnn_api_db.get_epis_nan_diagnosis_eval(i_lang               => i_lang,
                                                                              i_prof               => i_prof,
                                                                              i_nnn_epis_diag_eval => l_nnn_epis_diag_eval_ltest);
        END IF;
        
        g_error := 'Initialize the JSON object that will be the output with the careplan''s diagnosis as root';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_diagnosis := l_obj_epis_diagnosis.to_json(i_lang => i_lang, i_prof => i_prof);
        
        g_error := 'Add the diagnosis info to the JSON document';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_jsn_diagnosis.put('NANDA_DIAGNOSIS', l_obj_nan_diagnosis.to_json());
        
        g_error := 'Add the last diagnosis evaluation to the JSON object';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        IF l_obj_epis_diag_eval IS NOT NULL
        THEN
            l_jsn_diagnosis.put('LAST_EVALUATION', l_obj_epis_diag_eval.to_json(i_lang => i_lang, i_prof => i_prof));
        ELSE
            l_jsn_diagnosis.put('LAST_EVALUATION', json());
        END IF;
        
        g_error := 'Get linked NOC outcomes';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_lst_jsn_outcome       := json_list();
        l_epis_lnk_dg_outc_rows := pk_nnn_core.get_lnk_dg_outc_by_diag(i_nnn_epis_diagnosis => l_obj_epis_diagnosis.id_nnn_epis_diagnosis,
                                                                       i_fltr_status        => pk_nnn_constant.g_req_status_ordered ||
                                                                                               pk_nnn_constant.g_req_status_ongoing ||
                                                                                               pk_nnn_constant.g_req_status_suspended ||
                                                                                               pk_nnn_constant.g_req_status_finished ||
                                                                                               pk_nnn_constant.g_req_status_expired);
        FOR i IN 1 .. l_epis_lnk_dg_outc_rows.count()
        LOOP
            l_nnn_epis_outcome := l_epis_lnk_dg_outc_rows(i).id_nnn_epis_outcome;
            -- Get the hierachical detail of the careplan's NOC Outcome            
            l_jsn_outcome := get_epis_outcome_hier_detail(i_lang             => i_lang,
                                                          i_prof             => i_prof,
                                                          i_nnn_epis_outcome => l_nnn_epis_outcome);
        
            --Append to the array of outcomes
            l_lst_jsn_outcome.append(l_jsn_outcome.to_json_value());
        
        END LOOP;
        -- Add the array of outcomes to the Diagnosis object
        l_jsn_diagnosis.put('OUTCOMES', l_lst_jsn_outcome);
        
        g_error := 'Get linked NIC interventions';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        l_lst_jsn_intervention   := json_list();
        l_epis_lnk_dg_intrv_rows := pk_nnn_core.get_lnk_dg_intrv_by_diag(i_nnn_epis_diagnosis => l_obj_epis_diagnosis.id_nnn_epis_diagnosis,
                                                                         i_fltr_status        => pk_nnn_constant.g_req_status_ordered ||
                                                                                                 pk_nnn_constant.g_req_status_ongoing ||
                                                                                                 pk_nnn_constant.g_req_status_suspended ||
                                                                                                 pk_nnn_constant.g_req_status_finished ||
                                                                                                 pk_nnn_constant.g_req_status_expired);
        FOR i IN 1 .. l_epis_lnk_dg_intrv_rows.count()
        LOOP
            l_nnn_epis_intervention := l_epis_lnk_dg_intrv_rows(i).id_nnn_epis_intervention;
            -- Get the hierachical detail of the careplan's NIC Intervention
            l_jsn_intervention := get_epis_interv_hier_detail(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_nnn_epis_intervention => l_nnn_epis_intervention);
        
            --Append to the array of interventions        
            l_lst_jsn_intervention.append(l_jsn_intervention.to_json_value());
        END LOOP;
        -- Add the array of interventions to the Diagnosis object
        l_jsn_diagnosis.put('INTERVENTIONS', l_lst_jsn_intervention);
        */
        RETURN l_jsn_diagnosis;
    END get_epis_diagnosis_hier_detail;

    FUNCTION get_pat_diagnoses_hier_detail
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_patient    IN patient.id_patient%TYPE,
        i_scope      IN NUMBER,
        i_scope_type IN VARCHAR2 DEFAULT pk_alert_constant.g_scope_type_episode
    ) RETURN json_object_t IS
        k_function_name CONSTANT pk_types.t_internal_name_byte := 'get_pat_diagnoses_hier_detail';
        l_jsn_document           json_object_t;
        l_jsn_diagnosis          json_object_t;
        l_lst_jsn_diagnosis      json_array_t;
        l_lst_nnn_epis_diagnosis table_number;
        l_lst_diag_name          table_varchar;
        l_patient                patient.id_patient%TYPE;
        l_visit                  visit.id_visit%TYPE;
        l_episode                episode.id_episode%TYPE;
        l_error                  t_error_out;
    BEGIN
        /*
        g_error := 'Input arguments:';
        g_error := g_error || ' i_lang = ' || coalesce(to_char(i_lang), '<null>');
        g_error := g_error || ' i_prof.id = ' || coalesce(to_char(i_prof.id), '<null>');
        g_error := g_error || ' i_prof.institution = ' || coalesce(to_char(i_prof.institution), '<null>');
        g_error := g_error || ' i_prof.software = ' || coalesce(to_char(i_prof.software), '<null>');
        g_error := g_error || ' i_patient = ' || coalesce(to_char(i_patient), '<null>');
        g_error := g_error || ' i_scope = ' || coalesce(to_char(i_scope), '<null>');
        g_error := g_error || ' i_scope_type = ' || coalesce(to_char(i_scope_type), '<null>');
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
        g_error := 'Analysing input arguments';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        IF i_patient IS NULL
           OR i_scope IS NULL
           OR i_scope_type IS NULL
        THEN
            g_error := 'An input parameter has an unexpected value';
            RAISE pk_nnn_constant.e_invalid_argument;
        END IF;
        
        g_error := 'Analysing scope type';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_scope_type,
                                              o_patient    => l_patient,
                                              o_visit      => l_visit,
                                              o_episode    => l_episode,
                                              o_error      => l_error)
        THEN
            g_error := 'Error found while calling PK_TOUCH_OPTION.GET_SCOPE_VARS';
            RAISE pk_nnn_constant.e_call_error;
        END IF;
        
        pk_alert_exceptions.assert(condition_in => i_patient = l_patient, message_in => 'The i_patient doesn''t match');
        
        g_error := 'Get the careplan''s NANDA Diagnoses for i_patient = ' || to_char(i_patient);
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => k_function_name);
        
        SELECT ed.id_nnn_epis_diagnosis,
               pk_nan_model.get_nan_diagnosis_name(i_nan_diagnosis   => ed.id_nan_diagnosis,
                                                   i_code_format     => pk_nan_model.g_code_format_end,
                                                   i_additional_info => ed.edited_diagnosis_name) diagnosis_name
          BULK COLLECT
          INTO l_lst_nnn_epis_diagnosis, l_lst_diag_name
          FROM nnn_epis_diagnosis ed
         WHERE ed.id_patient = i_patient
           AND ((l_episode IS NOT NULL AND ed.id_episode = l_episode) OR (l_episode IS NULL))
           AND ((l_visit IS NOT NULL AND ed.id_visit = l_visit) OR (l_visit IS NULL))
         ORDER BY pk_sysdomain.get_rank(i_lang     => i_lang,
                                        i_code_dom => pk_nnn_constant.g_dom_epis_diag_flg_req_status,
                                        i_val      => ed.flg_req_status),
                  diagnosis_name;
        
        l_lst_jsn_diagnosis := json_list();
        FOR i IN 1 .. l_lst_nnn_epis_diagnosis.count
        LOOP
            l_jsn_diagnosis := get_epis_diagnosis_hier_detail(i_lang               => i_lang,
                                                              i_prof               => i_prof,
                                                              i_nnn_epis_diagnosis => l_lst_nnn_epis_diagnosis(i));
            l_lst_jsn_diagnosis.append(l_jsn_diagnosis.to_json_value);
        
        END LOOP;
        l_jsn_document := json();
        l_jsn_document.put('DIAGNOSES', l_lst_jsn_diagnosis);
        */
    
        RETURN l_jsn_document;
    
    END get_pat_diagnoses_hier_detail;

    FUNCTION inactivate_nnn_tasks
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_inst      IN institution.id_institution%TYPE,
        o_has_error OUT BOOLEAN,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        IF NOT pk_nnn_core.inactivate_nnn_tasks(i_lang      => i_lang,
                                                i_prof      => i_prof,
                                                i_inst      => i_inst,
                                                o_has_error => o_has_error,
                                                o_error     => o_error)
        THEN
            RAISE pk_nnn_constant.e_invalid_argument;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'INACTIVATE_NNN_TASKS',
                                              o_error);
            RETURN FALSE;
    END inactivate_nnn_tasks;

BEGIN
    -- Initialization

    /* CAN'T TOUCH THIS */
    /* Who am I */
    alertlog.pk_alertlog.who_am_i(owner => g_owner, name => g_package);
    /* Log init */
    alertlog.pk_alertlog.log_init(object_name => g_package);
END pk_nnn_api_db;
/
