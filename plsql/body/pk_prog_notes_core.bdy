/*-- Last Change Revision: $Rev: 2053688 $*/
/*-- Last Change by: $Author: elisabete.bugalho $*/
/*-- Date of last change: $Date: 2022-12-21 11:12:37 +0000 (qua, 21 dez 2022) $*/
CREATE OR REPLACE PACKAGE BODY pk_prog_notes_core IS

    -- Private type declarations
    -- Private constant declarations  
    -- Private variable declarations    
    -- Function and procedure implementations 
    g_owner   VARCHAR2(30 CHAR);
    g_package VARCHAR2(30 CHAR);

    -- debug mode enabled/disabled
    g_debug BOOLEAN;

    -- Local variables here
    k_flag_review    CONSTANT VARCHAR2(1 CHAR) := 'V';
    k_flag_submitted CONSTANT VARCHAR2(1 CHAR) := 'B';
    k_flg_cancel     CONSTANT VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_epis_pn_flg_status_c;

    k_no CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_no;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_id_epis_pn         Progress note ID
    * @param   i_id_episode         Episode Id
    * @param   i_dt_pn_date         Note date
    * @param   i_id_dep_clin_serv   Dep_clin_serv ID
    * @param   i_id_pn_note_type    Note type ID
    * @param   i_id_pn_area         Area ID
    * @param   i_flg_synchronized   Y-single page. N-single note
    * @param   io_note_struct       Note structure data            
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  Sofia MEndes
    * @version 2.6.2
    * @since   22-Jun-2012
    */
    FUNCTION get_epis_pn_struct
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_dt_pn_date       IN epis_pn.dt_pn_date%TYPE,
        i_id_dep_clin_serv IN epis_pn.id_dep_clin_serv%TYPE,
        i_id_pn_note_type  IN epis_pn.id_pn_note_type%TYPE,
        i_id_pn_area       IN epis_pn.id_pn_area%TYPE,
        i_flg_synchronized IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_flg_definitive   IN VARCHAR2,
        i_dt_proposed      IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        io_id_epis_pn      IN OUT epis_pn.id_epis_pn%TYPE,
        io_note_struct     IN OUT NOCOPY pk_prog_notes_types.t_note_struct,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(21 CHAR) := 'GET_EPIS_PN_STRUCT';
        l_flg_create     VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_id_prof_create professional.id_professional%TYPE;
        l_area_category  pn_area.id_category%TYPE;
        l_prof_category  category.id_category%TYPE;
    BEGIN
        --If we do not receive the value from UI layer we will get it from DB
        IF io_id_epis_pn IS NULL
        THEN
            IF (i_flg_synchronized = pk_alert_constant.g_yes)
            THEN
                --autodiscover the note ID
                --The single pages like current visit will only have one note
                --every time the deepnav is accessed it is required to check if there a note already created
                g_error := 'CALL pk_prog_notes_utils.get_note_id. i_id_episode: ' || i_id_episode ||
                           ' i_id_pn_note_type: ' || i_id_pn_note_type;
                IF NOT pk_prog_notes_utils.get_note_id(i_lang            => i_lang,
                                                       i_prof            => i_prof,
                                                       i_id_episode      => i_id_episode,
                                                       i_id_pn_note_type => i_id_pn_note_type,
                                                       o_id_epis_pn      => io_id_epis_pn,
                                                       o_error           => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            IF (io_id_epis_pn IS NULL)
            THEN
                IF i_id_pn_area IN
                   (pk_prog_notes_constants.g_area_nursing_assessment_5, pk_prog_notes_constants.g_area_current_visit_3)
                THEN
                    g_error         := 'GET PROF CATEGORY';
                    l_prof_category := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
                
                    g_error := 'GET PN_AREA CATEGORY';
                    SELECT a.id_category
                      INTO l_area_category
                      FROM pn_area a
                     WHERE a.id_pn_area = i_id_pn_area;
                
                    /*TODO ALERT-333578
                    * Create table pn_area_category and related with pn_area (id_category) (substitute field id_category)
                    * Change in all code related
                    */
                    IF l_prof_category = l_area_category
                       OR (l_prof_category = 26 AND l_area_category = pk_prog_notes_constants.g_area_pn_2)
                    THEN
                        io_id_epis_pn    := ts_epis_pn.next_key;
                        l_flg_create     := pk_alert_constant.g_yes;
                        l_id_prof_create := i_prof.id;
                    END IF;
                
                ELSE
                    io_id_epis_pn    := ts_epis_pn.next_key;
                    l_flg_create     := pk_alert_constant.g_yes;
                    l_id_prof_create := i_prof.id;
                END IF;
            
            END IF;
        
        ELSE
            io_id_epis_pn := io_id_epis_pn;
        END IF;
    
        io_note_struct.id_epis_pn := io_id_epis_pn;
        IF (l_flg_create = pk_alert_constant.g_yes)
        THEN
            io_note_struct.id_episode       := i_id_episode;
            io_note_struct.id_professional  := l_id_prof_create;
            io_note_struct.dt_pn_date := CASE
                                             WHEN i_dt_pn_date IS NULL THEN
                                              current_timestamp
                                             ELSE
                                              i_dt_pn_date
                                         END;
            io_note_struct.id_dep_clin_serv := i_id_dep_clin_serv;
            io_note_struct.id_pn_note_type  := i_id_pn_note_type;
            io_note_struct.id_pn_area       := i_id_pn_area;
        
            IF i_dt_proposed IS NOT NULL
            THEN
                g_error := '[get_epis_pn_struct]pk_date_utils.get_string_tstz. i_dt_proposed: ' || i_dt_proposed ||
                           ' io_note_struct.dt_proposed: ' || io_note_struct.dt_proposed;
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                io_note_struct.dt_proposed := nvl(i_dt_proposed, io_note_struct.dt_proposed);
            END IF;
        END IF;
        io_note_struct.id_episode     := i_id_episode;
        io_note_struct.flg_auto_saved := CASE
                                             WHEN i_flg_definitive = pk_alert_constant.g_no THEN
                                              pk_alert_constant.g_yes
                                             ELSE
                                              pk_alert_constant.g_no
                                         END;
        io_note_struct.flg_create     := l_flg_create;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_epis_pn_struct;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_epis_pn            Progress note ID
    * @param   i_pn_soap_block      SOAP Block ID
    * @param   i_pn_data_block      Data Block ID
    * @param   i_flg_status         Detail status
    * @param   i_pn_note            Detail note
    * @param   i_dt_pn_date         Note date
    * @param   i_flg_aggregate_data Y-the data of this data block should be aggregated in free text. N-Otherwise
    * @param   i_flg_scope          Scope (E- Episode, V- Visit, P- Patient)
    * @param   io_note_struct       Note structure data            
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  Sofia MEndes
    * @version 2.6.2
    * @since   22-Jun-2012
    */
    FUNCTION get_epis_pn_det_struct
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_epis_pn            IN epis_pn.id_epis_pn%TYPE,
        i_soap_block         IN epis_pn_det.id_pn_soap_block%TYPE,
        i_data_block         IN epis_pn_det.id_pn_data_block%TYPE,
        i_flg_status         IN epis_pn_det.flg_status%TYPE,
        i_pn_note            IN epis_pn_det.pn_note%TYPE,
        i_dt_pn_note         IN epis_pn_det.dt_note%TYPE,
        i_flg_type           IN pn_data_block.flg_type%TYPE,
        i_flg_aggregate_data IN pn_dblock_mkt.flg_group_on_import%TYPE,
        i_flg_app_upd        IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_scope          VARCHAR2,
        i_flg_group_type     IN VARCHAR2 DEFAULT NULL,
        io_epis_pn_det       IN OUT epis_pn_det.id_epis_pn_det%TYPE,
        io_note_struct       IN OUT NOCOPY pk_prog_notes_types.t_note_struct,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'GET_EPIS_PN_DET_STRUCT';
        l_flg_create VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_flg_type     pn_data_block.flg_type%TYPE := i_flg_type;
        l_professional epis_pn_det.id_professional%TYPE;
    
    BEGIN
    
        --If we do not receive the value from UI layer we will get it from DB
        IF io_epis_pn_det IS NULL
        THEN
            g_error := 'CALL pk_prog_notes_utils.get_epispn_det_by_block. i_epis_pn: ' || i_epis_pn ||
                       ' i_soap_block: ' || i_soap_block || ' i_data_block: ' || i_data_block;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            io_epis_pn_det := pk_prog_notes_utils.get_epispn_det_by_block(i_epis_pn    => i_epis_pn,
                                                                          i_soap_block => i_soap_block,
                                                                          i_data_block => i_data_block);
        
            IF (io_epis_pn_det IS NULL)
            THEN
                g_error := 'GENerating new id_epis_pn_det';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                io_epis_pn_det := ts_epis_pn_det.next_key;
                l_flg_create   := pk_alert_constant.g_yes;
                l_professional := i_prof.id;
            END IF;
        END IF;
    
        IF (l_flg_type IS NULL)
        THEN
            g_error := 'CALL pk_prog_notes_utils.get_data_block_type. i_pn_data_block: ' || i_data_block;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_flg_type := pk_prog_notes_utils.get_data_block_type(i_lang             => i_lang,
                                                                  i_prof             => i_prof,
                                                                  i_id_pn_data_block => i_data_block);
        END IF;
    
        IF (l_flg_type = pk_prog_notes_constants.g_data_block_cdate)
        THEN
            io_note_struct.dt_pn_date := i_dt_pn_note;
        END IF;
    
        IF NOT (io_note_struct.tbl_dblock_det.exists(io_epis_pn_det))
        THEN
            io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_create := l_flg_create;
            io_note_struct.tbl_dblock_det(io_epis_pn_det).id_epis_pn := i_epis_pn;
            io_note_struct.tbl_dblock_det(io_epis_pn_det).id_pn_soap_block := i_soap_block;
            io_note_struct.tbl_dblock_det(io_epis_pn_det).id_pn_data_block := i_data_block;
        
            io_note_struct.tbl_dblock_det(io_epis_pn_det).id_professional := l_professional;
        
        END IF;
    
        io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_aggregate_data := i_flg_aggregate_data;
        io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_group_type := i_flg_group_type;
    
        IF (l_flg_type = pk_prog_notes_constants.g_dblock_table)
        THEN
            io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_update_ranks := pk_alert_constant.g_yes;
            io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_scope := i_flg_scope;
        END IF;
    
        io_note_struct.tbl_dblock_det(io_epis_pn_det).id_epis_pn_det := io_epis_pn_det;
        io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_status := i_flg_status;
    
        io_note_struct.tbl_dblock_det(io_epis_pn_det).pn_note := CASE
                                                                     WHEN i_flg_app_upd = pk_prog_notes_constants.g_append_a
                                                                          AND i_pn_note IS NOT NULL THEN
                                                                      pk_string_utils.trim_empty_lines(i_pn_note) ||
                                                                      pk_prog_notes_constants.g_new_line || io_note_struct.tbl_dblock_det(io_epis_pn_det).pn_note
                                                                     ELSE
                                                                      i_pn_note
                                                                 END;
        io_note_struct.tbl_dblock_det(io_epis_pn_det).dt_note := i_dt_pn_note;
        io_note_struct.tbl_dblock_det(io_epis_pn_det).flg_app_upd := i_flg_app_upd;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_epis_pn_det_struct;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_epis_pn            Progress note ID
    * @param   i_epis_pn_det        Progress note detail ID
    * @param   i_pn_soap_block      SOAP Block ID
    * @param   i_pn_data_block      Data Block ID
    * @param   i_flg_status         Detail status
    * @param   i_pn_note            Detail note
    * @param   i_dt_last_upd_task   Last update date od the task
    * @param   i_id_task_parent     Parent task id
    * @param   i_dt_group_import    Aggregation info: Date: 1st aggregation level
    * @param   i_id_group_import    Aggregation info: Group: 2nd aggregation level
    * @param   i_code_desc_group    Aggregation info: Group desc
    * @param   i_id_sub_group_import Aggregation info: Sub-Group: 3rd aggregation level
    * @param   i_code_desc_sub_group Aggregation info: Sub-Group desc
    * @param   i_id_group_table       Table row id (to be used on vital signs table)
    * @param   i_flg_aggregate_data Y-the data of this data block should be aggregated in free text. N-Otherwise
    * @param   i_table_position         Table column position
    * @param   i_id_prof_review     Professional that performed the last review of the record
    * @param   i_dt_review          Date in which was performed the last review of the record
    * @param   i_flg_status         Status of the task
    * @param   i_flg_action         Action being performed: A - auto-population, I - import, S-shortuct
    * @param   i_id_sample_type      Sample type id. Only used for analysis results to join to the sub group desc
    * @param   i_code_desc_sample_type Sample type code desc. Only used for analysis results to join to the sub group desc
    * @param   io_note_struct       Note structure data            
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  Sofia MEndes
    * @version 2.6.2
    * @since   22-Jun-2012
    */
    FUNCTION get_epis_pn_det_task_struct
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_episode             IN episode.id_episode%TYPE,
        i_id_task                IN epis_pn_det_task.id_task%TYPE,
        i_id_task_type           IN epis_pn_det_task.id_task_type%TYPE,
        i_id_epis_pn_det         IN epis_pn_det.id_epis_pn_det%TYPE,
        i_id_task_aggregator     IN epis_pn_det_task.id_task_aggregator%TYPE,
        i_flg_status             IN epis_pn_det_task.flg_status%TYPE,
        i_pn_note                IN epis_pn_det_task.pn_note%TYPE,
        i_flg_table_origin       IN epis_pn_det_task.flg_table_origin%TYPE,
        i_dt_task                IN epis_pn_det_task.dt_task%TYPE,
        i_id_parent              IN epis_pn_det_task.id_parent%TYPE,
        i_rank_task              IN epis_pn_det_task.rank_task%TYPE,
        i_id_prof_task           IN epis_pn_det_task.id_prof_task%TYPE,
        i_id_epis_pn_det_task    IN epis_pn_det_task.id_epis_pn_det_task%TYPE,
        i_id_task_parent         IN task_timeline_ea.id_parent_comments%TYPE,
        i_dt_group_import        IN epis_pn_det_task.dt_group_import%TYPE,
        i_id_group_import        IN epis_pn_det_task.id_group_import%TYPE,
        i_code_desc_group        IN epis_pn_det_task.code_desc_group%TYPE,
        i_desc_group             IN VARCHAR2,
        i_id_sub_group_import    IN epis_pn_det_task.id_sub_group_import%TYPE,
        i_code_desc_sub_group    IN epis_pn_det_task.code_desc_sub_group%TYPE,
        i_id_sample_type         IN epis_pn_det_task.id_sample_type%TYPE,
        i_code_desc_sample_type  IN epis_pn_det_task.code_desc_sample_type%TYPE,
        i_id_group_table         IN epis_pn_det_task.id_group_table%TYPE,
        i_flg_aggregate_data     IN pn_dblock_mkt.flg_group_on_import%TYPE,
        i_table_position         IN epis_pn_det_task.table_position%TYPE,
        i_code_description       IN task_timeline_ea.code_description%TYPE,
        i_universal_desc_clob    IN task_timeline_ea.universal_desc_clob%TYPE,
        i_flg_sos                IN task_timeline_ea.flg_sos%TYPE,
        i_dt_begin               IN task_timeline_ea.dt_begin%TYPE,
        i_id_doc_area            IN task_timeline_ea.id_doc_area%TYPE,
        i_dt_register            IN task_timeline_ea.dt_req%TYPE,
        i_flg_show_sub_title     IN pn_dblock_mkt.flg_show_sub_title%TYPE,
        i_id_prof_review         IN epis_pn_det_task.id_prof_review%TYPE,
        i_dt_review              IN epis_pn_det_task.dt_review%TYPE,
        i_code_status            IN task_timeline_ea.code_status%TYPE,
        i_flg_status_req         IN task_timeline_ea.flg_status_req%TYPE,
        i_end_date               IN task_timeline_ea.dt_end%TYPE,
        i_dt_req                 IN task_timeline_ea.dt_req%TYPE,
        i_id_task_notes          IN task_timeline_ea.id_task_notes%TYPE,
        i_flg_action             IN epis_pn_det_task.flg_action%TYPE,
        i_flg_description        IN pn_dblock_ttp_mkt.flg_description%TYPE,
        i_description_condition  IN pn_dblock_ttp_mkt.description_condition%TYPE,
        i_code_desc_group_parent IN epis_pn_det_task.code_desc_group_parent%TYPE,
        i_instructions_hash      IN epis_pn_det_task.instructions_hash%TYPE,
        o_rec_task               OUT pk_prog_notes_types.t_rec_tasks,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(27 CHAR) := 'GET_EPIS_PN_DET_TASK_STRUCT';
        l_flg_create          VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_id_epis_pn_det_task epis_pn_det_task.id_epis_pn_det_task%TYPE := i_id_epis_pn_det_task;
        l_desc                CLOB;
        l_detailed_desc       CLOB;
    BEGIN
    
        IF i_id_epis_pn_det_task IS NULL
        THEN
            --check if the record had already been saved in the note
            BEGIN
                SELECT e.id_epis_pn_det_task
                  INTO l_id_epis_pn_det_task
                  FROM epis_pn_det_task e
                 WHERE e.id_epis_pn_det = i_id_epis_pn_det
                   AND e.id_task = i_id_task
                   AND e.id_task_type = i_id_task_type
                   AND nvl(e.id_task_aggregator, -1) = nvl(i_id_task_aggregator, -1)
                   AND e.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_epis_pn_det_task := NULL;
            END;
        
        END IF;
    
        g_error := 'get_epis_pn_det_task_struct. i_id_epis_pn_det_task: ' || i_id_epis_pn_det_task;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        --If we do not receive the value from UI layer we will get it from DB
        IF l_id_epis_pn_det_task IS NULL
        THEN
            l_id_epis_pn_det_task := ts_epis_pn_det_task.next_key;
            l_flg_create          := pk_alert_constant.g_yes;
            o_rec_task.flg_action := i_flg_action;
        END IF;
    
        o_rec_task.id_epis_pn_det     := i_id_epis_pn_det;
        o_rec_task.id_task            := i_id_task;
        o_rec_task.id_task_aggregator := i_id_task_aggregator;
        o_rec_task.id_task_type       := i_id_task_type;
        o_rec_task.flg_status         := i_flg_status;
    
        IF (i_pn_note IS NOT NULL)
        THEN
            o_rec_task.pn_note := i_pn_note;
        ELSE
        
            g_error := 'call pk_prog_notes_in.get_detailed_desc_all';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            IF (i_flg_description = 'C')
            THEN
                g_error := 'call pk_prog_notes_in.get_task_description';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_prog_notes_in.get_task_description(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_id_episode            => i_id_episode,
                                                             i_id_patient            => pk_episode.get_id_patient(i_episode => i_id_episode),
                                                             i_id_task_type          => i_id_task_type,
                                                             i_id_task               => i_id_task,
                                                             i_code_description      => i_code_description,
                                                             i_universal_desc_clob   => i_universal_desc_clob,
                                                             i_flg_sos               => i_flg_sos,
                                                             i_dt_begin              => i_dt_begin,
                                                             i_id_task_aggregator    => i_id_task_aggregator,
                                                             i_id_doc_area           => i_id_doc_area,
                                                             i_code_status           => i_code_status,
                                                             i_flg_status            => i_flg_status_req,
                                                             i_end_date              => i_end_date,
                                                             i_dt_req                => i_dt_req,
                                                             i_id_task_notes         => i_id_task_notes,
                                                             i_code_desc_sample_type => i_code_desc_sample_type,
                                                             i_flg_description       => i_flg_description,
                                                             i_description_condition => i_description_condition,
                                                             o_short_desc            => l_desc,
                                                             o_detailed_desc         => l_detailed_desc)
                THEN
                    RAISE g_exception;
                END IF;
            ELSE
            
                l_detailed_desc := pk_prog_notes_in.get_detailed_desc_all(i_lang                  => i_lang,
                                                                          i_prof                  => i_prof,
                                                                          i_id_episode            => i_id_episode,
                                                                          i_id_task_type          => i_id_task_type,
                                                                          i_id_task               => i_id_task,
                                                                          i_universal_description => i_universal_desc_clob,
                                                                          i_short_desc            => l_desc,
                                                                          i_code_description      => i_code_description,
                                                                          i_flg_description       => i_flg_description,
                                                                          i_description_condition => i_description_condition);
            
                IF (l_detailed_desc IS NULL OR dbms_lob.compare(l_detailed_desc, empty_clob()) = 0)
                THEN
                    g_error := 'call pk_prog_notes_in.get_task_description';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT pk_prog_notes_in.get_task_description(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_id_episode            => i_id_episode,
                                                                 i_id_patient            => pk_episode.get_id_patient(i_episode => i_id_episode),
                                                                 i_id_task_type          => i_id_task_type,
                                                                 i_id_task               => i_id_task,
                                                                 i_code_description      => i_code_description,
                                                                 i_universal_desc_clob   => i_universal_desc_clob,
                                                                 i_flg_sos               => i_flg_sos,
                                                                 i_dt_begin              => i_dt_begin,
                                                                 i_id_task_aggregator    => i_id_task_aggregator,
                                                                 i_id_doc_area           => i_id_doc_area,
                                                                 i_code_status           => i_code_status,
                                                                 i_flg_status            => i_flg_status_req,
                                                                 i_end_date              => i_end_date,
                                                                 i_dt_req                => i_dt_req,
                                                                 i_id_task_notes         => i_id_task_notes,
                                                                 i_code_desc_sample_type => i_code_desc_sample_type,
                                                                 i_flg_description       => i_flg_description,
                                                                 i_description_condition => i_description_condition,
                                                                 o_short_desc            => l_desc,
                                                                 o_detailed_desc         => l_detailed_desc)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            END IF;
        
            IF l_detailed_desc IS NULL
               OR dbms_lob.compare(l_detailed_desc, empty_clob()) = 0
            THEN
                l_detailed_desc := l_desc;
            END IF;
        
            g_error := 'call pk_prog_notes_utils.get_date';
            pk_alertlog.log_debug(g_error);
            o_rec_task.pn_note := l_detailed_desc;
        END IF;
    
        o_rec_task.flg_table_origin    := i_flg_table_origin;
        o_rec_task.dt_task             := i_dt_task;
        o_rec_task.id_parent           := i_id_parent;
        o_rec_task.rank_task           := i_rank_task;
        o_rec_task.id_prof_task        := i_id_prof_task;
        o_rec_task.id_epis_pn_det_task := l_id_epis_pn_det_task;
        o_rec_task.flg_create          := l_flg_create;
        o_rec_task.id_task_parent      := i_id_task_parent;
    
        IF (i_id_task_parent IS NOT NULL)
        THEN
            o_rec_task.flg_find_parent := pk_alert_constant.g_yes;
        END IF;
    
        o_rec_task.dt_group_import        := i_dt_group_import;
        o_rec_task.id_group_import        := i_id_group_import;
        o_rec_task.desc_group             := i_desc_group;
        o_rec_task.code_desc_group        := i_code_desc_group;
        o_rec_task.code_desc_sub_group    := i_code_desc_sub_group;
        o_rec_task.id_sub_group_import    := i_id_sub_group_import;
        o_rec_task.id_group_table         := i_id_group_table;
        o_rec_task.table_position         := i_table_position;
        o_rec_task.flg_show_sub_title     := i_flg_show_sub_title;
        o_rec_task.id_prof_review         := i_id_prof_review;
        o_rec_task.dt_review              := i_dt_review;
        o_rec_task.id_task_notes          := i_id_task_notes;
        o_rec_task.id_sample_type         := i_id_sample_type;
        o_rec_task.code_desc_sample_type  := i_code_desc_sample_type;
        o_rec_task.dt_req_task            := i_dt_register;
        o_rec_task.code_desc_group_parent := i_code_desc_group_parent;
        o_rec_task.instructions_hash      := i_instructions_hash;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_epis_pn_det_task_struct;

    /**
    * Create/update a Progress Notes Addendum
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   i_epis_pn             Progress Notes ID
    * @param   i_flg_type            Type of addendum
    * @param   i_id_epis_pn_addendum Addendum ID
    * @param   i_pn_addendum         Progress Notes Addendum (text)
    * @param   i_area                Area name
    *  
    * @param   o_epis_pn_addendum    PN Addendum ID created or updated
    * @param   o_error               Error information
    *
    * @return  Boolean               True: Sucess, False: Fail
    *
    * @author  RUI.BATISTA
    * @version <2.6.0.5>
    * @since   31-01-2011
    */
    FUNCTION set_pn_addendum
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_flg_type            IN epis_pn_addendum.flg_type%TYPE,
        i_id_epis_pn_addendum IN epis_pn_addendum.id_epis_pn_addendum%TYPE,
        i_pn_addendum         IN epis_pn_addendum.pn_addendum%TYPE,
        o_epis_pn_addendum    OUT epis_pn_addendum.id_epis_pn_addendum%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        IF NOT set_pn_addendum_internal(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_epis_pn          => i_id_epis_pn,
                                        i_flg_type            => i_flg_type,
                                        i_id_epis_pn_addendum => i_id_epis_pn_addendum,
                                        i_pn_addendum         => i_pn_addendum,
                                        i_dt_addendum         => g_sysdate_tstz,
                                        i_last_update_date    => NULL,
                                        o_epis_pn_addendum    => o_epis_pn_addendum,
                                        o_error               => o_error)
        THEN
            RETURN FALSE;
        
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_PN_ADDENDUM',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_pn_addendum;

    /**
    * Create/update a Progress Notes Addendum
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   i_epis_pn             Progress Notes ID
    * @param   i_flg_type            Type of addendum
    * @param   i_id_epis_pn_addendum Addendum ID
    * @param   i_pn_addendum         Progress Notes Addendum (text)
    * @param   i_area                Area Name to check max addendums allowed
    * @param   i_dt_addendum         Addendum date
    *  
    * @param   o_epis_pn_addendum    PN Addendum ID created or updated
    * @param   o_error               Error information
    *
    * @return  Boolean               True: Sucess, False: Fail
    *
    * @author  RUI.BATISTA
    * @version <2.6.0.5>
    * @since   31-01-2011
    */
    FUNCTION set_pn_addendum_internal
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_flg_type            IN epis_pn_addendum.flg_type%TYPE DEFAULT pk_prog_notes_constants.g_epa_flg_type_addendum,
        i_id_epis_pn_addendum IN epis_pn_addendum.id_epis_pn_addendum%TYPE,
        i_pn_addendum         IN epis_pn_addendum.pn_addendum%TYPE,
        i_dt_addendum         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_last_update_date    IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_epis_pn_addendum    OUT epis_pn_addendum.id_epis_pn_addendum%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_PN_ADDENDUM_INTERNAL';
        l_rows_out       table_varchar;
        l_dt_addendum    TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_last_update TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_create_avail PLS_INTEGER;
        l_creation_unavailable_exc EXCEPTION;
    
        CURSOR c_addendum IS
            SELECT id_epis_pn_addendum,
                   id_epis_pn,
                   flg_status,
                   id_professional,
                   dt_addendum,
                   pn_addendum,
                   dt_signoff,
                   id_prof_signoff,
                   id_prof_cancel,
                   id_cancel_reason,
                   dt_cancel,
                   notes_cancel,
                   dt_last_update,
                   id_prof_last_update,
                   flg_type
              FROM epis_pn_addendum ea
             WHERE ea.id_epis_pn_addendum = i_id_epis_pn_addendum;
    
        l_epis_pn_addendum epis_pn_addendum%ROWTYPE;
    
    BEGIN
    
        l_dt_last_update := nvl(g_sysdate_tstz, current_timestamp);
        l_dt_addendum    := nvl(i_dt_addendum, l_dt_last_update);
    
        IF i_id_epis_pn_addendum IS NULL
        THEN
            IF i_flg_type = pk_prog_notes_constants.g_epa_flg_type_addendum
            THEN
                --check if it is possible to create more adendums
                IF NOT pk_prog_notes_utils.check_max_draft_addendums(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_id_epis_pn   => i_id_epis_pn,
                                                                     o_create_avail => l_create_avail,
                                                                     o_error        => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                IF (l_create_avail = 0)
                THEN
                    RAISE l_creation_unavailable_exc;
                END IF;
            END IF;
            --Create new addendum
            g_error := 'Create new addendum';
            pk_alertlog.log_info(text            => g_error,
                                 object_name     => g_package,
                                 sub_object_name => 'SET_PN_ADDENDUM_INTERNAL');
        
            o_epis_pn_addendum := ts_epis_pn_addendum.next_key;
            ts_epis_pn_addendum.ins(id_epis_pn_addendum_in => o_epis_pn_addendum,
                                    id_epis_pn_in          => i_id_epis_pn,
                                    flg_status_in          => pk_prog_notes_constants.g_pn_draft,
                                    id_professional_in     => i_prof.id,
                                    dt_addendum_in         => l_dt_addendum,
                                    pn_addendum_in         => i_pn_addendum,
                                    flg_type_in            => i_flg_type,
                                    rows_out               => l_rows_out);
        
            g_error := 'PROCESS INSERT epis_pn_addendum WITH id_epis_pn_addendum: ' || o_epis_pn_addendum;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN_ADDENDUM',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
        ELSE
            --Create history record
            g_error := 'Create addendum history record';
            pk_alertlog.log_info(text            => g_error,
                                 object_name     => g_package,
                                 sub_object_name => 'SET_PN_ADDENDUM_INTERNAL');
            OPEN c_addendum;
            FETCH c_addendum
                INTO l_epis_pn_addendum.id_epis_pn_addendum,
                     l_epis_pn_addendum.id_epis_pn,
                     l_epis_pn_addendum.flg_status,
                     l_epis_pn_addendum.id_professional,
                     l_epis_pn_addendum.dt_addendum,
                     l_epis_pn_addendum.pn_addendum,
                     l_epis_pn_addendum.dt_signoff,
                     l_epis_pn_addendum.id_prof_signoff,
                     l_epis_pn_addendum.id_prof_cancel,
                     l_epis_pn_addendum.id_cancel_reason,
                     l_epis_pn_addendum.dt_cancel,
                     l_epis_pn_addendum.notes_cancel,
                     l_epis_pn_addendum.dt_last_update,
                     l_epis_pn_addendum.id_prof_last_update,
                     l_epis_pn_addendum.flg_type;
            CLOSE c_addendum;
        
            ts_epis_pn_addendum_hist.ins(id_epis_pn_addendum_in   => l_epis_pn_addendum.id_epis_pn_addendum,
                                         dt_epis_addendum_hist_in => l_dt_last_update,
                                         id_epis_pn_in            => l_epis_pn_addendum.id_epis_pn,
                                         flg_status_in            => l_epis_pn_addendum.flg_status,
                                         id_professional_in       => l_epis_pn_addendum.id_professional,
                                         dt_addendum_in           => l_epis_pn_addendum.dt_addendum,
                                         pn_addendum_in           => l_epis_pn_addendum.pn_addendum,
                                         dt_signoff_in            => l_epis_pn_addendum.dt_signoff,
                                         id_prof_signoff_in       => l_epis_pn_addendum.id_prof_signoff,
                                         id_prof_cancel_in        => l_epis_pn_addendum.id_prof_cancel,
                                         id_cancel_reason_in      => l_epis_pn_addendum.id_cancel_reason,
                                         dt_cancel_in             => l_epis_pn_addendum.dt_cancel,
                                         notes_cancel_in          => l_epis_pn_addendum.notes_cancel,
                                         dt_last_update_in        => l_epis_pn_addendum.dt_last_update,
                                         id_prof_last_update_in   => l_epis_pn_addendum.id_prof_last_update,
                                         flg_type_in              => l_epis_pn_addendum.flg_type,
                                         rows_out                 => l_rows_out);
        
            g_error := 'PROCESS INSERT epis_pn_addendum_hist WITH id_epis_pn_addendum: ' ||
                       l_epis_pn_addendum.id_epis_pn_addendum;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN_ADDENDUM_HIST',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            --update existing addendum    
            g_error := 'Update addendum';
            pk_alertlog.log_info(text            => g_error,
                                 object_name     => g_package,
                                 sub_object_name => 'SET_PN_ADDENDUM_INTERNAL');
            ts_epis_pn_addendum.upd(id_epis_pn_addendum_in => i_id_epis_pn_addendum,
                                    pn_addendum_in         => i_pn_addendum,
                                    dt_last_update_in      => nvl(i_last_update_date, l_dt_last_update),
                                    id_prof_last_update_in => i_prof.id,
                                    rows_out               => l_rows_out);
        
            g_error := 'PROCESS UPDATE epis_pn_addendum WITH i_id_epis_pn_addendum: ' || i_id_epis_pn_addendum;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_PN_ADDENDUM',
                                          i_rowids       => l_rows_out,
                                          i_list_columns => table_varchar('PN_ADDENDUM',
                                                                          'DT_LAST_UPDATE',
                                                                          'ID_PROF_LAST_UPDATE'),
                                          o_error        => o_error);
        END IF;
    
        o_epis_pn_addendum := nvl(o_epis_pn_addendum, i_id_epis_pn_addendum);
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_creation_unavailable_exc THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => pk_prog_notes_constants.g_max_addendums_reached,
                                              i_sqlerrm  => pk_message.get_message(i_lang      => i_lang,
                                                                                   i_code_mess => pk_prog_notes_constants.g_max_addendums_reached),
                                              i_message  => pk_message.get_message(i_lang      => i_lang,
                                                                                   i_code_mess => pk_prog_notes_constants.g_msg_error),
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_PN_ADDENDUM_INTERNAL',
                                              o_error    => o_error);
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_PN_ADDENDUM_INTERNAL',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_pn_addendum_internal;

    /**
    * Cancel a Progress Notes Addendum
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn_addendum      Progress Notes ID
    * @param   i_cancel_reason  Cancel reason ID
    * @param   i_notes_cancel Cancel notes
    *
    * @param   o_epis_pn      Progress note ID  (null if non-existent)  
    * @param   o_error        Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    *
    * @author  RUI.BATISTA
    * @version <2.6.0.5>
    * @since   31-01-2011
    */
    FUNCTION cancel_pn_addendum
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_pn_addendum IN epis_pn_addendum.id_epis_pn_addendum%TYPE,
        i_cancel_reason    IN cancel_reason.id_cancel_reason%TYPE,
        i_notes_cancel     IN epis_pn_addendum.notes_cancel%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'CANCEL_PN_ADDENDUM';
    
        CURSOR c_addendum IS
            SELECT ea.id_epis_pn_addendum,
                   ea.id_epis_pn,
                   ea.flg_status,
                   ea.id_professional,
                   ea.dt_addendum,
                   ea.pn_addendum,
                   ea.dt_signoff,
                   ea.id_prof_signoff,
                   ea.id_prof_cancel,
                   ea.id_cancel_reason,
                   ea.dt_cancel,
                   ea.notes_cancel,
                   ea.flg_type
              FROM epis_pn_addendum ea
             WHERE ea.id_epis_pn_addendum = i_epis_pn_addendum;
    
        l_epis_pn_addendum epis_pn_addendum%ROWTYPE;
        l_rows_out         table_varchar;
        l_dt_last_update   TIMESTAMP WITH LOCAL TIME ZONE;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_dt_last_update := g_sysdate_tstz;
    
        g_error := 'Get PN addendum to cancel';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_addendum;
        FETCH c_addendum
            INTO l_epis_pn_addendum.id_epis_pn_addendum,
                 l_epis_pn_addendum.id_epis_pn,
                 l_epis_pn_addendum.flg_status,
                 l_epis_pn_addendum.id_professional,
                 l_epis_pn_addendum.dt_addendum,
                 l_epis_pn_addendum.pn_addendum,
                 l_epis_pn_addendum.dt_signoff,
                 l_epis_pn_addendum.id_prof_signoff,
                 l_epis_pn_addendum.id_prof_cancel,
                 l_epis_pn_addendum.id_cancel_reason,
                 l_epis_pn_addendum.dt_cancel,
                 l_epis_pn_addendum.notes_cancel,
                 l_epis_pn_addendum.flg_type;
        CLOSE c_addendum;
    
        --Validate addendum status
        -- Can only cancel addendum if not cancelled already    
        IF nvl(l_epis_pn_addendum.flg_status, '@') = pk_prog_notes_constants.g_addendum_status_c
        THEN
            g_error := 'Cannot cancel a PN addendum already cancelled';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            RETURN TRUE;
        END IF;
    
        --insert history record
        g_error := 'Create PN addendum history record';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        ts_epis_pn_addendum_hist.ins(id_epis_pn_addendum_in   => l_epis_pn_addendum.id_epis_pn_addendum,
                                     dt_epis_addendum_hist_in => l_dt_last_update,
                                     id_epis_pn_in            => l_epis_pn_addendum.id_epis_pn,
                                     flg_status_in            => l_epis_pn_addendum.flg_status,
                                     id_professional_in       => l_epis_pn_addendum.id_professional,
                                     dt_addendum_in           => l_epis_pn_addendum.dt_addendum,
                                     pn_addendum_in           => l_epis_pn_addendum.pn_addendum,
                                     dt_signoff_in            => l_epis_pn_addendum.dt_signoff,
                                     id_prof_signoff_in       => l_epis_pn_addendum.id_prof_signoff,
                                     id_prof_cancel_in        => l_epis_pn_addendum.id_prof_cancel,
                                     id_cancel_reason_in      => l_epis_pn_addendum.id_cancel_reason,
                                     dt_cancel_in             => l_epis_pn_addendum.dt_cancel,
                                     notes_cancel_in          => l_epis_pn_addendum.notes_cancel,
                                     flg_type_in              => l_epis_pn_addendum.flg_type,
                                     rows_out                 => l_rows_out);
    
        g_error := 'PROCESS INSERT epis_pn_addendum_hist WITH id_epis_pn_addendum: ' ||
                   l_epis_pn_addendum.id_epis_pn_addendum;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_ADDENDUM_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        --Cancel PN addendum
        g_error := 'Cancel PN addendum';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        ts_epis_pn_addendum.upd(id_epis_pn_addendum_in => l_epis_pn_addendum.id_epis_pn_addendum,
                                flg_status_in          => pk_prog_notes_constants.g_addendum_status_c,
                                id_prof_cancel_in      => i_prof.id,
                                id_cancel_reason_in    => i_cancel_reason,
                                dt_cancel_in           => l_dt_last_update,
                                notes_cancel_in        => i_notes_cancel,
                                rows_out               => l_rows_out);
    
        g_error := 'PROCESS UPDATE epis_pn_addendum WITH i_id_epis_pn_addendum: ' ||
                   l_epis_pn_addendum.id_epis_pn_addendum;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN_ADDENDUM',
                                      i_rowids       => l_rows_out,
                                      i_list_columns => table_varchar('FLG_STATUS',
                                                                      'ID_PROF_CANCEL',
                                                                      'ID_CANCEL_REASON',
                                                                      'DT_CANCEL',
                                                                      'NOTES_CANCEL'),
                                      o_error        => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'CANCEL_PN_ADDENDUM',
                                              o_error    => o_error);
            RETURN FALSE;
    END cancel_pn_addendum;

    /**
    * Sign-Off an addendum
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   i_epis_pn             Progress Notes ID    
    * @param   i_epis_pn_addendum    Addendum to signoff
    * @param   i_pn_addendum         Progress Notes Addendum (text)
    * @param   i_dt_signoff          Sign-off date
    * @param   i_flg_just_save       Just Save flag (Y- Just Save, N- Sign-off
    * @param   i_flg_edited          Edited addentum? (Y- Yes, N- No)
    * @param   i_flg_hist            Must generate history record? (Y- Yes, N- No)
    *
    * @param   o_epis_pn_addendum    PN Addendum ID created or updated
    * @param   o_error        Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    *
    * @author  RUI.BATISTA
    * @version <2.6.0.5>
    * @since   01-02-2011
    */
    FUNCTION set_signoff_addendum
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        i_epis_pn_addendum IN epis_pn_addendum.id_epis_pn_addendum%TYPE,
        i_pn_addendum      IN epis_pn_addendum.pn_addendum%TYPE,
        i_dt_signoff       IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_just_save    IN VARCHAR2,
        i_flg_edited       IN VARCHAR2,
        i_flg_hist         IN VARCHAR2 DEFAULT 'Y',
        o_epis_pn_addendum OUT epis_pn_addendum.id_epis_pn_addendum%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_addendum IS
            SELECT ea.id_epis_pn_addendum,
                   ea.id_epis_pn,
                   ea.flg_status,
                   ea.id_professional,
                   ea.dt_addendum,
                   ea.pn_addendum,
                   ea.dt_signoff,
                   ea.id_prof_signoff,
                   ea.id_prof_cancel,
                   ea.id_cancel_reason,
                   ea.dt_cancel,
                   ea.notes_cancel,
                   ea.flg_type
              FROM epis_pn_addendum ea
             WHERE ea.id_epis_pn_addendum = i_epis_pn_addendum;
    
        l_epis_pn_addendum epis_pn_addendum%ROWTYPE;
        l_rows_out         table_varchar;
        l_dt_last_update   TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_signoff       TIMESTAMP WITH LOCAL TIME ZONE;
        g_yes       CONSTANT VARCHAR2(1 CHAR) := 'Y';
        g_no        CONSTANT VARCHAR2(1 CHAR) := 'N';
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'SET_SIGNOFF_ADDENDUM';
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_dt_last_update := g_sysdate_tstz;
    
        l_dt_signoff := nvl(i_dt_signoff, l_dt_last_update);
    
        OPEN c_addendum;
        FETCH c_addendum
            INTO l_epis_pn_addendum.id_epis_pn_addendum,
                 l_epis_pn_addendum.id_epis_pn,
                 l_epis_pn_addendum.flg_status,
                 l_epis_pn_addendum.id_professional,
                 l_epis_pn_addendum.dt_addendum,
                 l_epis_pn_addendum.pn_addendum,
                 l_epis_pn_addendum.dt_signoff,
                 l_epis_pn_addendum.id_prof_signoff,
                 l_epis_pn_addendum.id_prof_cancel,
                 l_epis_pn_addendum.id_cancel_reason,
                 l_epis_pn_addendum.dt_cancel,
                 l_epis_pn_addendum.notes_cancel,
                 l_epis_pn_addendum.flg_type;
        CLOSE c_addendum;
    
        --If the addendum was edited then insert record in history and update addendum
        IF nvl(i_flg_edited, g_yes) = g_yes
        THEN
            IF NOT set_pn_addendum(i_lang                => i_lang,
                                   i_prof                => i_prof,
                                   i_id_epis_pn          => i_id_epis_pn,
                                   i_flg_type            => nvl(l_epis_pn_addendum.flg_type,
                                                                pk_prog_notes_constants.g_epa_flg_type_addendum),
                                   i_id_epis_pn_addendum => i_epis_pn_addendum,
                                   i_pn_addendum         => i_pn_addendum,
                                   o_epis_pn_addendum    => o_epis_pn_addendum,
                                   o_error               => o_error)
            THEN
                g_error := 'Cannot update addendum';
                pk_alertlog.log_info(text            => g_error,
                                     object_name     => g_package,
                                     sub_object_name => 'SET_SIGNOFF_ADDENDUM');
                RETURN FALSE;
            
            END IF;
        END IF;
    
        --If not Just Save then sign-off addendum
        IF nvl(i_flg_just_save, g_no) = g_no
        THEN
        
            --If addendum was edited, the hitory record was already created above
            IF nvl(i_flg_edited, g_yes) = g_no
               AND nvl(i_flg_hist, g_yes) = g_yes
            THEN
            
                g_error := 'Get PN addendum to sign-off';
                pk_alertlog.log_info(text            => g_error,
                                     object_name     => g_package,
                                     sub_object_name => 'SET_SIGNOFF_ADDENDUM');
            
                --Validate addendum status
                -- Can only sign-off addendum if not cancelled ou signed-off already    
                IF nvl(l_epis_pn_addendum.flg_status, '@') IN
                   (pk_prog_notes_constants.g_addendum_status_c, pk_prog_notes_constants.g_addendum_status_s)
                THEN
                    g_error := 'Cannot signoff a PN addendum already cancelled ou signed-off';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package,
                                         sub_object_name => 'SET_SIGNOFF_ADDENDUM');
                    RETURN TRUE;
                END IF;
            
                --insert history record
                g_error := 'Create PN addendum history record';
                pk_alertlog.log_info(text            => g_error,
                                     object_name     => g_package,
                                     sub_object_name => 'SET_SIGNOFF_ADDENDUM');
                ts_epis_pn_addendum_hist.ins(id_epis_pn_addendum_in   => l_epis_pn_addendum.id_epis_pn_addendum,
                                             dt_epis_addendum_hist_in => l_dt_last_update,
                                             id_epis_pn_in            => l_epis_pn_addendum.id_epis_pn,
                                             flg_status_in            => l_epis_pn_addendum.flg_status,
                                             id_professional_in       => l_epis_pn_addendum.id_professional,
                                             dt_addendum_in           => l_epis_pn_addendum.dt_addendum,
                                             pn_addendum_in           => l_epis_pn_addendum.pn_addendum,
                                             dt_signoff_in            => l_epis_pn_addendum.dt_signoff,
                                             id_prof_signoff_in       => l_epis_pn_addendum.id_prof_signoff,
                                             id_prof_cancel_in        => l_epis_pn_addendum.id_prof_cancel,
                                             id_cancel_reason_in      => l_epis_pn_addendum.id_cancel_reason,
                                             dt_cancel_in             => l_epis_pn_addendum.dt_cancel,
                                             notes_cancel_in          => l_epis_pn_addendum.notes_cancel,
                                             flg_type_in              => l_epis_pn_addendum.flg_type,
                                             rows_out                 => l_rows_out);
            
                g_error := 'PROCESS INSERT epis_pn_addendum_hist WITH id_epis_pn_addendum: ' ||
                           l_epis_pn_addendum.id_epis_pn_addendum;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_ADDENDUM_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
            END IF;
        
            --Sign-off PN addendum
            g_error := 'Sign-off PN addendum';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => 'SET_SIGNOFF_ADDENDUM');
        
            ts_epis_pn_addendum.upd(id_epis_pn_addendum_in => nvl(i_epis_pn_addendum, o_epis_pn_addendum),
                                    flg_status_in          => pk_prog_notes_constants.g_addendum_status_s,
                                    id_prof_signoff_in     => i_prof.id,
                                    dt_signoff_in          => l_dt_signoff,
                                    rows_out               => l_rows_out);
        
            g_error := 'PROCESS UPDATE epis_pn_addendum ';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_PN_ADDENDUM',
                                          i_rowids       => l_rows_out,
                                          i_list_columns => table_varchar('FLG_STATUS', 'ID_PROF_SIGNOFF', 'DT_SIGNOFF'),
                                          o_error        => o_error);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_SIGNOFF_ADDENDUM',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_signoff_addendum;

    /**
    * Checks if it is necessary to copy the current info to the history table
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn      Progress note identifier
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   20-Jul-2012
    */
    FUNCTION check_move_to_hist
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        o_flg_move_to_hist OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(19 CHAR) := 'CHECK_MOVE_TO_HIST';
    BEGIN
        --Check if it is necesary to generate history
        BEGIN
            g_error := 'GET THE last auto_saved flg. i_epis_pn: ' || i_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT decode(t.flg_auto_saved, pk_alert_constant.g_no, pk_alert_constant.g_yes, pk_alert_constant.g_no)
              INTO o_flg_move_to_hist
              FROM (SELECT e.id_epis_pn, e.flg_auto_saved
                      FROM epis_pn e
                     WHERE e.id_epis_pn = i_epis_pn) t;
        EXCEPTION
            WHEN no_data_found THEN
                o_flg_move_to_hist := pk_alert_constant.g_no;
        END;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END check_move_to_hist;

    /**
    * Moves progress notes and detail to corresponding history tables
    * Although we have created the i_flg_type parameter at the moment we have decided to allways use the MD mode
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn      Progress note identifier
    * @param   i_flg_type     Type of move:
    *                                   'M' - EPIS_PN
    *                                   'D' - EPIS_PN_DET
    *                                   'MD' - EPIS_PN and EPIS_PN_DET
    *                                   Because of the history screen all the history table have to be synchorized, that is
    *                                   when an update is done in the epis_pn_det, the epis_pn history should also be set
    * @param   i_flg_check_temp Y-Check if the previous record is temporary. N-otherwise
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   31-01-2011
    */
    FUNCTION move_epis_pn_2_hist
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_pn        IN epis_pn.id_epis_pn%TYPE,
        i_flg_type       IN VARCHAR2 DEFAULT pk_prog_notes_constants.g_flg_type_md,
        i_dt_hist        IN epis_pn_hist.dt_epis_pn_hist%TYPE DEFAULT g_sysdate_tstz,
        i_flg_check_temp IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_id_episode_pn  IN epis_pn.id_episode%TYPE DEFAULT NULL,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_func_name         VARCHAR2(19 CHAR) := 'MOVE_EPIS_PN_2_HIST';
        l_rows_out          table_varchar;
        l_rows_out_det      table_varchar;
        l_rows_out_det_task table_varchar;
    
        CURSOR c_epis_pn IS
            SELECT ep.id_epis_pn,
                   ep.id_episode,
                   ep.flg_status,
                   ep.dt_pn_date,
                   ep.id_prof_create,
                   ep.dt_create,
                   ep.id_dep_clin_serv,
                   ep.id_prof_last_update,
                   ep.dt_last_update,
                   ep.dt_signoff,
                   ep.id_prof_signoff,
                   ep.id_prof_cancel,
                   ep.dt_cancel,
                   ep.id_cancel_reason,
                   ep.notes_cancel,
                   ep.id_dictation_report,
                   ep.id_pn_note_type,
                   ep.id_pn_area,
                   ep.flg_auto_saved,
                   ep.dt_proposed,
                   ep.id_prof_reviewed,
                   ep.dt_reviewed,
                   ep.id_prof_submit,
                   ep.dt_submit,
                   ep.notes_submit
              FROM epis_pn ep
             WHERE ep.id_epis_pn = i_epis_pn;
    
        CURSOR c_epis_pn_det IS
            SELECT epd.id_epis_pn_det,
                   epd.id_epis_pn,
                   epd.id_professional,
                   epd.dt_pn,
                   epd.id_pn_data_block,
                   epd.id_pn_soap_block,
                   epd.flg_status,
                   epd.pn_note,
                   epd.dt_note
              FROM epis_pn_det epd
             WHERE epd.id_epis_pn = i_epis_pn;
    
        CURSOR c_epis_pn_det_task(l_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE) IS
            SELECT epdt.id_epis_pn_det_task,
                   epdt.id_epis_pn_det,
                   epdt.flg_status,
                   epdt.pn_note,
                   epdt.dt_last_update,
                   epdt.id_task,
                   epdt.id_task_aggregator,
                   epdt.id_task_type,
                   epdt.id_prof_last_update,
                   epdt.dt_task,
                   epdt.id_prof_task,
                   epdt.rank_task,
                   epdt.id_parent,
                   epdt.dt_group_import,
                   epdt.id_group_import,
                   epdt.code_desc_group,
                   epdt.id_sub_group_import,
                   epdt.code_desc_sub_group,
                   epdt.id_group_table,
                   epdt.table_position,
                   epdt.id_sample_type,
                   epdt.code_desc_sample_type,
                   epdt.dt_req_task,
                   epdt.code_desc_group_parent
              FROM epis_pn_det_task epdt
             WHERE epdt.id_epis_pn_det = l_epis_pn_det;
    
        l_epis_pn          c_epis_pn%ROWTYPE;
        l_counter          PLS_INTEGER := 0;
        l_flg_move_to_hist VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
    
        wrong_episode_patient EXCEPTION;
    
    BEGIN
    
        IF i_flg_check_temp = pk_alert_constant.g_yes
        THEN
            --Check if it is necesary to generate history  
            g_error := 'CALL check_move_to_hist';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT check_move_to_hist(i_lang             => i_lang,
                                      i_prof             => i_prof,
                                      i_epis_pn          => i_epis_pn,
                                      o_flg_move_to_hist => l_flg_move_to_hist,
                                      o_error            => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        IF l_flg_move_to_hist = pk_alert_constant.g_yes
        THEN
            g_error := 'open epis_pn cursor';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'move_epis_pn_2_hist');
        
            IF i_flg_type IN (pk_prog_notes_constants.g_flg_type_m, pk_prog_notes_constants.g_flg_type_md)
            THEN
                --fetch progress note records
                OPEN c_epis_pn;
                FETCH c_epis_pn
                    INTO l_epis_pn.id_epis_pn,
                         l_epis_pn.id_episode,
                         l_epis_pn.flg_status,
                         l_epis_pn.dt_pn_date,
                         l_epis_pn.id_prof_create,
                         l_epis_pn.dt_create,
                         l_epis_pn.id_dep_clin_serv,
                         l_epis_pn.id_prof_last_update,
                         l_epis_pn.dt_last_update,
                         l_epis_pn.dt_signoff,
                         l_epis_pn.id_prof_signoff,
                         l_epis_pn.id_prof_cancel,
                         l_epis_pn.dt_cancel,
                         l_epis_pn.id_cancel_reason,
                         l_epis_pn.notes_cancel,
                         l_epis_pn.id_dictation_report,
                         l_epis_pn.id_pn_note_type,
                         l_epis_pn.id_pn_area,
                         l_epis_pn.flg_auto_saved,
                         l_epis_pn.dt_proposed,
                         l_epis_pn.id_prof_reviewed,
                         l_epis_pn.dt_reviewed,
                         l_epis_pn.id_prof_submit,
                         l_epis_pn.dt_submit,
                         l_epis_pn.notes_submit;
                CLOSE c_epis_pn;
            
                g_error := 'insert epis_pn_hist';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => 'move_epis_pn_2_hist');
            
                -- CHECK IF EPISODE AND PATIENT ARE THE SAME ON HIST TABLE 
                IF i_id_episode_pn IS NOT NULL
                THEN
                    IF i_id_episode_pn <> l_epis_pn.id_episode
                       AND
                       pk_episode.get_id_patient(i_id_episode_pn) <> pk_episode.get_id_patient(l_epis_pn.id_episode)
                    THEN
                        RAISE wrong_episode_patient;
                    END IF;
                END IF;
                --insert into history table
                ts_epis_pn_hist.ins(id_epis_pn_in          => l_epis_pn.id_epis_pn,
                                    dt_epis_pn_hist_in     => i_dt_hist,
                                    id_episode_in          => l_epis_pn.id_episode,
                                    flg_status_in          => l_epis_pn.flg_status,
                                    id_dep_clin_serv_in    => l_epis_pn.id_dep_clin_serv,
                                    dt_pn_date_in          => l_epis_pn.dt_pn_date,
                                    id_prof_create_in      => l_epis_pn.id_prof_create,
                                    dt_create_in           => l_epis_pn.dt_create,
                                    dt_last_update_in      => l_epis_pn.dt_last_update,
                                    id_prof_last_update_in => l_epis_pn.id_prof_last_update,
                                    id_prof_cancel_in      => l_epis_pn.id_prof_cancel,
                                    dt_cancel_in           => l_epis_pn.dt_cancel,
                                    id_cancel_reason_in    => l_epis_pn.id_cancel_reason,
                                    dt_signoff_in          => l_epis_pn.dt_signoff,
                                    id_prof_signoff_in     => l_epis_pn.id_prof_signoff,
                                    notes_cancel_in        => l_epis_pn.notes_cancel,
                                    id_dictation_report_in => l_epis_pn.id_dictation_report,
                                    id_pn_note_type_in     => l_epis_pn.id_pn_note_type,
                                    id_pn_area_in          => l_epis_pn.id_pn_area,
                                    flg_auto_saved_in      => l_epis_pn.flg_auto_saved,
                                    dt_proposed_in         => l_epis_pn.dt_proposed,
                                    id_software_in         => i_prof.software,
                                    id_prof_reviewed_in    => l_epis_pn.id_prof_reviewed,
                                    dt_reviewed_in         => l_epis_pn.dt_reviewed,
                                    id_prof_submit_in      => l_epis_pn.id_prof_submit,
                                    dt_submit_in           => l_epis_pn.dt_submit,
                                    notes_submit_in        => l_epis_pn.notes_submit,
                                    rows_out               => l_rows_out);
            
                g_error := 'PROCESS INSERT epis_pn_hist WITH id_epis_pn: ' || l_epis_pn.id_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            END IF;
        
            g_error := 'insert epis_pn_det_hist';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'move_epis_pn_2_hist');
        
            IF i_flg_type IN (pk_prog_notes_constants.g_flg_type_md, pk_prog_notes_constants.g_flg_type_d)
            THEN
                --fetch progress notes det records
                FOR r_epis_pn_det IN c_epis_pn_det
                LOOP
                    --insert into history table
                    ts_epis_pn_det_hist.ins(id_epis_pn_det_in      => r_epis_pn_det.id_epis_pn_det,
                                            dt_epis_pn_det_hist_in => i_dt_hist,
                                            id_epis_pn_in          => r_epis_pn_det.id_epis_pn,
                                            id_professional_in     => r_epis_pn_det.id_professional,
                                            dt_pn_in               => r_epis_pn_det.dt_pn,
                                            id_pn_data_block_in    => r_epis_pn_det.id_pn_data_block,
                                            id_pn_soap_block_in    => r_epis_pn_det.id_pn_soap_block,
                                            flg_status_in          => r_epis_pn_det.flg_status,
                                            pn_note_in             => r_epis_pn_det.pn_note,
                                            rows_out               => l_rows_out_det);
                
                    g_error := 'PROCESS INSERT epis_pn_det_hist WITH id_epis_pn: ' || l_epis_pn.id_epis_pn;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET_HIST',
                                                  i_rowids     => l_rows_out_det,
                                                  o_error      => o_error);
                
                    l_counter := pk_prog_notes_utils.count_tasks(i_epis_pn_det => r_epis_pn_det.id_epis_pn_det,
                                                                 i_flg_status  => table_varchar(pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                                                                                pk_prog_notes_constants.g_epis_pn_det_flg_status_r,
                                                                                                pk_prog_notes_constants.g_epis_pn_det_sug_add_s,
                                                                                                pk_prog_notes_constants.g_epis_pn_det_sug_rem_i,
                                                                                                pk_prog_notes_constants.g_epis_pn_det_aut_rem_z));
                
                    IF l_counter > 0
                    THEN
                        FOR r_epis_pn_det_task IN c_epis_pn_det_task(r_epis_pn_det.id_epis_pn_det)
                        LOOP
                            ts_epis_pn_det_task_hist.ins(id_epis_pn_det_task_in      => r_epis_pn_det_task.id_epis_pn_det_task,
                                                         dt_epis_pn_det_task_hist_in => i_dt_hist,
                                                         id_epis_pn_det_in           => r_epis_pn_det_task.id_epis_pn_det,
                                                         id_task_in                  => r_epis_pn_det_task.id_task,
                                                         id_task_aggregator_in       => r_epis_pn_det_task.id_task_aggregator,
                                                         id_task_type_in             => r_epis_pn_det_task.id_task_type,
                                                         flg_status_in               => r_epis_pn_det_task.flg_status,
                                                         pn_note_in                  => r_epis_pn_det_task.pn_note,
                                                         dt_last_update_in           => r_epis_pn_det_task.dt_last_update,
                                                         id_prof_last_update_in      => r_epis_pn_det_task.id_prof_last_update,
                                                         dt_task_in                  => r_epis_pn_det_task.dt_task,
                                                         id_prof_task_in             => r_epis_pn_det_task.id_prof_task,
                                                         rank_task_in                => r_epis_pn_det_task.rank_task,
                                                         id_parent_in                => r_epis_pn_det_task.id_parent,
                                                         dt_group_import_in          => r_epis_pn_det_task.dt_group_import,
                                                         id_group_import_in          => r_epis_pn_det_task.id_group_import,
                                                         code_desc_group_in          => r_epis_pn_det_task.code_desc_group,
                                                         id_sub_group_import_in      => r_epis_pn_det_task.id_sub_group_import,
                                                         code_desc_sub_group_in      => r_epis_pn_det_task.code_desc_sub_group,
                                                         id_group_table_in           => r_epis_pn_det_task.id_group_table,
                                                         table_position_in           => r_epis_pn_det_task.table_position,
                                                         id_sample_type_in           => r_epis_pn_det_task.id_sample_type,
                                                         code_desc_sample_type_in    => r_epis_pn_det_task.code_desc_sample_type,
                                                         dt_req_task_in              => r_epis_pn_det_task.dt_req_task,
                                                         code_desc_group_parent_in   => r_epis_pn_det_task.code_desc_group_parent,
                                                         rows_out                    => l_rows_out_det_task);
                        
                            g_error := 'PROCESS INSERT EPIS_PN_DET_TASK_HIST WITH id_epis_pn: ' ||
                                       r_epis_pn_det_task.id_epis_pn_det_task;
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package_name,
                                                 sub_object_name => l_func_name);
                            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'EPIS_PN_DET_TASK_HIST',
                                                          i_rowids     => l_rows_out_det_task,
                                                          o_error      => o_error);
                        
                        END LOOP;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN wrong_episode_patient THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => 'PATIENT AND EPISODE DONT MATCH',
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'MOVE_EPIS_PN_2_HIST',
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'MOVE_EPIS_PN_2_HIST',
                                              o_error    => o_error);
            RETURN FALSE;
    END move_epis_pn_2_hist;

    /**
    * Delete work tables
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn      Progress note identifier
    *
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   31-01-2011
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   26-Jul-2012
    */
    FUNCTION delete_work_tables
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_epis_pn IN NUMBER,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_pn_auto_saved epis_pn.flg_auto_saved%TYPE;
    
        l_rows_out table_varchar := table_varchar();
    
        l_no_note_exception EXCEPTION;
        l_task_type_lst table_number;
        l_task_lst      table_number;
    
        CURSOR c_epis_pn IS
            SELECT t.id_epis_pn,
                   t.id_episode,
                   t.flg_status,
                   t.dt_pn_date,
                   t.id_prof_create,
                   t.dt_create,
                   t.id_dep_clin_serv,
                   t.id_prof_last_update,
                   t.dt_last_update,
                   t.dt_signoff,
                   t.id_prof_signoff,
                   t.id_prof_cancel,
                   t.dt_cancel,
                   t.id_cancel_reason,
                   t.notes_cancel,
                   t.id_pn_note_type,
                   t.id_pn_area,
                   t.flg_auto_saved,
                   t.dt_epis_pn_hist,
                   t.id_dictation_report
              FROM (SELECT ep.*, row_number() over(PARTITION BY ep.id_epis_pn ORDER BY ep.dt_epis_pn_hist DESC) rn
                      FROM epis_pn_hist ep
                     WHERE ep.id_epis_pn = i_epis_pn
                    /*AND ep.flg_auto_saved = pk_alert_constant.g_no*/
                    ) t
             WHERE rn = 1;
    
        l_rec_epis_pn c_epis_pn%ROWTYPE;
    
        l_func_name CONSTANT VARCHAR2(18 CHAR) := 'DELETE_WORK_TABLES';
    
    BEGIN
    
        g_error := 'Open EPIS_PN cursor';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'set_copy_2_work');
    
        BEGIN
            g_error := 'GET AUTO_SAVED FLG for current note: ' || i_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT epn.flg_auto_saved
              INTO l_pn_auto_saved
              FROM epis_pn epn
             WHERE epn.id_epis_pn = i_epis_pn;
        EXCEPTION
            WHEN no_data_found THEN
                RAISE l_no_note_exception;
        END;
    
        --if the current note save is definitive nothing was saved in the meanwhile        
        IF (l_pn_auto_saved = pk_alert_constant.g_yes)
        THEN
        
            OPEN c_epis_pn;
            FETCH c_epis_pn
                INTO l_rec_epis_pn;
            CLOSE c_epis_pn;
        
            --if there is an history record
            IF (l_rec_epis_pn.id_epis_pn IS NOT NULL)
            THEN
                g_error := 'CALL ts_epis_pn.upd';
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_epis_pn.upd(id_epis_pn_in          => l_rec_epis_pn.id_epis_pn,
                               id_episode_in          => l_rec_epis_pn.id_episode,
                               flg_status_in          => l_rec_epis_pn.flg_status,
                               id_dep_clin_serv_in    => l_rec_epis_pn.id_dep_clin_serv,
                               id_prof_create_in      => l_rec_epis_pn.id_prof_create,
                               dt_create_in           => l_rec_epis_pn.dt_create,
                               dt_last_update_in      => l_rec_epis_pn.dt_last_update,
                               id_prof_last_update_in => l_rec_epis_pn.id_prof_last_update,
                               id_dictation_report_in => l_rec_epis_pn.id_dictation_report,
                               id_pn_note_type_in     => l_rec_epis_pn.id_pn_note_type,
                               id_pn_area_in          => l_rec_epis_pn.id_pn_area,
                               flg_auto_saved_in      => l_rec_epis_pn.flg_auto_saved,
                               rows_out               => l_rows_out);
            
                g_error := 'PROCESS update epis_pn WITH id_epis_pn: ' || l_rec_epis_pn.id_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL ts_epis_pn_hist';
                ts_epis_pn_hist.del(id_epis_pn_in      => l_rec_epis_pn.id_epis_pn,
                                    dt_epis_pn_hist_in => l_rec_epis_pn.dt_epis_pn_hist,
                                    rows_out           => l_rows_out);
                g_error := 'PROCESS delete epis_pn_hist WITH id_epis_pn: ' || l_rec_epis_pn.id_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                BEGIN
                    --delete the records that exist in the DET table and not exists in the previous HIst record
                    SELECT epdt.id_task_type, epdt.id_task
                      BULK COLLECT
                      INTO l_task_type_lst, l_task_lst
                      FROM epis_pn_det_task epdt
                     WHERE epdt.id_epis_pn_det IN
                           (SELECT epd.id_epis_pn_det
                              FROM epis_pn_det epd
                             WHERE epd.id_epis_pn = l_rec_epis_pn.id_epis_pn
                               AND NOT EXISTS (SELECT 1
                                      FROM epis_pn_det_hist epdh
                                     WHERE epdh.id_epis_pn = l_rec_epis_pn.id_epis_pn
                                       AND epdh.dt_epis_pn_det_hist = l_rec_epis_pn.dt_epis_pn_hist
                                       AND epdh.id_epis_pn_det = epd.id_epis_pn_det));
                
                    -- In AIH it is necessary to cancel created records in the aih tables
                    g_error := 'Call pk_prog_notes_in.set_cancel_task_on_del_note';
                    IF NOT pk_prog_notes_in.set_cancel_task_on_del_note(i_lang          => i_lang,
                                                                        i_prof          => i_prof,
                                                                        i_id_task_type  => l_task_type_lst,
                                                                        i_id_task_refid => l_task_lst,
                                                                        o_error         => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            
                FOR recdet IN (SELECT *
                                 FROM epis_pn_det epd
                                WHERE epd.id_epis_pn = l_rec_epis_pn.id_epis_pn
                                  AND NOT EXISTS (SELECT 1
                                         FROM epis_pn_det_hist epdh
                                        WHERE epdh.id_epis_pn = l_rec_epis_pn.id_epis_pn
                                          AND epdh.dt_epis_pn_det_hist = l_rec_epis_pn.dt_epis_pn_hist
                                          AND epdh.id_epis_pn_det = epd.id_epis_pn_det))
                LOOP
                
                    g_error := 'CALL ts_epis_pn_det_task id_epis_pn_det: ' || recdet.id_epis_pn_det;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    ts_epis_pn_det_task.del_epdtk_eptd_fk(id_epis_pn_det_in => recdet.id_epis_pn_det,
                                                          rows_out          => l_rows_out);
                    g_error := 'PROCESS delete epis_pn_det_task';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET_TASK',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    g_error := 'CALL ts_epis_pn_det id_epis_pn_det: ' || recdet.id_epis_pn_det;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    ts_epis_pn_det.del(id_epis_pn_det_in => recdet.id_epis_pn_det, rows_out => l_rows_out);
                    g_error := 'PROCESS delete epis_pn_det';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                END LOOP;
            
                --delete the records that exist in the DET_TASK table and not exists in the previous HIst record
                FOR recdettask IN (SELECT *
                                     FROM epis_pn_det_task epdt
                                     JOIN epis_pn_det epd
                                       ON epd.id_epis_pn_det = epdt.id_epis_pn_det
                                    WHERE epd.id_epis_pn = l_rec_epis_pn.id_epis_pn
                                      AND NOT EXISTS
                                    (SELECT 1
                                             FROM epis_pn_det_task_hist epdh
                                             JOIN epis_pn_det_hist eph
                                               ON eph.id_epis_pn_det = epdh.id_epis_pn_det
                                              AND eph.dt_epis_pn_det_hist = epdh.dt_epis_pn_det_task_hist
                                            WHERE eph.id_epis_pn = l_rec_epis_pn.id_epis_pn
                                              AND eph.dt_epis_pn_det_hist = l_rec_epis_pn.dt_epis_pn_hist
                                              AND epdh.id_epis_pn_det_task = epdt.id_epis_pn_det_task))
                LOOP
                
                    g_error := 'CALL ts_epis_pn_det_task id_epis_pn_det_task: ' || recdettask.id_epis_pn_det_task;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    ts_epis_pn_det_task.del(id_epis_pn_det_task_in => recdettask.id_epis_pn_det_task,
                                            rows_out               => l_rows_out);
                    g_error := 'PROCESS delete epis_pn_det_task';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET_TASK',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    -- In AIH it is necessary to cancel created records in the aih tables
                    g_error := 'Call pk_prog_notes_in.set_cancel_task_on_del_note';
                    IF NOT pk_prog_notes_in.set_cancel_task_on_del_note(i_lang          => i_lang,
                                                                        i_prof          => i_prof,
                                                                        i_id_task_type  => table_number(recdettask.id_task_type),
                                                                        i_id_task_refid => table_number(recdettask.id_task),
                                                                        o_error         => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END LOOP;
            
                FOR rec IN (SELECT *
                              FROM epis_pn_det_hist epdh
                             WHERE epdh.id_epis_pn = l_rec_epis_pn.id_epis_pn
                               AND epdh.dt_epis_pn_det_hist = l_rec_epis_pn.dt_epis_pn_hist)
                LOOP
                
                    FOR rectask IN (SELECT *
                                      FROM epis_pn_det_task_hist epdth
                                     WHERE epdth.id_epis_pn_det = rec.id_epis_pn_det
                                       AND epdth.dt_epis_pn_det_task_hist = rec.dt_epis_pn_det_hist)
                    LOOP
                        ts_epis_pn_det_task.upd(id_epis_pn_det_task_in => rectask.id_epis_pn_det_task,
                                                id_epis_pn_det_in      => rectask.id_epis_pn_det,
                                                id_task_in             => rectask.id_task,
                                                id_task_type_in        => rectask.id_task_type,
                                                flg_status_in          => rectask.flg_status,
                                                pn_note_in             => rectask.pn_note,
                                                dt_last_update_in      => rectask.dt_last_update,
                                                id_prof_last_update_in => rectask.id_prof_last_update,
                                                flg_table_origin_in    => rectask.flg_table_origin,
                                                id_task_aggregator_in  => rectask.id_task_aggregator,
                                                dt_task_in             => rectask.dt_task,
                                                id_prof_task_in        => rectask.id_prof_task,
                                                rank_task_in           => rectask.rank_task,
                                                id_parent_in           => rectask.id_parent,
                                                dt_req_task_in         => rectask.dt_req_task,
                                                rows_out               => l_rows_out);
                    
                        g_error := 'PROCESS update epis_pn_det_task WITH id_epis_pn_det_task: ' ||
                                   rectask.id_epis_pn_det_task;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPIS_PN_DET_TASK',
                                                      i_rowids     => l_rows_out,
                                                      o_error      => o_error);
                    
                        g_error := 'CALL ts_epis_pn_det_task_hist delete id_epis_pn_det: ' || rec.id_epis_pn_det;
                        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                        ts_epis_pn_det_task_hist.del(id_epis_pn_det_task_in      => rectask.id_epis_pn_det_task,
                                                     dt_epis_pn_det_task_hist_in => rectask.dt_epis_pn_det_task_hist,
                                                     rows_out                    => l_rows_out);
                        g_error := 'PROCESS delete epis_pn_det_hist';
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPIS_PN_DET_HIST',
                                                      i_rowids     => l_rows_out,
                                                      o_error      => o_error);
                    
                    END LOOP;
                
                    g_error := 'CALL ts_epis_pn_det delete id_epis_pn_det: ' || rec.id_epis_pn_det;
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_pn_det.upd(id_epis_pn_det_in   => rec.id_epis_pn_det,
                                       id_epis_pn_in       => rec.id_epis_pn,
                                       id_professional_in  => rec.id_professional,
                                       dt_pn_in            => rec.dt_pn,
                                       id_pn_data_block_in => rec.id_pn_data_block,
                                       id_pn_soap_block_in => rec.id_pn_soap_block,
                                       flg_status_in       => rec.flg_status,
                                       pn_note_in          => rec.pn_note,
                                       rows_out            => l_rows_out);
                
                    g_error := 'PROCESS update epis_pn_det WITH id_epis_pn_det: ' || rec.id_epis_pn_det;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    g_error := 'CALL ts_epis_pn_hist delete id_epis_pn_det: ' || rec.id_epis_pn_det;
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_pn_det_hist.del(id_epis_pn_det_in      => rec.id_epis_pn_det,
                                            dt_epis_pn_det_hist_in => rec.dt_epis_pn_det_hist,
                                            rows_out               => l_rows_out);
                    g_error := 'PROCESS delete epis_pn_det_hist';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET_HIST',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                END LOOP;
            ELSE
                --if there isn?t a previous record in the history
            
                --delete the current note
                g_error := 'CALL ts_epis_pn_hist';
                ts_epis_pn_det_task_hist.del_by(where_clause_in => ' id_epis_pn_det IN (select id_epis_pn_det from
            epis_pn_det epd where epd.id_epis_pn = ' ||
                                                                   i_epis_pn || ')',
                                                rows_out        => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_DET_TASK_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                BEGIN
                    g_error := 'GET tasks to cancel';
                    SELECT epdt.id_task_type, epdt.id_task
                      BULK COLLECT
                      INTO l_task_type_lst, l_task_lst
                      FROM epis_pn_det_task epdt
                      JOIN epis_pn_det epd
                        ON epd.id_epis_pn_det = epdt.id_epis_pn_det
                     WHERE epd.id_epis_pn = i_epis_pn;
                
                    -- In AIH it is necessary to cancel created records in the aih tables
                    g_error := 'Call pk_prog_notes_in.set_cancel_task_on_del_note';
                    IF NOT pk_prog_notes_in.set_cancel_task_on_del_note(i_lang          => i_lang,
                                                                        i_prof          => i_prof,
                                                                        i_id_task_type  => l_task_type_lst,
                                                                        i_id_task_refid => l_task_lst,
                                                                        o_error         => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            
                g_error := 'CALL ts_epis_pn_hist';
                ts_epis_pn_det_task.del_by(where_clause_in => ' id_epis_pn_det IN (select id_epis_pn_det from
            epis_pn_det epd where epd.id_epis_pn = ' ||
                                                              i_epis_pn || ')',
                                           rows_out        => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_DET_TASK',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL ts_epis_pn_hist';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn_det_hist.del_by(where_clause_in => ' id_epis_pn = ' || i_epis_pn, rows_out => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn_det_hist WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_DET_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL ts_epis_pn_hist';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn_det.del_eptd_epn_fk(id_epis_pn_in => i_epis_pn, rows_out => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_DET',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL ts_epis_pn_hist';
                ts_epis_pn_hist.del_by(where_clause_in => ' id_epis_pn = ' || i_epis_pn, rows_out => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_HIST',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL ts_epis_pn_hist';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn.del(id_epis_pn_in => i_epis_pn, rows_out => l_rows_out);
            
                g_error := 'PROCESS delete epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_no_note_exception THEN
            --the note had already been deleted;
            g_error := 'No note exists. id_epis_pn ' || i_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'delete_work_tables',
                                              o_error    => o_error);
            RETURN FALSE;
    END delete_work_tables;

    /**
    * Saves work data into progress notes tables
    *
    * @param   i_lang            Professional preferred language
    * @param   i_prof            Professional identification and its context (institution and software)
    * @param   i_epis_pn         Progress note identifier
    * @param   i_epis_pn_work    Progress note identifier in work table
    * @param   i_id_pn_area      Pn area id
    *
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   31-01-2011
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   20-07-2012
    */
    FUNCTION set_save_work_data
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_pn      IN NUMBER,
        i_epis_pn_work IN NUMBER,
        i_id_pn_area   IN pn_area.id_pn_area%TYPE DEFAULT NULL,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rows      table_varchar := table_varchar();
        l_func_name VARCHAR2(18 CHAR) := 'SET_SAVE_WORK_DATA';
    BEGIN
        g_error := 'CALL ts_epis_pn id_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        ts_epis_pn.upd(id_epis_pn_in => i_epis_pn, flg_auto_saved_in => pk_alert_constant.g_no, rows_out => l_rows);
    
        g_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN',
                                      i_rowids       => l_rows,
                                      i_list_columns => table_varchar('FLG_AUTO_SAVED'),
                                      o_error        => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
    
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_save_work_data;

    /**
    * Cancel progress note
    *
    * @param   i_lang           Professional preferred language
    * @param   i_prof           Professional identification and its context (institution and software)
    * @param   i_epis_pn        Progress note identifier
    * @param   i_cancel_reason  Cancel reason identifier
    * @param   i_notes_cancel   Cancel notes
    * @param   i_dt_cancel      Cancelation date
    *
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   01-02-2011
    */
    FUNCTION cancel_progress_note
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_epis_pn       IN NUMBER,
        i_cancel_reason IN NUMBER,
        i_notes_cancel  IN VARCHAR2,
        i_dt_cancel     IN epis_pn_hist.dt_cancel%TYPE DEFAULT current_timestamp,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'CANCEL_PROGRESS_NOTE';
        move_2_hist_error     EXCEPTION;
        note_already_canceled EXCEPTION;
        l_rows    table_varchar;
        l_counter PLS_INTEGER;
    
        CURSOR c_note_canceled IS
            SELECT COUNT(0)
              FROM epis_pn ep
             WHERE ep.id_epis_pn = i_epis_pn
               AND ep.flg_status = pk_prog_notes_constants.g_epis_pn_flg_status_c;
    
    BEGIN
        g_error := 'Validate if note is already canceled';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'cancel_progress_note');
    
        --Validate if note is already canceled (l_counter > 0)
        OPEN c_note_canceled;
        FETCH c_note_canceled
            INTO l_counter;
        CLOSE c_note_canceled;
    
        IF l_counter > 0
        THEN
            RAISE note_already_canceled;
        END IF;
    
        g_error := 'Move records to hist tables';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'cancel_progress_note');
    
        --Create history records
        IF NOT move_epis_pn_2_hist(i_lang     => i_lang,
                                   i_prof     => i_prof,
                                   i_epis_pn  => i_epis_pn,
                                   i_flg_type => pk_prog_notes_constants.g_flg_type_md,
                                   i_dt_hist  => i_dt_cancel,
                                   o_error    => o_error)
        THEN
            RAISE move_2_hist_error;
        END IF;
    
        g_error := 'update the cancel fields';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'cancel_progress_note');
    
        --update cancel columns and flg_status
        ts_epis_pn.upd(id_epis_pn_in       => i_epis_pn,
                       flg_status_in       => pk_prog_notes_constants.g_epis_pn_flg_status_c,
                       id_prof_cancel_in   => i_prof.id,
                       dt_cancel_in        => i_dt_cancel,
                       id_cancel_reason_in => i_cancel_reason,
                       notes_cancel_in     => i_notes_cancel,
                       rows_out            => l_rows);
    
        g_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN',
                                      i_rowids       => l_rows,
                                      i_list_columns => table_varchar('FLG_STATUS',
                                                                      'ID_PROF_CANCEL',
                                                                      'DT_CANCEL',
                                                                      'ID_CANCEL_REASON',
                                                                      'NOTES_CANCEL'),
                                      o_error        => o_error);
        RETURN TRUE;
    EXCEPTION
        WHEN note_already_canceled THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => 'note already canceled',
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'cancel_progress_note',
                                              o_error    => o_error);
            RETURN FALSE;
        
        WHEN move_2_hist_error THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => 'move 2 hist',
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'cancel_progress_note',
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'cancel_progress_note',
                                              o_error    => o_error);
            RETURN FALSE;
    END cancel_progress_note;

    /**
    * Sign off a progress note
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_pn                   Progress note identifier
    * @param   i_flg_edited                Indicate if the SOAP block was edited
    * @param   i_pn_soap_block             Soap Block array with ids
    * @param   i_pn_signoff_note           Notes array
    * @param   i_flg_just_save             Indicate if its just to save or to signoff
    * @param   i_flg_showed_just_save      Indicates if just save screen showed or not
    *
    * @param   o_error                     Error information
    *
    * @return                              Returns TRUE if success, otherwise returns FALSE
    *
    * @value   i_flg_just_save             {*} 'Y'- Yes {*} 'N'- No
    * @value   i_flg_showed_just_save      {*} 'Y'- screen was showed to Professional {*} 'N'- screen didn't showed to Professional
    *
    * @author                              RUI.SPRATLEY
    * @version                             2.6.0.5
    * @since                               02-02-2011
    *
    * @author                              ANTONIO.NETO
    * @version                             2.6.2
    * @since                               19-Apr-2012
    */
    FUNCTION set_sign_off
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_epis_pn              IN epis_pn.id_epis_pn%TYPE,
        i_flg_edited           IN table_varchar,
        i_pn_soap_block        IN table_number,
        i_pn_signoff_note      IN table_clob,
        i_flg_just_save        IN VARCHAR2,
        i_flg_showed_just_save IN VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_flg_edited      table_varchar;
        l_pn_soap_block   table_number;
        l_pn_signoff_note table_clob;
    
        --If i_epis_pn_signoff has records its an update otherwise tis an insert
        no_texs_found           EXCEPTION;
        no_records_found        EXCEPTION;
        move_2_hist_error       EXCEPTION;
        note_canceled_or_signed EXCEPTION;
        l_rows_out        table_varchar;
        l_epis_pn_signoff epis_pn_signoff.id_epis_pn_signoff%TYPE;
    
        l_func_name CONSTANT VARCHAR2(12 CHAR) := 'SET_SIGN_OFF';
    
        CURSOR c_epis_pn_signoff(l_pn_soap_block epis_pn_signoff.id_pn_soap_block%TYPE) IS
            SELECT eso.id_epis_pn_signoff,
                   eso.id_epis_pn,
                   eso.id_pn_soap_block,
                   eso.pn_signoff_note,
                   eso.id_prof_last_update,
                   eso.dt_last_update
              FROM epis_pn_signoff eso
             WHERE eso.id_epis_pn = i_epis_pn
               AND eso.id_pn_soap_block = l_pn_soap_block;
    
        r_epis_pn_signoff c_epis_pn_signoff%ROWTYPE;
    
        l_counter  PLS_INTEGER;
        l_notfound BOOLEAN;
        l_changed  BOOLEAN := FALSE;
    
        CURSOR c_note_canc_sign IS
            SELECT COUNT(0)
              FROM epis_pn ep
             WHERE ep.id_epis_pn = i_epis_pn
               AND ep.flg_status IN
                   (pk_prog_notes_constants.g_epis_pn_flg_status_c, pk_prog_notes_constants.g_epis_pn_flg_status_s);
    
    BEGIN
        g_error := 'Validate if note is already canceled or signed off';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        --Validate if note is already canceled (l_counter > 0)
        OPEN c_note_canc_sign;
        FETCH c_note_canc_sign
            INTO l_counter;
        CLOSE c_note_canc_sign;
    
        IF l_counter > 0
        THEN
            RAISE note_canceled_or_signed;
        END IF;
    
        --check if didn't passed by just save screen of sign off create the text
        IF nvl(i_flg_showed_just_save, pk_alert_constant.g_no) = pk_alert_constant.g_no
        THEN
            g_error := 'CALL PK_PROG_NOTES_GRIDS.GET_SIGNOFF_NOTE_TEXT';
            IF NOT pk_prog_notes_grids.get_signoff_note_text(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_id_epis_pn      => i_epis_pn,
                                                             o_flg_edited      => l_flg_edited,
                                                             o_pn_soap_block   => l_pn_soap_block,
                                                             o_pn_signoff_note => l_pn_signoff_note,
                                                             o_error           => o_error)
            THEN
                RAISE no_texs_found;
            END IF;
        ELSE
            l_flg_edited      := i_flg_edited;
            l_pn_soap_block   := i_pn_soap_block;
            l_pn_signoff_note := i_pn_signoff_note;
        END IF;
    
        g_error := 'Validate input records';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF l_pn_soap_block.count = 0
        THEN
            RAISE no_records_found;
        END IF;
    
        --For all soap block records
        FOR i IN 1 .. l_pn_soap_block.count
        LOOP
        
            OPEN c_epis_pn_signoff(l_pn_soap_block(i));
            FETCH c_epis_pn_signoff
                INTO r_epis_pn_signoff;
            l_notfound := c_epis_pn_signoff%NOTFOUND;
            CLOSE c_epis_pn_signoff;
        
            --If we edited the record
            IF nvl(l_flg_edited(i), pk_prog_notes_constants.g_no) = pk_prog_notes_constants.g_yes
            THEN
                IF NOT l_notfound
                THEN
                    l_changed := TRUE;
                
                    g_error := 'Get sign off id for update';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                
                    --Pode-se trocar por um open fetch
                    g_error := 'Update history table';
                    ts_epis_pn_signoff_hist.ins(id_epis_pn_signoff_in      => r_epis_pn_signoff.id_epis_pn_signoff,
                                                dt_epis_pn_signoff_hist_in => g_sysdate_tstz,
                                                id_epis_pn_in              => r_epis_pn_signoff.id_epis_pn,
                                                id_pn_soap_block_in        => r_epis_pn_signoff.id_pn_soap_block,
                                                pn_signoff_note_in         => r_epis_pn_signoff.pn_signoff_note,
                                                id_prof_last_update_in     => r_epis_pn_signoff.id_prof_last_update,
                                                dt_last_update_in          => r_epis_pn_signoff.dt_last_update,
                                                rows_out                   => l_rows_out);
                
                    g_error := 'PROCESS INSERT epis_pn_signoff_hist WITH id_epis_pn_signoff: ' ||
                               r_epis_pn_signoff.id_epis_pn_signoff;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_SIGNOFF_HIST',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    g_error := 'Update sign off table';
                    ts_epis_pn_signoff.upd(id_epis_pn_signoff_in  => r_epis_pn_signoff.id_epis_pn_signoff,
                                           id_epis_pn_in          => i_epis_pn,
                                           id_pn_soap_block_in    => l_pn_soap_block(i),
                                           pn_signoff_note_in     => l_pn_signoff_note(i),
                                           id_prof_last_update_in => r_epis_pn_signoff.id_prof_last_update,
                                           dt_last_update_in      => r_epis_pn_signoff.dt_last_update,
                                           rows_out               => l_rows_out);
                
                    g_error := 'PROCESS UPDATE epis_pn_signoff_hist WITH id_epis_pn_signoff: ' ||
                               r_epis_pn_signoff.id_epis_pn_signoff;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPIS_PN_SIGNOFF',
                                                  i_rowids       => l_rows_out,
                                                  i_list_columns => table_varchar('ID_EPIS_PN',
                                                                                  'ID_PN_SOAP_BLOCK',
                                                                                  'PN_SIGNOFF_NOTE',
                                                                                  'ID_PROF_LAST_UPDATE',
                                                                                  'DT_LAST_UPDATE'),
                                                  o_error        => o_error);
                
                ELSE
                    l_changed := TRUE;
                
                    --if we do not have the i_epis_pn_signoff array then its a new record
                    g_error := 'Insert new sign off record';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                
                    ts_epis_pn_signoff.ins(id_epis_pn_in          => i_epis_pn,
                                           id_pn_soap_block_in    => l_pn_soap_block(i),
                                           pn_signoff_note_in     => l_pn_signoff_note(i),
                                           id_epis_pn_signoff_out => l_epis_pn_signoff,
                                           rows_out               => l_rows_out);
                
                    g_error := 'PROCESS INSERT epis_pn_signoff WITH id_epis_pn: ' || i_epis_pn;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_SIGNOFF',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                END IF;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            END IF;
        END LOOP;
        --
    
        --We will only update status if we changed the progress notes signoff tables
        IF l_changed
           OR i_flg_just_save = pk_prog_notes_constants.g_no
        THEN
            g_error := 'Create history records';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --Create history records
            IF NOT move_epis_pn_2_hist(i_lang     => i_lang,
                                       i_prof     => i_prof,
                                       i_epis_pn  => i_epis_pn,
                                       i_flg_type => pk_prog_notes_constants.g_flg_type_md,
                                       o_error    => o_error)
            THEN
                RAISE move_2_hist_error;
            END IF;
        
            --If it is not just a temporary save then we must update EPIS_PN as signed off
            IF i_flg_just_save = pk_prog_notes_constants.g_no
            THEN
                g_error := 'update status in epis_pn table to signed off.';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn.upd(id_epis_pn_in      => i_epis_pn,
                               flg_status_in      => pk_prog_notes_constants.g_epis_pn_flg_status_s,
                               dt_signoff_in      => g_sysdate_tstz,
                               id_prof_signoff_in => i_prof.id,
                               rows_out           => l_rows_out);
            
                g_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('FLG_STATUS',
                                                                              'DT_SIGNOFF',
                                                                              'ID_PROF_SIGNOFF'),
                                              o_error        => o_error);
                --Else we must update EPIS_PN as temporary save
            ELSE
                g_error := 'update status in epis_pn table to temporary save.';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn.upd(id_epis_pn_in          => i_epis_pn,
                               flg_status_in          => pk_prog_notes_constants.g_epis_pn_flg_status_t,
                               id_prof_last_update_in => i_prof.id,
                               dt_last_update_in      => g_sysdate_tstz,
                               rows_out               => l_rows_out);
            
                g_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || i_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('FLG_STATUS',
                                                                              'ID_PROF_LAST_UPDATE',
                                                                              'DT_LAST_UPDATE'),
                                              o_error        => o_error);
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN move_2_hist_error THEN
            g_error := 'move_2_hist_error';
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_sign_off',
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN no_records_found THEN
            g_error := 'no_records_found';
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_sign_off',
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN note_canceled_or_signed THEN
            g_error := 'note_canceled_or_signed';
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_sign_off',
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_sign_off',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_sign_off;

    /**
    * Returns the notes to the summary grid.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn            Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_flg_comments           Y-Returns the comment records. N-otherwise
    * @param i_flg_editable           A-Editable note. T-Not editable except free texts N-Otherwise
    * @param i_market                 Market ID
    * @param i_configs_ctx            Configs context structure 
    * @param i_id_pn_soap_block       Soap block ID
    * @param o_text_blocks            Output cursor
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   03-02-2011
    */

    FUNCTION get_block_txt
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        i_flg_editable     IN VARCHAR2,
        i_configs_ctx      IN pk_prog_notes_types.t_configs_ctx,
        i_dt_last_update   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_id_pn_soap_block IN table_number,
        o_text_blocks      OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_pn_soap_block table_number := table_number();
    BEGIN
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        g_error := 'GET NON SIGNED OFF BLOCK TEXT from definitive model';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'get_block_txt');
        OPEN o_text_blocks FOR
            SELECT t_int.id_epis_pn,
                   t_int.id_epis_pn_det,
                   t_int.block_id,
                   t_int.id_pn_data_block,
                   CASE
                        WHEN instr(t_int.pn_note, '[B|ID_TASK:') > 0 THEN
                         pk_prog_notes_utils.get_bl_epis_documentation_clob(i_lang, i_prof, t_int.pn_note)
                        ELSE
                         t_int.pn_note
                    END pn_note,
                   t_int.id_task,
                   t_int.id_task_aggregator,
                   t_int.id_epis_pn_det_task,
                   t_int.note_date,
                   t_int.flg_table_origin,
                   t_int.id_pn_task_type,
                   t_int.flg_review,
                   t_int.flg_may_edit,
                   (SELECT pk_prog_notes_utils.get_signature(i_lang               => i_lang,
                                                             i_prof               => i_prof,
                                                             i_id_episode         => t_int.id_episode,
                                                             i_id_prof_last_upd   => t_int.id_prof_last_update,
                                                             i_dt_last_upd        => t_int.dt_last_update,
                                                             i_id_prof_review     => t_int.id_prof_review,
                                                             i_dt_review          => t_int.dt_review,
                                                             i_flg_show_signature => t_int.flg_show_signature,
                                                             i_id_pn_task_type    => t_int.id_pn_task_type)
                      FROM dual) signature,
                   t_int.flg_hour_origin,
                   t_int.flg_remove,
                   t_int.flg_state_review,
                   t_int.flg_state_remove,
                   t_int.dt_note,
                   t_int.flg_select_in_group,
                   (SELECT pk_prog_notes_utils.get_flg_no_action(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_flg_dblock_type => t_int.flg_type,
                                                                 i_flg_editable    => i_flg_editable)
                      FROM dual) flg_no_action,
                   pk_alert_constant.g_no flg_suggested,
                   t_int.id_parent,
                   (SELECT pk_prog_notes_in.has_multichoice(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_id_task_type => t_int.id_pn_task_type)
                      FROM dual) flg_has_multichoice,
                   t_int.table_position,
                   --because not all the vital signs has a short description when no short desc exists to the table row,
                   --we try to get the long desc
                   decode(t_int.table_row_desc,
                          NULL,
                          (SELECT pk_translation.get_translation(i_lang      => i_lang,
                                                                 i_code_mess => pk_prog_notes_constants.g_vital_sign_long_desc_code ||
                                                                                t_int.table_row_id)
                             FROM dual),
                          t_int.table_row_desc) table_row_desc,
                   t_int.table_row_id,
                   CASE
                        WHEN t_int.dt_group_import IS NOT NULL THEN
                         (SELECT pk_date_utils.date_char_tsz(i_lang,
                                                             t_int.dt_group_import,
                                                             i_prof.institution,
                                                             i_prof.software)
                            FROM dual)
                    END table_date_reg,
                   t_int.flg_modified,
                   t_int.flg_show_signature,
                   t_int.id_group,
                   t_int.is_templ_bl,
                   t_int.flg_score,
                   t_int.id_prof_last_update
              FROM (SELECT t.*,
                           (SELECT pk_prog_notes_utils.get_flg_show_signature(i_lang             => i_lang,
                                                                              i_prof             => i_prof,
                                                                              i_flg_suggested    => pk_alert_constant.g_no,
                                                                              i_id_prof_reg      => nvl(t.id_prof_review,
                                                                                                        t.id_prof_last_update),
                                                                              i_flg_import_date  => t.flg_import_date,
                                                                              i_dblock_data_area => t.data_area,
                                                                              i_flg_import       => t.flg_import,
                                                                              i_flg_signature    => t.flg_signature)
                              FROM dual) flg_show_signature
                      FROM (SELECT /*+opt_estimate(table,db,scale_rows=0.000001)*/ /*+opt_estimate(table,dbtt,scale_rows=0.0000001)*/
                             epd.id_epis_pn,
                             epd.id_epis_pn_det,
                             epd.id_pn_soap_block block_id,
                             epd.id_pn_data_block,
                             CASE
                                  WHEN epdw.id_task_type IS NULL THEN
                                   CASE
                                       WHEN epd.pn_note IS NULL
                                            OR length(epd.pn_note) = 0
                                            OR db.flg_import = pk_prog_notes_constants.g_import_block THEN
                                        pk_prog_notes_utils.get_tasks_concat(i_lang           => i_lang,
                                                                             i_prof           => i_prof,
                                                                             i_id_epis_pn_det => epd.id_epis_pn_det)
                                       ELSE
                                        epd.pn_note
                                   END
                                  ELSE
                                   epdw.pn_note
                              END pn_note,
                             epdw.id_task,
                             epdw.id_task_aggregator,
                             epdw.id_epis_pn_det_task id_epis_pn_det_task,
                             (SELECT pk_date_utils.date_send_tsz(i_lang, epd.dt_note, i_prof.institution, i_prof.software)
                                FROM dual) note_date,
                             epdw.flg_table_origin,
                             nvl(epdw.id_task_type, db.id_task_type_ftxt) id_pn_task_type,
                             pk_alert_constant.g_no flg_review,
                             --this is only used to check if the signature should be displayed
                             decode(nvl(epdw.id_prof_task, i_prof.id),
                                    i_prof.id,
                                    pk_alert_constant.g_yes,
                                    pk_alert_constant.g_no) flg_may_edit,
                             CASE
                                  WHEN epdw.id_task_type = pk_prog_notes_constants.g_task_dicharge_sch
                                       AND epdw.id_task IS NOT NULL THEN
                                   pk_discharge.get_dich_sch_flg_hour_origin(i_lang, i_prof, epdw.id_task)
                              END flg_hour_origin,
                             (SELECT get_flg_remove(i_flg_data_removal => db.flg_data_removable,
                                                    i_flg_suggested    => pk_alert_constant.g_no,
                                                    i_flg_editable     => i_flg_editable,
                                                    i_flg_action       => epdw.flg_action)
                                FROM dual) flg_remove,
                             pk_prog_notes_constants.g_review_action flg_state_review,
                             pk_prog_notes_constants.g_epis_pn_det_flg_status_r flg_state_remove,
                             epd.dt_note,
                             (SELECT get_flg_select_in_group(i_flg_review_all => i_configs_ctx.note_type.flg_review_all,
                                                             i_id_task_type   => epdw.id_task_type)
                                FROM dual) flg_select_in_group,
                             epdw.dt_task,
                             epdw.id_parent,
                             db.rank dblock_rank,
                             db.flg_actions_available,
                             db.flg_import,
                             db.flg_type,
                             decode(db.flg_type, pk_prog_notes_constants.g_dblock_table, epdw.table_position, NULL) table_position,
                             decode(db.flg_type,
                                    pk_prog_notes_constants.g_dblock_table,
                                    (SELECT pk_translation.get_translation(i_lang      => i_lang,
                                                                           i_code_mess => pk_prog_notes_constants.g_vital_sign_long_desc_code ||
                                                                                          epdw.id_group_table)
                                       FROM dual),
                                    NULL) table_row_desc,
                             decode(db.flg_type, pk_prog_notes_constants.g_dblock_table, epdw.id_group_table, NULL) table_row_id,
                             epdw.dt_group_import,
                             epdw.rank_task table_rank,
                             (SELECT pk_prog_notes_utils.get_flg_modified(i_lang                => i_lang,
                                                                          i_prof                => i_prof,
                                                                          i_pn_note             => epdw.pn_note,
                                                                          i_dt_pn               => epd.dt_pn,
                                                                          i_dt_last_update_task => epdw.dt_last_update,
                                                                          i_dt_last_update      => i_dt_last_update,
                                                                          i_flg_syncronized     => i_configs_ctx.note_type.flg_synchronized)
                                FROM dual) flg_modified,
                             nvl(epdw.id_prof_task, epd.id_professional) id_prof_last_update,
                             epn.id_episode,
                             db.data_area,
                             db.flg_import_date,
                             nvl(epdw.dt_task, epd.dt_pn) dt_last_update,
                             epdw.id_prof_review,
                             epdw.dt_review,
                             epdw.dt_req_task,
                             epdw.id_group_import id_group,
                             CASE
                                  WHEN epdw.id_task_type IN (pk_prog_notes_constants.g_task_templates) THEN
                                   pk_touch_option_out.has_layout(i_epis_documentation => epdw.id_task)
                                  ELSE
                                   pk_alert_constant.g_no
                              END is_templ_bl,
                             db.flg_order_type flg_order_type,
                             db.flg_signature,
                             da.flg_score
                              FROM epis_pn_det epd
                              JOIN epis_pn epn
                                ON epn.id_epis_pn = epd.id_epis_pn
                              LEFT JOIN TABLE(i_configs_ctx.data_blocks) db
                                ON epd.id_pn_soap_block = db.id_pn_soap_block
                               AND epd.id_pn_data_block = db.id_pn_data_block
                              LEFT OUTER JOIN epis_pn_det_task epdw
                                ON epdw.id_epis_pn_det = epd.id_epis_pn_det
                               AND db.flg_import = pk_prog_notes_constants.g_import_block
                               AND epdw.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                              LEFT JOIN pn_data_block pdb
                                ON pdb.id_pn_data_block = epd.id_pn_data_block
                              LEFT JOIN doc_area da
                                ON da.id_doc_area = pdb.id_doc_area
                             WHERE epd.id_epis_pn = i_id_epis_pn
                               AND (l_id_pn_soap_block IS NULL OR
                                   epd.id_pn_soap_block IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                              column_value
                                                               FROM TABLE(l_id_pn_soap_block) t))
                               AND epd.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                               AND epdw.id_parent IS NULL) t) t_int
             ORDER BY t_int.table_rank,
                      CASE
                           WHEN t_int.flg_order_type = 'D' THEN
                            t_int.dt_task
                           ELSE
                            NULL
                       END DESC,
                      CASE
                           WHEN t_int.flg_order_type = 'A' THEN
                            t_int.dt_task
                           ELSE
                            NULL
                       END ASC,
                      t_int.dt_req_task DESC,
                      t_int.dt_last_update DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_text_blocks);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_BLOCK_TXT',
                                              o_error);
        
            RETURN FALSE;
    END get_block_txt;

    /**
    * Returns data blocks that only have cancelled records.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note identifier
    * @param i_configs_ctx            Configs context structure
    * @param i_id_pn_soap_block       Soap block ID
    * @param o_cancelled              Output cursor
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         Vanessa Barsottelli
    * @version                        2.6.4
    * @since                          07-07-2014
    */
    FUNCTION get_dblock_cancelled
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        i_configs_ctx      IN pk_prog_notes_types.t_configs_ctx,
        i_id_pn_soap_block IN table_number,
        o_cancelled        OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name        VARCHAR2(21 CHAR) := 'GET_DBLOCK_CANCELLED';
        l_id_pn_soap_block table_number;
        l_msg              sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                   i_code_mess => 'CHIEF_COMPLAINT_CANCELLED_REC');
    
        l_msg_removed sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                              i_code_mess => 'PROGRESS_NOTES_M015');
    BEGIN
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        g_error := 'GET CANCELLED RECORDS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_cancelled FOR
            SELECT t.block_id,
                   t.id_pn_data_block,
                   decode(flg_status, pk_prog_notes_constants.g_epis_pn_det_flg_status_r, l_msg_removed, l_msg) pn_note,
                   pk_prog_notes_constants.g_yes flg_show_icon
              FROM (SELECT /*+opt_estimate(table,db,scale_rows=0.000001)*/
                     epd.id_pn_soap_block block_id,
                     epd.id_pn_data_block,
                     epdw.rank_task,
                     epdw.dt_req_task,
                     epdw.dt_task,
                     epdw.id_epis_pn_det,
                     nvl(epdw.dt_task, epd.dt_pn) dt_last_update,
                     epd.flg_status,
                     row_number() over(PARTITION BY epd.id_pn_soap_block, epd.id_pn_data_block ORDER BY epd.id_pn_soap_block, epd.id_pn_data_block, epd.dt_pn DESC) rn
                      FROM epis_pn_det epd
                      JOIN epis_pn epn
                        ON epn.id_epis_pn = epd.id_epis_pn
                      LEFT JOIN TABLE(i_configs_ctx.data_blocks) db
                        ON epd.id_pn_soap_block = db.id_pn_soap_block
                       AND epd.id_pn_data_block = db.id_pn_data_block
                      JOIN epis_pn_det_task epdw
                        ON epdw.id_epis_pn_det = epd.id_epis_pn_det
                       AND db.flg_import = pk_prog_notes_constants.g_import_block
                     WHERE epd.id_epis_pn = i_id_epis_pn
                       AND (l_id_pn_soap_block IS NULL OR
                           epd.id_pn_soap_block IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                      column_value
                                                       FROM TABLE(l_id_pn_soap_block) t))
                       AND epd.flg_status IN (pk_prog_notes_constants.g_epis_pn_det_flg_status_r,
                                              pk_prog_notes_constants.g_epis_pn_det_aut_rem_z)
                       AND epdw.id_parent IS NULL
                       AND epdw.id_task_type IN (pk_prog_notes_constants.g_task_chief_complaint_anm,
                                                 pk_prog_notes_constants.g_task_chief_complaint,
                                                 pk_prog_notes_constants.g_task_emergency_law,
                                                 pk_prog_notes_constants.g_task_templates)
                       AND NOT EXISTS
                     (SELECT 1
                              FROM epis_pn_det d
                             WHERE d.id_epis_pn = i_id_epis_pn
                               AND d.id_pn_data_block = epd.id_pn_data_block
                               AND d.id_pn_soap_block = epd.id_pn_soap_block
                               AND d.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a)) t
             WHERE t.rn = 1
             ORDER BY t.rank_task, t.dt_req_task DESC, t.dt_task DESC, t.dt_last_update DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_dblock_cancelled;

    /**
    * Returns the notes to the summary grid.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn        Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_flg_comments           Y-Returns the comment records. N-otherwise
    * @param i_flg_editable           A-Editable note. T-Not editable except free texts N-Otherwise
    * @param i_market                 Market ID
    * @param i_configs_ctx            Configs context structure 
    * @param i_id_pn_soap_block       Soap block ID
    * @param o_text_blocks            Output cursor
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   11-Jul-2012
    */

    FUNCTION get_comments
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        i_flg_editable     IN VARCHAR2,
        i_configs_ctx      IN pk_prog_notes_types.t_configs_ctx,
        i_id_pn_soap_block IN table_number,
        o_text_blocks      OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_pn_soap_block table_number;
    BEGIN
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        g_error := 'GET comments from def model';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'get_comments');
        OPEN o_text_blocks FOR
            SELECT t_int.id_epis_pn,
                   t_int.id_epis_pn_det,
                   t_int.block_id,
                   t_int.id_pn_data_block,
                   t_int.pn_note,
                   t_int.id_task,
                   t_int.id_task_aggregator,
                   t_int.id_epis_pn_det_task,
                   t_int.note_date,
                   t_int.flg_table_origin,
                   t_int.id_pn_task_type,
                   t_int.flg_review,
                   decode(nvl(t_int.id_prof_task, i_prof.id),
                          i_prof.id,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_may_edit,
                   (SELECT pk_prog_notes_utils.get_signature(i_lang               => i_lang,
                                                             i_prof               => i_prof,
                                                             i_id_episode         => t_int.id_episode,
                                                             i_id_prof_last_upd   => t_int.id_prof_last_update,
                                                             i_dt_last_upd        => t_int.dt_last_update,
                                                             i_id_prof_review     => t_int.id_prof_review,
                                                             i_dt_review          => t_int.dt_review,
                                                             i_flg_show_signature => t_int.flg_show_signature)
                      FROM dual) signature,
                   CASE
                        WHEN t_int.id_task_type = pk_prog_notes_constants.g_task_dicharge_sch
                             AND t_int.id_task IS NOT NULL THEN
                         pk_discharge.get_dich_sch_flg_hour_origin(i_lang, i_prof, t_int.id_task)
                    END flg_hour_origin,
                   t_int.flg_remove,
                   t_int.flg_state_review,
                   t_int.flg_state_remove,
                   t_int.dt_note,
                   t_int.flg_select_in_group,
                   (SELECT pk_prog_notes_utils.get_flg_no_action(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_flg_dblock_type => t_int.flg_type,
                                                                 i_flg_editable    => i_flg_editable)
                      FROM dual) flg_no_action,
                   CASE
                        WHEN t_int.flg_status = pk_prog_notes_constants.g_epis_pn_det_sug_add_s THEN
                         pk_alert_constant.g_yes
                        ELSE
                        
                         pk_alert_constant.g_no
                    END flg_suggested,
                   t_int.id_parent,
                   pk_alert_constant.g_no flg_has_multichoice,
                   t_int.flg_show_signature
              FROM (SELECT /*+opt_estimate(table,db,scale_rows=0.000001)*/
                     epd.id_epis_pn,
                     epd.id_epis_pn_det,
                     epd.id_pn_soap_block block_id,
                     epd.id_pn_data_block,
                     epdw.pn_note pn_note,
                     epdw.id_task,
                     epdw.id_task_aggregator,
                     epdw.id_epis_pn_det_task,
                     NULL note_date,
                     epdw.flg_table_origin,
                     epdw.id_task_type id_pn_task_type,
                     pk_alert_constant.g_no flg_review,
                     pk_alert_constant.g_no flg_remove, --it is not possible to remove a comment independetly from the main task
                     NULL flg_state_review,
                     pk_prog_notes_constants.g_epis_pn_det_flg_status_r flg_state_remove,
                     epd.dt_note,
                     pk_alert_constant.g_no flg_select_in_group,
                     epdw.dt_last_update,
                     epdw.dt_task,
                     epdw.id_parent,
                     db.flg_type,
                     epdw.flg_status,
                     nvl(epdw.id_prof_last_update, epdw.id_prof_task) id_prof_last_update,
                     epdw.id_prof_task,
                     epn.id_episode,
                     epdw.id_task_type,
                     (SELECT pk_prog_notes_utils.get_flg_show_signature(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_flg_suggested    => pk_alert_constant.g_no,
                                                                        i_id_prof_reg      => nvl(epdw.id_prof_review,
                                                                                                  nvl(epdw.id_prof_last_update,
                                                                                                      epdw.id_prof_task)),
                                                                        i_flg_import_date  => db.flg_import_date,
                                                                        i_dblock_data_area => db.data_area,
                                                                        i_flg_import       => db.flg_import,
                                                                        i_flg_signature    => db.flg_signature)
                        FROM dual) flg_show_signature,
                     epdw.id_prof_review,
                     epdw.dt_review
                      FROM epis_pn_det epd
                      JOIN epis_pn epn
                        ON epn.id_epis_pn = epd.id_epis_pn
                      LEFT JOIN TABLE(i_configs_ctx.data_blocks) db
                        ON epd.id_pn_soap_block = db.id_pn_soap_block
                       AND epd.id_pn_data_block = db.id_pn_data_block
                     INNER JOIN epis_pn_det_task epdw
                        ON (epdw.id_epis_pn_det = epd.id_epis_pn_det)
                    
                     WHERE epd.id_epis_pn = i_id_epis_pn
                       AND epdw.id_parent IS NOT NULL
                       AND (l_id_pn_soap_block IS NULL OR
                           epd.id_pn_soap_block IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                      column_value
                                                       FROM TABLE(l_id_pn_soap_block) t))
                       AND epdw.flg_status IN (pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                               pk_prog_notes_constants.g_epis_pn_det_sug_add_s)) t_int
             ORDER BY t_int.dt_task DESC, t_int.dt_last_update DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_text_blocks);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_COMMENTS',
                                              o_error);
        
            RETURN FALSE;
    END get_comments;

    /**
    *  Get the import configs and set them in the temporary table
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_episode             Episode ID
    * @param i_flg_filter             Filter to apply 
    * @param o_flg_ongoing            O-auto-populate the ongoing tasks.F- finalized tasks.I-inactive tasks. N-otherwize
    * @param o_flg_normal             Y-auto-populate records with normal results. N-otherwize
    * @param o_flg_first_record       Y-auto-populate the first record. N-otherwize 
    * @param o_flg_last_record        Y-auto-populate the last record. N-otherwize
    * @param o_flg_comments           Y-auto-populate the records with comments. N-auto-populate the records without comments. I-not applicable
    * @param o_flg_since_last         P-auto-populate since last record (all records, if there is no previsous note)
    * @param o_flg_ong_exec           A-Ongoing records with at least one completed execution since last note
    * @param o_flg_no_note_sl         B-All records since last note + all records without notes/comments
    * @param o_flg_reviewed_info      V - Filter by reviewed info in the episode. N-Not applicable.
    * @param o_flg_med_filter         Z - Prescriptions that originated a new prescription (and it was finalized: the prescription 
    *                                 was printed), only available for medication continue at home; 
    *                                 E- Ambulatory medication not originated in the medication reconciliation from home medication
    *                                 prescriptoins; N-Not applicable.
    * @param o_flg_stat               Flag that indicates if an order must be executed immediately
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         Sofia Mendes
    * @version                        2.6.1.2
    * @since                          20-Set-2011
    */
    FUNCTION get_auto_pop_options
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_episode              IN episode.id_episode%TYPE,
        i_flg_filter              IN pn_dblock_ttp_mkt.flg_auto_populated%TYPE,
        o_flg_ongoing             OUT NOCOPY VARCHAR2,
        o_flg_normal              OUT NOCOPY VARCHAR2,
        o_flg_first_record        OUT NOCOPY VARCHAR2,
        o_flg_last_record         OUT NOCOPY VARCHAR2,
        o_flg_comments            OUT NOCOPY VARCHAR2,
        o_flg_since_last          OUT NOCOPY VARCHAR2,
        o_flg_ong_exec            OUT NOCOPY VARCHAR2,
        o_flg_no_note_sl          OUT NOCOPY VARCHAR2,
        o_flg_reviewed_info       OUT NOCOPY VARCHAR2,
        o_flg_med_filter          OUT NOCOPY VARCHAR2,
        o_flg_relevant            OUT NOCOPY VARCHAR2,
        o_flg_technical           OUT NOCOPY VARCHAR2,
        o_flg_stat                OUT NOCOPY VARCHAR2,
        o_flg_type                OUT NOCOPY VARCHAR2,
        o_action                  OUT NOCOPY VARCHAR2,
        o_id_pn_note_type_action  OUT NUMBER,
        o_id_pn_data_block_action OUT NUMBER,
        o_flg_view                OUT NOCOPY VARCHAR2,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name   VARCHAR2(20 CHAR) := 'GET_AUTO_POP_OPTIONS';
        l_filter_list table_varchar := table_varchar();
        l_filter      pk_translation.t_desc_translation;
    BEGIN
        o_flg_normal        := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_first_record  := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_last_record   := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_comments      := pk_prog_notes_constants.g_task_comments_na_i;
        o_flg_since_last    := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_ong_exec      := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_no_note_sl    := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_reviewed_info := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_med_filter    := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_relevant      := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_technical     := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_stat          := pk_prog_notes_constants.g_task_not_applicable_n;
        o_flg_view          := '';
    
        --ALERT-173 change filter
        pk_alertlog.log_info('i_flg_filter: ' || i_flg_filter);
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_ongoing_o) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_ongoing_o,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ongoing := pk_prog_notes_constants.g_task_ongoing_o;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_inactive_i) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_inactive_i,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ongoing := o_flg_ongoing || pk_prog_notes_constants.g_task_inactive_i;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_finalized_f) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_finalized_f,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ongoing := o_flg_ongoing || pk_prog_notes_constants.g_task_finalized_f;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_pending_d) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_pending_d,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ongoing := o_flg_ongoing || pk_prog_notes_constants.g_task_pending_d;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_ongoing_q) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_ongoing_q,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ongoing := o_flg_ongoing || pk_prog_notes_constants.g_ongoing_q;
        END IF;
    
        IF (o_flg_ongoing IS NULL)
        THEN
            o_flg_ongoing := pk_prog_notes_constants.g_task_not_applicable_n;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_anormal_a) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_anormal_a,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_normal := pk_alert_constant.g_no;
            --ELSIF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_normal_m) > 0)
        ELSIF (pk_utils.str_token_find(i_string => i_flg_filter,
                                       i_token  => pk_prog_notes_constants.g_auto_pop_normal_m,
                                       i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_normal := pk_alert_constant.g_yes;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_first_record_r) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_first_record_r,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_first_record := pk_alert_constant.g_yes;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_last_record_l) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_last_record_l,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_last_record := pk_prog_notes_constants.g_auto_pop_last_record_l;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_last_record_l_area,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_last_record := pk_prog_notes_constants.g_auto_pop_last_record_area;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_last_rec_subg_s) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_last_rec_subg_s,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_last_record := pk_prog_notes_constants.g_auto_pop_last_rec_subg_s;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_last_rec_gr_g) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_last_rec_gr_g,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_last_record := pk_prog_notes_constants.g_auto_pop_last_rec_gr_g;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_with_notes_w) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_with_notes_w,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_comments := pk_alert_constant.g_yes;
            --ELSIF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_without_notes_t) > 0)
        ELSIF (pk_utils.str_token_find(i_string => i_flg_filter,
                                       i_token  => pk_prog_notes_constants.g_auto_pop_without_notes_t,
                                       i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_comments := pk_alert_constant.g_no;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_since_last_p) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_since_last_p,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            -- to prevent the case of an action over a record in the note. Do not update records accordong to note date
            o_flg_since_last := pk_prog_notes_constants.g_auto_pop_since_last_p;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_ong_exec_c) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_ong_exec_c,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_ong_exec := pk_prog_notes_constants.g_auto_pop_ong_exec_c;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_no_note_sl_b) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_no_note_sl_b,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_no_note_sl := pk_prog_notes_constants.g_auto_pop_no_note_sl_b;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_reviewed_v) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_reviewed_v,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_reviewed_info := pk_prog_notes_constants.g_auto_pop_reviewed_v;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_no_new_presc_k) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_no_new_presc_k,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_no_new_presc_k;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_no_new_presc_z) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_no_new_presc_z,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_no_new_presc_z;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_new_prescs_h) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_new_prescs_h,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_new_prescs_h;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_new_prescs_x) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_new_prescs_x,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_new_prescs_x;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_fin_execs_e) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_fin_execs_e,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_fin_execs_e;
            o_flg_ongoing    := o_flg_ongoing || pk_prog_notes_constants.g_task_finalized_f;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_current_institution,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_current_institution;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_ext_institution,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_med_filter := pk_prog_notes_constants.g_auto_pop_ext_institution;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_invasive_u) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_invasive_u,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_technical := pk_prog_notes_constants.g_auto_pop_invasive_u;
            o_flg_ongoing   := o_flg_ongoing || pk_prog_notes_constants.g_auto_pop_invasive_u;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_chest_xr,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_technical := pk_prog_notes_constants.g_auto_pop_chest_xr;
            o_flg_ongoing   := o_flg_ongoing;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_stat,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_stat := pk_prog_notes_constants.g_stat;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_stat_result,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_stat := pk_prog_notes_constants.g_stat_result;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_exam_pathology_pt,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_technical := pk_prog_notes_constants.g_auto_pop_exam_pathology_pt;
        END IF;
    
        --IF (instr(i_flg_filter, pk_prog_notes_constants.g_auto_pop_relevant_j) > 0)
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_relevant_j,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_relevant := pk_prog_notes_constants.g_auto_pop_relevant_j;
        END IF;
    
        IF (instr(i_flg_filter, pk_prog_notes_constants.g_action_copy_record_from_note) > 0)
        THEN
            l_filter := regexp_substr(i_flg_filter,
                                      '(\w*-\d*-\d*)',
                                      instr(i_flg_filter, pk_prog_notes_constants.g_action_copy_record_from_note));
            pk_alertlog.log_debug('l_filter: ' || l_filter);
            BEGIN
                l_filter_list             := pk_string_utils.str_split(i_list => l_filter, i_delim => '-');
                o_action                  := l_filter_list(1);
                o_id_pn_note_type_action  := to_number(l_filter_list(2));
                o_id_pn_data_block_action := to_number(l_filter_list(3));
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
        END IF;
    
        IF (instr(i_flg_filter, pk_prog_notes_constants.g_action_cp_rec_from_same_note) > 0)
        THEN
            l_filter := regexp_substr(i_flg_filter,
                                      '(\w*-\d*-\d*)',
                                      instr(i_flg_filter, pk_prog_notes_constants.g_action_cp_rec_from_same_note));
            pk_alertlog.log_debug('l_filter: ' || l_filter);
            BEGIN
                l_filter_list             := pk_string_utils.str_split(i_list => l_filter, i_delim => '-');
                o_action                  := l_filter_list(1);
                o_id_pn_note_type_action  := to_number(l_filter_list(2));
                o_id_pn_data_block_action := to_number(l_filter_list(3));
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_bd_others,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_bd_others;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_bd_neur_assessm,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_bd_neur_assessm;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_bd_drain,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_bd_drain;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_bd_medical_needs,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_bd_medical_needs;
        END IF;
    
        -- MISS: Modified Injury Severity Score
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_miss,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_miss;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_b_streptococcus,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_b_streptococcus;
        END IF;
    
        IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_b_chemo,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep || pk_prog_notes_constants.g_auto_pop_b_chemo;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_antibiotic,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep || pk_prog_notes_constants.g_auto_pop_antibiotic;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_non_antibiotic,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_non_antibiotic;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_restraint_order,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_restraint_order;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_chemotherapy,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_chemotherapy;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n2,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n2;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_procedure_gen,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_procedure_gen;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_procedure_reh,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_procedure_reh;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_procedure_oth,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_procedure_oth;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_procedure_dent,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_procedure_dent;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_auto_pop_procedure_obs,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_sep ||
                          pk_prog_notes_constants.g_auto_pop_procedure_obs;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n3,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n3;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n4,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n4;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_primary_diagnosis,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_type := pk_prog_notes_constants.g_primary_diagnosis;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_secondary_diagnosis,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_type := pk_prog_notes_constants.g_secondary_diagnosis;
        END IF;
    
        /*IF pk_utils.str_token_find(i_string => i_flg_filter,
                                   i_token  => pk_prog_notes_constants.g_auto_pop_mapacheii,
                                   i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes
        THEN
            o_flg_type := o_flg_type || pk_prog_notes_constants.g_auto_pop_mapacheii;
        END IF;*/
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_replied_opinion,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_type := pk_prog_notes_constants.g_replied_opinion;
        END IF;
    
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n5,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n5;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n6,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n6;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_n7,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_n7;
        END IF;
        IF (pk_utils.str_token_find(i_string => i_flg_filter,
                                    i_token  => pk_prog_notes_constants.g_vs_view_pt,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes)
        THEN
            o_flg_view := pk_prog_notes_constants.g_vs_view_pt;
        END IF;
        pk_alertlog.log_info('o_flg_ongoing: ' || o_flg_ongoing || ', o_flg_normal: ' || o_flg_normal ||
                             ', o_flg_first_record: ' || o_flg_first_record || ', o_flg_last_record: ' ||
                             o_flg_last_record || 'o_flg_comments: ' || o_flg_comments || 'o_flg_since_last: ' ||
                             o_flg_since_last || 'o_flg_ong_exec: ' || o_flg_ong_exec || 'o_flg_no_note_sl: ' ||
                             o_flg_no_note_sl || 'o_flg_reviewed_info: ' || o_flg_reviewed_info ||
                             'o_flg_med_filter: ' || o_flg_med_filter || 'o_flg_relevant: ' || o_flg_relevant ||
                             'o_flg_technical: ' || o_flg_technical || 'o_flg_stat' || o_flg_stat || ' o_flg_type: ' ||
                             o_flg_type);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_auto_pop_options;

    /**
    *  Get the tasks associated to the note, through shortcut or import
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note id
    * @param o_tasks                  Tasks associated to the note done by shortcut or import
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         Sofia Mendes
    * @version                        2.6.3.1
    * @since                          27-Nov-2012
    */
    FUNCTION get_not_auto_pop_tasks
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        o_tasks      OUT NOCOPY pk_prog_notes_types.t_tasks_by_sblock,
        i_id_epis_pn IN epis_pn.id_epis_pn%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'GET_NOT_AUTO_POP_TASKS';
        l_tasks_by_sblock   pk_prog_notes_types.t_tasks_by_sblock;
        l_tasks             pk_prog_notes_types.t_table_task_action := pk_prog_notes_types.t_table_task_action();
        l_rec_task_action   pk_prog_notes_types.t_rec_task_action;
        l_prev_id_pn_sblock epis_pn_det.id_pn_soap_block%TYPE;
        l_prev_id_pn_dblock epis_pn_det.id_pn_data_block%TYPE;
        l_prev_id_task_type epis_pn_det_task.id_task_type%TYPE;
    BEGIN
    
        IF (i_id_epis_pn IS NOT NULL)
        THEN
            g_error := 'get the tasks done by shortcut or import. i_id_epis_pn: ' || i_id_epis_pn;
            pk_alertlog.log_debug(g_error);
            FOR rec IN (SELECT epd.id_pn_soap_block,
                               epd.id_pn_data_block,
                               epdt.id_task_type,
                               epdt.id_task,
                               epdt.flg_action
                          FROM epis_pn_det_task epdt
                          JOIN epis_pn_det epd
                            ON epd.id_epis_pn_det = epdt.id_epis_pn_det
                          JOIN epis_pn epn
                            ON epn.id_epis_pn = epd.id_epis_pn
                         WHERE epn.id_epis_pn = i_id_epis_pn
                           AND epdt.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                           AND epdt.flg_action IN (pk_prog_notes_constants.g_flg_action_shortcut,
                                                   pk_prog_notes_constants.g_flg_action_import)
                         ORDER BY epd.id_pn_soap_block, epd.id_pn_data_block, epdt.id_task_type)
            LOOP
            
                IF (l_prev_id_task_type <> rec.id_task_type OR l_prev_id_task_type IS NULL)
                THEN
                    IF (l_prev_id_task_type IS NOT NULL)
                    THEN
                        l_tasks_by_sblock(l_prev_id_pn_sblock)(l_prev_id_pn_dblock)(l_prev_id_task_type) := l_tasks;
                    END IF;
                    l_rec_task_action.id_task    := rec.id_task;
                    l_rec_task_action.flg_action := rec.flg_action;
                
                    l_tasks.extend(1);
                    l_tasks(l_tasks.last) := l_rec_task_action;
                
                    l_prev_id_task_type := rec.id_task_type;
                ELSE
                    l_rec_task_action.id_task    := rec.id_task;
                    l_rec_task_action.flg_action := rec.flg_action;
                
                    l_tasks.extend(1);
                    l_tasks(l_tasks.last) := l_rec_task_action;
                END IF;
            
                IF (l_prev_id_pn_sblock <> rec.id_pn_soap_block OR l_prev_id_pn_sblock IS NULL)
                THEN
                    l_prev_id_pn_sblock := rec.id_pn_soap_block;
                END IF;
            
                IF (l_prev_id_pn_dblock <> rec.id_pn_data_block OR l_prev_id_pn_dblock IS NULL)
                THEN
                    l_prev_id_pn_dblock := rec.id_pn_data_block;
                END IF;
            
            END LOOP;
        
            IF (l_tasks IS NOT NULL AND l_tasks.exists(1))
            THEN
                l_tasks_by_sblock(l_prev_id_pn_sblock)(l_prev_id_pn_dblock)(l_prev_id_task_type) := l_tasks;
            END IF;
        
        END IF;
    
        o_tasks := l_tasks_by_sblock;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_not_auto_pop_tasks;

    /**
    *  Get the import configs and set them in the temporary table
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_episode             Episode identifier
    * @param i_id_patient             Patient identifier
    * @param i_data_blocks            Data blocks to be imported
    * @param i_begin_date             Import start date
    * @param i_end_date               Import end date
    * @param i_flg_synch_note         Y-this note type should be synchronized. Should opens directly the edit screen. N-otherwize
    * @param i_import_screen          Y- We are in the import screen: we . Should opens directly the edit screen. N-otherwize
    * @param i_action                 A-Auto-population; I-import
    * @param i_id_epis_pn             Note id
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_id_task_type           Task type ID: specific task type to be synchronized
    * @param i_dt_proposed            note proposed date
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         Sofia Mendes
    * @version                        2.6.1.2
    * @since                          20-Set-2011
    */
    FUNCTION get_import_configs
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_patient          IN patient.id_patient%TYPE,
        i_data_blocks         IN t_coll_data_blocks,
        i_begin_date          IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date            IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_synch_note      IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_import_screen       IN VARCHAR2,
        i_action              IN VARCHAR2 DEFAULT pk_prog_notes_constants.g_flg_action_import,
        i_id_visit            IN visit.id_visit%TYPE,
        i_id_pn_note_type     IN pn_note_type.id_pn_note_type%TYPE,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_epis_pn_det_task IN table_number,
        i_id_task_type        IN epis_pn_det_task.id_task_type%TYPE,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dblocks_count PLS_INTEGER;
        l_id_patient    patient.id_patient%TYPE;
    
        l_scope           NUMBER;
        l_begin_date      TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_date        TIMESTAMP WITH LOCAL TIME ZONE;
        l_prev_data_block pn_data_block.id_pn_data_block%TYPE := NULL;
    
        l_id_visit_scope   visit.id_visit%TYPE;
        l_id_episode_scope episode.id_episode%TYPE;
    
        l_task_types    table_number;
        l_nr_task_types PLS_INTEGER;
    
        l_flg_ongoing      VARCHAR2(24 CHAR);
        l_flg_normal       VARCHAR2(1 CHAR);
        l_flg_first_record VARCHAR2(1 CHAR);
        l_flg_last_record  VARCHAR2(1 CHAR);
        l_flg_comments     VARCHAR2(1 CHAR);
        l_flg_since_last   VARCHAR2(1 CHAR);
        l_flg_ong_exec     VARCHAR2(1 CHAR);
        l_flg_no_note_sl   VARCHAR2(1 CHAR);
        l_note_date        TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_func_name CONSTANT VARCHAR2(18 CHAR) := 'GET_IMPORT_CONFIGS';
        l_flg_reviwed_info VARCHAR2(1 CHAR);
        l_flg_med_filter   VARCHAR2(24 CHAR);
        l_flg_relevant     VARCHAR2(1 CHAR);
        l_flg_technical    VARCHAR2(24 CHAR);
        l_flg_stat         VARCHAR2(24 CHAR);
        l_flg_type         pk_types.t_low_char;
        l_flg_view         VARCHAR2(2 CHAR);
    
        l_tasks_by_sblock         pk_prog_notes_types.t_tasks_by_sblock;
        l_task_type_tasks         pk_prog_notes_types.t_table_task_action;
        l_count_task_type_tasks   PLS_INTEGER;
        l_dblock_in_tmptbl        PLS_INTEGER := 0;
        l_action                  VARCHAR2(200 CHAR);
        l_id_pn_note_type_action  NUMBER;
        l_id_pn_data_block_action NUMBER;
    
    BEGIN
    
        g_error := 'delete tmp_pn_configs';
        pk_alertlog.log_debug(g_error);
        DELETE tmp_pn_configs;
    
        IF (i_id_patient IS NULL)
        THEN
            l_id_patient := pk_episode.get_id_patient(i_episode => i_id_episode);
        ELSE
            l_id_patient := i_id_patient;
        END IF;
    
        IF (i_action <> pk_prog_notes_constants.g_flg_action_import)
        THEN
            g_error := 'call get_not_auto_pop_tasks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT get_not_auto_pop_tasks(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          o_tasks      => l_tasks_by_sblock,
                                          i_id_epis_pn => i_id_epis_pn,
                                          o_error      => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        --Loop through the list of importable blocks to retrieve data of the task types associated to the data blocks
        l_dblocks_count := i_data_blocks.count;
    
        g_error := 'Loop through the list of blocks';
        pk_alertlog.log_debug(g_error);
        FOR i IN 1 .. l_dblocks_count
        LOOP
            IF (i_data_blocks(i).id_pn_data_block <> l_prev_data_block OR l_prev_data_block IS NULL)
            THEN
                g_error := 'Get get_data_block_configs';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_data_block_configs(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_episode             => i_id_episode,
                                              i_patient             => l_id_patient,
                                              i_id_visit            => i_id_visit,
                                              i_begin_date          => i_begin_date,
                                              i_end_date            => i_end_date,
                                              i_action              => i_action,
                                              i_data_blocks         => i_data_blocks(i),
                                              i_id_epis_pn          => i_id_epis_pn,
                                              i_id_pn_note_type     => i_id_pn_note_type,
                                              i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                              i_dt_proposed         => i_dt_proposed,
                                              i_flg_synch_note      => i_flg_synch_note,
                                              i_import_screen       => i_import_screen,
                                              o_note_date           => l_note_date,
                                              o_begin_date          => l_begin_date,
                                              o_end_date            => l_end_date,
                                              o_scope               => l_scope,
                                              o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                l_id_visit_scope := CASE
                                        WHEN i_data_blocks(i).flg_scope IN (pk_prog_notes_constants.g_flg_scope_v,
                                                            pk_prog_notes_constants.g_flg_scope_e) THEN
                                         i_id_visit
                                        ELSE
                                         NULL
                                    END;
            
                l_id_episode_scope := CASE
                                          WHEN i_data_blocks(i).flg_scope = pk_prog_notes_constants.g_flg_scope_e THEN
                                           i_id_episode
                                          ELSE
                                           NULL
                                      END;
            END IF;
        
            --check if the task type has children, if so the EA records are associated to the child task types
            g_error := 'CALL pk_prog_notes_utils.get_child_task_types. parent task type: ' || i_data_blocks(i).id_pn_task_type;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_child_task_types(i_lang          => i_lang,
                                                            i_prof          => i_prof,
                                                            i_id_task_type  => i_data_blocks(i).id_pn_task_type,
                                                            o_task_types    => l_task_types,
                                                            o_nr_task_types => l_nr_task_types,
                                                            o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            FOR j IN 1 .. l_nr_task_types
            LOOP
            
                IF ((i_action = pk_prog_notes_constants.g_flg_action_autopop AND
                   /*(i_data_blocks(i).flg_auto_populated <> pk_alert_constant.g_no OR i_data_blocks(i).flg_synchronized <> pk_alert_constant.g_no)) OR*/
                   (pk_utils.str_token_find(i_string => i_data_blocks(i).flg_auto_populated,
                                              i_token  => pk_alert_constant.g_no,
                                              i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_no OR
                   pk_utils.str_token_find(i_string => i_data_blocks(i).flg_synchronized,
                                              i_token  => pk_alert_constant.g_no,
                                              i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_no)) OR
                   (i_action = pk_prog_notes_constants.g_flg_action_import) OR (i_id_task_type IS NOT NULL))
                THEN
                
                    g_error := 'CALL get_auto_pop_options';
                    pk_alertlog.log_debug(g_error);
                    IF NOT get_auto_pop_options(i_lang                    => i_lang,
                                           i_prof                    => i_prof,
                                           i_id_episode              => i_id_episode,
                                           i_flg_filter              => CASE
                                                                            WHEN i_action = pk_prog_notes_constants.g_flg_action_autopop THEN
                                                                             CASE
                                                                             --WHEN i_data_blocks(i).flg_auto_populated <> pk_alert_constant.g_no THEN
                                                                                 WHEN pk_utils.str_token_find(i_string => i_data_blocks(i).flg_auto_populated,
                                                                                                              i_token  => pk_alert_constant.g_no,
                                                                                                              i_sep    => pk_prog_notes_constants.g_sep) =
                                                                                      pk_alert_constant.g_no THEN
                                                                                  i_data_blocks(i).flg_auto_populated
                                                                                 ELSE
                                                                                  i_data_blocks(i).flg_synchronized
                                                                             END
                                                                            ELSE
                                                                             i_data_blocks(i).flg_import_filter
                                                                        END,
                                           o_flg_ongoing             => l_flg_ongoing,
                                           o_flg_normal              => l_flg_normal,
                                           o_flg_first_record        => l_flg_first_record,
                                           o_flg_last_record         => l_flg_last_record,
                                           o_flg_comments            => l_flg_comments,
                                           o_flg_since_last          => l_flg_since_last,
                                           o_flg_ong_exec            => l_flg_ong_exec,
                                           o_flg_no_note_sl          => l_flg_no_note_sl,
                                           o_flg_reviewed_info       => l_flg_reviwed_info,
                                           o_flg_med_filter          => l_flg_med_filter,
                                           o_flg_relevant            => l_flg_relevant,
                                           o_flg_technical           => l_flg_technical,
                                           o_flg_stat                => l_flg_stat,
                                           o_flg_type                => l_flg_type,
                                           o_action                  => l_action,
                                           o_id_pn_note_type_action  => l_id_pn_note_type_action,
                                           o_id_pn_data_block_action => l_id_pn_data_block_action,
                                           o_flg_view                => l_flg_view,
                                           o_error                   => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    IF (i_id_task_type IS NULL OR i_id_task_type = l_task_types(j))
                    THEN
                        g_error := 'Insert into tmp_pn_configs. : id_task_type: ' || l_task_types(j) ||
                                   ' id_data_block: ' || i_data_blocks(i).id_pn_data_block || ' i_id_patient: ' ||
                                   l_id_patient || ' block_id: ' || i_data_blocks(i).block_id || ' id_doc_area: ' || i_data_blocks(i).id_doc_area ||
                                   ' id_visit: ' || l_id_visit_scope || ' id_episode: ' || l_id_episode_scope ||
                                   ' flg_outside_period: ' || i_data_blocks(i).flg_outside_period ||
                                   ' flg_import_date: ' || i_data_blocks(i).flg_import_date || ' flg_group_on_import: ' || i_data_blocks(i).flg_group_on_import ||
                                   ' flg_synchronized: ' || i_data_blocks(i).flg_synchronized;
                        pk_alertlog.log_debug(g_error);
                        g_error := ' l_flg_ongoing: ' || l_flg_ongoing || ' l_flg_normal: ' || l_flg_normal ||
                                   ' auto_pop_exec_prof_cat: ' || i_data_blocks(i).auto_pop_exec_prof_cat ||
                                   ' l_flg_first_record: ' || l_flg_first_record || ' l_flg_last_record: ' ||
                                   l_flg_last_record || ' l_flg_comments: ' || l_flg_comments || ' l_flg_since_last: ' ||
                                   l_flg_since_last || ' l_flg_ong_exec: ' || l_flg_ong_exec || ' l_flg_no_note_sl: ' ||
                                   l_flg_no_note_sl || ' id_summary_page: ' || i_data_blocks(i).id_summary_page ||
                                   ' flg_actions_available: ' || i_data_blocks(i).flg_actions_available ||
                                   ' flg_show_sub_title: ' || i_data_blocks(i).flg_show_sub_title ||
                                   ' review_context: ' || i_data_blocks(i).review_context || ' FLG_REVIEWED_INFO:' ||
                                   l_flg_reviwed_info || ' l_flg_med_filter: ' || l_flg_med_filter ||
                                   ' last_n_records_nr: ' || i_data_blocks(i).last_n_records_nr ||
                                   'days_available_period:' || i_data_blocks(i).days_available_period || 'flg_type:' ||
                                   l_flg_type || ' l_note_date:' || l_note_date;
                        pk_alertlog.log_debug(g_error);
                        INSERT INTO tmp_pn_configs
                            (id_task_type,
                             id_pn_data_block,
                             id_pn_soap_block,
                             id_doc_area,
                             id_patient,
                             id_visit,
                             id_episode,
                             dt_begin,
                             dt_end,
                             flg_outside_period,
                             flg_import_date,
                             flg_group_on_import,
                             flg_synchronized,
                             flg_ongoing,
                             flg_normal,
                             auto_pop_exec_prof_cat,
                             flg_first_record,
                             flg_last_n_records,
                             last_note_date,
                             flg_comments,
                             flg_since_last,
                             flg_ong_exec,
                             flg_no_note_sl,
                             id_summary_page,
                             flg_actions_available,
                             flg_show_sub_title,
                             review_context,
                             flg_reviewed_info,
                             flg_med_filter,
                             last_n_records_nr,
                             review_cat,
                             flg_technical,
                             flg_stat,
                             flg_relevant,
                             flg_description,
                             description_condition,
                             action,
                             id_pn_note_type_action,
                             id_pn_data_block_action,
                             flg_type,
                             days_available_period,
                             id_mtos_score,
                             flg_dt_task,
                             flg_exc_sum_page_da,
                             flg_group_type)
                        VALUES
                            (l_task_types(j),
                             i_data_blocks(i).id_pn_data_block,
                             i_data_blocks(i).block_id,
                             i_data_blocks(i).id_doc_area,
                             l_id_patient,
                             decode(l_flg_reviwed_info,
                                    pk_prog_notes_constants.g_auto_pop_reviewed_v,
                                    NULL,
                                    l_id_visit_scope),
                             decode(l_flg_reviwed_info,
                                    pk_prog_notes_constants.g_auto_pop_reviewed_v,
                                    NULL,
                                    l_id_episode_scope),
                             l_begin_date,
                             l_end_date,
                             i_data_blocks(i).flg_outside_period,
                             i_data_blocks(i).flg_import_date,
                             i_data_blocks(i).flg_group_on_import,
                             nvl(i_data_blocks(i).flg_synchronized, pk_alert_constant.g_no),
                             l_flg_ongoing,
                             l_flg_normal,
                             i_data_blocks(i).auto_pop_exec_prof_cat,
                             l_flg_first_record,
                             l_flg_last_record,
                             l_note_date,
                             l_flg_comments,
                             l_flg_since_last,
                             l_flg_ong_exec,
                             l_flg_no_note_sl,
                             i_data_blocks(i).id_summary_page,
                             nvl(i_data_blocks(i).flg_actions_available, pk_alert_constant.g_no),
                             i_data_blocks(i).flg_show_sub_title,
                             i_data_blocks(i).review_context,
                             l_flg_reviwed_info,
                             l_flg_med_filter,
                             i_data_blocks(i).last_n_records_nr,
                             i_data_blocks(i).review_cat,
                             l_flg_technical,
                             l_flg_stat,
                             l_flg_relevant,
                             i_data_blocks(i).flg_description,
                             i_data_blocks(i).description_condition,
                             l_action,
                             l_id_pn_note_type_action,
                             l_id_pn_data_block_action,
                             l_flg_type,
                             i_data_blocks(i).days_available_period,
                             i_data_blocks(i).id_mtos_score,
                             i_data_blocks(i).flg_dt_task,
                             i_data_blocks(i).flg_exc_sum_page_da,
                             i_data_blocks(i).flg_group_type);
                    
                        l_dblock_in_tmptbl := 1;
                    END IF;
                END IF;
            
                --if the data block and task type are not in the tmp table yet
                IF (l_dblock_in_tmptbl = 0)
                THEN
                    --       na auto-popula?
                    --       se flg_auto_pop = N e flg_sync <> N
                    -- ver se ha registos com flg_action in ('S', 'I')
                    IF (l_tasks_by_sblock.exists(i_data_blocks(i).block_id))
                    THEN
                        IF (l_tasks_by_sblock(i_data_blocks(i).block_id).exists(i_data_blocks(i).id_pn_data_block))
                        THEN
                            IF (l_tasks_by_sblock(i_data_blocks(i).block_id)(i_data_blocks(i).id_pn_data_block).exists(l_task_types(j)))
                            THEN
                                l_task_type_tasks := l_tasks_by_sblock(i_data_blocks(i).block_id)
                                                     (i_data_blocks(i).id_pn_data_block) (l_task_types(j));
                            END IF;
                        END IF;
                    END IF;
                
                    IF (l_task_type_tasks IS NOT NULL AND l_task_type_tasks.exists(1))
                    THEN
                        l_count_task_type_tasks := l_task_type_tasks.count;
                    
                        FOR k IN 1 .. l_count_task_type_tasks
                        LOOP
                        
                            g_error := 'CALL get_auto_pop_options';
                            pk_alertlog.log_debug(g_error);
                            IF NOT get_auto_pop_options(i_lang                    => i_lang,
                                                   i_prof                    => i_prof,
                                                   i_id_episode              => i_id_episode,
                                                   i_flg_filter              => CASE
                                                                                    WHEN l_task_type_tasks(k)
                                                                                     .flg_action = pk_prog_notes_constants.g_flg_action_shortcut THEN
                                                                                     i_data_blocks(i).flg_shortcut_filter
                                                                                    ELSE
                                                                                     i_data_blocks(i).flg_import_filter
                                                                                END,
                                                   o_flg_ongoing             => l_flg_ongoing,
                                                   o_flg_normal              => l_flg_normal,
                                                   o_flg_first_record        => l_flg_first_record,
                                                   o_flg_last_record         => l_flg_last_record,
                                                   o_flg_comments            => l_flg_comments,
                                                   o_flg_since_last          => l_flg_since_last,
                                                   o_flg_ong_exec            => l_flg_ong_exec,
                                                   o_flg_no_note_sl          => l_flg_no_note_sl,
                                                   o_flg_reviewed_info       => l_flg_reviwed_info,
                                                   o_flg_med_filter          => l_flg_med_filter,
                                                   o_flg_relevant            => l_flg_relevant,
                                                   o_flg_technical           => l_flg_technical,
                                                   o_flg_stat                => l_flg_stat,
                                                   o_flg_type                => l_flg_type,
                                                   o_action                  => l_action,
                                                   o_id_pn_note_type_action  => l_id_pn_note_type_action,
                                                   o_id_pn_data_block_action => l_id_pn_data_block_action,
                                                   o_flg_view                => l_flg_view,
                                                   o_error                   => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            g_error := 'Insert into tmp_pn_configs. : id_task_type: ' || l_task_types(j) ||
                                       ' id_data_block: ' || i_data_blocks(i).id_pn_data_block || ' i_id_patient: ' ||
                                       l_id_patient || ' id_task: ' || l_task_type_tasks(k).id_task;
                            pk_alertlog.log_debug(g_error);
                            INSERT INTO tmp_pn_configs
                                (id_task_type,
                                 id_pn_data_block,
                                 id_pn_soap_block,
                                 id_doc_area,
                                 id_patient,
                                 id_visit,
                                 id_episode,
                                 dt_begin,
                                 dt_end,
                                 flg_outside_period,
                                 flg_import_date,
                                 flg_group_on_import,
                                 flg_synchronized,
                                 flg_ongoing,
                                 flg_normal,
                                 auto_pop_exec_prof_cat,
                                 flg_first_record,
                                 flg_last_n_records,
                                 last_note_date,
                                 flg_comments,
                                 flg_since_last,
                                 flg_ong_exec,
                                 flg_no_note_sl,
                                 id_summary_page,
                                 flg_actions_available,
                                 flg_show_sub_title,
                                 review_context,
                                 flg_reviewed_info,
                                 flg_med_filter,
                                 last_n_records_nr,
                                 id_task,
                                 review_cat,
                                 flg_technical,
                                 flg_stat,
                                 flg_relevant,
                                 action,
                                 id_pn_note_type_action,
                                 id_pn_data_block_action,
                                 flg_type,
                                 days_available_period,
                                 id_mtos_score,
                                 flg_dt_task,
                                 flg_exc_sum_page_da,
                                 flg_group_type)
                            VALUES
                                (l_task_types(j),
                                 i_data_blocks(i).id_pn_data_block,
                                 i_data_blocks(i).block_id,
                                 i_data_blocks(i).id_doc_area,
                                 l_id_patient,
                                 decode(l_flg_reviwed_info,
                                        pk_prog_notes_constants.g_auto_pop_reviewed_v,
                                        NULL,
                                        l_id_visit_scope),
                                 decode(l_flg_reviwed_info,
                                        pk_prog_notes_constants.g_auto_pop_reviewed_v,
                                        NULL,
                                        l_id_episode_scope),
                                 l_begin_date,
                                 l_end_date,
                                 i_data_blocks(i).flg_outside_period,
                                 i_data_blocks(i).flg_import_date,
                                 i_data_blocks(i).flg_group_on_import,
                                 nvl(i_data_blocks(i).flg_synchronized, pk_alert_constant.g_no),
                                 l_flg_ongoing,
                                 l_flg_normal,
                                 i_data_blocks(i).auto_pop_exec_prof_cat,
                                 l_flg_first_record,
                                 l_flg_last_record,
                                 l_note_date,
                                 l_flg_comments,
                                 l_flg_since_last,
                                 l_flg_ong_exec,
                                 l_flg_no_note_sl,
                                 i_data_blocks(i).id_summary_page,
                                 nvl(i_data_blocks(i).flg_actions_available, pk_alert_constant.g_no),
                                 i_data_blocks(i).flg_show_sub_title,
                                 i_data_blocks(i).review_context,
                                 l_flg_reviwed_info,
                                 l_flg_med_filter,
                                 i_data_blocks(i).last_n_records_nr,
                                 l_task_type_tasks(k).id_task,
                                 i_data_blocks(i).review_cat,
                                 l_flg_technical,
                                 l_flg_stat,
                                 l_flg_relevant,
                                 l_action,
                                 l_id_pn_note_type_action,
                                 l_id_pn_data_block_action,
                                 l_flg_type,
                                 i_data_blocks(i).days_available_period,
                                 i_data_blocks(i).id_mtos_score,
                                 i_data_blocks(i).flg_dt_task,
                                 i_data_blocks(i).flg_exc_sum_page_da,
                                 i_data_blocks(i).flg_group_type);
                        END LOOP;
                    END IF;
                END IF;
                l_dblock_in_tmptbl := 0;
            END LOOP;
        
            l_prev_data_block := i_data_blocks(i).id_pn_data_block;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_import_configs;
    /**
    *  Get imported data from temporary tables to be edited in Progress Notes (internal function)
    *  Returns the imported data for several data blocks
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_episode             Episode identifier
    * @param i_id_patient             Patient identifier
    * @param i_id_visit               Visit identifier
    * @param i_data_blocks            Data blocks to be imported
    * @param i_begin_date             Import start date
    * @param i_end_date               Import end date
    * @param i_flg_synch_note         Y-this note type should be synchronized. Should opens directly the edit screen. N-otherwize
    * @param i_import_screen          Y- We are in the import screen: we . Should opens directly the edit screen. N-otherwize
    * @param i_action                 A-Auto-population; I-import
    * @param i_id_pn_note_type        pn_note_type ID
    * @param i_id_tasks               task ID
    * @param i_id_task_types          task type ID
    * @param i_id_pn_soap_block       Soap blocks ID
    * @param i_id_epis_pn             Note ID
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_dt_proposed            note proposed date
    * @param o_data_import            Data bo be imported    
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         Sofia Mendes
    * @version                        2.6.1.2
    * @since                          25-Aug-2011
    */

    FUNCTION get_data_import_list
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_patient          IN patient.id_patient%TYPE,
        i_id_visit            IN visit.id_visit%TYPE,
        i_data_blocks         IN t_coll_data_blocks,
        i_begin_date          IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date            IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_synch_note      IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_import_screen       IN VARCHAR2,
        i_action              IN VARCHAR2 DEFAULT pk_prog_notes_constants.g_flg_action_import,
        i_id_pn_note_type     IN pn_note_type.id_pn_note_type%TYPE,
        i_id_tasks            IN table_number,
        i_id_task_types       IN table_number,
        i_id_pn_soap_block    IN table_number,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_epis_pn_det_task IN table_number,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_only_autopop        IN VARCHAR2,
        o_data_import         OUT t_coll_data_import,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_dblocks_count PLS_INTEGER;
    
        l_scope      NUMBER;
        l_begin_date TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_date   TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_prev_data_block pn_data_block.id_pn_data_block%TYPE := NULL;
    
        l_import_tasks t_coll_data_blocks;
    
        l_count_records PLS_INTEGER;
    
        --data blocks that will be imported from the EA table
        l_dblocks_ea t_coll_data_blocks := t_coll_data_blocks();
    
        --data blocks that will be imported from the respective areas
        l_dblocks_areas t_coll_data_blocks := t_coll_data_blocks();
    
        l_task_types    table_number;
        l_nr_task_types PLS_INTEGER;
    
        l_flg_ongoing       VARCHAR2(24 CHAR);
        l_flg_normal        VARCHAR2(1 CHAR);
        l_flg_first_record  VARCHAR2(1 CHAR);
        l_flg_last_record   VARCHAR2(1 CHAR);
        l_flg_comments      VARCHAR2(1 CHAR);
        l_flg_since_last    VARCHAR2(1 CHAR);
        l_flg_ong_exec      VARCHAR2(1 CHAR);
        l_flg_no_note_sl    VARCHAR2(1 CHAR);
        l_flg_reviewed_info VARCHAR2(1 CHAR);
        l_flg_med_filter    VARCHAR2(24 CHAR);
        l_flg_technical     VARCHAR2(24 CHAR);
        l_flg_stat          VARCHAR(24 CHAR);
        l_flg_relevant      VARCHAR2(1 CHAR);
        l_flg_type_dummy    pk_types.t_low_char;
        l_note_date         TIMESTAMP WITH LOCAL TIME ZONE;
        l_flg_view          VARCHAR(2 CHAR);
    
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'GET_DATA_IMPORT_LIST';
        l_id_pn_soap_block        table_number;
        l_action                  VARCHAR2(200 CHAR);
        l_id_pn_note_type_action  NUMBER;
        l_id_pn_data_block_action NUMBER;
    
        /*l_ids_tests table_number;
        l_flgs_auto table_varchar;
        l_ids_task_types table_number;*/
    
    BEGIN
    
        /*BEGIN
            SELECT d.id_pn_data_block, d.flg_auto_populated, d.id_pn_task_type
              BULK COLLECT
              INTO l_ids_tests, l_flgs_auto, l_ids_task_types
              FROM TABLE(i_data_blocks) d;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;*/
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        SELECT t_rec_data_blocks(d.block_id,
                                 d.id_pn_data_block,
                                 d.id_pndb_parent,
                                 d.data_area,
                                 d.id_doc_area,
                                 d.area_name,
                                 d.flg_type,
                                 d.flg_import,
                                 d.area_level,
                                 d.flg_scope,
                                 d.flg_selected,
                                 d.flg_actions_available,
                                 d.id_swf_file_viewer,
                                 d.flg_line_on_boxes,
                                 d.gender,
                                 d.age_min,
                                 d.age_max,
                                 d.flg_pregnant,
                                 d.flg_auto_populated,
                                 d.flg_cp_no_changes_import,
                                 d.rank,
                                 d.id_pn_task_type,
                                 d.flg_import_date,
                                 d.flg_outside_period,
                                 d.days_available_period,
                                 d.id_pn_task_type_prt,
                                 d.review_context,
                                 d.flg_group_on_import,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 d.flg_show_sub_title,
                                 d.flg_synchronized,
                                 d.flg_data_removable,
                                 d.auto_pop_exec_prof_cat,
                                 d.id_summary_page,
                                 d.flg_focus,
                                 d.flg_editable,
                                 d.flg_import_filter,
                                 d.flg_ea,
                                 d.last_n_records_nr,
                                 d.flg_group_select_filter,
                                 d.flg_synch_area,
                                 d.flg_shortcut_filter,
                                 d.review_cat,
                                 d.flg_review_avail,
                                 d.flg_description,
                                 d.description_condition,
                                 d.id_mtos_score,
                                 d.flg_dt_task,
                                 d.flg_exc_sum_page_da,
                                 flg_group_type)
          BULK COLLECT
          INTO l_dblocks_ea
          FROM TABLE(i_data_blocks) d
         WHERE d.flg_ea = pk_alert_constant.g_yes
           AND (l_id_pn_soap_block IS NULL OR
               d.block_id IN (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value
                                 FROM TABLE(l_id_pn_soap_block) t));
    
        SELECT t_rec_data_blocks(d.block_id,
                                 d.id_pn_data_block,
                                 d.id_pndb_parent,
                                 d.data_area,
                                 d.id_doc_area,
                                 d.area_name,
                                 d.flg_type,
                                 d.flg_import,
                                 d.area_level,
                                 d.flg_scope,
                                 d.flg_selected,
                                 d.flg_actions_available,
                                 d.id_swf_file_viewer,
                                 d.flg_line_on_boxes,
                                 d.gender,
                                 d.age_min,
                                 d.age_max,
                                 d.flg_pregnant,
                                 d.flg_auto_populated,
                                 d.flg_cp_no_changes_import,
                                 d.rank,
                                 d.id_pn_task_type,
                                 d.flg_import_date,
                                 d.flg_outside_period,
                                 d.days_available_period,
                                 d.id_pn_task_type_prt,
                                 d.review_context,
                                 d.flg_group_on_import,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 d.flg_show_sub_title,
                                 d.flg_synchronized,
                                 d.flg_data_removable,
                                 d.auto_pop_exec_prof_cat,
                                 d.id_summary_page,
                                 d.flg_focus,
                                 d.flg_editable,
                                 d.flg_import_filter,
                                 d.flg_ea,
                                 d.last_n_records_nr,
                                 d.flg_group_select_filter,
                                 d.flg_synch_area,
                                 d.flg_shortcut_filter,
                                 d.review_cat,
                                 d.flg_review_avail,
                                 d.flg_description,
                                 d.description_condition,
                                 d.id_mtos_score,
                                 d.flg_dt_task,
                                 d.flg_exc_sum_page_da,
                                 d.flg_group_type)
          BULK COLLECT
          INTO l_dblocks_areas
          FROM TABLE(i_data_blocks) d
         WHERE d.flg_ea = pk_alert_constant.g_no
              --the syncronizable dates are not imported by API
           AND d.flg_synch_area <> pk_alert_constant.g_yes
           AND (l_id_pn_soap_block IS NULL OR
               d.block_id IN (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value
                                 FROM TABLE(l_id_pn_soap_block) t));
    
        --************************ EA import
        g_error := 'CALL get_import_configs to the areas importable from EA';
        pk_alertlog.log_debug(g_error);
        IF NOT get_import_configs(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_id_episode          => i_id_episode,
                             i_id_patient          => i_id_patient,
                             i_data_blocks         => l_dblocks_ea,
                             i_begin_date          => i_begin_date,
                             i_end_date            => i_end_date,
                             i_flg_synch_note      => i_flg_synch_note,
                             i_import_screen       => i_import_screen,
                             i_action              => i_action,
                             i_id_pn_note_type     => i_id_pn_note_type,
                             i_id_visit            => i_id_visit,
                             i_id_epis_pn          => i_id_epis_pn,
                             i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                             i_id_task_type        => CASE
                                                          WHEN i_id_task_types IS NOT NULL
                                                               AND i_id_task_types.exists(1) THEN
                                                           i_id_task_types(1)
                                                          ELSE
                                                           NULL
                                                      END,
                             i_dt_proposed         => i_dt_proposed,
                             o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        o_data_import := t_coll_data_import();
    
        g_error := 'CALL pk_prog_notes_dblock.get_import_from_ea from EA';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_prog_notes_dblock.get_import_from_ea(i_lang            => i_lang,
                                                  i_prof            => i_prof,
                                                  i_id_episode      => i_id_episode,
                                                  i_id_patient      => i_id_patient,
                                                  i_id_tasks        => i_id_tasks,
                                                  i_id_task_types   => i_id_task_types,
                                                  i_calc_task_descs => CASE
                                                                           WHEN i_action =
                                                                                pk_prog_notes_constants.g_flg_action_import THEN
                                                                            1
                                                                           ELSE
                                                                            0
                                                                       END,
                                                  i_epis_pn         => i_id_epis_pn,
                                                  i_id_pn_note_type => i_id_pn_note_type,
                                                  io_data_import    => o_data_import,
                                                  o_count_records   => l_count_records,
                                                  o_error           => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        ---------------------- AREAS IMPORT
        l_import_tasks := l_dblocks_areas;
        --Loop through the list of importable blocks to retrieve data of the task types associated to the data blocks
        l_dblocks_count := l_import_tasks.count;
    
        g_error := 'Loop through the list of blocks';
        pk_alertlog.log_debug(g_error);
        FOR i IN 1 .. l_dblocks_count
        LOOP
            pk_alertlog.log_debug('l_import_tasks(i).id_pn_data_block:' || l_import_tasks(i).id_pn_data_block ||
                                  ' l_prev_data_block:' || l_prev_data_block);
            IF (l_import_tasks(i).id_pn_data_block <> l_prev_data_block OR l_prev_data_block IS NULL)
            THEN
                g_error := 'Get get_data_block_configs';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_data_block_configs(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_episode             => i_id_episode,
                                              i_patient             => i_id_patient,
                                              i_id_visit            => i_id_visit,
                                              i_begin_date          => i_begin_date,
                                              i_end_date            => i_end_date,
                                              i_flg_synch_note      => i_flg_synch_note,
                                              i_import_screen       => i_import_screen,
                                              i_action              => i_action,
                                              i_data_blocks         => l_import_tasks(i),
                                              i_id_epis_pn          => i_id_epis_pn,
                                              i_id_pn_note_type     => i_id_pn_note_type,
                                              i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                              i_dt_proposed         => i_dt_proposed,
                                              o_note_date           => l_note_date,
                                              o_begin_date          => l_begin_date,
                                              o_end_date            => l_end_date,
                                              o_scope               => l_scope,
                                              o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            g_error := 'CALL get_auto_pop_options';
            pk_alertlog.log_debug(g_error);
            IF NOT get_auto_pop_options(i_lang                    => i_lang,
                                   i_prof                    => i_prof,
                                   i_id_episode              => i_id_episode,
                                   i_flg_filter              => CASE
                                                                    WHEN i_action = pk_prog_notes_constants.g_flg_action_autopop THEN
                                                                     l_import_tasks(i).flg_auto_populated
                                                                    ELSE
                                                                     l_import_tasks(i).flg_import_filter
                                                                END,
                                   o_flg_ongoing             => l_flg_ongoing,
                                   o_flg_normal              => l_flg_normal,
                                   o_flg_first_record        => l_flg_first_record,
                                   o_flg_last_record         => l_flg_last_record,
                                   o_flg_comments            => l_flg_comments,
                                   o_flg_since_last          => l_flg_since_last,
                                   o_flg_ong_exec            => l_flg_ong_exec,
                                   o_flg_no_note_sl          => l_flg_no_note_sl,
                                   o_flg_reviewed_info       => l_flg_reviewed_info,
                                   o_flg_med_filter          => l_flg_med_filter,
                                   o_flg_technical           => l_flg_technical,
                                   o_flg_stat                => l_flg_stat,
                                   o_flg_relevant            => l_flg_relevant,
                                   o_flg_type                => l_flg_type_dummy,
                                   o_action                  => l_action,
                                   o_id_pn_note_type_action  => l_id_pn_note_type_action,
                                   o_id_pn_data_block_action => l_id_pn_data_block_action,
                                   o_flg_view                => l_flg_view,
                                   o_error                   => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_prev_data_block := l_import_tasks(i).id_pn_data_block;
        
            g_error := 'CALL pk_prog_notes_utils.get_child_task_types. parent task type: ' || l_import_tasks(i).id_pn_task_type;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_child_task_types(i_lang          => i_lang,
                                                            i_prof          => i_prof,
                                                            i_id_task_type  => l_import_tasks(i).id_pn_task_type,
                                                            o_task_types    => l_task_types,
                                                            o_nr_task_types => l_nr_task_types,
                                                            o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            FOR j IN 1 .. l_nr_task_types
            LOOP
                g_error := 'CALL get_import_task. i_episode: ' || i_id_episode || ' i_patient: ' || i_id_patient ||
                           ' i_pn_soap_block: ' || l_import_tasks(i).block_id || ' i_pn_data_block: ' || l_import_tasks(i).id_pn_data_block ||
                           ' i_scope_type: ' || l_import_tasks(i).flg_scope || ' i_scope: ' || l_scope ||
                           ' i_doc_area: ' || l_import_tasks(i).id_doc_area || ' i_pn_task_type: ' || l_import_tasks(i).id_pn_task_type ||
                           ' i_outside_period: ' || l_import_tasks(i).flg_outside_period || ' i_action: ' || i_action ||
                           ' flg_auto_populated: ' || l_import_tasks(i).flg_auto_populated || ' flg_synchronized: ' || l_import_tasks(i).flg_synchronized ||
                           ' flg_import_filter: ' || l_import_tasks(i).flg_import_filter || ' l_flg_technical: ' ||
                           l_flg_technical || ' l_note_date: ' || l_note_date;
                pk_alertlog.log_error(g_error);
            
                IF NOT get_import_task(i_lang                  => i_lang,
                                  i_prof                  => i_prof,
                                  i_episode               => i_id_episode,
                                  i_patient               => i_id_patient,
                                  i_pn_soap_block         => l_import_tasks(i).block_id,
                                  i_pn_data_block         => l_import_tasks(i).id_pn_data_block,
                                  i_begin_date            => l_begin_date,
                                  i_end_date              => l_end_date,
                                  i_scope_type            => l_import_tasks(i).flg_scope,
                                  i_scope                 => l_scope,
                                  i_pn_task_type          => l_task_types(j),
                                  i_outside_period        => l_import_tasks(i).flg_outside_period,
                                  i_flg_import_date       => l_import_tasks(i).flg_import_date,
                                  i_flg_group_on_import   => l_import_tasks(i).flg_group_on_import,
                                  i_flg_ongoing           => l_flg_ongoing,
                                  i_dblock_flg_type       => l_import_tasks(i).flg_type,
                                  i_flg_synchronized      => l_import_tasks(i).flg_synchronized,
                                  i_flg_filter            => CASE
                                                                 WHEN i_action = pk_prog_notes_constants.g_flg_action_autopop THEN
                                                                  CASE
                                                                      WHEN l_import_tasks(i).flg_auto_populated <> pk_alert_constant.g_no THEN
                                                                       l_import_tasks(i).flg_auto_populated
                                                                      ELSE
                                                                       l_import_tasks(i).flg_synchronized
                                                                  END
                                                                 ELSE
                                                                  l_import_tasks(i).flg_import_filter
                                                             END,
                                  i_flg_view              => l_flg_view,
                                  i_flg_first_record      => l_flg_first_record,
                                  i_only_autopop          => i_only_autopop,
                                  i_flg_description       => l_import_tasks(i).flg_description,
                                  i_description_condition => l_import_tasks(i).description_condition,
                                  o_data_import           => o_data_import,
                                  o_error                 => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END LOOP;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            o_data_import := t_coll_data_import();
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_data_import_list;

    /**
    * Check if a parent of a comment is also in the importation list.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note id
    * @param i_id_parent_task         Id parent task   
    * @param i_id_parent_task_type    Parent task type
    * @param i_id_pn_data_block       Data block ID
    * @param i_id_pn_soap_block       Soap block ID
    * @param i_imported_data          Data to be imported   
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                10-May-2012
    */

    FUNCTION check_has_parent
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_parent_task      IN epis_pn_det_task.id_task%TYPE,
        i_id_parent_task_type IN epis_pn_det_task.id_task_type%TYPE,
        i_id_pn_data_block    IN pn_data_block.id_pn_data_block%TYPE,
        i_id_pn_soap_block    IN pn_soap_block.id_pn_soap_block%TYPE,
        i_imported_data       IN t_coll_data_import
    ) RETURN VARCHAR2 IS
        l_flg_parent_imported VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_error               t_error_out;
        l_status              table_varchar;
        l_status_count        PLS_INTEGER;
        l_import_count        PLS_INTEGER;
    BEGIN
        IF (i_id_parent_task IS NOT NULL)
        THEN
            IF (i_id_epis_pn IS NOT NULL)
            THEN
            
                g_error := 'Check in the saved records from def tables';
                pk_alertlog.log_debug(g_error);
                SELECT epdt.flg_status
                  BULK COLLECT
                  INTO l_status
                  FROM epis_pn_det_task epdt
                  JOIN epis_pn_det epd
                    ON epd.id_epis_pn_det = epdt.id_epis_pn_det
                 WHERE epdt.id_task = i_id_parent_task
                   AND epdt.id_task_type = i_id_parent_task_type
                   AND epd.id_pn_data_block = i_id_pn_data_block
                   AND epd.id_pn_soap_block = i_id_pn_soap_block
                   AND epd.id_epis_pn = i_id_epis_pn
                   AND epdt.flg_status IN (pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                           pk_prog_notes_constants.g_epis_pn_det_flg_status_r);
            
                l_status_count := l_status.count;
                FOR i IN 1 .. l_status_count
                LOOP
                    IF (l_status(i) = pk_prog_notes_constants.g_epis_pn_det_flg_status_a)
                    THEN
                        l_flg_parent_imported := pk_alert_constant.g_yes;
                        EXIT;
                    
                    END IF;
                END LOOP;
            END IF;
        
            IF (l_status_count = 0 OR i_id_epis_pn IS NULL)
            THEN
                g_error := 'Check in the imported records';
                pk_alertlog.log_debug(g_error);
                l_import_count := i_imported_data.count;
                FOR idx IN 1 .. l_import_count
                LOOP
                    IF (i_imported_data(idx)
                       .id_task = i_id_parent_task AND i_imported_data(idx).id_task_type = i_id_parent_task_type AND i_imported_data(idx)
                       .id_pn_data_block = i_id_pn_data_block AND i_imported_data(idx)
                       .id_pn_soap_block = i_id_pn_soap_block)
                    THEN
                        l_flg_parent_imported := pk_alert_constant.g_yes;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        ELSE
            l_flg_parent_imported := pk_alert_constant.g_yes;
        END IF;
    
        RETURN l_flg_parent_imported;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'CHECK_HAS_PARENT',
                                              l_error);
        
            RETURN NULL;
    END check_has_parent;

    /**
    * Transform cursor to final output data
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_id_epis_pn           Note Id
    * @param   i_id_episode           Episode Id
    * @param   i_data_import          Data imported from Alert areas
    * @param   i_flg_review           Y - the review is available on page/note. N-otherwise
    * @param   i_flg_synchronized     Y - the review is available on page/note. N-otherwise
    * @param   i_data_block           Data blocks properies     
    *
    * @param   o_data         Final data
    * @param   o_error        Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    *
    * @author  RUI.BATISTA
    * @version <2.6.0.5>
    * @since   17-02-2011
    */
    FUNCTION get_data_cursor
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_epis_pn  IN epis_pn.id_epis_pn%TYPE,
        i_id_episode  IN episode.id_episode%TYPE,
        i_id_patient  IN patient.id_patient%TYPE,
        i_data_import IN t_coll_data_import,
        i_data_block  IN t_coll_data_blocks,
        i_flg_review  IN pn_note_type_mkt.flg_review_all%TYPE,
        o_data        OUT t_coll_pn_work_data,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        --Get the final data
        g_error := 'Open cursor with the final data';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_DATA_CURSOR');
        SELECT t_rec_pn_work_data(c.area_name,
                                  c.id_pn_soap_block,
                                  c.id_pn_data_block,
                                  c.id_pndb_parent,
                                  c.task_description,
                                  c.task,
                                  c.dt_reg,
                                  c.dt_register,
                                  c.id_professional,
                                  c.id_task,
                                  c.id_task_type,
                                  c.table_origin,
                                  c.rank,
                                  c.flg_import_date,
                                  c.id_episode,
                                  NULL,
                                  c.id_task_aggregator,
                                  decode(i_flg_review,
                                         pk_alert_constant.g_yes,
                                         pk_prog_notes_in.check_reviewed_record(i_lang         => i_lang,
                                                                                i_prof         => i_prof,
                                                                                i_id_episode   => i_id_episode,
                                                                                i_id_patient   => i_id_patient,
                                                                                i_id_task      => c.id_task,
                                                                                i_id_task_type => c.id_task_type,
                                                                                i_flg_context  => c.review_context,
                                                                                i_review_cat   => c.review_cat),
                                         pk_alert_constant.g_yes),
                                  c.review_context,
                                  c.flg_auto_populated,
                                  c.flg_import,
                                  c.flg_data_removable,
                                  c.flg_synchronized,
                                  c.id_parent_comments,
                                  c.flg_has_notes,
                                  c.parent_task_type,
                                  (SELECT check_has_parent(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_id_epis_pn          => i_id_epis_pn,
                                                           i_id_parent_task      => c.id_parent_comments,
                                                           i_id_parent_task_type => c.parent_task_type,
                                                           i_id_pn_data_block    => c.id_pn_data_block,
                                                           i_id_pn_soap_block    => c.id_pn_soap_block,
                                                           i_imported_data       => i_data_import)
                                     FROM dual),
                                  coalesce(c.dt_last_update, c.dt_begin, c.dt_register, c.dt_task),
                                  c.flg_type,
                                  c.flg_ongoing,
                                  c.flg_selected,
                                  c.flg_group_on_import,
                                  c.dt_register,
                                  c.id_group_import,
                                  c.code_desc_group,
                                  c.desc_group,
                                  c.id_sub_group_import,
                                  c.code_desc_sub_group,
                                  c.separator,
                                  c.flg_scope,
                                  c.id_group_table,
                                  c.table_position,
                                  c.flg_editable,
                                  c.code_description,
                                  c.universal_description,
                                  c.flg_sos,
                                  c.dt_begin,
                                  c.id_doc_area,
                                  c.flg_group_select_filter,
                                  c.flg_show_sub_title,
                                  c.id_prof_review,
                                  c.dt_review,
                                  c.code_status,
                                  c.dt_end,
                                  c.id_task_notes,
                                  c.flg_status,
                                  c.id_sample_type,
                                  c.code_desc_sample_type,
                                  c.flg_review_avail,
                                  c.flg_description,
                                  c.description_condition,
                                  c.code_desc_group_parent,
                                  instructions_hash,
                                  c.flg_group_type)
          BULK COLLECT
          INTO o_data
          FROM (SELECT /*+opt_estimate(table,a,scale_rows=0.0000001)*/ /*+opt_estimate(table,b,scale_rows=0.0000001)*/
                 b.area_name,
                 a.id_pn_soap_block,
                 a.id_pn_data_block,
                 b.id_pndb_parent,
                 a.task_description,
                 a.task,
                 a.dt_reg,
                 a.dt_register,
                 a.id_professional,
                 a.id_task,
                 a.id_task_type,
                 a.table_origin,
                 a.rank,
                 b.flg_import_date,
                 a.id_episode,
                 a.separator,
                 a.id_task_aggregator,
                 b.review_context,
                 b.flg_auto_populated,
                 b.flg_import,
                 b.flg_data_removable,
                 b.flg_synchronized,
                 a.id_parent_comments,
                 a.flg_has_notes,
                 (SELECT pk_prog_notes_in.get_comment_task_type(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_id_task_type => a.id_task_type)
                    FROM dual) parent_task_type,
                 a.dt_last_update,
                 a.dt_task,
                 b.flg_type,
                 a.flg_ongoing,
                 b.flg_selected,
                 a.flg_group_on_import,
                 a.id_group_import,
                 a.code_desc_group,
                 a.desc_group,
                 a.id_sub_group_import,
                 a.code_desc_sub_group,
                 b.flg_scope,
                 a.id_group_table,
                 a.table_position,
                 b.flg_editable,
                 a.code_description,
                 a.universal_description,
                 a.flg_sos,
                 a.dt_begin,
                 a.id_doc_area,
                 b.flg_group_select_filter,
                 b.flg_show_sub_title,
                 a.id_prof_review,
                 a.dt_review,
                 a.code_status,
                 a.flg_status,
                 a.dt_end,
                 a.id_task_notes,
                 a.id_sample_type,
                 a.code_desc_sample_type,
                 b.review_cat,
                 b.flg_review_avail,
                 a.flg_description,
                 a.description_condition,
                 a.code_desc_group_parent,
                 a.instructions_hash,
                 a.flg_group_type
                  FROM TABLE(i_data_import) a, TABLE(i_data_block) b
                 WHERE a.id_pn_data_block = b.id_pn_data_block
                   AND a.id_task_type = b.id_pn_task_type
                   AND a.id_pn_soap_block = b.block_id) c
         ORDER BY c.id_pn_soap_block, c.id_pn_data_block;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_DATA_CURSOR',
                                              o_error);
        
            RETURN FALSE;
    END get_data_cursor;

    /**
    * checks if the record should be reviewed by the general review mechanism.
    *
    * @param i_current_episode             Current episode ID
    * @param i_imported_episode            Episode in which was created the imported task
    * @param i_flg_review                  Y - the review is available on page/note. N-otherwise 
    * @param i_flg_review_avail            Y - the review is configured to be available to the current task type. N-otherwise
    * @param i_flg_auto_populated          Y-The data block is filled automatically with the existing info. N-otherwise       
    * @param i_flg_reviewed_epis           Y -The task had already been reviewed in the current episode
    * @param i_review_context              Context of revision. If it is filled the task requires revision.
    * @param i_id_task_type                Task type Id
    * @param i_flg_suggest_concept         Concept to determine the suggested records.
    * @param i_flg_editable                Y-Editable record; N-otherwise
    * @param i_flg_status                  Record flg status
    *
    * @return                 Y-The record must be auto-suggested to the user. N-otherwise     
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                13-04-2012
    */
    FUNCTION get_review_flg
    (
        i_current_episode     IN episode.id_episode%TYPE,
        i_imported_episode    IN episode.id_episode%TYPE,
        i_flg_review          IN pn_note_type_mkt.flg_review_all%TYPE,
        i_flg_review_avail    IN pn_dblock_ttp_mkt.flg_review_avail%TYPE,
        i_flg_auto_populated  IN pn_dblock_ttp_mkt.flg_auto_populated%TYPE,
        i_flg_reviewed_epis   IN VARCHAR2,
        i_review_context      IN tl_task.review_context%TYPE,
        i_id_task_type        IN tl_task.id_tl_task%TYPE,
        i_flg_suggest_concept IN pn_note_type_mkt.flg_suggest_concept%TYPE,
        i_flg_editable        IN pn_dblock_mkt.flg_editable%TYPE,
        i_flg_status          IN epis_pn_det_task.flg_status%TYPE
    ) RETURN VARCHAR2 IS
        l_res VARCHAR2(1 CHAR);
    BEGIN
        g_error := 'CHECKS IF RECORD SHOULD BE REVIEWED. i_flg_auto_populated: ' || i_flg_auto_populated ||
                   ' i_flg_reviewed_epis: ' || i_flg_reviewed_epis || ' i_review_context: ' || i_review_context ||
                   ' i_current_episode: ' || i_current_episode || ' i_imported_episode : ' || i_imported_episode;
        pk_alertlog.log_debug(g_error);
    
        g_error := 'CALL get_auto_suggested_flg.';
        pk_alertlog.log_debug(g_error);
        l_res := pk_prog_notes_utils.get_auto_suggested_flg(i_current_episode     => i_current_episode,
                                                            i_imported_episode    => i_imported_episode,
                                                            i_flg_review          => i_flg_review,
                                                            i_flg_review_avail    => i_flg_review_avail,
                                                            i_flg_auto_populated  => i_flg_auto_populated,
                                                            i_flg_reviewed_epis   => i_flg_reviewed_epis,
                                                            i_review_context      => i_review_context,
                                                            i_id_task_type        => i_id_task_type,
                                                            i_flg_new             => NULL,
                                                            i_flg_import          => NULL,
                                                            i_flg_synch_db        => NULL,
                                                            i_flg_suggest_concept => i_flg_suggest_concept,
                                                            i_flg_editable        => i_flg_editable,
                                                            i_flg_status          => i_flg_status);
    
        RETURN l_res;
    
    END get_review_flg;

    /**
    * checks if all the tasks of this type should be selected when one of the tasks is selected (it works in a group)
    *
    * @param i_flg_review_all              Y-the review is available. N-otherwise
    * @param i_id_task_type                Task type Id
    *
    * @return                 Y-The record must be selected in group. N-otherwise     
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                15-03-2012
    */
    FUNCTION get_flg_select_in_group
    (
        i_flg_review_all IN pn_note_type_mkt.flg_review_all%TYPE DEFAULT pk_alert_constant.g_yes,
        i_id_task_type   IN tl_task.id_tl_task%TYPE
    ) RETURN VARCHAR2 IS
        l_res VARCHAR2(1 CHAR);
    BEGIN
        g_error := 'CHECKS IF ALL records should be selected at the same time. i_id_task_type: ' || i_id_task_type;
        pk_alertlog.log_debug(g_error);
    
        IF (i_id_task_type = pk_prog_notes_constants.g_task_reported_medic AND
           i_flg_review_all = pk_alert_constant.g_yes)
        THEN
            l_res := pk_alert_constant.g_yes;
        ELSE
            l_res := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_res;
    
    END get_flg_select_in_group;

    /**
    * checks if all the tasks of this type should be selected when one of the tasks is selected (it works in a group)
    *
    * @param i_flg_data_removal       Indicates the data that can be removed. Configuration. 
    * @param i_flg_suggested          Y - suggested record. N-otherwise
    * @param i_flg_editable           A-Editable note. T-Not editable except free texts N-Otherwise
    * @param i_flg_action             I-record imported by import screen; A - record auto-populated; S- record created by shortcut
    *
    * @return                 Y-The record must be selected in group. N-otherwise     
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                15-03-2012
    */
    FUNCTION get_flg_remove
    (
        i_flg_data_removal IN pn_dblock_mkt.flg_data_removable%TYPE,
        i_flg_suggested    IN VARCHAR2,
        i_flg_editable     IN VARCHAR2,
        i_flg_action       IN epis_pn_det_task.flg_action%TYPE
    ) RETURN VARCHAR2 IS
        l_res VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    BEGIN
        g_error := 'CHECKS IF the record should have the otion ''Remove''. i_flg_data_removal: ' || i_flg_data_removal ||
                   ' i_flg_suggested: ' || i_flg_suggested || ' i_flg_editable: ' || i_flg_editable || 'i_flg_action: ' ||
                   i_flg_action;
        pk_alertlog.log_debug(g_error);
    
        IF (i_flg_editable IN (pk_alert_constant.g_no, pk_prog_notes_constants.g_not_editable_by_time))
        THEN
            l_res := pk_alert_constant.g_no;
        ELSE
            --the suggested records can always be removed
            IF (i_flg_suggested = pk_alert_constant.g_yes AND i_flg_data_removal <> pk_alert_constant.g_no)
            THEN
                l_res := pk_alert_constant.g_yes;
            ELSE
                IF (i_flg_action IS NOT NULL)
                THEN
                    IF (instr(i_flg_data_removal, pk_prog_notes_constants.g_flg_remove_imported_i) > 0)
                    THEN
                        IF (i_flg_action = pk_prog_notes_constants.g_flg_action_import)
                        THEN
                            l_res := pk_alert_constant.g_yes;
                        END IF;
                    END IF;
                
                    IF (instr(i_flg_data_removal, pk_prog_notes_constants.g_flg_remove_populated_p) > 0)
                    THEN
                        IF (i_flg_action = pk_prog_notes_constants.g_flg_action_autopop)
                        THEN
                            l_res := pk_alert_constant.g_yes;
                        END IF;
                    END IF;
                
                    IF (instr(i_flg_data_removal, pk_prog_notes_constants.g_flg_remove_shortcut_s) > 0)
                    THEN
                        IF (i_flg_action = pk_prog_notes_constants.g_flg_action_shortcut)
                        THEN
                            l_res := pk_alert_constant.g_yes;
                        END IF;
                    END IF;
                ELSE
                    IF (i_flg_data_removal = pk_alert_constant.g_no)
                    THEN
                        l_res := pk_alert_constant.g_no;
                    ELSE
                        --the vital signs in the H&P, are grouped in text and should be possible to remove them from the note
                        l_res := pk_alert_constant.g_yes;
                    END IF;
                END IF;
            END IF;
        
        END IF;
    
        RETURN l_res;
    
    END get_flg_remove;

    /**
    * Syncronize the note with the data in the auto-populated areas     
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_episode             Episode identifier
    * @param i_id_epis_pn             Note identifier    
    * @param i_id_pn_soap_block       Soap blocks ID
    * @param o_id_epis_pn             Note id. In the 1st time it is created a new note id
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   13-Feb-2012
    */

    FUNCTION set_synch_remove_canc
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_data_import      IN t_coll_data_import,
        i_data_blocks      IN t_coll_data_blocks,
        i_id_task          IN table_number,
        i_id_task_type     IN table_number,
        i_id_pn_soap_block IN table_number,
        io_id_epis_pn      IN OUT epis_pn.id_epis_pn%TYPE,
        io_note_struct     IN OUT NOCOPY pk_prog_notes_types.t_note_struct,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(21 CHAR) := 'SET_SYNCH_REMOVE_CANC';
        l_prev_epis_pn_det epis_pn_det_task.id_epis_pn_det%TYPE;
    
        l_id_pn_data_block  epis_pn_det.id_pn_data_block%TYPE;
        l_id_pn_soap_block  epis_pn_det.id_pn_soap_block%TYPE;
        l_new_status        epis_pn_det_task.flg_status%TYPE;
        l_id_epis_pn_det    epis_pn_det.id_epis_pn_det%TYPE;
        l_rec_task          pk_prog_notes_types.t_rec_tasks;
        l_tbl_tasks         pk_prog_notes_types.t_table_tasks;
        l_tbl_tasks_reset   pk_prog_notes_types.t_table_tasks;
        l_id_pn_soap_blocks table_number;
    BEGIN
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_blocks := NULL;
        ELSE
            l_id_pn_soap_blocks := i_id_pn_soap_block;
        END IF;
    
        IF (io_id_epis_pn IS NOT NULL)
        THEN
        
            IF i_data_import.exists(1)
            THEN
                pk_alertlog.log_info(text => 'i_data_import', object_name => g_package, sub_object_name => l_func_name);
                FOR i IN 1 .. i_data_import.count
                LOOP
                    pk_alertlog.log_info(text            => 'id_pn_soap_block:' || i_data_import(i).id_pn_soap_block ||
                                                            ' id_pn_data_block:' || i_data_import(i).id_pn_data_block ||
                                                            ' task_description:' || i_data_import(i).task_description ||
                                                            ' task:' || i_data_import(i).task || ' dt_reg:' || i_data_import(i).dt_reg ||
                                                            ' dt_register:' || i_data_import(i).dt_register ||
                                                            ' id_professional:' || i_data_import(i).id_professional ||
                                                            ' id_task:' || i_data_import(i).id_task || ' id_task_type:' || i_data_import(i).id_task_type ||
                                                            ' table_origin:' || i_data_import(i).table_origin ||
                                                            ' rank:' || i_data_import(i).rank || ' id_episode:' || i_data_import(i).id_episode ||
                                                            ' id_task_aggregator:' || i_data_import(i).id_task_aggregator ||
                                                            ' dt_record:' || i_data_import(i).dt_record ||
                                                            ' flg_ongoing:' || i_data_import(i).flg_ongoing ||
                                                            ' flg_normal:' || i_data_import(i).flg_normal ||
                                                            ' id_prof_exec:' || i_data_import(i).id_prof_exec ||
                                                            ' dt_last_update:' || i_data_import(i).dt_last_update ||
                                                            ' id_parent_comments:' || i_data_import(i).id_parent_comments ||
                                                            ' flg_has_notes:' || i_data_import(i).flg_has_notes ||
                                                            ' dt_task:' || i_data_import(i).dt_task ||
                                                            ' flg_show_sub_title:' || i_data_import(i).flg_show_sub_title ||
                                                            ' flg_group_on_import:' || i_data_import(i).flg_group_on_import ||
                                                            ' dt_group_import:' || i_data_import(i).dt_group_import ||
                                                            ' id_group_import:' || i_data_import(i).id_group_import ||
                                                            ' code_desc_group:' || i_data_import(i).code_desc_group ||
                                                            ' desc_group:' || i_data_import(i).desc_group ||
                                                            ' id_sub_group_import:' || i_data_import(i).id_sub_group_import ||
                                                            ' code_desc_sub_group:' || i_data_import(i).code_desc_sub_group ||
                                                            ' separator:' || i_data_import(i).separator ||
                                                            ' id_group_table:' || i_data_import(i).id_group_table ||
                                                            ' table_position:' || i_data_import(i).table_position ||
                                                            ' code_description:' || i_data_import(i).code_description ||
                                                            ' universal_description:' || i_data_import(i).universal_description ||
                                                            ' flg_sos:' || i_data_import(i).flg_sos || ' dt_begin:' || i_data_import(i).dt_begin ||
                                                            ' id_doc_area:' || i_data_import(i).id_doc_area ||
                                                            ' id_prof_review:' || i_data_import(i).id_prof_review ||
                                                            ' dt_review:' || i_data_import(i).dt_review ||
                                                            ' code_status:' || i_data_import(i).code_status ||
                                                            ' dt_end:' || i_data_import(i).dt_end || ' id_task_notes:' || i_data_import(i).id_task_notes ||
                                                            ' flg_status:' || i_data_import(i).flg_status ||
                                                            ' id_sample_type:' || i_data_import(i).id_sample_type ||
                                                            ' code_desc_sample_type:' || i_data_import(i).code_desc_sample_type,
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END LOOP;
            END IF;
        
            IF i_data_blocks.exists(1)
            THEN
                pk_alertlog.log_info(text => 'i_data_blocks', object_name => g_package, sub_object_name => l_func_name);
                FOR i IN 1 .. i_data_blocks.count
                LOOP
                    pk_alertlog.log_info(text            => ' block_id:' || i_data_blocks(i).block_id ||
                                                            ' id_pn_data_block:' || i_data_blocks(i).id_pn_data_block ||
                                                            ' id_pndb_parent:' || i_data_blocks(i).id_pndb_parent ||
                                                            ' data_area:' || i_data_blocks(i).data_area ||
                                                            ' id_doc_area:' || i_data_blocks(i).id_doc_area ||
                                                            ' area_name:' || i_data_blocks(i).area_name || ' flg_type:' || i_data_blocks(i).flg_type ||
                                                            ' flg_import:' || i_data_blocks(i).flg_import ||
                                                            ' area_level:' || i_data_blocks(i).area_level ||
                                                            ' flg_scope:' || i_data_blocks(i).flg_scope ||
                                                            ' flg_selected:' || i_data_blocks(i).flg_selected ||
                                                            ' flg_actions_available:' || i_data_blocks(i).flg_actions_available ||
                                                            ' id_swf_file_viewer:' || i_data_blocks(i).id_swf_file_viewer ||
                                                            ' flg_line_on_boxes:' || i_data_blocks(i).flg_line_on_boxes ||
                                                            ' gender:' || i_data_blocks(i).gender || ' age_min:' || i_data_blocks(i).age_min ||
                                                            ' age_max:' || i_data_blocks(i).age_max || ' flg_pregnant:' || i_data_blocks(i).flg_pregnant ||
                                                            ' flg_auto_populated:' || i_data_blocks(i).flg_auto_populated ||
                                                            ' flg_cp_no_changes_import:' || i_data_blocks(i).flg_cp_no_changes_import ||
                                                            ' rank:' || i_data_blocks(i).rank || ' id_pn_task_type:' || i_data_blocks(i).id_pn_task_type ||
                                                            ' flg_import_date:' || i_data_blocks(i).flg_import_date ||
                                                            ' flg_outside_period:' || i_data_blocks(i).flg_outside_period ||
                                                            ' days_available_period:' || i_data_blocks(i).days_available_period ||
                                                            ' id_pn_task_type_prt:' || i_data_blocks(i).id_pn_task_type_prt ||
                                                            ' review_context:' || i_data_blocks(i).review_context ||
                                                            ' flg_group_on_import:' || i_data_blocks(i).flg_group_on_import ||
                                                            ' id_parent_no_struct:' || i_data_blocks(i).id_parent_no_struct ||
                                                            ' flg_has_struct_levels:' || i_data_blocks(i).flg_has_struct_levels ||
                                                            ' flg_last_struct_level:' || i_data_blocks(i).flg_last_struct_level ||
                                                            ' count_child:' || i_data_blocks(i).count_child ||
                                                            ' flg_show_sub_title:' || i_data_blocks(i).flg_show_sub_title ||
                                                            ' flg_synchronized:' || i_data_blocks(i).flg_synchronized ||
                                                            ' flg_data_removable:' || i_data_blocks(i).flg_data_removable ||
                                                            ' auto_pop_exec_prof_cat:' || i_data_blocks(i).auto_pop_exec_prof_cat ||
                                                            ' id_summary_page:' || i_data_blocks(i).id_summary_page ||
                                                            ' flg_focus:' || i_data_blocks(i).flg_focus ||
                                                            ' flg_editable:' || i_data_blocks(i).flg_editable ||
                                                            ' flg_import_filter:' || i_data_blocks(i).flg_import_filter ||
                                                            ' flg_ea:' || i_data_blocks(i).flg_ea ||
                                                            ' last_n_records_nr:' || i_data_blocks(i).last_n_records_nr ||
                                                            ' flg_group_select_filter:' || i_data_blocks(i).flg_group_select_filter ||
                                                            ' flg_synch_area:' || i_data_blocks(i).flg_synch_area ||
                                                            ' flg_shortcut_filter:' || i_data_blocks(i).flg_shortcut_filter ||
                                                            ' review_cat:' || i_data_blocks(i).review_cat ||
                                                            ' flg_review_avail:' || i_data_blocks(i).flg_review_avail,
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END LOOP;
            END IF;
        
            IF i_id_task.exists(1)
            THEN
                FOR i IN 1 .. i_id_task.count
                LOOP
                    pk_alertlog.log_info(text            => 'i_id_task:' || i_id_task(i),
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END LOOP;
            END IF;
            IF i_id_task_type.exists(1)
            THEN
                FOR i IN 1 .. i_id_task_type.count
                LOOP
                    pk_alertlog.log_info(text            => 'i_id_task_type:' || i_id_task_type(i),
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END LOOP;
            END IF;
            IF i_id_pn_soap_block.exists(1)
            THEN
                FOR i IN 1 .. i_id_pn_soap_block.count
                LOOP
                    pk_alertlog.log_info(text            => 'i_id_pn_soap_block:' || i_id_pn_soap_block(i),
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END LOOP;
            END IF;
        
            --we can not exclude the not imported records any more. We can have inactive records not auto-poopulated and
            --to be possible to import them. So, we have to exclude the records that were excluded from the EA table
            --get the removed items            
            FOR rec IN (SELECT *
                          FROM (SELECT /*+opt_estimate(table,db,scale_rows=0.0000001)*/ /*+opt_estimate(table,t,scale_rows=0.000000000001)*/ /*+ index(epdt,EPDTK_EPTD_FK_IDX) */
                                 epdt.id_epis_pn_det_task,
                                 epdt.id_task,
                                 epdt.id_task_aggregator,
                                 epdt.id_task_type,
                                 epd.id_pn_soap_block,
                                 epd.id_pn_data_block,
                                 epd.id_epis_pn_det,
                                 epdt.flg_status,
                                 epd.id_epis_pn,
                                 db.flg_synchronized
                                  FROM epis_pn_det epd
                                  JOIN epis_pn_det_task epdt
                                    ON epdt.id_epis_pn_det = epd.id_epis_pn_det
                                  JOIN tl_task tt
                                    ON tt.id_tl_task = epdt.id_task_type
                                  JOIN TABLE(i_data_blocks) db
                                    ON db.id_pn_data_block = epd.id_pn_data_block
                                   AND db.block_id = epd.id_pn_soap_block
                                   AND db.id_pn_task_type = epdt.id_task_type
                                      --AND (db.flg_synchronized <> pk_alert_constant.g_no OR i_id_task IS NOT NULL)
                                   AND (pk_utils.str_token_find(i_string => db.flg_synchronized,
                                                                i_token  => pk_alert_constant.g_no,
                                                                i_sep    => pk_prog_notes_constants.g_sep) =
                                       pk_alert_constant.g_no OR i_id_task IS NOT NULL)
                                --if for instance, we remove a task type from a data block not syncronizable, in the already created
                                --notes the records of the removed task type will not be removed automatically from the note                               
                                 WHERE epd.id_epis_pn = io_id_epis_pn
                                      
                                   AND epdt.flg_status IN
                                       (pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                        pk_prog_notes_constants.g_epis_pn_det_sug_add_s)
                                      --case of records that do not come from EA
                                   AND (((epdt.id_task, epdt.id_task_type, epdt.id_task_aggregator, epd.id_pn_data_block,
                                        epd.id_pn_soap_block) NOT IN
                                       (SELECT /*+opt_estimate(table,t,scale_rows=0.0000001)*/
                                           t.id_task,
                                           t.id_task_type,
                                           t.id_task_aggregator,
                                           t.id_pn_data_block,
                                           t.id_pn_soap_block
                                            FROM TABLE(i_data_import) t)))
                                      
                                   AND (i_id_task IS NULL OR
                                       (epdt.id_task IN (SELECT /*+opt_estimate(table,tk,scale_rows=0.0000001)*/
                                                           column_value
                                                            FROM TABLE(i_id_task) tk) AND
                                       epdt.id_task_type IN (SELECT /*+opt_estimate(table,tt,scale_rows=0.0000001)*/
                                                                column_value
                                                                 FROM TABLE(i_id_task_type) tt)
                                       
                                       ))
                                   AND (l_id_pn_soap_blocks IS NULL OR
                                       epd.id_pn_soap_block IN
                                       (SELECT /*+opt_estimate(table t rows=1)*/
                                          column_value
                                           FROM TABLE(l_id_pn_soap_blocks) t))
                                
                                ) t_int
                        
                         ORDER BY t_int.id_epis_pn_det,
                                  t_int.id_pn_soap_block,
                                  t_int.id_pn_data_block,
                                  t_int.id_task_type)
            LOOP
                l_id_pn_data_block := rec.id_pn_data_block;
                l_id_pn_soap_block := rec.id_pn_soap_block;
            
                l_new_status := pk_prog_notes_constants.g_epis_pn_det_aut_rem_z;
            
                IF (rec.id_epis_pn_det <> l_prev_epis_pn_det OR l_prev_epis_pn_det IS NULL)
                THEN
                    l_tbl_tasks      := l_tbl_tasks_reset;
                    l_id_epis_pn_det := rec.id_epis_pn_det;
                
                    g_error := 'CALL get_epis_pn_det_struct';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT get_epis_pn_det_struct(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_epis_pn            => rec.id_epis_pn,
                                                  i_soap_block         => l_id_pn_soap_block,
                                                  i_data_block         => l_id_pn_data_block,
                                                  i_flg_status         => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                                  i_pn_note            => NULL,
                                                  i_dt_pn_note         => NULL,
                                                  i_flg_type           => NULL,
                                                  i_flg_aggregate_data => NULL,
                                                  i_flg_scope          => NULL,
                                                  io_epis_pn_det       => l_id_epis_pn_det,
                                                  io_note_struct       => io_note_struct,
                                                  o_error              => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                END IF;
            
                g_error := 'CALL get_epis_pn_det_task_struct';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_epis_pn_det_task_struct(i_lang                   => i_lang,
                                                   i_prof                   => i_prof,
                                                   i_id_episode             => i_id_episode,
                                                   i_id_task                => rec.id_task,
                                                   i_id_task_type           => rec.id_task_type,
                                                   i_id_epis_pn_det         => l_id_epis_pn_det,
                                                   i_id_task_aggregator     => rec.id_task_aggregator,
                                                   i_flg_status             => l_new_status,
                                                   i_pn_note                => NULL,
                                                   i_flg_table_origin       => NULL,
                                                   i_dt_task                => NULL,
                                                   i_id_parent              => NULL,
                                                   i_rank_task              => NULL,
                                                   i_id_prof_task           => NULL,
                                                   i_id_epis_pn_det_task    => rec.id_epis_pn_det_task,
                                                   i_id_task_parent         => NULL,
                                                   i_dt_group_import        => NULL,
                                                   i_id_group_import        => NULL,
                                                   i_code_desc_group        => NULL,
                                                   i_desc_group             => NULL,
                                                   i_id_sub_group_import    => NULL,
                                                   i_code_desc_sub_group    => NULL,
                                                   i_id_group_table         => NULL,
                                                   i_flg_aggregate_data     => NULL,
                                                   i_table_position         => NULL,
                                                   i_code_description       => NULL,
                                                   i_universal_desc_clob    => NULL,
                                                   i_flg_sos                => NULL,
                                                   i_dt_begin               => NULL,
                                                   i_id_doc_area            => NULL,
                                                   i_dt_register            => NULL,
                                                   i_flg_show_sub_title     => NULL,
                                                   i_id_prof_review         => NULL,
                                                   i_dt_review              => NULL,
                                                   i_code_status            => NULL,
                                                   i_flg_status_req         => NULL,
                                                   i_end_date               => NULL,
                                                   i_dt_req                 => NULL,
                                                   i_id_task_notes          => NULL,
                                                   i_flg_action             => NULL,
                                                   i_id_sample_type         => NULL,
                                                   i_code_desc_sample_type  => NULL,
                                                   i_flg_description        => NULL,
                                                   i_description_condition  => NULL,
                                                   i_code_desc_group_parent => NULL,
                                                   i_instructions_hash      => NULL,
                                                   o_rec_task               => l_rec_task,
                                                   o_error                  => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                io_note_struct.tbl_dblock_det(rec.id_epis_pn_det).tbl_tasks(rec.id_epis_pn_det_task) := l_rec_task;
            
                l_prev_epis_pn_det := rec.id_epis_pn_det;
            
            END LOOP;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END set_synch_remove_canc;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_episode            Episode ID
    * @param   i_import_rec         Imported record
    * @param   i_flg_review_all     Y-review available. N-otherwise
    * @param   i_flg_new            Y-new record. N-otherwise 
    * @param   i_flg_suggest_concept         Concept to determine the suggested records.
    * @param   i_flg_status                  Record flg status
    * @param   io_flg_status         A-active. S-suggested
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   16-06-2012
    */
    FUNCTION get_flg_status
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_import_rec          IN t_rec_pn_work_data,
        i_flg_review_all      IN pn_note_type_mkt.flg_review_all%TYPE,
        i_flg_new             IN VARCHAR2,
        i_flg_suggest_concept IN pn_note_type_mkt.flg_suggest_concept%TYPE,
        io_flg_status         IN OUT epis_pn_det_task.flg_status%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(14 CHAR) := 'GET_FLG_STATUS';
    
        l_auto_suggested VARCHAR2(1 CHAR);
    BEGIN
        g_error := 'CALL get_auto_suggested_flg';
        pk_alertlog.log_debug(g_error);
        l_auto_suggested := pk_prog_notes_utils.get_auto_suggested_flg(i_current_episode     => i_episode,
                                                                       i_imported_episode    => i_import_rec.id_episode,
                                                                       i_flg_review          => i_flg_review_all,
                                                                       i_flg_review_avail    => i_import_rec.flg_review_avail,
                                                                       i_flg_auto_populated  => i_import_rec.flg_auto_populated,
                                                                       i_flg_reviewed_epis   => i_import_rec.flg_reviewed_epis,
                                                                       i_review_context      => i_import_rec.review_context,
                                                                       i_id_task_type        => i_import_rec.id_task_type,
                                                                       i_flg_new             => i_flg_new,
                                                                       i_flg_import          => i_import_rec.flg_import,
                                                                       i_flg_synch_db        => i_import_rec.flg_synchronized,
                                                                       i_flg_suggest_concept => i_flg_suggest_concept,
                                                                       i_flg_editable        => i_import_rec.flg_editable,
                                                                       i_flg_status          => io_flg_status);
    
        IF (l_auto_suggested = pk_alert_constant.g_yes)
        THEN
            io_flg_status := pk_prog_notes_constants.g_epis_pn_det_sug_add_s;
        ELSE
            io_flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_flg_status;

    /**
    * Saves the records in the note that were imported and do not need of review    
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_epis_pn             Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_id_dep_clin_serv       Dep_clin_serv id
    * @param i_data_import            Imported records to save in the note
    * @param i_note_type_cfg          Note type configs
    * @param i_flg_suggest_concept    Concept to determine the suggested records.
    * @param io_id_epis_pn            Note id. In the 1st time it is created a new note id
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   13-Feb-2012
    */

    FUNCTION check_save
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_import_rec          IN t_rec_pn_work_data,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_flg_review_all      IN pn_note_type_mkt.flg_review_all%TYPE,
        i_flg_suggest_concept IN pn_note_type_mkt.flg_suggest_concept%TYPE,
        o_flg_save            OUT VARCHAR2,
        o_id_epis_pn_det_task OUT epis_pn_det_task.id_epis_pn_det_task%TYPE,
        o_flg_status          OUT epis_pn_det_task.flg_status%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(10 CHAR) := 'CHECK_SAVE';
    
        l_id_epis_pn_det_task     epis_pn_det_task.id_epis_pn_det_task%TYPE;
        l_note_task_text          epis_pn_det_task.pn_note%TYPE;
        l_flg_status              epis_pn_det_task.flg_status%TYPE;
        l_new_status              epis_pn_det_task.flg_status%TYPE;
        l_parent_tasks            table_number;
        l_parent_tasks_count      PLS_INTEGER;
        l_id_epis_pn_det_task_prt epis_pn_det_task.id_epis_pn_det_task%TYPE;
        l_note_task_text_prt      epis_pn_det_task.pn_note%TYPE;
        l_flg_status_prt          epis_pn_det_task.flg_status%TYPE;
        l_save_in_note            PLS_INTEGER;
        l_flg_new                 VARCHAR2(1 CHAR);
        l_dt_last_upd_task        epis_pn_det_task.dt_task%TYPE;
        l_dt_last_update_task     epis_pn_det_task.dt_task%TYPE;
        l_dt_last_update_task_prt epis_pn_det_task.dt_task%TYPE;
        l_task_last_upd_date      epis_pn_det_task.dt_task%TYPE;
        l_dt_review_task          epis_pn_det_task.dt_review%TYPE;
        l_dt_review_task_prt      epis_pn_det_task.dt_review%TYPE;
        l_rank_task               epis_pn_det_task.rank_task%TYPE;
        l_rank_task_prt           epis_pn_det_task.rank_task%TYPE;
    BEGIN
    
        o_flg_save := pk_alert_constant.g_no;
    
        --check if the current task had already been imported to the note
        g_error := 'CALL pk_prog_notes_utils.get_imported_record. i_id_task: ' || i_import_rec.id_task ||
                   ' i_id_task_aggregator: ' || i_import_rec.id_task_aggregator || ' i_id_task_type: ' ||
                   i_import_rec.id_task_type;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_prog_notes_utils.get_imported_record(i_lang                => i_lang,
                                                       i_prof                => i_prof,
                                                       i_id_episode          => i_id_episode,
                                                       i_id_epis_pn          => i_id_epis_pn,
                                                       i_id_task             => i_import_rec.id_task,
                                                       i_id_task_aggregator  => i_import_rec.id_task_aggregator,
                                                       i_id_task_type        => i_import_rec.id_task_type,
                                                       i_id_pn_data_block    => i_import_rec.id_pn_data_block,
                                                       i_id_pn_soap_block    => i_import_rec.id_pn_soap_block,
                                                       i_flg_only_active     => pk_alert_constant.g_no,
                                                       o_id_epis_pn_det_task => l_id_epis_pn_det_task,
                                                       o_task_text           => l_note_task_text,
                                                       o_flg_status          => l_flg_status,
                                                       o_dt_last_update_task => l_dt_last_upd_task,
                                                       o_dt_review_task      => l_dt_review_task,
                                                       o_rank_task           => l_rank_task,
                                                       o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_dt_last_upd_task >= l_dt_review_task OR l_dt_review_task IS NULL)
        THEN
            l_dt_last_update_task := l_dt_last_upd_task;
        ELSE
            l_dt_last_update_task := l_dt_review_task;
        END IF;
    
        --if it is a task removed automatically we can recuperate it, if it appears another time in the import list
        --to prevent errors or to recuperate from bugs
        IF (l_flg_status = pk_prog_notes_constants.g_epis_pn_det_aut_rem_z)
        THEN
            l_flg_status          := NULL;
            l_id_epis_pn_det_task := NULL;
        END IF;
    
        --in the case of synch records (not auto-populated), in the functionalities that creates a new ID when editing a record, 
        -- if it is not yet in the note, check if a parent was in the note before performing the action (see in the definitive model).
        --if so, put this record in the note
        l_save_in_note := 0;
        --IF (i_import_rec.flg_auto_populated = pk_alert_constant.g_no AND
        IF (pk_utils.str_token_find(i_string => i_import_rec.flg_auto_populated,
                                    i_token  => pk_alert_constant.g_no,
                                    i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_yes AND
           (l_id_epis_pn_det_task IS NULL OR l_flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_r))
        THEN
            g_error := 'CALL pk_prog_notes_utils.get_outdated_parents.';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_in.get_outdated_parents(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_id_task      => i_import_rec.id_task,
                                                         i_id_task_type => i_import_rec.id_task_type,
                                                         o_parent_tasks => l_parent_tasks,
                                                         o_error        => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF (l_parent_tasks IS NOT NULL AND l_parent_tasks.exists(1))
            THEN
                l_parent_tasks_count := l_parent_tasks.count;
                FOR j IN 1 .. l_parent_tasks_count
                LOOP
                    g_error := 'CALL pk_prog_notes_utils.get_imported_record. i_id_task: ' || i_import_rec.id_task ||
                               ' i_id_task_aggregator: ' || i_import_rec.id_task_aggregator || ' i_id_task_type: ' ||
                               i_import_rec.id_task_type;
                    pk_alertlog.log_debug(g_error);
                    IF NOT pk_prog_notes_utils.get_imported_record(i_lang                => i_lang,
                                                                   i_prof                => i_prof,
                                                                   i_id_episode          => i_id_episode,
                                                                   i_id_epis_pn          => i_id_epis_pn,
                                                                   i_id_task             => l_parent_tasks(j),
                                                                   i_id_task_aggregator  => NULL,
                                                                   i_id_task_type        => i_import_rec.id_task_type,
                                                                   i_id_pn_data_block    => i_import_rec.id_pn_data_block,
                                                                   i_id_pn_soap_block    => i_import_rec.id_pn_soap_block,
                                                                   i_flg_only_active     => pk_alert_constant.g_no,
                                                                   o_id_epis_pn_det_task => l_id_epis_pn_det_task_prt,
                                                                   o_task_text           => l_note_task_text_prt,
                                                                   o_flg_status          => l_flg_status_prt,
                                                                   o_dt_last_update_task => l_dt_last_update_task_prt,
                                                                   o_dt_review_task      => l_dt_review_task_prt,
                                                                   o_rank_task           => l_rank_task_prt,
                                                                   o_error               => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                
                    --if before this transaction, there was parent active inserted in the note
                    -- we have to synch it, inserting the generated child
                    IF (l_flg_status_prt IN (pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                             pk_prog_notes_constants.g_epis_pn_det_sug_add_s))
                    THEN
                        l_save_in_note := 1;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    
        pk_alertlog.log_info(text            => 'i_import_rec.dt_task:' || i_import_rec.dt_task ||
                                                ' i_import_rec.dt_review:' || i_import_rec.dt_review,
                             object_name     => g_package,
                             sub_object_name => l_func_name);
        IF (i_import_rec.dt_task >= i_import_rec.dt_review OR i_import_rec.dt_review IS NULL)
        THEN
            l_task_last_upd_date := i_import_rec.dt_task;
        ELSE
            l_task_last_upd_date := i_import_rec.dt_review;
        END IF;
    
        pk_alertlog.log_debug('check_save i_import_rec.id_pn_data_block: ' || i_import_rec.id_pn_data_block ||
                              ', flg_auto_populated: ' || i_import_rec.flg_auto_populated ||
                              ', flg_auto_populated=N :' ||
                              pk_utils.str_token_find(i_string => i_import_rec.flg_auto_populated,
                                                      i_token  => pk_alert_constant.g_no,
                                                      i_sep    => pk_prog_notes_constants.g_sep));
        pk_alertlog.log_debug('check_save i_import_rec.id_pn_data_block: ' || i_import_rec.id_pn_data_block ||
                              ', flg_synchronized: ' || i_import_rec.flg_synchronized || ', flg_synchronized=N : ' ||
                              pk_utils.str_token_find(i_string => i_import_rec.flg_synchronized,
                                                      i_token  => pk_alert_constant.g_no,
                                                      i_sep    => pk_prog_notes_constants.g_sep));
        --if the task was removed by the user, it will not be auto-populated again by the system.
        --In the get_imported_record we only search in the definitive model in order to do not get the removed status done in the set_synch_remove_canc
        --If the task is not auto-poopulated and it is not in the note yet it will not be saved in the note
        pk_alertlog.log_info(text            => 'i_import_rec.flg_synchronized:' || i_import_rec.flg_synchronized ||
                                                ' l_save_in_note:' || l_save_in_note,
                             object_name     => g_package,
                             sub_object_name => l_func_name);
        IF ((
           --record not yet imported
            (l_flg_status IS NULL AND
            /*(i_import_rec.flg_auto_populated <> pk_alert_constant.g_no OR i_import_rec.flg_synchronized <> pk_alert_constant.g_no)) OR*/
            
            (pk_utils.str_token_find(i_string => i_import_rec.flg_auto_populated,
                                       i_token  => pk_alert_constant.g_no,
                                       i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_no OR
            pk_utils.str_token_find(i_string => i_import_rec.flg_synchronized,
                                       i_token  => pk_alert_constant.g_no,
                                       i_sep    => pk_prog_notes_constants.g_sep) = pk_alert_constant.g_no)) OR
           --record already imported: it is necessary to check if there is changes
            l_flg_status IN
            (pk_prog_notes_constants.g_epis_pn_det_flg_status_a, pk_prog_notes_constants.g_epis_pn_det_sug_add_s)) OR
           --record that replaces a parent one that was previously in the note
           l_save_in_note = 1)
        THEN
            l_flg_new := CASE
                             WHEN ((l_id_epis_pn_det_task IS NULL AND (pk_utils.str_token_find(i_string => i_import_rec.flg_auto_populated,
                                                                                               i_token  => pk_alert_constant.g_no,
                                                                                               i_sep    => pk_prog_notes_constants.g_sep) =
                                  pk_alert_constant.g_no OR pk_utils.str_token_find(i_string => i_import_rec.flg_synchronized,
                                                                                                                         i_token  => pk_alert_constant.g_no,
                                                                                                                         i_sep    => pk_prog_notes_constants.g_sep) =
                                  pk_alert_constant.g_no)) OR l_save_in_note = 1) THEN
                              pk_alert_constant.g_yes
                             ELSE
                              pk_alert_constant.g_no
                         END;
        
            pk_alertlog.log_info(text            => 'l_flg_new:' || l_flg_new || ' i_import_rec.flg_auto_populated:' ||
                                                    i_import_rec.flg_auto_populated ||
                                                    ' i_import_rec.flg_synchronized:' || i_import_rec.flg_synchronized ||
                                                    ' l_save_in_note:' || l_save_in_note || ' l_flg_status:' ||
                                                    l_flg_status,
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
        
            IF (l_flg_new = pk_alert_constant.g_yes)
            THEN
                o_flg_save := pk_prog_notes_constants.g_insert_i;
            ELSE
                l_new_status := l_flg_status;
                IF NOT get_flg_status(i_lang                => i_lang,
                                      i_prof                => i_prof,
                                      i_episode             => i_id_episode,
                                      i_import_rec          => i_import_rec,
                                      i_flg_review_all      => i_flg_review_all,
                                      i_flg_new             => l_flg_new,
                                      i_flg_suggest_concept => i_flg_suggest_concept,
                                      io_flg_status         => l_new_status, --o_flg_status,
                                      o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                o_flg_status := l_new_status;
            
                pk_alertlog.log_info(text            => 'l_dt_last_update_task:' || l_dt_last_update_task ||
                                                        ' l_task_last_upd_date:' || l_task_last_upd_date ||
                                                        ' l_id_epis_pn_det_task:' || l_id_epis_pn_det_task ||
                                                        ' l_rank_task:' || l_rank_task || ' i_import_rec.rank:' ||
                                                        i_import_rec.rank || ' l_flg_status:' || l_flg_status ||
                                                        ' o_flg_status:' || o_flg_status ||
                                                        ' i_import_rec.id_task_type:' || i_import_rec.id_task_type ||
                                                        ' i_flg_suggest_concept:' || i_flg_suggest_concept,
                                     object_name     => g_package,
                                     sub_object_name => l_func_name);
            
                IF ((l_dt_last_update_task IS NULL AND
                   (l_task_last_upd_date IS NOT NULL OR l_id_epis_pn_det_task IS NOT NULL)) OR
                   /*if the task was updated in the meanwhile dt_task = task last update date*/
                   (l_dt_last_update_task <> l_task_last_upd_date) OR (l_rank_task <> i_import_rec.rank) OR
                   (l_flg_status <> o_flg_status
                   --only in reported medication it is possible to change records from active to suggested if the review criteria is being used 
                   AND (l_flg_status <> pk_prog_notes_constants.g_epis_pn_det_flg_status_a OR
                   (i_import_rec.id_task_type = pk_prog_notes_constants.g_task_reported_medic AND
                   i_flg_suggest_concept = pk_prog_notes_constants.g_suggest_review_r))))
                
                THEN
                    o_flg_save := pk_prog_notes_constants.g_update_u;
                    pk_alertlog.log_info(text            => 'o_flg_save:' || o_flg_save,
                                         object_name     => g_package,
                                         sub_object_name => l_func_name);
                END IF;
            
            END IF;
        
        END IF;
    
        o_id_epis_pn_det_task := l_id_epis_pn_det_task;
        pk_alertlog.log_info(text            => 'o_id_epis_pn_det_task:' || o_id_epis_pn_det_task,
                             object_name     => g_package,
                             sub_object_name => l_func_name);
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END check_save;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_episode            Episode ID
    * @param   i_patient            Patient ID
    * @param   i_id_pn_note_type    Progress Note type (P-progress note; L-prolonged progress note; CC-intensive care note; H-history and physician note) 
    * @param   i_epis_pn            Progress note ID
    * @param   i_epis_pn_det        Progress note detail ID
    * @param   i_dep_clin_serv      Clinical Service ID
    * @param   i_pn_soap_block      SOAP Block ID
    * @param   i_pn_data_block      Data Block ID
    * @param   i_dt_begin           Start date to filter
    * @param   i_dt_end             End date to filter
    * @param   i_id_task_type       Array of task type ids
    * @param   i_id_pn_group        Group identifier
    * @param   i_epis_pn_det_task  Array of PN task details
    * @param   i_calc_task_descs        1-Calc the task descriptions. 0-Otherwise   
    * @param   i_flg_suggest_concept    Concept to determine the suggested records.      
    * @param   i_flg_action         Action being performed: A - auto-population, I - import, S-shortuct
    * @param   o_flg_imported       Flg indicating data imported Y/N
    * @param   o_id_epis_pn        Id of the created note
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   16-02-2011
    */
    FUNCTION get_import_save_struct
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_id_patient          IN patient.id_patient%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_epis_pn             IN epis_pn.id_epis_pn%TYPE,
        i_epis_pn_det         IN epis_pn_det.id_epis_pn_det%TYPE,
        i_dep_clin_serv       IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_data_import         IN t_coll_pn_work_data,
        i_id_pn_area          IN pn_area.id_pn_area%TYPE,
        i_flg_synchronized    IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_flg_review_all      IN pn_note_type_mkt.flg_review_all%TYPE,
        i_flg_check_prof      IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        i_flg_check_save      IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_definitive      IN VARCHAR2,
        i_flg_suggest_concept IN pn_note_type_mkt.flg_suggest_concept%TYPE,
        i_flg_action          IN epis_pn_det_task.flg_action%TYPE,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        io_note_struct        IN OUT NOCOPY pk_prog_notes_types.t_note_struct,
        o_tasks_descs_by_type OUT NOCOPY pk_prog_notes_types.t_tasks_descs_by_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'GET_IMPORT_SAVE_STRUCT';
    
        l_note_text CLOB;
        l_exception EXCEPTION;
    
        l_data_import_count PLS_INTEGER;
        l_add_to_list       PLS_INTEGER;
    
        l_epis_pn_det          epis_pn_det.id_epis_pn_det%TYPE := i_epis_pn_det;
        l_epis_pn              epis_pn.id_epis_pn%TYPE := i_epis_pn;
        l_rec_task             pk_prog_notes_types.t_rec_tasks;
        l_prev_soap_block      epis_pn_det_task.id_task_type%TYPE;
        l_prev_data_block      pn_data_block.id_pn_data_block%TYPE;
        l_flg_save             VARCHAR2(1 CHAR);
        l_id_epis_pn_det_task  epis_pn_det_task.id_epis_pn_det_task%TYPE;
        l_flg_new              VARCHAR2(1 CHAR);
        l_flg_status           epis_pn_det_task.flg_status%TYPE;
        l_tasks_groups_by_type pk_prog_notes_types.t_tasks_groups_by_type;
        l_grouped_task         VARCHAR2(1 CHAR);
    BEGIN
    
        pk_alertlog.log_info(text            => 'i_lang:' || i_lang || ' i_prof(' || i_prof.id || ',' ||
                                                i_prof.institution || ',' || i_prof.software || ')' || ' i_episode:' ||
                                                i_episode || ' i_id_patient:' || i_id_patient || ' i_id_pn_note_type:' ||
                                                i_id_pn_note_type || ' i_epis_pn:' || i_epis_pn || ' i_epis_pn_det:' ||
                                                i_epis_pn_det || ' i_dep_clin_serv:' || i_dep_clin_serv ||
                                                ' i_id_pn_area:' || i_id_pn_area || ' i_flg_synchronized:' ||
                                                i_flg_synchronized || ' i_flg_review_all:' || i_flg_review_all ||
                                                ' i_flg_check_prof:' || i_flg_check_prof || ' i_flg_check_save:' ||
                                                i_flg_check_save || ' i_flg_definitive:' || i_flg_definitive ||
                                                ' i_flg_suggest_concept:' || i_flg_suggest_concept || ' i_flg_action:' ||
                                                i_flg_action,
                             object_name     => g_package,
                             sub_object_name => l_func_name);
    
        /*IF i_data_import.exists(1)
        THEN
            FOR i IN 1 .. i_data_import.count
            LOOP
            
                pk_alertlog.log_info(text            => 'area_name:' || i_data_import(i).area_name ||
                                                        ' id_pn_soap_block:' || i_data_import(i).id_pn_soap_block ||
                                                        ' id_pn_data_block:' || i_data_import(i).id_pn_data_block ||
                                                        ' id_parent:' || i_data_import(i).id_parent ||
                                                        ' task_description:' || i_data_import(i).task_description ||
                                                        ' task:' || i_data_import(i).task || ' dt_reg:' || i_data_import(i)
                                                       .dt_reg || ' dt_register:' || i_data_import(i).dt_register ||
                                                        ' id_professional:' || i_data_import(i).id_professional ||
                                                        ' id_task:' || i_data_import(i).id_task || ' id_task_type:' || i_data_import(i)
                                                       .id_task_type || ' table_origin:' || i_data_import(i)
                                                       .table_origin || ' rank:' || i_data_import(i).rank ||
                                                        ' flg_import_date:' || i_data_import(i).flg_import_date ||
                                                        ' id_episode:' || i_data_import(i).id_episode ||
                                                        ' id_parent_struct_imp:' || i_data_import(i)
                                                       .id_parent_struct_imp || ' id_task_aggregator:' || i_data_import(i)
                                                       .id_task_aggregator || ' flg_reviewed_epis:' || i_data_import(i)
                                                       .flg_reviewed_epis || ' review_context:' || i_data_import(i)
                                                       .review_context || ' flg_auto_populated:' || i_data_import(i)
                                                       .flg_auto_populated || ' flg_import:' || i_data_import(i)
                                                       .flg_import || ' flg_data_removable:' || i_data_import(i)
                                                       .flg_data_removable || ' flg_synchronized:' || i_data_import(i)
                                                       .flg_synchronized || ' id_parent_comments:' || i_data_import(i)
                                                       .id_parent_comments || ' flg_has_comments:' || i_data_import(i)
                                                       .flg_has_comments || ' parent_task_type:' || i_data_import(i)
                                                       .parent_task_type || ' flg_parent_imported:' || i_data_import(i)
                                                       .flg_parent_imported || ' dt_task:' || i_data_import(i).dt_task ||
                                                        ' flg_type:' || i_data_import(i).flg_type || ' flg_ongoing:' || i_data_import(i)
                                                       .flg_ongoing || ' flg_selected:' || i_data_import(i)
                                                       .flg_selected || ' flg_group_on_import:' || i_data_import(i)
                                                       .flg_group_on_import || ' dt_group_import:' || i_data_import(i)
                                                       .dt_group_import || ' id_group_import:' || i_data_import(i)
                                                       .id_group_import || ' code_desc_group:' || i_data_import(i)
                                                       .code_desc_group || ' desc_group:' || i_data_import(i)
                                                       .desc_group || ' id_sub_group_import:' || i_data_import(i)
                                                       .id_sub_group_import || ' code_desc_sub_group:' || i_data_import(i)
                                                       .code_desc_sub_group || ' separator:' || i_data_import(i)
                                                       .separator || ' flg_scope:' || i_data_import(i).flg_scope ||
                                                        ' id_group_table:' || i_data_import(i).id_group_table ||
                                                        ' table_position:' || i_data_import(i).table_position ||
                                                        ' flg_editable:' || i_data_import(i).flg_editable ||
                                                        ' code_description:' || i_data_import(i).code_description ||
                                                        ' universal_description:' || i_data_import(i)
                                                       .universal_description || ' flg_sos:' || i_data_import(i)
                                                       .flg_sos || ' dt_begin:' || i_data_import(i).dt_begin ||
                                                        ' id_doc_area:' || i_data_import(i).id_doc_area ||
                                                        ' flg_group_select_filter:' || i_data_import(i)
                                                       .flg_group_select_filter || ' flg_show_sub_title:' || i_data_import(i)
                                                       .flg_show_sub_title || ' id_prof_review:' || i_data_import(i)
                                                       .id_prof_review || ' dt_review:' || i_data_import(i).dt_review ||
                                                        ' code_status:' || i_data_import(i).code_status || ' dt_end:' || i_data_import(i)
                                                       .dt_end || ' id_task_notes:' || i_data_import(i).id_task_notes ||
                                                        ' flg_status:' || i_data_import(i).flg_status ||
                                                        ' id_sample_type:' || i_data_import(i).id_sample_type ||
                                                        ' code_desc_sample_type:' || i_data_import(i)
                                                       .code_desc_sample_type || ' flg_review_avail:' || i_data_import(i)
                                                       .flg_review_avail || ' flg_description:' || i_data_import(i)
                                                       .flg_description,
                                     object_name     => g_package,
                                     sub_object_name => l_func_name);
            END LOOP;
        END IF;*/
    
        IF (i_data_import.exists(1))
        THEN
            g_error := 'CALL get_epis_pn_struct';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT get_epis_pn_struct(i_lang             => i_lang,
                                      i_prof             => i_prof,
                                      io_id_epis_pn      => l_epis_pn,
                                      i_id_episode       => i_episode,
                                      i_dt_pn_date       => NULL,
                                      i_id_dep_clin_serv => i_dep_clin_serv,
                                      i_id_pn_note_type  => i_id_pn_note_type,
                                      i_id_pn_area       => i_id_pn_area,
                                      i_flg_synchronized => i_flg_synchronized,
                                      i_flg_definitive   => i_flg_definitive,
                                      i_dt_proposed      => i_dt_proposed,
                                      io_note_struct     => io_note_struct,
                                      o_error            => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_data_import_count := i_data_import.count;
            FOR i IN 1 .. l_data_import_count
            LOOP
                l_flg_status := NULL;
            
                IF (i_flg_check_prof = pk_alert_constant.g_yes AND i_data_import(i).id_professional <> i_prof.id)
                THEN
                    l_add_to_list := 0;
                ELSE
                    l_add_to_list := 1;
                END IF;
            
                IF (l_add_to_list = 1)
                THEN
                    IF (i_data_import(i).flg_parent_imported = pk_alert_constant.g_yes)
                    THEN
                        IF ((i_data_import(i).id_pn_data_block <> l_prev_data_block OR l_prev_data_block IS NULL) OR
                           (i_data_import(i).id_pn_soap_block <> l_prev_soap_block OR l_prev_soap_block IS NULL))
                        THEN
                            l_epis_pn_det := NULL;
                        END IF;
                    
                        --check if it is necessary to save the record in the note
                        pk_alertlog.log_info(text            => 'i_flg_check_save:' || i_flg_check_save,
                                             object_name     => g_package,
                                             sub_object_name => l_func_name);
                        IF (i_flg_check_save = pk_alert_constant.g_yes)
                        THEN
                            g_error := 'CALL check_save';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT check_save(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_episode          => i_episode,
                                              i_import_rec          => i_data_import(i),
                                              i_id_epis_pn          => i_epis_pn,
                                              i_flg_review_all      => i_flg_review_all,
                                              i_flg_suggest_concept => i_flg_suggest_concept,
                                              o_flg_save            => l_flg_save,
                                              o_id_epis_pn_det_task => l_id_epis_pn_det_task,
                                              o_flg_status          => l_flg_status,
                                              o_error               => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            pk_alertlog.log_info(text            => 'l_flg_save:' || l_flg_save ||
                                                                    ' l_id_epis_pn_det_task:' || l_id_epis_pn_det_task ||
                                                                    ' l_flg_status:' || l_flg_status,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                        
                            IF (l_flg_save = pk_prog_notes_constants.g_insert_i)
                            THEN
                                l_id_epis_pn_det_task := NULL;
                                l_flg_new             := pk_alert_constant.g_yes;
                            END IF;
                        ELSE
                            l_flg_save            := pk_prog_notes_constants.g_insert_i;
                            l_id_epis_pn_det_task := NULL;
                            l_flg_new             := pk_alert_constant.g_yes;
                        END IF;
                        pk_alertlog.log_info(text            => 'l_flg_save2:' || l_flg_save,
                                             object_name     => g_package,
                                             sub_object_name => l_func_name);
                        IF (l_flg_save <> pk_alert_constant.g_no)
                        THEN
                            IF (l_flg_status IS NULL)
                            THEN
                                g_error := 'CALL get_flg_status';
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                            
                                IF NOT get_flg_status(i_lang                => i_lang,
                                                      i_prof                => i_prof,
                                                      i_episode             => i_episode,
                                                      i_import_rec          => i_data_import(i),
                                                      i_flg_review_all      => i_flg_review_all,
                                                      i_flg_new             => l_flg_new,
                                                      i_flg_suggest_concept => i_flg_suggest_concept,
                                                      io_flg_status         => l_flg_status, --TODO
                                                      o_error               => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            END IF;
                        
                            g_error := 'CALL pk_prog_notes_utils.get_task_text';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                        
                            l_note_text := i_data_import(i).task;
                        
                            IF ((i_data_import(i).id_pn_data_block <> l_prev_data_block OR l_prev_data_block IS NULL) OR
                               (i_data_import(i).id_pn_soap_block <> l_prev_soap_block OR l_prev_soap_block IS NULL))
                               OR (l_epis_pn_det IS NULL)
                               OR (i_data_import(i).flg_import = pk_prog_notes_constants.g_import_text)
                            THEN
                                IF ((i_data_import(i).id_pn_data_block <> l_prev_data_block OR l_prev_data_block IS NULL) OR
                                   (i_data_import(i).id_pn_soap_block <> l_prev_soap_block OR l_prev_soap_block IS NULL))
                                THEN
                                    l_epis_pn_det := NULL;
                                END IF;
                            
                                -- CREATE EPIS_PN_DET structure
                                g_error := 'CALL get_epis_pn_det_struct l_epis_pn_det: ' || l_epis_pn_det;
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                IF NOT get_epis_pn_det_struct(i_lang               => i_lang,
                                                         i_prof               => i_prof,
                                                         i_epis_pn            => l_epis_pn,
                                                         i_soap_block         => i_data_import(i).id_pn_soap_block,
                                                         i_data_block         => i_data_import(i).id_pn_data_block,
                                                         i_flg_status         => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                                         i_pn_note            => CASE
                                                                                     WHEN i_data_import(i)
                                                                                      .flg_import = pk_prog_notes_constants.g_import_text
                                                                                          --the not editable data blocks like visit information do not have an id_task
                                                                                           OR i_data_import(i).id_task IS NULL THEN
                                                                                      l_note_text
                                                                                     ELSE
                                                                                      NULL
                                                                                 END,
                                                         i_dt_pn_note         => NULL,
                                                         i_flg_type           => i_data_import(i).flg_type,
                                                         i_flg_app_upd        => CASE
                                                                                     WHEN i_data_import(i)
                                                                                      .flg_import = pk_prog_notes_constants.g_import_text THEN
                                                                                      pk_prog_notes_constants.g_append_a
                                                                                     ELSE
                                                                                      pk_alert_constant.g_no
                                                                                 END,
                                                         i_flg_aggregate_data => i_data_import(i).flg_group_on_import,
                                                         i_flg_scope          => i_data_import(i).flg_scope,
                                                         i_flg_group_type     => i_data_import(i).flg_group_type,
                                                         io_epis_pn_det       => l_epis_pn_det,
                                                         io_note_struct       => io_note_struct,
                                                         o_error              => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            END IF;
                        
                            g_error := 'CAll get_epis_pn_det_task_struct id_task: ' || i_data_import(i).id_task ||
                                       ' id_task_type: ' || i_data_import(i).id_task_type || ' l_epis_pn_det: ' ||
                                       l_epis_pn_det;
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF (i_data_import(i).id_task IS NOT NULL)
                            THEN
                            
                                IF NOT get_epis_pn_det_task_struct(i_lang                   => i_lang,
                                                                   i_prof                   => i_prof,
                                                                   i_id_episode             => i_episode,
                                                                   i_id_task                => i_data_import(i).id_task,
                                                                   i_id_task_type           => i_data_import(i).id_task_type,
                                                                   i_id_epis_pn_det         => l_epis_pn_det,
                                                                   i_id_task_aggregator     => i_data_import(i).id_task_aggregator,
                                                                   i_flg_status             => l_flg_status,
                                                                   i_pn_note                => l_note_text,
                                                                   i_flg_table_origin       => i_data_import(i).table_origin,
                                                                   i_dt_task                => i_data_import(i).dt_task,
                                                                   i_id_parent              => NULL,
                                                                   i_rank_task              => i_data_import(i).rank,
                                                                   i_id_prof_task           => i_data_import(i).id_professional,
                                                                   i_id_epis_pn_det_task    => l_id_epis_pn_det_task,
                                                                   i_id_task_parent         => i_data_import(i).id_parent_comments,
                                                                   i_dt_group_import        => i_data_import(i).dt_group_import,
                                                                   i_id_group_import        => i_data_import(i).id_group_import,
                                                                   i_code_desc_group        => i_data_import(i).code_desc_group,
                                                                   i_desc_group             => i_data_import(i).desc_group,
                                                                   i_id_sub_group_import    => i_data_import(i).id_sub_group_import,
                                                                   i_code_desc_sub_group    => i_data_import(i).code_desc_sub_group,
                                                                   i_id_group_table         => i_data_import(i).id_group_table,
                                                                   i_flg_aggregate_data     => i_data_import(i).flg_group_on_import,
                                                                   i_table_position         => i_data_import(i).table_position,
                                                                   i_code_description       => i_data_import(i).code_description,
                                                                   i_universal_desc_clob    => i_data_import(i).universal_description,
                                                                   i_flg_sos                => i_data_import(i).flg_sos,
                                                                   i_dt_begin               => i_data_import(i).dt_begin,
                                                                   i_id_doc_area            => i_data_import(i).id_doc_area,
                                                                   i_dt_register            => i_data_import(i).dt_register,
                                                                   i_flg_show_sub_title     => i_data_import(i).flg_show_sub_title,
                                                                   i_id_prof_review         => i_data_import(i).id_prof_review,
                                                                   i_dt_review              => i_data_import(i).dt_review,
                                                                   i_code_status            => i_data_import(i).code_status,
                                                                   i_flg_status_req         => i_data_import(i).flg_status,
                                                                   i_end_date               => i_data_import(i).dt_end,
                                                                   i_dt_req                 => i_data_import(i).dt_register,
                                                                   i_id_task_notes          => i_data_import(i).id_task_notes,
                                                                   i_flg_action             => i_flg_action,
                                                                   i_id_sample_type         => i_data_import(i).id_sample_type,
                                                                   i_code_desc_sample_type  => i_data_import(i).code_desc_sample_type,
                                                                   i_flg_description        => i_data_import(i).flg_description,
                                                                   i_description_condition  => i_data_import(i).description_condition,
                                                                   i_code_desc_group_parent => i_data_import(i).code_desc_group_parent,
                                                                   i_instructions_hash      => i_data_import(i).instructions_hash,
                                                                   o_rec_task               => l_rec_task,
                                                                   o_error                  => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            
                                IF (i_flg_action <> pk_prog_notes_constants.g_flg_action_shortcut AND i_data_import(i).description_condition IS NULL)
                                THEN
                                    g_error := 'CALL pk_prog_notes_utils.get_task_groups_by_type';
                                    pk_alertlog.log_debug(g_error);
                                    IF NOT
                                        pk_prog_notes_utils.get_task_groups_by_type(i_lang                  => i_lang,
                                                                                    i_prof                  => i_prof,
                                                                                    i_id_task_type          => i_data_import(i).id_task_type,
                                                                                    i_id_task               => i_data_import(i).id_task,
                                                                                    i_id_task_notes         => i_data_import(i).id_task_notes,
                                                                                    io_tasks_groups_by_type => l_tasks_groups_by_type,
                                                                                    o_grouped_task          => l_grouped_task,
                                                                                    o_error                 => o_error)
                                    THEN
                                        RAISE g_exception;
                                    END IF;
                                END IF;
                            
                                g_error := 'Assign task to strucutre. l_epis_pn_det: ' || l_epis_pn_det ||
                                           ' id_epis_pn_det_task: ' || l_rec_task.id_epis_pn_det_task;
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                io_note_struct.tbl_dblock_det(l_epis_pn_det).tbl_tasks(l_rec_task.id_epis_pn_det_task) := l_rec_task;
                            END IF;
                        END IF;
                    
                        l_prev_soap_block := i_data_import(i).id_pn_soap_block;
                        l_prev_data_block := i_data_import(i).id_pn_data_block;
                    END IF;
                END IF;
            END LOOP;
        
            IF (i_flg_action <> pk_prog_notes_constants.g_flg_action_shortcut)
            THEN
                g_error := 'CALL pk_prog_notes_in.get_group_descriptions';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_prog_notes_in.get_group_descriptions(i_lang                 => i_lang,
                                                               i_prof                 => i_prof,
                                                               i_id_episode           => i_episode,
                                                               i_id_patient           => i_id_patient,
                                                               i_tasks_groups_by_type => l_tasks_groups_by_type,
                                                               o_tasks_descs_by_type  => o_tasks_descs_by_type,
                                                               o_error                => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_import_save_struct;

    /**
    * Syncronize the note with the data in the auto-populated areas     
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_patient             patient identifier
    * @param i_id_epis_pn             Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_id_dep_clin_serv       Dep_clin_serv id
    * @param i_flg_synch_note         Y-this note type should be synchronized. Should opens directly the edit screen. N-otherwize
    * @param i_flg_search_dblock      Types of Data Blocks to search on records
    * @param i_discharge_date         Discharge date, the syncronization will only be done till this date, if it is send
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_configs_ctx            Configs context structure  
    * @param i_id_pn_soap_block       Soap blocks ID
    * @param i_flg_action             Action being performed: A - auto-population, I - import, S-shortuct
    * @param io_id_epis_pn            Note id. In the 1st time it is created a new note id
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @value  i_flg_search_dblock     {*} 'I'- Import Mechanism {*} 'A'- Auto populated records {*} 'S'- Suggested records
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   13-Feb-2012
    */

    FUNCTION set_synchronize_note
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_patient          IN patient.id_patient%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_id_dep_clin_serv    IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_flg_search_dblock   IN VARCHAR2,
        i_discharge_date      IN discharge.dt_med_tstz%TYPE,
        i_configs_ctx         IN pk_prog_notes_types.t_configs_ctx,
        i_id_epis_pn_det_task IN table_number,
        i_flg_definitive      IN VARCHAR2,
        i_id_pn_soap_block    IN table_number,
        i_flg_action          IN epis_pn_det_task.flg_action%TYPE,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_flg_update_dt       IN VARCHAR2 DEFAULT 'Y',
        i_only_autopop        IN VARCHAR2,
        io_id_epis_pn         IN OUT epis_pn.id_epis_pn%TYPE,
        o_dt_last_update      OUT TIMESTAMP WITH LOCAL TIME ZONE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'SET_SYNCHRONIZE_NOTE';
    
        work_block_header EXCEPTION;
        work_block_txt    EXCEPTION;
        copy_2_work       EXCEPTION;
        epis_start_date   EXCEPTION;
        discharge_date    EXCEPTION;
        pn_note_type      EXCEPTION;
    
        l_data_blocks t_coll_data_blocks;
    
        l_data_blocks_notes table_number;
        l_soap_blocks_notes table_number;
        l_id_tasks          table_number;
        l_id_task_types     table_number;
    
        l_note_struct pk_prog_notes_types.t_note_struct;
    
        l_data_import t_coll_data_import := t_coll_data_import();
        l_data        t_coll_pn_work_data := t_coll_pn_work_data();
        --l_start          NUMBER DEFAULT dbms_utility.get_time;   
        l_tasks_descs_by_type pk_prog_notes_types.t_tasks_descs_by_type;
        l_id_visit            visit.id_visit%TYPE;
        l_sblock              table_number;
        l_dblock              table_number;
    
    BEGIN
        --l_start          := dbms_utility.get_time;        
        o_dt_last_update := current_timestamp;
        l_id_visit       := pk_episode.get_id_visit(i_episode => i_id_episode);
    
        --when performing some action over a record in the note it is necessary to syncronize it        
        IF (i_id_epis_pn_det_task IS NOT NULL AND i_id_epis_pn_det_task.exists(1) AND
           i_id_epis_pn_det_task(1) IS NOT NULL)
        THEN
            SELECT /*+opt_estimate(table,t,scale_rows=0.0000001)*/
             epd.id_pn_data_block, epdt.id_task, epdt.id_task_type, epd.id_pn_soap_block
              BULK COLLECT
              INTO l_data_blocks_notes, l_id_tasks, l_id_task_types, l_soap_blocks_notes
              FROM epis_pn_det_task epdt
              JOIN epis_pn_det epd
                ON epd.id_epis_pn_det = epdt.id_epis_pn_det
              JOIN (SELECT column_value
                      FROM TABLE(i_id_epis_pn_det_task)) t
                ON t.column_value = epdt.id_epis_pn_det_task;
        
        ELSIF (i_configs_ctx.note_type.flg_synchronized = pk_alert_constant.g_yes OR
              i_flg_search_dblock IN
              (pk_prog_notes_constants.g_auto_pop_dblocks_a, pk_prog_notes_constants.g_synch_dblocks_c))
        THEN
            --calculate the data blocks in the note. Only these data blocks data are auto-syncronized will
            --be imported. There is no need to import all the auto-synch data, if they do not have records in the note
            g_error := 'CALL pk_prog_notes_utils.get_notes_list. io_id_epis_pn: ' || io_id_epis_pn;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_notes_list(i_lang             => i_lang,
                                                      i_prof             => i_prof,
                                                      i_id_epis_pn       => io_id_epis_pn,
                                                      i_id_pn_soap_block => i_id_pn_soap_block,
                                                      o_data_blocks      => l_data_blocks_notes,
                                                      o_soap_blocks      => l_soap_blocks_notes,
                                                      o_error            => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        IF i_flg_update_dt = pk_alert_constant.g_no
           AND io_id_epis_pn IS NOT NULL
        THEN
            o_dt_last_update := NULL;
        ELSE
            o_dt_last_update := current_timestamp;
        END IF;
    
        IF NOT pk_prog_notes_utils.get_related_blocks(i_lang        => i_lang,
                                                      i_prof        => i_prof,
                                                      i_id_sblock   => i_id_pn_soap_block,
                                                      i_configs_ctx => i_configs_ctx,
                                                      io_sblocks    => l_soap_blocks_notes,
                                                      io_dblocks    => l_data_blocks_notes,
                                                      o_error       => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --dbms_output.put_line('Synch1: ' || to_char(dbms_utility.get_time - l_start));
        --get all autopopulated data blocks from note
        g_error := 'CALL pk_progress_notes_upd.get_import_dblocks';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_progress_notes_upd.get_import_dblocks(i_lang             => i_lang,
                                                        i_prof             => i_prof,
                                                        i_id_pn_note_type  => i_id_pn_note_type,
                                                        i_flg_search       => i_flg_search_dblock,
                                                        i_dblocks_list     => l_data_blocks_notes,
                                                        i_sblocks_list     => l_soap_blocks_notes,
                                                        i_configs_ctx      => i_configs_ctx,
                                                        i_id_pn_soap_block => i_id_pn_soap_block,
                                                        o_data_block       => l_data_blocks,
                                                        o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --As the CIts info is in single page and the status is updates in the list view cits function when the user 
        --accesses the deepnav, it is also necessary to update cit status in the single page
        g_error := 'pk_cit.update_status_cit_int';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        pk_cit.update_status_cit_int(i_lang    => i_lang,
                                     i_prof    => i_prof,
                                     i_patient => i_id_patient,
                                     i_episode => i_id_episode);
    
        IF (l_data_blocks IS NOT NULL AND l_data_blocks.exists(1))
        THEN
            --get the importable data for the auto-populated data blocks
            g_error := 'CALL get_data_import_list.';
            pk_alertlog.log_debug(g_error);
            IF NOT get_data_import_list(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_episode          => i_id_episode,
                                        i_id_patient          => i_id_patient,
                                        i_id_visit            => l_id_visit,
                                        i_data_blocks         => l_data_blocks,
                                        i_begin_date          => NULL,
                                        i_end_date            => i_discharge_date,
                                        i_flg_synch_note      => i_configs_ctx.note_type.flg_synchronized,
                                        i_import_screen       => pk_alert_constant.g_no,
                                        i_action              => i_flg_action,
                                        i_id_pn_note_type     => i_id_pn_note_type,
                                        i_id_tasks            => l_id_tasks,
                                        i_id_task_types       => l_id_task_types,
                                        i_id_pn_soap_block    => i_id_pn_soap_block,
                                        i_id_epis_pn          => io_id_epis_pn,
                                        i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                        i_dt_proposed         => i_dt_proposed,
                                        i_only_autopop        => i_only_autopop,
                                        o_data_import         => l_data_import,
                                        o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            --Remove the records that are saved in the note but were cancelled or outdated in the meanwhile
            g_error := 'CALL set_synch_remove_canc.';
            pk_alertlog.log_debug(g_error);
            IF NOT set_synch_remove_canc(i_lang             => i_lang,
                                         i_prof             => i_prof,
                                         i_id_episode       => i_id_episode,
                                         i_data_import      => l_data_import,
                                         i_data_blocks      => l_data_blocks,
                                         i_id_task          => l_id_tasks,
                                         i_id_task_type     => l_id_task_types,
                                         i_id_pn_soap_block => i_id_pn_soap_block,
                                         io_id_epis_pn      => io_id_epis_pn,
                                         io_note_struct     => l_note_struct,
                                         o_error            => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF (l_data_import.count > 0)
            THEN
                --Transform cursor
                g_error := 'Transform cursor';
                IF NOT get_data_cursor(i_lang        => i_lang,
                                       i_prof        => i_prof,
                                       i_id_epis_pn  => io_id_epis_pn,
                                       i_id_episode  => i_id_episode,
                                       i_id_patient  => i_id_patient,
                                       i_data_import => l_data_import,
                                       i_data_block  => l_data_blocks,
                                       i_flg_review  => i_configs_ctx.note_type.flg_review_all,
                                       o_data        => l_data,
                                       o_error       => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                --l_start := dbms_utility.get_time;
                --save the tasks that does not need to be reviwed in the note
                g_error := 'CALL set_save_synch_records. i_id_episode: ' || i_id_episode || ' i_id_pn_note_type: ' ||
                           i_id_pn_note_type || ' i_id_dep_clin_serv: ' || i_id_dep_clin_serv;
                pk_alertlog.log_debug(g_error);
            
                g_error := 'CALL get_import_save_struct';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_import_save_struct(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_episode             => i_id_episode,
                                              i_id_patient          => i_id_patient,
                                              i_id_pn_note_type     => i_id_pn_note_type,
                                              i_epis_pn             => io_id_epis_pn,
                                              i_epis_pn_det         => NULL,
                                              i_dep_clin_serv       => i_configs_ctx.id_dep_clin_serv,
                                              i_data_import         => l_data,
                                              i_id_pn_area          => i_configs_ctx.note_type.id_pn_area,
                                              i_flg_synchronized    => i_configs_ctx.note_type.flg_synchronized,
                                              i_flg_review_all      => i_configs_ctx.note_type.flg_review_all,
                                              i_flg_check_prof      => pk_alert_constant.g_no,
                                              i_flg_check_save      => pk_alert_constant.g_yes,
                                              i_flg_definitive      => i_flg_definitive,
                                              i_flg_suggest_concept => i_configs_ctx.note_type.flg_suggest_concept,
                                              i_flg_action          => i_flg_action,
                                              i_dt_proposed         => i_dt_proposed,
                                              io_note_struct        => l_note_struct,
                                              o_tasks_descs_by_type => l_tasks_descs_by_type,
                                              o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
            END IF;
        END IF;
    
        io_id_epis_pn := nvl(io_id_epis_pn, l_note_struct.id_epis_pn);
    
        IF l_note_struct.id_epis_pn IS NOT NULL
        THEN
            g_error := 'CALL ins_upd_pn_note';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT ins_upd_pn_note(i_lang                => i_lang,
                                   i_prof                => i_prof,
                                   i_id_episode          => i_id_episode,
                                   i_note_struct         => l_note_struct,
                                   i_dt_last_update      => o_dt_last_update,
                                   i_flg_synchronized    => i_configs_ctx.note_type.flg_synchronized,
                                   i_flg_sign_off        => i_configs_ctx.note_type.flg_sign_off,
                                   i_flg_submit          => i_configs_ctx.note_type.flg_submit,
                                   i_flg_upd_note        => pk_alert_constant.g_no,
                                   i_tasks_descs_by_type => l_tasks_descs_by_type,
                                   o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'CALL update_task_ranks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_core.update_aggregations(i_lang        => i_lang,
                                                          i_prof        => i_prof,
                                                          i_id_episode  => i_id_episode,
                                                          i_id_visit    => l_id_visit,
                                                          i_id_patient  => i_id_patient,
                                                          i_note_struct => l_note_struct,
                                                          o_error       => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END set_synchronize_note;

    /**
    * Returns the suggested records for the episode
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_episode             Episode identifier
    * @param i_auto_suggested_tasks   Array of Auto Suggested tasks
    * @param i_id_epis_pn             Episode Work Note Identifier
    * @param i_id_pn_soap_block       Soap block ID
    * @param i_flg_editable           A-Editable note. T-Not editable except free texts N-Otherwise
    * @param i_market                 Market ID
    *
    * @param o_suggested              Array of Auto Suggested tasks
    * @param o_error                  error information
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author                         ANTONIO.NETO
    * @version                        2.6.2
    * @since                          08-Mar-2012
    */
    FUNCTION get_suggested_records
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        i_flg_editable     IN VARCHAR2,
        i_configs_ctx      IN pk_prog_notes_types.t_configs_ctx,
        i_dt_last_update   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_id_pn_soap_block IN table_number,
        o_suggested        OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_pn_soap_block table_number;
    BEGIN
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        g_error := 'GET Auto Populated BLOCK TEXT';
        pk_alertlog.log_debug(text            => g_error,
                              object_name     => g_package,
                              sub_object_name => 'get_auto_populated_block_txt');
        OPEN o_suggested FOR
            SELECT t_int.id_epis_pn,
                   t_int.id_epis_pn_det,
                   t_int.block_id,
                   t_int.id_pn_data_block,
                   t_int.pn_note,
                   t_int.id_task,
                   t_int.id_task_aggregator,
                   t_int.id_pn_task_type,
                   t_int.id_epis_pn_det_task,
                   t_int.note_date,
                   t_int.flg_table_origin,
                   t_int.flg_review,
                   t_int.flg_modified,
                   t_int.flg_may_edit,
                   t_int.flg_remove,
                   t_int.flg_state_review,
                   t_int.flg_state_remove,
                   t_int.block_area_desc,
                   t_int.dt_task_str,
                   t_int.flg_select_in_group,
                   (SELECT pk_prog_notes_utils.get_flg_no_action(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_flg_dblock_type => t_int.flg_type,
                                                                 i_flg_editable    => i_flg_editable)
                      FROM dual) flg_no_action,
                   pk_alert_constant.g_yes flg_suggested,
                   t_int.id_parent,
                   (SELECT pk_prog_notes_in.has_multichoice(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_id_task_type => t_int.id_pn_task_type)
                      FROM dual) flg_has_multichoice,
                   (SELECT pk_prog_notes_utils.get_signature(i_lang               => i_lang,
                                                             i_prof               => i_prof,
                                                             i_id_episode         => i_id_episode,
                                                             i_id_prof_last_upd   => t_int.id_prof_task,
                                                             i_dt_last_upd        => t_int.dt_register,
                                                             i_id_prof_review     => t_int.id_prof_review,
                                                             i_dt_review          => t_int.dt_review,
                                                             i_flg_show_signature => t_int.flg_show_signature)
                      FROM dual) signature,
                   t_int.flg_show_signature,
                   t_int.id_group,
                   t_int.is_templ_bl,
                   t_int.flg_score
            
              FROM (SELECT /*+opt_estimate(table,t,scale_rows=0.1)*/
                     i_id_epis_pn id_epis_pn,
                     epdw.id_epis_pn_det,
                     epd.id_pn_soap_block block_id,
                     epd.id_pn_data_block,
                     nvl(epdw.pn_note, epd.pn_note) pn_note,
                     epdw.id_task,
                     epdw.id_task_aggregator,
                     epdw.id_task_type id_pn_task_type,
                     epdw.id_epis_pn_det_task,
                     NULL note_date,
                     epdw.flg_table_origin,
                     pk_alert_constant.g_yes flg_review,
                     (SELECT pk_prog_notes_utils.get_flg_modified(i_lang                => i_lang,
                                                                  i_prof                => i_prof,
                                                                  i_pn_note             => epdw.pn_note,
                                                                  i_dt_pn               => epd.dt_pn,
                                                                  i_dt_last_update_task => epdw.dt_last_update,
                                                                  i_dt_last_update      => i_dt_last_update,
                                                                  i_flg_syncronized     => i_configs_ctx.note_type.flg_synchronized)
                        FROM dual) flg_modified,
                     pk_alert_constant.g_no flg_may_edit,
                     (SELECT get_flg_remove(i_flg_data_removal => db.flg_data_removable,
                                            i_flg_suggested    => pk_alert_constant.g_yes,
                                            i_flg_editable     => i_flg_editable,
                                            i_flg_action       => epdw.flg_action)
                        FROM dual) flg_remove,
                     pk_prog_notes_constants.g_review_action flg_state_review,
                     pk_prog_notes_constants.g_epis_pn_det_sug_rem_i flg_state_remove,
                     (SELECT pk_progress_notes_upd.get_block_area_desc(i_lang, i_prof, epd.id_pn_data_block)
                        FROM dual) block_area_desc,
                     (SELECT pk_date_utils.date_send_tsz(i_lang, epdw.dt_task, i_prof)
                        FROM dual) dt_task_str,
                     (SELECT get_flg_select_in_group(i_id_task_type   => epdw.id_task_type,
                                                     i_flg_review_all => i_configs_ctx.note_type.flg_review_all)
                        FROM dual) flg_select_in_group,
                     epdw.dt_task dt_register,
                     epdw.id_parent,
                     db.flg_type,
                     db.rank dblock_rank,
                     sb.rank sblock_rank,
                     epdw.rank_task task_rank,
                     epdw.id_prof_task,
                     (SELECT pk_prog_notes_utils.get_flg_show_signature(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_flg_suggested    => pk_alert_constant.g_yes,
                                                                        i_id_prof_reg      => nvl(epdw.id_prof_review,
                                                                                                  epdw.id_prof_task),
                                                                        i_flg_import_date  => db.flg_import_date,
                                                                        i_dblock_data_area => db.data_area,
                                                                        i_flg_import       => db.flg_import,
                                                                        i_flg_signature    => db.flg_signature)
                        FROM dual) flg_show_signature,
                     epdw.id_prof_review,
                     epdw.dt_review,
                     epdw.id_group_import id_group,
                     CASE
                          WHEN epdw.id_task_type IN (pk_prog_notes_constants.g_task_templates) THEN
                           pk_touch_option_out.has_layout(i_epis_documentation => epdw.id_task)
                          ELSE
                           pk_alert_constant.g_no
                      END is_templ_bl,
                     da.flg_score
                    
                      FROM epis_pn_det_task epdw
                     INNER JOIN epis_pn_det epd
                        ON epd.id_epis_pn_det = epdw.id_epis_pn_det
                      LEFT JOIN (SELECT /*+opt_estimate(table,t,scale_rows=0.0000001)*/
                                 t.id_pn_soap_block,
                                 t.id_pn_data_block,
                                 t.flg_import,
                                 t.flg_type,
                                 t.rank,
                                 t.flg_import_date,
                                 t.data_area,
                                 t.flg_signature,
                                 t.flg_data_removable,
                                 t.id_doc_area
                                  FROM TABLE(i_configs_ctx.data_blocks) t) db
                        ON epd.id_pn_soap_block = db.id_pn_soap_block
                       AND epd.id_pn_data_block = db.id_pn_data_block
                      LEFT JOIN TABLE(i_configs_ctx.soap_blocks) sb
                        ON sb.id_pn_soap_block = db.id_pn_soap_block
                      LEFT JOIN doc_area da
                        ON da.id_doc_area = db.id_doc_area
                     WHERE epdw.flg_status = pk_prog_notes_constants.g_epis_pn_det_sug_add_s
                       AND (l_id_pn_soap_block IS NULL OR
                           epd.id_pn_soap_block IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                      column_value
                                                       FROM TABLE(l_id_pn_soap_block) t))
                       AND epdw.id_parent IS NULL
                       AND epd.id_epis_pn = i_id_epis_pn) t_int
             ORDER BY sblock_rank ASC, dblock_rank ASC, block_id, id_pn_data_block, task_rank, t_int.dt_register DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_suggested);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_SUGGESTED_RECORDS',
                                              o_error);
        
            RETURN FALSE;
    END get_suggested_records;

    /**
    * Returns the notes to the summary grid.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_patient             patient identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_flg_search_dblock      Types of Data Blocks to search on records
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_configs_ctx             Configs context structure  
    * @param i_soap_blocks      Soap blocks list to be considered
    *
    * @param io_id_epis_pn_work        Episode Work Note Identifier 
    *
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @value  i_flg_search_dblock     {*} 'I'- Import Mechanism {*} 'A'- Auto populated records {*} 'S'- Suggested records
    *
    * @author                         RUI.SPRATLEY
    * @version                        2.6.0.5
    * @since                          04-02-2011
    *
    * @author                         ANTONIO.NETO
    * @version                        2.6.2
    * @since                          08-Mar-2012
    */
    FUNCTION get_notes_core_int
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_patient          IN patient.id_patient%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_flg_search_dblock   IN VARCHAR2,
        i_id_epis_pn_det_task IN table_number,
        i_configs_ctx         IN pk_prog_notes_types.t_configs_ctx,
        i_id_pn_soap_block    IN table_number,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_flg_update_dt       IN VARCHAR2 DEFAULT 'Y',
        i_only_autopop        IN VARCHAR2,
        io_id_epis_pn         IN OUT epis_pn.id_epis_pn%TYPE,
        o_dt_last_update      OUT TIMESTAMP WITH LOCAL TIME ZONE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        work_block_header EXCEPTION;
        copy_2_work       EXCEPTION;
        epis_start_date   EXCEPTION;
        discharge_date    EXCEPTION;
    
        pn_note_type EXCEPTION;
    
        l_flg_disch_status discharge.flg_status%TYPE;
    
        l_discharge_adm  discharge.dt_admin_tstz%TYPE;
        l_discharge_med  discharge.dt_med_tstz%TYPE;
        l_discharge_pend discharge.dt_pend_tstz%TYPE;
    
        l_discharge_date discharge.dt_med_tstz%TYPE := NULL;
        l_flg_synch      PLS_INTEGER := 1;
    
        l_func_name CONSTANT VARCHAR2(35 CHAR) := 'GET_NOTES_CORE_INT';
    
    BEGIN
        IF (i_configs_ctx.note_type.flg_edit_after_disch = pk_alert_constant.g_no)
        THEN
            --When the patient has discharge date. The auto-population considers the end date as the discharge date
            g_error := 'CALL pk_discharge.get_discharge_dates';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_discharge.get_discharge_dates(i_lang                 => i_lang,
                                                    i_prof                 => i_prof,
                                                    i_id_episode           => i_id_episode,
                                                    o_discharge_adm        => l_discharge_adm,
                                                    o_discharge_med        => l_discharge_med,
                                                    o_discharge_pend       => l_discharge_pend,
                                                    o_flg_discharge_status => l_flg_disch_status,
                                                    o_error                => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_discharge_date := nvl(nvl(l_discharge_pend, l_discharge_med), l_discharge_adm);
        END IF;
    
        g_error := 'CALL pk_prog_notes_utils.check_synchronization_needed';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_prog_notes_utils.check_synchronization_needed(i_lang                 => i_lang,
                                                                i_prof                 => i_prof,
                                                                i_id_episode           => i_id_episode,
                                                                i_id_epis_pn           => io_id_epis_pn,
                                                                i_editable_nr_min      => i_configs_ctx.note_type.editable_nr_min,
                                                                i_flg_synchronized     => i_configs_ctx.note_type.flg_synchronized,
                                                                i_id_pn_note_type      => i_id_pn_note_type,
                                                                i_id_epis_pn_det_task  => i_id_epis_pn_det_task,
                                                                i_flg_sync_after_disch => i_configs_ctx.note_type.flg_sync_after_disch,
                                                                o_flg_synch            => l_flg_synch,
                                                                o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_flg_synch = 1)
        THEN
            g_error := 'CALL set_synchronize_note. i_id_pn_note_type: ' || i_id_pn_note_type || ' i_id_epis_pn: ' ||
                       io_id_epis_pn || ' i_id_dep_clin_serv: ' || i_configs_ctx.id_dep_clin_serv;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT set_synchronize_note(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_id_episode          => i_id_episode,
                                        i_id_patient          => i_id_patient,
                                        i_id_pn_note_type     => i_id_pn_note_type,
                                        i_id_dep_clin_serv    => i_configs_ctx.id_dep_clin_serv,
                                        i_flg_search_dblock   => pk_prog_notes_utils.get_autopop_type_flg(i_lang                => i_lang,
                                                                                                          i_prof                => i_prof,
                                                                                                          i_id_epis_pn          => io_id_epis_pn,
                                                                                                          i_flg_synchronized    => i_configs_ctx.note_type.flg_synchronized,
                                                                                                          i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                                                                                          i_flg_search_dblock   => i_flg_search_dblock),
                                        i_discharge_date      => l_discharge_date,
                                        i_configs_ctx         => i_configs_ctx,
                                        i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                        i_flg_definitive      => pk_alert_constant.g_no,
                                        i_id_pn_soap_block    => i_id_pn_soap_block,
                                        i_flg_action          => pk_prog_notes_constants.g_flg_action_autopop,
                                        i_dt_proposed         => i_dt_proposed,
                                        io_id_epis_pn         => io_id_epis_pn,
                                        i_flg_update_dt       => i_flg_update_dt,
                                        i_only_autopop        => i_only_autopop,
                                        o_dt_last_update      => o_dt_last_update,
                                        o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN epis_start_date THEN
            g_error := 'EPIS_START_DATE';
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        WHEN copy_2_work THEN
            g_error := 'COPY_2_WORK';
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        WHEN work_block_header THEN
            g_error := 'work_block_header';
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
        WHEN g_exception THEN
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_notes_core_int;

    /**
    * Reset session context variables.
    *
    * @param i_prof             logged professional structure
    * @param i_episode          episode identifier
    * @param i_id_pn_note_type  soap note type
    * @param i_epis_pn          soap note identifier
    * @param i_id_dep_clin_serv Dep clin serv id
    * @param i_flg_get_blocks   Y-Get the data and soap blocks info as well as general info and note type info.
    *                           N-Get general and note type info only
    * @param i_soap_blocks      Soap blocks list to be considered
    *
    * @author                   Sofia Mendes
    * @version                  2.6.2.2
    * @since                    18-Jun-2012
    */
    FUNCTION reset_configs_ctx
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_id_pn_note_type  IN pn_note_type.id_pn_note_type%TYPE,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_dep_clin_serv IN dep_clin_serv.id_dep_clin_serv%TYPE DEFAULT NULL,
        i_flg_get_blocks   IN VARCHAR2 DEFAULT pk_alert_constant.g_yes
        
    ) RETURN pk_prog_notes_types.t_configs_ctx IS
        l_configs_ctx pk_prog_notes_types.t_configs_ctx;
        l_func_name CONSTANT VARCHAR2(17 CHAR) := 'RESET_CONFIGS_CTX';
    BEGIN
        g_error       := 'CALL reset_context';
        l_configs_ctx := pk_progress_notes_upd.reset_ctx(i_prof             => i_prof,
                                                         i_episode          => i_episode,
                                                         i_id_pn_note_type  => i_id_pn_note_type,
                                                         i_epis_pn          => i_epis_pn,
                                                         i_id_dep_clin_serv => i_id_dep_clin_serv);
    
        --set aditional info to context variable
        l_configs_ctx.id_lang := i_lang;
    
        IF (i_flg_get_blocks = pk_alert_constant.g_yes)
        THEN
            g_error := 'CALL pk_progress_notes_upd.get_all_blocks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            pk_progress_notes_upd.get_all_blocks(i_prof => i_prof, io_configs_ctx => l_configs_ctx);
        ELSIF (i_flg_get_blocks = pk_prog_notes_constants.g_soap_and_data_blocks)
        THEN
            g_error := 'CALL pk_progress_notes_upd.get_sblocks_dblocks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            pk_progress_notes_upd.get_sblocks_dblocks(i_prof => i_prof, io_configs_ctx => l_configs_ctx);
        END IF;
    
        g_error := 'Call GET_NOTE_TYPE_CONFIG';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx.note_type := pk_prog_notes_utils.get_note_type_config(i_lang                => i_lang,
                                                                            i_prof                => i_prof,
                                                                            i_id_episode          => i_episode,
                                                                            i_id_profile_template => l_configs_ctx.id_profile_template,
                                                                            i_id_market           => l_configs_ctx.id_market,
                                                                            i_id_department       => l_configs_ctx.id_department,
                                                                            i_id_dep_clin_serv    => l_configs_ctx.id_dep_clin_serv,
                                                                            i_id_epis_pn          => i_epis_pn,
                                                                            i_id_pn_note_type     => i_id_pn_note_type,
                                                                            i_software            => l_configs_ctx.id_software);
    
        pk_alertlog.log_info(text => 'STARTCONFIG', object_name => g_package, sub_object_name => l_func_name);
        g_error := 'id_market:' || l_configs_ctx.id_market || ' id_profile_template:' ||
                   l_configs_ctx.id_profile_template || ' id_category:' || l_configs_ctx.id_category ||
                   ' id_department:' || l_configs_ctx.id_department || ' id_dep_clin_serv:' ||
                   l_configs_ctx.id_dep_clin_serv || ' flg_approach:' || l_configs_ctx.flg_approach ||
                   ' id_pn_note_type:' || l_configs_ctx.id_pn_note_type || ' id_episode:' || l_configs_ctx.id_episode ||
                   ' id_software:' || l_configs_ctx.id_software || ' id_lang:' || l_configs_ctx.id_lang || ' prof:(' ||
                   l_configs_ctx.prof.id || ',' || l_configs_ctx.prof.institution || ',' || l_configs_ctx.prof.software || ')';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF l_configs_ctx.soap_blocks.exists(1)
        THEN
            pk_alertlog.log_info(text            => 'l_configs_ctx.soap_blocks',
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
            FOR i IN 1 .. l_configs_ctx.soap_blocks.count
            LOOP
                g_error := 'id_pn_soap_block:' || l_configs_ctx.soap_blocks(i).id_pn_soap_block || ' id_institution:' || l_configs_ctx.soap_blocks(i).id_institution ||
                           ' id_software:' || l_configs_ctx.soap_blocks(i).id_software || ' id_department:' || l_configs_ctx.soap_blocks(i).id_department ||
                           ' id_dep_clin_serv:' || l_configs_ctx.soap_blocks(i).id_dep_clin_serv || ' rank:' || l_configs_ctx.soap_blocks(i).rank ||
                           ' flg_execute_import:' || l_configs_ctx.soap_blocks(i).flg_execute_import ||
                           ' flg_show_title:' || l_configs_ctx.soap_blocks(i).flg_show_title;
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        IF l_configs_ctx.data_blocks.exists(1)
        THEN
            pk_alertlog.log_info(text            => 'l_configs_ctx.data_blocks',
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
            FOR i IN 1 .. l_configs_ctx.data_blocks.count
            LOOP
                g_error := 'id_pn_soap_block:' || l_configs_ctx.data_blocks(i).id_pn_soap_block || ' id_pn_data_block:' || l_configs_ctx.data_blocks(i).id_pn_data_block ||
                           ' flg_type:' || l_configs_ctx.data_blocks(i).flg_type || ' data_area:' || l_configs_ctx.data_blocks(i).data_area ||
                           ' id_doc_area:' || l_configs_ctx.data_blocks(i).id_doc_area || ' code_pn_data_block:' || l_configs_ctx.data_blocks(i).code_pn_data_block ||
                           ' id_department:' || l_configs_ctx.data_blocks(i).id_department || ' id_dep_clin_serv:' || l_configs_ctx.data_blocks(i).id_dep_clin_serv ||
                           ' flg_import:' || l_configs_ctx.data_blocks(i).flg_import || ' flg_select:' || l_configs_ctx.data_blocks(i).flg_select ||
                           ' flg_scope:' || l_configs_ctx.data_blocks(i).flg_scope || ' dblock_count:' || l_configs_ctx.data_blocks(i).dblock_count ||
                           ' flg_actions_available:' || l_configs_ctx.data_blocks(i).flg_actions_available ||
                           ' id_swf_file_viewer:' || l_configs_ctx.data_blocks(i).id_swf_file_viewer ||
                           ' flg_line_on_boxes:' || l_configs_ctx.data_blocks(i).flg_line_on_boxes || ' gender:' || l_configs_ctx.data_blocks(i).gender ||
                           ' age_min:' || l_configs_ctx.data_blocks(i).age_min || ' age_max:' || l_configs_ctx.data_blocks(i).age_max ||
                           ' flg_pregnant:' || l_configs_ctx.data_blocks(i).flg_pregnant || ' flg_outside_period:' || l_configs_ctx.data_blocks(i).flg_outside_period ||
                           ' days_available_period:' || l_configs_ctx.data_blocks(i).days_available_period ||
                           ' flg_mandatory:' || l_configs_ctx.data_blocks(i).flg_mandatory ||
                           ' flg_cp_no_changes_import:' || l_configs_ctx.data_blocks(i).flg_cp_no_changes_import ||
                           ' flg_import_date:' || l_configs_ctx.data_blocks(i).flg_import_date ||
                           ' id_sys_button_viewer:' || l_configs_ctx.data_blocks(i).id_sys_button_viewer ||
                           ' flg_group_on_import:' || l_configs_ctx.data_blocks(i).flg_group_on_import || ' rank:' || l_configs_ctx.data_blocks(i).rank ||
                           ' flg_wf_viewer:' || l_configs_ctx.data_blocks(i).flg_wf_viewer || ' id_pndb_parent:' || l_configs_ctx.data_blocks(i).id_pndb_parent ||
                           ' flg_struct_type:' || l_configs_ctx.data_blocks(i).flg_struct_type || ' flg_show_title:' || l_configs_ctx.data_blocks(i).flg_show_title ||
                           ' flg_show_sub_title:' || l_configs_ctx.data_blocks(i).flg_show_sub_title ||
                           ' flg_data_removable:' || l_configs_ctx.data_blocks(i).flg_data_removable ||
                           ' auto_pop_exec_prof_cat:' || l_configs_ctx.data_blocks(i).auto_pop_exec_prof_cat ||
                           ' id_summary_page:' || l_configs_ctx.data_blocks(i).id_summary_page || ' flg_focus:' || l_configs_ctx.data_blocks(i).flg_focus ||
                           ' flg_editable:' || l_configs_ctx.data_blocks(i).flg_editable || ' FLG_GROUP_SELECT_FILTER:' || l_configs_ctx.data_blocks(i).flg_group_select_filter ||
                           ' id_task_type_ftxt:' || l_configs_ctx.data_blocks(i).id_task_type_ftxt;
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        IF l_configs_ctx.buttons.exists(1)
        THEN
            pk_alertlog.log_info(text            => 'l_configs_ctx.buttons',
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
            FOR i IN 1 .. l_configs_ctx.buttons.count
            LOOP
                g_error := 'id_pn_soap_block:' || l_configs_ctx.buttons(i).id_pn_soap_block || ' id_conf_button_block:' || l_configs_ctx.buttons(i).id_conf_button_block ||
                           ' id_doc_area:' || l_configs_ctx.buttons(i).id_doc_area || ' id_pn_task_type:' || l_configs_ctx.buttons(i).id_pn_task_type ||
                           ' action:' || l_configs_ctx.buttons(i).action || ' id_parent:' || l_configs_ctx.buttons(i).id_parent ||
                           ' icon:' || l_configs_ctx.buttons(i).icon || ' flg_visible:' || l_configs_ctx.buttons(i).flg_visible ||
                           ' id_type:' || l_configs_ctx.buttons(i).id_type || ' rank:' || l_configs_ctx.buttons(i).rank ||
                           ' flg_activation:' || l_configs_ctx.buttons(i).flg_activation;
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        IF l_configs_ctx.task_types.exists(1)
        THEN
            pk_alertlog.log_info(text            => 'l_configs_ctx.task_types',
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
            FOR i IN 1 .. l_configs_ctx.task_types.count
            LOOP
                g_error := 'id_pn_data_block:' || l_configs_ctx.task_types(i).id_pn_data_block || ' id_pn_soap_block:' || l_configs_ctx.task_types(i).id_pn_soap_block ||
                           ' id_pn_note_type:' || l_configs_ctx.task_types(i).id_pn_note_type || ' id_task_type:' || l_configs_ctx.task_types(i).id_task_type ||
                           ' id_department:' || l_configs_ctx.task_types(i).id_department || ' id_dep_clin_serv:' || l_configs_ctx.task_types(i).id_dep_clin_serv ||
                           ' flg_auto_populated:' || l_configs_ctx.task_types(i).flg_auto_populated ||
                           ' task_type_id_parent:' || l_configs_ctx.task_types(i).task_type_id_parent ||
                           ' flg_synch_area:' || l_configs_ctx.task_types(i).flg_synch_area || ' review_context:' || l_configs_ctx.task_types(i).review_context ||
                           ' flg_selected:' || l_configs_ctx.task_types(i).flg_selected || ' flg_import_filter:' || l_configs_ctx.task_types(i).flg_import_filter ||
                           ' flg_ea:' || l_configs_ctx.task_types(i).flg_ea || ' last_n_records_nr:' || l_configs_ctx.task_types(i).last_n_records_nr ||
                           ' flg_shortcut_filter:' || l_configs_ctx.task_types(i).flg_shortcut_filter ||
                           ' flg_synchronized:' || l_configs_ctx.task_types(i).flg_synchronized || ' review_cat:' || l_configs_ctx.task_types(i).review_cat ||
                           ' flg_review_avail:' || l_configs_ctx.task_types(i).flg_review_avail;
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        pk_alertlog.log_info(text            => 'l_configs_ctx.note_type',
                             object_name     => g_package,
                             sub_object_name => l_func_name);
        g_error := 'id_pn_area:' || l_configs_ctx.note_type.id_pn_area || ' id_pn_note_type:' ||
                   l_configs_ctx.note_type.id_pn_note_type || ' rank:' || l_configs_ctx.note_type.rank ||
                   ' max_nr_notes:' || l_configs_ctx.note_type.max_nr_notes || ' max_nr_draft_notes:' ||
                   l_configs_ctx.note_type.max_nr_draft_notes || ' max_nr_draft_addendums:' ||
                   l_configs_ctx.note_type.max_nr_draft_addendums || ' flg_addend_other_prof:' ||
                   l_configs_ctx.note_type.flg_addend_other_prof || ' flg_show_empty_blocks:' ||
                   l_configs_ctx.note_type.flg_show_empty_blocks || ' flg_import_available:' ||
                   l_configs_ctx.note_type.flg_import_available || ' flg_sign_off_login_avail:' ||
                   l_configs_ctx.note_type.flg_sign_off_login_avail || ' flg_last_24h:' ||
                   l_configs_ctx.note_type.flg_last_24h || ' flg_dictation_editable:' ||
                   l_configs_ctx.note_type.flg_dictation_editable || ' flg_clear_information:' ||
                   l_configs_ctx.note_type.flg_clear_information || ' flg_review_all:' ||
                   l_configs_ctx.note_type.flg_review_all || ' flg_edit_after_disch:' ||
                   l_configs_ctx.note_type.flg_edit_after_disch || ' flg_import_first:' ||
                   l_configs_ctx.note_type.flg_import_first || ' flg_write:' || l_configs_ctx.note_type.flg_write ||
                   ' flg_copy_edit_replace:' || l_configs_ctx.note_type.flg_copy_edit_replace || ' gender:' ||
                   l_configs_ctx.note_type.gender || ' age_min:' || l_configs_ctx.note_type.age_min || ' age_max:' ||
                   l_configs_ctx.note_type.age_max || ' flg_expand_sblocks:' ||
                   l_configs_ctx.note_type.flg_expand_sblocks || ' flg_synchronized:' ||
                   l_configs_ctx.note_type.flg_synchronized || ' flg_show_import_menu:' ||
                   l_configs_ctx.note_type.flg_show_import_menu || ' flg_edit_other_prof:' ||
                   l_configs_ctx.note_type.flg_edit_other_prof || ' flg_create_on_app:' ||
                   l_configs_ctx.note_type.flg_create_on_app || ' flg_autopop_warning:' ||
                   l_configs_ctx.note_type.flg_autopop_warning || ' flg_discharge_warning:' ||
                   l_configs_ctx.note_type.flg_discharge_warning || ' flg_disch_warning_option:' ||
                   l_configs_ctx.note_type.flg_disch_warning_option || ' flg_review_warning:' ||
                   l_configs_ctx.note_type.flg_review_warning || ' flg_review_warn_option:' ||
                   l_configs_ctx.note_type.flg_review_warn_option || ' flg_import_warning:' ||
                   l_configs_ctx.note_type.flg_import_warning || ' flg_help_save:' ||
                   l_configs_ctx.note_type.flg_help_save || ' flg_edit_only_last:' ||
                   l_configs_ctx.note_type.flg_edit_only_last || ' flg_save_only_screen:' ||
                   l_configs_ctx.note_type.flg_save_only_screen || ' flg_status_available:' ||
                   l_configs_ctx.note_type.flg_status_available || ' flg_partial_warning:' ||
                   l_configs_ctx.note_type.flg_partial_warning || ' flg_remove_on_ok:' ||
                   l_configs_ctx.note_type.flg_remove_on_ok || ' editable_nr_min:' ||
                   l_configs_ctx.note_type.editable_nr_min || ' flg_suggest_concept:' ||
                   l_configs_ctx.note_type.flg_suggest_concept || ' flg_review_on_ok:' ||
                   l_configs_ctx.note_type.flg_review_on_ok || ' flg_partial_load:' ||
                   l_configs_ctx.note_type.flg_partial_load || ' flg_viewer_type:' ||
                   l_configs_ctx.note_type.flg_viewer_type || ' flg_sign_off:' || l_configs_ctx.note_type.flg_sign_off;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        RETURN l_configs_ctx;
    
    END reset_configs_ctx;

    /**
    * Returns the notes header info.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note ID
    * @param o_data                   notes header data
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   04-02-2011
    */

    FUNCTION get_note_general_data
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_epis_pn         IN epis_pn.id_epis_pn%TYPE,
        i_flg_show_signature IN pn_note_type_mkt.flg_show_signature%TYPE DEFAULT pk_alert_constant.g_yes,
        o_data               OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(21 CHAR) := 'GET_NOTE_GENERAL_DATA';
    
    BEGIN
    
        g_error := 'GET HEADER';
        pk_alertlog.log_debug(g_error);
        OPEN o_data FOR
            SELECT epn.id_epis_pn id_epis_pn,
                   decode(i_flg_show_signature,
                          pk_alert_constant.g_yes,
                          pk_prog_notes_utils.get_signature(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_id_episode          => epn.id_episode,
                                                            i_id_prof_create      => epn.id_prof_create,
                                                            i_dt_create           => epn.dt_create,
                                                            i_id_prof_last_update => epn.id_prof_last_update,
                                                            i_dt_last_update      => epn.dt_last_update,
                                                            i_id_prof_sign_off    => epn.id_prof_signoff,
                                                            i_dt_sign_off         => epn.dt_signoff,
                                                            i_id_prof_cancel      => epn.id_prof_cancel,
                                                            i_dt_cancel           => epn.dt_cancel,
                                                            i_id_dictation_report => epn.id_dictation_report,
                                                            --the single pages summaries do not have addendums
                                                            i_flg_history => pk_alert_constant.g_no,
                                                            i_id_software => epn.id_software),
                          NULL) prof_signature
              FROM epis_pn epn
             WHERE epn.id_epis_pn = i_id_epis_pn;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_data);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_note_general_data;

    /**
    * Returns the notes to the summary grid.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_epis_pn             Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_id_pn_soap_block       Soap block id
    * @param o_data                   notes data
    * @param o_notes_texts            Texts that compose the note            
    * @param o_text_comments          Comments cursor
    * @param o_configs                Dynamic configs: flg_import_available; flg_editable                                 
    * @param o_data_blocks            Dynamic data blocks (date data blocks)
    * @param o_buttons                Dynamic buttons (template records)
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   04-02-2011
    */

    FUNCTION get_notes_core
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_id_epis_pn_det_task IN table_number,
        i_id_pn_soap_block    IN table_number,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_data                OUT NOCOPY pk_types.cursor_type,
        o_text_blocks         OUT NOCOPY pk_types.cursor_type,
        o_text_comments       OUT NOCOPY pk_types.cursor_type,
        o_suggested           OUT NOCOPY pk_types.cursor_type,
        o_configs             OUT NOCOPY pk_types.cursor_type,
        o_data_blocks         OUT NOCOPY pk_types.cursor_type,
        o_buttons             OUT NOCOPY pk_types.cursor_type,
        o_cancelled           OUT NOCOPY pk_types.cursor_type,
        o_doc_reg             OUT NOCOPY pk_types.cursor_type,
        o_doc_val             OUT NOCOPY pk_types.cursor_type,
        o_template_layouts    OUT NOCOPY pk_types.cursor_type,
        o_doc_area_component  OUT NOCOPY pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        work_block_txt EXCEPTION;
    
        l_id_epis_pn epis_pn.id_epis_pn%TYPE := i_id_epis_pn;
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'GET_NOTES_CORE';
    
        l_configs_ctx    pk_prog_notes_types.t_configs_ctx;
        l_dt_last_update TIMESTAMP WITH LOCAL TIME ZONE;
        l_id_patient     patient.id_patient%TYPE;
        l_flg_editable   pn_dblock_mkt.flg_editable%TYPE;
        --l_start       NUMBER DEFAULT dbms_utility.get_time;
        l_epis_doc         table_number := table_number();
        l_id_pn_soap_block table_number := table_number();
        l_pn_note_tcl      table_clob;
        l_pn_note          epis_pn_det.pn_note%TYPE;
        l_epis_doc_aux     table_number := table_number();
        l_dt_proposed      TIMESTAMP WITH LOCAL TIME ZONE;
        l_only_autopop     VARCHAR2(1);
    BEGIN
        g_error := 'CALL pk_episode.get_epis_patient. i_id_episode: ' || i_id_episode;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_id_patient := pk_episode.get_epis_patient(i_lang => i_lang, i_prof => i_prof, i_episode => i_id_episode);
        --l_start := dbms_utility.get_time;
    
        IF pk_prog_notes_utils.check_epis_pn(i_id_epis_pn => l_id_epis_pn) = pk_alert_constant.g_yes
        THEN
            l_id_epis_pn := i_id_epis_pn;
        ELSE
            l_id_epis_pn := NULL;
        END IF;
    
        IF l_id_epis_pn IS NULL
        THEN
            l_only_autopop := pk_prog_notes_constants.g_yes;
        ELSE
            l_only_autopop := pk_prog_notes_constants.g_no;
        END IF;
    
        g_error := 'CALL reset_configs_ctx. i_id_episode: ' || i_id_episode || ' i_id_pn_note_type: ' ||
                   i_id_pn_note_type || ' l_id_epis_pn: ' || l_id_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_episode         => i_id_episode,
                                           i_id_pn_note_type => i_id_pn_note_type,
                                           i_epis_pn         => l_id_epis_pn);
    
        IF (l_id_epis_pn IS NULL AND l_configs_ctx.note_type.flg_synchronized = pk_alert_constant.g_yes)
        THEN
            --autodiscover the note ID
            --The single pages like current visit will only have one note
            --every time the deepnav is accessed it is required to check if there a note already created
            g_error := 'CALL pk_prog_notes_utils.get_note_id. i_id_episode: ' || i_id_episode || ' i_id_pn_note_type: ' ||
                       i_id_pn_note_type;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_note_id(i_lang            => i_lang,
                                                   i_prof            => i_prof,
                                                   i_id_episode      => i_id_episode,
                                                   i_id_pn_note_type => i_id_pn_note_type,
                                                   o_id_epis_pn      => l_id_epis_pn,
                                                   o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        g_error := 'CALL GET_NOTES_CORE_INT';
        pk_alertlog.log_debug(g_error);
        IF NOT get_notes_core_int(i_lang                => i_lang,
                                  i_prof                => i_prof,
                                  i_id_episode          => i_id_episode,
                                  i_id_patient          => l_id_patient,
                                  i_id_pn_note_type     => i_id_pn_note_type,
                                  i_flg_search_dblock   => pk_prog_notes_constants.g_auto_pop_dblocks_a,
                                  i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                  i_id_pn_soap_block    => i_id_pn_soap_block,
                                  i_dt_proposed         => i_dt_proposed,
                                  io_id_epis_pn         => l_id_epis_pn,
                                  i_configs_ctx         => l_configs_ctx,
                                  i_flg_update_dt       => pk_alert_constant.g_no,
                                  i_only_autopop        => l_only_autopop,
                                  o_dt_last_update      => l_dt_last_update,
                                  o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL get_note_general_data';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_note_general_data(i_lang               => i_lang,
                                     i_prof               => i_prof,
                                     i_id_epis_pn         => l_id_epis_pn,
                                     i_flg_show_signature => l_configs_ctx.note_type.flg_show_signature,
                                     o_data               => o_data,
                                     o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL pk_prog_notes_utils.get_dynamic_note_type_cfgs';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_prog_notes_utils.get_dynamic_note_type_cfgs(i_lang                 => i_lang,
                                                              i_prof                 => i_prof,
                                                              i_id_episode           => i_id_episode,
                                                              i_id_epis_pn           => l_id_epis_pn,
                                                              i_id_pn_note_type      => i_id_pn_note_type,
                                                              i_flg_import_available => l_configs_ctx.note_type.flg_import_available,
                                                              i_editable_nr_min      => l_configs_ctx.note_type.editable_nr_min,
                                                              i_flg_edit_after_disch => l_configs_ctx.note_type.flg_edit_after_disch,
                                                              i_flg_synchronized     => l_configs_ctx.note_type.flg_synchronized,
                                                              i_flg_edit_only_last   => l_configs_ctx.note_type.flg_edit_only_last,
                                                              o_flg_editable         => l_flg_editable,
                                                              o_configs              => o_configs,
                                                              o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL get_block_txt';
        pk_alertlog.log_debug(g_error);
        IF NOT get_block_txt(i_lang             => i_lang,
                             i_prof             => i_prof,
                             i_id_epis_pn       => l_id_epis_pn,
                             i_flg_editable     => l_flg_editable,
                             i_configs_ctx      => l_configs_ctx,
                             i_dt_last_update   => l_dt_last_update,
                             i_id_pn_soap_block => i_id_pn_soap_block,
                             o_text_blocks      => o_text_blocks,
                             o_error            => o_error)
        THEN
            RAISE work_block_txt;
        END IF;
    
        g_error := 'CALL get_comments';
        pk_alertlog.log_debug(g_error);
        IF NOT get_comments(i_lang             => i_lang,
                            i_prof             => i_prof,
                            i_id_epis_pn       => l_id_epis_pn,
                            i_flg_editable     => l_flg_editable,
                            i_configs_ctx      => l_configs_ctx,
                            i_id_pn_soap_block => i_id_pn_soap_block,
                            o_text_blocks      => o_text_comments,
                            o_error            => o_error)
        THEN
            RAISE work_block_txt;
        END IF;
    
        g_error := 'CALL GET_SUGGESTED_RECORDS';
        pk_alertlog.log_debug(g_error);
        IF NOT get_suggested_records(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_id_episode       => i_id_episode,
                                     i_id_epis_pn       => l_id_epis_pn,
                                     i_flg_editable     => l_flg_editable,
                                     i_configs_ctx      => l_configs_ctx,
                                     i_dt_last_update   => l_dt_last_update,
                                     i_id_pn_soap_block => i_id_pn_soap_block,
                                     o_suggested        => o_suggested,
                                     o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL pk_progress_notes_upd.get_dynamic_data_blocks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_dt_proposed := pk_prog_notes_utils.get_note_dt_proposed(i_lang       => i_lang,
                                                                  i_prof       => i_prof,
                                                                  i_id_episode => i_id_episode,
                                                                  i_id_epis_pn => i_id_epis_pn);
        IF l_dt_proposed IS NULL
        THEN
            l_dt_proposed := i_dt_proposed;
        END IF;
        g_error := 'get_notes_core l_dt_proposed:' || l_dt_proposed;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        g_error := 'CALL pk_progress_notes_upd.get_dynamic_data_blocks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        pk_progress_notes_upd.get_dynamic_data_blocks(i_lang        => i_lang,
                                                      i_prof        => i_prof,
                                                      i_episode     => i_id_episode,
                                                      i_data_blocks => l_configs_ctx.data_blocks,
                                                      i_task_types  => l_configs_ctx.task_types,
                                                      i_dt_purposed => l_dt_proposed,
                                                      o_data_blocks => o_data_blocks);
    
        g_error := 'CALL pk_progress_notes_upd.get_dynamic_buttons';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_progress_notes_upd.get_dynamic_buttons(i_lang          => i_lang,
                                                         i_prof          => i_prof,
                                                         i_patient       => l_id_patient,
                                                         i_episode       => i_id_episode,
                                                         i_id_market     => l_configs_ctx.id_market,
                                                         i_id_epis_pn    => l_id_epis_pn,
                                                         io_buttons      => l_configs_ctx.buttons,
                                                         o_button_blocks => o_buttons,
                                                         o_error         => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL pk_progress_notes_upd.get_dynamic_buttons';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_dblock_cancelled(i_lang             => i_lang,
                                    i_prof             => i_prof,
                                    i_id_epis_pn       => l_id_epis_pn,
                                    i_configs_ctx      => l_configs_ctx,
                                    i_id_pn_soap_block => i_id_pn_soap_block,
                                    o_cancelled        => o_cancelled,
                                    o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (i_id_pn_soap_block IS NULL OR NOT i_id_pn_soap_block.exists(1))
        THEN
            l_id_pn_soap_block := NULL;
        ELSE
            l_id_pn_soap_block := i_id_pn_soap_block;
        END IF;
    
        SELECT epdw.id_task
          BULK COLLECT
          INTO l_epis_doc
          FROM epis_pn_det epd
          JOIN epis_pn epn
            ON epn.id_epis_pn = epd.id_epis_pn
          JOIN TABLE(l_configs_ctx.data_blocks) db
            ON epd.id_pn_soap_block = db.id_pn_soap_block
           AND epd.id_pn_data_block = db.id_pn_data_block
          JOIN epis_pn_det_task epdw
            ON (epdw.id_epis_pn_det = epd.id_epis_pn_det AND db.flg_import = pk_prog_notes_constants.g_import_block AND
               epdw.flg_status IN
               (pk_prog_notes_constants.g_epis_pn_det_flg_status_a, pk_prog_notes_constants.g_epis_pn_flg_status_s))
           AND epdw.id_task_type IN (pk_prog_notes_constants.g_task_templates)
           AND pk_touch_option_out.has_layout(i_epis_documentation => epdw.id_task) = pk_alert_constant.g_yes
         WHERE epd.id_epis_pn = l_id_epis_pn
           AND (l_id_pn_soap_block IS NULL OR
               epd.id_pn_soap_block IN (SELECT /*+opt_estimate(table t rows=1)*/
                                          column_value
                                           FROM TABLE(l_id_pn_soap_block) t))
           AND epd.flg_status IN
               (pk_prog_notes_constants.g_epis_pn_det_flg_status_a, pk_prog_notes_constants.g_epis_pn_flg_status_s)
           AND epdw.id_parent IS NULL;
    
        -- martelada templates bilaterais gravados noutras SP   
        SELECT epd.pn_note
          BULK COLLECT
          INTO l_pn_note_tcl
          FROM epis_pn_det epd
         WHERE epd.id_epis_pn = l_id_epis_pn
           AND epd.flg_status IN
               (pk_prog_notes_constants.g_epis_pn_det_flg_status_a, pk_prog_notes_constants.g_epis_pn_flg_status_s)
           AND instr(epd.pn_note, '[B|ID_TASK:') > 0;
    
        FOR i IN 1 .. l_pn_note_tcl.count
        LOOP
            l_pn_note := l_pn_note || chr(13) || l_pn_note_tcl(i);
        END LOOP;
    
        l_epis_doc_aux := pk_prog_notes_utils.get_bl_epis_documentation_ids(l_pn_note);
    
        l_epis_doc := l_epis_doc MULTISET UNION DISTINCT l_epis_doc_aux;
        --
    
        --FOR i IN 1 .. l_epis_doc.count
        --LOOP
        --    pk_alertlog.log_info(text            => 'l_epis_doc(' || i || ')=' || l_epis_doc(i),
        --                         object_name     => g_package,
        --                        sub_object_name => l_func_name);
        --END LOOP;
    
        IF l_epis_doc.count > 0
        THEN
            IF NOT pk_touch_option.get_doc_area_value_internal(i_lang               => i_lang,
                                                               i_prof               => i_prof,
                                                               i_id_episode         => i_id_episode,
                                                               i_id_patient         => l_id_patient,
                                                               i_doc_area           => NULL,
                                                               i_epis_doc           => l_epis_doc,
                                                               i_epis_anamn         => table_number(),
                                                               i_epis_rev_sys       => table_number(),
                                                               i_epis_obs           => table_number(),
                                                               i_epis_past_fsh      => table_number(),
                                                               i_epis_recomend      => table_number(),
                                                               i_flg_show_fm        => pk_alert_constant.g_no,
                                                               o_doc_area_register  => o_doc_reg,
                                                               o_doc_area_val       => o_doc_val,
                                                               o_template_layouts   => o_template_layouts,
                                                               o_doc_area_component => o_doc_area_component,
                                                               o_error              => o_error)
            THEN
                RAISE g_exception;
            END IF;
        ELSE
            pk_types.open_my_cursor(i_cursor => o_doc_reg);
            pk_types.open_my_cursor(i_cursor => o_doc_val);
            pk_types.open_my_cursor(i_cursor => o_template_layouts);
            pk_types.open_my_cursor(i_cursor => o_doc_area_component);
        END IF;
    
        --dbms_output.put_line(dbms_utility.get_time - l_start);
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
            pk_types.open_my_cursor(i_cursor => o_data);
            pk_types.open_my_cursor(i_cursor => o_text_blocks);
            pk_types.open_my_cursor(i_cursor => o_suggested);
            pk_types.open_my_cursor(i_cursor => o_text_comments);
        
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_data);
            pk_types.open_my_cursor(i_cursor => o_text_blocks);
            pk_types.open_my_cursor(i_cursor => o_suggested);
            pk_types.open_my_cursor(i_cursor => o_text_comments);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_notes_core;

    /**
    * sincronize note records. When a record is created througth the help save. It is necessary to syncronize the record
    * to synch it (the data block can be configured to be not synch).
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_epis_pn             Note identifier
    * @param i_id_pn_note_type        Note type id. 3-Progress Note; 4-Prolonged Progress Note; 5-Intensive Care Note; 2-History and Physician Note
    * @param i_id_epis_pn_det_task    Task Ids that have to be syncronized
    * @param i_id_pn_soap_block       Soap block id    
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author  Sofia Mendes
    * @version 2.6.0.5
    * @since   04-02-2011
    */

    FUNCTION set_note_synch
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_id_epis_pn_det_task IN table_number,
        i_id_pn_soap_block    IN table_number,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        work_block_txt EXCEPTION;
    
        l_id_epis_pn epis_pn.id_epis_pn%TYPE := i_id_epis_pn;
        l_func_name CONSTANT VARCHAR2(20 CHAR) := 'SET_NOTE_SYNCH';
    
        l_configs_ctx    pk_prog_notes_types.t_configs_ctx;
        l_dt_last_update TIMESTAMP WITH LOCAL TIME ZONE;
        l_id_patient     patient.id_patient%TYPE;
        --l_start       NUMBER DEFAULT dbms_utility.get_time;
    BEGIN
        l_id_patient := pk_episode.get_epis_patient(i_lang => i_lang, i_prof => i_prof, i_episode => i_id_episode);
        --l_start := dbms_utility.get_time;
    
        g_error := 'CALL reset_configs_ctx';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_episode         => i_id_episode,
                                           i_id_pn_note_type => i_id_pn_note_type,
                                           i_epis_pn         => l_id_epis_pn);
    
        IF (l_id_epis_pn IS NULL AND l_configs_ctx.note_type.flg_synchronized = pk_alert_constant.g_yes)
        THEN
            --autodiscover the note ID
            --The single pages like current visit will only have one note
            --every time the deepnav is accessed it is required to check if there a note already created
            g_error := 'CALL pk_prog_notes_utils.get_note_id. i_id_episode: ' || i_id_episode || ' i_id_pn_note_type: ' ||
                       i_id_pn_note_type;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_note_id(i_lang            => i_lang,
                                                   i_prof            => i_prof,
                                                   i_id_episode      => i_id_episode,
                                                   i_id_pn_note_type => i_id_pn_note_type,
                                                   o_id_epis_pn      => l_id_epis_pn,
                                                   o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        g_error := 'CALL GET_NOTES_CORE_INT';
        pk_alertlog.log_debug(g_error);
        IF NOT get_notes_core_int(i_lang                => i_lang,
                                  i_prof                => i_prof,
                                  i_id_episode          => i_id_episode,
                                  i_id_patient          => l_id_patient,
                                  i_id_pn_note_type     => i_id_pn_note_type,
                                  i_flg_search_dblock   => pk_prog_notes_constants.g_auto_pop_dblocks_a,
                                  i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                  i_id_pn_soap_block    => i_id_pn_soap_block,
                                  io_id_epis_pn         => l_id_epis_pn,
                                  i_configs_ctx         => l_configs_ctx,
                                  i_only_autopop        => pk_prog_notes_constants.g_no,
                                  o_dt_last_update      => l_dt_last_update,
                                  o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --dbms_output.put_line(dbms_utility.get_time - l_start);
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
        
            RETURN FALSE;
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END set_note_synch;

    /**
    * Set the note header information
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_episode              Episode ID
    * @param   i_epis_pn              Progress note ID
    * @param   i_dt_pn_date           Progress Note date
    * @param   i_dep_clin_serv        Clinical Service ID
    * @param   i_id_pn_note_type      Progress Note type id (P-progress note; L-prolonged progress note; CC-intensive care note; H-history and physician note) 
    * @param   i_flg_synchronized   Y-single page. N-single note
    * @param   o_note_struct          Note info
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          21-Jun-2012
    */
    FUNCTION set_note_header
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_dep_clin_serv    IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_id_pn_note_type  IN epis_pn.id_pn_note_type%TYPE,
        i_id_pn_area       IN pn_area.id_pn_area%TYPE,
        i_flg_synchronized IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_dt_last_update   IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_definitive   IN VARCHAR2,
        i_dt_proposed      IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_note_struct      OUT pk_prog_notes_types.t_note_struct,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        e_error EXCEPTION;
    
        l_func_name CONSTANT VARCHAR2(19 CHAR) := 'SET_NOTE_HEADER';
        l_id_epis_pn epis_pn.id_epis_pn%TYPE := i_epis_pn;
    
    BEGIN
    
        --if i_epis_pn is null, then create a new note
    
        g_error := 'CALL get_epis_pn_struct';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_epis_pn_struct(i_lang             => i_lang,
                                  i_prof             => i_prof,
                                  i_id_episode       => i_episode,
                                  i_dt_pn_date       => i_dt_last_update,
                                  i_id_dep_clin_serv => i_dep_clin_serv,
                                  i_id_pn_note_type  => i_id_pn_note_type,
                                  i_id_pn_area       => i_id_pn_area,
                                  i_flg_synchronized => i_flg_synchronized,
                                  i_flg_definitive   => i_flg_definitive,
                                  i_dt_proposed      => i_dt_proposed,
                                  io_id_epis_pn      => l_id_epis_pn,
                                  io_note_struct     => o_note_struct,
                                  o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN e_error THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_note_header;

    /**
    * Update one data block's content. If the data doesn't exists yet, the record will be created.
    * the IN parameter Type allow for select if append or update should be done to the text.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_episode              Episode ID
    * @param   i_id_patient           Patient Identifier
    * @param   i_id_visit             Visit Identifier
    * @param   i_epis_pn              Progress note ID
    * @param   i_dt_pn_date           Progress Note date
    * @param   i_flg_action           C-Create; U-update; I-import
    * @param   i_date_type            DH- Date hour; D-Date
    * @param   i_pn_soap_block        SOAP Block ID
    * @param   i_pn_data_block        Data Block ID
    * @param   i_id_task              Task ID
    * @param   i_dep_clin_serv        Clinical Service ID
    * @param   i_epis_pn_det          Progress note detail ID
    * @param   i_pn_note              Progress note detail text 
    * @param   i_flg_add_remove       Add or remove block from note. A R-Removed block is like a canceled one.
    * @param   i_id_pn_note_type      Progress Note type id (P-progress note; L-prolonged progress note; CC-intensive care note; H-history and physician note) 
    * @param   i_flg_app_upd          Type of operation: A-Append, U-Update
    * @param   i_epis_pn_det_task     Array of PN task details
    * @param   i_pn_note_task         Array of PN task descriptions
    * @param   i_flg_add_rem_task     Array of task status (A- Active, R- Removed)
    * @param   i_flg_table_origin     Flag origin table for documentation ( D - documentation, A - Anamnesis, S - Review of system)
    * @param   i_id_task_aggregator   For analysis and exam recurrences, an imported registry will only be uniquely 
    *                                 identified by id_task (id_analysis/id_exam) + i_id_task_aggregator
    * @param   i_flg_synchronized     Data Block info if is to be synchronized with the directed areas, other than templates
    * @param   i_dt_task              Task dates
    * @param   i_id_task_parent       Parent task identifier for comments functionality
    * @param   i_flg_task_parent      Flag tells where i_id_task_parent is a taskid or id_epis_pn_det_task
    * @param   i_id_multichoice       Array of tasks identifiers for cases that have more than one parameter (multichoice on exam results)
    * @param   i_rank_task            Rank of the tasks
    * @param   i_prof_task            Professional that created the tasks
    * @param   i_dblock_cfgs          Data block configs record
    * @param   i_id_group_table       Id Group (vital sign id): vital signs table row id
    *
    * @param   io_id_task_type        Task type Identifiers
    *
    * @param   o_id_epis_pn           ID of the PN created
    * @param   o_flg_reload           Tells UX layer it It's needed the reload screen or not
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @value   i_flg_task_parent      {*} 'Y'- Passed in i_id_task_parent the id_epis_pn_det_task {*} 'N'- Passed in i_id_task_parent the taskid
    *
    * @author                         RUI.BATISTA
    * @version                        <2.6.0.5>
    * @since                          04-02-2011
    */
    FUNCTION set_data_block
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_episode            IN episode.id_episode%TYPE,
        i_patient            IN patient.id_patient%TYPE DEFAULT NULL,
        i_epis_pn            IN epis_pn.id_epis_pn%TYPE,
        i_dt_pn_date         IN VARCHAR2,
        i_flg_action         IN VARCHAR2,
        i_date_type          IN VARCHAR2,
        i_pn_soap_block      IN pn_soap_block.id_pn_soap_block%TYPE,
        i_pn_data_block      IN pn_data_block.id_pn_data_block%TYPE,
        i_id_task            IN table_number,
        i_epis_pn_det        IN epis_pn_det.id_epis_pn_det%TYPE,
        i_pn_note            IN epis_pn_det.pn_note%TYPE,
        i_flg_status         IN epis_pn_det.flg_status%TYPE,
        i_flg_app_upd        IN VARCHAR2,
        i_epis_pn_det_task   IN table_number,
        i_pn_note_task       IN table_clob,
        i_flg_add_rem_task   IN table_varchar,
        i_flg_table_origin   IN table_varchar DEFAULT NULL,
        i_id_task_aggregator IN table_number,
        i_dt_task            IN table_varchar,
        i_id_task_parent     IN table_number,
        i_flg_task_parent    IN VARCHAR2 DEFAULT 'N',
        i_id_multichoice     IN table_number,
        i_rank_task          IN table_number,
        i_prof_task          IN table_number,
        i_prof_cat_type      IN category.flg_type%TYPE,
        i_dblock_cfgs        IN t_rec_dblock,
        i_dblock_task_type   IN t_coll_dblock_task_type DEFAULT NULL,
        i_id_group_table     IN table_number,
        i_flg_related        IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        io_note_struct       IN OUT pk_prog_notes_types.t_note_struct,
        io_id_task_type      IN OUT table_number,
        io_timezone          IN OUT VARCHAR2,
        o_id_epis_pn         OUT epis_pn.id_epis_pn%TYPE,
        o_flg_reload         OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        e_error EXCEPTION;
        l_dt_pn_date TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_exists BOOLEAN;
        l_func_name CONSTANT VARCHAR2(19 CHAR) := 'SET_DATA_BLOCK';
    
        l_id_task        table_number := i_id_task;
        l_id_task_parent table_number := i_id_task_parent;
    
        l_tbl_tasks  pk_prog_notes_types.t_table_tasks;
        l_pn_note    epis_pn_det.pn_note%TYPE := i_pn_note;
        l_flg_status epis_pn_det.flg_status%TYPE;
    
        l_epis_pn_det epis_pn_det.id_epis_pn_det%TYPE := i_epis_pn_det;
        l_flg_action  epis_pn_det_task.flg_action%TYPE := i_flg_action;
    
        -- l_flg_type     pn_data_block.flg_type%TYPE;
    BEGIN
    
        o_id_epis_pn := i_epis_pn;
    
        -- Convert start date to timestamp
        g_error := 'CALL GET_STRING_TSTZ FOR i_dt_pn_date';
        pk_alertlog.log_debug(g_error);
        IF i_dt_pn_date IS NOT NULL
        THEN
            IF (io_timezone IS NULL)
            THEN
                g_error := 'CALL pk_date_utils.get_timezone';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_date_utils.get_timezone(i_lang     => i_lang,
                                                  i_prof     => i_prof,
                                                  i_timezone => io_timezone,
                                                  o_timezone => io_timezone,
                                                  o_error    => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            g_error := 'pk_date_utils.get_string_tstz. i_dt_pn_date: ' || i_dt_pn_date || ' i_timezone: ' ||
                       io_timezone;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                 i_prof      => i_prof,
                                                 i_timestamp => i_dt_pn_date,
                                                 i_timezone  => io_timezone,
                                                 o_timestamp => l_dt_pn_date,
                                                 o_error     => o_error)
            THEN
                RAISE e_error;
            END IF;
        END IF;
    
        --Eliminate a record when the user erases a text
        --If block text is empty and there is no template block filled then 
        -- remove the data block from the Progress Note
        IF i_pn_note IS NULL
           AND (l_id_task.count = 0 OR l_id_task IS NULL)
        THEN
            l_exists := FALSE;
            FOR i IN 1 .. i_pn_note_task.count
            LOOP
                IF i_pn_note_task(i) IS NOT NULL
                THEN
                    l_exists := TRUE;
                END IF;
            END LOOP;
        
            IF NOT l_exists
            THEN
                l_flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_r;
            ELSE
                l_flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
            END IF;
        ELSE
            l_flg_status := i_flg_status;
        END IF;
    
        g_error := 'CALL get_epis_pn_det_struct';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_epis_pn_det_struct(i_lang    => i_lang,
                                      i_prof    => i_prof,
                                      i_epis_pn => nvl(i_epis_pn, io_note_struct.id_epis_pn),
                                      
                                      i_soap_block         => i_pn_soap_block,
                                      i_data_block         => i_pn_data_block,
                                      i_flg_status         => l_flg_status,
                                      i_pn_note            => l_pn_note,
                                      i_dt_pn_note         => l_dt_pn_date,
                                      i_flg_type           => i_dblock_cfgs.flg_type,
                                      i_flg_app_upd        => i_flg_app_upd,
                                      i_flg_aggregate_data => i_dblock_cfgs.flg_group_on_import,
                                      i_flg_scope          => i_dblock_cfgs.flg_scope,
                                      i_flg_group_type     => i_dblock_cfgs.flg_group_type,
                                      io_epis_pn_det       => l_epis_pn_det,
                                      io_note_struct       => io_note_struct,
                                      o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --Create or edit the detail related to tasks
        g_error := 'Edit new data block task detail';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT set_data_block_task( --
                              i_lang               => i_lang,
                              i_prof               => i_prof,
                              i_id_episode         => i_episode,
                              i_flg_action         => l_flg_action,
                              i_prof_cat_type      => i_prof_cat_type,
                              i_epis_pn_det        => l_epis_pn_det,
                              i_id_task            => l_id_task,
                              i_id_task_aggregator => i_id_task_aggregator,
                              io_id_task_type      => io_id_task_type,
                              i_epis_pn_det_task   => i_epis_pn_det_task,
                              i_pn_note_task       => CASE
                                                          WHEN i_pn_note_task.exists(1) THEN
                                                           i_pn_note_task
                                                          ELSE
                                                           NULL
                                                      END,
                              i_flg_add_rem_task   => i_flg_add_rem_task,
                              i_flg_table_origin   => i_flg_table_origin,
                              i_dt_task            => i_dt_task,
                              i_id_task_parent     => l_id_task_parent,
                              i_flg_task_parent    => i_flg_task_parent,
                              i_id_multichoice     => i_id_multichoice,
                              i_rank_task          => i_rank_task,
                              i_prof_task          => i_prof_task,
                              i_id_group_table     => i_id_group_table,
                              i_dblock_cfgs        => i_dblock_cfgs,
                              i_dblock_task_type   => i_dblock_task_type,
                              i_id_patient         => i_patient,
                              i_dt_pn_date         => i_dt_pn_date,
                              i_date_type          => i_date_type,
                              i_dblock_type        => i_dblock_cfgs.flg_type,
                              i_flg_related        => i_flg_related,
                              i_flg_group_type     => i_dblock_cfgs.flg_group_type,
                              o_tbl_tasks          => l_tbl_tasks,
                              o_flg_reload         => o_flg_reload,
                              o_error              => o_error)
        THEN
            RAISE e_error;
        END IF;
    
        IF (io_note_struct.tbl_dblock_det.exists(l_epis_pn_det))
        THEN
            g_error := 'CALL pk_prog_notes_utils.append_tables_tasks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.append_tables_tasks(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_table_to_append => l_tbl_tasks,
                                                           io_total_table    => io_note_struct.tbl_dblock_det(l_epis_pn_det).tbl_tasks,
                                                           o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        ELSE
            g_error := 'Assign tbl tasks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            io_note_struct.tbl_dblock_det(l_epis_pn_det).tbl_tasks := l_tbl_tasks;
        END IF;
    
        o_id_epis_pn := io_note_struct.tbl_dblock_det(l_epis_pn_det).id_epis_pn;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN e_error THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_data_block;

    /**
    * Create a copy of an existing template.
    *
    * @param   i_lang             Professional preferred language
    * @param   i_prof             Professional identification and its context (institution and software)
    * @param   i_episode          Episode ID
    * @param   i_prof_cat_type    Professional category type    
    * @param   i_id_task          Array of task IDs
    *
    * @param   o_epis_documentation         The epis_documentation ID created
    * @param   o_id_epis_scales_score       The epis_scales_score ID created
    * @param   o_error                      Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    *
    * @author  Sofia Mendes
    * @version 2.6.1.3
    * @since   27-09-2011
    */
    FUNCTION set_copy_template
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_episode            IN episode.id_episode%TYPE,
        i_prof_cat_type         IN category.flg_type%TYPE,
        i_id_task               IN epis_pn_det_task.id_task%TYPE,
        o_id_epis_documentation OUT epis_documentation.id_epis_documentation%TYPE,
        o_id_epis_scales_score  OUT table_number,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name    VARCHAR2(17 CHAR) := 'SET_COPY_TEMPLATE';
        l_doc_area     doc_area.id_doc_area%TYPE;
        l_doc_template doc_template.id_doc_template%TYPE;
    BEGIN
        g_error := 'Get doc_area. id_epis_documentation: ' || i_id_task;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT ed.id_doc_area, ed.id_doc_template
          INTO l_doc_area, l_doc_template
          FROM epis_documentation ed
         WHERE ed.id_epis_documentation = i_id_task;
    
        IF (l_doc_area = pk_prog_notes_constants.g_barthel_index)
        THEN
            g_error := 'CALL pk_wtl_api_ui.set_wtl_epis_documentation. l_doc_area: ' || l_doc_area ||
                       ' l_doc_template: ' || l_doc_template;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_wtl_api_ui.set_wtl_epis_documentation(i_lang                  => i_lang,
                                                            i_prof                  => i_prof,
                                                            i_prof_cat_type         => i_prof_cat_type,
                                                            i_epis                  => i_id_episode,
                                                            i_doc_area              => l_doc_area,
                                                            i_doc_template          => l_doc_template,
                                                            i_epis_documentation    => i_id_task, --7
                                                            i_flg_type              => pk_touch_option.g_flg_edition_type_nochanges,
                                                            i_id_documentation      => table_number(),
                                                            i_id_doc_element        => table_number(),
                                                            i_id_doc_element_crit   => table_number(),
                                                            i_value                 => table_varchar(),
                                                            i_notes                 => NULL,
                                                            i_id_doc_element_qualif => table_table_number(),
                                                            i_epis_context          => NULL, --15
                                                            i_summary_and_notes     => NULL,
                                                            i_episode_context       => NULL,
                                                            i_flg_table_origin      => pk_touch_option.g_flg_tab_origin_epis_doc,
                                                            i_wtl_change            => pk_alert_constant.g_no, --???
                                                            i_notes_wtl             => NULL,
                                                            i_flags                 => NULL,
                                                            i_ids                   => NULL,
                                                            i_scores                => NULL,
                                                            i_id_scales_formulas    => NULL,
                                                            o_epis_documentation    => o_id_epis_documentation,
                                                            o_id_epis_scales_score  => o_id_epis_scales_score,
                                                            o_error                 => o_error)
            THEN
                RAISE g_exception;
            END IF;
        ELSE
        
            g_error := 'CALL pk_inp_nurse.set_epis_doc_scales. l_doc_area: ' || l_doc_area || ' l_doc_template: ' ||
                       l_doc_template;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_inp_nurse.set_epis_doc_scales(i_lang                  => i_lang,
                                                    i_prof                  => i_prof,
                                                    i_prof_cat_type         => i_prof_cat_type,
                                                    i_epis                  => i_id_episode,
                                                    i_doc_area              => l_doc_area,
                                                    i_doc_template          => l_doc_template,
                                                    i_epis_documentation    => i_id_task, --7
                                                    i_flg_type              => pk_touch_option.g_flg_edition_type_nochanges,
                                                    i_id_documentation      => table_number(),
                                                    i_id_doc_element        => table_number(),
                                                    i_id_doc_element_crit   => table_number(),
                                                    i_value                 => table_varchar(),
                                                    i_notes                 => NULL,
                                                    i_id_doc_element_qualif => table_table_number(),
                                                    i_epis_context          => NULL, --15
                                                    i_summary_and_notes     => NULL,
                                                    i_episode_context       => NULL,
                                                    i_flg_table_origin      => pk_touch_option.g_flg_tab_origin_epis_doc,
                                                    i_vs_element_list       => table_number(),
                                                    i_vs_save_mode_list     => table_varchar(),
                                                    i_vs_list               => table_number(),
                                                    i_vs_value_list         => table_number(),
                                                    i_vs_uom_list           => table_number(),
                                                    i_vs_scales_list        => table_number(),
                                                    i_vs_date_list          => table_varchar(),
                                                    i_vs_read_list          => table_number(), --
                                                    i_flags                 => NULL,
                                                    i_ids                   => NULL,
                                                    i_scores                => NULL,
                                                    i_id_scales_formulas    => NULL,
                                                    o_epis_documentation    => o_id_epis_documentation,
                                                    o_id_epis_scales_score  => o_id_epis_scales_score,
                                                    o_error                 => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        --copy the templates scores
        g_error := 'CALL pk_scales_core.set_copy_scores. i_id_epis_doc_old: ' || i_id_task || ' i_id_epis_doc_new: ' ||
                   o_id_epis_documentation;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_scales_core.set_copy_scores(i_lang                 => i_lang,
                                              i_prof                 => i_prof,
                                              i_id_episode           => i_id_episode,
                                              i_id_epis_doc_old      => i_id_task,
                                              i_id_epis_doc_new      => o_id_epis_documentation,
                                              o_id_epis_scales_score => o_id_epis_scales_score,
                                              o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_COPY_TEMPLATE',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_copy_template;

    /**
    * Updates the status of the epis_pn_det record
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_epis_pn_det          Progress note detail ID    
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_epis_pn_det_status
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        o_flg_status  OUT epis_pn_det.flg_status%TYPE,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_EPIS_PN_DET_STATUS';
    
        l_flg_status_lst     table_varchar;
        l_flg_status         epis_pn_det.flg_status%TYPE := NULL;
        l_flg_status_lst_cnt PLS_INTEGER;
    
    BEGIN
        g_error := 'GET TASKS status. i_epis_pn_det: ' || i_epis_pn_det;
        pk_alertlog.log_debug(g_error);
        SELECT DISTINCT epdt.flg_status
          BULK COLLECT
          INTO l_flg_status_lst
          FROM epis_pn_det_task epdt
         WHERE epdt.id_epis_pn_det = i_epis_pn_det;
    
        l_flg_status_lst_cnt := l_flg_status_lst.count;
    
        IF (l_flg_status_lst_cnt = 1)
        THEN
            l_flg_status := l_flg_status_lst(1);
        ELSIF (l_flg_status_lst_cnt > 0)
        THEN
            IF (pk_utils.search_table_varchar(i_table  => l_flg_status_lst,
                                              i_search => pk_prog_notes_constants.g_epis_pn_det_flg_status_a) > 0)
            THEN
                l_flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
            ELSIF (pk_utils.search_table_varchar(i_table  => l_flg_status_lst,
                                                 i_search => pk_prog_notes_constants.g_epis_pn_det_sug_add_s) > 0)
            THEN
                l_flg_status := pk_prog_notes_constants.g_epis_pn_det_sug_add_s;
            ELSE
                l_flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_r;
            END IF;
        END IF;
    
        o_flg_status := l_flg_status;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_epis_pn_det_status;

    /**
    * Insert and update a set of records in the epis_pn_det_task table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_tasks_insert_rows    Tasks structure to be inserted
    * @param   i_tasks_upd_rows       Tasks structure to be inserted    
    * @param   i_tasks_childs_work_rows    Tasks with the child records (has to be inserted after the parent records)
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION ins_upd_det_task
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_tasks_insert_rows IN ts_epis_pn_det_task.epis_pn_det_task_tc,
        i_tasks_upd_rows    IN ts_epis_pn_det_task.epis_pn_det_task_tc,
        i_tasks_childs_rows IN ts_epis_pn_det_task.epis_pn_det_task_tc,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'INS_UPD_DET_TASK';
        l_rowids table_varchar;
    
    BEGIN
    
        IF (i_tasks_insert_rows.count > 0)
        THEN
            --save the new records collection
            g_error := 'CALL ts_epis_pn_det_task.ins';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det_task.ins(rows_in => i_tasks_insert_rows, rows_out => l_rowids);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'TS_EPIS_PN_DET_TASK',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        IF (i_tasks_childs_rows.count > 0)
        THEN
            --save the new records collection
            g_error := 'CALL ts_epis_pn_det_task.ins';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det_task.ins(rows_in => i_tasks_childs_rows, rows_out => l_rowids);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'TS_EPIS_PN_DET_TASK',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        IF (i_tasks_upd_rows.count > 0)
        THEN
            g_error := 'CALL ts_epis_pn_det_task.upd';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det_task.upd(col_in => i_tasks_upd_rows, ignore_if_null_in => TRUE, rows_out => l_rowids);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'TS_EPIS_PN_DET_TASK',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END ins_upd_det_task;

    /**
    * Calculates the task of a det task considering the status of the detail record.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_pn_det_status        epis_pn_det status
    * @param   i_pn_det_task_status   epis_pn_det_task status
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_pn_det_task_status
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_pn_det_status      IN epis_pn_det.flg_status%TYPE,
        i_pn_det_task_status IN epis_pn_det_task.flg_status%TYPE
    ) RETURN epis_pn_det_task.flg_status%TYPE IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_PN_DET_TASK_STATUS';
    
        l_pn_det_task_status epis_pn_det_task.flg_status%TYPE;
        l_error              t_error_out;
    BEGIN
        g_error := 'GET dest task status. i_pn_det_status: ' || i_pn_det_status || ' i_pn_det_task_status: ' ||
                   i_pn_det_task_status;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF (i_pn_det_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_r)
        THEN
            l_pn_det_task_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_r;
        ELSE
            l_pn_det_task_status := i_pn_det_task_status;
        END IF;
    
        RETURN l_pn_det_task_status;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN NULL;
    END get_pn_det_task_status;

    /**
    * Calculates the detail note.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_id_epis_pn_det       epis_pn_det ID
    * @param   i_pn_note              Det note
    * @param   i_flg_create           Y-new record to be created. N-record to be updated
    * @param   flg_app_upd           A-append text to the existing one; U-update the existing text
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_pn_det_note
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        i_pn_note        IN epis_pn_det.pn_note%TYPE,
        i_flg_create     IN VARCHAR2,
        i_flg_app_upd    IN VARCHAR2
    ) RETURN epis_pn_det.pn_note%TYPE IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_PN_DET_NOTE';
    
        l_pn_note epis_pn_det.pn_note%TYPE;
        l_error   t_error_out;
    BEGIN
        g_error := 'GET dest note. i_id_epis_pn_det: ' || i_id_epis_pn_det || ' i_flg_create: ' || i_flg_create;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF (i_flg_create = pk_alert_constant.g_no AND i_flg_app_upd = pk_prog_notes_constants.g_append_a)
        THEN
            g_error := 'GET pn_note';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT pn_note
              INTO l_pn_note
              FROM epis_pn_det
             WHERE id_epis_pn_det = i_id_epis_pn_det;
        
            l_pn_note := pk_string_utils.trim_empty_lines(i_text => i_pn_note) || pk_prog_notes_constants.g_new_line ||
                         pk_prog_notes_constants.g_new_line || l_pn_note;
        ELSE
            l_pn_note := i_pn_note;
        END IF;
    
        RETURN l_pn_note;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN NULL;
    END get_pn_det_note;

    /**
    * Get the flg_table_origin for the template records
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_flg_table_origin     Flg_table_origin
    * @param   i_id_task_type         Task type
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_flg_table_origin
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_flg_table_origin IN epis_pn_det_task.flg_table_origin%TYPE,
        i_id_task_type     IN epis_pn_det_task.id_task_type%TYPE
    ) RETURN epis_pn_det_task.flg_table_origin%TYPE IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_FLG_TABLE_ORIGIN';
        l_flg_table_origin epis_pn_det_task.flg_table_origin%TYPE := i_flg_table_origin;
        l_error            t_error_out;
    BEGIN
        g_error := 'GET flg_table_origin note. i_flg_table_origin: ' || i_flg_table_origin || ' i_id_task_type: ' ||
                   i_id_task_type;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF (i_flg_table_origin IS NULL AND
           i_id_task_type IN (pk_prog_notes_constants.g_task_templates, pk_prog_notes_constants.g_task_ph_templ))
        THEN
            l_flg_table_origin := pk_touch_option.g_flg_tab_origin_epis_doc;
        END IF;
    
        RETURN l_flg_table_origin;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN NULL;
    END get_flg_table_origin;

    /**
    * Construct the DETail structure to be saved in the definitive tables
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_note_struct          Note structure data
    * @param   i_dt_last_update       Last updte date
    * @param   i_tasks_descs_by_type  Group description not assigned yet to the note struct
    * @param   o_det_insert_work_rows Detail structure to be inserted    
    * @param   o_det_upd_work_rows    Detail structure to be updated
    * @param   o_tasks_insert_work_rows Tasks structure to be inserted
    * @param   o_tasks_upd_work_rows    Tasks structure to be updated
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_pn_det_struct
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_note_struct         IN pk_prog_notes_types.t_note_struct,
        i_dt_last_update      IN epis_pn.dt_last_update%TYPE,
        i_tasks_descs_by_type IN pk_prog_notes_types.t_tasks_descs_by_type,
        o_det_insert_rows     OUT NOCOPY ts_epis_pn_det.epis_pn_det_tc,
        o_det_upd_rows        OUT NOCOPY ts_epis_pn_det.epis_pn_det_tc,
        o_tasks_insert_rows   OUT NOCOPY ts_epis_pn_det_task.epis_pn_det_task_tc,
        o_tasks_childs_rows   OUT NOCOPY ts_epis_pn_det_task.epis_pn_det_task_tc,
        o_tasks_upd_rows      OUT NOCOPY ts_epis_pn_det_task.epis_pn_det_task_tc,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_TASKS_STRUCT';
    
        l_pn_det               epis_pn_det%ROWTYPE;
        l_pn_det_task          epis_pn_det_task%ROWTYPE;
        l_det_indx_ins         PLS_INTEGER := 1;
        l_det_indx_upd         PLS_INTEGER := 1;
        l_task_indx_ins        PLS_INTEGER := 1;
        l_task_indx_upd        PLS_INTEGER := 1;
        l_task_indx_ins_childs PLS_INTEGER := 1;
        l_id_epis_pn_det       epis_pn_det.id_epis_pn_det%TYPE;
        l_id_epis_pn_det_task  epis_pn_det_task.id_epis_pn_det_task%TYPE;
    
        l_id_task      epis_pn_det_task.id_task%TYPE;
        l_id_task_type epis_pn_det_task.id_task_type%TYPE;
        l_pn_note_task epis_pn_det_task.pn_note%TYPE;
        l_save_task    VARCHAR2(1 CHAR);
    
        l_id_task_prt epis_pn_det_task.id_epis_pn_det_task%TYPE;
    
        l_desc      CLOB;
        l_desc_long CLOB;
    
    BEGIN
        g_error := 'LOOP THROUGHT the DET records';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF (i_note_struct.tbl_dblock_det.count > 0)
        THEN
            l_id_epis_pn_det := i_note_struct.tbl_dblock_det.first;
            LOOP
                EXIT WHEN l_id_epis_pn_det IS NULL;
            
                l_pn_det.id_epis_pn_det   := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_epis_pn_det;
                l_pn_det.id_epis_pn       := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_epis_pn;
                l_pn_det.id_pn_data_block := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_pn_data_block;
                l_pn_det.id_pn_soap_block := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_pn_soap_block;
                l_pn_det.flg_status       := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_status;
                l_pn_det.dt_pn            := i_dt_last_update;
                l_pn_det.dt_note          := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).dt_note;
                l_pn_det.id_professional  := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_professional;
            
                g_error := 'CALL get_pn_det_note';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                l_pn_det.pn_note := get_pn_det_note(i_lang           => i_lang,
                                                    i_prof           => i_prof,
                                                    i_id_epis_pn_det => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).id_epis_pn_det,
                                                    i_pn_note        => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).pn_note,
                                                    i_flg_create     => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_create,
                                                    i_flg_app_upd    => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_app_upd);
            
                IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_create = pk_alert_constant.g_yes)
                THEN
                    o_det_insert_rows(l_det_indx_ins) := l_pn_det;
                    l_det_indx_ins := l_det_indx_ins + 1;
                ELSE
                    o_det_upd_rows(l_det_indx_upd) := l_pn_det;
                    l_det_indx_upd := l_det_indx_upd + 1;
                END IF;
            
                IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks.count > 0)
                THEN
                    g_error := 'LOOP THROUGHT the TASKS records';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                
                    l_id_epis_pn_det_task := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks.first;
                    LOOP
                        EXIT WHEN l_id_epis_pn_det_task IS NULL;
                    
                        l_pn_det_task.id_epis_pn_det_task := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_epis_pn_det_task;
                        l_pn_det_task.id_epis_pn_det      := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task) .
                                                              id_epis_pn_det;
                        l_pn_det_task.id_task             := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task;
                        l_pn_det_task.id_task_aggregator  := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_aggregator;
                        l_pn_det_task.id_task_type        := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_type;
                        l_pn_det_task.id_prof_review      := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_prof_review;
                        l_pn_det_task.dt_review           := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).dt_review;
                    
                        l_pn_det_task.dt_req_task := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).dt_req_task;
                    
                        IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).flg_action IS NOT NULL)
                        THEN
                            l_pn_det_task.flg_action := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).flg_action;
                        END IF;
                    
                        g_error := 'CALL get_pn_det_task_status';
                        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                        l_pn_det_task.flg_status := get_pn_det_task_status(i_lang               => i_lang,
                                                                           i_prof               => i_prof,
                                                                           i_pn_det_status      => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_status,
                                                                           i_pn_det_task_status => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).flg_status);
                    
                        IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).pn_note IS NOT NULL AND i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_notes IS NULL)
                        THEN
                            l_pn_det_task.pn_note := pk_string_utils.trim_empty_lines(i_text => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).pn_note);
                        ELSE
                            IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_notes IS NOT NULL)
                            THEN
                                l_desc_long := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task)
                                               .pn_note || pk_prog_notes_constants.g_enter;
                            ELSE
                                l_desc      := NULL;
                                l_desc_long := NULL;
                            END IF;
                        
                            g_error := 'CALL pk_prog_notes_utils.get_import_group_desc. id_task_type: ' ||
                                       l_pn_det_task.id_task_type || ' id_task: ' || l_pn_det_task.id_task;
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package_owner,
                                                 sub_object_name => l_func_name);
                            IF NOT pk_prog_notes_utils.get_import_group_desc(i_lang                => i_lang,
                                                                             i_prof                => i_prof,
                                                                             i_tasks_descs_by_type => i_tasks_descs_by_type,
                                                                             i_id_task_type        => l_pn_det_task.id_task_type,
                                                                             i_id_task             => l_pn_det_task.id_task,
                                                                             i_id_task_notes       => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_notes,
                                                                             i_flg_show_sub_title  => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).flg_show_sub_title,
                                                                             io_desc               => l_desc,
                                                                             io_desc_long          => l_desc_long,
                                                                             o_error               => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            l_pn_det_task.pn_note := l_desc_long;
                        
                        END IF;
                        l_pn_det_task.dt_last_update := i_dt_last_update;
                    
                        g_error := 'CALL  get_flg_table_origin';
                        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                        l_pn_det_task.flg_table_origin := get_flg_table_origin(i_lang             => i_lang,
                                                                               i_prof             => i_prof,
                                                                               i_flg_table_origin => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).flg_table_origin,
                                                                               i_id_task_type     => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_type);
                        l_pn_det_task.dt_task          := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).dt_task;
                        l_pn_det_task.id_prof_task     := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_prof_task;
                        l_pn_det_task.rank_task        := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).rank_task;
                    
                        l_pn_det_task.dt_group_import        := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).dt_group_import;
                        l_pn_det_task.id_group_import        := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_group_import;
                        l_pn_det_task.code_desc_group        := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).code_desc_group;
                        l_pn_det_task.id_sub_group_import    := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_sub_group_import;
                        l_pn_det_task.code_desc_sub_group    := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).code_desc_sub_group;
                        l_pn_det_task.id_sample_type         := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_sample_type;
                        l_pn_det_task.code_desc_sample_type  := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).code_desc_sample_type;
                        l_pn_det_task.code_desc_group_parent := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).code_desc_group_parent;
                        l_pn_det_task.instructions_hash      := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).instructions_hash;
                    
                        l_pn_det_task.id_group_table := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_group_table;
                    
                        l_pn_det_task.table_position := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).table_position;
                    
                        IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task)
                           .flg_find_parent = pk_alert_constant.g_yes)
                        THEN
                            l_id_task_prt  := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_parent;
                            l_id_task      := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task;
                            l_id_task_type := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_task_type;
                        
                            l_pn_note_task := l_pn_det_task.pn_note;
                        
                            g_error := 'CALL pk_prog_notes_in.set_comment_on_area';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT pk_prog_notes_in.set_comment_on_area(i_lang            => i_lang,
                                                                        i_prof            => i_prof,
                                                                        i_id_episode      => NULL,
                                                                        i_id_epis_pn_det  => l_id_epis_pn_det,
                                                                        i_flg_task_parent => pk_alert_constant.g_no,
                                                                        i_id_multichoice  => NULL,
                                                                        i_tbl_tasks       => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks,
                                                                        io_id_task        => l_id_task,
                                                                        io_id_task_type   => l_id_task_type,
                                                                        io_id_task_parent => l_id_task_prt,
                                                                        io_pn_note_task   => l_pn_note_task,
                                                                        o_save_task       => l_save_task,
                                                                        o_error           => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                            l_pn_det_task.id_parent := l_id_task_prt;
                        
                        ELSE
                            l_pn_det_task.id_parent := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task).id_parent;
                        END IF;
                    
                        IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks(l_id_epis_pn_det_task)
                           .flg_create = pk_alert_constant.g_yes)
                        THEN
                            IF (l_pn_det_task.id_parent IS NULL)
                            THEN
                                g_error := 'ASSIGN the TASK insert records l_det_indx: ' || l_id_epis_pn_det ||
                                           ' idx_task: ' || l_id_epis_pn_det_task;
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                o_tasks_insert_rows(l_task_indx_ins) := l_pn_det_task;
                                l_task_indx_ins := l_task_indx_ins + 1;
                            ELSE
                                g_error := 'ASSIGN the TASK child work insert records';
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                o_tasks_childs_rows(l_task_indx_ins_childs) := l_pn_det_task;
                                l_task_indx_ins_childs := l_task_indx_ins_childs + 1;
                            END IF;
                        ELSE
                            o_tasks_upd_rows(l_task_indx_upd) := l_pn_det_task;
                            l_task_indx_upd := l_task_indx_upd + 1;
                        END IF;
                    
                        l_id_epis_pn_det_task := i_note_struct.tbl_dblock_det(l_id_epis_pn_det).tbl_tasks.next(l_id_epis_pn_det_task);
                    
                    END LOOP;
                END IF;
            
                l_id_epis_pn_det := i_note_struct.tbl_dblock_det.next(l_id_epis_pn_det);
            
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_pn_det_struct;

    /**
    * Set the epis_pn_det status after inserting the task records.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_det_rows             Detail rows    
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION set_det_status
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_det_rows ts_epis_pn_det.epis_pn_det_tc,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'SET_DET_STATUS';
        l_idx        epis_pn_det.id_epis_pn_det%TYPE;
        l_flg_status epis_pn_det.flg_status%TYPE;
    
        l_rows_out table_varchar;
    BEGIN
    
        l_idx := i_det_rows.first;
        LOOP
            EXIT WHEN l_idx IS NULL;
        
            IF (i_det_rows(l_idx).flg_status <> pk_prog_notes_constants.g_epis_pn_det_flg_status_r)
            THEN
                g_error := 'CALL set_epis_pn_det_status work';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_epis_pn_det_status(i_lang        => i_lang,
                                              i_prof        => i_prof,
                                              i_epis_pn_det => i_det_rows(l_idx).id_epis_pn_det,
                                              o_flg_status  => l_flg_status,
                                              o_error       => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            ELSE
                ts_epis_pn_det_task.upd(where_in      => ' id_epis_pn_det = ' || i_det_rows(l_idx).id_epis_pn_det,
                                        flg_status_in => i_det_rows(l_idx).flg_status,
                                        rows_out      => l_rows_out);
            
                g_error := 'PROCESS UPDATE ts_epis_pn_det_task WITH id_epis_pn_det: ' || i_det_rows(l_idx).id_epis_pn_det;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN_DET_TASK',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('FLG_STATUS'),
                                              o_error        => o_error);
            END IF;
        
            IF (l_flg_status IS NOT NULL)
            THEN
                ts_epis_pn_det.upd(id_epis_pn_det_in => i_det_rows(l_idx).id_epis_pn_det,
                                   flg_status_in     => l_flg_status,
                                   rows_out          => l_rows_out);
            
                g_error := 'PROCESS UPDATE epis_pn_det WITH id_epis_pn_det: ' || i_det_rows(l_idx).id_epis_pn_det;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN_DET',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('FLG_STATUS'),
                                              o_error        => o_error);
            END IF;
        
            l_idx := i_det_rows.next(l_idx);
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_det_status;
    /**
    * Set the epis_pn_det status after inserting the task records.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_det_rows             Detail rows    
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION set_det_task_status
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_tasks_upd_rows IN ts_epis_pn_det_task.epis_pn_det_task_tc,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'set_det_task_status';
        l_idx                 epis_pn_det.id_epis_pn_det%TYPE;
        l_tb_epis_pn_det_task table_number;
        l_rows_out            table_varchar;
    BEGIN
    
        l_idx := i_tasks_upd_rows.first;
        LOOP
            EXIT WHEN l_idx IS NULL;
        
            g_error := 'SELECT i_tasks_upd_rows(l_idx).id_epis_pn_det = ' || i_tasks_upd_rows(l_idx).id_epis_pn_det_task;
            IF i_tasks_upd_rows(l_idx)
             .id_parent IS NULL
                AND i_tasks_upd_rows(l_idx).flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a
            THEN
                SELECT e.id_epis_pn_det_task
                  BULK COLLECT
                  INTO l_tb_epis_pn_det_task
                  FROM epis_pn_det_task e
                 WHERE e.id_parent = i_tasks_upd_rows(l_idx).id_epis_pn_det_task
                   AND e.flg_status = pk_prog_notes_constants.g_epis_pn_det_sug_add_s;
            
                IF l_tb_epis_pn_det_task.count > 0
                THEN
                    g_error := 'ts_epis_pn_det_task.upd WITH id_epis_pn_det_task in: ' ||
                               pk_utils.concat_table(l_tb_epis_pn_det_task, ',', 1, -1);
                    ts_epis_pn_det_task.upd(where_in      => ' id_epis_pn_det_task in (' ||
                                                             pk_utils.concat_table(l_tb_epis_pn_det_task, ',', 1, -1) || ')',
                                            flg_status_in => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                            rows_out      => l_rows_out);
                
                    g_error := 'process_update EPIS_PN_DET_TASK';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPIS_PN_DET_TASK',
                                                  i_rowids       => l_rows_out,
                                                  i_list_columns => table_varchar('FLG_STATUS'),
                                                  o_error        => o_error);
                
                END IF;
            END IF;
        
            l_idx := i_tasks_upd_rows.next(l_idx);
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_det_task_status;
    /**
    * Insert and update a set or records in the epis_pn_det_task table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_tasks_insert_rows    Tasks structure to be inserted
    * @param   i_tasks_upd_rows       Tasks structure to be inserted
    * @param   i_tasks_descs_by_type  Group description not assigned yet to the note struct    
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION ins_upd_pn_det
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_note_struct         IN pk_prog_notes_types.t_note_struct,
        i_dt_last_update      IN epis_pn.dt_last_update%TYPE,
        i_tasks_descs_by_type IN pk_prog_notes_types.t_tasks_descs_by_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'INS_UPD_PN_DET';
    
        l_det_insert_rows   ts_epis_pn_det.epis_pn_det_tc;
        l_det_upd_rows      ts_epis_pn_det.epis_pn_det_tc;
        l_tasks_insert_rows ts_epis_pn_det_task.epis_pn_det_task_tc;
        l_tasks_upd_rows    ts_epis_pn_det_task.epis_pn_det_task_tc;
        l_tasks_childs_rows ts_epis_pn_det_task.epis_pn_det_task_tc;
    
        l_rowids table_varchar;
    BEGIN
        g_error := 'CALL get_pn_det_struct';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_pn_det_struct(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_note_struct         => i_note_struct,
                                 i_dt_last_update      => i_dt_last_update,
                                 i_tasks_descs_by_type => i_tasks_descs_by_type,
                                 o_det_insert_rows     => l_det_insert_rows,
                                 o_det_upd_rows        => l_det_upd_rows,
                                 o_tasks_insert_rows   => l_tasks_insert_rows,
                                 o_tasks_childs_rows   => l_tasks_childs_rows,
                                 o_tasks_upd_rows      => l_tasks_upd_rows,
                                 o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_det_insert_rows.count > 0)
        THEN
            g_error := 'CALL ts_epis_pn_det_task.ins';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det.ins(rows_in => l_det_insert_rows, rows_out => l_rowids);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN_DET',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        IF (l_det_upd_rows.count > 0)
        THEN
            g_error := 'CALL ts_epis_pn_det.upd';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det.upd(col_in => l_det_upd_rows, ignore_if_null_in => TRUE, rows_out => l_rowids);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN_DET',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        END IF;
    
        g_error := 'CALL ins_upd_det_task';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT ins_upd_det_task(i_lang              => i_lang,
                                i_prof              => i_prof,
                                i_tasks_insert_rows => l_tasks_insert_rows,
                                i_tasks_upd_rows    => l_tasks_upd_rows,
                                i_tasks_childs_rows => l_tasks_childs_rows,
                                o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_det_insert_rows.count > 0)
        THEN
            g_error := 'CALL set_det_status';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT
                set_det_status(i_lang => i_lang, i_prof => i_prof, i_det_rows => l_det_insert_rows, o_error => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        IF (l_det_upd_rows.count > 0)
        THEN
            g_error := 'CALL set_det_status';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT set_det_status(i_lang => i_lang, i_prof => i_prof, i_det_rows => l_det_upd_rows, o_error => o_error)
            THEN
                RAISE g_exception;
            END IF;
            -- updates all notes with same id_parent to 'A' 
            g_error := 'CALL set_det_task_status';
            IF NOT set_det_task_status(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_tasks_upd_rows => l_tasks_upd_rows,
                                       o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END ins_upd_pn_det;

    /**
    * Insert and update a set or records in the epis_pn_det_task table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_id_episode           Episode ID
    * @param   i_note_struct          Note info
    * @param   i_dt_last_update       Last update date    
    * @param   i_flg_synchronized     Y-Single note. N- single page
    * @param   i_flg_upd_note         Y-update the note header. N- do not update the note header
    * @param   i_tasks_descs_by_type  Group description not assigned yet to the note struct
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */

    --*********************************************
    FUNCTION get_status_epis_pn(i_pk IN NUMBER) RETURN VARCHAR2 IS
        tbl_status table_varchar;
        l_return   VARCHAR2(0050 CHAR);
    BEGIN
    
        SELECT flg_status
          BULK COLLECT
          INTO tbl_status
          FROM epis_pn x
         WHERE x.id_epis_pn = i_pk;
    
        IF tbl_status.count > 0
        THEN
            l_return := tbl_status(1);
        END IF;
    
        RETURN l_return;
    
    END get_status_epis_pn;

    -- ***********************************************
    FUNCTION get_status
    (
        i_flg_create   IN VARCHAR2,
        i_epis_pn      IN NUMBER,
        i_flg_sign_off IN VARCHAR2,
        i_flg_submit   IN VARCHAR2
    ) RETURN VARCHAR2 IS
        k_no  CONSTANT VARCHAR2(0050 CHAR) := pk_prog_notes_constants.g_no;
        k_yes CONSTANT VARCHAR2(0050 CHAR) := pk_prog_notes_constants.g_yes;
        l_return                VARCHAR2(0100 CHAR);
        b_functionality_signoff BOOLEAN;
        b_functionality_submit  BOOLEAN;
    
        l_curr_flg_status VARCHAR2(0010 CHAR);
    BEGIN
    
        b_functionality_signoff := i_flg_sign_off = k_yes AND i_flg_submit = k_no;
        b_functionality_submit  := i_flg_sign_off = k_no AND i_flg_submit = k_yes;
    
        CASE
            WHEN b_functionality_submit THEN
            
                IF i_flg_create = k_yes
                THEN
                    l_return := pk_prog_notes_constants.g_epis_pn_flg_status_d;
                ELSE
                    l_return := get_status_epis_pn(i_pk => i_epis_pn);
                
                    IF l_return = pk_prog_notes_constants.g_epis_pn_flg_submited
                    THEN
                        l_return := pk_prog_notes_constants.g_epis_pn_flg_draftsubmit;
                    END IF;
                
                END IF;
            
            WHEN b_functionality_signoff THEN
                l_return := pk_prog_notes_constants.g_epis_pn_flg_status_d;
            
            ELSE
                l_return := pk_prog_notes_constants.g_epis_pn_flg_status_f;
        END CASE;
    
        RETURN l_return;
    
    END get_status;

    -- *******************************
    FUNCTION ins_upd_pn_note
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_episode          IN episode.id_episode%TYPE,
        i_note_struct         IN pk_prog_notes_types.t_note_struct,
        i_dt_last_update      IN epis_pn.dt_last_update%TYPE,
        i_flg_synchronized    IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_flg_sign_off        IN pn_note_type_mkt.flg_sign_off%TYPE,
        i_flg_submit          IN pn_note_type_mkt.flg_submit%TYPE,
        i_flg_upd_note        IN VARCHAR2,
        i_tasks_descs_by_type IN pk_prog_notes_types.t_tasks_descs_by_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'INS_UPD_PN_NOTE';
        l_status VARCHAR2(0010 CHAR);
        l_rowids table_varchar;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF i_flg_synchronized = pk_alert_constant.g_no
        THEN
            --If we are updating a record then we must move the record to hist table
            g_error := 'CALL move_epis_pn_2_hist';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT move_epis_pn_2_hist(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       i_epis_pn        => i_note_struct.id_epis_pn,
                                       i_dt_hist        => g_sysdate_tstz,
                                       i_flg_type       => pk_prog_notes_constants.g_flg_type_md,
                                       i_flg_check_temp => pk_alert_constant.g_yes,
                                       i_id_episode_pn  => i_note_struct.id_episode,
                                       o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        l_status := get_status(i_flg_create   => i_note_struct.flg_create,
                               i_epis_pn      => i_note_struct.id_epis_pn,
                               i_flg_sign_off => i_flg_sign_off,
                               i_flg_submit   => i_flg_submit);
    
        IF (i_note_struct.flg_create = pk_alert_constant.g_yes)
        THEN
            g_error := 'CALL ts_epis_pn';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            ts_epis_pn.ins(id_epis_pn_in       => i_note_struct.id_epis_pn,
                           id_episode_in       => i_note_struct.id_episode,
                           id_prof_create_in   => i_prof.id,
                           dt_pn_date_in       => i_note_struct.dt_pn_date,
                           flg_status_in       => l_status,
                           id_dep_clin_serv_in => i_note_struct.id_dep_clin_serv,
                           dt_create_in        => nvl(i_dt_last_update, g_sysdate_tstz),
                           id_pn_note_type_in  => i_note_struct.id_pn_note_type,
                           id_pn_area_in       => i_note_struct.id_pn_area,
                           flg_auto_saved_in   => i_note_struct.flg_auto_saved,
                           id_software_in      => i_prof.software,
                           dt_proposed_in      => i_note_struct.dt_proposed,
                           rows_out            => l_rowids);
        
            g_error := 'PROCESS INSERT epis_pn WITH id_epis_pn: ' || i_note_struct.id_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN',
                                          i_rowids     => l_rowids,
                                          o_error      => o_error);
        
        ELSIF (i_note_struct.flg_create = pk_alert_constant.g_no)
        THEN
            IF (i_flg_synchronized = pk_alert_constant.g_no OR i_flg_upd_note = pk_alert_constant.g_yes)
            THEN
                g_error := 'CALL ts_epis_pn.upd: ' || i_note_struct.id_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                ts_epis_pn.upd(id_epis_pn_in          => i_note_struct.id_epis_pn,
                               id_episode_in          => i_note_struct.id_episode,
                               dt_pn_date_in          => i_note_struct.dt_pn_date,
                               flg_status_in          => l_status,
                               id_dep_clin_serv_in    => i_note_struct.id_dep_clin_serv,
                               dt_last_update_in      => i_dt_last_update,
                               id_prof_last_update_in => CASE
                                                             WHEN i_dt_last_update IS NULL THEN
                                                              NULL
                                                             ELSE
                                                              i_prof.id
                                                         END,
                               id_pn_note_type_in     => i_note_struct.id_pn_note_type,
                               id_pn_area_in          => i_note_struct.id_pn_area,
                               flg_auto_saved_in      => i_note_struct.flg_auto_saved,
                               rows_out               => l_rowids);
            
                g_error := 'PROCESS INSERT epis_pn WITH id_epis_pn: ' || i_note_struct.id_epis_pn;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN',
                                              i_rowids     => l_rowids,
                                              o_error      => o_error);
            END IF;
        END IF;
    
        g_error := 'CALL ins_upd_pn_det';
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        IF NOT ins_upd_pn_det(i_lang                => i_lang,
                              i_prof                => i_prof,
                              i_note_struct         => i_note_struct,
                              i_dt_last_update      => nvl(i_dt_last_update, g_sysdate_tstz),
                              i_tasks_descs_by_type => i_tasks_descs_by_type,
                              o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (i_flg_synchronized = pk_alert_constant.g_no)
        THEN
        
            -- dont run set_first_obs if temporary
            IF l_status != pk_prog_notes_constants.g_epis_pn_flg_status_t
               AND i_note_struct.flg_create <> pk_alert_constant.g_yes
               AND i_note_struct.flg_auto_saved <> pk_alert_constant.g_yes
            THEN
            
                g_error := 'CALL TO PK_VISIT.SET_FIRST_OBS';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                              i_id_episode          => i_id_episode,
                                              i_pat                 => NULL,
                                              i_prof                => i_prof,
                                              i_prof_cat_type       => NULL,
                                              i_dt_last_interaction => g_sysdate_tstz,
                                              i_dt_first_obs        => g_sysdate_tstz,
                                              o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
            END IF;
        
        END IF;
        IF i_prof.software = pk_alert_constant.g_soft_home_care
           AND i_note_struct.id_pn_note_type = 155
        THEN
            IF NOT pk_hhc_core.set_req_status_ie(i_lang            => i_lang,
                                                 i_prof            => i_prof,
                                                 i_id_episode      => i_id_episode,
                                                 i_id_epis_hhc_req => NULL,
                                                 o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END ins_upd_pn_note;

    /**
    * Update the task ranks to the vital signs table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_id_epis_pn_det       Epis_pn_det ID
    * @param   i_id_episode           Episode ID
    * @param   i_id_visit             Visit ID
    * @param   i_id_patient           Patient ID
    * @param   i_note_struct          Note info
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION update_task_ranks
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        i_id_episode     IN episode.id_episode%TYPE,
        i_id_visit       IN episode.id_visit%TYPE,
        i_id_patient     IN patient.id_patient%TYPE,
        i_note_struct    IN pk_prog_notes_types.t_note_struct,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(17 CHAR) := 'UPDATE_TASK_RANKS';
        l_tasks      table_number;
        l_rank_tasks table_number;
        l_ranks      table_number;
        l_rows_out   table_varchar;
    BEGIN
    
        g_error := 'GET note tasks to update ranks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT epdt.id_task
          BULK COLLECT
          INTO l_tasks
          FROM epis_pn_det_task epdt
         WHERE epdt.id_epis_pn_det = i_id_epis_pn_det
           AND epdt.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
    
        g_error := 'pk_vital_signs.get_vital_signs_ranks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT
            pk_prog_notes_in.get_table_ranks(i_lang      => i_lang,
                                             i_prof      => i_prof,
                                             i_flg_scope => i_note_struct.tbl_dblock_det(i_id_epis_pn_det).flg_scope,
                                             i_scope     => CASE i_note_struct.tbl_dblock_det(i_id_epis_pn_det).flg_scope
                                                                WHEN pk_alert_constant.g_scope_type_episode THEN
                                                                 i_id_episode
                                                                WHEN pk_alert_constant.g_scope_type_visit THEN
                                                                 i_id_visit
                                                                ELSE
                                                                 i_id_patient
                                                            END,
                                             i_id_tasks  => l_tasks,
                                             o_id_tasks  => l_rank_tasks,
                                             o_rank      => l_ranks,
                                             o_error     => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_rank_tasks.exists(1))
        THEN
            FOR i IN 1 .. l_rank_tasks.count
            LOOP
                g_error := 'ts_epis_pn_det_task.upd. l_id_epis_pn_det: ' || i_id_epis_pn_det || ' i_id_task: ' ||
                           l_rank_tasks(i) || 'rank: ' || l_ranks(i);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_pn_det_task.upd(where_in          => ' id_task = ' || l_rank_tasks(i) ||
                                                             ' and id_epis_pn_det = ' || i_id_epis_pn_det,
                                        table_position_in => l_ranks(i),
                                        rows_out          => l_rows_out);
            
                g_error := 'PROCESS UPDATE ts_epis_pn_det_task';
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN_DET_TASK',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('TABLE_POSITION'),
                                              o_error        => o_error);
            
            END LOOP;
        
            --exclude the records that were already in the note but do not belong to the last 2 records any more
            -- that is, set flg_status = 'R'
            FOR rec IN (SELECT column_value id_task
                          FROM TABLE(l_tasks) t
                         WHERE t.column_value NOT IN (SELECT column_value
                                                        FROM TABLE(l_rank_tasks)))
            LOOP
                /*ts_epis_pn_det_task.del_by(where_clause_in => ' id_task = ' || rec.id_task || ' and id_epis_pn_det = ' ||
                                   i_id_epis_pn_det,
                rows_out        => l_rows_out);*/
            
                ts_epis_pn_det_task.upd(where_in      => ' id_task = ' || rec.id_task || ' and id_epis_pn_det = ' ||
                                                         i_id_epis_pn_det,
                                        flg_status_in => pk_prog_notes_constants.g_epis_pn_det_flg_status_r,
                                        rows_out      => l_rows_out);
            
                g_error := 'PROCESS UPDATE ts_epis_pn_det_task removing task';
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_update(i_lang         => i_lang,
                                              i_prof         => i_prof,
                                              i_table_name   => 'EPIS_PN_DET_TASK',
                                              i_rowids       => l_rows_out,
                                              i_list_columns => table_varchar('FLG_STATUS'),
                                              o_error        => o_error);
            
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END update_task_ranks;

    /**
    * Get the aggregated text.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_id_epis_pn_det       Epis_pn_det ID
    * @param   o_text                 Aggregated text
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION get_aggregated_text
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        i_note_dash      IN VARCHAR2 DEFAULT pk_alert_constant.get_no,
        i_flg_group_type IN VARCHAR2 DEFAULT NULL,
        o_text           OUT NOCOPY CLOB,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(19 CHAR) := 'GET_AGGREGATED_TEXT';
    
        l_prev_dt_import         TIMESTAMP WITH LOCAL TIME ZONE;
        l_truncated_dt_import    TIMESTAMP WITH LOCAL TIME ZONE;
        l_text                   CLOB;
        l_date_title             pk_translation.t_desc_translation;
        l_prev_desc_group        pk_translation.t_desc_translation;
        l_prev_desc_sub_group    pk_translation.t_desc_translation;
        l_prev_task              epis_pn_det_task.pn_note%TYPE;
        l_no_date_desc           PLS_INTEGER := 0;
        l_prev_instructions_hash epis_pn_det_task.instructions_hash%TYPE;
        l_instructions           pk_translation.t_desc_translation;
        l_new_date               VARCHAR2(1 CHAR);
        l_id_task                epis_pn_det_task.id_task%TYPE;
    BEGIN
        g_error := 'GET note tasks to update ranks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR rec IN (SELECT t.dt_group_import,
                           t.id_group_import,
                           t.id_task,
                           t.id_task_aggregator,
                           t.id_sub_group_import,
                           t.code_desc_sub_group,
                           t.id_task_type,
                           t.pn_note task_text,
                           t.desc_group,
                           t.desc_sub_group,
                           trunc(t.dt_group_import,
                                 decode(id_task_type, pk_prog_notes_constants.g_task_lab_results, 'HH', 'DD')) trunc_dt_import,
                           instructions_hash,
                           lead(instructions_hash, 1, '') over(ORDER BY dt_group_import DESC, t.desc_group NULLS FIRST, t.desc_sub_group NULLS FIRST, t.dt_group_import DESC, t.rank_task) AS instructions_next,
                           id_parent
                    --lag(instructions_hash, 1, '') over(ORDER BY dt_group_import DESC, t.desc_group NULLS FIRST, t.desc_sub_group NULLS FIRST, t.dt_group_import DESC, t.rank_task) AS instructions_previous
                      FROM (SELECT epdt.dt_group_import,
                                   epdt.id_group_import,
                                   epdt.id_task,
                                   epdt.id_sub_group_import,
                                   epdt.code_desc_sub_group,
                                   epdt.id_task_aggregator,
                                   epdt.id_task_type,
                                   epdt.id_parent,
                                   CASE
                                        WHEN i_note_dash = pk_alert_constant.g_yes THEN
                                         (SELECT pk_translation.get_translation(i_lang      => i_lang,
                                                                                i_code_mess => pk_prog_notes_constants.g_vital_sign_desc_code ||
                                                                                               epdt.id_group_table)
                                            FROM dual) || pk_prog_notes_constants.g_colon || epdt.pn_note
                                        ELSE
                                         epdt.pn_note
                                    END pn_note,
                                   epdt.rank_task,
                                   pk_prog_notes_utils.get_group_desc(i_lang                   => i_lang,
                                                                      i_prof                   => i_prof,
                                                                      i_id_task_type           => epdt.id_task_type,
                                                                      i_dt_group_import        => epdt.dt_group_import,
                                                                      i_code_desc_group        => epdt.code_desc_group,
                                                                      i_code_desc_group_parent => epdt.code_desc_group_parent) desc_group,
                                   
                                   pk_prog_notes_utils.get_sub_group_desc(i_lang                  => i_lang,
                                                                          i_prof                  => i_prof,
                                                                          i_code_desc_sub_group   => epdt.code_desc_sub_group,
                                                                          i_code_desc_sample_type => epdt.code_desc_sample_type) desc_sub_group,
                                   epdt.instructions_hash
                            
                              FROM epis_pn_det_task epdt
                             WHERE epdt.id_epis_pn_det = i_id_epis_pn_det
                               AND epdt.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a) t
                     ORDER BY trunc_dt_import   DESC,
                              t.desc_group      NULLS FIRST,
                              t.desc_sub_group  NULLS FIRST,
                              t.dt_group_import DESC,
                              t.rank_task)
        LOOP
        
            l_truncated_dt_import := rec.trunc_dt_import; --trunc(rec.dt_group_import, 'DD');
            IF (l_truncated_dt_import IS NULL)
            THEN
                l_no_date_desc := 1;
            ELSE
                l_no_date_desc := 0;
            END IF;
            IF rec.id_task_type = pk_prog_notes_constants.g_task_lab_recur
            THEN
                IF i_flg_group_type = 'I'
                THEN
                
                    IF NOT pk_lab_tests_external.get_lab_req_det_by_id_recurr(i_lang             => i_lang,
                                                                              i_prof             => i_prof,
                                                                              i_order_recurrence => rec.id_task_aggregator,
                                                                              i_dt_req           => rec.dt_group_import,
                                                                              o_analysis_req_det => l_id_task,
                                                                              o_error            => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            ELSE
                l_id_task := rec.id_task;
            END IF;
            IF (l_truncated_dt_import <> l_prev_dt_import OR (l_prev_dt_import IS NULL AND l_no_date_desc = 0))
            THEN
            
                --1st aggregation level: Date: mandatory
                --new date group
                g_error := 'CALL pk_prog_notes_utils.get_date_aggr_desc';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_prog_notes_utils.get_date_aggr_desc(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_id_task_type    => rec.id_task_type,
                                                              i_dt_group_import => rec.dt_group_import,
                                                              o_date_title      => l_date_title,
                                                              o_error           => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                IF (l_text IS NOT NULL)
                THEN
                    l_text := l_text || pk_prog_notes_constants.g_new_line || pk_prog_notes_constants.g_new_line;
                END IF;
            
                l_text      := l_text || l_date_title; -- || pk_prog_notes_constants.g_new_line;
                l_prev_task := NULL;
                l_new_date  := pk_alert_constant.g_yes;
            ELSE
                l_new_date := pk_alert_constant.g_no;
            END IF;
        
            IF l_text IS NOT NULL
               AND i_flg_group_type = 'I'
               AND l_new_date = pk_alert_constant.g_yes
            THEN
            
                IF --(rec.instructions_hash <> rec.instructions_next OR rec.instructions_next IS NULL)
                --   AND rec.instructions_next IS NOT NULL                    END IF;
                
                --AND 
                 rec.instructions_hash IS NOT NULL
                 AND rec.id_task_type IN (pk_prog_notes_constants.g_task_lab, pk_prog_notes_constants.g_task_lab_recur)
                THEN
                
                    IF NOT pk_lab_tests_external.get_lab_test_task_instructions(i_lang              => i_lang,
                                                                                i_prof              => i_prof,
                                                                                i_task_request      => NULL,
                                                                                i_task_request_det  => l_id_task,
                                                                                i_flg_group_type    => i_flg_group_type,
                                                                                o_task_instructions => l_instructions,
                                                                                o_error             => o_error)
                    THEN
                        NULL;
                    END IF;
                    l_text := l_text || pk_prog_notes_constants.g_new_line || l_instructions;
                END IF;
            END IF;
        
            --2nd aggregation level: not mandatory (the lab request do not have group description)
            IF (l_prev_desc_group IS NULL OR l_prev_desc_group <> rec.desc_group OR
               ((l_truncated_dt_import <> l_prev_dt_import OR (l_prev_dt_import IS NULL AND l_no_date_desc = 0))))
            THEN
                IF (rec.desc_group IS NOT NULL)
                THEN
                    l_text := l_text || pk_prog_notes_constants.g_new_line || pk_prog_notes_constants.g_space ||
                              pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                              pk_prog_notes_constants.g_space || rec.desc_group || pk_prog_notes_constants.g_space;
                END IF;
                l_prev_task := NULL;
            END IF;
        
            IF (rec.code_desc_sub_group IS NOT NULL)
            THEN
                --3rd level of aggregation: not mandatory
                IF (l_prev_desc_sub_group IS NULL OR l_prev_desc_sub_group <> rec.desc_sub_group)
                THEN
                    l_text      := l_text || pk_prog_notes_constants.g_new_line || pk_prog_notes_constants.g_space ||
                                   pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                   pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                   pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                   pk_prog_notes_constants.g_space || rec.desc_sub_group ||
                                   pk_prog_notes_constants.g_new_line;
                    l_prev_task := NULL;
                END IF;
            END IF;
        
            --include the final records
            l_text := l_text ||
                      pk_prog_notes_utils.get_txt_aggr_separator(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_task_type        => rec.id_task_type,
                                                                 i_id_sub_group_import => rec.id_sub_group_import,
                                                                 i_prev_task           => l_prev_task) || rec.task_text;
        
            l_prev_instructions_hash := rec.instructions_hash;
            l_prev_dt_import         := l_truncated_dt_import;
            l_prev_desc_group        := rec.desc_group;
            l_prev_desc_sub_group    := rec.desc_sub_group;
            l_prev_task              := rec.task_text;
        
            IF l_text IS NOT NULL
               AND i_flg_group_type = 'I'
            THEN
            
                IF (rec.instructions_hash <> rec.instructions_next OR rec.instructions_next IS NULL)
                  --   AND rec.instructions_next IS NOT NULL
                   AND rec.instructions_hash IS NOT NULL
                   AND
                   rec.id_task_type IN (pk_prog_notes_constants.g_task_lab, pk_prog_notes_constants.g_task_lab_recur)
                THEN
                    /*                
                    IF NOT pk_lab_tests_external.get_lab_test_task_instructions(i_lang              => i_lang,
                                                                                i_prof              => i_prof,
                                                                                i_task_request      => NULL,
                                                                                i_task_request_det  => rec.id_task,
                                                                                i_flg_group_type    => i_flg_group_type,
                                                                                o_task_instructions => l_instructions,
                                                                                o_error             => o_error)
                    THEN
                        NULL;
                    END IF;
                    
                    l_text                := l_text || pk_prog_notes_constants.g_new_line ||
                                             pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                             pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                             pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                             pk_prog_notes_constants.g_space || pk_prog_notes_constants.g_space ||
                                             l_instructions;*/
                    l_prev_dt_import      := NULL;
                    l_prev_desc_group     := NULL;
                    l_prev_desc_sub_group := NULL;
                END IF;
            END IF;
        
        END LOOP;
    
        o_text := l_text;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_aggregated_text;
    --
    FUNCTION get_aggregated_text_clob
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        i_note_dash      IN VARCHAR2 DEFAULT pk_alert_constant.get_no
    ) RETURN CLOB IS
        l_func_name CONSTANT VARCHAR2(50 CHAR) := 'GET_AGGREGATED_TEXT_CLOB';
        l_text  CLOB;
        o_error t_error_out;
    BEGIN
        g_error := 'get_aggregated_text. i_id_epis_pn_det: ' || i_id_epis_pn_det;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_aggregated_text(i_lang           => i_lang,
                                   i_prof           => i_prof,
                                   i_id_epis_pn_det => i_id_epis_pn_det,
                                   i_note_dash      => i_note_dash,
                                   o_text           => l_text,
                                   o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN l_text;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN NULL;
    END get_aggregated_text_clob;
    /**
    * Update the task ranks to the vital signs table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_id_epis_pn_det       Epis_pn_det ID
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION update_aggregated_texts
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_pn_det IN epis_pn_det.id_epis_pn_det%TYPE,
        i_flg_group_type IN VARCHAR2 DEFAULT NULL,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(23 CHAR) := 'UPDATE_AGGREGATED_TEXTS';
    
        l_rows_out table_varchar;
        l_text     CLOB;
    
    BEGIN
        g_error := 'get_aggregated_text. i_id_epis_pn_det: ' || i_id_epis_pn_det;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_aggregated_text(i_lang           => i_lang,
                                   i_prof           => i_prof,
                                   i_id_epis_pn_det => i_id_epis_pn_det,
                                   i_flg_group_type => i_flg_group_type,
                                   o_text           => l_text,
                                   o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_text IS NOT NULL)
        THEN
        
            g_error := 'ts_epis_pn_det.upd. l_id_epis_pn_det: ' || i_id_epis_pn_det;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_pn_det.upd(id_epis_pn_det_in => i_id_epis_pn_det, pn_note_in => l_text, rows_out => l_rows_out);
        
            g_error := 'PROCESS UPDATE ts_epis_pn_det';
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_PN_DET',
                                          i_rowids       => l_rows_out,
                                          i_list_columns => table_varchar('PN_NOTE'),
                                          o_error        => o_error);
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END update_aggregated_texts;

    /**
    * Update the task ranks to the vital signs table.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)         *                                 
    * @param   i_id_episode           Episode ID
    * @param   i_id_visit             Visit ID
    * @param   i_id_patient           Patient ID
    * @param   i_note_struct          Note info
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         Sofia Mendes
    * @version                        2.6.2
    * @since                          20-Jun-2012
    */
    FUNCTION update_aggregations
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_episode  IN episode.id_episode%TYPE,
        i_id_visit    IN episode.id_visit%TYPE,
        i_id_patient  IN patient.id_patient%TYPE,
        i_note_struct IN pk_prog_notes_types.t_note_struct,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(19 CHAR) := 'UPDATE_AGGREGATIONS';
        l_id_epis_pn_det epis_pn_det.id_epis_pn_det%TYPE;
    
    BEGIN
        IF (i_note_struct.tbl_dblock_det.count > 0)
        THEN
            l_id_epis_pn_det := i_note_struct.tbl_dblock_det.first;
            LOOP
                EXIT WHEN l_id_epis_pn_det IS NULL;
                IF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_update_ranks = pk_alert_constant.g_yes)
                THEN
                    g_error := 'CALL update_task_ranks';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT update_task_ranks(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_id_epis_pn_det => l_id_epis_pn_det,
                                             i_id_episode     => i_id_episode,
                                             i_id_visit       => i_id_visit,
                                             i_id_patient     => i_id_patient,
                                             i_note_struct    => i_note_struct,
                                             o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                ELSIF (i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_aggregate_data = pk_alert_constant.g_yes)
                THEN
                    g_error := 'CALL update_aggregated_texts';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT update_aggregated_texts(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_id_epis_pn_det => l_id_epis_pn_det,
                                                   i_flg_group_type => i_note_struct.tbl_dblock_det(l_id_epis_pn_det).flg_group_type,
                                                   o_error          => o_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            
                l_id_epis_pn_det := i_note_struct.tbl_dblock_det.next(l_id_epis_pn_det);
            
            END LOOP;
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END update_aggregations;

    FUNCTION get_data_block_related
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_flg_category     IN category.flg_type%TYPE,
        i_episode          IN episode.id_episode%TYPE,
        i_patient          IN patient.id_patient%TYPE,
        i_pn_note_type     IN pn_note_type.id_pn_note_type%TYPE,
        i_market           IN market.id_market%TYPE,
        i_software         IN software.id_software%TYPE,
        i_id_pn_data_block IN pn_data_block.id_pn_data_block%TYPE,
        i_dblocks          IN t_coll_dblock,
        i_dblock_task_type IN t_coll_dblock_task_type DEFAULT NULL,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_dt_pn_date       IN VARCHAR2,
        i_flg_action       IN VARCHAR2,
        i_date_type        IN VARCHAR2,
        i_id_task          IN table_number,
        i_id_task_related  IN table_number,
        io_note_struct     IN OUT pk_prog_notes_types.t_note_struct,
        --  o_rec_dblock       OUT NOCOPY t_rec_dblock,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(22 CHAR) := 'get_data_block_related';
        l_dblocks_count    PLS_INTEGER;
        l_id_pn_soap_block pn_soap_block.id_pn_soap_block%TYPE;
        l_task_types       table_number;
        l_rec_dblock       t_rec_dblock;
        l_id_task          table_number;
        l_dt_task          table_varchar;
        l_timezone         pk_translation.t_desc_translation;
        l_flg_reload       VARCHAR2(1 CHAR);
        l_note_task        CLOB;
        l_tbl_note_task    table_clob;
        l_id_epis_pn       epis_pn.id_epis_pn%TYPE;
        l_id_task_type     table_number;
    BEGIN
        --    g_error := 'GET get_data_block_related. i_id_pn_data_block: ' || i_id_pn_data_block || ' i_id_pn_soap_block: ' ||
        --                 i_id_pn_soap_block;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_id_pn_soap_block := pk_prog_notes_utils.get_dblock_sblock(i_lang             => i_lang,
                                                                    i_prof             => i_prof,
                                                                    i_dblocks          => i_dblocks,
                                                                    i_id_pn_data_block => i_id_pn_data_block);
        --      l_dblocks_count := i_dblocks.count;
        IF NOT pk_prog_notes_utils.get_dblock_cfgs_rec(i_lang             => i_lang,
                                                       i_prof             => i_prof,
                                                       i_dblocks          => i_dblocks,
                                                       i_id_pn_data_block => i_id_pn_data_block,
                                                       i_id_pn_soap_block => l_id_pn_soap_block,
                                                       o_rec_dblock       => l_rec_dblock,
                                                       o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
        -- get task_types for the data block
        IF NOT pk_prog_notes_utils.get_dblock_task_types(i_lang             => i_lang,
                                                         i_prof             => i_prof,
                                                         i_id_episode       => i_episode,
                                                         i_id_market        => i_market,
                                                         i_id_department    => NULL,
                                                         i_id_dep_clin_serv => NULL,
                                                         i_id_pn_data_block => i_id_pn_data_block,
                                                         i_id_pn_soap_block => l_id_pn_soap_block,
                                                         i_id_pn_note_type  => i_pn_note_type,
                                                         i_software         => i_software,
                                                         i_id_task_type_prt => NULL,
                                                         i_id_task_related  => i_id_task_related,
                                                         o_task_types       => l_task_types,
                                                         o_error            => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        IF l_task_types IS NOT NULL
           AND l_task_types.exists(1)
        THEN
        
            FOR i IN l_task_types.first .. l_task_types.last
            LOOP
                -- get the 
                --Call function that deal with one block at the time
                g_error := 'set data block: id_pn_data_block ' || i_id_pn_data_block || ' id_pn_soap_block ' ||
                           l_id_pn_soap_block;
                IF NOT pk_prog_notes_dblock.get_related_data_from_ea(i_lang                 => i_lang,
                                                                     i_prof                 => i_prof,
                                                                     i_id_episode           => i_episode,
                                                                     i_id_task              => i_id_task,
                                                                     i_id_task_type_related => l_task_types(i),
                                                                     i_id_data_block        => i_id_pn_data_block,
                                                                     i_id_soap_block        => l_id_pn_soap_block,
                                                                     i_id_note_type         => i_pn_note_type,
                                                                     i_flg_action           => i_flg_action,
                                                                     o_id_task              => l_id_task,
                                                                     o_dt_task              => l_dt_task,
                                                                     o_id_task_type         => l_id_task_type,
                                                                     o_note_task            => l_tbl_note_task,
                                                                     o_error                => o_error)
                THEN
                    RETURN FALSE;
                END IF;
                IF l_id_task IS NOT NULL
                   AND l_id_task.exists(1)
                THEN
                    -- check if record already exists on note
                
                    IF NOT set_data_block( --
                                     i_lang               => i_lang,
                                     i_prof               => i_prof,
                                     i_episode            => i_episode,
                                     i_patient            => i_patient,
                                     i_epis_pn            => i_epis_pn,
                                     i_dt_pn_date         => i_dt_pn_date,
                                     i_flg_action         => i_flg_action,
                                     i_date_type          => i_date_type,
                                     i_pn_soap_block      => l_id_pn_soap_block,
                                     i_pn_data_block      => i_id_pn_data_block,
                                     i_id_task            => l_id_task,
                                     io_id_task_type      => l_id_task_type,
                                     i_epis_pn_det        => NULL,
                                     i_pn_note            => NULL, --i_pn_note(i),
                                     i_flg_status         => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                     i_flg_app_upd        => pk_prog_notes_constants.g_flg_app_upd,
                                     i_epis_pn_det_task   => NULL,
                                     i_pn_note_task       => l_tbl_note_task,
                                     i_flg_add_rem_task   => NULL,
                                     i_flg_table_origin   => NULL,
                                     i_id_task_aggregator => NULL,
                                     i_dt_task            => CASE
                                                                 WHEN l_dt_task.exists(1) THEN
                                                                  l_dt_task
                                                                 ELSE
                                                                  NULL
                                                             END,
                                     i_id_task_parent     => NULL,
                                     --    i_flg_task_parent    => NULL,
                                     i_id_multichoice   => NULL,
                                     i_rank_task        => NULL,
                                     i_prof_task        => NULL,
                                     i_prof_cat_type    => i_flg_category,
                                     i_dblock_cfgs      => l_rec_dblock,
                                     i_dblock_task_type => i_dblock_task_type,
                                     i_id_group_table   => NULL,
                                     i_flg_related      => pk_alert_constant.g_yes,
                                     o_id_epis_pn       => l_id_epis_pn,
                                     o_flg_reload       => l_flg_reload,
                                     io_note_struct     => io_note_struct,
                                     io_timezone        => l_timezone,
                                     o_error            => o_error)
                    THEN
                        RETURN FALSE;
                    END IF;
                    --   END IF;
                END IF;
            END LOOP;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN g_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_data_block_related;
    /**
    * Update all data block's content for a PN. If the data doesn't exists yet, the record will be created.
    * the IN parameter Type allow for select if append or update should be done to the text.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_episode              Episode ID
    * @param   i_epis_pn              Progress note ID
    * @param   i_dt_pn_date           Progress Note date Array
    * @param   i_flg_action           C-Create; U-update; I-import
    * @param   i_date_type            DH- Date hour; D-Date
    * @param   i_pn_soap_block        SOAP Block ID
    * @param   i_pn_data_block        Data Block ID
    * @param   i_id_task              Array of task IDs
    * @param   i_id_task_type         Array of task type IDs
    * @param   i_dep_clin_serv        Clinical Service ID
    * @param   i_epis_pn_det          Progress note detail ID
    * @param   i_pn_note              Progress note detail text 
    * @param   i_flg_add_remove       Add or remove block from note. A R-Removed block is like a canceled one.
    * @param   i_id_pn_note_type      Progress Note type (P-progress note; L-prolonged progress note; CC-intensive care note; H-history and physician note) 
    * @param   i_flg_app_upd          Type of operation: A-Append, U-Update
    * @param   i_flg_definitive       Save PN in the definitive model (Y- YES, N- NO)
    * @param   i_epis_pn_det_task     Array of PN task details
    * @param   i_pn_note_task         Array of PN task descriptions
    * @param   i_flg_add_rem_task     Array of task status (A- Active, R- Removed)
    * @param   i_flg_table_origin     Flag origin table for documentation ( D - documentation, A - Anamnesis, S - Review of system)
    * @param   i_id_task_aggregator   For analysis and exam recurrences, an imported registry will only be uniquely 
    *                                 identified by id_task (id_analysis/id_exam) + i_id_task_aggregator
    * @param   i_dt_task              Task dates
    * @param   i_id_task_parent       Parent task identifier for comments functionality
    * @param   i_flg_task_parent      Flag tells where i_id_task_parent (Y) is a taskid or id_epis_pn_det_task
    * @param   i_id_multichoice       Array of tasks identifiers for cases that have more than one parameter (multichoice on exam results)
    * @param   i_id_group_table       Id Group (vital sign id): vital signs table row id
    *
    * @param   o_id_epis_pn           ID of the PN created
    * @param   o_flg_reload           Tells UX layer it It's needed the reload screen or not
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @value   o_flg_reload           {*} 'Y'- Yes {*} 'N'- No
    * @value   i_flg_task_parent      {*} 'Y'- Passed in i_id_task_parent the id_epis_pn_det_task {*} 'N'- Passed in i_id_task_parent the taskid
    *
    * @author                         RUI.BATISTA
    * @version                        <2.6.0.5>
    * @since                          04-02-2011
    */
    FUNCTION set_all_data_block
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_episode            IN episode.id_episode%TYPE,
        i_epis_pn            IN epis_pn.id_epis_pn%TYPE,
        i_dt_pn_date         IN table_varchar,
        i_flg_action         IN VARCHAR2,
        i_date_type          IN table_varchar,
        i_pn_soap_block      IN table_number,
        i_pn_data_block      IN table_number,
        i_id_task            IN table_table_number,
        i_id_task_type       IN table_table_number,
        i_dep_clin_serv      IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_epis_pn_det        IN table_number,
        i_pn_note            IN table_clob,
        i_flg_add_remove     IN table_varchar,
        i_id_pn_note_type    IN epis_pn.id_pn_note_type%TYPE,
        i_flg_app_upd        IN VARCHAR2,
        i_flg_definitive     IN VARCHAR2,
        i_epis_pn_det_task   IN table_table_number,
        i_pn_note_task       IN table_table_clob,
        i_flg_add_rem_task   IN table_table_varchar,
        i_flg_table_origin   IN table_table_varchar DEFAULT NULL,
        i_id_task_aggregator IN table_table_number,
        i_dt_task            IN table_table_varchar,
        i_id_task_parent     IN table_table_number,
        i_flg_task_parent    IN VARCHAR2,
        i_id_multichoice     IN table_table_number,
        i_id_group_table     IN table_table_number,
        i_dt_proposed        IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_id_epis_pn         OUT epis_pn.id_epis_pn%TYPE,
        o_flg_reload         OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_epis_pn epis_pn.id_epis_pn%TYPE;
        g_yes CONSTANT VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
    
        l_id_patient patient.id_patient%TYPE;
        l_id_visit   visit.id_visit%TYPE;
        l_id_episode episode.id_episode%TYPE;
    
        l_id_pn_soap_block pn_soap_block.id_pn_soap_block%TYPE;
        l_id_pn_data_block pn_data_block.id_pn_data_block%TYPE;
        l_id_task_type     table_table_number := i_id_task_type;
        e_invalid_argument EXCEPTION;
    
        l_func_name CONSTANT VARCHAR2(23 CHAR) := 'SET_ALL_DATA_BLOCK';
        l_configs_ctx pk_prog_notes_types.t_configs_ctx;
        l_note_struct pk_prog_notes_types.t_note_struct;
        l_timezone    pk_translation.t_desc_translation;
    
        l_dt_last_update TIMESTAMP WITH LOCAL TIME ZONE;
        l_prof_cat_type  category.flg_type%TYPE;
    
        l_rec_dblock          t_rec_dblock;
        l_tasks_descs_by_type pk_prog_notes_types.t_tasks_descs_by_type;
        l_id_task_related     table_number;
        --l_start NUMBER DEFAULT dbms_utility.get_time;
    BEGIN
        l_id_epis_pn := i_epis_pn;
    
        l_dt_last_update := current_timestamp;
    
        --l_start := dbms_utility.get_time;
    
        l_prof_cat_type := pk_tools.get_prof_cat(i_prof);
    
        g_error := 'CALL reset_configs_ctx. i_episode: ' || i_episode || ' i_id_pn_note_type: ' || i_id_pn_note_type ||
                   ' i_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang             => i_lang,
                                           i_prof             => i_prof,
                                           i_episode          => i_episode,
                                           i_id_pn_note_type  => i_id_pn_note_type,
                                           i_epis_pn          => i_epis_pn,
                                           i_id_dep_clin_serv => i_dep_clin_serv,
                                           i_flg_get_blocks   => pk_alert_constant.g_yes);
    
        g_error := 'ANALYSING SCOPE TYPE. i_episode: ' || i_episode;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_episode,
                                              i_scope_type => pk_alert_constant.g_scope_type_episode,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => o_error)
        THEN
            RAISE e_invalid_argument;
        END IF;
    
        --If there any other task that has tl_task flg_synch_area with 'N'
        --then Edit Screen by default must reload
        o_flg_reload := g_yes;
    
        g_error := 'CALL set_note_header';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT set_note_header(i_lang             => i_lang,
                               i_prof             => i_prof,
                               i_episode          => i_episode,
                               i_epis_pn          => l_id_epis_pn,
                               i_dep_clin_serv    => l_configs_ctx.id_dep_clin_serv,
                               i_id_pn_note_type  => i_id_pn_note_type,
                               i_id_pn_area       => l_configs_ctx.note_type.id_pn_area,
                               i_flg_synchronized => l_configs_ctx.note_type.flg_synchronized,
                               i_dt_last_update   => l_dt_last_update,
                               i_flg_definitive   => i_flg_definitive,
                               i_dt_proposed      => i_dt_proposed,
                               o_note_struct      => l_note_struct,
                               o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        l_id_epis_pn := l_note_struct.id_epis_pn;
    
        g_error := 'Run through array to set de PN header and details';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR i IN 1 .. i_pn_data_block.count
        LOOP
            l_id_pn_soap_block := i_pn_soap_block(i);
            l_id_pn_data_block := i_pn_data_block(i);
        
            IF (i_id_task.exists(i) AND i_id_task(i).exists(1))
            THEN
                g_error := 'CALL pk_prog_notes_utils.get_flg_aggregate_data';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_prog_notes_utils.get_dblock_cfgs_rec(i_lang             => i_lang,
                                                               i_prof             => i_prof,
                                                               i_dblocks          => l_configs_ctx.data_blocks,
                                                               i_id_pn_data_block => l_id_pn_data_block,
                                                               i_id_pn_soap_block => l_id_pn_soap_block,
                                                               o_rec_dblock       => l_rec_dblock,
                                                               o_error            => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
            --Call function that deal with one block at the time
            g_error := 'set data block: id_pn_data_block ' || l_id_pn_data_block || ' id_pn_soap_block ' ||
                       l_id_pn_soap_block;
            IF NOT set_data_block( --
                             i_lang               => i_lang,
                             i_prof               => i_prof,
                             i_episode            => i_episode,
                             i_patient            => l_id_patient,
                             i_epis_pn            => l_id_epis_pn,
                             i_dt_pn_date         => CASE
                                                         WHEN i_dt_pn_date.exists(i) THEN
                                                          i_dt_pn_date(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_date_type          => CASE
                                                         WHEN i_date_type.exists(i) THEN
                                                          i_date_type(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_flg_action         => i_flg_action,
                             i_pn_soap_block      => l_id_pn_soap_block,
                             i_pn_data_block      => l_id_pn_data_block,
                             i_id_task            => i_id_task(i),
                             io_id_task_type      => l_id_task_type(i),
                             i_epis_pn_det        => i_epis_pn_det(i),
                             i_pn_note            => i_pn_note(i),
                             i_flg_status         => nvl(i_flg_add_remove(i), pk_prog_notes_constants.g_epis_pn_det_flg_status_a),
                             i_flg_app_upd        => i_flg_app_upd,
                             i_epis_pn_det_task   => CASE
                                                         WHEN i_epis_pn_det_task.exists(i) THEN
                                                          i_epis_pn_det_task(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_pn_note_task       => CASE
                                                         WHEN i_pn_note_task.exists(i) THEN
                                                          i_pn_note_task(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_flg_add_rem_task   => CASE
                                                         WHEN i_flg_add_rem_task.exists(i) THEN
                                                          i_flg_add_rem_task(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_flg_table_origin   => CASE
                                                         WHEN i_flg_table_origin.exists(i) THEN
                                                          i_flg_table_origin(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_id_task_aggregator => CASE
                                                         WHEN i_id_task_aggregator.exists(i) THEN
                                                          i_id_task_aggregator(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_dt_task            => CASE
                                                         WHEN i_dt_task.exists(i) THEN
                                                          i_dt_task(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_id_task_parent     => CASE
                                                         WHEN i_id_task_parent.exists(i) THEN
                                                          i_id_task_parent(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_flg_task_parent    => i_flg_task_parent,
                             i_id_multichoice     => CASE
                                                         WHEN i_id_multichoice.exists(i) THEN
                                                          i_id_multichoice(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             i_rank_task          => NULL,
                             i_prof_task          => NULL,
                             i_prof_cat_type      => l_prof_cat_type,
                             i_dblock_cfgs        => l_rec_dblock,
                             i_dblock_task_type   => l_configs_ctx.task_types,
                             i_id_group_table     => CASE
                                                         WHEN i_id_group_table IS NOT NULL
                                                              AND i_id_group_table.exists(i) THEN
                                                          i_id_group_table(i)
                                                         ELSE
                                                          NULL
                                                     END,
                             o_id_epis_pn         => l_id_epis_pn,
                             o_flg_reload         => o_flg_reload,
                             io_note_struct       => l_note_struct,
                             io_timezone          => l_timezone,
                             o_error              => o_error)
            THEN
                RETURN FALSE;
            END IF;
            IF l_rec_dblock.id_pndb_related IS NOT NULL
            THEN
                IF NOT get_task_related(i_lang             => i_lang,
                                        i_id_pn_data_block => l_id_pn_data_block,
                                        i_id_pn_soap_block => l_id_pn_soap_block,
                                        i_id_pn_note_type  => i_id_pn_note_type,
                                        i_id_task_type     => l_id_task_type(i),
                                        o_id_task_related  => l_id_task_related)
                THEN
                
                    RETURN FALSE;
                END IF;
            
                IF NOT get_data_block_related(i_lang             => i_lang,
                                         i_prof             => i_prof,
                                         i_flg_category     => l_prof_cat_type,
                                         i_episode          => i_episode,
                                         i_patient          => l_id_patient,
                                         i_pn_note_type     => l_configs_ctx.id_pn_note_type,
                                         i_market           => l_configs_ctx.id_market,
                                         i_software         => l_configs_ctx.id_software,
                                         i_id_pn_data_block => l_rec_dblock.id_pndb_related,
                                         i_dblocks          => l_configs_ctx.data_blocks,
                                         i_dblock_task_type => l_configs_ctx.task_types,
                                         i_epis_pn          => l_id_epis_pn,
                                         i_dt_pn_date       => CASE
                                                                   WHEN i_dt_pn_date.exists(i) THEN
                                                                    i_dt_pn_date(i)
                                                                   ELSE
                                                                    NULL
                                                               END,
                                         i_flg_action       => i_flg_action,
                                         i_date_type        => CASE
                                                                   WHEN i_date_type.exists(i) THEN
                                                                    i_date_type(i)
                                                                   ELSE
                                                                    NULL
                                                               END,
                                         i_id_task          => i_id_task(i),
                                         i_id_task_related  => l_id_task_related,
                                         io_note_struct     => l_note_struct,
                                         o_error            => o_error)
                THEN
                
                    RETURN FALSE;
                END IF;
            
            END IF;
        END LOOP;
    
        /*pode ser isso 
        -- find if FLG_SUBMIT is to be processes
        -- flg_submit supercedes flg_sign_off
        */
    
        /*
                l_configs_ctx.note_type.flg_sign_off := process_flg_submit(i_prof        => i_prof,
                                                                           i_flg_signoff => l_configs_ctx.note_type.flg_sign_off,
                                                                           i_flg_submit  => l_configs_ctx.note_type.flg_submit);
        */
    
        g_error := 'CALL ins_upd_pn_note';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT ins_upd_pn_note(i_lang                => i_lang,
                               i_prof                => i_prof,
                               i_id_episode          => i_episode,
                               i_note_struct         => l_note_struct,
                               i_dt_last_update      => l_dt_last_update,
                               i_flg_synchronized    => l_configs_ctx.note_type.flg_synchronized,
                               i_flg_sign_off        => l_configs_ctx.note_type.flg_sign_off,
                               i_flg_submit          => l_configs_ctx.note_type.flg_submit,
                               i_flg_upd_note        => pk_alert_constant.g_yes,
                               i_tasks_descs_by_type => l_tasks_descs_by_type,
                               o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --Save all changes to the definitive data model
        IF nvl(i_flg_definitive, g_yes) = g_yes
           AND l_configs_ctx.note_type.flg_synchronized = pk_alert_constant.g_no
        THEN
            g_error := 'Save all changes to the definitive data model';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => 'SET_ALL_DATA_BLOCK');
            IF NOT set_save_work_data(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_epis_pn      => i_epis_pn,
                                      i_epis_pn_work => l_id_epis_pn,
                                      o_error        => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        --update tasks ranks when using vital sign table        
        g_error := 'CALL update_task_ranks';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT update_aggregations(i_lang        => i_lang,
                                   i_prof        => i_prof,
                                   i_id_episode  => l_id_episode,
                                   i_id_visit    => l_id_visit,
                                   i_id_patient  => l_id_patient,
                                   i_note_struct => l_note_struct,
                                   o_error       => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_configs_ctx.note_type.flg_review_all = pk_alert_constant.g_yes)
        THEN
            --review the tasks
            FOR i IN 1 .. i_id_task.count
            LOOP
                IF (i_id_task.exists(i) AND l_id_task_type.exists(i) AND i_flg_add_rem_task.exists(i))
                THEN
                    IF (i_id_task(i) IS NOT NULL AND l_id_task_type(i) IS NOT NULL AND
                       i_flg_add_rem_task(i) IS NOT NULL)
                    THEN
                        g_error := 'CALL set_review_tasks';
                        pk_alertlog.log_debug(g_error);
                        IF NOT set_review_tasks(i_lang         => i_lang,
                                                i_prof         => i_prof,
                                                i_id_episode   => i_episode,
                                                i_id_task      => i_id_task(i),
                                                i_id_task_type => l_id_task_type(i),
                                                i_flg_auto     => pk_alert_constant.g_no,
                                                i_flg_review   => i_flg_add_rem_task(i),
                                                i_id_patient   => l_id_patient,
                                                o_error        => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    
        o_id_epis_pn := l_id_epis_pn;
    
        --        dbms_output.put_line(dbms_utility.get_time - l_start);
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_ALL_DATA_BLOCK',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_all_data_block;

    /**
    * Get the flag that indicates if should be performed a copy of the template in the import
    *
    * @param i_flg_cp_edit_import     Y-should be performed the copy    
    *
    * @return                 C-should be performed the copy of the task. A- should be added the current record to the note        
    *
    * @author               Sofia Mendes
    * @version              2.6.1.2
    * @since                29-09-2011
    */
    FUNCTION get_cp_no_changes_flg(i_flg_cp_edit_import IN pn_dblock_mkt.flg_cp_no_changes_import%TYPE) RETURN VARCHAR2 IS
    BEGIN
        IF (i_flg_cp_edit_import = pk_alert_constant.g_yes)
        THEN
            RETURN pk_prog_notes_constants.g_copy_template_action;
        ELSE
            RETURN pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
        END IF;
    END get_cp_no_changes_flg;

    /**
    * Get the flag that indicates if the registry should be dimmed:
    * the reference to the original record is imported and the record had already been imported in the current note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_id_episode         Episode identifier
    * @param   i_id_epis_pn         Note identifier
    * @param   i_id_task            Task identifier
    * @param   i_id_task_type            Task type identifier
    * @param   i_id_pn_data_block        Data block id
    * @param   i_id_pn_soap_block        Soap block id
    * @param   i_flg_cp_edit_import     Y-should be performed the copy   
    *
    * @return                 C-should be performed the copy of the task. A- should be added the current record to the note        
    *
    * @author               Sofia Mendes
    * @version              2.6.1.2
    * @since                29-09-2011
    */
    FUNCTION get_dimmed_flg
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_episode             IN episode.id_episode%TYPE,
        i_id_epis_pn             IN epis_pn.id_epis_pn%TYPE,
        i_id_task                IN epis_pn_det_task.id_task%TYPE,
        i_id_task_aggregator     IN epis_pn_det_task.id_task_aggregator%TYPE,
        i_id_task_type           IN epis_pn_det_task.id_task_type%TYPE,
        i_id_pn_data_block       IN pn_data_block.id_pn_data_block%TYPE,
        i_id_pn_soap_block       IN pn_soap_block.id_pn_soap_block%TYPE,
        i_flg_import             IN pn_dblock_mkt.flg_import%TYPE,
        i_flg_previouly_imported IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_flg_previously_imported VARCHAR2(1 CHAR);
    BEGIN
        IF (i_flg_previouly_imported = pk_alert_constant.g_yes)
        THEN
            l_flg_previously_imported := pk_prog_notes_utils.check_imported_record(i_lang               => i_lang,
                                                                                   i_prof               => i_prof,
                                                                                   i_id_episode         => i_id_episode,
                                                                                   i_id_epis_pn         => i_id_epis_pn,
                                                                                   i_id_task            => i_id_task,
                                                                                   i_id_task_aggregator => i_id_task_aggregator,
                                                                                   i_id_task_type       => i_id_task_type,
                                                                                   i_id_pn_data_block   => i_id_pn_data_block,
                                                                                   i_id_pn_soap_block   => i_id_pn_soap_block,
                                                                                   i_flg_only_active    => pk_alert_constant.g_yes);
        ELSE
            l_flg_previously_imported := i_flg_previouly_imported;
        END IF;
    
        IF (i_flg_import IN (pk_prog_notes_constants.g_import_block) AND
           l_flg_previously_imported = pk_alert_constant.g_yes)
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    
    END get_dimmed_flg;

    /**
    * Get the flag_select that indicates if the registry should be selected by default in the import screen.
    * If the record had already been imported it should not be selected even though it is configured to be selected by default.
    *
    * @param i_flg_selected                Y-Record configured to be selected by default. N-otherwise
    * @param i_flg_previously_imported     Y-Record that had already been imported. N-otherwise
    * @param i_flg_status                  Y-Record status. O -ongoing; F - finalized; I - inactive
    *
    * @return                 A-record selected by default. N-otherwise     
    *
    * @author               Sofia Mendes
    * @version              2.6.1.2
    * @since                29-09-2011
    */
    FUNCTION get_selected_flg
    (
        i_flg_selected            IN pn_dblock_ttp_mkt.flg_selected%TYPE,
        i_flg_previously_imported IN VARCHAR2,
        i_flg_status              IN task_timeline_ea.flg_ongoing%TYPE
    ) RETURN VARCHAR2 IS
        l_res VARCHAR2(1char) := pk_alert_constant.g_no;
    BEGIN
    
        IF (i_flg_previously_imported = pk_alert_constant.g_yes)
        THEN
            l_res := pk_alert_constant.g_no;
        ELSE
        
            IF i_flg_selected = pk_alert_constant.g_yes
            THEN
                l_res := pk_prog_notes_constants.g_selected;
            ELSE
                IF (i_flg_status = pk_prog_notes_constants.g_finalized_f)
                THEN
                    IF (instr(i_flg_selected, pk_prog_notes_constants.g_finalized_f) > 0)
                    THEN
                        l_res := pk_prog_notes_constants.g_selected;
                    END IF;
                ELSIF i_flg_status = pk_prog_notes_constants.g_ongoing_o
                THEN
                    IF instr(i_flg_selected, pk_prog_notes_constants.g_ongoing_o) > 0
                    THEN
                        l_res := pk_prog_notes_constants.g_selected;
                    END IF;
                
                ELSIF i_flg_status = pk_prog_notes_constants.g_inactive_i
                THEN
                    IF instr(i_flg_selected, pk_prog_notes_constants.g_inactive_i) > 0
                    THEN
                        l_res := pk_prog_notes_constants.g_selected;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN l_res;
    
    END get_selected_flg;

    /**
    * For each data block in the import screen calculates the nr of child records
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note identifier   
    * @param io_data_blocks           Data blocks info
    * @param io_imported_data         Data to be imported   
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                24-01-2012
    */

    FUNCTION get_childs_nr
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        io_data_blocks   IN OUT t_coll_data_blocks,
        io_imported_data IN OUT t_coll_pn_work_data,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_cursor_data_blocks_count PLS_INTEGER;
    BEGIN
    
        g_error := 'LOOP THROUGH THE DATA BLOCKS CURSOR';
        pk_alertlog.log_debug(g_error);
        l_cursor_data_blocks_count := io_data_blocks.count;
        FOR i IN 1 .. l_cursor_data_blocks_count
        LOOP
            IF (io_data_blocks(i).flg_type = pk_prog_notes_constants.g_type_replace_dblock AND io_data_blocks(i)
               .flg_last_struct_level = pk_alert_constant.g_yes)
            THEN
                --in the last level of the import scruture we have to count the childs of the parent data block 
                --(not considering the import structure)
                g_error := 'CALL pk_prog_notes_utils.count_child. id_soap_block: ' || io_data_blocks(i).block_id ||
                           ' id_parent_no_struct: ' || io_data_blocks(i).id_parent_no_struct;
                pk_alertlog.log_debug(g_error);
                io_data_blocks(i).count_child := pk_prog_notes_utils.get_count_nr_records(i_lang              => i_lang,
                                                                                          i_prof              => i_prof,
                                                                                          i_data              => io_imported_data,
                                                                                          i_id_prt_data_block => io_data_blocks(i).id_pn_data_block,
                                                                                          i_id_pn_soap_block  => io_data_blocks(i).block_id);
            
            ELSIF (io_data_blocks(i).flg_type = pk_prog_notes_constants.g_type_replace_dblock)
            THEN
                --in the intermediate levels of the import structure we have to check if there is some childs of the current data block
                --not considering the results
                g_error := 'CALL pk_prog_notes_utils.count_child_no_hierarc. id_soap_block: ' || io_data_blocks(i).block_id ||
                           ' id_pn_data_block: ' || io_data_blocks(i).id_pn_data_block || ' id_parent_no_struct: ' || io_data_blocks(i).id_parent_no_struct;
                pk_alertlog.log_debug(g_error);
                io_data_blocks(i).count_child := pk_prog_notes_utils.count_child_struct(i_pn_soap_block => io_data_blocks(i).block_id,
                                                                                        i_pn_data_block => io_data_blocks(i).id_pn_data_block,
                                                                                        i_data_block    => io_data_blocks,
                                                                                        i_data          => io_imported_data);
            ELSE
                g_error := 'CALL pk_prog_notes_utils.count_child. id_soap_block: ' || io_data_blocks(i).block_id ||
                           ' id_pn_data_block: ' || io_data_blocks(i).id_pn_data_block;
                pk_alertlog.log_debug(g_error);
                io_data_blocks(i).count_child := pk_prog_notes_utils.count_child(io_data_blocks  (i).block_id,
                                                                                 io_data_blocks  (i).id_pn_data_block,
                                                                                 io_data_blocks,
                                                                                 io_imported_data);
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_CHILDS_NR',
                                              o_error);
        
            RETURN FALSE;
    END get_childs_nr;

    /**
    * Replaces the extra import sctructure that should be replaced by the date, group or subgroup
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_id_epis_pn             Note identifier   
    * @param io_data_blocks           Data blocks info
    * @param io_imported_data         Data to be imported   
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                24-01-2012
    */

    FUNCTION get_extra_import_struct
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        io_data_blocks   IN OUT t_coll_data_blocks,
        io_imported_data IN OUT t_coll_pn_work_data,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_import_data_internal EXCEPTION;
    
        l_id_parent_no_struct table_number := table_number();
        l_id_pn_data_block    pn_data_block.id_pn_data_block%TYPE;
        l_id_parent_dblock    pn_data_block.id_pndb_parent%TYPE;
        l_last_level          VARCHAR2(1 CHAR) := NULL;
        l_rank                PLS_INTEGER := 1;
        l_index               PLS_INTEGER;
        l_prt_no_struct_cfgs  t_rec_data_blocks;
        l_prev_prt_no_struct  pn_data_block.id_pndb_parent%TYPE;
        l_dblock_str          pk_translation.t_desc_translation;
        l_parent_str          pk_translation.t_desc_translation;
        l_prev_data_block     pn_data_block.id_pn_data_block%TYPE;
    BEGIN
        g_error := 'LOOP THROUGHT THE IMPORT STRUCTURE DATA BLOCKS';
        pk_alertlog.log_debug(g_error);
        --Get the import structure data blocks        
        FOR rec IN (SELECT *
                      FROM (SELECT res.*, tdb.*
                              FROM (SELECT /*+opt_estimate(table,id,scale_rows=0.1)*/
                                     id.id_pn_soap_block,
                                     id.id_pn_data_block,
                                     id.id_task,
                                     id.id_task_aggregator,
                                     id.dt_register,
                                     pk_prog_notes_utils.get_group_desc(i_lang                   => i_lang,
                                                                        i_prof                   => i_prof,
                                                                        i_id_task_type           => id.id_task_type,
                                                                        i_dt_group_import        => id.dt_group_import,
                                                                        i_code_desc_group        => id.code_desc_group,
                                                                        i_code_desc_group_parent => id.code_desc_group_parent) group_sub_title,
                                     pk_prog_notes_utils.get_sub_group_desc(i_lang                  => i_lang,
                                                                            i_prof                  => i_prof,
                                                                            i_code_desc_sub_group   => id.code_desc_sub_group,
                                                                            i_code_desc_sample_type => id.code_desc_sample_type) group_sub_sub_title,
                                     id.id_task_type,
                                     id.id_group_import id_sub_group,
                                     to_number(id.id_sub_group_import || CASE
                                                    WHEN id.id_sample_type IS NOT NULL THEN
                                                     '0' || id.id_sample_type
                                                    ELSE
                                                     ''
                                                END) id_sub_sub_group,
                                     rownum imprn
                                      FROM TABLE(io_imported_data) id) res
                              JOIN (SELECT /*+opt_estimate(table,t,scale_rows=0.0001)*/
                                    t.id_pn_data_block id_data_block,
                                    t.id_pndb_parent id_parent_dblock,
                                    t.area_level,
                                    t.block_id,
                                    pk_prog_notes_utils.get_parent_no_struct(i_lang             => i_lang,
                                                                             i_prof             => i_prof,
                                                                             i_dblocks          => io_data_blocks,
                                                                             i_id_pn_data_block => t.id_pn_data_block,
                                                                             i_id_pn_soap_block => t.block_id) id_parent_no_struct,
                                    t.flg_show_sub_title,
                                    t.flg_type
                                     FROM TABLE(io_data_blocks) t
                                    WHERE flg_type IN (pk_prog_notes_constants.g_dblock_strut_date,
                                                       pk_prog_notes_constants.g_dblock_strut_group,
                                                       pk_prog_notes_constants.g_dblock_strut_subgroup)) tdb
                                ON tdb.id_parent_no_struct = res.id_pn_data_block
                               AND tdb.block_id = res.id_pn_soap_block)
                     ORDER BY dt_register DESC, id_task, id_task_aggregator, area_level)
        LOOP
        
            --CALC id_data_block        
            g_error := 'CALL pk_prog_notes_utils.get_id_dblock_prt_imp. i_id_parent_dblock: ' || rec.id_parent_dblock ||
                       ' i_prev_id_data_block: ' || l_id_pn_data_block;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_id_dblock_prt_imp(i_lang               => i_lang,
                                                             i_prof               => i_prof,
                                                             i_id_parent_dblock   => rec.id_parent_dblock,
                                                             i_prev_id_data_block => l_id_pn_data_block,
                                                             i_prev_dblock_str    => l_dblock_str,
                                                             o_id_parent          => l_id_parent_dblock,
                                                             o_id_parent_str      => l_parent_str,
                                                             o_error              => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_prev_data_block := l_id_pn_data_block;
            g_error           := 'CALL pk_prog_notes_utils.get_id_data_block_imp. i_id_parent_no_struct: ' ||
                                 rec.id_parent_no_struct || ' i_id_data_block: ' || rec.id_data_block ||
                                 ' i_id_sub_group: ' || rec.id_sub_group || ' i_id_sub_sub_group: ' ||
                                 rec.id_sub_sub_group;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_id_data_block_imp(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_id_parent_no_struct   => rec.id_parent_no_struct,
                                                             i_dblock_flg_type       => rec.flg_type,
                                                             i_id_dblock_parent      => l_parent_str,
                                                             i_id_pn_soap_block      => rec.block_id,
                                                             i_date                  => rec.dt_register,
                                                             i_id_sub_group          => rec.id_sub_group,
                                                             i_id_sub_sub_group      => rec.id_sub_sub_group,
                                                             o_id_pn_data_block      => l_id_pn_data_block,
                                                             o_id_dblock_no_checksum => l_dblock_str,
                                                             o_error                 => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'CALC last level. CALL pk_prog_notes_utils.get_count_childs i_id_prt_data_block: ' ||
                       rec.id_data_block;
            pk_alertlog.log_debug(g_error);
            l_last_level := CASE
                                WHEN pk_prog_notes_utils.get_count_childs(i_lang              => i_lang,
                                                                          i_prof              => i_prof,
                                                                          i_dblocks           => io_data_blocks,
                                                                          i_id_prt_data_block => rec.id_data_block,
                                                                          i_id_pn_soap_block  => rec.block_id) = 0 THEN
                                 pk_alert_constant.g_yes
                                ELSE
                                 NULL
                            END;
        
            IF (l_last_level = pk_alert_constant.g_yes)
            THEN
                io_imported_data(rec.imprn).id_parent_struct_imp := l_id_pn_data_block; --l_prev_data_block;
            END IF;
        
            g_error := 'CALL pk_prog_notes_utils.check_exists_data_block';
            pk_alertlog.log_debug(g_error);
            IF (pk_prog_notes_utils.check_exists_data_block(i_lang             => i_lang,
                                                            i_prof             => i_prof,
                                                            i_id_pn_data_block => l_id_pn_data_block,
                                                            i_id_pn_soap_block => rec.id_pn_soap_block,
                                                            i_id_dblock_parent => l_id_parent_dblock,
                                                            i_dblocks          => io_data_blocks) = 0)
            THEN
                -- Get configs from rec.id_parent_no_struct
                IF (rec.id_parent_no_struct <> l_prev_prt_no_struct OR l_prev_prt_no_struct IS NULL)
                THEN
                    l_index := pk_prog_notes_utils.search_tab_data_blocks(i_table      => io_data_blocks,
                                                                          i_data_block => rec.id_parent_no_struct);
                
                    IF (l_index > 0)
                    THEN
                        l_prt_no_struct_cfgs := io_data_blocks(l_index);
                        l_prev_prt_no_struct := rec.id_parent_no_struct;
                    END IF;
                
                    --save the id_parents that have import strucutre data blocks between the parent dblock and the results
                    -- in order to the possible to do not show the results imediatly after the parent data block
                    l_id_parent_no_struct.extend;
                    l_id_parent_no_struct(l_id_parent_no_struct.last) := rec.id_parent_no_struct;
                
                END IF;
            
                -- Replace the generic data blocks by the data collected in the import: Date, groups and sub groups
                io_data_blocks.extend;
                io_data_blocks(io_data_blocks.last) := t_rec_data_blocks(rec.id_pn_soap_block,
                                                                         l_id_pn_data_block,
                                                                         l_id_parent_dblock,
                                                                         l_prt_no_struct_cfgs.data_area,
                                                                         l_prt_no_struct_cfgs.id_doc_area,
                                                                         pk_prog_notes_utils.get_imp_dblock_desc(i_lang                => i_lang,
                                                                                                                 i_prof                => i_prof,
                                                                                                                 i_dblock_flg_type     => rec.flg_type,
                                                                                                                 i_date_desc           => pk_date_utils.dt_chr_tsz(i_lang => i_lang,
                                                                                                                                                                   i_date => rec.dt_register,
                                                                                                                                                                   i_inst => i_prof.institution,
                                                                                                                                                                   i_soft => i_prof.software),
                                                                                                                 i_sub_group_title     => rec.group_sub_title,
                                                                                                                 i_sub_sub_group_title => rec.group_sub_sub_title),
                                                                         pk_prog_notes_constants.g_type_replace_dblock,
                                                                         l_prt_no_struct_cfgs.flg_import,
                                                                         rec.area_level,
                                                                         l_prt_no_struct_cfgs.flg_scope,
                                                                         l_prt_no_struct_cfgs.flg_selected,
                                                                         l_prt_no_struct_cfgs.flg_actions_available,
                                                                         l_prt_no_struct_cfgs.id_swf_file_viewer,
                                                                         l_prt_no_struct_cfgs.flg_line_on_boxes,
                                                                         l_prt_no_struct_cfgs.gender,
                                                                         l_prt_no_struct_cfgs.age_min,
                                                                         l_prt_no_struct_cfgs.age_max,
                                                                         l_prt_no_struct_cfgs.flg_pregnant,
                                                                         l_prt_no_struct_cfgs.flg_auto_populated,
                                                                         l_prt_no_struct_cfgs.flg_cp_no_changes_import,
                                                                         CASE
                                                                             WHEN rec.flg_type = pk_prog_notes_constants.g_dblock_strut_date THEN
                                                                              l_rank
                                                                             ELSE
                                                                              NULL
                                                                         END,
                                                                         rec.id_task_type,
                                                                         l_prt_no_struct_cfgs.flg_import_date,
                                                                         l_prt_no_struct_cfgs.flg_outside_period,
                                                                         l_prt_no_struct_cfgs.days_available_period,
                                                                         l_prt_no_struct_cfgs.id_pn_task_type_prt,
                                                                         l_prt_no_struct_cfgs.review_context,
                                                                         l_prt_no_struct_cfgs.flg_group_on_import,
                                                                         rec.id_parent_no_struct,
                                                                         NULL,
                                                                         --if we are in the last level of the hierarqchy we will after this level
                                                                         -- show the results associated to the parent (not considering the import structural levels) data block
                                                                         l_last_level,
                                                                         NULL,
                                                                         rec.flg_show_sub_title,
                                                                         NULL,
                                                                         l_prt_no_struct_cfgs.flg_data_removable,
                                                                         l_prt_no_struct_cfgs.auto_pop_exec_prof_cat,
                                                                         l_prt_no_struct_cfgs.id_summary_page,
                                                                         l_prt_no_struct_cfgs.flg_focus,
                                                                         l_prt_no_struct_cfgs.flg_editable,
                                                                         l_prt_no_struct_cfgs.flg_import_filter,
                                                                         l_prt_no_struct_cfgs.flg_ea,
                                                                         l_prt_no_struct_cfgs.last_n_records_nr,
                                                                         l_prt_no_struct_cfgs.flg_group_select_filter,
                                                                         NULL,
                                                                         l_prt_no_struct_cfgs.flg_shortcut_filter,
                                                                         l_prt_no_struct_cfgs.review_cat,
                                                                         l_prt_no_struct_cfgs.flg_review_avail,
                                                                         l_prt_no_struct_cfgs.flg_description,
                                                                         l_prt_no_struct_cfgs.description_condition,
                                                                         l_prt_no_struct_cfgs.id_mtos_score,
                                                                         l_prt_no_struct_cfgs.flg_dt_task,
                                                                         l_prt_no_struct_cfgs.flg_exc_sum_page_da,
                                                                         l_prt_no_struct_cfgs.flg_group_type);
            
                --rank to be used to sort the dates   
                IF (rec.flg_type = pk_prog_notes_constants.g_dblock_strut_date)
                THEN
                    l_rank := l_rank + 1;
                END IF;
            
            END IF;
        END LOOP;
    
        g_error := 'MARK THE DATA BLOCKS FROM IMPORT STRUCT IN THE LAST LEVEL';
        pk_alertlog.log_debug(g_error);
        --Get the import structure data blocks        
        FOR rec IN (SELECT db.*, t.*
                      FROM (SELECT id_pn_data_block, rownum rndb
                              FROM TABLE(io_data_blocks)) db
                      JOIN TABLE(l_id_parent_no_struct) t
                        ON db.id_pn_data_block = t.column_value)
        LOOP
        
            io_data_blocks(rec.rndb).flg_has_struct_levels := pk_alert_constant.g_yes;
        
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EXTRA_IMPORT_STRUCT',
                                              o_error);
        
            RETURN FALSE;
    END get_extra_import_struct;

    /**
    * Returns the notes to the import screen
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_epis_pn             Note identifier
    * @param o_data                   Grid data level x    
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                15-Mar-2012
    */

    FUNCTION get_import_cursor
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_episode            IN episode.id_episode%TYPE,
        i_id_epis_pn         IN epis_pn.id_epis_pn%TYPE,
        i_cursor_data_blocks IN t_coll_data_blocks,
        i_cursor_pn_data     IN t_coll_pn_work_data,
        i_id_record          IN PLS_INTEGER,
        i_level              IN PLS_INTEGER,
        i_note_type_cfg      IN t_rec_note_type,
        o_data               OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(17 CHAR) := 'GET_IMPORT_CURSOR';
    BEGIN
        g_error := 'open o_data';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        OPEN o_data FOR
            SELECT t.id_pndb_parent,
                   t.block_id,
                   t.id_pn_data_block,
                   t.area_name,
                   t.table_origin,
                   t.task_description,
                   t.id_task id_task,
                   t.id_task_aggregator,
                   t.id_task_type,
                   t.dt_reg,
                   t.dt_register,
                   t.task,
                   t.flg_selected,
                   t.flg_cp_no_changes_import,
                   t.rank,
                   t.flg_import_date,
                   t.task_desc_with_date,
                   t.flg_previously_imported,
                   t.flg_dimmed,
                   t.id_professional,
                   t.id_episode,
                   t.flg_review,
                   t.flg_show_sub_title,
                   t.flg_state_review,
                   t.flg_state_remove,
                   t.flg_select_in_group,
                   t.id_parent_comments,
                   t.id_task_type_comment,
                   t.flg_has_comments,
                   t.flg_parent_imported,
                   t.flg_reviewed_epis,
                   t.review_context,
                   t.dt_last_update_task,
                   t.id_group_table,
                   t.flg_select_by_status,
                   t.flg_group_select_filter,
                   rownum + i_id_record id_record
              FROM (SELECT /*+opt_estimate(table,imp,scale_rows=0.000001)*/ /*+opt_estimate(table,rb,scale_rows=0.00001)*/
                    DISTINCT imp.id_pndb_parent,
                             imp.block_id,
                             imp.id_pn_data_block,
                             imp.area_name,
                             NULL table_origin,
                             nvl(rb.area_name, imp.area_name) || ' ' ||
                             pk_string_utils.surround(imp.count_child, pk_string_utils.g_pattern_parenthesis) task_description,
                             NULL id_task, --Only for last level
                             NULL id_task_aggregator,
                             NULL id_task_type, --Only for last level
                             NULL dt_reg,
                             NULL dt_register,
                             NULL task,
                             NULL flg_selected,
                             NULL flg_cp_no_changes_import,
                             imp.rank,
                             imp.flg_import_date,
                             NULL task_desc_with_date,
                             NULL flg_previously_imported,
                             NULL flg_dimmed,
                             NULL id_professional,
                             NULL id_episode,
                             NULL flg_review,
                             imp.flg_show_sub_title,
                             NULL flg_state_review,
                             NULL flg_state_remove,
                             NULL flg_select_in_group,
                             NULL id_parent_comments,
                             NULL sort_id,
                             NULL sort_desc,
                             NULL sort_date,
                             NULL id_task_type_comment,
                             NULL flg_has_comments,
                             NULL flg_parent_imported,
                             NULL flg_reviewed_epis,
                             NULL review_context,
                             NULL dt_last_update_task,
                             NULL id_group_table,
                             NULL table_position,
                             NULL flg_select_by_status,
                             imp.flg_group_select_filter,
                             NULL rank_task
                      FROM TABLE(i_cursor_data_blocks) imp
                      LEFT JOIN TABLE(i_cursor_pn_data) rb
                        ON ((imp.id_pn_data_block = rb.id_pn_data_block) AND imp.block_id = rb.id_pn_soap_block)
                     WHERE imp.area_level = i_level
                       AND (imp.count_child > 0 /*OR rb.task_description IS NOT NULL*/
                           )
                    UNION ALL
                    SELECT t_int.id_pn_data_block id_pndb_parent,
                           t_int.block_id,
                           t_int.id_pn_data_block,
                           t_int.area_name,
                           t_int.table_origin,
                           t_int.task_description,
                           t_int.id_task id_task,
                           t_int.id_task_aggregator,
                           t_int.id_task_type,
                           t_int.dt_reg,
                           t_int.dt_register,
                           t_int.task,
                           (SELECT get_selected_flg(t_int.flg_selected, t_int.flg_previously_imported, t_int.flg_ongoing)
                              FROM dual) flg_selected,
                           t_int.flg_cp_no_changes_import,
                           t_int.rank,
                           t_int.flg_import_date,
                           t_int.task_desc_with_date,
                           t_int.flg_previously_imported,
                           get_dimmed_flg(i_lang,
                                          i_prof,
                                          i_episode,
                                          i_id_epis_pn,
                                          t_int.id_task,
                                          t_int.id_task_aggregator,
                                          t_int.id_task_type,
                                          t_int.id_pn_data_block,
                                          t_int.block_id,
                                          t_int.flg_import,
                                          t_int.flg_previously_imported) flg_dimmed,
                           t_int.id_professional,
                           t_int.id_episode,
                           (SELECT get_review_flg(i_current_episode     => i_episode,
                                                  i_imported_episode    => t_int.id_episode,
                                                  i_flg_review          => i_note_type_cfg.flg_review_all,
                                                  i_flg_review_avail    => t_int.flg_review_avail,
                                                  i_flg_auto_populated  => NULL,
                                                  i_flg_reviewed_epis   => t_int.flg_reviewed_epis,
                                                  i_review_context      => t_int.review_context,
                                                  i_id_task_type        => t_int.id_task_type,
                                                  i_flg_suggest_concept => i_note_type_cfg.flg_suggest_concept,
                                                  i_flg_editable        => t_int.flg_editable,
                                                  i_flg_status          => NULL)
                              FROM dual) flg_review,
                           t_int.flg_show_sub_title,
                           pk_prog_notes_constants.g_review_action flg_state_review,
                           pk_prog_notes_constants.g_epis_pn_det_sug_rem_i flg_state_remove,
                           (SELECT get_flg_select_in_group(i_flg_review_all => i_note_type_cfg.flg_review_all,
                                                           i_id_task_type   => t_int.id_task_type)
                              FROM dual) flg_select_in_group,
                           t_int.id_parent_comments,
                           t_int.sort_id,
                           CASE
                               WHEN t_int.id_parent_comments IS NULL THEN
                                t_int.task_description
                               ELSE
                                NULL
                           END sort_desc,
                           CASE
                               WHEN t_int.id_parent_comments IS NULL THEN
                                t_int.dt_register_tstz
                               ELSE
                                (SELECT get_parent_date(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_cursor_pn_data      => i_cursor_pn_data,
                                                        i_id_task_parent      => t_int.id_parent_comments,
                                                        i_id_task_type_parent => t_int.id_task_type_comment)
                                   FROM dual)
                           END sort_date,
                           t_int.id_task_type_comment,
                           t_int.flg_has_comments,
                           t_int.flg_parent_imported,
                           t_int.flg_reviewed_epis,
                           t_int.review_context,
                           pk_date_utils.date_send_tsz(i_lang, t_int.dt_last_update_task, i_prof) dt_last_update_task,
                           t_int.id_group_table,
                           t_int.table_position,
                           (SELECT pk_prog_notes_utils.get_flg_select_by_status(i_lang                    => i_lang,
                                                                                i_prof                    => i_prof,
                                                                                i_flg_task_stauts         => t_int.flg_ongoing,
                                                                                i_flg_group_select_filter => t_int.flg_group_select_filter)
                              FROM dual) flg_select_by_status,
                           t_int.flg_group_select_filter,
                           t_int.rank_task
                      FROM (SELECT /*+opt_estimate(table,imp,scale_rows=0.000001)*/ /*+opt_estimate(table,rb,scale_rows=0.00001)*/
                             imp.id_pn_data_block id_pndb_parent,
                             imp.block_id,
                             rb.id_pn_data_block,
                             imp.area_name,
                             rb.table_origin,
                             pk_string_utils.clob_to_plsqlvarchar2(rb.task_description) task_description,
                             rb.id_task id_task,
                             rb.id_task_aggregator,
                             rb.id_task_type,
                             rb.dt_reg,
                             pk_date_utils.date_send_tsz(i_lang, rb.dt_register, i_prof) dt_register,
                             rb.dt_register dt_register_tstz,
                             pk_string_utils.clob_to_plsqlvarchar2(rb.task) task,
                             imp.flg_selected flg_selected,
                             (SELECT get_cp_no_changes_flg(imp.flg_cp_no_changes_import)
                                FROM dual) flg_cp_no_changes_import,
                             imp.rank,
                             imp.flg_import_date,
                             pk_string_utils.clob_to_plsqlvarchar2(rb.task) task_desc_with_date,
                             pk_prog_notes_utils.check_imported_record(i_lang,
                                                                       i_prof,
                                                                       i_episode,
                                                                       i_id_epis_pn,
                                                                       rb.id_task,
                                                                       rb.id_task_aggregator,
                                                                       rb.id_task_type,
                                                                       rb.id_pn_data_block,
                                                                       rb.id_pn_soap_block,
                                                                       pk_alert_constant.g_no) flg_previously_imported,
                             rb.id_professional,
                             rb.id_episode,
                             imp.flg_import,
                             imp.review_context,
                             rb.flg_reviewed_epis,
                             imp.flg_auto_populated,
                             imp.flg_show_sub_title,
                             imp.flg_actions_available,
                             rb.id_parent_comments,
                             rb.flg_has_comments,
                             CASE
                                  WHEN rb.id_parent_comments IS NULL THEN
                                   rb.id_task
                                  ELSE
                                   rb.id_parent_comments
                              END sort_id,
                             rb.parent_task_type id_task_type_comment,
                             rb.flg_parent_imported,
                             rb.dt_task dt_last_update_task,
                             rb.flg_ongoing,
                             rb.id_group_table,
                             rb.table_position,
                             imp.flg_editable,
                             imp.flg_group_select_filter,
                             rb.rank rank_task,
                             imp.flg_review_avail
                              FROM TABLE(i_cursor_data_blocks) imp
                              JOIN TABLE(i_cursor_pn_data) rb
                                ON ((
                                   
                                    (imp.id_pn_data_block = rb.id_pn_data_block AND
                                    (imp.flg_has_struct_levels <> pk_alert_constant.g_yes OR
                                    imp.flg_has_struct_levels IS NULL)) OR
                                    rb.id_pn_data_block = imp.id_parent_no_struct AND
                                    rb.id_parent_struct_imp = imp.id_pn_data_block AND
                                    imp.flg_last_struct_level = pk_alert_constant.g_yes
                                   
                                   ) AND imp.block_id = rb.id_pn_soap_block AND (imp.id_pn_task_type = rb.id_task_type))
                             WHERE imp.area_level = i_level - 1
                               AND rb.flg_parent_imported = pk_alert_constant.g_yes) t_int) t
             ORDER BY t.rank, t.rank_task, sort_date DESC NULLS LAST, t.sort_desc NULLS LAST, t.sort_id;
    
        pk_types.open_cursor_if_closed(i_cursor => o_data);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_data);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_import_cursor;

    /**
    * Get the parent description.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_cursor_pn_data         Imported data
    * @param i_id_task_parent         Parent task ID
    * @param i_id_task_type_parent    Parent task type    
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                09-Mai-2012
    */

    FUNCTION get_parent_desc
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_cursor_pn_data      IN t_coll_pn_work_data,
        i_id_task_parent      IN epis_pn_det_task.id_task%TYPE,
        i_id_task_type_parent IN epis_pn_det_task.id_task_type%TYPE
    ) RETURN epis_pn_det_task.pn_note%TYPE IS
        l_func_name        VARCHAR2(17 CHAR) := 'GET_PARENT_DESC';
        l_task_description epis_pn_det_task.pn_note%TYPE;
        l_error            t_error_out;
    BEGIN
        g_error := 'open o_data';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        SELECT /*+opt_estimate(table,t,scale_rows=0.0000001)*/
         t.task_description
          INTO l_task_description
          FROM TABLE(i_cursor_pn_data) t
         WHERE t.id_task = i_id_task_parent
           AND t.id_task_type = i_id_task_type_parent;
    
        RETURN l_task_description;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
        
            RETURN NULL;
    END get_parent_desc;

    /**
    * Get the parent registration date.
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_cursor_pn_data         Imported data
    * @param i_id_task_parent         Parent task ID
    * @param i_id_task_type_parent    Parent task type    
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Sofia Mendes
    * @version              2.6.2
    * @since                09-Mai-2012
    */

    FUNCTION get_parent_date
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_cursor_pn_data      IN t_coll_pn_work_data,
        i_id_task_parent      IN epis_pn_det_task.id_task%TYPE,
        i_id_task_type_parent IN epis_pn_det_task.id_task_type%TYPE
    ) RETURN epis_pn_det_task.dt_task%TYPE IS
        l_func_name        VARCHAR2(17 CHAR) := 'GET_PARENT_DATE';
        l_task_dt_register TIMESTAMP WITH LOCAL TIME ZONE;
        l_error            t_error_out;
    BEGIN
        g_error := 'GET PARENT DATE REGISTER. i_id_task_parent: ' || i_id_task_parent || ' i_id_task_type_parent: ' ||
                   i_id_task_type_parent;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        SELECT /*+opt_estimate(table,t,scale_rows=0.0000001)*/
         t.dt_register
          INTO l_task_dt_register
          FROM TABLE(i_cursor_pn_data) t
         WHERE t.id_task = i_id_task_parent
           AND t.id_task_type = i_id_task_type_parent;
    
        RETURN l_task_dt_register;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
        
            RETURN NULL;
    END get_parent_date;

    /**
    * Returns the notes to the import screen
    *
    * @param i_lang                   language identifier
    * @param i_prof                   logged professional structure
    * @param i_episode                episode identifier
    * @param i_id_pn_note_type        Note type identifier
    * @param i_id_epis_pn             Note identifier    
    * @param o_data_1                 Grid data level 1
    * @param o_data_2                 Grid data level 2
    * @param o_data_3                 Grid data level 3
    * @param o_data_4                 Grid data level 4
    * @param o_data_5                 Grid data level 5
    * @param o_error                  error
    *
    * @return                         false if errors occur, true otherwise
    *
    * @author               Rui Spratley
    * @version              2.6.0.5
    * @since                07-02-2011
    */

    FUNCTION get_import_data
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_patient         IN patient.id_patient%TYPE,
        i_id_pn_note_type IN pn_note_type.id_pn_note_type%TYPE,
        i_id_epis_pn      IN epis_pn.id_epis_pn%TYPE,
        o_data_1          OUT pk_types.cursor_type,
        o_data_2          OUT pk_types.cursor_type,
        o_data_3          OUT pk_types.cursor_type,
        o_data_4          OUT pk_types.cursor_type,
        o_data_5          OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_import_data_internal EXCEPTION;
    
        l_func_name CONSTANT VARCHAR2(15 CHAR) := 'GET_IMPORT_DATA';
    
        l_cursor_import      pk_types.cursor_type;
        l_cursor_data_blocks t_coll_data_blocks := t_coll_data_blocks();
        l_cursor_pn_data     t_coll_pn_work_data := t_coll_pn_work_data();
    
        l_pn_note_type t_rec_note_type;
    BEGIN
    
        g_error := 'Call pk_prog_notes_utils.get_note_type_config. i_id_pn_note_type: ' || i_id_pn_note_type;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_pn_note_type := pk_prog_notes_utils.get_note_type_config(i_lang                => i_lang,
                                                                   i_prof                => i_prof,
                                                                   i_id_episode          => i_episode,
                                                                   i_id_profile_template => NULL,
                                                                   i_id_market           => NULL,
                                                                   i_id_department       => NULL,
                                                                   i_id_dep_clin_serv    => NULL,
                                                                   i_id_epis_pn          => NULL,
                                                                   i_id_pn_note_type     => i_id_pn_note_type,
                                                                   i_software            => NULL);
    
        g_error := 'Get data from parametrization function';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF NOT get_data_import(i_lang             => i_lang,
                               i_prof             => i_prof,
                               i_episode          => i_episode,
                               i_patient          => i_patient,
                               i_id_pn_note_type  => i_id_pn_note_type,
                               i_pn_note_type_cfg => l_pn_note_type,
                               i_id_epis_pn       => i_id_epis_pn,
                               o_data_import_list => l_cursor_import,
                               o_data_block       => l_cursor_data_blocks, --Import function
                               o_data             => l_cursor_pn_data, --RB function
                               o_error            => o_error)
        THEN
            g_error := 'No blocks to import';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            pk_types.open_my_cursor(i_cursor => o_data_1);
            pk_types.open_my_cursor(i_cursor => o_data_2);
            pk_types.open_my_cursor(i_cursor => o_data_3);
            pk_types.open_my_cursor(i_cursor => o_data_4);
            pk_types.open_my_cursor(i_cursor => o_data_5);
            RAISE l_import_data_internal;
        END IF;
    
        --GET extra levels that are only configured to the import screen
        --This levels will be replaced by some fileds imported
        g_error := 'CALL get_extra_import_struct';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_extra_import_struct(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       io_data_blocks   => l_cursor_data_blocks,
                                       io_imported_data => l_cursor_pn_data,
                                       o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --because of performance reasons the nr of childs for each data block will be pre-calculated
        g_error := 'CALL get_childs_nr';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_childs_nr(i_lang           => i_lang,
                             i_prof           => i_prof,
                             io_data_blocks   => l_cursor_data_blocks,
                             io_imported_data => l_cursor_pn_data,
                             o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF l_cursor_data_blocks.exists(1)
        THEN
            pk_alertlog.log_info(text            => 'l_cursor_data_blocks',
                                 object_name     => g_package,
                                 sub_object_name => l_func_name);
            FOR i IN 1 .. l_cursor_data_blocks.count
            LOOP
                pk_alertlog.log_info(text            => ' block_id:' || l_cursor_data_blocks(i).block_id ||
                                                        ' id_pn_data_block:' || l_cursor_data_blocks(i).id_pn_data_block ||
                                                        ' id_pndb_parent:' || l_cursor_data_blocks(i).id_pndb_parent ||
                                                        ' data_area:' || l_cursor_data_blocks(i).data_area ||
                                                        ' id_doc_area:' || l_cursor_data_blocks(i).id_doc_area ||
                                                        ' area_name:' || l_cursor_data_blocks(i).area_name ||
                                                        ' flg_type:' || l_cursor_data_blocks(i).flg_type ||
                                                        ' flg_import:' || l_cursor_data_blocks(i).flg_import ||
                                                        ' area_level:' || l_cursor_data_blocks(i).area_level ||
                                                        ' flg_scope:' || l_cursor_data_blocks(i).flg_scope ||
                                                        ' flg_selected:' || l_cursor_data_blocks(i).flg_selected ||
                                                        ' flg_actions_available:' || l_cursor_data_blocks(i).flg_actions_available ||
                                                        ' id_swf_file_viewer:' || l_cursor_data_blocks(i).id_swf_file_viewer ||
                                                        ' flg_line_on_boxes:' || l_cursor_data_blocks(i).flg_line_on_boxes ||
                                                        ' gender:' || l_cursor_data_blocks(i).gender || ' age_min:' || l_cursor_data_blocks(i).age_min ||
                                                        ' age_max:' || l_cursor_data_blocks(i).age_max ||
                                                        ' flg_pregnant:' || l_cursor_data_blocks(i).flg_pregnant ||
                                                        ' flg_auto_populated:' || l_cursor_data_blocks(i).flg_auto_populated ||
                                                        ' flg_cp_no_changes_import:' || l_cursor_data_blocks(i).flg_cp_no_changes_import ||
                                                        ' rank:' || l_cursor_data_blocks(i).rank || ' id_pn_task_type:' || l_cursor_data_blocks(i).id_pn_task_type ||
                                                        ' flg_import_date:' || l_cursor_data_blocks(i).flg_import_date ||
                                                        ' flg_outside_period:' || l_cursor_data_blocks(i).flg_outside_period ||
                                                        ' days_available_period:' || l_cursor_data_blocks(i).days_available_period ||
                                                        ' id_pn_task_type_prt:' || l_cursor_data_blocks(i).id_pn_task_type_prt ||
                                                        ' review_context:' || l_cursor_data_blocks(i).review_context ||
                                                        ' flg_group_on_import:' || l_cursor_data_blocks(i).flg_group_on_import ||
                                                        ' id_parent_no_struct:' || l_cursor_data_blocks(i).id_parent_no_struct ||
                                                        ' flg_has_struct_levels:' || l_cursor_data_blocks(i).flg_has_struct_levels ||
                                                        ' flg_last_struct_level:' || l_cursor_data_blocks(i).flg_last_struct_level ||
                                                        ' count_child:' || l_cursor_data_blocks(i).count_child ||
                                                        ' flg_show_sub_title:' || l_cursor_data_blocks(i).flg_show_sub_title ||
                                                        ' flg_synchronized:' || l_cursor_data_blocks(i).flg_synchronized ||
                                                        ' flg_data_removable:' || l_cursor_data_blocks(i).flg_data_removable ||
                                                        ' auto_pop_exec_prof_cat:' || l_cursor_data_blocks(i).auto_pop_exec_prof_cat ||
                                                        ' id_summary_page:' || l_cursor_data_blocks(i).id_summary_page ||
                                                        ' flg_focus:' || l_cursor_data_blocks(i).flg_focus ||
                                                        ' flg_editable:' || l_cursor_data_blocks(i).flg_editable ||
                                                        ' flg_import_filter:' || l_cursor_data_blocks(i).flg_import_filter ||
                                                        ' flg_ea:' || l_cursor_data_blocks(i).flg_ea ||
                                                        ' last_n_records_nr:' || l_cursor_data_blocks(i).last_n_records_nr ||
                                                        ' flg_group_select_filter:' || l_cursor_data_blocks(i).flg_group_select_filter ||
                                                        ' flg_synch_area:' || l_cursor_data_blocks(i).flg_synch_area ||
                                                        ' flg_shortcut_filter:' || l_cursor_data_blocks(i).flg_shortcut_filter ||
                                                        ' review_cat:' || l_cursor_data_blocks(i).review_cat ||
                                                        ' flg_review_avail:' || l_cursor_data_blocks(i).flg_review_avail,
                                     object_name     => g_package,
                                     sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        IF l_cursor_pn_data.exists(1)
        THEN
            pk_alertlog.log_info(text => 'l_cursor_pn_data', object_name => g_package, sub_object_name => l_func_name);
            FOR i IN 1 .. l_cursor_pn_data.count
            LOOP
                pk_alertlog.log_info(text            => 'area_name:' || l_cursor_pn_data(i).area_name ||
                                                        ' id_pn_soap_block:' || l_cursor_pn_data(i).id_pn_soap_block ||
                                                        ' id_pn_data_block:' || l_cursor_pn_data(i).id_pn_data_block ||
                                                        ' id_parent:' || l_cursor_pn_data(i).id_parent ||
                                                        ' task_description:' || l_cursor_pn_data(i).task_description ||
                                                        ' task:' || l_cursor_pn_data(i).task || ' dt_reg:' || l_cursor_pn_data(i).dt_reg ||
                                                        ' dt_register:' || l_cursor_pn_data(i).dt_register ||
                                                        ' id_professional:' || l_cursor_pn_data(i).id_professional ||
                                                        ' id_task:' || l_cursor_pn_data(i).id_task || ' id_task_type:' || l_cursor_pn_data(i).id_task_type ||
                                                        ' table_origin:' || l_cursor_pn_data(i).table_origin ||
                                                        ' rank:' || l_cursor_pn_data(i).rank || ' flg_import_date:' || l_cursor_pn_data(i).flg_import_date ||
                                                        ' id_episode:' || l_cursor_pn_data(i).id_episode ||
                                                        ' id_parent_struct_imp:' || l_cursor_pn_data(i).id_parent_struct_imp ||
                                                        ' id_task_aggregator:' || l_cursor_pn_data(i).id_task_aggregator ||
                                                        ' flg_reviewed_epis:' || l_cursor_pn_data(i).flg_reviewed_epis ||
                                                        ' review_context:' || l_cursor_pn_data(i).review_context ||
                                                        ' flg_auto_populated:' || l_cursor_pn_data(i).flg_auto_populated ||
                                                        ' flg_import:' || l_cursor_pn_data(i).flg_import ||
                                                        ' flg_data_removable:' || l_cursor_pn_data(i).flg_data_removable ||
                                                        ' flg_synchronized:' || l_cursor_pn_data(i).flg_synchronized ||
                                                        ' id_parent_comments:' || l_cursor_pn_data(i).id_parent_comments ||
                                                        ' flg_has_comments:' || l_cursor_pn_data(i).flg_has_comments ||
                                                        ' parent_task_type:' || l_cursor_pn_data(i).parent_task_type ||
                                                        ' flg_parent_imported:' || l_cursor_pn_data(i).flg_parent_imported ||
                                                        ' dt_task:' || l_cursor_pn_data(i).dt_task || ' flg_type:' || l_cursor_pn_data(i).flg_type ||
                                                        ' flg_ongoing:' || l_cursor_pn_data(i).flg_ongoing ||
                                                        ' flg_selected:' || l_cursor_pn_data(i).flg_selected ||
                                                        ' flg_group_on_import:' || l_cursor_pn_data(i).flg_group_on_import ||
                                                        ' dt_group_import:' || l_cursor_pn_data(i).dt_group_import ||
                                                        ' id_group_import:' || l_cursor_pn_data(i).id_group_import ||
                                                        ' code_desc_group:' || l_cursor_pn_data(i).code_desc_group ||
                                                        ' desc_group:' || l_cursor_pn_data(i).desc_group ||
                                                        ' id_sub_group_import:' || l_cursor_pn_data(i).id_sub_group_import ||
                                                        ' code_desc_sub_group:' || l_cursor_pn_data(i).code_desc_sub_group ||
                                                        ' separator:' || l_cursor_pn_data(i).separator || ' flg_scope:' || l_cursor_pn_data(i).flg_scope ||
                                                        ' id_group_table:' || l_cursor_pn_data(i).id_group_table ||
                                                        ' table_position:' || l_cursor_pn_data(i).table_position ||
                                                        ' flg_editable:' || l_cursor_pn_data(i).flg_editable ||
                                                        ' code_description:' || l_cursor_pn_data(i).code_description ||
                                                        ' universal_description:' || l_cursor_pn_data(i).universal_description ||
                                                        ' flg_sos:' || l_cursor_pn_data(i).flg_sos || ' dt_begin:' || l_cursor_pn_data(i).dt_begin ||
                                                        ' id_doc_area:' || l_cursor_pn_data(i).id_doc_area ||
                                                        ' flg_group_select_filter:' || l_cursor_pn_data(i).flg_group_select_filter ||
                                                        ' flg_show_sub_title:' || l_cursor_pn_data(i).flg_show_sub_title ||
                                                        ' id_prof_review:' || l_cursor_pn_data(i).id_prof_review ||
                                                        ' dt_review:' || l_cursor_pn_data(i).dt_review ||
                                                        ' code_status:' || l_cursor_pn_data(i).code_status ||
                                                        ' dt_end:' || l_cursor_pn_data(i).dt_end || ' id_task_notes:' || l_cursor_pn_data(i).id_task_notes ||
                                                        ' flg_status:' || l_cursor_pn_data(i).flg_status ||
                                                        ' id_sample_type:' || l_cursor_pn_data(i).id_sample_type ||
                                                        ' code_desc_sample_type:' || l_cursor_pn_data(i).code_desc_sample_type ||
                                                        ' flg_review_avail:' || l_cursor_pn_data(i).flg_review_avail,
                                     object_name     => g_package,
                                     sub_object_name => l_func_name);
            END LOOP;
        END IF;
    
        g_error := 'open o_data_1';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        OPEN o_data_1 FOR
            SELECT t.*, rownum id_record
              FROM (SELECT /*+opt_estimate(table,imp,scale_rows=0.000001)*/ /*+opt_estimate(table,rb,scale_rows=0.00001)*/
                    DISTINCT imp.id_pndb_parent,
                             imp.block_id,
                             imp.id_pn_data_block,
                             imp.area_name,
                             NULL table_origin,
                             nvl(rb.area_name, imp.area_name) || ' ' ||
                             pk_string_utils.surround(imp.count_child, pk_string_utils.g_pattern_parenthesis) task_description,
                             NULL flg_selected,
                             NULL flg_cp_no_changes_import,
                             imp.rank,
                             imp.flg_import_date,
                             NULL task_desc_with_date,
                             NULL flg_previously_imported,
                             NULL flg_dimmed,
                             NULL id_professional,
                             NULL id_episode,
                             NULL id_sub_group,
                             NULL group_title,
                             NULL group_sub_title,
                             NULL separator,
                             NULL flg_review,
                             imp.flg_show_sub_title,
                             NULL flg_state_review,
                             NULL flg_state_remove,
                             NULL flg_select_in_group, --to be used to select all the medications records
                             NULL id_parent_comments,
                             NULL flg_has_comments,
                             NULL dt_last_update_task,
                             NULL id_group_table,
                             imp.flg_group_select_filter
                      FROM TABLE(l_cursor_data_blocks) imp
                      LEFT OUTER JOIN TABLE(l_cursor_pn_data) rb
                        ON (imp.id_pn_data_block = rb.id_pn_data_block AND imp.block_id = rb.id_pn_soap_block)
                     WHERE imp.area_level = 1
                       AND (imp.count_child > 0 /*OR rb.task_description IS NOT NULL*/
                           )) t
             ORDER BY t.rank, t.task_description;
    
        g_error := 'open o_data_2. CALL get_import_cursor';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_import_cursor(i_lang               => i_lang,
                                 i_prof               => i_prof,
                                 i_episode            => i_episode,
                                 i_id_epis_pn         => i_id_epis_pn,
                                 i_cursor_data_blocks => l_cursor_data_blocks,
                                 i_cursor_pn_data     => l_cursor_pn_data,
                                 i_id_record          => 1000,
                                 i_level              => 2,
                                 i_note_type_cfg      => l_pn_note_type,
                                 o_data               => o_data_2,
                                 o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'open o_data_3.  CALL get_import_cursor';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_import_cursor(i_lang               => i_lang,
                                 i_prof               => i_prof,
                                 i_episode            => i_episode,
                                 i_id_epis_pn         => i_id_epis_pn,
                                 i_cursor_data_blocks => l_cursor_data_blocks,
                                 i_cursor_pn_data     => l_cursor_pn_data,
                                 i_id_record          => 2000,
                                 i_level              => 3,
                                 i_note_type_cfg      => l_pn_note_type,
                                 o_data               => o_data_3,
                                 o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'open o_data_4.  CALL get_import_cursor';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_import_cursor(i_lang               => i_lang,
                                 i_prof               => i_prof,
                                 i_episode            => i_episode,
                                 i_id_epis_pn         => i_id_epis_pn,
                                 i_cursor_data_blocks => l_cursor_data_blocks,
                                 i_cursor_pn_data     => l_cursor_pn_data,
                                 i_id_record          => 3000,
                                 i_level              => 4,
                                 i_note_type_cfg      => l_pn_note_type,
                                 o_data               => o_data_4,
                                 o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'open o_data_5';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        OPEN o_data_5 FOR
            SELECT t.id_pndb_parent,
                   t.block_id,
                   t.id_pn_data_block,
                   t.area_name,
                   t.table_origin,
                   t.task_description,
                   t.id_task,
                   t.id_task_aggregator,
                   t.id_task_type,
                   t.dt_reg,
                   t.dt_register,
                   t.task,
                   (SELECT get_selected_flg(t.flg_selected, t.flg_previously_imported, t.flg_ongoing)
                      FROM dual) flg_selected,
                   (SELECT get_cp_no_changes_flg(t.flg_cp_no_changes_import)
                      FROM dual) flg_cp_no_changes_import,
                   t.rank,
                   t.flg_import_date,
                   t.task_desc_with_date,
                   t.flg_previously_imported,
                   get_dimmed_flg(i_lang,
                                  i_prof,
                                  i_episode,
                                  i_id_epis_pn,
                                  t.id_task,
                                  t.id_task_aggregator,
                                  t.id_task_type,
                                  t.id_pn_data_block,
                                  t.block_id,
                                  t.flg_import,
                                  t.flg_previously_imported) flg_dimmed,
                   t.id_professional,
                   t.id_episode,
                   rownum + 4000 id_record,
                   (SELECT get_review_flg(i_current_episode     => i_episode,
                                          i_imported_episode    => t.id_episode,
                                          i_flg_review          => l_pn_note_type.flg_review_all,
                                          i_flg_review_avail    => t.flg_review_avail,
                                          i_flg_auto_populated  => NULL,
                                          i_flg_reviewed_epis   => t.flg_reviewed_epis,
                                          i_review_context      => t.review_context,
                                          i_id_task_type        => t.id_task_type,
                                          i_flg_suggest_concept => l_pn_note_type.flg_suggest_concept,
                                          i_flg_editable        => t.flg_editable,
                                          i_flg_status          => NULL)
                      FROM dual) flg_review,
                   t.flg_show_sub_title,
                   pk_prog_notes_constants.g_review_action flg_state_review,
                   pk_prog_notes_constants.g_epis_pn_det_sug_rem_i flg_state_remove,
                   (SELECT get_flg_select_in_group(i_flg_review_all => l_pn_note_type.flg_review_all,
                                                   i_id_task_type   => t.id_task_type)
                      FROM dual) flg_select_in_group,
                   t.id_parent_comments,
                   t.sort_id,
                   CASE
                        WHEN t.id_parent_comments IS NULL THEN
                         t.task_description
                        ELSE
                         NULL
                    END sort_desc,
                   CASE
                        WHEN t.id_parent_comments IS NULL THEN
                         t.dt_register_tstz
                        ELSE
                         (SELECT get_parent_date(i_lang                => i_lang,
                                                 i_prof                => i_prof,
                                                 i_cursor_pn_data      => l_cursor_pn_data,
                                                 i_id_task_parent      => t.id_parent_comments,
                                                 i_id_task_type_parent => t.id_task_type_comment)
                            FROM dual)
                    END sort_date,
                   t.id_task_type_comment,
                   t.flg_has_comments,
                   pk_date_utils.date_send_tsz(i_lang, t.dt_last_update_task, i_prof) dt_last_update_task,
                   t.id_group_table,
                   NULL flg_group_selection,
                   (SELECT pk_prog_notes_utils.get_flg_select_by_status(i_lang                    => i_lang,
                                                                        i_prof                    => i_prof,
                                                                        i_flg_task_stauts         => t.flg_ongoing,
                                                                        i_flg_group_select_filter => t.flg_group_select_filter)
                      FROM dual) flg_select_by_status,
                   t.flg_group_select_filter
              FROM (SELECT /*+opt_estimate(table,imp,scale_rows=0.000001)*/ /*+opt_estimate(table,rb,scale_rows=0.00001)*/
                     imp.id_pn_data_block id_pndb_parent,
                     imp.block_id,
                     rb.id_pn_data_block,
                     imp.area_name,
                     rb.table_origin,
                     pk_string_utils.clob_to_plsqlvarchar2(rb.task_description) task_description,
                     rb.id_task,
                     rb.id_task_aggregator,
                     rb.id_task_type,
                     rb.dt_reg,
                     pk_date_utils.date_send_tsz(i_lang, rb.dt_register, i_prof) dt_register,
                     rb.dt_register dt_register_tstz,
                     pk_string_utils.clob_to_plsqlvarchar2(rb.task) task,
                     imp.flg_selected flg_selected,
                     imp.flg_cp_no_changes_import,
                     imp.rank,
                     imp.flg_import_date,
                     pk_string_utils.clob_to_plsqlvarchar2(rb.task) task_desc_with_date,
                     pk_prog_notes_utils.check_imported_record(i_lang,
                                                               i_prof,
                                                               i_episode,
                                                               i_id_epis_pn,
                                                               rb.id_task,
                                                               rb.id_task_aggregator,
                                                               rb.id_task_type,
                                                               rb.id_pn_data_block,
                                                               rb.id_pn_soap_block,
                                                               pk_alert_constant.g_no) flg_previously_imported,
                     rb.id_professional,
                     rb.id_episode,
                     imp.flg_import,
                     imp.review_context,
                     rb.flg_reviewed_epis,
                     imp.flg_auto_populated,
                     imp.flg_show_sub_title,
                     imp.flg_actions_available,
                     rb.id_parent_comments,
                     rb.flg_has_comments,
                     CASE
                          WHEN rb.id_parent_comments IS NULL THEN
                           rb.id_task
                          ELSE
                           rb.id_parent_comments
                      END sort_id,
                     rb.parent_task_type id_task_type_comment,
                     rb.dt_task dt_last_update_task,
                     rb.flg_ongoing,
                     rb.id_group_table,
                     imp.flg_editable,
                     imp.flg_group_select_filter,
                     rb.rank rank_task,
                     imp.flg_review_avail
                      FROM TABLE(l_cursor_data_blocks) imp
                      JOIN TABLE(l_cursor_pn_data) rb
                        ON ((
                           
                            (imp.id_pn_data_block = rb.id_pn_data_block AND
                            (imp.flg_has_struct_levels <> pk_alert_constant.g_yes OR imp.flg_has_struct_levels IS NULL))
                           
                            OR (rb.id_pn_data_block = imp.id_parent_no_struct AND
                            
                            /*(*/
                            ((rb.id_parent_struct_imp = imp.id_pn_data_block) OR
                            (imp.flg_last_struct_level = pk_alert_constant.g_no))
                            /*OR
                            (rb.id_parent_struct_imp = imp.id_pn_data_block AND
                            imp.flg_last_struct_level = pk_alert_constant.g_yes))*/
                            
                            )) AND imp.block_id = rb.id_pn_soap_block AND (imp.id_pn_task_type = rb.id_task_type))
                     WHERE imp.area_level = 4
                       AND rb.flg_parent_imported = pk_alert_constant.g_yes) t
             ORDER BY t.rank, t.rank_task, sort_date DESC NULLS LAST, sort_desc, t.sort_id;
    
        pk_types.open_cursor_if_closed(i_cursor => o_data_1);
        pk_types.open_cursor_if_closed(i_cursor => o_data_2);
        pk_types.open_cursor_if_closed(i_cursor => o_data_3);
        pk_types.open_cursor_if_closed(i_cursor => o_data_4);
        pk_types.open_cursor_if_closed(i_cursor => o_data_5);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_data_1);
            pk_types.open_my_cursor(i_cursor => o_data_2);
            pk_types.open_my_cursor(i_cursor => o_data_3);
            pk_types.open_my_cursor(i_cursor => o_data_4);
            pk_types.open_my_cursor(i_cursor => o_data_5);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_import_data;

    /**
    * Sends the registry in epis_pn_sign associated to a note to the history tables
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn      Progress note identifier
    * @param   i_epis_pn      Progress note identifier in work table
    *
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  Sofia Mendes
    * @version 2.6.0.5
    * @since   16-Feb-2011
    */
    FUNCTION set_pn_signoff_hist
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_epis_pn            IN epis_pn.id_epis_pn%TYPE,
        i_id_epis_pn_signoff IN epis_pn_signoff.id_epis_pn_signoff%TYPE,
        i_dt_hist            IN epis_pn_signoff_hist.dt_epis_pn_signoff_hist%TYPE,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rows_out table_varchar;
        l_func_name CONSTANT VARCHAR2(19 CHAR) := 'SET_PN_SIGNOFF_HIST';
    
        CURSOR c_epis_pn_signoff IS
            SELECT eso.id_epis_pn_signoff,
                   eso.id_epis_pn,
                   eso.id_pn_soap_block,
                   eso.pn_signoff_note,
                   eso.id_prof_last_update,
                   eso.dt_last_update
              FROM epis_pn_signoff eso
             WHERE eso.id_epis_pn = i_epis_pn
               AND eso.id_epis_pn_signoff = i_id_epis_pn_signoff;
    
        l_rec_epis_pn_signoff c_epis_pn_signoff%ROWTYPE;
    BEGIN
        g_error := 'Get sign off id for update';
        OPEN c_epis_pn_signoff;
        FETCH c_epis_pn_signoff
            INTO l_rec_epis_pn_signoff;
        CLOSE c_epis_pn_signoff;
    
        g_error := 'Update history table';
        ts_epis_pn_signoff_hist.ins(id_epis_pn_signoff_in      => l_rec_epis_pn_signoff.id_epis_pn_signoff,
                                    dt_epis_pn_signoff_hist_in => i_dt_hist,
                                    id_epis_pn_in              => l_rec_epis_pn_signoff.id_epis_pn,
                                    id_pn_soap_block_in        => l_rec_epis_pn_signoff.id_pn_soap_block,
                                    pn_signoff_note_in         => l_rec_epis_pn_signoff.pn_signoff_note,
                                    id_prof_last_update_in     => l_rec_epis_pn_signoff.id_prof_last_update,
                                    dt_last_update_in          => l_rec_epis_pn_signoff.dt_last_update,
                                    rows_out                   => l_rows_out);
    
        g_error := 'PROCESS INSERT epis_pn_signoff_hist WITH id_epis_pn_signoff: ' ||
                   l_rec_epis_pn_signoff.id_epis_pn_signoff;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_SIGNOFF_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_pn_signoff_hist',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_pn_signoff_hist;

    /**
    * Saves a progress note in the definitive tables
    * This function does not support the removal of id_documentation in the note updates
    *
    * @param   i_lang                         Professional preferred language
    * @param   i_prof                         Professional identification and its context (institution and software)
    * @param   i_epis_pn                      Progress note identifier
    * @param   i_id_dictation_report          Dictation report identifier
    * @param   i_id_episode                   Episode identifier
    * @param   i_pn_flg_status                Note flag status
    * @param   i_id_pn_note_type              Note type id
    * @param   i_dt_pn_date                   Note date
    * @param   i_id_dep_clin_serv             Episode dep_clin_serv id
    * @param   i_id_pn_data_block             Pn data block id
    * @param   i_id_pn_soap_block             Pn soap block id
    * @param   i_id_task                      Task ids
    * @param   i_id_task_type                 Task type ids
    * @param   i_pn_note                      Note text
    * @param   i_id_professional              Professional that created/updates the note
    * @param   i_dt_execution                 Date in which the note is being created/updated
    * @param   i_dt_sent_to_hist              Date in which the note was updated
    * @param   i_dt_sent_to_hist              Date in which the note was updated
    * @param   i_id_prof_sign_off             Professional that signed-off the note
    *                                         Mandatory field when creating Signed-off or Migrated records
    * @param   i_dt_sign_off                  Date in which it was performed the sign off
    *                                         Mandatory field when creating Signed-off or Migrated records
    * @param   o_id_epis_pn                   Created/updated note id
    *
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  Sofia Mendes
    * @version 2.6.0.5
    * @since  15-Feb-2011
    */
    FUNCTION set_save_def_note
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_pn             IN epis_pn.id_epis_pn%TYPE,
        i_id_dictation_report IN epis_pn.id_dictation_report%TYPE,
        i_id_episode          IN epis_pn.id_episode%TYPE,
        i_pn_flg_status       IN epis_pn.flg_status%TYPE,
        i_id_pn_note_type     IN pn_note_type.id_pn_note_type%TYPE,
        i_dt_pn_date          IN epis_pn.dt_pn_date%TYPE,
        i_id_dep_clin_serv    IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_id_pn_data_block    IN table_number,
        i_id_pn_soap_block    IN table_number,
        i_id_task             IN table_number,
        i_id_task_type        IN table_number,
        i_pn_note             IN table_clob,
        i_id_professional     IN professional.id_professional%TYPE,
        i_dt_last_update      IN epis_pn.dt_last_update%TYPE DEFAULT NULL,
        i_dt_create           IN epis_pn.dt_create%TYPE DEFAULT NULL,
        i_dt_sent_to_hist     IN epis_pn_signoff_hist.dt_epis_pn_signoff_hist%TYPE,
        i_id_prof_sign_off    IN epis_pn.id_prof_signoff%TYPE,
        i_dt_sign_off         IN epis_pn.dt_signoff%TYPE,
        i_flg_handle_error    IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_id_pn_area          IN NUMBER DEFAULT NULL,
        o_id_epis_pn          OUT epis_pn.id_epis_pn%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rows                table_varchar := table_varchar();
        l_id_epis_pn          epis_pn.id_epis_pn%TYPE;
        l_id_epis_pn_det      epis_pn_det.id_epis_pn_det%TYPE;
        l_id_epis_pn_signoff  epis_pn_signoff.id_epis_pn_signoff%TYPE;
        l_create              VARCHAR2(1) := pk_alert_constant.g_yes;
        l_id_prof_sign_off    epis_pn.id_prof_signoff%TYPE;
        l_dt_sign_off         epis_pn.dt_signoff%TYPE;
        l_id_epis_pn_det_task epis_pn_det_task.id_epis_pn_det_task%TYPE;
        l_id_prof_task        epis_pn_det_task.id_prof_task%TYPE;
        l_rank_task           epis_pn_det_task.rank_task%TYPE;
        l_id_parent           epis_pn_det_task.id_parent%TYPE;
        l_pn_note             epis_pn_det.pn_note%TYPE;
        l_id_pn_area          pn_area.id_pn_area%TYPE;
        l_func_name           VARCHAR2(17 CHAR) := 'SET_SAVE_DEF_NOTE';
        l_new_record          PLS_INTEGER;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF (i_id_dictation_report IS NOT NULL)
        THEN
            BEGIN
                SELECT epn.id_epis_pn
                  INTO l_id_epis_pn
                  FROM epis_pn epn
                 WHERE epn.id_dictation_report = i_id_dictation_report;
            
                l_create := pk_alert_constant.g_no;
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_epis_pn := ts_epis_pn.next_key;
            END;
        ELSIF (i_epis_pn IS NULL)
        THEN
            l_id_epis_pn := ts_epis_pn.next_key;
        ELSE
            l_id_epis_pn := i_epis_pn;
            l_create     := pk_alert_constant.g_no;
        END IF;
    
        --the sign off professional and date should only be set if the status is Signed-off or Migrated
        IF (i_pn_flg_status IN
           (pk_prog_notes_constants.g_epis_pn_flg_status_s, pk_prog_notes_constants.g_epis_pn_flg_status_m))
        THEN
            l_id_prof_sign_off := i_id_prof_sign_off;
            l_dt_sign_off      := i_dt_sign_off;
        ELSE
            l_id_prof_sign_off := NULL;
            l_dt_sign_off      := NULL;
        END IF;
    
        --Update
        g_error := 'Validate if its to insert or update';
        IF l_create = pk_alert_constant.g_no
        THEN
            g_error := 'set_save_def_note';
            IF NOT move_epis_pn_2_hist(i_lang          => i_lang,
                                       i_prof          => i_prof,
                                       i_epis_pn       => l_id_epis_pn,
                                       i_flg_type      => pk_prog_notes_constants.g_flg_type_md,
                                       i_dt_hist       => i_dt_sent_to_hist,
                                       i_id_episode_pn => i_id_episode,
                                       o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            --updating - last update fields must be updated
            g_error := 'Update';
            ts_epis_pn.upd(id_epis_pn_in          => l_id_epis_pn,
                           id_episode_in          => i_id_episode,
                           flg_status_in          => i_pn_flg_status,
                           dt_pn_date_in          => i_dt_pn_date,
                           id_dep_clin_serv_in    => i_id_dep_clin_serv,
                           id_prof_last_update_in => i_id_professional,
                           id_dictation_report_in => i_id_dictation_report,
                           dt_last_update_in      => i_dt_last_update,
                           id_prof_signoff_in     => l_id_prof_sign_off,
                           dt_signoff_in          => l_dt_sign_off,
                           id_pn_note_type_in     => i_id_pn_note_type,
                           rows_out               => l_rows);
        
            g_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || l_id_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'EPIS_PN',
                                          i_rowids       => l_rows,
                                          i_list_columns => table_varchar('ID_EPISODE',
                                                                          'FLG_STATUS',
                                                                          'DT_PN_DATE',
                                                                          'ID_DEP_CLIN_SERV',
                                                                          'ID_PROF_LAST_UPDATE',
                                                                          'ID_DICTATION_REPORT',
                                                                          'DT_LAST_UPDATE',
                                                                          'ID_PROF_SIGNOFF',
                                                                          'DT_SIGNOFF',
                                                                          'ID_PN_NOTE_TYPE'),
                                          o_error        => o_error);
        
            FOR i IN 1 .. i_id_pn_soap_block.count
            LOOP
                BEGIN
                    SELECT epd.id_epis_pn_det, epd.pn_note
                      INTO l_id_epis_pn_det, l_pn_note
                      FROM epis_pn_det epd
                     WHERE epd.id_epis_pn = l_id_epis_pn
                       AND epd.id_pn_soap_block = i_id_pn_soap_block(i)
                       AND epd.id_pn_data_block = i_id_pn_data_block(i)
                       AND epd.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_epis_pn_det := ts_epis_pn_det.next_key;
                END;
            
                IF ((i_id_pn_soap_block(i) = 6 AND dbms_lob.compare(l_pn_note, i_pn_note(i)) <> 0) OR
                   i_id_pn_soap_block(i) <> 6)
                THEN
                    g_error := 'Insert/Update epis pn table';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => 'set_save_def_note');
                    --Insert detail records
                    ts_epis_pn_det.upd(id_epis_pn_det_in   => l_id_epis_pn_det,
                                       id_epis_pn_in       => l_id_epis_pn,
                                       id_professional_in  => i_id_professional,
                                       dt_pn_in            => i_dt_pn_date,
                                       id_pn_data_block_in => i_id_pn_data_block(i),
                                       id_pn_soap_block_in => i_id_pn_soap_block(i),
                                       flg_status_in       => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                       pn_note_in          => CASE
                                                                  WHEN i_id_task(i) IS NULL THEN
                                                                   i_pn_note(i)
                                                                  ELSE
                                                                   NULL
                                                              END,
                                       dt_note_in          => i_dt_pn_date,
                                       rows_out            => l_rows);
                
                    g_error := 'PROCESS UPDATE epis_pn_det WITH id_epis_pn: ' || l_id_epis_pn;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPIS_PN_DET',
                                                  i_rowids       => l_rows,
                                                  i_list_columns => table_varchar('ID_EPIS_PN',
                                                                                  'ID_PROFESSIONAL',
                                                                                  'DT_PN',
                                                                                  'ID_PN_DATA_BLOCK',
                                                                                  'ID_PN_SOAP_BLOCK',
                                                                                  'FLG_STATUS',
                                                                                  'PN_NOTE',
                                                                                  'DT_NOTE'),
                                                  o_error        => o_error);
                END IF;
            
                IF (i_id_task IS NOT NULL AND i_id_task.exists(i) AND i_id_task(i) IS NOT NULL)
                THEN
                    BEGIN
                        l_new_record := 0;
                    
                        SELECT epdt.id_epis_pn_det, id_prof_task, rank_task, id_parent
                          INTO l_id_epis_pn_det_task, l_id_prof_task, l_rank_task, l_id_parent
                          FROM epis_pn_det_task epdt
                         WHERE epdt.id_epis_pn_det = l_id_epis_pn_det
                           AND epdt.id_task = i_id_task(i)
                           AND epdt.id_task_type = i_id_task_type(i)
                           AND epdt.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_new_record          := 1;
                            l_id_epis_pn_det_task := ts_epis_pn_det_task.next_key;
                    END;
                
                    g_error := 'Create/Update the progress note det task';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package,
                                         sub_object_name => 'set_save_def_note');
                    ts_epis_pn_det_task.upd_ins(id_epis_pn_det_task_in => l_id_epis_pn_det_task,
                                                id_epis_pn_det_in      => l_id_epis_pn_det,
                                                id_task_in             => i_id_task(i),
                                                id_task_type_in        => i_id_task_type(i),
                                                flg_status_in          => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                                pn_note_in             => i_pn_note(i),
                                                dt_last_update_in      => i_dt_last_update,
                                                id_prof_last_update_in => i_id_professional,
                                                flg_table_origin_in    => pk_touch_option.g_flg_tab_origin_epis_doc,
                                                id_prof_task_in        => l_id_prof_task,
                                                rank_task_in           => l_rank_task,
                                                id_parent_in           => l_id_parent,
                                                rows_out               => l_rows);
                
                    IF (l_new_record = 1)
                    THEN
                        g_error := 'PROCESS INSERT epis_pn_det_task WITH id_epis_pn_det_task: ' ||
                                   l_id_epis_pn_det_task;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPIS_PN_DET_TASK',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    ELSE
                        g_error := 'PROCESS UPDATE epis_pn_addendum WITH id_epis_pn_det_task: ' ||
                                   l_id_epis_pn_det_task;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPIS_PN_DET_TASK',
                                                      i_rowids       => l_rows,
                                                      i_list_columns => table_varchar('ID_EPIS_PN_DET',
                                                                                      'ID_TASK',
                                                                                      'ID_TASK_TYPE',
                                                                                      'FLG_STATUS',
                                                                                      'PN_NOTE',
                                                                                      'DT_LAST_UPDATE',
                                                                                      'ID_PROF_LAST_UPDATE',
                                                                                      'FLG_TABLE_ORIGIN'),
                                                      o_error        => o_error);
                    END IF;
                
                END IF;
            
            END LOOP;
        
            IF (i_pn_flg_status IN
               (pk_prog_notes_constants.g_epis_pn_flg_status_s, pk_prog_notes_constants.g_epis_pn_flg_status_m))
            THEN
                FOR i IN 1 .. i_id_pn_soap_block.count
                LOOP
                
                    BEGIN
                        SELECT eps.id_epis_pn_signoff
                          INTO l_id_epis_pn_signoff
                          FROM epis_pn_signoff eps
                         WHERE eps.id_epis_pn = l_id_epis_pn
                           AND eps.id_pn_soap_block = i_id_pn_soap_block(i);
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_id_epis_pn_signoff := NULL;
                    END;
                
                    IF (l_id_epis_pn_signoff IS NOT NULL)
                    THEN
                        g_error := 'CALL set_pn_signoff_hist';
                        IF NOT set_pn_signoff_hist(i_lang               => i_lang,
                                                   i_prof               => i_prof,
                                                   i_epis_pn            => l_id_epis_pn,
                                                   i_id_epis_pn_signoff => l_id_epis_pn_signoff,
                                                   i_dt_hist            => i_dt_sent_to_hist,
                                                   o_error              => o_error)
                        THEN
                            RAISE g_exception;
                        END IF;
                    END IF;
                
                    IF (l_id_epis_pn_signoff IS NOT NULL)
                    THEN
                        --create the progress note sign-off registry
                        g_error := 'Create the progress note sign-off';
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package,
                                             sub_object_name => 'set_save_def_note');
                        ts_epis_pn_signoff.upd(id_epis_pn_signoff_in  => l_id_epis_pn_signoff,
                                               id_epis_pn_in          => l_id_epis_pn,
                                               id_pn_soap_block_in    => i_id_pn_soap_block(i),
                                               pn_signoff_note_in     => i_pn_note(i),
                                               id_prof_last_update_in => i_id_professional,
                                               dt_last_update_in      => i_dt_last_update,
                                               rows_out               => l_rows);
                    
                        g_error := 'PROCESS UPDATE epis_pn_signoff WITH id_epis_pn_signoff: ' || l_id_epis_pn_signoff;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPIS_PN_SIGNOFF',
                                                      i_rowids       => l_rows,
                                                      i_list_columns => table_varchar('ID_EPIS_PN',
                                                                                      'ID_PN_SOAP_BLOCK',
                                                                                      'PN_SIGNOFF_NOTE',
                                                                                      'ID_PROF_LAST_UPDATE',
                                                                                      'DT_LAST_UPDATE'),
                                                      o_error        => o_error);
                    ELSE
                        --create the progress note sign-off registry
                        g_error := 'Create the progress note sign-off if it not exists when updating';
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package,
                                             sub_object_name => 'set_save_def_note');
                        ts_epis_pn_signoff.ins(id_epis_pn_in       => l_id_epis_pn,
                                               id_pn_soap_block_in => i_id_pn_soap_block(i),
                                               pn_signoff_note_in  => i_pn_note(i),
                                               rows_out            => l_rows);
                    
                        g_error := 'PROCESS INSERT epis_pn_signoff WITH id_epis_pn: ' || l_id_epis_pn;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_table_name => 'EPIS_PN_SIGNOFF',
                                                      i_rowids     => l_rows,
                                                      o_error      => o_error);
                    END IF;
                END LOOP;
            
            END IF;
            --create
        ELSE
            g_error := 'Get id_pn_area from parametrizations function id_pn_note_type: ' || i_id_pn_note_type ||
                       ' and id_episode: ' || i_id_episode;
            IF i_id_pn_area IS NULL
            THEN
            
                BEGIN
                    SELECT tf.id_pn_area
                      INTO l_id_pn_area
                      FROM TABLE(pk_prog_notes_utils.tf_pn_note_type(i_lang,
                                                                     i_prof,
                                                                     i_id_episode,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     NULL,
                                                                     i_id_pn_note_type,
                                                                     pk_prog_notes_constants.g_pn_flg_scope_notetype_n,
                                                                     NULL)) tf
                     WHERE rownum = 1;
                EXCEPTION
                    WHEN no_data_found THEN
                        IF i_flg_handle_error = pk_alert_constant.g_yes
                        THEN
                            RETURN TRUE;
                        ELSE
                            RAISE g_exception;
                        END IF;
                END;
            ELSE
                l_id_pn_area := i_id_pn_area;
            END IF;
        
            g_error := 'Insert';
            --inserting - last update fields cant be updated
            ts_epis_pn.ins(id_epis_pn_in          => l_id_epis_pn,
                           id_episode_in          => i_id_episode,
                           flg_status_in          => i_pn_flg_status,
                           dt_pn_date_in          => i_dt_pn_date,
                           id_prof_create_in      => i_id_professional,
                           dt_create_in           => i_dt_create,
                           id_dep_clin_serv_in    => i_id_dep_clin_serv,
                           id_dictation_report_in => i_id_dictation_report,
                           id_prof_signoff_in     => l_id_prof_sign_off,
                           dt_signoff_in          => l_dt_sign_off,
                           id_pn_note_type_in     => i_id_pn_note_type,
                           id_pn_area_in          => l_id_pn_area,
                           id_software_in         => i_prof.software,
                           rows_out               => l_rows);
        
            g_error := 'PROCESS INSERT epis_pn WITH id_epis_pn: ' || l_id_epis_pn;
            pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_PN',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            FOR i IN 1 .. i_id_pn_soap_block.count
            LOOP
                g_error := 'Insert/Update epis pn table';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => 'set_save_def_note');
            
                l_id_epis_pn_det := ts_epis_pn_det.next_key;
            
                --Insert detail records
                ts_epis_pn_det.ins(id_epis_pn_det_in   => l_id_epis_pn_det,
                                   id_epis_pn_in       => l_id_epis_pn,
                                   id_professional_in  => i_id_professional,
                                   dt_pn_in            => i_dt_pn_date,
                                   id_pn_data_block_in => i_id_pn_data_block(i),
                                   id_pn_soap_block_in => i_id_pn_soap_block(i),
                                   flg_status_in       => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                   pn_note_in          => CASE
                                                              WHEN i_id_task(i) IS NULL THEN
                                                               i_pn_note(i)
                                                              ELSE
                                                               NULL
                                                          END,
                                   dt_note_in          => i_dt_pn_date,
                                   rows_out            => l_rows);
            
                g_error := 'PROCESS INSERT epis_pn_det WITH id_epis_pn_det: ' || l_id_epis_pn_det;
                pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_PN_DET',
                                              i_rowids     => l_rows,
                                              o_error      => o_error);
            
                IF (i_id_task IS NOT NULL AND i_id_task.exists(i) AND i_id_task(i) IS NOT NULL)
                THEN
                    l_id_epis_pn_det_task := ts_epis_pn_det_task.next_key;
                
                    g_error := 'Create the progress note det task';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package,
                                         sub_object_name => 'set_save_def_note');
                    ts_epis_pn_det_task.ins(id_epis_pn_det_task_in => l_id_epis_pn_det_task,
                                            id_epis_pn_det_in      => l_id_epis_pn_det,
                                            id_task_in             => i_id_task(i),
                                            id_task_type_in        => i_id_task_type(i),
                                            flg_status_in          => pk_prog_notes_constants.g_epis_pn_det_flg_status_a,
                                            pn_note_in             => i_pn_note(i),
                                            dt_last_update_in      => i_dt_last_update,
                                            id_prof_last_update_in => i_id_professional,
                                            flg_table_origin_in    => pk_touch_option.g_flg_tab_origin_epis_doc,
                                            rows_out               => l_rows);
                
                    g_error := 'PROCESS INSERT epis_pn_det_task WITH id_epis_pn_det_task: ' || l_id_epis_pn_det_task;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_DET_TASK',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                END IF;
            
            END LOOP;
        
            IF (i_pn_flg_status IN
               (pk_prog_notes_constants.g_epis_pn_flg_status_s, pk_prog_notes_constants.g_epis_pn_flg_status_m))
            THEN
                FOR i IN 1 .. i_id_pn_soap_block.count
                LOOP
                    --create the progress note sign-off registry
                    g_error := 'Create the progress note sign-off';
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package,
                                         sub_object_name => 'set_save_def_note');
                    ts_epis_pn_signoff.ins(id_epis_pn_in       => l_id_epis_pn,
                                           id_pn_soap_block_in => i_id_pn_soap_block(i),
                                           pn_signoff_note_in  => i_pn_note(i),
                                           rows_out            => l_rows);
                
                    g_error := 'PROCESS INSERT epis_pn_signoff WITH id_epis_pn: ' || l_id_epis_pn;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'EPIS_PN_SIGNOFF',
                                                  i_rowids     => l_rows,
                                                  o_error      => o_error);
                END LOOP;
            END IF;
        
            g_error := 'CALL TO PK_VISIT.SET_FIRST_OBS';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_id_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => NULL,
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        o_id_epis_pn := l_id_epis_pn;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_save_def_note',
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_save_def_note;

    /**
    * Get imported data from temporary tables to be edited in Progress Notes (internal function)
    * related to one task type
    *
    * @param   i_lang                  Professional preferred language
    * @param   i_prof                  Professional identification and its context (institution and software)
    * @param   i_episode               Episode ID
    * @param   i_patient               Patient ID
    * @param   i_pn_soap_block         SOAP block ID
    * @param   i_pn_data_block         Data block ID
    * @param   i_id_pn_note_type       Note type Identifier     
    * @param   i_begin_date            Date begin
    * @param   i_end_date              Date end
    * @param   i_scope_type            Scope (E- Episode, V- Visit, P- Patient)
    * @param   i_flg_block_type        Block Type (D- Documentation, T- Free Text)
    * @param   i_pn_task_type          Task type id   
    * @param   i_flg_import_date       Y-record date should be imported; N-otherwise 
    * @param   i_flg_group_on_import   D-records grouped by date
    * @param   i_flg_ongoing           O-auto-populate the ongoing tasks. F-auto-populate the finalized tasks. N-otherwize
    * @param   i_dblock_flg_type       Data block flg_Type
    * @param   i_flg_filter             Filter to apply
    *
    * @param   o_data_import_list      Data to return
    * @param   o_error                 Error information
    *
    * @return  Boolean                 True: Sucess, False: Fail
    *
    * @value   i_flg_finalized         {*} 'F'- auto-populate the finalized tasks {*} 'N'- otherwise
    *
    * @author                          Sofia Mendes
    * @version                         2.6.1.2
    * @since                           07-09-2011
    */
    FUNCTION get_import_task
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_episode               IN episode.id_episode%TYPE,
        i_patient               IN patient.id_patient%TYPE,
        i_pn_soap_block         IN pn_soap_block.id_pn_soap_block%TYPE,
        i_pn_data_block         IN pn_data_block.id_pn_data_block%TYPE,
        i_begin_date            IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date              IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_scope_type            IN VARCHAR2,
        i_scope                 IN NUMBER,
        i_pn_task_type          IN epis_pn_det_task.id_task_type%TYPE,
        i_outside_period        IN VARCHAR2,
        i_flg_import_date       IN pn_dblock_mkt.flg_import_date%TYPE,
        i_flg_group_on_import   IN pn_dblock_mkt.flg_group_on_import%TYPE,
        i_flg_ongoing           IN VARCHAR2,
        i_dblock_flg_type       IN pn_data_block.flg_type%TYPE,
        i_flg_synchronized      IN VARCHAR2,
        i_flg_filter            IN VARCHAR2,
        i_flg_view              IN vs_soft_inst.flg_view%TYPE,
        i_flg_first_record      IN VARCHAR2,
        i_only_autopop          IN VARCHAR2,
        i_flg_description       IN VARCHAR2 DEFAULT NULL,
        i_description_condition IN VARCHAR2 DEFAULT NULL,
        o_data_import           IN OUT t_coll_data_import,
        o_error                 IN OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_import t_coll_data_import := t_coll_data_import();
        l_exception EXCEPTION;
    
        l_num_records         NUMBER;
        l_admitting_physician VARCHAR2(1 CHAR);
    BEGIN
    
        l_data_import := o_data_import;
    
        IF i_pn_task_type IN (pk_prog_notes_constants.g_task_vital_signs, pk_prog_notes_constants.g_task_biometrics) --Vital Signs
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_vital_signs';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_vital_signs(i_lang                => i_lang,
                                                               i_prof                => i_prof,
                                                               i_scope               => i_scope,
                                                               i_scope_type          => i_scope_type,
                                                               i_pn_soap_block       => i_pn_soap_block,
                                                               i_pn_data_block       => i_pn_data_block,
                                                               i_begin_date          => i_begin_date,
                                                               i_end_date            => i_end_date,
                                                               io_data_import        => l_data_import,
                                                               i_outside_period      => i_outside_period,
                                                               i_id_pn_task_type     => i_pn_task_type,
                                                               i_flg_import_date     => i_flg_import_date,
                                                               i_flg_group_on_import => i_flg_group_on_import,
                                                               i_flg_type            => i_dblock_flg_type,
                                                               o_count_records       => l_num_records,
                                                               o_error               => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --*************************************************************************************************
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_care_plans --Care plans
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_care_plans';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_care_plans(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_id_patient      => i_patient,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_begin_date      => i_begin_date,
                                                              i_end_date        => i_end_date,
                                                              i_flg_import_date => i_flg_import_date,
                                                              i_flg_ongoing     => i_flg_ongoing,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_guidelines --Guidelines
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_guidelines';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_guidelines(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_id_episode      => i_episode,
                                                              i_id_patient      => i_patient,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_begin_date      => i_begin_date,
                                                              i_end_date        => i_end_date,
                                                              i_flg_import_date => i_flg_import_date,
                                                              i_flg_ongoing     => i_flg_ongoing,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --*************************************************************************************************
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_protocol --Protocol
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_protocol';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_protocol(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_id_episode      => i_episode,
                                                            i_id_patient      => i_patient,
                                                            i_pn_soap_block   => i_pn_soap_block,
                                                            i_pn_data_block   => i_pn_data_block,
                                                            i_begin_date      => i_begin_date,
                                                            i_end_date        => i_end_date,
                                                            i_flg_import_date => i_flg_import_date,
                                                            i_flg_ongoing     => i_flg_ongoing,
                                                            io_data_import    => l_data_import,
                                                            o_count_records   => l_num_records,
                                                            o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --*************************************************************************************************
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_ph_obstetric_hist --Past history - Obstetric history
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_past_hist_obstetric';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_past_hist_obstetric(i_lang             => i_lang,
                                                                       i_prof             => i_prof,
                                                                       i_id_episode       => i_episode,
                                                                       i_id_doc_area      => pk_pregnancy_core.g_doc_area_past_hist,
                                                                       i_scope            => i_scope,
                                                                       i_scope_type       => i_scope_type,
                                                                       i_pn_soap_block    => i_pn_soap_block,
                                                                       i_pn_data_block    => i_pn_data_block,
                                                                       i_flg_import_date  => i_flg_import_date,
                                                                       i_begin_date       => i_begin_date,
                                                                       i_end_date         => i_end_date,
                                                                       i_flg_synchronized => i_flg_synchronized,
                                                                       io_data_import     => l_data_import,
                                                                       o_count_records    => l_num_records,
                                                                       o_error            => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_ph_medical_other --Medical history: diagnosis and surgery records
        THEN
        
            g_error := 'call to pk_prog_notes_dblock.get_import_past_hist_medical';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_past_hist_medical(i_lang            => i_lang,
                                                                     i_prof            => i_prof,
                                                                     i_id_episode      => i_episode,
                                                                     i_id_patient      => i_patient,
                                                                     i_pn_soap_block   => i_pn_soap_block,
                                                                     i_pn_data_block   => i_pn_data_block,
                                                                     i_flg_import_date => i_flg_import_date,
                                                                     i_begin_date      => i_begin_date,
                                                                     i_end_date        => i_end_date,
                                                                     io_data_import    => l_data_import,
                                                                     o_count_records   => l_num_records,
                                                                     o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --*************************************************************************************************
        ELSIF ((i_pn_task_type = pk_prog_notes_constants.g_task_single_page_note OR
              i_pn_task_type = pk_prog_notes_constants.g_task_readmission) AND
              (i_flg_synchronized = pk_prog_notes_constants.g_yes OR i_only_autopop = pk_prog_notes_constants.g_yes)) --Single Page note
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_single_page_note';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_single_page_note(i_lang          => i_lang,
                                                                    i_prof          => i_prof,
                                                                    i_scope         => i_scope,
                                                                    i_scope_type    => i_scope_type,
                                                                    i_pn_soap_block => i_pn_soap_block,
                                                                    i_pn_data_block => i_pn_data_block,
                                                                    i_flg_filter    => i_flg_filter,
                                                                    i_id_task_type  => i_pn_task_type,
                                                                    io_data_import  => l_data_import,
                                                                    o_count_records => l_num_records,
                                                                    o_error         => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
        ELSIF (i_pn_task_type = pk_prog_notes_constants.g_task_handp AND
              (i_flg_synchronized = pk_prog_notes_constants.g_yes OR i_only_autopop = pk_prog_notes_constants.g_yes)) --History and physical note
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_h_and_p';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_h_and_p(i_lang          => i_lang,
                                                           i_prof          => i_prof,
                                                           i_scope         => i_scope,
                                                           i_scope_type    => i_scope_type,
                                                           i_pn_soap_block => i_pn_soap_block,
                                                           i_pn_data_block => i_pn_data_block,
                                                           io_data_import  => l_data_import,
                                                           o_count_records => l_num_records,
                                                           o_error         => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
        ELSIF i_pn_task_type IN (pk_prog_notes_constants.g_task_visit_info_inp,
                                 pk_prog_notes_constants.g_task_visit_info_edis,
                                 pk_prog_notes_constants.g_task_visit_info_amb)
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_visit_info';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_visit_info(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_scope                 => i_scope,
                                                              i_scope_type            => i_scope_type,
                                                              i_pn_soap_block         => i_pn_soap_block,
                                                              i_pn_data_block         => i_pn_data_block,
                                                              i_id_pn_task_type       => i_pn_task_type,
                                                              i_flg_description       => i_flg_description,
                                                              i_description_condition => i_description_condition,
                                                              io_data_import          => l_data_import,
                                                              o_count_records         => l_num_records,
                                                              o_error                 => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_arrival_days
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_admission_days';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_admission_days(i_lang            => i_lang,
                                                                  i_prof            => i_prof,
                                                                  i_scope           => i_scope,
                                                                  i_scope_type      => i_scope_type,
                                                                  i_pn_soap_block   => i_pn_soap_block,
                                                                  i_pn_data_block   => i_pn_data_block,
                                                                  i_id_pn_task_type => i_pn_task_type,
                                                                  io_data_import    => l_data_import,
                                                                  o_count_records   => l_num_records,
                                                                  o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --*************************************************************************************************
        ELSIF i_pn_task_type IN
              (pk_prog_notes_constants.g_task_dev_first_yr, pk_prog_notes_constants.g_task_nutr_first_yr) -- Child nutrition and development
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_child_dev_feed';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_child_dev_feed(i_lang            => i_lang,
                                                                  i_prof            => i_prof,
                                                                  i_id_patient      => i_patient,
                                                                  i_pn_soap_block   => i_pn_soap_block,
                                                                  i_pn_data_block   => i_pn_data_block,
                                                                  i_id_pn_task_type => i_pn_task_type,
                                                                  io_data_import    => l_data_import,
                                                                  o_count_records   => l_num_records,
                                                                  o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_prof_resp -- admitting physician
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_prof_resp';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_PROF_RESP');
            IF i_flg_filter = pk_prog_notes_constants.g_current_resp_phys
            THEN
                l_admitting_physician := pk_alert_constant.g_no;
            ELSE
                l_admitting_physician := pk_alert_constant.g_yes;            
            END IF;
        
            IF NOT pk_prog_notes_dblock.get_import_prof_resp(i_lang                    => i_lang,
                                                             i_prof                    => i_prof,
                                                             i_scope                   => i_scope,
                                                             i_scope_type              => i_scope_type,
                                                             i_pn_soap_block           => i_pn_soap_block,
                                                             i_pn_data_block           => i_pn_data_block,
                                                             i_id_pn_task_type         => i_pn_task_type,
                                                             i_flg_admitting_physician => l_admitting_physician,
                                                             io_data_import            => l_data_import,
                                                             o_count_records           => l_num_records,
                                                             o_error                   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_resp_physician -- current episode responsable
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_prof_resp';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_PROF_RESP');
        
            IF NOT pk_prog_notes_dblock.get_import_prof_resp(i_lang                    => i_lang,
                                                             i_prof                    => i_prof,
                                                             i_scope                   => i_scope,
                                                             i_scope_type              => i_scope_type,
                                                             i_pn_soap_block           => i_pn_soap_block,
                                                             i_pn_data_block           => i_pn_data_block,
                                                             i_id_pn_task_type         => i_pn_task_type,
                                                             i_flg_admitting_physician => pk_alert_constant.g_no,
                                                             io_data_import            => l_data_import,
                                                             o_count_records           => l_num_records,
                                                             o_error                   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_document_status
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_doc_status';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_DOC_STATUS');
        
            IF NOT pk_prog_notes_dblock.get_import_doc_status(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_scope           => i_scope,
                                                              i_scope_type      => i_scope_type,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_id_pn_task_type => i_pn_task_type,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --*************************************************************************************************
            --patient information for new datablock
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_patient_information --patient information
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_patient_information';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_PATIENT_INFORMATION');
        
            IF NOT pk_prog_notes_dblock.get_import_patient_information(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_id_episode      => i_episode,
                                                                       i_id_patient      => i_patient,
                                                                       i_pn_soap_block   => i_pn_soap_block,
                                                                       i_pn_data_block   => i_pn_data_block,
                                                                       i_id_pn_task_type => i_pn_task_type,
                                                                       io_data_import    => l_data_import,
                                                                       o_count_records   => l_num_records,
                                                                       o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            -- Vaccination_Immunization for new datablock
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_vacc --vaccination
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_vacc';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_VACCINATION');
        
            IF NOT pk_prog_notes_dblock.get_import_vaccination(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_id_episode      => i_episode,
                                                               i_id_patient      => i_patient,
                                                               i_pn_soap_block   => i_pn_soap_block,
                                                               i_pn_data_block   => i_pn_data_block,
                                                               i_id_pn_task_type => i_pn_task_type,
                                                               io_data_import    => l_data_import,
                                                               o_count_records   => l_num_records,
                                                               o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_past_hist_biometrics -- Past medical history - Biometrics
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_vacc';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_PMH_BIOMETRICS');
        
            IF NOT pk_prog_notes_dblock.get_import_pmh_biometrics(i_lang            => i_lang,
                                                                  i_prof            => i_prof,
                                                                  i_id_patient      => i_patient,
                                                                  i_pn_soap_block   => i_pn_soap_block,
                                                                  i_pn_data_block   => i_pn_data_block,
                                                                  i_id_pn_task_type => i_pn_task_type,
                                                                  io_data_import    => l_data_import,
                                                                  o_count_records   => l_num_records,
                                                                  o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_templates_other_note
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_from_other_note';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'call get_import_from_other_note');
            IF NOT pk_prog_notes_dblock.get_import_from_other_note(i_lang          => i_lang,
                                                                   i_prof          => i_prof,
                                                                   i_id_episode    => i_episode,
                                                                   i_pn_soap_block => i_pn_soap_block,
                                                                   i_pn_data_block => i_pn_data_block,
                                                                   i_flg_filter    => i_flg_filter,
                                                                   io_data_import  => l_data_import,
                                                                   o_count_records => l_num_records,
                                                                   o_error         => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_complications
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_vacc';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_COMPLICATIONS');
        
            IF NOT pk_prog_notes_dblock.get_import_complications(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_id_episode      => i_episode,
                                                                 i_id_patient      => i_patient,
                                                                 i_pn_soap_block   => i_pn_soap_block,
                                                                 i_pn_data_block   => i_pn_data_block,
                                                                 i_id_pn_task_type => i_pn_task_type,
                                                                 io_data_import    => l_data_import,
                                                                 o_count_records   => l_num_records,
                                                                 o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_vital_signs_view_date
        THEN
            g_error := 'call to pk_prog_notes_dblock.g_task_vital_signs_view_date';
            alertlog.pk_alertlog.log_debug(text            => g_error,
                                           object_name     => g_package,
                                           sub_object_name => 'GET_IMPORT_VITAL_SIGNS_BY_VIEW_DATE');
        
            IF NOT pk_prog_notes_dblock.get_import_vs_by_view_date(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_scope            => i_scope,
                                                                   i_scope_type       => i_scope_type,
                                                                   i_pn_soap_block    => i_pn_soap_block,
                                                                   i_pn_data_block    => i_pn_data_block,
                                                                   i_begin_date       => i_begin_date,
                                                                   i_end_date         => i_end_date,
                                                                   i_id_pn_task_type  => i_pn_task_type,
                                                                   i_flg_view         => i_flg_view,
                                                                   i_flg_first_record => i_flg_first_record,
                                                                   io_data_import     => l_data_import,
                                                                   o_count_records    => l_num_records,
                                                                   o_error            => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
            -- episode transfer information 
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_episode_transf
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_transfer_info';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_IMPORT_TASK');
        
            IF NOT pk_prog_notes_dblock.get_import_transfer_info(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_id_episode      => i_episode,
                                                                 i_pn_soap_block   => i_pn_soap_block,
                                                                 i_pn_data_block   => i_pn_data_block,
                                                                 i_id_pn_task_type => i_pn_task_type,
                                                                 io_data_import    => l_data_import,
                                                                 o_count_records   => l_num_records,
                                                                 o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            --Attending physicians for new datablock
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_attending_physicians --Attending physicians 
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_attending_physicians';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_ATTENDING_PHYSICIANS');
        
            IF NOT pk_prog_notes_dblock.get_import_att_phy(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_id_episode      => i_episode,
                                                           i_pn_soap_block   => i_pn_soap_block,
                                                           i_pn_data_block   => i_pn_data_block,
                                                           i_id_pn_task_type => i_pn_task_type,
                                                           io_data_import    => l_data_import,
                                                           o_count_records   => l_num_records,
                                                           o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            -- ICU assessment
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_icu_assessment
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_asse_score';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_ASSE_SCORE');
        
            IF NOT pk_prog_notes_dblock.get_import_asse_score(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_id_episode      => i_episode,
                                                              i_id_patient      => i_patient,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_id_pn_task_type => i_pn_task_type,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
            -- ICU assessment priority 
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_icu_asse_priority
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_asse_priority';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_ASSE_PRIORITY');
        
            IF NOT pk_prog_notes_dblock.get_import_asse_priority(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_pn_soap_block   => i_pn_soap_block,
                                                                 i_pn_data_block   => i_pn_data_block,
                                                                 i_id_pn_task_type => i_pn_task_type,
                                                                 io_data_import    => l_data_import,
                                                                 o_count_records   => l_num_records,
                                                                 o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_transfer_cs
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_trans_cs_dest';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'GET_IMPORT_TRANS_CS_DEST');
        
            IF NOT pk_prog_notes_dblock.get_import_trans_cs_dest(i_lang            => i_lang,
                                                                 i_prof            => i_prof,
                                                                 i_scope           => i_scope,
                                                                 i_scope_type      => i_scope_type,
                                                                 i_pn_soap_block   => i_pn_soap_block,
                                                                 i_pn_data_block   => i_pn_data_block,
                                                                 i_id_pn_task_type => i_pn_task_type,
                                                                 io_data_import    => l_data_import,
                                                                 o_count_records   => l_num_records,
                                                                 o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_check_reicu
        THEN
            g_error := 'call to pk_prog_notes_dblock.check_reenter_icu';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'CHECK_REENTER_ICU');
        
            IF NOT pk_prog_notes_dblock.check_reenter_icu(i_lang            => i_lang,
                                                          i_prof            => i_prof,
                                                          i_id_episode      => i_episode,
                                                          i_id_patient      => i_patient,
                                                          i_pn_soap_block   => i_pn_soap_block,
                                                          i_pn_data_block   => i_pn_data_block,
                                                          i_id_pn_task_type => i_pn_task_type,
                                                          io_data_import    => l_data_import,
                                                          o_count_records   => l_num_records,
                                                          o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_cp_icu_info
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_cur_pre_icu_info';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_CP_ICU_INFO');
        
            IF NOT pk_prog_notes_dblock.get_cur_pre_icu_info(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_id_episode      => i_episode,
                                                             i_id_patient      => i_patient,
                                                             i_pn_soap_block   => i_pn_soap_block,
                                                             i_pn_data_block   => i_pn_data_block,
                                                             i_id_pn_task_type => i_pn_task_type,
                                                             io_data_import    => l_data_import,
                                                             o_count_records   => l_num_records,
                                                             o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_blood_type
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_Blood_Type';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_import_Blood_Type');
        
            IF NOT pk_prog_notes_dblock.get_import_blood_type(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_scope           => i_scope,
                                                              i_scope_type      => i_scope_type,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_id_pn_task_type => i_pn_task_type,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_obstetric_index
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_obstetric_index';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_import_obstetric_index');
        
            IF NOT pk_prog_notes_dblock.get_import_obstetric_index(i_lang            => i_lang,
                                                                   i_prof            => i_prof,
                                                                   i_scope           => i_scope,
                                                                   i_scope_type      => i_scope_type,
                                                                   i_pn_soap_block   => i_pn_soap_block,
                                                                   i_pn_data_block   => i_pn_data_block,
                                                                   i_id_pn_task_type => i_pn_task_type,
                                                                   io_data_import    => l_data_import,
                                                                   o_count_records   => l_num_records,
                                                                   o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_current_pregnancy
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_current_pregnancy';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_import_current_pregnancy');
        
            IF NOT pk_prog_notes_dblock.get_import_current_pregnancy(i_lang            => i_lang,
                                                                     i_prof            => i_prof,
                                                                     i_scope           => i_scope,
                                                                     i_scope_type      => i_scope_type,
                                                                     i_pn_soap_block   => i_pn_soap_block,
                                                                     i_pn_data_block   => i_pn_data_block,
                                                                     i_id_pn_task_type => i_pn_task_type,
                                                                     io_data_import    => l_data_import,
                                                                     o_count_records   => l_num_records,
                                                                     o_error           => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_home
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_housing';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'get_import_housing');
        
            IF NOT pk_prog_notes_dblock.get_import_housing(i_lang            => i_lang,
                                                           i_prof            => i_prof,
                                                           i_scope           => i_scope,
                                                           i_scope_type      => i_scope_type,
                                                           i_pn_soap_block   => i_pn_soap_block,
                                                           i_pn_data_block   => i_pn_data_block,
                                                           i_id_pn_task_type => i_pn_task_type,
                                                           io_data_import    => l_data_import,
                                                           o_count_records   => l_num_records,
                                                           o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_fam_soc_class
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_soc_class';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'get_import_soc_class');
        
            IF NOT pk_prog_notes_dblock.get_import_soc_class(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_scope           => i_scope,
                                                             i_scope_type      => i_scope_type,
                                                             i_pn_soap_block   => i_pn_soap_block,
                                                             i_pn_data_block   => i_pn_data_block,
                                                             i_id_pn_task_type => i_pn_task_type,
                                                             io_data_import    => l_data_import,
                                                             o_count_records   => l_num_records,
                                                             o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_family_monetary
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_house_financial';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_import_house_financial');
        
            IF NOT pk_prog_notes_dblock.get_import_house_financial(i_lang            => i_lang,
                                                                   i_prof            => i_prof,
                                                                   i_scope           => i_scope,
                                                                   i_scope_type      => i_scope_type,
                                                                   i_pn_soap_block   => i_pn_soap_block,
                                                                   i_pn_data_block   => i_pn_data_block,
                                                                   i_id_pn_task_type => i_pn_task_type,
                                                                   io_data_import    => l_data_import,
                                                                   o_count_records   => l_num_records,
                                                                   o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_household
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_household';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'get_import_household');
        
            IF NOT pk_prog_notes_dblock.get_import_household(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_scope           => i_scope,
                                                             i_scope_type      => i_scope_type,
                                                             i_pn_soap_block   => i_pn_soap_block,
                                                             i_pn_data_block   => i_pn_data_block,
                                                             i_id_pn_task_type => i_pn_task_type,
                                                             io_data_import    => l_data_import,
                                                             o_count_records   => l_num_records,
                                                             o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_intervention_plan
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_import_interv_plan';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_import_interv_plan');
        
            IF NOT pk_prog_notes_dblock.get_import_interv_plan(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_scope           => i_scope,
                                                               i_scope_type      => i_scope_type,
                                                               i_pn_soap_block   => i_pn_soap_block,
                                                               i_pn_data_block   => i_pn_data_block,
                                                               i_id_pn_task_type => i_pn_task_type,
                                                               io_data_import    => l_data_import,
                                                               o_count_records   => l_num_records,
                                                               o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_pat_identification
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_pat_identification';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_pat_identification');
        
            IF NOT pk_prog_notes_dblock.get_pat_identification(i_lang                  => i_lang,
                                                               i_prof                  => i_prof,
                                                               i_scope                 => i_scope,
                                                               i_scope_type            => i_scope_type,
                                                               i_pn_soap_block         => i_pn_soap_block,
                                                               i_pn_data_block         => i_pn_data_block,
                                                               i_id_pn_task_type       => i_pn_task_type,
                                                               i_flg_description       => i_flg_description,
                                                               i_description_condition => i_description_condition,
                                                               io_data_import          => l_data_import,
                                                               o_count_records         => l_num_records,
                                                               o_error                 => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_med_admin_herelastday
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_local_med_lastday';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_local_med_lastday');
        
            IF NOT pk_prog_notes_dblock.get_local_med_lastday(i_lang            => i_lang,
                                                              i_prof            => i_prof,
                                                              i_scope           => i_scope,
                                                              i_scope_type      => i_scope_type,
                                                              i_pn_soap_block   => i_pn_soap_block,
                                                              i_pn_data_block   => i_pn_data_block,
                                                              i_id_pn_task_type => i_pn_task_type,
                                                              io_data_import    => l_data_import,
                                                              o_count_records   => l_num_records,
                                                              o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        ELSIF i_pn_task_type = pk_prog_notes_constants.g_task_med_antibiotics
        THEN
            g_error := 'call to pk_prog_notes_dblock.get_local_med_antibiotics';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => 'get_med_antibioticslocal');
        
            IF NOT pk_prog_notes_dblock.get_local_med_antibiotics(i_lang            => i_lang,
                                                                  i_prof            => i_prof,
                                                                  i_scope           => i_scope,
                                                                  i_scope_type      => i_scope_type,
                                                                  i_pn_soap_block   => i_pn_soap_block,
                                                                  i_pn_data_block   => i_pn_data_block,
                                                                  i_id_pn_task_type => i_pn_task_type,
                                                                  io_data_import    => l_data_import,
                                                                  o_count_records   => l_num_records,
                                                                  o_error           => o_error)
            
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        o_data_import := l_data_import;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_IMPORT_TASK',
                                              o_error);
        
            RETURN FALSE;
    END get_import_task;

    /**
    * Get the data blocks configs needed to perform the import of the data to the data block.
    *
    * @param   i_lang                  Professional preferred language
    * @param   i_prof                  Professional identification and its context (institution and software)
    * @param   i_episode               Episode ID
    * @param   i_patient               Patient ID
    * @param   i_id_visit              visit ID
    * @param   i_begin_date            Date begin
    * @param   i_end_date              Date end
    * @param   i_flg_synch_note        Y-this note type should be synchronized. Should opens directly the edit screen. N-otherwise
    * @param   i_import_screen         Y- We are in the import screen: we . Should opens directly the edit screen. N-otherwize
    * @param   i_action                A-Auto-population; I-import
    * @param   i_data_blocks           t_rec_data_blocks
    * @param   i_id_epis_pn            epis_pn ID
    * @param   i_id_pn_note_type       pn_note_type ID
    * @param   i_id_epis_pn_det_task   epis_pn_det_task ID
    * @param   i_dt_proposed           note proposed date
    * @param   o_begin_date            Import start date
    * @param   o_end_date              Import end date
    * @param   o_scope                 Scope id (pateitn id, episode id or visit id)    
    * @param   o_error                 Error information
    *
    * @return  Boolean                 True: Sucess, False: Fail
    *
    * @value   i_scope_type            {*} 'E'- Episode {*} 'V'- Visit {*} 'P'- Patient
    * @value   i_flg_synch_note        {*} 'Y'- Yes {*} 'N'- no
    * @value   i_flg_data_removable    {*} 'N'- Not applicable {*} 'I'- Imported data {*} 'P'- Auto Populated
    *
    * @author                          Sofia Mendes
    * @version                         2.6.1.2
    * @since                           07-09-2011
    */
    FUNCTION get_data_block_configs
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_patient             IN patient.id_patient%TYPE,
        i_id_visit            IN visit.id_visit%TYPE DEFAULT NULL,
        i_begin_date          IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date            IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_flg_synch_note      IN pn_note_type_mkt.flg_synchronized%TYPE,
        i_import_screen       IN VARCHAR2,
        i_action              IN VARCHAR2 DEFAULT pk_prog_notes_constants.g_flg_action_import,
        i_data_blocks         IN t_rec_data_blocks,
        i_id_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_pn_note_type     IN pn_note_type.id_pn_note_type%TYPE,
        i_id_epis_pn_det_task IN table_number,
        i_dt_proposed         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        o_note_date           OUT TIMESTAMP WITH LOCAL TIME ZONE,
        o_begin_date          OUT TIMESTAMP WITH LOCAL TIME ZONE,
        o_end_date            OUT TIMESTAMP WITH LOCAL TIME ZONE,
        o_scope               OUT NUMBER,
        o_error               IN OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_visit visit.id_visit%TYPE;
    BEGIN
    
        --Get the visit for the id_episode
        g_error := 'Get the episode visit. ID_episode = ' || to_char(i_episode);
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => 'GET_DATA_BLOCK_CONFIGS');
    
        IF (i_id_visit IS NULL)
        THEN
            l_id_visit := pk_episode.get_id_visit(i_episode => i_episode);
        ELSE
            l_id_visit := i_id_visit;
        END IF;
    
        --Determine the scope according to the scope type defined for the data block
        SELECT decode(i_data_blocks.flg_scope,
                      pk_prog_notes_constants.g_flg_scope_p,
                      i_patient,
                      pk_prog_notes_constants.g_flg_scope_v,
                      l_id_visit,
                      i_episode)
          INTO o_scope
          FROM dual;
    
        IF i_begin_date IS NULL
           AND i_end_date IS NULL
        THEN
            -- function has been called by import screen for each Data Block
            g_error := 'CALL GET_PERIOD_TIME_HP_IMPORT_DATA FUNCTION';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_import_dates(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_id_episode          => i_episode,
                                                        i_begin_date          => i_begin_date,
                                                        i_end_date            => i_end_date,
                                                        i_flg_synchronized    => i_flg_synch_note,
                                                        i_import_screen       => i_import_screen,
                                                        i_id_epis_pn_det_task => i_id_epis_pn_det_task,
                                                        i_id_epis_pn          => i_id_epis_pn,
                                                        i_id_pn_note_type     => i_id_pn_note_type,
                                                        i_dt_proposed         => i_dt_proposed,
                                                        i_action              => i_action,
                                                        i_data_blocks         => i_data_blocks,
                                                        o_begin_date          => o_begin_date,
                                                        o_end_date            => o_end_date,
                                                        o_note_date           => o_note_date,
                                                        o_error               => o_error)
            
            THEN
                RAISE g_exception;
            END IF;
        ELSE
            o_begin_date := i_begin_date;
            o_end_date   := i_end_date;
        
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN g_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_DATA_BLOCK_CONFIGS',
                                              o_error);
        
            RETURN FALSE;
    END get_data_block_configs;

    /**
    * Get imported data from temporary tables to be edited in Progress Notes
    *
    * @param   i_lang              Professional preferred language
    * @param   i_prof              Professional identification and its context (institution and software)
    * @param   i_episode           Episode ID
    * @param   i_patient           Patient ID
    * @param   i_id_pn_note_type   Note type Identifier 
    * @param   i_pn_note_type_cfg  Configs associated to the note type 
    * @param   i_id_epis_pn             Note ID
    *
    * @param   o_data_import_list
    * @param   o_data_block
    * @param   o_data
    * @param   o_error             Error information
    *
    * @return  Boolean             True: Sucess, False: Fail
    *
    * @author                      Ant? Neto
    * @version                     2.6.1.2
    * @since                       27-Jul-2011
    */
    FUNCTION get_data_import
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_patient          IN patient.id_patient%TYPE,
        i_id_pn_note_type  IN pn_note_type.id_pn_note_type%TYPE,
        i_pn_note_type_cfg IN t_rec_note_type,
        i_id_epis_pn       IN epis_pn.id_epis_pn%TYPE,
        o_data_import_list OUT pk_types.cursor_type,
        o_data_block       OUT t_coll_data_blocks,
        o_data             OUT t_coll_pn_work_data,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_data_import t_coll_data_import := t_coll_data_import();
        l_exception EXCEPTION;
    
        l_cursor_dblock     t_coll_data_blocks;
        l_begin_date        TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_date          TIMESTAMP WITH LOCAL TIME ZONE;
        l_current_timestamp TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_configs_ctx pk_prog_notes_types.t_configs_ctx;
        l_func_name CONSTANT VARCHAR2(15 CHAR) := 'GET_DATA_IMPORT';
    BEGIN
    
        l_current_timestamp := current_timestamp;
    
        g_error := 'CALL reset_configs_ctx';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_episode         => i_episode,
                                           i_id_pn_note_type => i_id_pn_note_type,
                                           i_epis_pn         => NULL);
    
        --Get list of SOAP Blocks to import   
        g_error := 'Get list of blocks to import. Call to pk_progress_notes_upd.get_import_dblocks';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_progress_notes_upd.get_import_dblocks(i_lang             => i_lang,
                                                        i_prof             => i_prof,
                                                        i_id_pn_note_type  => i_id_pn_note_type,
                                                        i_configs_ctx      => l_configs_ctx,
                                                        i_id_pn_soap_block => NULL,
                                                        o_data_block       => o_data_block,
                                                        o_error            => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        --Array with data blocks defined as importable
        l_cursor_dblock := o_data_block;
    
        g_error := 'Get note begin and end dates for records import';
        IF i_pn_note_type_cfg.flg_last_24h = pk_alert_constant.g_no
        THEN
            l_begin_date := NULL;
            l_end_date   := NULL;
        ELSE
            IF i_pn_note_type_cfg.flg_last_24h = pk_alert_constant.g_yes
            THEN
                l_begin_date := pk_date_utils.add_days_to_tstz(l_current_timestamp, -1);
                l_end_date   := l_current_timestamp;
            ELSE
                l_begin_date := pk_date_utils.trunc_insttimezone(i_prof, l_current_timestamp);
                l_end_date   := l_current_timestamp;
            END IF;
        END IF;
    
        g_error := 'CALL get_data_import_list.';
        pk_alertlog.log_debug(g_error);
        IF NOT get_data_import_list(i_lang                => i_lang,
                                    i_prof                => i_prof,
                                    i_id_episode          => i_episode,
                                    i_id_patient          => i_patient,
                                    i_id_visit            => pk_episode.get_id_visit(i_episode => i_episode),
                                    i_data_blocks         => l_cursor_dblock,
                                    i_begin_date          => l_begin_date,
                                    i_end_date            => l_end_date,
                                    i_flg_synch_note      => i_pn_note_type_cfg.flg_synchronized,
                                    i_import_screen       => pk_alert_constant.g_yes,
                                    i_id_pn_note_type     => i_id_pn_note_type,
                                    i_id_tasks            => NULL,
                                    i_id_task_types       => NULL,
                                    i_id_pn_soap_block    => NULL,
                                    i_id_epis_pn          => i_id_epis_pn,
                                    i_id_epis_pn_det_task => NULL,
                                    i_only_autopop        => pk_prog_notes_constants.g_no,
                                    o_data_import         => l_data_import,
                                    o_error               => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        --Transform cursor
        g_error := 'Transform cursor';
        IF NOT get_data_cursor(i_lang        => i_lang,
                               i_prof        => i_prof,
                               i_id_epis_pn  => NULL,
                               i_id_episode  => i_episode,
                               i_id_patient  => i_patient,
                               i_data_import => l_data_import,
                               i_data_block  => o_data_block,
                               i_flg_review  => i_pn_note_type_cfg.flg_review_all,
                               o_data        => o_data,
                               o_error       => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'open cursor parameter';
        OPEN o_data_import_list FOR
            SELECT *
              FROM TABLE(o_data);
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_types.open_my_cursor(o_data_import_list);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_data_import_list);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_DATA_IMPORT',
                                              o_error);
        
            RETURN FALSE;
    END get_data_import;

    /**
    * Get the list of tasks and data blocks that should be imported
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_episode            Episode ID
    * @param   i_soap_block         SOAP Block ID
    * @param   i_data_block         Data Block ID
    * @param   i_id_task_type       Task type id (Parent task type or single task type)    
    * @param   i_id_market          Market identifier
    * @param   i_id_department            Service identifier
    * @param   i_id_dep_clin_serv         Service/specialty identifier
    * @param   i_episode_software         Software ID associated to the episode
    * @param   i_configs_ctx             Configs context structure  
    * @param   o_data_blocks        List with the data blocks, task types and associated configs
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author Sofia Mendes
    * @version 2.6.2
    * @since   17-Nov-2011
    */
    FUNCTION get_task_configs
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_soap_block   IN epis_pn_det.id_pn_soap_block%TYPE,
        i_data_block   IN epis_pn_det.id_pn_data_block%TYPE,
        i_id_task_type IN epis_pn_det_task.id_task_type%TYPE,
        i_id_pn_group  IN pn_group.id_pn_group%TYPE,
        i_configs_ctx  IN pk_prog_notes_types.t_configs_ctx,
        o_data_blocks  OUT t_coll_data_blocks,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_data_blocks_import     table_number := table_number();
        l_soap_blocks_import     table_number := table_number();
        l_task_types             table_number := table_number();
        l_task_types_grp         table_number := table_number();
        l_flg_ea                 table_varchar := table_varchar();
        l_tasks_count            PLS_INTEGER;
        l_data_blocks_import_ctn PLS_INTEGER;
        l_dblock_rec             t_rec_dblock;
    
        l_func_name CONSTANT VARCHAR2(16 CHAR) := 'GET_TASK_CONFIGS';
        l_count_dblocks        PLS_INTEGER;
        l_task_types_childs    table_number;
        l_nr_task_types        PLS_INTEGER;
        l_flg_ea_tt            tl_task.flg_ea%TYPE;
        l_count_task_types     PLS_INTEGER;
        l_rec_dblock_task_type t_rec_dblock_task_type;
    BEGIN
        o_data_blocks := t_coll_data_blocks();
    
        --in case it is imported tasks that will appear in different data_blocks, when importing it is not specified the data block    
        IF (i_data_block IS NULL AND i_id_task_type IS NOT NULL)
        THEN
        
            SELECT id_pn_data_block, id_pn_soap_block, id_task_type, flg_ea
              BULK COLLECT
              INTO l_data_blocks_import, l_soap_blocks_import, l_task_types, l_flg_ea
              FROM (SELECT /*+opt_estimate(table,pdtt,scale_rows=0.0000001)*/
                     pdtt.id_pn_data_block, pdtt.id_pn_soap_block, pdtt.id_task_type, pdtt.flg_ea
                      FROM TABLE(i_configs_ctx.task_types) pdtt
                     WHERE pdtt.id_task_type = i_id_task_type
                    UNION ALL
                    SELECT /*+opt_estimate(table,pdtt,scale_rows=0.0000001)*/
                     pdtt.id_pn_data_block, pdtt.id_pn_soap_block, pdtt.id_task_type, pdtt.flg_ea
                      FROM TABLE(i_configs_ctx.task_types) pdtt
                     WHERE pdtt.task_type_id_parent = i_id_task_type);
            --ELSIF (i_data_block IS NULL AND i_id_pn_group IS NOT NULL)
        ELSIF ((i_data_block IS NULL OR i_id_task_type = 43) AND i_id_pn_group IS NOT NULL)
        THEN
            g_error := 'CALL pk_prog_notes_utils.get_task_types_from_group. i_id_pn_group: ' || i_id_pn_group;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_task_types_from_group(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_id_pn_group   => i_id_pn_group,
                                                                 o_id_task_types => l_task_types_grp,
                                                                 o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'GET data blocks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT /*+opt_estimate(table,pdtt,scale_rows=0.001)*/ /*+opt_estimate(table,tt,scale_rows=0.000000001)*/
             id_pn_data_block, id_pn_soap_block, id_task_type, flg_ea
              BULK COLLECT
              INTO l_data_blocks_import, l_soap_blocks_import, l_task_types, l_flg_ea
              FROM TABLE(i_configs_ctx.task_types) pdtt
              JOIN TABLE(l_task_types_grp) tt
                ON tt.column_value = pdtt.id_task_type;
        
        ELSIF (i_id_pn_group IS NOT NULL)
        THEN
            g_error := 'CALL pk_prog_notes_utils.get_task_types_from_group. i_id_pn_group: ' || i_id_pn_group;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_task_types_from_group(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_id_pn_group   => i_id_pn_group,
                                                                 o_id_task_types => l_task_types,
                                                                 o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_tasks_count := l_task_types.count;
            FOR i IN 1 .. l_tasks_count
            LOOP
                l_data_blocks_import.extend(1);
                l_data_blocks_import(l_data_blocks_import.last) := i_data_block;
            
                l_soap_blocks_import.extend(1);
                l_soap_blocks_import(l_soap_blocks_import.last) := i_soap_block;
            
                g_error := 'CALL pk_prog_notes_utils.get_task_flg_ea. i_id_task_type: ' || l_task_types(i);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_prog_notes_utils.get_task_flg_ea(i_lang         => i_lang,
                                                           i_prof         => i_prof,
                                                           i_id_task_type => l_task_types(i),
                                                           o_flg_ea       => l_flg_ea_tt,
                                                           o_error        => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                l_flg_ea.extend(1);
                l_flg_ea(l_flg_ea.last) := l_flg_ea_tt;
            
            END LOOP;
        
        ELSE
        
            l_data_blocks_import.extend(1);
            l_data_blocks_import(1) := i_data_block;
        
            l_soap_blocks_import.extend(1);
            l_soap_blocks_import(l_soap_blocks_import.last) := i_soap_block;
        
            l_task_types.extend(1);
            l_task_types(1) := i_id_task_type;
        
            g_error := 'CALL pk_prog_notes_utils.get_task_flg_ea. i_id_task_type: ' || i_id_task_type;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_task_flg_ea(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_id_task_type => i_id_task_type,
                                                       o_flg_ea       => l_flg_ea_tt,
                                                       o_error        => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_flg_ea.extend(1);
            l_flg_ea(l_flg_ea.last) := l_flg_ea_tt;
        END IF;
    
        l_data_blocks_import_ctn := l_data_blocks_import.count;
        l_count_dblocks          := i_configs_ctx.data_blocks.count;
    
        FOR i IN 1 .. l_data_blocks_import_ctn
        LOOP
            g_error := 'Get data block info id_pn_data_block: ' || l_data_blocks_import(i);
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --find the flg_import of the data block
            l_dblock_rec := NULL;
            FOR j IN 1 .. l_count_dblocks
            LOOP
                IF (i_configs_ctx.data_blocks(j).id_pn_data_block = l_data_blocks_import(i) AND i_configs_ctx.data_blocks(j)
                   .id_pn_soap_block = i_soap_block)
                THEN
                    l_dblock_rec := i_configs_ctx.data_blocks(j);
                    EXIT;
                END IF;
            END LOOP;
        
            --check if the task type has children, if so the EA records are associated to the child task types
            g_error := 'CALL pk_prog_notes_utils.get_child_task_types. parent task_type: ' || l_task_types(i);
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_child_task_types(i_lang          => i_lang,
                                                            i_prof          => i_prof,
                                                            i_id_task_type  => l_task_types(i),
                                                            o_task_types    => l_task_types_childs,
                                                            o_nr_task_types => l_nr_task_types,
                                                            o_error         => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_count_task_types := i_configs_ctx.task_types.count;
        
            FOR j IN 1 .. l_nr_task_types
            LOOP
                g_error := 'GET task type configs. id_task_type: ' || l_task_types_childs(j);
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                l_rec_dblock_task_type := NULL;
                FOR k IN 1 .. l_count_task_types
                LOOP
                    IF (i_configs_ctx.task_types(k).id_task_type = l_task_types_childs(j) AND i_configs_ctx.task_types(k)
                       .id_pn_data_block = l_data_blocks_import(i) AND i_configs_ctx.task_types(k)
                       .id_pn_soap_block = l_soap_blocks_import(i))
                    THEN
                        l_rec_dblock_task_type := i_configs_ctx.task_types(k);
                        EXIT;
                    END IF;
                END LOOP;
            
                g_error := 'CONSTRUCT the output structure';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                --Get the text for the SOAP/DATA BLOCK area filtered by date            
                o_data_blocks.extend(1);
                o_data_blocks(o_data_blocks.last) := t_rec_data_blocks(l_soap_blocks_import(i),
                                                                       l_data_blocks_import(i),
                                                                       NULL,
                                                                       l_dblock_rec.data_area,
                                                                       l_dblock_rec.id_doc_area,
                                                                       NULL,
                                                                       l_dblock_rec.flg_type,
                                                                       l_dblock_rec.flg_import,
                                                                       NULL,
                                                                       l_dblock_rec.flg_scope,
                                                                       NULL,
                                                                       l_dblock_rec.flg_actions_available,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       l_task_types_childs(j),
                                                                       l_dblock_rec.flg_import_date,
                                                                       l_dblock_rec.flg_outside_period,
                                                                       l_dblock_rec.days_available_period,
                                                                       NULL,
                                                                       NULL,
                                                                       l_dblock_rec.flg_group_on_import,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       l_dblock_rec.flg_show_sub_title,
                                                                       NULL,
                                                                       NULL,
                                                                       NULL,
                                                                       l_dblock_rec.id_summary_page,
                                                                       NULL,
                                                                       NULL,
                                                                       l_rec_dblock_task_type.flg_shortcut_filter,
                                                                       l_flg_ea(i),
                                                                       NULL,
                                                                       l_dblock_rec.flg_group_select_filter,
                                                                       l_rec_dblock_task_type.flg_synch_area,
                                                                       l_rec_dblock_task_type.flg_shortcut_filter,
                                                                       l_rec_dblock_task_type.review_cat,
                                                                       l_rec_dblock_task_type.flg_review_avail,
                                                                       l_rec_dblock_task_type.flg_description,
                                                                       l_rec_dblock_task_type.description_condition,
                                                                       l_dblock_rec.id_mtos_score,
                                                                       l_rec_dblock_task_type.flg_dt_task,
                                                                       l_dblock_rec.flg_exc_sum_page_da,
                                                                       l_dblock_rec.flg_group_type);
            END LOOP;
        
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_TASK_CONFIGS',
                                              o_error);
            RETURN FALSE;
    END get_task_configs;

    /**
    * Save an imported data block to a progress note
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_episode            Episode ID
    * @param   i_patient            Patient ID
    * @param   i_id_pn_note_type    Progress Note type (P-progress note; L-prolonged progress note; CC-intensive care note; H-history and physician note) 
    * @param   i_epis_pn            Progress note ID
    * @param   i_epis_pn_det        Progress note detail ID
    * @param   i_dep_clin_serv      Clinical Service ID
    * @param   i_pn_soap_block      SOAP Block ID
    * @param   i_pn_data_block      Data Block ID
    * @param   i_dt_begin           Start date to filter
    * @param   i_dt_end             End date to filter
    * @param   i_id_task_type       Array of task type ids
    * @param   i_id_pn_group        Group identifier
    * @param   i_id_epis_pn_det_task Epis_pn_det_task ID. To be used in templates when performing the copy and edit action, 
    *                                to replace the previous record (if configured to behave like that)
    * @param   o_flg_imported       Flg indicating data imported Y/N
    * @param   o_id_epis_pn        Id of the created note
    * @param   o_error              Error information
    *
    * @return  Boolean        True: Sucess, False: Fail
    * 
    * @author  RUI.SPRATLEY
    * @version 2.6.0.5
    * @since   16-02-2011
    */
    FUNCTION set_import_data_block
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_patient             IN patient.id_patient%TYPE,
        i_id_pn_note_type     IN epis_pn.id_pn_note_type%TYPE,
        i_epis_pn             IN epis_pn.id_epis_pn%TYPE,
        i_epis_pn_det         IN epis_pn_det.id_epis_pn_det%TYPE,
        i_dep_clin_serv       IN dep_clin_serv.id_dep_clin_serv%TYPE,
        i_soap_block          IN epis_pn_det.id_pn_soap_block%TYPE,
        i_data_block          IN epis_pn_det.id_pn_data_block%TYPE,
        i_dt_begin            IN VARCHAR2,
        i_dt_end              IN VARCHAR2,
        i_id_task_type        IN epis_pn_det_task.id_task_type%TYPE,
        i_id_pn_group         IN pn_group.id_pn_group%TYPE,
        i_id_epis_pn_det_task IN epis_pn_det_task.id_epis_pn_det_task%TYPE,
        o_flg_imported        OUT VARCHAR2,
        o_id_epis_pn          OUT epis_pn.id_epis_pn%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name   VARCHAR2(21 CHAR) := 'SET_IMPORT_DATA_BLOCK';
        l_data_import t_coll_data_import := t_coll_data_import();
    
        l_exception EXCEPTION;
    
        l_dt_begin TIMESTAMP WITH LOCAL TIME ZONE;
        l_dt_end   TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_id_doc_area pn_data_block.id_doc_area%TYPE;
    
        l_data_blocks t_coll_data_blocks := t_coll_data_blocks();
    
        l_outside_period  pn_dblock_mkt.flg_outside_period%TYPE;
        l_date_margin     pn_dblock_mkt.days_available_period%TYPE;
        l_flg_import_date pn_dblock_mkt.flg_import_date%TYPE;
        l_pn_note_type    t_rec_note_type;
    
        l_configs_ctx         pk_prog_notes_types.t_configs_ctx;
        l_note_struct         pk_prog_notes_types.t_note_struct;
        l_imported_data       t_coll_pn_work_data := t_coll_pn_work_data();
        l_tasks_descs_by_type pk_prog_notes_types.t_tasks_descs_by_type;
        l_rows_out            table_varchar := table_varchar();
        l_flg_status          VARCHAR2(1 CHAR);
        l_id_task             epis_pn_det_task.id_task%TYPE;
    BEGIN
    
        g_error := 'CALL reset_configs_ctx';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang             => i_lang,
                                           i_prof             => i_prof,
                                           i_episode          => i_episode,
                                           i_id_pn_note_type  => i_id_pn_note_type,
                                           i_id_dep_clin_serv => i_dep_clin_serv,
                                           i_epis_pn          => i_epis_pn);
    
        --We do not need to validate de imput datas according to the last input date for that SOAP/DATA BLOCK area
        --because the UX layer assures that the start date is the date where we pressed the shortcut button
        --and the end date is the one from the OK button on the other screen
    
        g_error := 'Convert strings to timestamps';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        --Convert string datas into timestamps
        l_dt_begin := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                    i_prof      => i_prof,
                                                    i_timestamp => i_dt_begin,
                                                    i_timezone  => NULL,
                                                    i_mask      => pk_date_utils.g_dateformat_msec);
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof => i_prof, i_timestamp => l_dt_begin, i_format => 'MI');
    
        l_dt_end := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_end, NULL);
    
        --because of some cases where the set function of the area is very quick and we try to import with the end date 
        --in the same second of the save in the are, I am going to add a second to the end date    
        l_dt_end := l_dt_end + INTERVAL '5' SECOND;
    
        g_error := 'CALL get_task_config. i_id_pn_note_type: ' || i_id_pn_note_type || ' i_soap_block: ' ||
                   i_soap_block || ' i_data_block: ' || i_data_block || ' i_id_task_type: ' || i_id_task_type;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_task_configs(i_lang         => i_lang,
                                i_prof         => i_prof,
                                i_soap_block   => i_soap_block,
                                i_data_block   => i_data_block,
                                i_id_task_type => i_id_task_type,
                                i_id_pn_group  => i_id_pn_group,
                                i_configs_ctx  => l_configs_ctx,
                                o_data_blocks  => l_data_blocks,
                                o_error        => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL get_data_import_list i_soap_block: ' || i_soap_block || ' i_data_block: ' || i_data_block ||
                   ' l_id_doc_area: ' || l_id_doc_area || ' i_id_task_type: ' || i_id_task_type ||
                   ' l_flg_import_date: ' || l_flg_import_date || ' l_outside_period: ' || l_outside_period ||
                   ' l_date_margin: ' || l_date_margin;
        pk_alertlog.log_debug(g_error);
        IF NOT get_data_import_list(i_lang                => i_lang,
                                    i_prof                => i_prof,
                                    i_id_episode          => i_episode,
                                    i_id_patient          => i_patient,
                                    i_id_visit            => pk_episode.get_id_visit(i_episode => i_episode),
                                    i_data_blocks         => l_data_blocks,
                                    i_begin_date          => l_dt_begin,
                                    i_end_date            => l_dt_end,
                                    i_flg_synch_note      => l_pn_note_type.flg_synchronized,
                                    i_import_screen       => pk_alert_constant.g_no,
                                    i_id_pn_note_type     => i_id_pn_note_type,
                                    i_id_tasks            => NULL,
                                    i_id_task_types       => NULL,
                                    i_id_pn_soap_block    => NULL,
                                    i_action              => pk_prog_notes_constants.g_flg_action_import,
                                    i_id_epis_pn          => i_epis_pn,
                                    i_id_epis_pn_det_task => table_number(i_id_epis_pn_det_task),
                                    i_only_autopop        => pk_prog_notes_constants.g_no,
                                    o_data_import         => l_data_import,
                                    o_error               => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF (l_data_import.exists(1))
        THEN
            --Transform cursor
            g_error := 'Transform cursor';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT get_data_cursor(i_lang        => i_lang,
                                   i_prof        => i_prof,
                                   i_id_epis_pn  => i_epis_pn,
                                   i_id_episode  => i_episode,
                                   i_id_patient  => i_patient,
                                   i_data_import => l_data_import,
                                   i_data_block  => l_data_blocks,
                                   i_flg_review  => l_configs_ctx.note_type.flg_review_all,
                                   o_data        => l_imported_data,
                                   o_error       => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'CALL get_import_save_struct';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT get_import_save_struct(i_lang                => i_lang,
                                          i_prof                => i_prof,
                                          i_episode             => i_episode,
                                          i_id_patient          => i_patient,
                                          i_id_pn_note_type     => i_id_pn_note_type,
                                          i_epis_pn             => i_epis_pn,
                                          i_epis_pn_det         => i_epis_pn_det,
                                          i_dep_clin_serv       => l_configs_ctx.id_dep_clin_serv,
                                          i_data_import         => l_imported_data,
                                          i_id_pn_area          => l_configs_ctx.note_type.id_pn_area,
                                          i_flg_synchronized    => l_configs_ctx.note_type.flg_synchronized,
                                          i_flg_review_all      => l_configs_ctx.note_type.flg_review_all,
                                          i_flg_definitive      => l_configs_ctx.note_type.flg_synchronized,
                                          i_flg_suggest_concept => l_configs_ctx.note_type.flg_suggest_concept,
                                          i_flg_action          => pk_prog_notes_constants.g_flg_action_shortcut,
                                          io_note_struct        => l_note_struct,
                                          o_tasks_descs_by_type => l_tasks_descs_by_type,
                                          o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'CALL ins_upd_pn_note';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT ins_upd_pn_note(i_lang                => i_lang,
                                   i_prof                => i_prof,
                                   i_id_episode          => i_episode,
                                   i_note_struct         => l_note_struct,
                                   i_dt_last_update      => current_timestamp,
                                   i_flg_synchronized    => l_configs_ctx.note_type.flg_synchronized,
                                   i_flg_sign_off        => l_configs_ctx.note_type.flg_sign_off,
                                   i_flg_submit          => l_configs_ctx.note_type.flg_submit,
                                   i_flg_upd_note        => pk_alert_constant.g_yes,
                                   i_tasks_descs_by_type => l_tasks_descs_by_type,
                                   o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            g_error := 'CALL update_task_ranks';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT update_aggregations(i_lang        => i_lang,
                                       i_prof        => i_prof,
                                       i_id_episode  => i_episode,
                                       i_id_visit    => pk_episode.get_id_visit(i_episode => i_episode),
                                       i_id_patient  => pk_episode.get_id_patient(i_episode => i_episode),
                                       i_note_struct => l_note_struct,
                                       o_error       => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF (l_configs_ctx.note_type.flg_copy_edit_replace = pk_alert_constant.g_yes AND
               i_id_epis_pn_det_task IS NOT NULL)
            THEN
                -- validate the record status 
                IF i_id_task_type = pk_prog_notes_constants.g_task_chief_complaint
                THEN
                    SELECT epdt.id_task
                    
                      INTO l_id_task
                      FROM epis_pn_det_task epdt
                     WHERE epdt.id_epis_pn_det_task = i_id_epis_pn_det_task;
                
                    IF NOT pk_complaint.get_complaint_status(i_lang => i_lang,
                                                             i_prof => i_prof,
                                                             
                                                             i_id_epis_complaint => l_id_task,
                                                             o_status            => l_flg_status,
                                                             o_error             => o_error)
                    THEN
                        o_flg_imported := pk_prog_notes_constants.g_yes;
                        o_id_epis_pn   := l_note_struct.id_epis_pn;
                    
                        RETURN TRUE;
                    END IF;
                
                    IF l_flg_status <> pk_prog_notes_constants.g_active
                    THEN
                        ts_epis_pn_det_task.upd(id_epis_pn_det_task_in => i_id_epis_pn_det_task,
                                                flg_status_in          => pk_prog_notes_constants.g_epis_pn_det_flg_status_r,
                                                rows_out               => l_rows_out);
                    
                        g_error := 'PROCESS UPDATE epis_pn_det_task WITH i_id_epis_pn_det_task: ' ||
                                   i_id_epis_pn_det_task;
                        pk_alertlog.log_info(text            => g_error,
                                             object_name     => g_package_name,
                                             sub_object_name => l_func_name);
                        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_table_name   => 'EPIS_PN_DET_TASK',
                                                      i_rowids       => l_rows_out,
                                                      i_list_columns => table_varchar('FLG_STATUS'),
                                                      o_error        => o_error);
                    
                    END IF;
                ELSE
                    ts_epis_pn_det_task.upd(id_epis_pn_det_task_in => i_id_epis_pn_det_task,
                                            flg_status_in          => pk_prog_notes_constants.g_epis_pn_det_flg_status_r,
                                            rows_out               => l_rows_out);
                
                    g_error := 'PROCESS UPDATE epis_pn_det_task WITH i_id_epis_pn_det_task: ' || i_id_epis_pn_det_task;
                    pk_alertlog.log_info(text            => g_error,
                                         object_name     => g_package_name,
                                         sub_object_name => l_func_name);
                    t_data_gov_mnt.process_update(i_lang         => i_lang,
                                                  i_prof         => i_prof,
                                                  i_table_name   => 'EPIS_PN_DET_TASK',
                                                  i_rowids       => l_rows_out,
                                                  i_list_columns => table_varchar('FLG_STATUS'),
                                                  o_error        => o_error);
                END IF;
            END IF;
        
            o_flg_imported := pk_prog_notes_constants.g_yes;
        ELSE
            o_flg_imported := pk_prog_notes_constants.g_no;
        END IF;
    
        o_id_epis_pn := l_note_struct.id_epis_pn;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            o_flg_imported := pk_prog_notes_constants.g_no;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            o_flg_imported := pk_prog_notes_constants.g_no;
            RETURN FALSE;
    END set_import_data_block;

    /**
    * remove child tasks of a certain parent
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_id_epis_pn_det_task  PN task detail identifier
    * @param   io_tbl_tasks           Tasks to update structure
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         ANTONIO.NETO
    * @version                        2.6.2
    * @since                          10-May-2012
    */
    FUNCTION remove_child_tasks
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_pn_det_task IN epis_pn_det_task.id_epis_pn_det_task%TYPE,
        io_tbl_tasks          IN OUT pk_prog_notes_types.t_table_tasks,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'REMOVE_CHILD_TASKS';
    
        CURSOR c_epis_pn_det_task IS
            SELECT epdtw.id_epis_pn_det_task
              FROM epis_pn_det_task epdtw
             WHERE epdtw.id_parent = i_id_epis_pn_det_task
               AND epdtw.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
    
        l_id_epis_pn_det_task epis_pn_det_task.id_epis_pn_det_task%TYPE;
    
    BEGIN
        g_error := 'Open EPIS_PN_DET_TASK cursor for i_id_epis_pn_det_task: ' || i_id_epis_pn_det_task;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_epis_pn_det_task;
        LOOP
            FETCH c_epis_pn_det_task
                INTO l_id_epis_pn_det_task;
            EXIT WHEN c_epis_pn_det_task%NOTFOUND;
        
            io_tbl_tasks(i_id_epis_pn_det_task).id_epis_pn_det_task := i_id_epis_pn_det_task;
            io_tbl_tasks(i_id_epis_pn_det_task).flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_r;
        
        END LOOP;
        CLOSE c_epis_pn_det_task;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END remove_child_tasks;

    /**
    * review the parent task of a certain child task (when creating a comment for reviewed task, we need also to put the parent task in the note)
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_id_epis_pn_det_task  PN task detail identifier
    * @param   io_tbl_tasks           PN tasks info
    *
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         ANTONIO.NETO
    * @version                        2.6.2
    * @since                          18-May-2012
    */
    FUNCTION review_task_parent
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_epis_pn_det_task IN epis_pn_det_task.id_epis_pn_det_task%TYPE,
        io_tbl_tasks          IN OUT pk_prog_notes_types.t_table_tasks,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'REVIEW_TASK_PARENT';
    BEGIN
        io_tbl_tasks(i_id_epis_pn_det_task).id_epis_pn_det_task := i_id_epis_pn_det_task;
        io_tbl_tasks(i_id_epis_pn_det_task).flg_status := pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END review_task_parent;

    /**
    * Update one data block's content. If the data doesn't exists yet, the record will be created.
    * the IN parameter Type allow for select if append or update should be done to the text.
    *
    * @param   i_lang                 Professional preferred language
    * @param   i_prof                 Professional identification and its context (institution and software)
    * @param   i_id_episode           Episode ID
    * @param   i_flg_action           C-Create; U-update; I-import
    * @param   i_prof_cat_type        Prof category type
    * @param   i_epis_pn_det          Progress note detail ID
    * @param   i_id_task              Task IDs
    * @param   i_id_task_aggregator   For analysis and exam recurrences, an imported registry will only be uniquely 
    *                                 identified by id_task (id_analysis/id_exam) + i_id_task_aggregator
    * @param   i_epis_pn_det_task     Array of PN task details
    * @param   i_pn_note_task         Array of PN task descriptions
    * @param   i_flg_add_rem_task     Array of task status (A- Active, R- Removed)
    * @param   i_flg_table_origin     Flag origin table for documentation ( D - documentation, A - Anamnesis, S - Review of system)
    * @param   i_dt_task              Task dates
    * @param   i_id_task_parent       Parent task identifier for comments functionality
    * @param   i_flg_task_parent      Flag tells where i_id_task_parent is a taskid or id_epis_pn_det_task
    * @param   i_id_multichoice       Array of tasks identifiers for cases that have more than one parameter (multichoice on exam results)
    * @param   i_rank_task            Rank of the tasks
    * @param   i_prof_task            Professional that created the tasks
    * @param   i_id_group_table       Id Group (vital sign id): vital signs table row id
    * @param   i_dblock_cfgs          Data block configs record
    * @param   i_id_patient           Patient id
    * @param   i_dt_pn_date           Progress Note date
    * @param   i_date_type            DH- Date hour; D-Date
    * @param   i_dblock_type          Data block type
    *
    * @param   io_id_task_type        Array of PN task types
    *
    * @param   O_FLG_RELOAD            Tells UX layer it It's needed the reload screen or not
    * @param   o_error                Error information
    *
    * @return  Boolean                True: Sucess, False: Fail
    *
    * @author                         RUI.BATISTA
    * @version                        <2.6.0.5>
    * @since                          04-02-2011
    */
    FUNCTION set_data_block_task
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_episode         IN episode.id_episode%TYPE,
        i_flg_action         IN VARCHAR2,
        i_prof_cat_type      IN category.flg_type%TYPE,
        i_epis_pn_det        IN epis_pn_det.id_epis_pn_det%TYPE,
        i_id_task            IN table_number,
        i_id_task_aggregator IN table_number,
        i_epis_pn_det_task   IN table_number,
        i_pn_note_task       IN table_clob,
        i_flg_add_rem_task   IN table_varchar,
        i_flg_table_origin   IN table_varchar DEFAULT NULL,
        i_dt_task            IN table_varchar,
        i_id_task_parent     IN table_number,
        i_flg_task_parent    IN VARCHAR2,
        i_id_multichoice     IN table_number,
        i_rank_task          IN table_number,
        i_prof_task          IN table_number,
        i_id_group_table     IN table_number,
        i_dblock_cfgs        IN t_rec_dblock,
        i_dblock_task_type   IN t_coll_dblock_task_type DEFAULT NULL,
        i_id_patient         IN patient.id_patient%TYPE,
        i_dt_pn_date         IN VARCHAR2,
        i_date_type          IN VARCHAR2,
        i_dblock_type        IN pn_data_block.flg_type%TYPE,
        i_flg_related        IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_group_type     IN VARCHAR2 DEFAULT NULL,
        io_id_task_type      IN OUT table_number,
        o_tbl_tasks          OUT pk_prog_notes_types.t_table_tasks,
        o_flg_reload         OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'SET_DATA_BLOCK_TASK';
    
        l_id_tasks       table_number := i_id_task;
        l_id_task_parent table_number := i_id_task_parent;
        l_pn_note_task   table_clob := i_pn_note_task;
        l_save_task      VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
        e_comment_on_area    EXCEPTION;
        e_review_task_parent EXCEPTION;
        l_id_task               epis_pn_det_task.id_task%TYPE;
        l_scores                table_number;
        l_flg_status_task       epis_pn_det_task.flg_status%TYPE;
        l_number_of_time_do_for PLS_INTEGER;
    
        l_dt_group_import        epis_pn_det_task.dt_group_import%TYPE;
        l_id_group_import        epis_pn_det_task.id_group_import%TYPE;
        l_desc_group             VARCHAR2(200 CHAR);
        l_code_desc_group_parent epis_pn_det_task.code_desc_group_parent%TYPE;
        l_code_desc_group        epis_pn_det_task.code_desc_group%TYPE;
        l_id_sub_group_import    epis_pn_det_task.id_sub_group_import%TYPE;
        l_code_desc_sub_group    epis_pn_det_task.code_desc_sub_group%TYPE;
        l_id_group_table         epis_pn_det_task.id_group_table%TYPE;
    
        l_id_sample_type        epis_pn_det_task.id_sample_type%TYPE;
        l_code_desc_sample_type epis_pn_det_task.code_desc_sample_type%TYPE;
        l_id_prof_task          epis_pn_det_task.id_prof_task%TYPE;
    
        l_instructions_hash epis_pn_det_task.instructions_hash%TYPE;
    
        l_rec_task pk_prog_notes_types.t_rec_tasks;
    
        l_id_prof_review task_timeline_ea.id_prof_review%TYPE;
        l_dt_review      task_timeline_ea.dt_review%TYPE;
    
        l_flg_action     epis_pn_det_task.flg_action%TYPE := i_flg_action;
        l_dt_task        epis_pn_det_task.dt_task%TYPE;
        l_rank_task      epis_pn_det_task.rank_task%TYPE;
        l_dt_last_update epis_pn_det_task.dt_last_update%TYPE;
    
        l_rec_dblock_task_type t_rec_dblock_task_type;
    
        l_id_epis_pn       epis_pn.id_epis_pn%TYPE;
        l_id_pn_data_block epis_pn_det.id_pn_data_block%TYPE;
        l_id_pn_soap_block epis_pn_det.id_pn_soap_block%TYPE;
        --procedure to check if there are tasks with parents (comments functionality)
        --if so iterate first the parent tasks then the childs
        PROCEDURE checkparentsfirst IS
            l_task_parent_count    PLS_INTEGER;
            l_task_parent_not_null PLS_INTEGER;
            l_task_parent_null     PLS_INTEGER;
        BEGIN
            IF i_id_task_parent IS NOT NULL
            THEN
                l_task_parent_count    := i_id_task_parent.count;
                l_task_parent_not_null := 0;
                l_task_parent_null     := 0;
                FOR aux_parent IN 1 .. l_task_parent_count
                LOOP
                    IF i_id_task_parent(aux_parent) IS NOT NULL
                    THEN
                        l_task_parent_not_null := l_task_parent_not_null + 1;
                    ELSE
                        l_task_parent_null := l_task_parent_null + 1;
                    END IF;
                END LOOP;
                IF l_task_parent_not_null + l_task_parent_null > 1
                THEN
                    l_number_of_time_do_for := 2;
                ELSE
                    l_number_of_time_do_for := 1;
                END IF;
            ELSE
                l_number_of_time_do_for := 1;
            END IF;
        END checkparentsfirst;
    
    BEGIN
        -- The comments does not have i_id_task
        IF (i_id_task IS NOT NULL AND i_id_task.exists(1))
        THEN
            --check if there is parents
            checkparentsfirst;
        
            FOR aux_parent_child IN 1 .. l_number_of_time_do_for
            LOOP
                FOR i IN 1 .. i_id_task.count
                LOOP
                
                    IF i_id_task_parent IS NOT NULL
                       AND i_id_task_parent.exists(i)
                       AND i_id_task_parent(i) IS NOT NULL
                    THEN
                        IF aux_parent_child = 2
                           OR l_number_of_time_do_for = 1
                        THEN
                        
                            g_error := 'CALL set_comment_on_area';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT pk_prog_notes_in.set_comment_on_area(i_lang            => i_lang,
                                                                   i_prof            => i_prof,
                                                                   i_id_episode      => i_id_episode,
                                                                   i_id_epis_pn_det  => i_epis_pn_det,
                                                                   i_flg_task_parent => i_flg_task_parent,
                                                                   i_id_multichoice  => CASE
                                                                                            WHEN i_id_multichoice.exists(i) THEN
                                                                                             i_id_multichoice(i)
                                                                                            ELSE
                                                                                             NULL
                                                                                        END,
                                                                   i_tbl_tasks       => o_tbl_tasks,
                                                                   io_id_task        => l_id_tasks(i),
                                                                   io_id_task_type   => io_id_task_type(i),
                                                                   io_id_task_parent => l_id_task_parent(i),
                                                                   io_pn_note_task   => l_pn_note_task(i),
                                                                   o_save_task       => l_save_task,
                                                                   o_error           => o_error)
                            THEN
                                RAISE e_comment_on_area;
                            ELSE
                                --TODO!!!
                                --save parent task to the note if it is to be reviewed
                                g_error := 'CALL REVIEW_TASK_PARENT. i_id_epis_pn_det_task: ' || l_id_task_parent(i);
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                IF NOT review_task_parent(i_lang                => i_lang,
                                                          i_prof                => i_prof,
                                                          i_id_epis_pn_det_task => l_id_task_parent(i),
                                                          io_tbl_tasks          => o_tbl_tasks,
                                                          o_error               => o_error)
                                THEN
                                    RAISE e_review_task_parent;
                                END IF;
                            
                            END IF;
                        ELSE
                            l_save_task := pk_alert_constant.g_no;
                        END IF;
                    ELSE
                        IF aux_parent_child = 1
                        THEN
                            l_save_task := pk_alert_constant.g_yes;
                        ELSE
                            l_save_task := pk_alert_constant.g_no;
                        END IF;
                    END IF;
                    IF i_flg_related = pk_alert_constant.g_yes
                       AND i_epis_pn_det IS NOT NULL
                    THEN
                        BEGIN
                            SELECT id_epis_pn, id_pn_data_block, id_pn_soap_block
                              INTO l_id_epis_pn, l_id_pn_data_block, l_id_pn_soap_block
                              FROM epis_pn_det ed
                             WHERE ed.id_epis_pn_det = i_epis_pn_det;
                        EXCEPTION
                            WHEN OTHERS THEN
                                l_id_epis_pn := 0;
                        END;
                        IF l_id_epis_pn <> 0
                        THEN
                            IF pk_prog_notes_utils.check_imported_record(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_id_episode         => i_id_episode,
                                                                         i_id_epis_pn         => l_id_epis_pn,
                                                                         i_id_task            => l_id_tasks(i),
                                                                         i_id_task_aggregator => NULL,
                                                                         i_id_task_type       => io_id_task_type(i),
                                                                         i_id_pn_data_block   => l_id_pn_data_block,
                                                                         i_id_pn_soap_block   => l_id_pn_soap_block,
                                                                         i_flg_only_active    => pk_alert_constant.g_yes) =
                               pk_alert_constant.g_yes
                            THEN
                                l_save_task := pk_alert_constant.g_no;
                            END IF;
                        END IF;
                    
                    END IF;
                    IF l_save_task = pk_alert_constant.g_yes
                    THEN
                    
                        IF (l_flg_action <> pk_prog_notes_constants.g_flg_action_import)
                        THEN
                            g_error := 'CALL pk_prog_notes_utils.get_flg_synch_area';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF (pk_prog_notes_utils.get_flg_synch_area(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_id_task_type => io_id_task_type(i)) =
                               pk_alert_constant.g_yes)
                            THEN
                                g_error := 'CALL SET_SYNCHRONIZABLE_AREAS id_task_type: ' || io_id_task_type(i);
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                IF NOT pk_prog_notes_in.set_synchronizable_areas(i_lang             => i_lang,
                                                                            i_prof             => i_prof,
                                                                            i_id_episode       => i_id_episode,
                                                                            i_id_patient       => i_id_patient,
                                                                            i_dt_pn_date       => i_dt_pn_date,
                                                                            i_date_type        => i_date_type,
                                                                            i_pn_note_task     => CASE
                                                                                                      WHEN i_pn_note_task.exists(i) THEN
                                                                                                       i_pn_note_task(i)
                                                                                                      ELSE
                                                                                                       NULL
                                                                                                  END,
                                                                            i_flg_add_rem_task => CASE
                                                                                                      WHEN i_flg_add_rem_task.exists(i) THEN
                                                                                                       i_flg_add_rem_task(i)
                                                                                                      ELSE
                                                                                                       NULL
                                                                                                  END,
                                                                            i_flg_task_parent  => pk_alert_constant.g_yes,
                                                                            i_prof_cat_type    => i_prof_cat_type,
                                                                            i_id_doc_area      => i_dblock_cfgs.id_doc_area,
                                                                            i_dblock_type      => i_dblock_type,
                                                                            io_id_task         => l_id_tasks(i),
                                                                            io_id_task_type    => io_id_task_type(i),
                                                                            io_id_task_parent  => l_id_task_parent(i),
                                                                            o_flg_reload       => o_flg_reload,
                                                                            o_dt_task          => l_dt_task,
                                                                            o_error            => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            END IF;
                        END IF;
                    
                        -- Because flash sends an array of empty values and not null values the
                        --code needs to be like this, comparing empty strings and not nulls
                        IF nvl(l_id_tasks(i), -1) != -1
                        THEN
                            l_flg_status_task := CASE
                                                     WHEN i_flg_add_rem_task.exists(i) THEN
                                                      CASE
                                                          WHEN i_flg_add_rem_task(i) IN
                                                               (pk_prog_notes_constants.g_copy_template_action,
                                                                pk_prog_notes_constants.g_review_action) THEN
                                                           pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                                                          WHEN i_flg_add_rem_task(i) = pk_prog_notes_constants.g_remove_action THEN
                                                           pk_prog_notes_constants.g_remove_action
                                                          WHEN i_flg_add_rem_task(i) = pk_prog_notes_constants.g_epis_pn_det_sug_rem_i THEN
                                                           pk_prog_notes_constants.g_epis_pn_det_sug_rem_i
                                                          ELSE
                                                          
                                                           pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                                                      
                                                      END
                                                     ELSE
                                                      pk_prog_notes_constants.g_epis_pn_det_flg_status_a
                                                 END;
                        
                            --If i_epis_pn_det_task is null then create new record
                            IF ((NOT i_epis_pn_det_task.exists(i)) OR i_epis_pn_det_task(i) IS NULL)
                            THEN
                            
                                IF (i_flg_add_rem_task.exists(i) AND
                                   i_flg_add_rem_task(i) = pk_prog_notes_constants.g_copy_template_action)
                                THEN
                                    g_error := 'CALL set_copy_template. i_id_episode: ' || i_id_episode ||
                                               ' i_prof_cat_type: ' || i_prof_cat_type || ' l_id_tasks: ' ||
                                               l_id_tasks(i);
                                    IF NOT set_copy_template(i_lang                  => i_lang,
                                                             i_prof                  => i_prof,
                                                             i_id_episode            => i_id_episode,
                                                             i_prof_cat_type         => i_prof_cat_type,
                                                             i_id_task               => l_id_tasks(i),
                                                             o_id_epis_documentation => l_id_task,
                                                             o_id_epis_scales_score  => l_scores,
                                                             o_error                 => o_error)
                                    THEN
                                        RAISE g_exception;
                                    END IF;
                                
                                ELSE
                                    l_id_task := l_id_tasks(i);
                                END IF;
                            ELSE
                                l_id_task := l_id_tasks(i);
                            
                                --Else if i_epis_pn_det_task is not null then update record                        
                            END IF;
                        
                            --if flg_type = TB only allow rank 1,2,3 the others should be removed
                            g_error := 'CALL pk_prog_notes_utils.get_aggregation_data_from_ea. l_id_task: ' ||
                                       l_id_task || ' task_type:' || io_id_task_type(i);
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT pk_prog_notes_utils.get_aggregation_data_from_ea(i_lang                   => i_lang,
                                                                               i_prof                   => i_prof,
                                                                               i_id_task_type           => io_id_task_type(i),
                                                                               i_id_task                => l_id_task,
                                                                               i_id_task_aggregator     => CASE
                                                                                                               WHEN i_id_task_aggregator.exists(1) THEN
                                                                                                                i_id_task_aggregator(i)
                                                                                                               ELSE
                                                                                                                NULL
                                                                                                           END,
                                                                               i_id_patient             => i_id_patient,
                                                                               i_flg_group_type         => i_flg_group_type,
                                                                               i_dt_task                => CASE
                                                                                                               WHEN i_dt_task.exists(1) THEN
                                                                                                                i_dt_task(i)
                                                                                                               ELSE
                                                                                                                NULL
                                                                                                           END,
                                                                               o_dt_group_import        => l_dt_group_import,
                                                                               o_id_group_import        => l_id_group_import,
                                                                               o_code_desc_group        => l_code_desc_group,
                                                                               o_desc_group             => l_desc_group,
                                                                               o_id_sub_group_import    => l_id_sub_group_import,
                                                                               o_code_desc_sub_group    => l_code_desc_sub_group,
                                                                               o_id_sample_type         => l_id_sample_type,
                                                                               o_code_desc_sample_type  => l_code_desc_sample_type,
                                                                               o_id_prof_task           => l_id_prof_task,
                                                                               o_code_desc_group_parent => l_code_desc_group_parent,
                                                                               o_instructions_hash      => l_instructions_hash,
                                                                               o_error                  => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            l_id_group_table := CASE
                                                    WHEN i_id_group_table IS NOT NULL
                                                         AND i_id_group_table.exists(1) THEN
                                                     i_id_group_table(i)
                                                    ELSE
                                                     NULL
                                                END;
                        
                            g_error := 'CALL pk_prog_notes_utils.get_review_data_from_ea';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT pk_prog_notes_utils.get_review_data_from_ea(i_lang           => i_lang,
                                                                               i_prof           => i_prof,
                                                                               i_id_task_type   => io_id_task_type(i),
                                                                               i_id_task        => l_id_task,
                                                                               o_id_prof_review => l_id_prof_review,
                                                                               o_dt_review      => l_dt_review,
                                                                               o_dt_last_update => l_dt_last_update,
                                                                               o_error          => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            IF (io_id_task_type(i) = pk_prog_notes_constants.g_task_ph_obstetric_hist)
                            THEN
                                g_error := 'CALL pk_pregnancy.get_n_pregnancy. l_id_task: ' || l_id_task;
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                IF NOT pk_pregnancy.get_n_pregnancy(i_lang            => i_lang,
                                                                    i_prof            => i_prof,
                                                                    i_id_pat_pregancy => l_id_task,
                                                                    o_n_pregnancy     => l_rank_task)
                                THEN
                                    RAISE g_exception;
                                END IF;
                                l_rank_task := l_rank_task * -1;
                            
                            ELSE
                                l_rank_task := CASE
                                                   WHEN i_rank_task.exists(i) THEN
                                                    i_rank_task(i)
                                                   ELSE
                                                    NULL
                                               END;
                            END IF;
                        
                            IF (i_flg_action <> pk_prog_notes_constants.g_flg_action_import AND l_id_task IS NOT NULL)
                            THEN
                                l_flg_action := pk_prog_notes_constants.g_flg_action_shortcut;
                            END IF;
                        
                            IF (i_dt_task.exists(i) AND i_dt_task(i) IS NOT NULL)
                            THEN
                                g_error := 'CALL pk_date_utils.get_string_tstz';
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                l_dt_task := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                           i_prof      => i_prof,
                                                                           i_timestamp => i_dt_task(i),
                                                                           i_timezone  => NULL);
                            ELSE
                                l_dt_task := l_dt_last_update;
                            END IF;
                        
                            IF i_dblock_task_type IS NOT NULL
                            THEN
                                g_error := 'CALL pk_prog_notes_utils.get_task_type_cfgs_rec';
                                pk_alertlog.log_info(text            => g_error,
                                                     object_name     => g_package,
                                                     sub_object_name => l_func_name);
                                IF NOT pk_prog_notes_utils.get_task_type_cfgs_rec(i_lang                  => i_lang,
                                                                                  i_prof                  => i_prof,
                                                                                  i_coll_dblock_task_type => i_dblock_task_type,
                                                                                  i_id_pn_data_block      => i_dblock_cfgs.id_pn_data_block,
                                                                                  i_id_pn_soap_block      => i_dblock_cfgs.id_pn_soap_block,
                                                                                  i_id_task_type          => io_id_task_type(i),
                                                                                  o_rec_dblock_task_type  => l_rec_dblock_task_type,
                                                                                  o_error                 => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            END IF;
                        
                            g_error := 'CALL get_epis_pn_det_task_struct';
                            pk_alertlog.log_info(text            => g_error,
                                                 object_name     => g_package,
                                                 sub_object_name => l_func_name);
                            IF NOT get_epis_pn_det_task_struct(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_id_episode             => i_id_episode,
                                                          i_id_task                => l_id_task,
                                                          i_id_task_type           => io_id_task_type(i),
                                                          i_id_epis_pn_det         => i_epis_pn_det,
                                                          i_id_task_aggregator     => CASE
                                                                                          WHEN i_id_task_aggregator.exists(i) THEN
                                                                                           i_id_task_aggregator(i)
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_flg_status             => l_flg_status_task,
                                                          i_pn_note                => CASE
                                                                                          WHEN l_pn_note_task.exists(i) THEN
                                                                                           l_pn_note_task(i)
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_flg_table_origin       => CASE
                                                                                          WHEN i_flg_table_origin.exists(i) THEN
                                                                                           i_flg_table_origin(i)
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_dt_task                => CASE
                                                                                          WHEN io_id_task_type(i) IN
                                                                                               (pk_prog_notes_constants.g_task_templates) THEN
                                                                                           current_timestamp
                                                                                          ELSE
                                                                                           l_dt_task
                                                                                      END,
                                                          i_id_parent              => CASE
                                                                                          WHEN l_id_task_parent IS NOT NULL
                                                                                               AND l_id_task_parent.exists(i) THEN
                                                                                           l_id_task_parent(i)
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_rank_task              => l_rank_task,
                                                          i_id_prof_task           => CASE
                                                                                          WHEN i_prof_task.exists(i) THEN
                                                                                           i_prof_task(i)
                                                                                          ELSE
                                                                                           l_id_prof_task
                                                                                      END,
                                                          i_id_epis_pn_det_task    => CASE
                                                                                          WHEN i_epis_pn_det_task.exists(i) THEN
                                                                                           i_epis_pn_det_task(i)
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_id_task_parent         => NULL,
                                                          i_dt_group_import        => l_dt_group_import,
                                                          i_id_group_import        => l_id_group_import,
                                                          i_code_desc_group        => l_code_desc_group,
                                                          i_desc_group             => l_desc_group,
                                                          i_id_sub_group_import    => l_id_sub_group_import,
                                                          i_code_desc_sub_group    => l_code_desc_sub_group,
                                                          i_id_group_table         => l_id_group_table,
                                                          i_flg_aggregate_data     => i_dblock_cfgs.flg_group_on_import,
                                                          i_table_position         => NULL,
                                                          i_code_description       => NULL,
                                                          i_universal_desc_clob    => NULL,
                                                          i_flg_sos                => NULL,
                                                          i_dt_begin               => NULL,
                                                          i_id_doc_area            => NULL,
                                                          i_dt_register            => l_dt_task,
                                                          i_flg_show_sub_title     => i_dblock_cfgs.flg_show_sub_title,
                                                          i_id_prof_review         => l_id_prof_review,
                                                          i_dt_review              => l_dt_review,
                                                          i_code_status            => NULL,
                                                          i_flg_status_req         => NULL,
                                                          i_end_date               => NULL,
                                                          i_dt_req                 => NULL,
                                                          i_id_task_notes          => NULL,
                                                          i_flg_action             => CASE
                                                                                          WHEN l_flg_action IN
                                                                                               (pk_prog_notes_constants.g_flg_action_import,
                                                                                                pk_prog_notes_constants.g_flg_action_shortcut,
                                                                                                pk_prog_notes_constants.g_flg_action_autopop) THEN
                                                                                           l_flg_action
                                                                                      
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                          i_id_sample_type         => l_id_sample_type,
                                                          i_code_desc_sample_type  => l_code_desc_sample_type,
                                                          i_flg_description        => l_rec_dblock_task_type.flg_description, --VERIFICAR
                                                          i_description_condition  => l_rec_dblock_task_type.description_condition,
                                                          i_code_desc_group_parent => l_code_desc_group_parent,
                                                          i_instructions_hash      => l_instructions_hash,
                                                          o_rec_task               => l_rec_task,
                                                          o_error                  => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        
                            o_tbl_tasks(l_rec_task.id_epis_pn_det_task) := l_rec_task;
                        
                            g_error := 'CALL PK_PROG_NOTES_IN.GET_COMMENT_TASK_TYPE_PARENT';
                            IF i_epis_pn_det_task.exists(i)
                               AND i_epis_pn_det_task(i) IS NOT NULL
                               AND l_flg_status_task = pk_prog_notes_constants.g_epis_pn_det_flg_status_r
                               AND
                               pk_prog_notes_in.get_comment_task_type_parent(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_id_task_type => io_id_task_type(i)) IS NOT NULL
                            THEN
                                g_error := 'CALL REMOVE_CHILD_TASKS';
                                IF NOT remove_child_tasks(i_lang                => i_lang,
                                                          i_prof                => i_prof,
                                                          i_id_epis_pn_det_task => i_epis_pn_det_task(i),
                                                          io_tbl_tasks          => o_tbl_tasks,
                                                          o_error               => o_error)
                                THEN
                                    RAISE g_exception;
                                END IF;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            END LOOP;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'set_data_block_task',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_data_block_task;

    /**************************************************************************
    * Returns a set of records done in a touch-option area for a specific id_epis_documentation
    *                                                                         
    * @param i_lang                   Language ID                             
    * @param i_prof                   Profissional ID                         
    * @param i_id_episode             Episode ID
    * @param i_id_epis_documentation  Epis documentation ID
    * @param i_scope                  Scope ID (Patient ID, Visit ID, Episode ID)    
    * @param i_scope_type             Scope type (by patient {P}, by visit {V}, by episode{E})
    *
    * @param   o_doc_area_register    Cursor with the doc area info register
    * @param   o_doc_area_val         Cursor containing the completed info for episode
    * @param   o_template_layouts     Cursor containing the layout for each template used
    * @param   o_doc_area_component   Cursor containing the components for each template used 
    * @param   o_id_doc_area          Documentation area ID 
    * @param   o_error                Error
    *                                                                         
    * @author                         Filipe Silva                            
    * @version                        2.6.0.5                                 
    * @since                          2011/03/03                                 
    **************************************************************************/
    FUNCTION get_epis_document_area_value
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_episode            IN episode.id_episode%TYPE,
        i_id_epis_documentation IN epis_documentation.id_epis_documentation%TYPE,
        i_scope                 NUMBER,
        i_scope_type            IN VARCHAR2,
        o_doc_area_register     OUT pk_touch_option.t_cur_doc_area_register,
        o_doc_area_val          OUT pk_touch_option.t_cur_doc_area_val,
        o_template_layouts      OUT pk_types.cursor_type,
        o_doc_area_component    OUT pk_types.cursor_type,
        o_id_doc_area           OUT NUMBER,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_function_name VARCHAR2(30 CHAR) := 'GET_EPIS_DOCUMENT_AREA_VALUE';
        l_id_doc_area   epis_documentation.id_doc_area%TYPE;
        l_record_count  NUMBER;
    
    BEGIN
        g_error := 'CALL PK_TOUCH_OPTION.GET_DOC_AREA_FROM_EPIS_DOC FOR I_ID_EPIS_DOCUMENTATION: ' ||
                   i_id_epis_documentation;
        pk_alertlog.log_debug(g_error);
        IF NOT pk_touch_option.get_doc_area_from_epis_doc(i_lang     => i_lang,
                                                          i_prof     => i_prof,
                                                          i_epis_doc => i_id_epis_documentation,
                                                          o_doc_area => l_id_doc_area,
                                                          o_error    => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL PK_TOUCH_OPTION.GET_DOC_AREA_VALUE';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_touch_option.get_doc_area_value(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_doc_area           => l_id_doc_area,
                                                  i_current_episode    => i_id_episode,
                                                  i_scope              => i_scope,
                                                  i_scope_type         => i_scope_type,
                                                  o_doc_area_register  => o_doc_area_register,
                                                  o_doc_area_val       => o_doc_area_val,
                                                  o_template_layouts   => o_template_layouts,
                                                  o_doc_area_component => o_doc_area_component,
                                                  o_record_count       => l_record_count,
                                                  o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        o_id_doc_area := l_id_doc_area;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
            pk_touch_option.open_cur_doc_area_register(i_cursor => o_doc_area_register);
            pk_touch_option.open_cur_doc_area_val(i_cursor => o_doc_area_val);
            pk_types.open_my_cursor(i_cursor => o_template_layouts);
            pk_types.open_my_cursor(i_cursor => o_doc_area_component);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_function_name,
                                              o_error    => o_error);
            pk_touch_option.open_cur_doc_area_register(i_cursor => o_doc_area_register);
            pk_touch_option.open_cur_doc_area_val(i_cursor => o_doc_area_val);
            pk_types.open_my_cursor(i_cursor => o_template_layouts);
            pk_types.open_my_cursor(i_cursor => o_doc_area_component);
            RETURN FALSE;
    END get_epis_document_area_value;

    /**********************************************************************************************
    * DELETE_NOTE         Deletes a note.
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_id_epis_pn                    Note identifier
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Sofia Mendes
    * @version                               2.6.2
    * @since                                 29-Mar-2012
    **********************************************************************************************/
    FUNCTION delete_note
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_epis_pn IN epis_pn.id_epis_pn%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rows_out table_varchar := table_varchar();
    BEGIN
        l_rows_out := table_varchar();
        g_error    := 'CALL ts_epis_pn_addendum_hist. i_id_epis_pn: ' || i_id_epis_pn;
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_addendum_hist.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_ADDENDUM_HIST';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_ADDENDUM_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
        g_error    := 'CALL ts_epis_pn_addendum. i_id_epis_pn: ' || i_id_epis_pn;
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_addendum.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_ADDENDUM';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_ADDENDUM',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
        g_error    := 'CALL ts_epis_pn_signoff_hist. i_id_epis_pn: ' || i_id_epis_pn;
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_signoff_hist.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_SIGNOFF_HIST';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_SIGNOFF_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
        g_error    := 'CALL ts_epis_pn_signoff.';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_signoff.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_SIGNOFF';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_SIGNOFF',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
        g_error    := 'CALL ts_epis_pn_det_task_hist';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_det_task_hist.del_by(where_clause_in => 'id_epis_pn_det IN (SELECT ep.id_epis_pn_det
                                      FROM epis_pn_det_hist ep
                                     WHERE ep.id_epis_pn = ' ||
                                                           i_id_epis_pn || ')',
                                        rows_out        => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_DET_TASK_HIST';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_DET_TASK_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
    
        g_error := 'CALL ts_epis_pn_det_task';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_det_task.del_by(where_clause_in => 'id_epis_pn_det IN (SELECT ep.id_epis_pn_det
                                      FROM epis_pn_det ep
                                     WHERE ep.id_epis_pn =' ||
                                                      i_id_epis_pn || ')',
                                   rows_out        => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_DET_TASK';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_DET_TASK',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
    
        g_error := 'CALL ts_epis_pn_det_hist';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_det_hist.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_DET_HIST';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_DET_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
    
        g_error := 'CALL ts_epis_pn_det';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_det.del_eptd_epn_fk(id_epis_pn_in => i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_DET';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_DET',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
    
        g_error := 'CALL ts_epis_pn_hist';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn_hist.del_by(where_clause_in => 'id_epis_pn = ' || i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN_HIST';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN_HIST',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        l_rows_out := table_varchar();
    
        g_error := 'CALL ts_epis_pn';
        pk_alertlog.log_debug(text => g_error);
        ts_epis_pn.del(id_epis_pn_in => i_id_epis_pn, rows_out => l_rows_out);
    
        g_error := 'PROCESS DELETE EPIS_PN';
        pk_alertlog.log_debug(text => g_error);
        t_data_gov_mnt.process_delete(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_PN',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'DELETE_NOTE',
                                              o_error);
            RETURN FALSE;
    END delete_note;

    /**********************************************************************************************
    * SET_MATCH_SINGLE_PAGE                 This function rebuilds the single pages after an episode merge.
    *                                       it has to be called in the end of the match.
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_episode_temp                  Temporary episode
    * @param i_episode                       Episode identifier 
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Sofia Mendes
    * @version                               2.6.2
    * @since                                 29-Mar-2012
    **********************************************************************************************/
    FUNCTION set_match_single_page
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode_temp IN episode.id_episode%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_note     epis_pn.id_epis_pn%TYPE;
        l_configs_ctx pk_prog_notes_types.t_configs_ctx;
    
        l_func_name CONSTANT VARCHAR(21 CHAR) := 'SET_MATCH_SINGLE_PAGE';
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        FOR rec IN (SELECT /*+opt_estimate(table,nt,scale_rows=1)*/
                     epn.id_pn_note_type
                      FROM epis_pn epn
                      JOIN TABLE(pk_prog_notes_utils.tf_pn_note_type(i_lang, i_prof, i_episode, NULL, NULL, NULL, epn.id_dep_clin_serv, NULL, NULL, epn.id_pn_note_type, pk_prog_notes_constants.g_pn_flg_scope_notetype_n, NULL)) nt
                        ON nt.id_pn_note_type = epn.id_pn_note_type
                     WHERE epn.id_episode = i_episode
                       AND nt.flg_synchronized = pk_alert_constant.g_yes
                     GROUP BY epn.id_pn_note_type, epn.id_episode
                    HAVING COUNT(1) > 1)
        LOOP
            g_error := 'CALL reset_configs_ctx';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_configs_ctx := reset_configs_ctx(i_lang            => i_lang,
                                               i_prof            => i_prof,
                                               i_episode         => i_episode,
                                               i_id_pn_note_type => rec.id_pn_note_type,
                                               i_epis_pn         => NULL);
        
            g_error := 'CALL pk_prog_notes_utils.get_note_id. i_episode: ' || i_episode || ' i_id_pn_note_type: ' ||
                       rec.id_pn_note_type;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_utils.get_note_id(i_lang            => i_lang,
                                                   i_prof            => i_prof,
                                                   i_id_episode      => i_episode,
                                                   i_id_pn_note_type => rec.id_pn_note_type,
                                                   o_id_epis_pn      => l_id_note,
                                                   o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF (l_id_note IS NOT NULL)
            THEN
                --delete note from temp episode
                g_error := 'CALL delete_note. i_id_epis_pn: ' || l_id_note;
                pk_alertlog.log_debug(g_error);
                IF NOT delete_note(i_lang => i_lang, i_prof => i_prof, i_id_epis_pn => l_id_note, o_error => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        
        END LOOP;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_MATCH_SINGLE_PAGE',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_match_single_page;

    /**********************************************************************************************
    * SET_MATCH_PROG_NOTES                   This function make "match" of progress notes between episodes
    *
    * @param i_lang                          Language ID
    * @param i_prof                          Profissional array
    * @param i_episode_temp                  Temporary episode
    * @param i_episode                       Episode identifier 
    * @param o_error                         Error object
    *
    * @return                                Success / fail
    *
    * @author                                Sofia Mendes
    * @version                               2.6.0.5
    * @since                                 07-Apr-2011
    **********************************************************************************************/
    FUNCTION set_match_prog_notes
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode_temp IN episode.id_episode%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_rowids table_varchar;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'GET NOTES FROM THE EPISODE.  i_episode_temp: ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        FOR rec IN (SELECT *
                      FROM epis_pn epn
                     WHERE epn.id_episode = i_episode_temp)
        LOOP
            g_error := 'CALL move_epis_pn_2_hist. i_epis_pn' || rec.id_epis_pn;
            pk_alertlog.log_debug(g_error);
            IF NOT
                move_epis_pn_2_hist(i_lang => i_lang, i_prof => i_prof, i_epis_pn => rec.id_epis_pn, o_error => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END LOOP;
    
        g_error := 'CALL ts_epis_pn_hist.UPD WITH ID_EPISODE = ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_pn_hist.upd(id_episode_in   => i_episode,
                            id_episode_nin  => FALSE,
                            where_in        => 'id_episode = ' || i_episode_temp,
                            handle_error_in => FALSE,
                            rows_out        => l_rowids);
    
        g_error := 'PROCESS UPDATE WITH ID_EPISODE ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN_HIST',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('ID_EPISODE'));
    
        --
        g_error := 'CALL ts_epis_pn.UPD WITH ID_EPISODE = ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        l_rowids := table_varchar();
        ts_epis_pn.upd(id_episode_in   => i_episode,
                       id_episode_nin  => FALSE,
                       where_in        => 'id_episode = ' || i_episode_temp,
                       handle_error_in => FALSE,
                       rows_out        => l_rowids);
    
        g_error := 'PROCESS UPDATE WITH ID_EPISODE ' || i_episode_temp;
        pk_alertlog.log_debug(g_error);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN',
                                      i_rowids       => l_rowids,
                                      o_error        => o_error,
                                      i_list_columns => table_varchar('ID_EPISODE'));
        --
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_MATCH_PROG_NOTES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_match_prog_notes;

    /**
    * Review tasks
    *
    * @param   i_lang                Professional preferred language
    * @param   i_prof                Professional identification and its context (institution and software)
    * @param   i_id_episode          Episode ID    
    * @param   i_id_task             tasks ids    
    * @param   i_id_task_type        task type ids
    * @param   i_flg_auto            reviewed automatically (Y/N)
    * @param   i_flg_review          (x): Indicates for each task if it is to be performed the review
    * @param   i_id_patient          Patient identifier
    *
    * @param   o_error               Error information
    *
    * @return  Boolean               True: Sucess, False: Fail
    *
    * @author                        Sofia Mendes
    * @version                       2.6.1.2
    * @since                         19-Ago-2011
    */
    FUNCTION set_review_tasks
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_episode   IN episode.id_episode%TYPE,
        i_id_task      IN table_number,
        i_id_task_type IN table_number,
        i_flg_auto     IN review_detail.flg_auto%TYPE,
        i_flg_review   IN table_varchar,
        i_id_patient   IN patient.id_patient%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_review_contexts table_varchar := table_varchar();
        l_invalid_arguments_exc EXCEPTION;
        l_no_review_context_exc EXCEPTION;
        l_id_task_count   PLS_INTEGER;
        l_review_home_med BOOLEAN := FALSE;
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        --get task contexts
        g_error := 'GET review contexts';
        pk_alertlog.log_debug(g_error);
        SELECT tt.review_context
          BULK COLLECT
          INTO l_review_contexts
          FROM tl_task tt
          JOIN (SELECT column_value id_pn_task_type, rownum rn
                  FROM TABLE(i_id_task_type)) t
            ON t.id_pn_task_type = tt.id_tl_task
         ORDER BY t.rn;
    
        l_id_task_count := i_id_task.count;
    
        FOR i IN 1 .. l_id_task_count
        LOOP
            IF (i_flg_review(i) = pk_prog_notes_constants.g_review_action)
            THEN
                IF NOT (l_review_contexts.exists(i))
                THEN
                    g_error := 'No review context available';
                    RAISE l_no_review_context_exc;
                END IF;
            
                g_error := 'Verify if exits a home medication task to review';
                IF i_id_task_type.exists(i)
                THEN
                    IF i_id_task_type(i) = pk_prog_notes_constants.g_task_reported_medic
                    THEN
                        l_review_home_med := TRUE;
                    END IF;
                END IF;
            
                g_error := 'CALL pk_prog_notes_in.set_review_info. i_id_record_area: ' || i_id_task(i) ||
                           ' i_flg_context: ' || l_review_contexts(i);
                pk_alertlog.log_debug(g_error);
                IF NOT pk_prog_notes_in.set_review_info(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_episode        => i_id_episode,
                                                   i_id_record_area => i_id_task(i),
                                                   i_flg_context    => l_review_contexts(i),
                                                   i_dt_review      => g_sysdate_tstz,
                                                   i_review_notes   => NULL,
                                                   i_flg_auto       => i_flg_auto,
                                                   i_id_task_type   => CASE
                                                                           WHEN i_id_task_type.exists(i) THEN
                                                                            i_id_task_type(i)
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                                   i_id_patient     => i_id_patient,
                                                   o_error          => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            END IF;
        END LOOP;
    
        IF l_review_home_med
        THEN
            g_error := 'CALL pk_prog_notes_in.set_review_home_med i_id_episode:' || i_id_episode || ' i_id_patient: ' ||
                       i_id_patient;
            pk_alertlog.log_debug(g_error);
            IF NOT pk_prog_notes_in.set_review_home_med(i_lang       => i_lang,
                                                        i_prof       => i_prof,
                                                        i_episode    => i_id_episode,
                                                        i_id_patient => i_id_patient,
                                                        o_error      => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_no_review_context_exc THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_REVIEW_TASKS',
                                              o_error    => o_error);
        WHEN l_invalid_arguments_exc THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_REVIEW_TASKS',
                                              o_error    => o_error);
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_REVIEW_TASKS',
                                              o_error    => o_error);
            RETURN FALSE;
    END set_review_tasks;

    /**
    * Returns the suggested records for the episode
    *
    * @param      i_lang                   language identifier
    * @param      i_prof                   logged professional structure
    * @param      i_episode                episode identifier
    * @param      i_id_pn_note_type        Note type identifier
    * @param      i_id_epis_pn             Note identifier
    * @param      o_suggested              Texts that compose the note with the suggested records
    *
    * @param      o_error                  error information
    *
    * @return                              false if errors occur, true otherwise
    *
    * @author                              ANTONIO.NETO
    * @version                             2.6.2
    * @since                               08-Mar-2012
    */
    FUNCTION get_suggest_records
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_pn_note_type IN epis_pn.id_pn_note_type%TYPE,
        i_id_epis_pn      IN epis_pn.id_epis_pn%TYPE,
        o_suggested       OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_id_epis_pn   epis_pn.id_epis_pn%TYPE := i_id_epis_pn;
        l_pn_note_type t_rec_note_type;
        l_flg_editable VARCHAR2(1 CHAR);
    
        l_func_name CONSTANT VARCHAR2(24 CHAR) := 'GET_SUGGEST_RECORDS';
        l_configs_ctx    pk_prog_notes_types.t_configs_ctx;
        l_dt_last_update TIMESTAMP WITH LOCAL TIME ZONE;
    BEGIN
        g_error := 'CALL reset_configs_ctx';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_configs_ctx := reset_configs_ctx(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_episode         => i_id_episode,
                                           i_id_pn_note_type => i_id_pn_note_type,
                                           i_epis_pn         => l_id_epis_pn);
    
        IF (l_id_epis_pn IS NULL AND l_configs_ctx.note_type.flg_synchronized = pk_alert_constant.g_yes)
        THEN
            --autodiscover the note ID
            --The single pages like current visit will only have one note
            --every time the deepnav is accessed it is required to check if there a note already created
            g_error := 'CALL pk_prog_notes_utils.get_note_id. i_id_episode: ' || i_id_episode || ' i_id_pn_note_type: ' ||
                       i_id_pn_note_type;
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_prog_notes_utils.get_note_id(i_lang            => i_lang,
                                                   i_prof            => i_prof,
                                                   i_id_episode      => i_id_episode,
                                                   i_id_pn_note_type => i_id_pn_note_type,
                                                   o_id_epis_pn      => l_id_epis_pn,
                                                   o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
        END IF;
    
        --IF (l_id_epis_pn IS NULL)
        --THEN
        g_error := 'CALL GET_NOTES_CORE_INT';
        pk_alertlog.log_debug(g_error);
        IF NOT get_notes_core_int(i_lang                => i_lang,
                                  i_prof                => i_prof,
                                  i_id_episode          => i_id_episode,
                                  i_id_patient          => pk_episode.get_epis_patient(i_lang    => i_lang,
                                                                                       i_prof    => i_prof,
                                                                                       i_episode => i_id_episode),
                                  i_id_pn_note_type     => i_id_pn_note_type,
                                  i_flg_search_dblock   => pk_prog_notes_constants.g_auto_pop_dblocks_a,
                                  i_id_epis_pn_det_task => NULL,
                                  i_configs_ctx         => l_configs_ctx,
                                  i_id_pn_soap_block    => NULL,
                                  i_only_autopop        => NULL,
                                  io_id_epis_pn         => l_id_epis_pn,
                                  o_dt_last_update      => l_dt_last_update,
                                  o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
        --END IF;
    
        g_error := 'CALL pk_prog_notes_utils.get_flg_editable. i_id_epis_pn: ' || l_id_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_flg_editable := pk_prog_notes_utils.get_flg_editable(i_lang                 => i_lang,
                                                               i_prof                 => i_prof,
                                                               i_id_episode           => i_id_episode,
                                                               i_id_epis_pn           => l_id_epis_pn,
                                                               i_editable_nr_min      => l_pn_note_type.editable_nr_min,
                                                               i_flg_edit_after_disch => l_pn_note_type.flg_edit_after_disch,
                                                               i_flg_synchronized     => l_pn_note_type.flg_synchronized,
                                                               i_id_pn_note_type      => i_id_pn_note_type,
                                                               i_flg_edit_only_last   => l_pn_note_type.flg_edit_only_last,
                                                               i_flg_edit_condition   => l_pn_note_type.flg_edit_condition);
    
        g_error := 'CALL GET_SUGGESTED_RECORDS';
        pk_alertlog.log_debug(g_error);
        IF NOT get_suggested_records(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_id_episode       => i_id_episode,
                                     i_id_epis_pn       => l_id_epis_pn,
                                     i_flg_editable     => l_flg_editable,
                                     i_configs_ctx      => l_configs_ctx,
                                     i_dt_last_update   => l_dt_last_update,
                                     i_id_pn_soap_block => NULL,
                                     o_suggested        => o_suggested,
                                     o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        IF (l_pn_note_type.flg_synchronized = pk_alert_constant.g_yes)
        THEN
            g_error := 'Save all changes to the definitive data model';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT set_save_work_data(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_epis_pn      => l_id_epis_pn,
                                      i_epis_pn_work => l_id_epis_pn,
                                      o_error        => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_suggested);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_suggest_records;

    /**
    * Returns the suggested records for the episode. 
    * To be used in the discharge screen: only suggestes records to the physician professionals
    *
    * @param      i_lang                   language identifier
    * @param      i_prof                   logged professional structure
    * @param      i_episode                episode identifier
    * @param      i_id_pn_note_type        Note type identifier
    * @param      i_id_epis_pn             Note identifier
    * @param      o_suggested              Texts that compose the note with the suggested records
    *
    * @param      o_error                  error information
    *
    * @return                              false if errors occur, true otherwise
    *
    * @author                              Sofia Mendes
    * @version                             2.6.3.1
    * @since                               17-Jan-2012
    */
    FUNCTION get_suggest_records_disch
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_pn_note_type IN epis_pn.id_pn_note_type%TYPE,
        i_id_epis_pn      IN epis_pn.id_epis_pn%TYPE,
        o_suggested       OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(25 CHAR) := 'GET_SUGGEST_RECORDS_DISCH';
    BEGIN
        g_error := 'CALL pk_prog_notes_core.get_suggest_records. i_id_episode: ' || i_id_episode ||
                   ' i_id_pn_note_type: ' || i_id_pn_note_type || ' i_id_epis_pn: ' || i_id_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_prog_notes_core.get_suggest_records(i_lang            => i_lang,
                                                      i_prof            => i_prof,
                                                      i_id_episode      => i_id_episode,
                                                      i_id_pn_note_type => i_id_pn_note_type,
                                                      i_id_epis_pn      => i_id_epis_pn,
                                                      o_suggested       => o_suggested,
                                                      o_error           => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_exception THEN
            pk_types.open_my_cursor(i_cursor => o_suggested);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_types.open_my_cursor(i_cursor => o_suggested);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
        
            RETURN FALSE;
    END get_suggest_records_disch;

    /**
    * Sets the note history in case the note was automatically saved in the last time.
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    * @param   i_epis_pn      Progress note identifier
    * @param   o_error        Error information
    *
    * @return  Boolean
    *
    * @author  Sofia Mendes
    * @version 2.6.2
    * @since   26-Jul-2012
    */
    FUNCTION set_note_history
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_epis_pn IN epis_pn.id_epis_pn%TYPE,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name      VARCHAR2(16 CHAR) := 'SET_NOTE_HISTORY';
        l_flg_auto_saved epis_pn.flg_auto_saved%TYPE;
    BEGIN
        g_error := 'GET FLG_AUTO_SAVED.  i_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT epn.flg_auto_saved
          INTO l_flg_auto_saved
          FROM epis_pn epn
         WHERE epn.id_epis_pn = i_epis_pn;
    
        IF (l_flg_auto_saved = pk_alert_constant.g_yes)
        THEN
            g_error := 'CALL move_epis_pn_2_hist. i_epis_pn' || i_epis_pn;
            pk_alertlog.log_debug(g_error);
            IF NOT move_epis_pn_2_hist(i_lang    => i_lang,
                                       i_prof    => i_prof,
                                       i_epis_pn => i_epis_pn,
                                       i_dt_hist => current_timestamp,
                                       o_error   => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_note_history;

    /**
    * Update all patients notes for viewer_ehr_ea
    *
    * @param   i_lang         Professional preferred language
    * @param   i_prof         Professional identification and its context (institution and software)
    *
    * @author  Vanessa Barsottelli
    * @version 2.6.3
    * @since   28-Feb-2014
    */
    PROCEDURE upd_viewer_ehr_ea
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) IS
        l_func_name VARCHAR2(20 CHAR) := 'UPD_VIEWER_EHR_EA';
    BEGIN
    
        MERGE INTO viewer_ehr_ea a
        USING (SELECT *
                 FROM (SELECT t.*,
                              COUNT(1) over(PARTITION BY t.id_patient) num_note,
                              row_number() over(PARTITION BY t.id_patient ORDER BY t.dt_note DESC NULLS LAST) rn
                         FROM (SELECT epis.id_patient,
                                      NULL desc_note,
                                      (SELECT a.code_pn_area
                                         FROM pn_area a
                                        WHERE a.id_pn_area = epn.id_pn_area) code_note,
                                      pk_prog_notes_utils.get_note_date(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_flg_synchronized => CASE
                                                                                                   WHEN epn.id_pn_area IN
                                                                                                        (pk_prog_notes_constants.g_area_nursing_assessment_5,
                                                                                                         pk_prog_notes_constants.g_area_current_visit_3) THEN
                                                                                                    pk_alert_constant.get_yes
                                                                                                   ELSE
                                                                                                    pk_alert_constant.g_no
                                                                                               END,
                                                                         i_dt_pn_date       => epn.dt_pn_date,
                                                                         i_dt_signoff       => epn.dt_signoff,
                                                                         i_dt_last_update   => epn.dt_last_update,
                                                                         i_dt_create        => epn.dt_create) dt_note
                                 FROM epis_pn epn
                                INNER JOIN episode epis
                                   ON epn.id_episode = epis.id_episode
                                WHERE epn.flg_status IN (pk_prog_notes_constants.g_epis_pn_flg_status_d,
                                                         pk_prog_notes_constants.g_epis_pn_flg_status_s,
                                                         pk_prog_notes_constants.g_epis_pn_flg_status_t,
                                                         pk_prog_notes_constants.g_epis_pn_flg_status_m,
                                                         pk_prog_notes_constants.g_epis_pn_flg_status_f)) t) t_epn
                WHERE t_epn.rn = 1) b
        ON (a.id_patient = b.id_patient)
        WHEN MATCHED THEN
            UPDATE
               SET a.num_note = b.num_note, a.desc_note = b.desc_note, a.code_note = b.code_note, a.dt_note = b.dt_note;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_error(text            => SQLERRM,
                                  object_name     => g_package_name,
                                  sub_object_name => l_func_name,
                                  owner           => g_package_owner);
    END upd_viewer_ehr_ea;

    FUNCTION get_epis_pn_det
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_pn_note_type  IN pn_note_type.id_pn_note_type%TYPE,
        i_id_pn_soap_block IN pn_soap_block.id_pn_soap_block%TYPE,
        i_id_pn_data_block IN pn_data_block.id_pn_data_block%TYPE,
        i_flg_status       IN epis_pn.flg_status%TYPE,
        o_id_epis_pn       OUT epis_pn.id_epis_pn%TYPE,
        o_id_epis_pn_det   OUT epis_pn_det.id_epis_pn_det%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(15 CHAR) := 'GET_EPIS_PN_DET';
    BEGIN
    
        g_error := 'GET ID_EPIS_PN_DET i_id_episode:' || i_id_episode || ', i_id_pn_note_type:' || i_id_pn_note_type ||
                   ', id_pn_soap_block:' || i_id_pn_soap_block || ', id_pn_data_block:' || i_id_pn_data_block ||
                   ', i_flg_status:' || i_flg_status;
        BEGIN
            SELECT ep.id_epis_pn, epd.id_epis_pn_det
              INTO o_id_epis_pn, o_id_epis_pn_det
              FROM epis_pn ep
              JOIN epis_pn_det epd
                ON epd.id_epis_pn = ep.id_epis_pn
             WHERE ep.id_episode = i_id_episode
               AND ep.id_pn_note_type = i_id_pn_note_type
               AND ep.flg_status = i_flg_status
               AND epd.id_pn_soap_block = i_id_pn_soap_block
               AND epd.id_pn_data_block = i_id_pn_data_block
               AND epd.flg_status = pk_prog_notes_constants.g_epis_pn_det_flg_status_a;
        EXCEPTION
            WHEN no_data_found THEN
                o_id_epis_pn     := NULL;
                o_id_epis_pn_det := NULL;
        END;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_epis_pn_det;

    FUNCTION set_pn_group_notes
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE,
        i_notes      IN epis_pn_det.pn_note%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(15 CHAR) := 'SET_GROUP_NOTES';
    
        l_sblock_cdate pn_soap_block.id_pn_soap_block%TYPE := pk_prog_notes_constants.g_sblock_cdate_6;
        l_dblock_cdate pn_data_block.id_pn_data_block%TYPE := pk_prog_notes_constants.g_dblock_cdate_47;
        l_sblock_ftext pn_soap_block.id_pn_soap_block%TYPE := pk_prog_notes_constants.g_sblock_free_text_pn_17;
        l_dblock_ftext pn_data_block.id_pn_data_block%TYPE := pk_prog_notes_constants.g_dblock_free_text_pn_92;
    
        l_note_type_gn pn_note_type.id_pn_note_type%TYPE := pk_prog_notes_constants.g_note_type_id_group_note_31;
    
        l_pn_note              table_clob;
        l_id_epis_pn           epis_pn.id_epis_pn%TYPE;
        l_id_epis_pn_det_cdate epis_pn_det.id_epis_pn_det%TYPE;
        l_id_epis_pn_det_ftext epis_pn_det.id_epis_pn_det%TYPE;
    
        l_date_type   table_varchar;
        l_epis_pn_det table_number;
    
        l_dt_pn_date      table_varchar;
        l_dt_pn_date_str  VARCHAR(14 CHAR);
        l_pn_date_str     VARCHAR(20 CHAR);
        l_flg_action      VARCHAR2(1 CHAR);
        l_flg_definitive  VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_yes;
        l_pn_soap_block   table_number;
        l_pn_data_block   table_number;
        l_flg_add_remove  table_varchar;
        l_flg_app_upd     VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_flg_app_upd;
        l_flg_task_parent VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_no;
    
        l_id_task            table_table_number;
        l_id_task_type       table_table_number;
        l_epis_pn_det_task   table_table_number;
        l_pn_note_task       table_table_clob;
        l_flg_add_rem_task   table_table_varchar;
        l_flg_table_origin   table_table_varchar;
        l_id_task_aggregator table_table_number;
        l_dt_task            table_table_varchar;
        l_id_task_parent     table_table_number;
        l_id_multichoice     table_table_number;
        l_id_group_table     table_table_number;
    
        o_id_epis_pn epis_pn.id_epis_pn%TYPE;
        o_flg_reload VARCHAR2(1 CHAR);
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'GET ID_EPIS_PN AND ID_EPIS_PN_DET FOR CURRENT DATE';
        IF NOT get_epis_pn_det(i_lang             => i_lang,
                               i_prof             => i_prof,
                               i_id_episode       => i_id_episode,
                               i_id_pn_note_type  => l_note_type_gn,
                               i_id_pn_soap_block => l_sblock_cdate,
                               i_id_pn_data_block => l_dblock_cdate,
                               i_flg_status       => pk_prog_notes_constants.g_epis_pn_flg_status_f,
                               o_id_epis_pn       => l_id_epis_pn,
                               o_id_epis_pn_det   => l_id_epis_pn_det_cdate,
                               o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'GET ID_EPIS_PN AND ID_EPIS_PN_DET FOR FREE TEXT';
        IF NOT get_epis_pn_det(i_lang             => i_lang,
                               i_prof             => i_prof,
                               i_id_episode       => i_id_episode,
                               i_id_pn_note_type  => l_note_type_gn,
                               i_id_pn_soap_block => l_sblock_ftext,
                               i_id_pn_data_block => l_dblock_ftext,
                               i_flg_status       => pk_prog_notes_constants.g_epis_pn_flg_status_f,
                               o_id_epis_pn       => l_id_epis_pn,
                               o_id_epis_pn_det   => l_id_epis_pn_det_ftext,
                               o_error            => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        --If l_id_epis_pn is null create a new group note
        --Else update only the text
        IF l_id_epis_pn IS NULL
        THEN
            l_flg_action     := pk_prog_notes_constants.g_flg_action_create;
            l_date_type      := table_varchar(NULL, NULL);
            l_pn_soap_block  := table_number(l_sblock_cdate, l_sblock_ftext);
            l_pn_data_block  := table_number(l_dblock_cdate, l_dblock_ftext);
            l_flg_add_remove := table_varchar(pk_prog_notes_constants.g_flg_add, pk_prog_notes_constants.g_flg_add);
            l_epis_pn_det    := table_number(l_id_epis_pn_det_cdate, l_id_epis_pn_det_ftext);
        
            l_dt_pn_date_str := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
            l_dt_pn_date     := table_varchar(l_dt_pn_date_str, NULL);
        
            l_pn_date_str := pk_date_utils.date_char_hour_tsz(i_lang,
                                                              g_sysdate_tstz,
                                                              i_prof.institution,
                                                              i_prof.software) || ' ' ||
                             pk_date_utils.dt_chr_tsz(i_lang, g_sysdate_tstz, i_prof.institution, i_prof.software);
        
            l_pn_note := table_clob(l_pn_date_str, i_notes);
        
            l_id_task            := table_table_number(table_number(NULL), table_number(NULL));
            l_id_task_type       := table_table_number(table_number(NULL), table_number(NULL));
            l_epis_pn_det_task   := table_table_number(table_number(NULL), table_number(NULL));
            l_pn_note_task       := table_table_clob(table_clob(NULL), table_clob(NULL));
            l_flg_add_rem_task   := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
            l_flg_table_origin   := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
            l_id_task_aggregator := table_table_number(table_number(NULL), table_number(NULL));
            l_dt_task            := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
            l_id_task_parent     := table_table_number(table_number(NULL), table_number(NULL));
            l_id_multichoice     := table_table_number(table_number(NULL), table_number(NULL));
            l_id_group_table     := table_table_number(table_number(NULL), table_number(NULL));
        
        ELSE
            l_flg_action         := pk_prog_notes_constants.g_flg_action_update;
            l_date_type          := table_varchar(NULL);
            l_pn_soap_block      := table_number(l_sblock_ftext);
            l_pn_data_block      := table_number(l_dblock_ftext);
            l_flg_add_remove     := table_varchar(pk_prog_notes_constants.g_flg_add);
            l_epis_pn_det        := table_number(l_id_epis_pn_det_ftext);
            l_dt_pn_date         := table_varchar(NULL);
            l_pn_note            := table_clob(i_notes);
            l_id_task            := table_table_number(table_number(NULL));
            l_id_task_type       := table_table_number(table_number(NULL));
            l_epis_pn_det_task   := table_table_number(table_number(NULL));
            l_pn_note_task       := table_table_clob(table_clob(NULL));
            l_flg_add_rem_task   := table_table_varchar(table_varchar(NULL));
            l_flg_table_origin   := table_table_varchar(table_varchar(NULL));
            l_id_task_aggregator := table_table_number(table_number(NULL));
            l_dt_task            := table_table_varchar(table_varchar(NULL));
            l_id_task_parent     := table_table_number(table_number(NULL));
            l_id_multichoice     := table_table_number(table_number(NULL));
            l_id_group_table     := table_table_number(table_number(NULL));
        END IF;
    
        g_error := 'CALL PK_PROG_NOTES_CORE.SET_ALL_DATA_BLOCK';
        IF NOT pk_prog_notes_core.set_all_data_block(i_lang               => i_lang,
                                                     i_prof               => i_prof,
                                                     i_episode            => i_id_episode,
                                                     i_epis_pn            => l_id_epis_pn,
                                                     i_dt_pn_date         => l_dt_pn_date,
                                                     i_flg_action         => l_flg_action,
                                                     i_date_type          => l_date_type,
                                                     i_pn_soap_block      => l_pn_soap_block,
                                                     i_pn_data_block      => l_pn_data_block,
                                                     i_id_task            => l_id_task,
                                                     i_id_task_type       => l_id_task_type,
                                                     i_dep_clin_serv      => NULL,
                                                     i_epis_pn_det        => l_epis_pn_det,
                                                     i_pn_note            => l_pn_note,
                                                     i_flg_add_remove     => l_flg_add_remove,
                                                     i_id_pn_note_type    => l_note_type_gn,
                                                     i_flg_app_upd        => l_flg_app_upd,
                                                     i_flg_definitive     => l_flg_definitive,
                                                     i_epis_pn_det_task   => l_epis_pn_det_task,
                                                     i_pn_note_task       => l_pn_note_task,
                                                     i_flg_add_rem_task   => l_flg_add_rem_task,
                                                     i_flg_table_origin   => l_flg_table_origin,
                                                     i_id_task_aggregator => l_id_task_aggregator,
                                                     i_dt_task            => l_dt_task,
                                                     i_id_task_parent     => l_id_task_parent,
                                                     i_flg_task_parent    => l_flg_task_parent,
                                                     i_id_multichoice     => l_id_multichoice,
                                                     i_id_group_table     => l_id_group_table,
                                                     o_id_epis_pn         => o_id_epis_pn,
                                                     o_flg_reload         => o_flg_reload,
                                                     o_error              => o_error)
        
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END set_pn_group_notes;

    FUNCTION set_pn_free_text
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        i_dt_pn_date IN table_varchar,
        i_note_type  IN pn_note_type.id_pn_note_type%TYPE,
        i_pn_note    IN table_clob,
        o_id_epis_pn OUT epis_pn.id_epis_pn%TYPE,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(20 CHAR) := 'SET_PN_FREE_TEXT';
    
        l_pn_note              table_clob;
        l_id_epis_pn           epis_pn.id_epis_pn%TYPE;
        l_id_epis_pn_det_cdate epis_pn_det.id_epis_pn_det%TYPE;
        l_id_epis_pn_det_ftext epis_pn_det.id_epis_pn_det%TYPE;
    
        l_date_type   table_varchar;
        l_epis_pn_det table_number;
    
        l_pn_date_str     VARCHAR(20 CHAR);
        l_flg_action      VARCHAR2(1 CHAR);
        l_flg_definitive  VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_yes;
        l_pn_soap_block   table_number;
        l_pn_data_block   table_number;
        l_flg_add_remove  table_varchar;
        l_flg_app_upd     VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_flg_app_upd;
        l_flg_task_parent VARCHAR2(1 CHAR) := pk_prog_notes_constants.g_no;
    
        l_id_task            table_table_number;
        l_id_task_type       table_table_number;
        l_epis_pn_det_task   table_table_number;
        l_pn_note_task       table_table_clob;
        l_flg_add_rem_task   table_table_varchar;
        l_flg_table_origin   table_table_varchar;
        l_id_task_aggregator table_table_number;
        l_dt_task            table_table_varchar;
        l_id_task_parent     table_table_number;
        l_id_multichoice     table_table_number;
        l_id_group_table     table_table_number;
    
        o_flg_reload VARCHAR2(1 CHAR);
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        l_flg_action     := pk_prog_notes_constants.g_flg_action_create;
        l_date_type      := table_varchar(NULL, NULL);
        l_flg_add_remove := table_varchar(pk_prog_notes_constants.g_flg_add, pk_prog_notes_constants.g_flg_add);
        l_epis_pn_det    := table_number(l_id_epis_pn_det_cdate, l_id_epis_pn_det_ftext);
    
        l_id_task            := table_table_number(table_number(NULL), table_number(NULL));
        l_id_task_type       := table_table_number(table_number(NULL), table_number(NULL));
        l_epis_pn_det_task   := table_table_number(table_number(NULL), table_number(NULL));
        l_pn_note_task       := table_table_clob(table_clob(NULL), table_clob(NULL));
        l_flg_add_rem_task   := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
        l_flg_table_origin   := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
        l_id_task_aggregator := table_table_number(table_number(NULL), table_number(NULL));
        l_dt_task            := table_table_varchar(table_varchar(NULL), table_varchar(NULL));
        l_id_task_parent     := table_table_number(table_number(NULL), table_number(NULL));
        l_id_multichoice     := table_table_number(table_number(NULL), table_number(NULL));
        l_id_group_table     := table_table_number(table_number(NULL), table_number(NULL));
    
        --GET SOAP_BLOCKs AND DATA_BLOCKs
        SELECT t.id_pn_soap_block, t.id_pn_data_block /*+opt_estimate(table,t,scale_rows=1)*/
          BULK COLLECT
          INTO l_pn_soap_block, l_pn_data_block
          FROM TABLE(pk_progress_notes_upd.tf_data_blocks(i_prof             => i_prof,
                                                          i_market           => NULL,
                                                          i_department       => NULL,
                                                          i_dcs              => NULL,
                                                          i_id_pn_note_type  => i_note_type,
                                                          i_id_episode       => i_episode,
                                                          i_id_pn_data_block => NULL,
                                                          i_software         => i_prof.software)) t
         ORDER BY t.rank ASC;
    
        g_error := 'CALL PK_PROG_NOTES_CORE.SET_ALL_DATA_BLOCK';
        IF NOT pk_prog_notes_core.set_all_data_block(i_lang               => i_lang,
                                                     i_prof               => i_prof,
                                                     i_episode            => i_episode,
                                                     i_epis_pn            => NULL,
                                                     i_dt_pn_date         => i_dt_pn_date,
                                                     i_flg_action         => l_flg_action,
                                                     i_date_type          => l_date_type,
                                                     i_pn_soap_block      => l_pn_soap_block,
                                                     i_pn_data_block      => l_pn_data_block,
                                                     i_id_task            => l_id_task,
                                                     i_id_task_type       => l_id_task_type,
                                                     i_dep_clin_serv      => NULL,
                                                     i_epis_pn_det        => l_epis_pn_det,
                                                     i_pn_note            => i_pn_note,
                                                     i_flg_add_remove     => l_flg_add_remove,
                                                     i_id_pn_note_type    => i_note_type,
                                                     i_flg_app_upd        => l_flg_app_upd,
                                                     i_flg_definitive     => l_flg_definitive,
                                                     i_epis_pn_det_task   => l_epis_pn_det_task,
                                                     i_pn_note_task       => l_pn_note_task,
                                                     i_flg_add_rem_task   => l_flg_add_rem_task,
                                                     i_flg_table_origin   => l_flg_table_origin,
                                                     i_id_task_aggregator => l_id_task_aggregator,
                                                     i_dt_task            => l_dt_task,
                                                     i_id_task_parent     => l_id_task_parent,
                                                     i_flg_task_parent    => l_flg_task_parent,
                                                     i_id_multichoice     => l_id_multichoice,
                                                     i_id_group_table     => l_id_group_table,
                                                     o_id_epis_pn         => o_id_epis_pn,
                                                     o_flg_reload         => o_flg_reload,
                                                     o_error              => o_error)
        
        THEN
            RAISE g_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => 'SET_PN_FREE_TEXT',
                                              o_error    => o_error);
        
            RETURN FALSE;
    END set_pn_free_text;

    /**
    * Sign off a progress note
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_pn                   Progress note identifier
    * @param   i_flg_edited                Indicate if the SOAP block was edited
    * @param   i_pn_soap_block             Soap Block array with ids
    * @param   i_pn_signoff_note           Notes array
    * @param   i_flg_just_save             Indicate if its just to save or to signoff
    * @param   i_flg_showed_just_save      Indicates if just save screen showed or not
    *
    * @param   o_error                     Error information
    *
    * @return                              Returns TRUE if success, otherwise returns FALSE
    *
    * @value   i_flg_just_save             {*} 'Y'- Yes {*} 'N'- No
    * @value   i_flg_showed_just_save      {*} 'Y'- screen was showed to Professional {*} 'N'- screen didn't showed to Professional
    *
    * @author                              RUI.SPRATLEY
    * @version                             2.6.0.5
    * @since                               02-02-2011
    *
    * @author                              ANTONIO.NETO
    * @version                             2.6.2
    * @since                               19-Apr-2012
    */

    FUNCTION get_note_canc_submit(i_epis_pn IN NUMBER) RETURN NUMBER IS
        l_return NUMBER;
    BEGIN
    
        SELECT COUNT(*)
          INTO l_return
          FROM epis_pn ep
         WHERE ep.id_epis_pn = i_epis_pn
           AND ep.flg_status IN (k_flg_cancel);
    
        RETURN l_return;
    
    END get_note_canc_submit;

    /**
    * submit for review of progress note
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_pn                   Progress note identifier
    *
    * @param   o_error                     Error information
    *
    * @return                              Returns TRUE if success, otherwise returns FALSE
    *
    *
    * @author                              Carlos ferreira
    * @version                             2.7.2
    * @since                               2017-11-17
    */
    FUNCTION set_submit_review
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_prof_review      IN NUMBER,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_flg_status       IN VARCHAR2,
        i_id_submit_reason IN epis_pn.id_submit_reason%TYPE DEFAULT NULL,
        i_notes_submit     IN epis_pn.notes_submit%TYPE DEFAULT NULL,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --If i_epis_pn_signoff has records its an update otherwise tis an insert
        no_texs_found           EXCEPTION;
        no_records_found        EXCEPTION;
        move_2_hist_error       EXCEPTION;
        note_canceled_or_submit EXCEPTION;
    
        l_rows_out table_varchar;
    
        k_func_name CONSTANT VARCHAR2(0050 CHAR) := 'SET_SUBMIT_REVIEW';
        l_error VARCHAR2(4000);
    
        l_counter   PLS_INTEGER;
        tbl_process table_varchar;
    
        -- *********************************************
        FUNCTION process_error
        (
            i_code  IN NUMBER,
            i_errm  IN VARCHAR2,
            i_error IN VARCHAR2
        ) RETURN BOOLEAN IS
        BEGIN
        
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => i_code,
                                              i_sqlerrm  => i_errm,
                                              i_message  => i_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => k_func_name,
                                              o_error    => o_error);
        
            RETURN FALSE;
        
        END process_error;
    
    BEGIN
        l_error := 'Validate if note is already canceled or signed off';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => k_func_name);
    
        g_sysdate_tstz := current_timestamp;
    
        --Validate if note is already canceled (l_counter > 0)
        l_counter := get_note_canc_submit(i_epis_pn => i_epis_pn);
    
        IF l_counter > 0
        THEN
            RAISE note_canceled_or_submit;
        END IF;
    
        --Create history records
        IF NOT move_epis_pn_2_hist(i_lang     => i_lang,
                                   i_prof     => i_prof,
                                   i_epis_pn  => i_epis_pn,
                                   i_flg_type => pk_prog_notes_constants.g_flg_type_md,
                                   o_error    => o_error)
        THEN
            RAISE move_2_hist_error;
        END IF;
    
        l_error := 'update status in epis_pn table to submit_for_review/submit ';
        pk_alertlog.log_debug(text => l_error, object_name => g_package, sub_object_name => k_func_name);
    
        CASE i_flg_status
            WHEN k_flag_review THEN
                ts_epis_pn.upd(id_epis_pn_in       => i_epis_pn,
                               flg_status_in       => i_flg_status,
                               dt_reviewed_in      => g_sysdate_tstz,
                               id_prof_reviewed_in => i_prof_review,
                               rows_out            => l_rows_out);
            
                tbl_process := table_varchar('FLG_STATUS',
                                             'DT_SUBMIT',
                                             'ID_PROF_SUBMIT',
                                             'ID_PROF_REVIEWED',
                                             'DT_REVIEWED');
            WHEN k_flag_submitted THEN
                ts_epis_pn.upd(id_epis_pn_in       => i_epis_pn,
                               flg_status_in       => i_flg_status,
                               dt_submit_in        => g_sysdate_tstz,
                               id_prof_submit_in   => i_prof.id,
                               id_submit_reason_in => i_id_submit_reason,
                               notes_submit_in     => i_notes_submit,
                               rows_out            => l_rows_out);
            
                tbl_process := table_varchar(' FLG_STATUS',
                                             'DT_SUBMIT',
                                             'ID_PROF_SUBMIT',
                                             'ID_PROF_REVIEWED',
                                             'DT_REVIEWED',
                                             'ID_SUBMIT_REASON',
                                             'NOTES_SUBMIT');
            ELSE
                NULL;
        END CASE;
    
        l_error := 'PROCESS UPDATE epis_pn WITH id_epis_pn: ' || i_epis_pn;
        pk_alertlog.log_info(text => l_error, object_name => g_package_name, sub_object_name => k_func_name);
        t_data_gov_mnt.process_update(i_lang         => i_lang,
                                      i_prof         => i_prof,
                                      i_table_name   => 'EPIS_PN',
                                      i_rowids       => l_rows_out,
                                      i_list_columns => tbl_process,
                                      o_error        => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN move_2_hist_error THEN
            l_error := 'move_2_hist_error';
            RETURN process_error(i_code => SQLCODE, i_errm => SQLERRM, i_error => l_error);
        
        WHEN note_canceled_or_submit THEN
            l_error := 'note_canceled_or_signed';
            RETURN process_error(i_code => SQLCODE, i_errm => SQLERRM, i_error => l_error);
        WHEN OTHERS THEN
            RETURN process_error(i_code => SQLCODE, i_errm => SQLERRM, i_error => l_error);
    END set_submit_review;

    /**
    * function to to save a "submit" progress note
    *
    */
    FUNCTION set_submit
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_epis_pn          IN epis_pn.id_epis_pn%TYPE,
        i_id_submit_reason IN epis_pn.id_submit_reason%TYPE DEFAULT NULL,
        i_notes_submit     IN epis_pn.notes_submit%TYPE DEFAULT NULL,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
        l_bool BOOLEAN;
    BEGIN
    
        l_bool := set_submit_review(i_lang             => i_lang,
                                    i_prof             => i_prof,
                                    i_epis_pn          => i_epis_pn,
                                    i_prof_review      => NULL,
                                    i_flg_status       => k_flag_submitted,
                                    i_id_submit_reason => i_id_submit_reason,
                                    i_notes_submit     => i_notes_submit,
                                    o_error            => o_error);
        RETURN l_bool;
    
    END set_submit;

    /**
    * function to save a "for review" progress note
    *
    */
    FUNCTION set_for_review
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_prof_review IN NUMBER,
        i_epis_pn     IN epis_pn.id_epis_pn%TYPE,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_bool BOOLEAN;
    BEGIN
    
        l_bool := set_submit_review(i_lang        => i_lang,
                                    i_prof        => i_prof,
                                    i_epis_pn     => i_epis_pn,
                                    i_prof_review => i_prof_review,
                                    i_flg_status  => k_flag_review,
                                    o_error       => o_error);
        RETURN l_bool;
    
    END set_for_review;

    -- 
    FUNCTION process_flg_submit
    (
        i_prof        IN profissional,
        i_flg_signoff IN VARCHAR2,
        i_flg_submit  IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_return VARCHAR2(0001 CHAR) := i_flg_signoff;
    BEGIN
    
        IF i_flg_submit != k_no
        THEN
        
            l_return := i_flg_submit;
        
        END IF;
    
        RETURN l_return;
    
    END process_flg_submit;

    /*****************************************************************************
    * Get the comments for some note
    * 
    * @param  i_lang        IN   language.id_language%TYPE  Language id
    * @param  i_prof        IN   profissional               Professional structure
    * @param  i_id_epis_pn  IN   epis_pn.id_epis_pn%TYPE    Note id
    * @param  o_pn_comments OUT  pk_types.cursor_type
    * @param  o_error       OUT  t_error_out
    *
    * @return   BOOLEAN   TRUE if succeeds, FALSE otherwise
    *
    * @author   rui.mendonca
    * @version  2.7.2.2
    * @since    14/12/2017
    *****************************************************************************/
    FUNCTION get_pn_comments
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_epis_pn  IN epis_pn.id_epis_pn%TYPE,
        o_pn_comments OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT user_objects.object_name%TYPE := 'GET_PN_COMMENTS';
    BEGIN
    
        OPEN o_pn_comments FOR
            SELECT epa.id_epis_pn_addendum, epa.pn_addendum
              FROM epis_pn_addendum epa
             WHERE epa.id_epis_pn = i_id_epis_pn
               AND epa.flg_type = pk_prog_notes_constants.g_epa_flg_type_comment;
    
        RETURN TRUE;
    
    EXCEPTION
    
        WHEN g_exception THEN
            pk_types.open_cursor_if_closed(i_cursor => o_pn_comments);
            RETURN FALSE;
        
        WHEN OTHERS THEN
            pk_types.open_cursor_if_closed(i_cursor => o_pn_comments);
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END get_pn_comments;

    /**************************************************************************
    * get notes data, use id_note_type to get note data
    * 
    * @param i_lang                   Language ID
    * @param i_prof                   Profissional ID
    *
    * @param o_note_lists             cursor with the information for timeline
    * @param o_error                  Error
    *
    * @author                         Amanda Lee
    * @version                        2.7
    * @since                          2017-11-24                       
    **************************************************************************/
    FUNCTION get_all_note_list
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_pn_area_inter_name IN VARCHAR2,
        i_id_episode         IN episode.id_episode%TYPE,
        i_begin_date         IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date           IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_note_lists         OUT pk_types.cursor_type,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name  VARCHAR2(50 CHAR) := 'GET_ALL_NOTE_LIST';
        l_note_lists t_coll_note_type_condition;
        l_pn_area    table_number;
    BEGIN
        SELECT pa.id_pn_area
          BULK COLLECT
          INTO l_pn_area
          FROM pn_area pa
         WHERE pa.internal_name = i_pn_area_inter_name;
    
        IF NOT pk_prog_notes_cal_condition.get_all_note(i_lang       => i_lang,
                                                        i_prof       => i_prof,
                                                        i_pn_area    => l_pn_area,
                                                        i_id_episode => i_id_episode,
                                                        i_begin_date => i_begin_date,
                                                        i_end_date   => i_end_date,
                                                        o_note_lists => l_note_lists,
                                                        o_error      => o_error)
        THEN
            RETURN FALSE;
        END IF;
    
        OPEN o_note_lists FOR
            SELECT id_pn_note_type, note_type_desc
              FROM TABLE(l_note_lists);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_note_lists);
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_all_note_list;

    /**************************************************************************
    * get notes data, use id_note_type to get note data
    * 
    * @param i_lang                   Language ID
    * @param i_prof                   Profissional ID
    *
    * @param o_note_lists             cursor with the information for timeline
    * @param o_error                  Error
    *
    * @author                         Amanda Lee
    * @version                        2.7
    * @since                          2017-11-24                       
    **************************************************************************/
    FUNCTION get_calendar_view_note
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_area       IN VARCHAR2,
        i_id_episode IN episode.id_episode%TYPE,
        i_begin_date IN TIMESTAMP WITH LOCAL TIME ZONE,
        i_end_date   IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_notes      OUT pk_types.cursor_type,
        o_notes_det  OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name          VARCHAR2(50 CHAR) := 'GET_CALENDAR_VIEW_NOTE';
        l_var_admission_date VARCHAR2(50 CHAR);
        l_admission_date     TIMESTAMP WITH LOCAL TIME ZONE;
        l_adm_date_time      TIMESTAMP WITH LOCAL TIME ZONE;
        l_begin_date         TIMESTAMP WITH LOCAL TIME ZONE;
        l_end_date           TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_all_dates_of_week       table_timestamp;
        l_tbl_pn_note_type        t_coll_note_type_condition;
        l_tbl_expect_note         t_coll_note_type_dt;
        l_tbl_exist_note_det      t_coll_calendar_note_det;
        l_tbl_exist_note_det_temp t_coll_calendar_note_det;
        l_pn_area                 table_number;
    
        l_discharge_adm    discharge.dt_admin_tstz%TYPE;
        l_discharge_med    discharge.dt_med_tstz%TYPE;
        l_discharge_pend   discharge.dt_pend_tstz%TYPE;
        l_flg_disch_status discharge.flg_status%TYPE;
        l_discharge_date   discharge.dt_med_tstz%TYPE;
    BEGIN
        l_begin_date := i_begin_date;
        l_end_date   := i_end_date;
    
        -- Get pn_area id
        IF NOT pk_prog_notes_cal_condition.get_pn_area_list(i_lang          => i_lang,
                                                            i_prof          => i_prof,
                                                            i_internal_name => table_varchar(i_area),
                                                            o_pn_area_lists => l_pn_area,
                                                            o_error         => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        -- Get all date of week, get current week without start date and end date
        g_error := 'Get all note type list';
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF i_begin_date IS NULL
           OR i_end_date IS NULL
        THEN
            IF NOT pk_prog_notes_cal_condition.get_f_e_date_of_week(i_lang  => i_lang,
                                                                    i_prof  => i_prof,
                                                                    i_date  => current_timestamp,
                                                                    o_bdate => l_begin_date,
                                                                    o_edate => l_end_date,
                                                                    o_dates => l_all_dates_of_week,
                                                                    o_error => o_error)
            THEN
                RAISE g_exception;
            END IF;
        ELSE
        
            IF NOT pk_prog_notes_cal_condition.get_dates_of_period(i_lang  => i_lang,
                                                                   i_prof  => i_prof,
                                                                   i_bdate => l_begin_date,
                                                                   i_edate => l_end_date,
                                                                   o_dates => l_all_dates_of_week,
                                                                   o_error => o_error)
            THEN
                RETURN FALSE;
            END IF;
        END IF;
        g_error := 'Get begin_date:' || to_char(l_begin_date) || ', end_date:' || to_char(l_end_date);
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        -- Get all note type list
        g_error := 'Get all note type list';
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_prog_notes_cal_condition.get_all_note(i_lang       => i_lang,
                                                        i_prof       => i_prof,
                                                        i_pn_area    => l_pn_area,
                                                        i_id_episode => i_id_episode,
                                                        i_begin_date => l_begin_date,
                                                        i_end_date   => l_end_date,
                                                        o_note_lists => l_tbl_pn_note_type,
                                                        o_error      => o_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'Get Admision Date';
        IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                 i_prof          => i_prof,
                                                 i_id_episode    => i_id_episode,
                                                 o_dt_begin_tstz => l_admission_date,
                                                 o_error         => o_error)
        THEN
            RETURN TRUE;
        END IF;
        g_error := 'Get Admision Date:' || to_char(l_admission_date);
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        --Get Discharge date
        g_error := 'CALL pk_discharge.get_discharge_dates';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_discharge.get_discharge_dates(i_lang                 => i_lang,
                                                i_prof                 => i_prof,
                                                i_id_episode           => i_id_episode,
                                                o_discharge_adm        => l_discharge_adm,
                                                o_discharge_med        => l_discharge_med,
                                                o_discharge_pend       => l_discharge_pend,
                                                o_flg_discharge_status => l_flg_disch_status,
                                                o_error                => o_error)
        THEN
            RAISE g_exception;
        END IF;
        l_discharge_date := nvl(nvl(l_discharge_pend, l_discharge_med), l_discharge_adm);
        g_error          := 'Get Discharge Date:' || to_char(l_discharge_date);
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        -- Get expect note
        IF NOT pk_prog_notes_cal_condition.get_expect_note(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_id_episode     => i_id_episode,
                                                           i_note_type_list => l_tbl_pn_note_type,
                                                           i_admission_date => l_admission_date,
                                                           i_discharge_date => l_discharge_date,
                                                           i_begin_date     => l_begin_date,
                                                           i_end_date       => l_end_date,
                                                           o_expect_note    => l_tbl_expect_note,
                                                           o_error          => o_error)
        THEN
            RAISE g_exception;
        END IF;
        g_error := 'get_expect_note count:' || l_tbl_expect_note.count;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        -- Get exist note
        IF NOT pk_prog_notes_cal_condition.get_exist_note(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_episode         => i_id_episode,
                                                          i_note_type_list     => l_tbl_pn_note_type,
                                                          i_pn_area_inter_name => i_area,
                                                          i_admission_date     => l_admission_date,
                                                          i_begin_date         => l_begin_date,
                                                          i_end_date           => l_end_date,
                                                          o_exist_note_det     => l_tbl_exist_note_det,
                                                          o_error              => o_error)
        THEN
            RAISE g_exception;
        END IF;
        g_error := 'l_tbl_exist_note_det count:' || l_tbl_exist_note_det.count;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        -- Get all note detail data ex.id_epis_pn...
        IF NOT pk_prog_notes_cal_condition.get_note_det(i_lang              => i_lang,
                                                        i_prof              => i_prof,
                                                        i_note_type_list    => l_tbl_pn_note_type,
                                                        i_exist_note_det    => l_tbl_exist_note_det,
                                                        i_expect_notes      => l_tbl_expect_note,
                                                        o_calendar_note_det => l_tbl_exist_note_det_temp,
                                                        o_note_det          => o_notes_det,
                                                        o_error             => o_error)
        THEN
            RAISE g_exception;
        END IF;
        g_error := 'l_tbl_exist_note_det count:' || l_tbl_exist_note_det.count;
        pk_alertlog.log_info(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
    
        -- Check every date of week status
        IF NOT pk_prog_notes_cal_condition.get_note_status(i_lang                => i_lang,
                                                           i_prof                => i_prof,
                                                           i_calendar_note_det   => l_tbl_exist_note_det_temp,
                                                           i_note_type_condition => l_tbl_pn_note_type,
                                                           i_dates_of_week       => l_all_dates_of_week,
                                                           o_note_lists          => o_notes,
                                                           o_error               => o_error)
        THEN
            RAISE g_exception;
        END IF;
        RETURN TRUE;
    EXCEPTION
        WHEN g_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END get_calendar_view_note;

    /**
    * get task related
    *
    * @param i_lang                   Language ID
    * @param i_id_pn_data_block       Data block identifier
    * @param i_id_pn_soap_block       Soap block identifier
    * @param i_id_pn_note_type        Note type identifier
    * @param i_id_task_type           Task type ID
    *
    * @param o_id_task_related        Task type identifier to be autopopulated with the informatition related
    *
    * @return                 TRUE if succeeds, FALSE otherwise
    *
    * @raises                 PL/SQL generic error "OTHERS"
    *
    * @author               Webber Chiou
    * @version              2.7.4.0
    * @since                2018-09-11
    */
    FUNCTION get_task_related
    (
        i_lang             IN language.id_language%TYPE,
        i_id_pn_data_block IN pn_dblock_ttp_mkt.id_pn_data_block%TYPE,
        i_id_pn_soap_block IN pn_dblock_ttp_mkt.id_pn_soap_block%TYPE,
        i_id_pn_note_type  IN pn_dblock_ttp_mkt.id_pn_note_type%TYPE,
        i_id_task_type     IN table_number,
        o_id_task_related  OUT table_number
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(50 CHAR) := 'GET_TASK_RELATED';
        l_error     t_error_out;
    BEGIN
        SELECT dbtm.id_task_related
          BULK COLLECT
          INTO o_id_task_related
          FROM pn_dblock_ttp_mkt dbtm
         WHERE dbtm.id_pn_data_block = i_id_pn_data_block
           AND dbtm.id_pn_soap_block = i_id_pn_soap_block
           AND dbtm.id_pn_note_type = i_id_pn_note_type
           AND dbtm.id_task_type IN (SELECT /*+opt_estimate(table t rows=1)*/
                                      column_value
                                       FROM TABLE(i_id_task_type) t);
    
        RETURN TRUE;
    EXCEPTION
        WHEN no_data_found THEN
            o_id_task_related := NULL;
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => l_error);
        
            RETURN FALSE;
    END get_task_related;
    /*
    * GET_ID_EPIS_PN
    * get the most recente id_epis_pn BY episode AND note_type
    * create FOR sbar note
    */
    FUNCTION get_id_epis_pn
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_tbl_pn_note_type IN table_varchar,
        o_id_epis_pn       OUT NUMBER,
        o_id_pn_note_type  OUT NUMBER
    ) RETURN BOOLEAN IS
    BEGIN
    
        SELECT id_epis_pn, id_pn_note_type
          INTO o_id_epis_pn, o_id_pn_note_type
          FROM (SELECT id_epis_pn, id_pn_note_type
                  FROM epis_pn e
                 WHERE e.id_episode = i_id_episode
                   AND e.flg_status != pk_alert_constant.g_cancelled
                   AND e.id_prof_create = i_prof.id
                   AND e.id_pn_note_type IN (SELECT /*+ OPT_ESTIMATE(TABLE t ROWS=1) */
                                              column_value
                                               FROM TABLE(i_tbl_pn_note_type) t)
                   AND e.id_epis_pn NOT IN (SELECT nvl(id_epis_pn, 0)
                                              FROM epis_prof_resp epr
                                             WHERE epr.id_episode = i_id_episode
                                               AND epr.id_prof_req = i_prof.id
                                               AND epr.flg_status != pk_alert_constant.g_cancelled)
                   AND e.dt_create =
                       (SELECT MAX(e.dt_create)
                          FROM epis_pn e
                         WHERE e.id_episode = i_id_episode
                           AND e.flg_status != pk_alert_constant.g_cancelled
                           AND e.id_pn_note_type IN (SELECT /*+ OPT_ESTIMATE(TABLE t ROWS=1) */
                                                      column_value
                                                       FROM TABLE(i_tbl_pn_note_type) t)
                           AND e.id_prof_create = i_prof.id)
                 ORDER BY e.dt_create DESC NULLS LAST)
         WHERE rownum = 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            o_id_epis_pn      := NULL;
            o_id_pn_note_type := NULL;
            RETURN TRUE;
    END get_id_epis_pn;
BEGIN
    -- Log initialization.
    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);
    g_debug := pk_alertlog.is_debug_enabled(i_object_name => g_package_name);
END pk_prog_notes_core;
/
