/*-- Last Change Revision: $Rev: 2027985 $*/
/*-- Last Change by: $Author: mario.fernandes $*/
/*-- Date of last change: $Date: 2022-08-02 18:43:52 +0100 (ter, 02 ago 2022) $*/
CREATE OR REPLACE PACKAGE BODY TS_CLINICAL_DATA_REC
/*
| Generated by or retrieved from QCGU - DO NOT MODIFY!
| QCGU - "Get it right, do it fast" - www.ToadWorld.com
| QCGU Universal ID: {7A44F965-7C77-42EE-9A04-269EF006213B}
| Created On: Maio 27, 2014 15:50:53
| Created By: ALERT_CORE_DATA
*/
 IS

  e_null_column_value EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_null_column_value, -1400);
  --
  e_existing_fky_reference EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_existing_fky_reference, -2266);
  --
  e_check_constraint_failure EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_check_constraint_failure, -2290);
  --
  e_no_parent_key EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_no_parent_key, -2291);
  --
  e_child_record_found EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_child_record_found, -2292);
  --
  e_forall_error EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_forall_error, -24381);
  --
  -- Defined for backward compatibilty.
  e_integ_constraint_failure EXCEPTION;
  PRAGMA EXCEPTION_INIT(e_integ_constraint_failure, -2291);

  -- Private utilities
  PROCEDURE get_constraint_info(owner_out OUT ALL_CONSTRAINTS.OWNER%TYPE,
                                name_out  OUT ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE) IS
    l_errm  VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
    dotloc  PLS_INTEGER;
    leftloc PLS_INTEGER;
  BEGIN
    dotloc    := INSTR(l_errm, '.');
    leftloc   := INSTR(l_errm, '(');
    owner_out := SUBSTR(l_errm, leftloc + 1, dotloc - leftloc - 1);
    name_out  := SUBSTR(l_errm, dotloc + 1, INSTR(l_errm, ')') - dotloc - 1);
  END get_constraint_info;
  -- Public programs

  PROCEDURE ins(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                handle_error_in         IN BOOLEAN := TRUE,
                rows_out                OUT TABLE_VARCHAR) IS
  BEGIN
  
    INSERT INTO CLINICAL_DATA_REC
      (ID_CLINICAL_DATA_REC,
       DOC_OID,
       DOC_SOURCE,
       ID_PROFESSIONAL,
       ID_INSTITUTION,
       DT_OPERATION,
       FLG_STATUS,
       CREATE_USER,
       CREATE_TIME,
       CREATE_INSTITUTION,
       UPDATE_USER,
       UPDATE_TIME,
       UPDATE_INSTITUTION,
       CLINICAL_DATA)
    VALUES
      (id_clinical_data_rec_in,
       doc_oid_in,
       doc_source_in,
       id_professional_in,
       id_institution_in,
       dt_operation_in,
       flg_status_in,
       create_user_in,
       create_time_in,
       create_institution_in,
       update_user_in,
       update_time_in,
       update_institution_in,
       clinical_data_in)
    RETURNING ROWID BULK COLLECT INTO rows_out;
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner           ALL_CONSTRAINTS.OWNER%TYPE;
          l_name            ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_err_instance_id PLS_INTEGER;
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF FALSE THEN
            NULL; -- Placeholder in case no unique indexes
          ELSE
            pk_alert_exceptions.raise_error(error_name_in => 'DUPLICATE-VALUE',
                                            name1_in      => 'OWNER',
                                            value1_in     => l_owner,
                                            name2_in      => 'CONSTRAINT_NAME',
                                            value2_in     => l_name,
                                            name3_in      => 'TABLE_NAME',
                                            value3_in     => 'CLINICAL_DATA_REC');
          END IF;
        END;
      END IF;
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          IF l_name = 'CDR_AI_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_INSTITUTION',
                                            value_in           => id_institution_in);
          END IF;
          IF l_name = 'CDR_P_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_PROFESSIONAL',
                                            value_in           => id_professional_in);
          END IF;
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
    WHEN e_null_column_value THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          v_errm    VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
          dot1loc   INTEGER;
          dot2loc   INTEGER;
          parenloc  INTEGER;
          c_owner   ALL_CONSTRAINTS.OWNER%TYPE;
          c_tabname ALL_TABLES.TABLE_NAME%TYPE;
          c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
          dot1loc   := INSTR(v_errm, '.', 1, 1);
          dot2loc   := INSTR(v_errm, '.', 1, 2);
          parenloc  := INSTR(v_errm, '(');
          c_owner   := SUBSTR(v_errm, parenloc + 1, dot1loc - parenloc - 1);
          c_tabname := SUBSTR(v_errm, dot1loc + 1, dot2loc - dot1loc - 1);
          c_colname := SUBSTR(v_errm,
                              dot2loc + 1,
                              INSTR(v_errm, ')') - dot2loc - 1);
        
          pk_alert_exceptions.raise_error(error_name_in => 'COLUMN-CANNOT-BE-NULL',
                                          name1_in      => 'OWNER',
                                          value1_in     => c_owner,
                                          name2_in      => 'TABLE_NAME',
                                          value2_in     => c_tabname,
                                          name3_in      => 'COLUMN_NAME',
                                          value3_in     => c_colname);
        END;
      END IF;
  END ins;

  PROCEDURE ins(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                handle_error_in         IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
  
    ins(id_clinical_data_rec_in => id_clinical_data_rec_in,
        doc_oid_in              => doc_oid_in,
        doc_source_in           => doc_source_in,
        id_professional_in      => id_professional_in,
        id_institution_in       => id_institution_in,
        dt_operation_in         => dt_operation_in,
        flg_status_in           => flg_status_in,
        create_user_in          => create_user_in,
        create_time_in          => create_time_in,
        create_institution_in   => create_institution_in,
        update_user_in          => update_user_in,
        update_time_in          => update_time_in,
        update_institution_in   => update_institution_in,
        clinical_data_in        => clinical_data_in,
        handle_error_in         => handle_error_in,
        rows_out                => rows_out);
  END ins;

  /*
  START Special logic for handling LOB columns....
  */

  PROCEDURE n_ins_clobs_in_chunks(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                                  doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                                  doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                                  id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                                  id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                                  dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                                  flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                                  create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                                  create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                                  create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                                  update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                                  update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                                  update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                                  handle_error_in         IN BOOLEAN := TRUE,
                                  clob_columns_in         IN varchar2_t,
                                  clob_pieces_in          IN varchar2_t) IS
    l_CLINICAL_DATA blob;
    i               PLS_INTEGER;
    current_column  varchar2(30) := '';
  BEGIN
    /* Be aware, PLSQL limitations on temporary clobs prevent multiple CLOB
    variables from pointing to the same temporary CLOB (it creates copies).
    Otherwise, the code could have been written a bit more compactly. */
  
    FOR i IN clob_columns_in.FIRST .. clob_columns_in.LAST LOOP
      /* Even when all clobs are null, DOA must send 1 row so skip it. */
      IF clob_columns_in(i) IS NOT NULL THEN
        IF current_column <> clob_columns_in(i) OR current_column IS NULL THEN
          current_column := LOWER(clob_columns_in(i));
        
          CASE current_column
            WHEN 'clinical_data_in' THEN
              IF l_CLINICAL_DATA IS NULL THEN
                DBMS_LOB.createtemporary(l_CLINICAL_DATA,
                                         TRUE,
                                         DBMS_LOB.CALL);
              END IF;
          END CASE;
        END IF;
      
        CASE current_column
          WHEN 'clinical_data_in' THEN
            DBMS_LOB.writeappend(l_CLINICAL_DATA,
                                 LENGTH(clob_pieces_in(i)),
                                 clob_pieces_in(i));
        END CASE;
      END IF;
    END LOOP;
  
    ins(id_clinical_data_rec_in => id_clinical_data_rec_in,
        doc_oid_in              => doc_oid_in,
        doc_source_in           => doc_source_in,
        id_professional_in      => id_professional_in,
        id_institution_in       => id_institution_in,
        dt_operation_in         => dt_operation_in,
        flg_status_in           => flg_status_in,
        create_user_in          => create_user_in,
        create_time_in          => create_time_in,
        create_institution_in   => create_institution_in,
        update_user_in          => update_user_in,
        update_time_in          => update_time_in,
        update_institution_in   => update_institution_in,
        clinical_data_in        => l_CLINICAL_DATA,
        handle_error_in         => handle_error_in);
  
  END n_ins_clobs_in_chunks;

  PROCEDURE n_upd_clobs_in_chunks(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                                  doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                                  doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                                  id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                                  id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                                  dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                                  flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                                  create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                                  create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                                  create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                                  update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                                  update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                                  update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                                  ignore_if_null_in       IN BOOLEAN := TRUE,
                                  handle_error_in         IN BOOLEAN := TRUE,
                                  clob_columns_in         IN varchar2_t,
                                  clob_pieces_in          IN varchar2_t) IS
    l_CLINICAL_DATA blob;
    i               PLS_INTEGER;
    current_column  varchar2(30) := '';
    l_rows          PLS_INTEGER;
  BEGIN
  
    /* Be aware, PLSQL limitations on temporary clobs prevent multiple CLOB
    variables from pointing to the same temporary CLOB (it creates copies).
    Otherwise, the code could have been written a bit more compactly. */
  
    FOR i IN clob_columns_in.FIRST .. clob_columns_in.LAST LOOP
      /* Even when all clobs are null, DOA must send 1 row so skip it. */
      IF clob_columns_in(i) IS NOT NULL THEN
        IF current_column <> clob_columns_in(i) OR current_column IS NULL THEN
          current_column := LOWER(clob_columns_in(i));
        
          CASE current_column
            WHEN 'clinical_data_in' THEN
              IF l_CLINICAL_DATA IS NULL THEN
                DBMS_LOB.createtemporary(l_CLINICAL_DATA,
                                         TRUE,
                                         DBMS_LOB.CALL);
              END IF;
          END CASE;
        END IF;
      
        CASE current_column
          WHEN 'clinical_data_in' THEN
            DBMS_LOB.writeappend(l_CLINICAL_DATA,
                                 LENGTH(clob_pieces_in(i)),
                                 clob_pieces_in(i));
        END CASE;
      END IF;
    END LOOP;
  
    upd(id_clinical_data_rec_in => id_clinical_data_rec_in,
        doc_oid_in              => doc_oid_in,
        doc_source_in           => doc_source_in,
        id_professional_in      => id_professional_in,
        id_institution_in       => id_institution_in,
        dt_operation_in         => dt_operation_in,
        flg_status_in           => flg_status_in,
        create_user_in          => create_user_in,
        create_time_in          => create_time_in,
        create_institution_in   => create_institution_in,
        update_user_in          => update_user_in,
        update_time_in          => update_time_in,
        update_institution_in   => update_institution_in,
        clinical_data_in        => l_CLINICAL_DATA,
        handle_error_in         => handle_error_in);
  END n_upd_clobs_in_chunks;

  PROCEDURE n_upd_ins_clobs_in_chunks(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                                      doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                                      doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                                      id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                                      id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                                      dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                                      flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                                      create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                                      create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                                      create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                                      update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                                      update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                                      update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                                      ignore_if_null_in       IN BOOLEAN DEFAULT TRUE,
                                      handle_error_in         IN BOOLEAN DEFAULT TRUE,
                                      clob_columns_in         IN varchar2_t,
                                      clob_pieces_in          IN varchar2_t) IS
  BEGIN
    n_upd_clobs_in_chunks(id_clinical_data_rec_in => id_clinical_data_rec_in,
                          doc_oid_in              => doc_oid_in,
                          doc_source_in           => doc_source_in,
                          id_professional_in      => id_professional_in,
                          id_institution_in       => id_institution_in,
                          dt_operation_in         => dt_operation_in,
                          flg_status_in           => flg_status_in,
                          create_user_in          => create_user_in,
                          create_time_in          => create_time_in,
                          create_institution_in   => create_institution_in,
                          update_user_in          => update_user_in,
                          update_time_in          => update_time_in,
                          update_institution_in   => update_institution_in,
                          clob_columns_in         => clob_columns_in,
                          clob_pieces_in          => clob_pieces_in,
                          ignore_if_null_in       => ignore_if_null_in,
                          handle_error_in         => handle_error_in);
  
    IF SQL%ROWCOUNT = 0 THEN
      n_ins_clobs_in_chunks(id_clinical_data_rec_in => id_clinical_data_rec_in,
                            doc_oid_in              => doc_oid_in,
                            doc_source_in           => doc_source_in,
                            id_professional_in      => id_professional_in,
                            id_institution_in       => id_institution_in,
                            dt_operation_in         => dt_operation_in,
                            flg_status_in           => flg_status_in,
                            create_user_in          => create_user_in,
                            create_time_in          => create_time_in,
                            create_institution_in   => create_institution_in,
                            update_user_in          => update_user_in,
                            update_time_in          => update_time_in,
                            update_institution_in   => update_institution_in,
                            clob_columns_in         => clob_columns_in,
                            clob_pieces_in          => clob_pieces_in,
                            handle_error_in         => handle_error_in);
    END IF;
  END n_upd_ins_clobs_in_chunks;

  /*
  END Special logic for handling LOB columns.
  */

  PROCEDURE ins(rec_in          IN CLINICAL_DATA_REC%ROWTYPE,
                sequence_in     IN VARCHAR2 := NULL,
                handle_error_in IN BOOLEAN := TRUE,
                rows_out        OUT TABLE_VARCHAR) IS
    l_rec CLINICAL_DATA_REC%ROWTYPE := rec_in;
  BEGIN
    ins(id_clinical_data_rec_in => l_rec.ID_CLINICAL_DATA_REC,
        doc_oid_in              => l_rec.DOC_OID,
        doc_source_in           => l_rec.DOC_SOURCE,
        id_professional_in      => l_rec.ID_PROFESSIONAL,
        id_institution_in       => l_rec.ID_INSTITUTION,
        dt_operation_in         => l_rec.DT_OPERATION,
        flg_status_in           => l_rec.FLG_STATUS,
        create_user_in          => l_rec.CREATE_USER,
        create_time_in          => l_rec.CREATE_TIME,
        create_institution_in   => l_rec.CREATE_INSTITUTION,
        update_user_in          => l_rec.UPDATE_USER,
        update_time_in          => l_rec.UPDATE_TIME,
        update_institution_in   => l_rec.UPDATE_INSTITUTION,
        clinical_data_in        => l_rec.CLINICAL_DATA,
        handle_error_in         => handle_error_in,
        rows_out                => rows_out);
  END ins;

  PROCEDURE ins(rec_in          IN CLINICAL_DATA_REC%ROWTYPE,
                sequence_in     IN VARCHAR2 := NULL,
                handle_error_in IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
  
    ins(rec_in          => rec_in,
        sequence_in     => sequence_in,
        handle_error_in => handle_error_in,
        rows_out        => rows_out);
  
  END ins;

  PROCEDURE ins(rows_in         IN CLINICAL_DATA_REC_tc,
                handle_error_in IN BOOLEAN := TRUE,
                rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    IF rows_in.COUNT = 0 THEN
      NULL;
    ELSE
      FORALL indx IN rows_in.FIRST .. rows_in.LAST SAVE EXCEPTIONS
        INSERT INTO CLINICAL_DATA_REC
          (ID_CLINICAL_DATA_REC,
           DOC_OID,
           DOC_SOURCE,
           ID_PROFESSIONAL,
           ID_INSTITUTION,
           DT_OPERATION,
           FLG_STATUS,
           CREATE_USER,
           CREATE_TIME,
           CREATE_INSTITUTION,
           UPDATE_USER,
           UPDATE_TIME,
           UPDATE_INSTITUTION,
           CLINICAL_DATA)
        VALUES
          (rows_in(indx).ID_CLINICAL_DATA_REC,
           rows_in(indx).DOC_OID,
           rows_in(indx).DOC_SOURCE,
           rows_in(indx).ID_PROFESSIONAL,
           rows_in(indx).ID_INSTITUTION,
           rows_in(indx).DT_OPERATION,
           rows_in(indx).FLG_STATUS,
           rows_in(indx).CREATE_USER,
           rows_in(indx).CREATE_TIME,
           rows_in(indx).CREATE_INSTITUTION,
           rows_in(indx).UPDATE_USER,
           rows_in(indx).UPDATE_TIME,
           rows_in(indx).UPDATE_INSTITUTION,
           rows_in(indx).CLINICAL_DATA)
        RETURNING ROWID BULK COLLECT INTO rows_out;
    
    END IF;
  EXCEPTION
    WHEN e_forall_error THEN
      -- In Oracle9i and above, SAVE EXCEPTIONS will direct control
      -- here if any error occurs. We can then save all the error
      -- information out to the error instance.
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        <<bulk_handler>>
        DECLARE
          l_err_instance_id NUMBER;
        BEGIN
          -- For each error, write to the log.
          FOR indx IN 1 .. SQL%BULK_EXCEPTIONS.COUNT LOOP
            pk_alert_exceptions.register_error(error_name_in       => 'FORALL-INSERT-FAILURE',
                                               err_instance_id_out => l_err_instance_id);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'BINDING_ROW_' || indx,
                                            value_in           => SQL%BULK_EXCEPTIONS(indx)
                                                                  .ERROR_INDEX,
                                            validate_in        => FALSE);
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'ERROR_AT_ROW_' || indx,
                                            value_in           => SQLERRM(-SQL%BULK_EXCEPTIONS(indx)
                                                                          .ERROR_CODE),
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'ID_CLINICAL_DATA_REC _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .ID_CLINICAL_DATA_REC,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'DOC_OID _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .DOC_OID,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'DOC_SOURCE _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .DOC_SOURCE,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'ID_PROFESSIONAL _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .ID_PROFESSIONAL,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'ID_INSTITUTION _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .ID_INSTITUTION,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'DT_OPERATION _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .DT_OPERATION,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'FLG_STATUS _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .FLG_STATUS,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'CREATE_USER _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .CREATE_USER,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'CREATE_TIME _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .CREATE_TIME,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'CREATE_INSTITUTION _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .CREATE_INSTITUTION,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'UPDATE_USER _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .UPDATE_USER,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'UPDATE_TIME _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .UPDATE_TIME,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.add_context(err_instance_id_in => l_err_instance_id,
                                            NAME_IN            => 'UPDATE_INSTITUTION _' || indx,
                                            value_in           => rows_in(SQL%BULK_EXCEPTIONS(indx).ERROR_INDEX)
                                                                  .UPDATE_INSTITUTION,
                                            validate_in        => FALSE);
          
            pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_err_instance_id);
          END LOOP;
        END bulk_handler;
      END IF;
    WHEN OTHERS THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        pk_alert_exceptions.raise_error(error_name_in => 'FORALL-INSERT-FAILURE',
                                        name1_in      => 'TABLE_NAME',
                                        value1_in     => 'CLINICAL_DATA_REC',
                                        name2_in      => 'ROW_COUNT',
                                        value2_in     => rows_in.COUNT);
      END IF;
  END ins;

  PROCEDURE ins(rows_in         IN CLINICAL_DATA_REC_tc,
                handle_error_in IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    ins(rows_in         => rows_in,
        handle_error_in => handle_error_in,
        rows_out        => rows_out);
  END ins;

  PROCEDURE upd(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                DOC_OID_nin             IN BOOLEAN := TRUE,
                doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                DOC_SOURCE_nin          IN BOOLEAN := TRUE,
                id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                ID_PROFESSIONAL_nin     IN BOOLEAN := TRUE,
                id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                ID_INSTITUTION_nin      IN BOOLEAN := TRUE,
                dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                DT_OPERATION_nin        IN BOOLEAN := TRUE,
                flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                FLG_STATUS_nin          IN BOOLEAN := TRUE,
                create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                CREATE_USER_nin         IN BOOLEAN := TRUE,
                create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                CREATE_TIME_nin         IN BOOLEAN := TRUE,
                create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                CREATE_INSTITUTION_nin  IN BOOLEAN := TRUE,
                update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                UPDATE_USER_nin         IN BOOLEAN := TRUE,
                update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                UPDATE_TIME_nin         IN BOOLEAN := TRUE,
                update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                UPDATE_INSTITUTION_nin  IN BOOLEAN := TRUE,
                clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                CLINICAL_DATA_nin       IN BOOLEAN := TRUE,
                handle_error_in         IN BOOLEAN := TRUE,
                rows_out                IN OUT TABLE_VARCHAR) IS
    l_rows_out             TABLE_VARCHAR;
    l_DOC_OID_n            NUMBER(1);
    l_DOC_SOURCE_n         NUMBER(1);
    l_ID_PROFESSIONAL_n    NUMBER(1);
    l_ID_INSTITUTION_n     NUMBER(1);
    l_DT_OPERATION_n       NUMBER(1);
    l_FLG_STATUS_n         NUMBER(1);
    l_CREATE_USER_n        NUMBER(1);
    l_CREATE_TIME_n        NUMBER(1);
    l_CREATE_INSTITUTION_n NUMBER(1);
    l_UPDATE_USER_n        NUMBER(1);
    l_UPDATE_TIME_n        NUMBER(1);
    l_UPDATE_INSTITUTION_n NUMBER(1);
    l_CLINICAL_DATA_n      NUMBER(1);
  BEGIN
  
    l_DOC_OID_n            := sys.diutil.bool_to_int(DOC_OID_nin);
    l_DOC_SOURCE_n         := sys.diutil.bool_to_int(DOC_SOURCE_nin);
    l_ID_PROFESSIONAL_n    := sys.diutil.bool_to_int(ID_PROFESSIONAL_nin);
    l_ID_INSTITUTION_n     := sys.diutil.bool_to_int(ID_INSTITUTION_nin);
    l_DT_OPERATION_n       := sys.diutil.bool_to_int(DT_OPERATION_nin);
    l_FLG_STATUS_n         := sys.diutil.bool_to_int(FLG_STATUS_nin);
    l_CREATE_USER_n        := sys.diutil.bool_to_int(CREATE_USER_nin);
    l_CREATE_TIME_n        := sys.diutil.bool_to_int(CREATE_TIME_nin);
    l_CREATE_INSTITUTION_n := sys.diutil.bool_to_int(CREATE_INSTITUTION_nin);
    l_UPDATE_USER_n        := sys.diutil.bool_to_int(UPDATE_USER_nin);
    l_UPDATE_TIME_n        := sys.diutil.bool_to_int(UPDATE_TIME_nin);
    l_UPDATE_INSTITUTION_n := sys.diutil.bool_to_int(UPDATE_INSTITUTION_nin);
    l_CLINICAL_DATA_n      := sys.diutil.bool_to_int(CLINICAL_DATA_nin);
  
    UPDATE CLINICAL_DATA_REC
       SET DOC_OID            = decode(l_DOC_OID_n,
                                       0,
                                       doc_oid_in,
                                       NVL(doc_oid_in, DOC_OID)),
           DOC_SOURCE         = decode(l_DOC_SOURCE_n,
                                       0,
                                       doc_source_in,
                                       NVL(doc_source_in, DOC_SOURCE)),
           ID_PROFESSIONAL    = decode(l_ID_PROFESSIONAL_n,
                                       0,
                                       id_professional_in,
                                       NVL(id_professional_in,
                                           ID_PROFESSIONAL)),
           ID_INSTITUTION     = decode(l_ID_INSTITUTION_n,
                                       0,
                                       id_institution_in,
                                       NVL(id_institution_in, ID_INSTITUTION)),
           DT_OPERATION       = decode(l_DT_OPERATION_n,
                                       0,
                                       dt_operation_in,
                                       NVL(dt_operation_in, DT_OPERATION)),
           FLG_STATUS         = decode(l_FLG_STATUS_n,
                                       0,
                                       flg_status_in,
                                       NVL(flg_status_in, FLG_STATUS)),
           CREATE_USER        = decode(l_CREATE_USER_n,
                                       0,
                                       create_user_in,
                                       NVL(create_user_in, CREATE_USER)),
           CREATE_TIME        = decode(l_CREATE_TIME_n,
                                       0,
                                       create_time_in,
                                       NVL(create_time_in, CREATE_TIME)),
           CREATE_INSTITUTION = decode(l_CREATE_INSTITUTION_n,
                                       0,
                                       create_institution_in,
                                       NVL(create_institution_in,
                                           CREATE_INSTITUTION)),
           UPDATE_USER        = decode(l_UPDATE_USER_n,
                                       0,
                                       update_user_in,
                                       NVL(update_user_in, UPDATE_USER)),
           UPDATE_TIME        = decode(l_UPDATE_TIME_n,
                                       0,
                                       update_time_in,
                                       NVL(update_time_in, UPDATE_TIME)),
           UPDATE_INSTITUTION = decode(l_UPDATE_INSTITUTION_n,
                                       0,
                                       update_institution_in,
                                       NVL(update_institution_in,
                                           UPDATE_INSTITUTION)),
           CLINICAL_DATA      = decode(l_CLINICAL_DATA_n,
                                       0,
                                       clinical_data_in,
                                       NVL(clinical_data_in, CLINICAL_DATA))
     WHERE ID_CLINICAL_DATA_REC = id_clinical_data_rec_in
    RETURNING ROWID BULK COLLECT INTO l_rows_out;
  
    if (rows_out is null) then
      rows_out := table_varchar();
    end if;
  
    rows_out := rows_out MULTISET UNION DISTINCT l_rows_out;
  
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner           ALL_CONSTRAINTS.OWNER%TYPE;
          l_name            ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_err_instance_id PLS_INTEGER;
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF FALSE THEN
            NULL; -- Placeholder in case no unique indexes
          ELSE
            pk_alert_exceptions.raise_error(error_name_in => 'DUPLICATE-VALUE',
                                            name1_in      => 'OWNER',
                                            value1_in     => l_owner,
                                            name2_in      => 'CONSTRAINT_NAME',
                                            value2_in     => l_name,
                                            name3_in      => 'TABLE_NAME',
                                            value3_in     => 'CLINICAL_DATA_REC');
          END IF;
        END;
      END IF;
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          IF l_name = 'CDR_AI_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_INSTITUTION',
                                            value_in           => id_institution_in);
          END IF;
          IF l_name = 'CDR_P_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_PROFESSIONAL',
                                            value_in           => id_professional_in);
          END IF;
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
    WHEN e_null_column_value THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          v_errm    VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
          dot1loc   INTEGER;
          dot2loc   INTEGER;
          parenloc  INTEGER;
          c_owner   ALL_CONSTRAINTS.OWNER%TYPE;
          c_tabname ALL_TABLES.TABLE_NAME%TYPE;
          c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
          dot1loc   := INSTR(v_errm, '.', 1, 1);
          dot2loc   := INSTR(v_errm, '.', 1, 2);
          parenloc  := INSTR(v_errm, '(');
          c_owner   := SUBSTR(v_errm, parenloc + 1, dot1loc - parenloc - 1);
          c_tabname := SUBSTR(v_errm, dot1loc + 1, dot2loc - dot1loc - 1);
          c_colname := SUBSTR(v_errm,
                              dot2loc + 1,
                              INSTR(v_errm, ')') - dot2loc - 1);
        
          pk_alert_exceptions.raise_error(error_name_in => 'COLUMN-CANNOT-BE-NULL',
                                          name1_in      => 'OWNER',
                                          value1_in     => c_owner,
                                          name2_in      => 'TABLE_NAME',
                                          value2_in     => c_tabname,
                                          name3_in      => 'COLUMN_NAME',
                                          value3_in     => c_colname);
        END;
      END IF;
  END upd;

  PROCEDURE upd(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                DOC_OID_nin             IN BOOLEAN := TRUE,
                doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                DOC_SOURCE_nin          IN BOOLEAN := TRUE,
                id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                ID_PROFESSIONAL_nin     IN BOOLEAN := TRUE,
                id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                ID_INSTITUTION_nin      IN BOOLEAN := TRUE,
                dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                DT_OPERATION_nin        IN BOOLEAN := TRUE,
                flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                FLG_STATUS_nin          IN BOOLEAN := TRUE,
                create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                CREATE_USER_nin         IN BOOLEAN := TRUE,
                create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                CREATE_TIME_nin         IN BOOLEAN := TRUE,
                create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                CREATE_INSTITUTION_nin  IN BOOLEAN := TRUE,
                update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                UPDATE_USER_nin         IN BOOLEAN := TRUE,
                update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                UPDATE_TIME_nin         IN BOOLEAN := TRUE,
                update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                UPDATE_INSTITUTION_nin  IN BOOLEAN := TRUE,
                clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                CLINICAL_DATA_nin       IN BOOLEAN := TRUE,
                handle_error_in         IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    upd(id_clinical_data_rec_in => id_clinical_data_rec_in,
        doc_oid_in              => doc_oid_in,
        DOC_OID_nin             => DOC_OID_nin,
        doc_source_in           => doc_source_in,
        DOC_SOURCE_nin          => DOC_SOURCE_nin,
        id_professional_in      => id_professional_in,
        ID_PROFESSIONAL_nin     => ID_PROFESSIONAL_nin,
        id_institution_in       => id_institution_in,
        ID_INSTITUTION_nin      => ID_INSTITUTION_nin,
        dt_operation_in         => dt_operation_in,
        DT_OPERATION_nin        => DT_OPERATION_nin,
        flg_status_in           => flg_status_in,
        FLG_STATUS_nin          => FLG_STATUS_nin,
        create_user_in          => create_user_in,
        CREATE_USER_nin         => CREATE_USER_nin,
        create_time_in          => create_time_in,
        CREATE_TIME_nin         => CREATE_TIME_nin,
        create_institution_in   => create_institution_in,
        CREATE_INSTITUTION_nin  => CREATE_INSTITUTION_nin,
        update_user_in          => update_user_in,
        UPDATE_USER_nin         => UPDATE_USER_nin,
        update_time_in          => update_time_in,
        UPDATE_TIME_nin         => UPDATE_TIME_nin,
        update_institution_in   => update_institution_in,
        UPDATE_INSTITUTION_nin  => UPDATE_INSTITUTION_nin,
        clinical_data_in        => clinical_data_in,
        CLINICAL_DATA_nin       => CLINICAL_DATA_nin,
        handle_error_in         => handle_error_in,
        rows_out                => rows_out);
  END upd;

  PROCEDURE upd(doc_oid_in             IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                DOC_OID_nin            IN BOOLEAN := TRUE,
                doc_source_in          IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                DOC_SOURCE_nin         IN BOOLEAN := TRUE,
                id_professional_in     IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                ID_PROFESSIONAL_nin    IN BOOLEAN := TRUE,
                id_institution_in      IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                ID_INSTITUTION_nin     IN BOOLEAN := TRUE,
                dt_operation_in        IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                DT_OPERATION_nin       IN BOOLEAN := TRUE,
                flg_status_in          IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                FLG_STATUS_nin         IN BOOLEAN := TRUE,
                create_user_in         IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                CREATE_USER_nin        IN BOOLEAN := TRUE,
                create_time_in         IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                CREATE_TIME_nin        IN BOOLEAN := TRUE,
                create_institution_in  IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                CREATE_INSTITUTION_nin IN BOOLEAN := TRUE,
                update_user_in         IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                UPDATE_USER_nin        IN BOOLEAN := TRUE,
                update_time_in         IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                UPDATE_TIME_nin        IN BOOLEAN := TRUE,
                update_institution_in  IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                UPDATE_INSTITUTION_nin IN BOOLEAN := TRUE,
                clinical_data_in       IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                CLINICAL_DATA_nin      IN BOOLEAN := TRUE,
                where_in               varchar2,
                handle_error_in        IN BOOLEAN := TRUE,
                rows_out               IN OUT TABLE_VARCHAR) IS
    l_sql                   VARCHAR2(32767);
    l_rows_out              TABLE_VARCHAR;
    l_DOC_OID_n             NUMBER(1);
    l_DOC_SOURCE_n          NUMBER(1);
    l_ID_PROFESSIONAL_n     NUMBER(1);
    l_ID_INSTITUTION_n      NUMBER(1);
    l_DT_OPERATION_n        NUMBER(1);
    l_FLG_STATUS_n          NUMBER(1);
    l_CREATE_USER_n         NUMBER(1);
    l_CREATE_TIME_n         NUMBER(1);
    l_CREATE_INSTITUTION_n  NUMBER(1);
    l_UPDATE_USER_n         NUMBER(1);
    l_UPDATE_TIME_n         NUMBER(1);
    l_UPDATE_INSTITUTION_n  NUMBER(1);
    l_CLINICAL_DATA_n       NUMBER(1);
    id_clinical_data_rec_in CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE;
  BEGIN
  
    l_DOC_OID_n            := sys.diutil.bool_to_int(DOC_OID_nin);
    l_DOC_SOURCE_n         := sys.diutil.bool_to_int(DOC_SOURCE_nin);
    l_ID_PROFESSIONAL_n    := sys.diutil.bool_to_int(ID_PROFESSIONAL_nin);
    l_ID_INSTITUTION_n     := sys.diutil.bool_to_int(ID_INSTITUTION_nin);
    l_DT_OPERATION_n       := sys.diutil.bool_to_int(DT_OPERATION_nin);
    l_FLG_STATUS_n         := sys.diutil.bool_to_int(FLG_STATUS_nin);
    l_CREATE_USER_n        := sys.diutil.bool_to_int(CREATE_USER_nin);
    l_CREATE_TIME_n        := sys.diutil.bool_to_int(CREATE_TIME_nin);
    l_CREATE_INSTITUTION_n := sys.diutil.bool_to_int(CREATE_INSTITUTION_nin);
    l_UPDATE_USER_n        := sys.diutil.bool_to_int(UPDATE_USER_nin);
    l_UPDATE_TIME_n        := sys.diutil.bool_to_int(UPDATE_TIME_nin);
    l_UPDATE_INSTITUTION_n := sys.diutil.bool_to_int(UPDATE_INSTITUTION_nin);
    l_CLINICAL_DATA_n      := sys.diutil.bool_to_int(CLINICAL_DATA_nin);
  
    l_sql := 'UPDATE CLINICAL_DATA_REC SET ' || ' DOC_OID = decode (' ||
             l_DOC_OID_n || ',0,:doc_oid_in, NVL (:doc_oid_in, DOC_OID)) ' || ',' ||
             ' DOC_SOURCE = decode (' || l_DOC_SOURCE_n ||
             ',0,:doc_source_in, NVL (:doc_source_in, DOC_SOURCE)) ' || ',' ||
             ' ID_PROFESSIONAL = decode (' || l_ID_PROFESSIONAL_n ||
             ',0,:id_professional_in, NVL (:id_professional_in, ID_PROFESSIONAL)) ' || ',' ||
             ' ID_INSTITUTION = decode (' || l_ID_INSTITUTION_n ||
             ',0,:id_institution_in, NVL (:id_institution_in, ID_INSTITUTION)) ' || ',' ||
             ' DT_OPERATION = decode (' || l_DT_OPERATION_n ||
             ',0,:dt_operation_in, NVL (:dt_operation_in, DT_OPERATION)) ' || ',' ||
             ' FLG_STATUS = decode (' || l_FLG_STATUS_n ||
             ',0,:flg_status_in, NVL (:flg_status_in, FLG_STATUS)) ' || ',' ||
             ' CREATE_USER = decode (' || l_CREATE_USER_n ||
             ',0,:create_user_in, NVL (:create_user_in, CREATE_USER)) ' || ',' ||
             ' CREATE_TIME = decode (' || l_CREATE_TIME_n ||
             ',0,:create_time_in, NVL (:create_time_in, CREATE_TIME)) ' || ',' ||
             ' CREATE_INSTITUTION = decode (' || l_CREATE_INSTITUTION_n ||
             ',0,:create_institution_in, NVL (:create_institution_in, CREATE_INSTITUTION)) ' || ',' ||
             ' UPDATE_USER = decode (' || l_UPDATE_USER_n ||
             ',0,:update_user_in, NVL (:update_user_in, UPDATE_USER)) ' || ',' ||
             ' UPDATE_TIME = decode (' || l_UPDATE_TIME_n ||
             ',0,:update_time_in, NVL (:update_time_in, UPDATE_TIME)) ' || ',' ||
             ' UPDATE_INSTITUTION = decode (' || l_UPDATE_INSTITUTION_n ||
             ',0,:update_institution_in, NVL (:update_institution_in, UPDATE_INSTITUTION)) ' || ',' ||
             ' CLINICAL_DATA = decode (' || l_CLINICAL_DATA_n ||
             ',0,:clinical_data_in, NVL (:clinical_data_in, CLINICAL_DATA)) ' ||
             ' where ' || nvl(where_in, '(1=1)') ||
             ' RETURNING ROWID BULK COLLECT INTO :l_rows_out';
  
    execute immediate 'BEGIN ' || l_sql || '; END;'
      using in doc_oid_in, doc_source_in, id_professional_in, id_institution_in, dt_operation_in, flg_status_in, create_user_in, create_time_in, create_institution_in, update_user_in, update_time_in, update_institution_in, clinical_data_in, OUT l_rows_out;
  
    if (rows_out is null) then
      rows_out := table_varchar();
    end if;
  
    rows_out := rows_out MULTISET UNION DISTINCT l_rows_out;
  
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner           ALL_CONSTRAINTS.OWNER%TYPE;
          l_name            ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_err_instance_id PLS_INTEGER;
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF FALSE THEN
            NULL; -- Placeholder in case no unique indexes
          ELSE
            pk_alert_exceptions.raise_error(error_name_in => 'DUPLICATE-VALUE',
                                            name1_in      => 'OWNER',
                                            value1_in     => l_owner,
                                            name2_in      => 'CONSTRAINT_NAME',
                                            value2_in     => l_name,
                                            name3_in      => 'TABLE_NAME',
                                            value3_in     => 'CLINICAL_DATA_REC');
          END IF;
        END;
      END IF;
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          IF l_name = 'CDR_AI_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_INSTITUTION',
                                            value_in           => id_institution_in);
          END IF;
          IF l_name = 'CDR_P_FK' THEN
            -- Add a context value for each column
            pk_alert_exceptions.add_context(err_instance_id_in => l_id,
                                            name_in            => 'ID_PROFESSIONAL',
                                            value_in           => id_professional_in);
          END IF;
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
    WHEN e_null_column_value THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          v_errm    VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
          dot1loc   INTEGER;
          dot2loc   INTEGER;
          parenloc  INTEGER;
          c_owner   ALL_CONSTRAINTS.OWNER%TYPE;
          c_tabname ALL_TABLES.TABLE_NAME%TYPE;
          c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
          dot1loc   := INSTR(v_errm, '.', 1, 1);
          dot2loc   := INSTR(v_errm, '.', 1, 2);
          parenloc  := INSTR(v_errm, '(');
          c_owner   := SUBSTR(v_errm, parenloc + 1, dot1loc - parenloc - 1);
          c_tabname := SUBSTR(v_errm, dot1loc + 1, dot2loc - dot1loc - 1);
          c_colname := SUBSTR(v_errm,
                              dot2loc + 1,
                              INSTR(v_errm, ')') - dot2loc - 1);
        
          pk_alert_exceptions.raise_error(error_name_in => 'COLUMN-CANNOT-BE-NULL',
                                          name1_in      => 'OWNER',
                                          value1_in     => c_owner,
                                          name2_in      => 'TABLE_NAME',
                                          value2_in     => c_tabname,
                                          name3_in      => 'COLUMN_NAME',
                                          value3_in     => c_colname);
        END;
      END IF;
  END upd;

  PROCEDURE upd(doc_oid_in             IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                DOC_OID_nin            IN BOOLEAN := TRUE,
                doc_source_in          IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                DOC_SOURCE_nin         IN BOOLEAN := TRUE,
                id_professional_in     IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                ID_PROFESSIONAL_nin    IN BOOLEAN := TRUE,
                id_institution_in      IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                ID_INSTITUTION_nin     IN BOOLEAN := TRUE,
                dt_operation_in        IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                DT_OPERATION_nin       IN BOOLEAN := TRUE,
                flg_status_in          IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                FLG_STATUS_nin         IN BOOLEAN := TRUE,
                create_user_in         IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                CREATE_USER_nin        IN BOOLEAN := TRUE,
                create_time_in         IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                CREATE_TIME_nin        IN BOOLEAN := TRUE,
                create_institution_in  IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                CREATE_INSTITUTION_nin IN BOOLEAN := TRUE,
                update_user_in         IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                UPDATE_USER_nin        IN BOOLEAN := TRUE,
                update_time_in         IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                UPDATE_TIME_nin        IN BOOLEAN := TRUE,
                update_institution_in  IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                UPDATE_INSTITUTION_nin IN BOOLEAN := TRUE,
                clinical_data_in       IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                CLINICAL_DATA_nin      IN BOOLEAN := TRUE,
                where_in               varchar2,
                handle_error_in        IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    upd(doc_oid_in             => doc_oid_in,
        DOC_OID_nin            => DOC_OID_nin,
        doc_source_in          => doc_source_in,
        DOC_SOURCE_nin         => DOC_SOURCE_nin,
        id_professional_in     => id_professional_in,
        ID_PROFESSIONAL_nin    => ID_PROFESSIONAL_nin,
        id_institution_in      => id_institution_in,
        ID_INSTITUTION_nin     => ID_INSTITUTION_nin,
        dt_operation_in        => dt_operation_in,
        DT_OPERATION_nin       => DT_OPERATION_nin,
        flg_status_in          => flg_status_in,
        FLG_STATUS_nin         => FLG_STATUS_nin,
        create_user_in         => create_user_in,
        CREATE_USER_nin        => CREATE_USER_nin,
        create_time_in         => create_time_in,
        CREATE_TIME_nin        => CREATE_TIME_nin,
        create_institution_in  => create_institution_in,
        CREATE_INSTITUTION_nin => CREATE_INSTITUTION_nin,
        update_user_in         => update_user_in,
        UPDATE_USER_nin        => UPDATE_USER_nin,
        update_time_in         => update_time_in,
        UPDATE_TIME_nin        => UPDATE_TIME_nin,
        update_institution_in  => update_institution_in,
        UPDATE_INSTITUTION_nin => UPDATE_INSTITUTION_nin,
        clinical_data_in       => clinical_data_in,
        CLINICAL_DATA_nin      => CLINICAL_DATA_nin,
        where_in               => where_in,
        handle_error_in        => handle_error_in,
        rows_out               => rows_out);
  END upd;

  PROCEDURE upd(rec_in          IN CLINICAL_DATA_REC%ROWTYPE,
                handle_error_in IN BOOLEAN := TRUE,
                rows_out        IN OUT TABLE_VARCHAR) IS
  BEGIN
    upd(id_clinical_data_rec_in => rec_in.ID_CLINICAL_DATA_REC,
        doc_oid_in              => rec_in.DOC_OID,
        doc_source_in           => rec_in.DOC_SOURCE,
        id_professional_in      => rec_in.ID_PROFESSIONAL,
        id_institution_in       => rec_in.ID_INSTITUTION,
        dt_operation_in         => rec_in.DT_OPERATION,
        flg_status_in           => rec_in.FLG_STATUS,
        create_user_in          => rec_in.CREATE_USER,
        create_time_in          => rec_in.CREATE_TIME,
        create_institution_in   => rec_in.CREATE_INSTITUTION,
        update_user_in          => rec_in.UPDATE_USER,
        update_time_in          => rec_in.UPDATE_TIME,
        update_institution_in   => rec_in.UPDATE_INSTITUTION,
        clinical_data_in        => rec_in.CLINICAL_DATA
        
       ,
        handle_error_in => handle_error_in,
        rows_out        => rows_out);
  END upd;

  PROCEDURE upd(rec_in          IN CLINICAL_DATA_REC%ROWTYPE,
                handle_error_in IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    upd(id_clinical_data_rec_in => rec_in.ID_CLINICAL_DATA_REC,
        doc_oid_in              => rec_in.DOC_OID,
        doc_source_in           => rec_in.DOC_SOURCE,
        id_professional_in      => rec_in.ID_PROFESSIONAL,
        id_institution_in       => rec_in.ID_INSTITUTION,
        dt_operation_in         => rec_in.DT_OPERATION,
        flg_status_in           => rec_in.FLG_STATUS,
        create_user_in          => rec_in.CREATE_USER,
        create_time_in          => rec_in.CREATE_TIME,
        create_institution_in   => rec_in.CREATE_INSTITUTION,
        update_user_in          => rec_in.UPDATE_USER,
        update_time_in          => rec_in.UPDATE_TIME,
        update_institution_in   => rec_in.UPDATE_INSTITUTION,
        clinical_data_in        => rec_in.CLINICAL_DATA
        
       ,
        handle_error_in => handle_error_in,
        rows_out        => rows_out);
  END upd;

  PROCEDURE upd_ins(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                    doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                    doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                    id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                    id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                    dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                    flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                    create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                    create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                    create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                    update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                    update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                    update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                    clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                    handle_error_in         IN BOOLEAN := TRUE,
                    rows_out                OUT TABLE_VARCHAR) IS
  BEGIN
    upd(id_clinical_data_rec_in => id_clinical_data_rec_in,
        doc_oid_in              => doc_oid_in,
        doc_source_in           => doc_source_in,
        id_professional_in      => id_professional_in,
        id_institution_in       => id_institution_in,
        dt_operation_in         => dt_operation_in,
        flg_status_in           => flg_status_in,
        create_user_in          => create_user_in,
        create_time_in          => create_time_in,
        create_institution_in   => create_institution_in,
        update_user_in          => update_user_in,
        update_time_in          => update_time_in,
        update_institution_in   => update_institution_in,
        clinical_data_in        => clinical_data_in,
        handle_error_in         => handle_error_in,
        rows_out                => rows_out);
    IF SQL%ROWCOUNT = 0 THEN
      ins(id_clinical_data_rec_in => id_clinical_data_rec_in,
          doc_oid_in              => doc_oid_in,
          doc_source_in           => doc_source_in,
          id_professional_in      => id_professional_in,
          id_institution_in       => id_institution_in,
          dt_operation_in         => dt_operation_in,
          flg_status_in           => flg_status_in,
          create_user_in          => create_user_in,
          create_time_in          => create_time_in,
          create_institution_in   => create_institution_in,
          update_user_in          => update_user_in,
          update_time_in          => update_time_in,
          update_institution_in   => update_institution_in,
          clinical_data_in        => clinical_data_in,
          handle_error_in         => handle_error_in,
          rows_out                => rows_out);
    END IF;
  END upd_ins;

  PROCEDURE upd_ins(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                    doc_oid_in              IN CLINICAL_DATA_REC.DOC_OID%TYPE DEFAULT NULL,
                    doc_source_in           IN CLINICAL_DATA_REC.DOC_SOURCE%TYPE DEFAULT NULL,
                    id_professional_in      IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE DEFAULT NULL,
                    id_institution_in       IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE DEFAULT NULL,
                    dt_operation_in         IN CLINICAL_DATA_REC.DT_OPERATION%TYPE DEFAULT NULL,
                    flg_status_in           IN CLINICAL_DATA_REC.FLG_STATUS%TYPE DEFAULT NULL,
                    create_user_in          IN CLINICAL_DATA_REC.CREATE_USER%TYPE DEFAULT NULL,
                    create_time_in          IN CLINICAL_DATA_REC.CREATE_TIME%TYPE DEFAULT NULL,
                    create_institution_in   IN CLINICAL_DATA_REC.CREATE_INSTITUTION%TYPE DEFAULT NULL,
                    update_user_in          IN CLINICAL_DATA_REC.UPDATE_USER%TYPE DEFAULT NULL,
                    update_time_in          IN CLINICAL_DATA_REC.UPDATE_TIME%TYPE DEFAULT NULL,
                    update_institution_in   IN CLINICAL_DATA_REC.UPDATE_INSTITUTION%TYPE DEFAULT NULL,
                    clinical_data_in        IN CLINICAL_DATA_REC.CLINICAL_DATA%TYPE DEFAULT NULL,
                    handle_error_in         IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    upd_ins(id_clinical_data_rec_in,
            doc_oid_in,
            doc_source_in,
            id_professional_in,
            id_institution_in,
            dt_operation_in,
            flg_status_in,
            create_user_in,
            create_time_in,
            create_institution_in,
            update_user_in,
            update_time_in,
            update_institution_in,
            clinical_data_in,
            handle_error_in,
            rows_out);
  END upd_ins;

  PROCEDURE upd(col_in            IN CLINICAL_DATA_REC_tc,
                ignore_if_null_in IN BOOLEAN := TRUE,
                handle_error_in   IN BOOLEAN := TRUE,
                rows_out          IN OUT TABLE_VARCHAR) IS
    l_ID_CLINICAL_DATA_REC ID_CLINICAL_DATA_REC_cc;
    l_DOC_OID              DOC_OID_cc;
    l_DOC_SOURCE           DOC_SOURCE_cc;
    l_ID_PROFESSIONAL      ID_PROFESSIONAL_cc;
    l_ID_INSTITUTION       ID_INSTITUTION_cc;
    l_DT_OPERATION         DT_OPERATION_cc;
    l_FLG_STATUS           FLG_STATUS_cc;
    l_CREATE_USER          CREATE_USER_cc;
    l_CREATE_TIME          CREATE_TIME_cc;
    l_CREATE_INSTITUTION   CREATE_INSTITUTION_cc;
    l_UPDATE_USER          UPDATE_USER_cc;
    l_UPDATE_TIME          UPDATE_TIME_cc;
    l_UPDATE_INSTITUTION   UPDATE_INSTITUTION_cc;
    l_CLINICAL_DATA        CLINICAL_DATA_cc;
  BEGIN
    FOR i IN col_in.FIRST .. col_in.LAST loop
      l_ID_CLINICAL_DATA_REC(i) := col_in(i).ID_CLINICAL_DATA_REC;
      l_DOC_OID(i) := col_in(i).DOC_OID;
      l_DOC_SOURCE(i) := col_in(i).DOC_SOURCE;
      l_ID_PROFESSIONAL(i) := col_in(i).ID_PROFESSIONAL;
      l_ID_INSTITUTION(i) := col_in(i).ID_INSTITUTION;
      l_DT_OPERATION(i) := col_in(i).DT_OPERATION;
      l_FLG_STATUS(i) := col_in(i).FLG_STATUS;
      l_CREATE_USER(i) := col_in(i).CREATE_USER;
      l_CREATE_TIME(i) := col_in(i).CREATE_TIME;
      l_CREATE_INSTITUTION(i) := col_in(i).CREATE_INSTITUTION;
      l_UPDATE_USER(i) := col_in(i).UPDATE_USER;
      l_UPDATE_TIME(i) := col_in(i).UPDATE_TIME;
      l_UPDATE_INSTITUTION(i) := col_in(i).UPDATE_INSTITUTION;
      l_CLINICAL_DATA(i) := col_in(i).CLINICAL_DATA;
    END LOOP;
    IF NVL(ignore_if_null_in, FALSE) THEN
      -- Set any columns to their current values
      -- if incoming value is NULL.
      -- Put WHEN clause on column-level triggers!
      FORALL i IN col_in.FIRST .. col_in.LAST
        UPDATE CLINICAL_DATA_REC
           SET DOC_OID            = NVL(l_DOC_OID(i), DOC_OID),
               DOC_SOURCE         = NVL(l_DOC_SOURCE(i), DOC_SOURCE),
               ID_PROFESSIONAL    = NVL(l_ID_PROFESSIONAL(i),
                                        ID_PROFESSIONAL),
               ID_INSTITUTION     = NVL(l_ID_INSTITUTION(i), ID_INSTITUTION),
               DT_OPERATION       = NVL(l_DT_OPERATION(i), DT_OPERATION),
               FLG_STATUS         = NVL(l_FLG_STATUS(i), FLG_STATUS),
               CREATE_USER        = NVL(l_CREATE_USER(i), CREATE_USER),
               CREATE_TIME        = NVL(l_CREATE_TIME(i), CREATE_TIME),
               CREATE_INSTITUTION = NVL(l_CREATE_INSTITUTION(i),
                                        CREATE_INSTITUTION),
               UPDATE_USER        = NVL(l_UPDATE_USER(i), UPDATE_USER),
               UPDATE_TIME        = NVL(l_UPDATE_TIME(i), UPDATE_TIME),
               UPDATE_INSTITUTION = NVL(l_UPDATE_INSTITUTION(i),
                                        UPDATE_INSTITUTION),
               CLINICAL_DATA      = NVL(l_CLINICAL_DATA(i), CLINICAL_DATA)
         WHERE ID_CLINICAL_DATA_REC = l_ID_CLINICAL_DATA_REC(i)
        returning rowid bulk collect into rows_out;
    ELSE
      FORALL i IN col_in.FIRST .. col_in.LAST
        UPDATE CLINICAL_DATA_REC
           SET DOC_OID            = l_DOC_OID(i),
               DOC_SOURCE         = l_DOC_SOURCE(i),
               ID_PROFESSIONAL    = l_ID_PROFESSIONAL(i),
               ID_INSTITUTION     = l_ID_INSTITUTION(i),
               DT_OPERATION       = l_DT_OPERATION(i),
               FLG_STATUS         = l_FLG_STATUS(i),
               CREATE_USER        = l_CREATE_USER(i),
               CREATE_TIME        = l_CREATE_TIME(i),
               CREATE_INSTITUTION = l_CREATE_INSTITUTION(i),
               UPDATE_USER        = l_UPDATE_USER(i),
               UPDATE_TIME        = l_UPDATE_TIME(i),
               UPDATE_INSTITUTION = l_UPDATE_INSTITUTION(i),
               CLINICAL_DATA      = l_CLINICAL_DATA(i)
         WHERE ID_CLINICAL_DATA_REC = l_ID_CLINICAL_DATA_REC(i)
        returning rowid bulk collect into rows_out;
    END IF;
  END upd;

  PROCEDURE upd(col_in            IN CLINICAL_DATA_REC_tc,
                ignore_if_null_in IN BOOLEAN := TRUE,
                handle_error_in   IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    upd(col_in, ignore_if_null_in, handle_error_in, rows_out);
  END upd;

  FUNCTION dynupdstr(colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
                     where_in   IN VARCHAR2 := NULL)
  
   RETURN VARCHAR2 IS
  BEGIN
    RETURN 'BEGIN UPDATE CLINICAL_DATA_REC
             SET ' || colname_in || ' = :value
           WHERE ' || NVL(where_in, '1=1') || ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;';
  END dynupdstr;

  FUNCTION dynupdstr_no_rows_out(colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
                                 where_in   IN VARCHAR2 := NULL)
  
   RETURN VARCHAR2 IS
  BEGIN
    RETURN 'UPDATE CLINICAL_DATA_REC
             SET ' || colname_in || ' = :value
           WHERE ' || NVL(where_in, '1=1');
  END dynupdstr_no_rows_out;

  PROCEDURE increment_onecol(colname_in         IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
                             where_in           IN VARCHAR2 := NULL,
                             increment_value_in IN NUMBER DEFAULT 1,
                             handle_error_in    IN BOOLEAN := TRUE,
                             rows_out           OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN UPDATE CLINICAL_DATA_REC set ' || colname_in || '=' ||
                      colname_in || ' + ' || nvl(increment_value_in, 1) ||
                      ' WHERE ' || NVL(where_in, '1=1') ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      USING OUT rows_out;
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner           ALL_CONSTRAINTS.OWNER%TYPE;
          l_name            ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_err_instance_id PLS_INTEGER;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'DUPLICATE-VALUE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
    WHEN e_null_column_value THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          v_errm    VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
          dot1loc   INTEGER;
          dot2loc   INTEGER;
          parenloc  INTEGER;
          c_owner   ALL_CONSTRAINTS.OWNER%TYPE;
          c_tabname ALL_TABLES.TABLE_NAME%TYPE;
          c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
          dot1loc   := INSTR(v_errm, '.', 1, 1);
          dot2loc   := INSTR(v_errm, '.', 1, 2);
          parenloc  := INSTR(v_errm, '(');
          c_owner   := SUBSTR(v_errm, parenloc + 1, dot1loc - parenloc - 1);
          c_tabname := SUBSTR(v_errm, dot1loc + 1, dot2loc - dot1loc - 1);
          c_colname := SUBSTR(v_errm,
                              dot2loc + 1,
                              INSTR(v_errm, ')') - dot2loc - 1);
        
          pk_alert_exceptions.raise_error(error_name_in => 'COLUMN-CANNOT-BE-NULL',
                                          name1_in      => 'OWNER',
                                          value1_in     => c_owner,
                                          name2_in      => 'TABLE_NAME',
                                          value2_in     => c_tabname,
                                          name3_in      => 'COLUMN_NAME',
                                          value3_in     => c_colname);
        END;
      END IF;
  END increment_onecol;

  PROCEDURE increment_onecol(colname_in         IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE,
                             where_in           IN VARCHAR2 := NULL,
                             increment_value_in IN NUMBER DEFAULT 1,
                             handle_error_in    IN BOOLEAN := TRUE) IS
    rows_out table_varchar;
  BEGIN
    EXECUTE IMMEDIATE 'UPDATE CLINICAL_DATA_REC set ' || colname_in || '=' ||
                      colname_in || ' + ' || nvl(increment_value_in, 1) ||
                      ' WHERE ' || NVL(where_in, '1=1');
  EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner           ALL_CONSTRAINTS.OWNER%TYPE;
          l_name            ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_err_instance_id PLS_INTEGER;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'DUPLICATE-VALUE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
    WHEN e_null_column_value THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          v_errm    VARCHAR2(2000) := DBMS_UTILITY.FORMAT_ERROR_STACK;
          dot1loc   INTEGER;
          dot2loc   INTEGER;
          parenloc  INTEGER;
          c_owner   ALL_CONSTRAINTS.OWNER%TYPE;
          c_tabname ALL_TABLES.TABLE_NAME%TYPE;
          c_colname ALL_TAB_COLUMNS.COLUMN_NAME%TYPE;
        BEGIN
          dot1loc   := INSTR(v_errm, '.', 1, 1);
          dot2loc   := INSTR(v_errm, '.', 1, 2);
          parenloc  := INSTR(v_errm, '(');
          c_owner   := SUBSTR(v_errm, parenloc + 1, dot1loc - parenloc - 1);
          c_tabname := SUBSTR(v_errm, dot1loc + 1, dot2loc - dot1loc - 1);
          c_colname := SUBSTR(v_errm,
                              dot2loc + 1,
                              INSTR(v_errm, ')') - dot2loc - 1);
        
          pk_alert_exceptions.raise_error(error_name_in => 'COLUMN-CANNOT-BE-NULL',
                                          name1_in      => 'OWNER',
                                          value1_in     => c_owner,
                                          name2_in      => 'TABLE_NAME',
                                          value2_in     => c_tabname,
                                          name3_in      => 'COLUMN_NAME',
                                          value3_in     => c_colname);
        END;
      END IF;
  END increment_onecol;

  -- Delete functionality

  PROCEDURE del(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                handle_error_in         IN BOOLEAN := TRUE,
                rows_out                OUT TABLE_VARCHAR) IS
  BEGIN
    DELETE FROM CLINICAL_DATA_REC
     WHERE ID_CLINICAL_DATA_REC = id_clinical_data_rec_in
    RETURNING ROWID BULK COLLECT INTO rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del;

  PROCEDURE del(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                handle_error_in         IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
  
    del(id_clinical_data_rec_in => id_clinical_data_rec_in,
        handle_error_in         => handle_error_in,
        rows_out                => rows_out);
  
  END del;

  -- Delete all rows for primary key column ID_CLINICAL_DATA_REC
  PROCEDURE del_ID_CLINICAL_DATA_REC(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                                     handle_error_in         IN BOOLEAN := TRUE,
                                     rows_out                OUT TABLE_VARCHAR) IS
  BEGIN
    DELETE FROM CLINICAL_DATA_REC
     WHERE ID_CLINICAL_DATA_REC = id_clinical_data_rec_in
    RETURNING ROWID BULK COLLECT INTO rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_ID_CLINICAL_DATA_REC;

  -- Delete all rows for primary key column ID_CLINICAL_DATA_REC
  PROCEDURE del_ID_CLINICAL_DATA_REC(id_clinical_data_rec_in IN CLINICAL_DATA_REC.ID_CLINICAL_DATA_REC%TYPE,
                                     handle_error_in         IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    del_ID_CLINICAL_DATA_REC(id_clinical_data_rec_in => id_clinical_data_rec_in,
                             handle_error_in         => handle_error_in,
                             rows_out                => rows_out);
  END del_ID_CLINICAL_DATA_REC;

  PROCEDURE del_CDR_AI_FK(id_institution_in IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE,
                          handle_error_in   IN BOOLEAN := TRUE,
                          rows_out          OUT TABLE_VARCHAR) IS
  BEGIN
    DELETE FROM CLINICAL_DATA_REC
     WHERE ID_INSTITUTION = del_CDR_AI_FK.id_institution_in
    RETURNING ROWID BULK COLLECT INTO rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_CDR_AI_FK;

  PROCEDURE del_CDR_AI_FK(id_institution_in IN CLINICAL_DATA_REC.ID_INSTITUTION%TYPE,
                          handle_error_in   IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    del_CDR_AI_FK(id_institution_in => id_institution_in,
                  handle_error_in   => handle_error_in,
                  rows_out          => rows_out);
  END del_CDR_AI_FK;

  PROCEDURE del_CDR_P_FK(id_professional_in IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE,
                         handle_error_in    IN BOOLEAN := TRUE,
                         rows_out           OUT TABLE_VARCHAR) IS
  BEGIN
    DELETE FROM CLINICAL_DATA_REC
     WHERE ID_PROFESSIONAL = del_CDR_P_FK.id_professional_in
    RETURNING ROWID BULK COLLECT INTO rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_CDR_P_FK;

  PROCEDURE del_CDR_P_FK(id_professional_in IN CLINICAL_DATA_REC.ID_PROFESSIONAL%TYPE,
                         handle_error_in    IN BOOLEAN := TRUE) IS
    rows_out TABLE_VARCHAR;
  BEGIN
    del_CDR_P_FK(id_professional_in => id_professional_in,
                 handle_error_in    => handle_error_in,
                 rows_out           => rows_out);
  END del_CDR_P_FK;

  -- Deletions using dynamic SQL
  FUNCTION dyndelstr(where_in IN VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    IF where_in IS NULL THEN
      RETURN 'DELETE FROM CLINICAL_DATA_REC';
    ELSE
      RETURN 'DELETE FROM CLINICAL_DATA_REC WHERE ' || where_in;
    END IF;
  END dyndelstr;

  FUNCTION dyncoldelstr(colname_in IN ALL_TAB_COLUMNS.COLUMN_NAME%TYPE)
    RETURN VARCHAR2 IS
  BEGIN
    RETURN dyndelstr(colname_in || ' = :value');
  END;

  PROCEDURE del_by(where_clause_in IN VARCHAR2,
                   handle_error_in IN BOOLEAN := TRUE) IS
  BEGIN
    EXECUTE IMMEDIATE dyndelstr(where_clause_in);
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by;

  PROCEDURE del_by(where_clause_in IN VARCHAR2,
                   handle_error_in IN BOOLEAN := TRUE,
                   rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN ' || dyndelstr(where_clause_in) ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      using OUT rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN VARCHAR2,
                       handle_error_in IN BOOLEAN := TRUE) IS
  BEGIN
    EXECUTE IMMEDIATE dyncoldelstr(colname_in)
      USING colvalue_in;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN VARCHAR2,
                       handle_error_in IN BOOLEAN := TRUE,
                       rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN ' || dyncoldelstr(colname_in) ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      USING IN colvalue_in, OUT rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN DATE,
                       handle_error_in IN BOOLEAN := TRUE) IS
  BEGIN
    EXECUTE IMMEDIATE dyncoldelstr(colname_in)
      USING colvalue_in;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN DATE,
                       handle_error_in IN BOOLEAN := TRUE,
                       rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN ' || dyncoldelstr(colname_in) ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      USING IN colvalue_in, OUT rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN TIMESTAMP WITH LOCAL TIME ZONE,
                       handle_error_in IN BOOLEAN := TRUE) IS
  BEGIN
    EXECUTE IMMEDIATE dyncoldelstr(colname_in)
      USING colvalue_in;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN TIMESTAMP WITH LOCAL TIME ZONE,
                       handle_error_in IN BOOLEAN := TRUE,
                       rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN ' || dyncoldelstr(colname_in) ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      USING IN colvalue_in, OUT rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN NUMBER,
                       handle_error_in IN BOOLEAN := TRUE) IS
  BEGIN
    EXECUTE IMMEDIATE dyncoldelstr(colname_in)
      USING colvalue_in;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  PROCEDURE del_by_col(colname_in      IN VARCHAR2,
                       colvalue_in     IN NUMBER,
                       handle_error_in IN BOOLEAN := TRUE,
                       rows_out        OUT TABLE_VARCHAR) IS
  BEGIN
    EXECUTE IMMEDIATE 'BEGIN ' || dyncoldelstr(colname_in) ||
                      ' RETURNING ROWID BULK COLLECT INTO :rows_out; END;'
      USING IN colvalue_in, OUT rows_out;
  EXCEPTION
    WHEN e_check_constraint_failure THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner ALL_CONSTRAINTS.OWNER%TYPE;
          l_name  ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
        BEGIN
          get_constraint_info(l_owner, l_name);
          pk_alert_exceptions.raise_error(error_name_in => 'CHECK-CONSTRAINT-FAILURE',
                                          name1_in      => 'OWNER',
                                          value1_in     => l_owner,
                                          name2_in      => 'CONSTRAINT_NAME',
                                          value2_in     => l_name,
                                          name3_in      => 'TABLE_NAME',
                                          value3_in     => 'CLINICAL_DATA_REC');
        END;
      END IF;
    WHEN e_integ_constraint_failure OR e_no_parent_key OR
         e_child_record_found THEN
      IF NOT handle_error_in THEN
        RAISE;
      ELSE
        DECLARE
          l_owner    ALL_CONSTRAINTS.OWNER%TYPE;
          l_name     ALL_CONSTRAINTS.CONSTRAINT_NAME%TYPE;
          l_id       PLS_INTEGER;
          l_err_name VARCHAR2(32767) DEFAULT 'NO-PARENT-KEY-FOUND';
        BEGIN
          get_constraint_info(l_owner, l_name);
          IF SQLCODE = -2292 -- Child record found
           THEN
            l_err_name := 'CHILD-RECORD-FOUND';
          END IF;
          pk_alert_exceptions.register_error(error_name_in       => l_err_name,
                                             err_instance_id_out => l_id,
                                             name1_in            => 'OWNER',
                                             value1_in           => l_owner,
                                             name2_in            => 'CONSTRAINT_NAME',
                                             value2_in           => l_name,
                                             name3_in            => 'TABLE_NAME',
                                             value3_in           => 'CLINICAL_DATA_REC');
          pk_alert_exceptions.raise_error_instance(err_instance_id_in => l_id);
        END;
      END IF;
  END del_by_col;

  -- Initialize a record with default values for columns in the table.
  PROCEDURE initrec(clinical_data_rec_inout IN OUT CLINICAL_DATA_REC%ROWTYPE) IS
  BEGIN
    clinical_data_rec_inout.ID_CLINICAL_DATA_REC := NULL;
    clinical_data_rec_inout.DOC_OID              := NULL;
    clinical_data_rec_inout.DOC_SOURCE           := NULL;
    clinical_data_rec_inout.ID_PROFESSIONAL      := NULL;
    clinical_data_rec_inout.ID_INSTITUTION       := NULL;
    clinical_data_rec_inout.DT_OPERATION         := NULL;
    clinical_data_rec_inout.FLG_STATUS           := NULL;
    clinical_data_rec_inout.CREATE_USER          := NULL;
    clinical_data_rec_inout.CREATE_TIME          := NULL;
    clinical_data_rec_inout.CREATE_INSTITUTION   := NULL;
    clinical_data_rec_inout.UPDATE_USER          := NULL;
    clinical_data_rec_inout.UPDATE_TIME          := NULL;
    clinical_data_rec_inout.UPDATE_INSTITUTION   := NULL;
    clinical_data_rec_inout.CLINICAL_DATA        := NULL;
  END initrec;

  FUNCTION initrec RETURN CLINICAL_DATA_REC%ROWTYPE IS
    l_clinical_data_rec CLINICAL_DATA_REC%ROWTYPE;
  BEGIN
    RETURN l_clinical_data_rec;
  END initrec;

  FUNCTION get_data_rowid(rows_in IN TABLE_VARCHAR)
    RETURN CLINICAL_DATA_REC_tc IS
    data CLINICAL_DATA_REC_tc;
  BEGIN
    select * bulk collect
      into data
      from CLINICAL_DATA_REC
     where rowid in (select /*+opt_estimate(table,t,scale_rows=0.0000001))*/
                      *
                       from table(rows_in) t);
    return data;
  EXCEPTION
    WHEN OTHERS THEN
      pk_alert_exceptions.raise_error(error_name_in => 'get_data_rowid');
  END get_data_rowid;

  FUNCTION get_data_rowid_pat(rows_in IN TABLE_VARCHAR)
    RETURN CLINICAL_DATA_REC_tc is
    PRAGMA AUTONOMOUS_TRANSACTION;
    data CLINICAL_DATA_REC_tc;
  BEGIN
    data := get_data_rowid(rows_in);
    commit;
    return data;
  EXCEPTION
    WHEN OTHERS THEN
      pk_alert_exceptions.raise_error(error_name_in => 'get_data_rowid');
      rollback;
  END get_data_rowid_pat;

BEGIN
  NULL;
END TS_CLINICAL_DATA_REC;
/
