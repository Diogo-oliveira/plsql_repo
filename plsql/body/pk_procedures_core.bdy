/*-- Last Change Revision: $Rev: 2055402 $*/
/*-- Last Change by: $Author: diogo.oliveira $*/
/*-- Date of last change: $Date: 2023-02-22 09:44:22 +0000 (qua, 22 fev 2023) $*/

CREATE OR REPLACE PACKAGE BODY pk_procedures_core IS

    FUNCTION create_procedure_order
    (
        i_lang                    IN language.id_language%TYPE, --1
        i_prof                    IN profissional,
        i_patient                 IN patient.id_patient%TYPE,
        i_episode                 IN episode.id_episode%TYPE,
        i_intervention            IN table_number, --5
        i_flg_time                IN table_varchar,
        i_dt_begin                IN table_varchar,
        i_episode_destination     IN table_number,
        i_order_recurrence        IN table_number,
        i_diagnosis_notes         IN table_varchar, --10
        i_diagnosis               IN pk_edis_types.table_in_epis_diagnosis,
        i_clinical_purpose        IN table_number,
        i_clinical_purpose_notes  IN table_varchar,
        i_laterality              IN table_varchar,
        i_priority                IN table_varchar, --15
        i_flg_prn                 IN table_varchar,
        i_notes_prn               IN table_varchar,
        i_exec_institution        IN table_number,
        i_flg_location            IN table_varchar,
        i_supply                  IN table_table_number, --20
        i_supply_set              IN table_table_number,
        i_supply_qty              IN table_table_number,
        i_dt_return               IN table_table_varchar,
        i_supply_loc              IN table_table_number,
        i_not_order_reason        IN table_number,
        i_notes                   IN table_varchar, --25
        i_prof_order              IN table_number,
        i_dt_order                IN table_varchar,
        i_order_type              IN table_number,
        i_codification            IN table_number,
        i_health_plan             IN table_number, --30
        i_exemption               IN table_number,
        i_clinical_question       IN table_table_number,
        i_response                IN table_table_varchar,
        i_clinical_question_notes IN table_table_varchar,
        i_clinical_decision_rule  IN table_number,
        i_flg_origin_req          IN VARCHAR2 DEFAULT 'D',
        i_test                    IN VARCHAR2, --35
        o_flg_show                OUT VARCHAR2,
        o_msg_title               OUT VARCHAR2,
        o_msg_req                 OUT VARCHAR2,
        o_interv_presc_array      OUT NOCOPY table_number,
        o_interv_presc_det_array  OUT NOCOPY table_number,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_continue BOOLEAN := TRUE;
    
        l_patient patient.id_patient%TYPE;
    
        l_interv_order interv_prescription.id_interv_prescription%TYPE;
        l_dt_begin     VARCHAR2(100 CHAR);
    
        l_clinical_question       table_number := table_number();
        l_response                table_varchar := table_varchar();
        l_clinical_question_notes table_varchar := table_varchar();
    
        l_count_out_reqs NUMBER := 0;
    
        TYPE t_record_interv_presc_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200 CHAR);
        ibt_interv_presc_map t_record_interv_presc_map;
    
        l_interv_presc     interv_prescription.id_interv_prescription%TYPE;
        l_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE;
    
        l_id_icnp_sug_interv table_number;
    
        l_order_recurrence         order_recurr_plan.id_order_recurr_plan%TYPE;
        l_order_recurrence_option  order_recurr_plan.id_order_recurr_option%TYPE;
        l_order_recurr_final_array table_number := table_number();
    
        TYPE t_order_recurr_plan_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200 CHAR);
        ibt_order_recurr_plan_map t_order_recurr_plan_map;
    
        l_tbl_supply_loc table_number := table_number();
    
        l_id_dept dept.id_dept%TYPE;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_sysdate_char := pk_date_utils.date_send_tsz(i_lang, current_timestamp, i_prof);
    
        o_interv_presc_array     := table_number();
        o_interv_presc_det_array := table_number();
    
        IF i_episode IS NOT NULL
        THEN
            l_patient := pk_episode.get_id_patient(i_episode => i_episode);
        
            g_error := 'PATIENT / EPISODE DON''T MATCH';
            IF l_patient != i_patient
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        IF i_test = pk_procedures_constant.g_yes
        THEN
            -- Verificar se o procedimento já tinha sido requisitado recentemente
            g_error    := 'CALL TO pk_procedures_utils.GET_PROCEDURE_REQUEST';
            o_flg_show := pk_procedures_utils.get_procedure_request(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_patient      => i_patient,
                                                                    i_intervention => i_intervention,
                                                                    o_msg_title    => o_msg_title,
                                                                    o_msg_req      => o_msg_req);
        
            IF o_flg_show = pk_procedures_constant.g_yes
            THEN
                l_continue := FALSE;
            END IF;
        END IF;
    
        IF l_continue
        THEN
            FOR i IN 1 .. i_intervention.count
            LOOP
                IF i_order_recurrence(i) IS NOT NULL
                   AND i_flg_origin_req != pk_alert_constant.g_task_origin_order_set
                THEN
                    BEGIN
                        l_order_recurrence := ibt_order_recurr_plan_map(i_order_recurrence(i));
                    EXCEPTION
                        WHEN no_data_found THEN
                        
                            -- set order recurrence plan as finished or cancel plan (order_recurr_option - 0 OR -2 ---- order_recurr_area NOT IN (7,8,9)
                            g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                            IF NOT
                                pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                                 i_prof                    => i_prof,
                                                                                 i_order_recurr_plan       => i_order_recurrence(i),
                                                                                 o_order_recurr_option     => l_order_recurrence_option,
                                                                                 o_final_order_recurr_plan => l_order_recurrence,
                                                                                 o_error                   => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            -- add new order recurrence plan to map collection
                            ibt_order_recurr_plan_map(i_order_recurrence(i)) := l_order_recurrence;
                        
                            IF l_order_recurrence IS NOT NULL
                            THEN
                                l_order_recurr_final_array.extend;
                                l_order_recurr_final_array(l_order_recurr_final_array.count) := l_order_recurrence;
                            END IF;
                    END;
                ELSIF i_order_recurrence(i) IS NOT NULL
                      AND i_flg_origin_req = pk_alert_constant.g_task_origin_order_set
                THEN
                    l_order_recurrence := i_order_recurrence(i);
                END IF;
            
                l_clinical_question := table_number();
                IF i_clinical_question.count > 0
                   AND i_clinical_question(i).count > 0
                THEN
                    FOR j IN i_clinical_question(i).first .. i_clinical_question(i).last
                    LOOP
                        l_clinical_question.extend;
                        l_clinical_question(j) := i_clinical_question(i) (j);
                    END LOOP;
                END IF;
            
                l_response := table_varchar();
                IF i_response.count > 0
                   AND i_response(i).count > 0
                THEN
                    FOR j IN i_response(i).first .. i_response(i).last
                    LOOP
                        l_response.extend;
                        l_response(j) := i_response(i) (j);
                    END LOOP;
                END IF;
            
                l_clinical_question_notes := table_varchar();
                IF i_clinical_question_notes.count > 0
                   AND i_clinical_question_notes(i).count > 0
                THEN
                    FOR j IN i_clinical_question_notes(i).first .. i_clinical_question_notes(i).last
                    LOOP
                        l_clinical_question_notes.extend;
                        l_clinical_question_notes(j) := i_clinical_question_notes(i) (j);
                    END LOOP;
                END IF;
            
                IF i_flg_origin_req NOT IN
                   (pk_alert_constant.g_task_origin_order_set, pk_alert_constant.g_task_origin_cpoe)
                THEN
                    IF l_interv_presc IS NULL
                    THEN
                        l_interv_presc := ts_interv_prescription.next_key();
                    ELSE
                        IF i_dt_begin(i) < g_sysdate_char
                        THEN
                            l_dt_begin := g_sysdate_char;
                        ELSE
                            l_dt_begin := i_dt_begin(i);
                        END IF;
                    
                        BEGIN
                            g_error := 'GET L_INTERV_ORDER 1';
                            SELECT i.id_interv_prescription
                              INTO l_interv_order
                              FROM (SELECT ipd.id_interv_prescription,
                                           CASE
                                                WHEN ipd.dt_begin < g_sysdate_char THEN
                                                 g_sysdate_char
                                                ELSE
                                                 ipd.dt_begin
                                            END dt_begin
                                      FROM (SELECT ip.id_interv_prescription,
                                                   pk_date_utils.trunc_insttimezone_str(i_prof, ip.dt_begin_tstz, 'MI') dt_begin
                                              FROM interv_presc_det ipd, interv_prescription ip
                                             WHERE ipd.id_interv_presc_det IN
                                                   (SELECT /*+opt_estimate (table t rows=1)*/
                                                     *
                                                      FROM TABLE(o_interv_presc_det_array) t)
                                               AND ipd.id_interv_prescription = ip.id_interv_prescription
                                               AND ip.flg_time = i_flg_time(i)
                                               AND ipd.flg_prty = i_priority(i)
                                               AND (ipd.id_exec_institution = i_exec_institution(i) OR
                                                   (ipd.id_exec_institution IS NULL AND i_exec_institution(i) IS NULL))) ipd) i
                             WHERE (i.dt_begin = l_dt_begin OR
                                   (l_dt_begin IS NULL AND
                                   i_flg_time(i) NOT IN (pk_procedures_constant.g_flg_time_e,
                                                           pk_procedures_constant.g_flg_time_b,
                                                           pk_procedures_constant.g_flg_time_a,
                                                           pk_procedures_constant.g_flg_time_h)))
                               AND rownum = 1;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_interv_presc := ts_interv_prescription.next_key();
                        END;
                    END IF;
                ELSE
                    l_interv_presc := NULL;
                END IF;
            
                g_error := 'PROCESSING SUPPLY LOCATION';
                IF i_supply_loc.exists(i)
                THEN
                    l_tbl_supply_loc := table_number();
                    l_tbl_supply_loc := i_supply_loc(i);
                ELSE
                    l_tbl_supply_loc := table_number(NULL);
                END IF;
            
                g_error := 'CALL PK_PROCEDURES_CORE.CREATE_PROCEDURE_REQUEST';
                IF NOT pk_procedures_core.create_procedure_request(i_lang                    => i_lang,
                                                              i_prof                    => i_prof,
                                                              i_patient                 => i_patient,
                                                              i_episode                 => i_episode,
                                                              i_interv_prescription     => l_interv_presc,
                                                              i_intervention            => i_intervention(i),
                                                              i_flg_time                => i_flg_time(i),
                                                              i_dt_begin                => i_dt_begin(i),
                                                              i_episode_destination     => i_episode_destination(i),
                                                              i_order_recurrence        => l_order_recurrence,
                                                              i_diagnosis_notes         => CASE
                                                                                               WHEN i_diagnosis_notes.exists(i) THEN
                                                                                                i_diagnosis_notes(i)
                                                                                               ELSE
                                                                                                NULL
                                                                                           END,
                                                              i_diagnosis               => CASE
                                                                                               WHEN i_diagnosis IS NOT NULL
                                                                                                    AND i_diagnosis.count > 0 THEN
                                                                                                i_diagnosis(i)
                                                                                               ELSE
                                                                                                NULL
                                                                                           END,
                                                              i_clinical_purpose        => i_clinical_purpose(i),
                                                              i_clinical_purpose_notes  => i_clinical_purpose_notes(i),
                                                              i_laterality              => i_laterality(i),
                                                              i_priority                => i_priority(i),
                                                              i_flg_prn                 => i_flg_prn(i),
                                                              i_notes_prn               => i_notes_prn(i),
                                                              i_exec_institution        => i_exec_institution(i),
                                                              i_flg_location            => CASE
                                                                                               WHEN i_flg_location IS NOT NULL
                                                                                                    AND i_flg_location.count > 0 THEN
                                                                                                i_flg_location(i)
                                                                                               ELSE
                                                                                                NULL
                                                                                           END,
                                                              i_supply                  => i_supply(i),
                                                              i_supply_set              => i_supply_set(i),
                                                              i_supply_qty              => i_supply_qty(i),
                                                              i_dt_return               => i_dt_return(i),
                                                              i_supply_loc              => l_tbl_supply_loc,
                                                              i_not_order_reason        => i_not_order_reason(i),
                                                              i_notes                   => i_notes(i),
                                                              i_prof_order              => i_prof_order(i),
                                                              i_dt_order                => i_dt_order(i),
                                                              i_order_type              => i_order_type(i),
                                                              i_codification            => i_codification(i),
                                                              i_health_plan             => i_health_plan(i),
                                                              i_exemption               => i_exemption(i),
                                                              i_clinical_question       => l_clinical_question,
                                                              i_response                => l_response,
                                                              i_clinical_question_notes => l_clinical_question_notes,
                                                              i_clinical_decision_rule  => i_clinical_decision_rule(i),
                                                              i_flg_origin_req          => i_flg_origin_req,
                                                              o_interv_presc            => l_interv_presc,
                                                              o_interv_presc_det        => l_interv_presc_det,
                                                              o_error                   => o_error)
                THEN
                    IF o_error.err_desc IS NOT NULL
                    THEN
                        g_error_code := o_error.ora_sqlcode;
                        g_error      := o_error.ora_sqlerrm;
                    
                        RAISE g_user_exception;
                    ELSE
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                -- check if interv_presc not exists
                g_error := 'OUT VARIABLES';
                IF NOT ibt_interv_presc_map.exists(to_char(l_interv_presc))
                THEN
                    o_interv_presc_array.extend;
                    l_count_out_reqs := l_count_out_reqs + 1;
                
                    -- set mapping between interv_presc and its position in the output array
                    ibt_interv_presc_map(to_char(l_interv_presc)) := l_count_out_reqs;
                
                    -- set interv_presc output 
                    o_interv_presc_array(l_count_out_reqs) := l_interv_presc;
                END IF;
            
                IF l_order_recurr_final_array IS NOT NULL
                   OR l_order_recurr_final_array.count > 0
                THEN
                    g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                    IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang       => i_lang,
                                                                                i_prof       => i_prof,
                                                                                i_order_plan => l_order_recurr_final_array,
                                                                                o_error      => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                o_interv_presc_det_array.extend;
                o_interv_presc_det_array(o_interv_presc_det_array.count) := l_interv_presc_det;
            END LOOP;
        
            IF o_interv_presc_det_array.count > 0
               OR o_interv_presc_det_array IS NOT NULL
            THEN
                IF i_episode IS NOT NULL
                THEN
                    g_error := 'CALL PK_ICNP_FO_API_DB.CREATE_SUGGS';
                    pk_icnp_fo_api_db.create_suggs(i_lang               => i_lang,
                                                   i_prof               => i_prof,
                                                   i_id_episode         => i_episode,
                                                   i_request_ids        => o_interv_presc_det_array,
                                                   i_task_ids           => i_intervention,
                                                   i_task_type_id       => pk_alert_constant.g_task_proc_interv,
                                                   i_sysdate_tstz       => g_sysdate_tstz,
                                                   o_id_icnp_sug_interv => l_id_icnp_sug_interv);
                END IF;
            END IF;
        
            g_error := 'CALL PK_EA_LOGIC_PROCEDURES.SET_GRID_TASK_PROCEDURES_ACROSS';
            IF NOT pk_ea_logic_procedures.set_grid_task_procedures_across(i_lang    => i_lang,
                                                                          i_prof    => i_prof,
                                                                          i_patient => i_patient,
                                                                          o_error   => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            BEGIN
                l_id_dept := pk_complaint.get_id_department(i_lang, i_prof, i_episode) (1);
            
                FOR i IN 1 .. i_intervention.count
                LOOP
                    IF NOT pk_procedures_utils.manage_most_frequent(i_lang            => i_lang,
                                                                    i_prof            => i_prof,
                                                                    i_id_intervention => i_intervention(i),
                                                                    o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    IF NOT pk_procedures_utils.manage_most_frequent_dept(i_lang            => i_lang,
                                                                         i_prof            => i_prof,
                                                                         i_id_intervention => i_intervention(i),
                                                                         i_dept            => l_id_dept,
                                                                         o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END LOOP;
            EXCEPTION
                WHEN OTHERS THEN
                    NULL;
            END;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_user_exception THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     g_error_code,
                                                     NULL,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'CREATE_PROCEDURE_ORDER',
                                                     'U',
                                                     NULL,
                                                     CASE WHEN g_error_code = 'INTERV_M010' THEN
                                                     pk_message.get_message(i_lang, 'COMMON_T006') ELSE '' END,
                                                     NULL,
                                                     o_error);
        
            o_interv_presc_array     := table_number();
            o_interv_presc_det_array := table_number();
        
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_PROCEDURE_ORDER',
                                              o_error);
            RETURN FALSE;
    END create_procedure_order;

    FUNCTION create_procedure_order
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_episode                IN episode.id_episode%TYPE,
        i_patient                IN patient.id_patient%TYPE,
        i_root_name              IN VARCHAR2,
        i_tbl_id_pk              IN table_number,
        i_tbl_data               IN table_table_varchar,
        i_tbl_ds_internal_name   IN table_varchar,
        i_tbl_real_val           IN table_table_varchar,
        i_tbl_val_clob           IN table_table_clob,
        i_tbl_val_array          IN tt_table_varchar DEFAULT NULL,
        i_tbl_val_array_desc     IN tt_table_varchar DEFAULT NULL,
        i_clinical_question_pk   IN table_number,
        i_clinical_question      IN table_varchar,
        i_response               IN table_table_varchar,
        i_test                   IN VARCHAR2,
        i_flg_update             IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_origin_req         IN VARCHAR2 DEFAULT 'D',
        o_flg_show               OUT VARCHAR2,
        o_msg_title              OUT VARCHAR2,
        o_msg_req                OUT VARCHAR2,
        o_interv_presc_array     OUT NOCOPY table_number,
        o_interv_presc_det_array OUT NOCOPY table_number,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_tbl_interv_presc_det       table_number := table_number();
        l_tbl_intervention           table_number := table_number();
        l_tbl_flg_time               table_varchar := table_varchar();
        l_dt_begin                   table_varchar := table_varchar();
        l_tbl_episode_destination    table_number := table_number();
        l_tbl_order_recurrence       table_number := table_number();
        l_tbl_diagnosis_notes        table_varchar := table_varchar();
        l_tbl_id_diagnosis           table_number := table_number();
        l_tbl_id_alert_diagnosis     table_number := table_number();
        l_tbl_diagnosis_desc         table_varchar := table_varchar();
        l_tbl_diagnosis              table_clob := table_clob();
        l_tbl_clinical_purpose       table_number := table_number();
        l_tbl_clinical_purpose_notes table_varchar := table_varchar();
        l_tbl_laterality             table_varchar := table_varchar();
        l_tbl_priority               table_varchar := table_varchar();
        l_tbl_flg_prn                table_varchar := table_varchar();
        l_tbl_notes_prn              table_varchar := table_varchar();
        l_tbl_exec_institution       table_number := table_number();
        l_tbl_flg_location           table_varchar := table_varchar();
        l_tbl_not_order_reason       table_number := table_number();
        l_tbl_notes                  table_varchar := table_varchar();
        l_tbl_prof_order             table_number := table_number();
        l_tbl_dt_order               table_varchar := table_varchar();
        l_tbl_order_type             table_number := table_number();
        l_tbl_codification           table_number := table_number();
        l_tbl_health_plan            table_number := table_number();
        l_tbl_exemption              table_number := table_number();
    
        --Supplies
        l_tbl_supply     table_table_number := table_table_number();
        l_tbl_supply_set table_table_number := table_table_number();
        l_tbl_supply_qty table_table_number := table_table_number();
        l_tbl_dt_return  table_table_varchar := table_table_varchar();
        l_tbl_supply_loc table_table_number := table_table_number();
    
        --Supplies processed with Set information
        l_tbl_p_supply     table_table_number := table_table_number();
        l_tbl_p_supply_set table_table_number := table_table_number();
        l_tbl_p_supply_qty table_table_number := table_table_number();
        l_tbl_p_dt_return  table_table_varchar := table_table_varchar();
        l_tbl_p_supply_loc table_table_number := table_table_number();
    
        l_current_set supply.id_supply%TYPE := NULL;
    
        l_tbl_distinct_set     table_number := table_number();
        l_tbl_distinct_set_loc table_number := table_number();
    
        l_tbl_clinical_decision_rule table_number := table_number();
    
        l_id_interv_prescription interv_prescription.id_interv_prescription%TYPE;
    
        --Clinical questions
        l_tbl_cq                  tbl_rehab_question_response := tbl_rehab_question_response();
        l_tbl_cq_response         tbl_cq_response := tbl_cq_response();
        l_clinical_question       table_table_number := table_table_number();
        l_response                table_table_varchar := table_table_varchar();
        l_clinical_question_notes table_table_varchar := table_table_varchar();
        l_tbl_id_task             table_number := table_number();
        l_tbl_questionnaire       table_number := table_number();
    
        l_co_sign_available VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
    BEGIN
        g_error := 'ERROR CALLING PK_CO_SIGN_UX.CHECK_PROF_NEEDS_COSIGN_ORDER';
        IF NOT pk_co_sign_ux.check_prof_needs_cosign_order(i_lang                 => i_lang,
                                                           i_prof                 => i_prof,
                                                           i_episode              => i_episode,
                                                           i_task_type            => 43,
                                                           o_flg_prof_need_cosign => l_co_sign_available,
                                                           o_error                => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        IF i_flg_update = pk_alert_constant.g_no
        THEN
            g_error := 'ERROR EXTENDING TABLES';
            IF i_tbl_data.count > 0
            THEN
                FOR i IN i_tbl_data.first .. i_tbl_data.last
                LOOP
                    l_tbl_intervention.extend();
                    l_tbl_intervention(l_tbl_intervention.count) := to_number(i_tbl_data(i) (1));
                
                    --TRATAR A PARTIR DAQUI                        
                    l_tbl_clinical_decision_rule.extend();
                    l_tbl_clinical_decision_rule(l_tbl_clinical_decision_rule.count) := NULL;
                END LOOP;
            END IF;
        END IF;
    
        FOR i IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
        LOOP
            IF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_to_execute_list
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_flg_time.extend();
                    l_tbl_flg_time(l_tbl_flg_time.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_start_date
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_dt_begin.extend();
                    l_dt_begin(l_dt_begin.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_dummy_number
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_order_recurrence.extend();
                    l_tbl_order_recurrence(l_tbl_order_recurrence.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_ft
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_diagnosis_notes.extend();
                    l_tbl_diagnosis_notes(l_tbl_diagnosis_notes.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_diagnosis.extend();
                    l_tbl_id_diagnosis       := table_number();
                    l_tbl_id_alert_diagnosis := table_number();
                    l_tbl_diagnosis_desc     := table_varchar();
                
                    SELECT ad.id_diagnosis, ad.id_alert_diagnosis, t_value_desc.diagnosis_desc
                      BULK COLLECT
                      INTO l_tbl_id_diagnosis, l_tbl_id_alert_diagnosis, l_tbl_diagnosis_desc
                      FROM (SELECT /*+opt_estimate(table t rows=1)*/
                             to_number(t.column_value) id_alert_diagnosis, rownum rn
                              FROM TABLE(i_tbl_val_array(i) (j)) t) t_value
                      JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                             t.column_value diagnosis_desc, rownum rn
                              FROM TABLE(i_tbl_val_array_desc(i) (j)) t) t_value_desc
                        ON t_value_desc.rn = t_value.rn
                      JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = t_value.id_alert_diagnosis;
                
                    IF l_tbl_id_diagnosis.count > 0
                    THEN
                        l_tbl_diagnosis(l_tbl_diagnosis.count) := '<EPIS_DIAGNOSES ID_PATIENT="' || i_patient ||
                                                                  '" ID_EPISODE="' || i_episode || '" PROF_CAT_TYPE="' ||
                                                                  pk_prof_utils.get_category(i_lang, i_prof) ||
                                                                  '" FLG_TYPE="P" FLG_EDIT_MODE="" ID_CDR_CALL="">
                            <EPIS_DIAGNOSIS ID_EPIS_DIAGNOSIS="" ID_EPIS_DIAGNOSIS_HIST="" FLG_TRANSF_FINAL="">
                              <CANCEL_REASON ID_CANCEL_REASON="" FLG_CANCEL_DIFF_DIAG="" /> ';
                    
                        FOR k IN l_tbl_id_diagnosis.first .. l_tbl_id_diagnosis.last
                        LOOP
                            l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) ||
                                                                      ' <DIAGNOSIS ID_DIAGNOSIS="' ||
                                                                      l_tbl_id_diagnosis(k) || '" ID_ALERT_DIAG="' ||
                                                                      l_tbl_id_alert_diagnosis(k) || '">
                                <DESC_DIAGNOSIS>' ||
                                                                      l_tbl_diagnosis_desc(k) ||
                                                                      '</DESC_DIAGNOSIS>
                                <DIAGNOSIS_WARNING_REPORT>Diagnosis with no form fields.</DIAGNOSIS_WARNING_REPORT>
                              </DIAGNOSIS> ';
                        END LOOP;
                    
                        l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) ||
                                                                  ' </EPIS_DIAGNOSIS>
                            <GENERAL_NOTES ID="" ID_CANCEL_REASON="" />
                          </EPIS_DIAGNOSES>';
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_purpose
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_clinical_purpose.extend();
                    l_tbl_clinical_purpose(l_tbl_clinical_purpose.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_purpose_ft
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_clinical_purpose_notes.extend();
                    l_tbl_clinical_purpose_notes(l_tbl_clinical_purpose_notes.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_laterality
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_laterality.extend();
                    l_tbl_laterality(l_tbl_laterality.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_priority
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_priority.extend();
                    l_tbl_priority(l_tbl_priority.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_prn
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_flg_prn.extend();
                    l_tbl_flg_prn(l_tbl_flg_prn.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_prn_specify
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_notes_prn.extend();
                    l_tbl_notes_prn(l_tbl_notes_prn.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_place_service
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_exec_institution.extend();
                    l_tbl_exec_institution(l_tbl_exec_institution.count) := to_number(i_tbl_real_val(i) (j));
                
                    l_tbl_flg_location.extend();
                    l_tbl_flg_location(l_tbl_flg_location.count) := CASE
                                                                    --Dont ask
                                                                        WHEN to_number(i_tbl_real_val(i) (j)) = -100 THEN
                                                                         'HHC'
                                                                        WHEN to_number(i_tbl_real_val(i) (j)) <> i_prof.institution THEN
                                                                         'I'
                                                                        ELSE
                                                                         NULL
                                                                    END;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_reason_not_ordering
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_not_order_reason.extend();
                    l_tbl_not_order_reason(l_tbl_not_order_reason.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_notes_execution
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_notes.extend();
                    l_tbl_notes(l_tbl_notes.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_ordered_by
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_prof_order.extend();
                    l_tbl_prof_order(l_tbl_prof_order.count) := CASE
                                                                    WHEN i_tbl_real_val(i) (j) = '-1' THEN
                                                                     NULL
                                                                    ELSE
                                                                     to_number(i_tbl_real_val(i) (j))
                                                                END;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_execution_ordered_at
                  AND l_co_sign_available = pk_alert_constant.g_no
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_dt_order.extend();
                    l_tbl_dt_order(l_tbl_dt_order.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_ordered_at
                  AND l_co_sign_available = pk_alert_constant.g_yes
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_dt_order.extend();
                    l_tbl_dt_order(l_tbl_dt_order.count) := i_tbl_real_val(i) (j);
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_type
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_order_type.extend();
                    l_tbl_order_type(l_tbl_order_type.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_catalogue
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_codification.extend();
                    l_tbl_codification(l_tbl_codification.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_health_coverage_plan
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_health_plan.extend();
                    l_tbl_health_plan(l_tbl_health_plan.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_exemption
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_exemption.extend();
                    IF i_tbl_real_val(i) (j) IS NOT NULL
                    THEN
                        BEGIN
                            SELECT p.id_pat_isencao
                              INTO l_tbl_exemption(l_tbl_exemption.count)
                              FROM pat_isencao p
                             WHERE p.id_isencao = to_number(i_tbl_real_val(i) (j))
                               AND p.id_patient = i_patient
                               AND p.record_status = pk_alert_constant.g_active
                               AND rownum = 1;
                        EXCEPTION
                            WHEN OTHERS THEN
                                l_tbl_exemption(l_tbl_exemption.count) := NULL;
                        END;
                    
                        --Se a isenção ainda não está associada ao paciente, é necessário pedir ao ADT para a associar
                        IF l_tbl_exemption(l_tbl_exemption.count) IS NULL
                        THEN
                            IF NOT pk_adt_core.set_pat_isencao(i_lang           => i_lang,
                                                               i_prof           => i_prof,
                                                               i_patient        => i_patient,
                                                               i_id_isencao     => to_number(i_tbl_real_val(i) (j)),
                                                               o_id_pat_isencao => l_tbl_exemption(l_tbl_exemption.count),
                                                               o_error          => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        END IF;
                    ELSE
                        l_tbl_exemption(l_tbl_exemption.count) := NULL;
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_next_episode_id
            THEN
                FOR j IN i_tbl_real_val(i).first .. i_tbl_real_val(i).last
                LOOP
                    l_tbl_episode_destination.extend();
                    l_tbl_episode_destination(l_tbl_episode_destination.count) := to_number(i_tbl_real_val(i) (j));
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_id_supply
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_supply.extend();
                    l_tbl_supply(l_tbl_supply.count) := table_number();
                
                    FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                    LOOP
                        l_tbl_supply(l_tbl_supply.count).extend();
                        l_tbl_supply(l_tbl_supply.count)(k) := CASE
                                                                   WHEN i_tbl_val_array(i) (j) (k) = '-1' THEN
                                                                    NULL
                                                                   ELSE
                                                                    to_number(i_tbl_val_array(i) (j) (k))
                                                               END;
                    END LOOP;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_supply_set
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_supply_set.extend();
                    l_tbl_supply_set(l_tbl_supply_set.count) := table_number();
                
                    FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                    LOOP
                        l_tbl_supply_set(l_tbl_supply_set.count).extend();
                        l_tbl_supply_set(l_tbl_supply_set.count)(k) := CASE
                                                                           WHEN i_tbl_val_array(i) (j) (k) = '-1' THEN
                                                                            NULL
                                                                           ELSE
                                                                            to_number(i_tbl_val_array(i) (j) (k))
                                                                       END;
                    END LOOP;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_supply_quantity
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_supply_qty.extend();
                    l_tbl_supply_qty(l_tbl_supply_qty.count) := table_number();
                
                    FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                    LOOP
                        l_tbl_supply_qty(l_tbl_supply_qty.count).extend();
                        l_tbl_supply_qty(l_tbl_supply_qty.count)(k) := CASE
                                                                           WHEN i_tbl_val_array(i) (j) (k) = '-1' THEN
                                                                            NULL
                                                                           ELSE
                                                                            to_number(i_tbl_val_array(i) (j) (k))
                                                                       END;
                    END LOOP;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_supply_dt_return
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_dt_return.extend();
                    l_tbl_dt_return(l_tbl_dt_return.count) := table_varchar();
                
                    FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                    LOOP
                        l_tbl_dt_return(l_tbl_dt_return.count).extend();
                        l_tbl_dt_return(l_tbl_dt_return.count)(k) := CASE
                                                                         WHEN i_tbl_val_array(i) (j) (k) = '-1' THEN
                                                                          NULL
                                                                         ELSE
                                                                          i_tbl_val_array(i) (j) (k)
                                                                     END;
                    END LOOP;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_supply_location
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    l_tbl_supply_loc.extend();
                    l_tbl_supply_loc(l_tbl_supply_loc.count) := table_number();
                
                    FOR k IN i_tbl_val_array(i)(j).first .. i_tbl_val_array(i)(j).last
                    LOOP
                        l_tbl_supply_loc(l_tbl_supply_loc.count).extend();
                        l_tbl_supply_loc(l_tbl_supply_loc.count)(k) := CASE
                                                                           WHEN i_tbl_val_array(i) (j) (k) = '-1' THEN
                                                                            NULL
                                                                           ELSE
                                                                            to_number(i_tbl_val_array(i) (j) (k))
                                                                       END;
                    END LOOP;
                END LOOP;
            END IF;
        END LOOP;
    
        --Processessar Sets
        g_error := 'ERROR PROCESSING SETS OF SUPPLIES';
        IF l_tbl_supply.exists(1)
        THEN
            FOR i IN l_tbl_supply.first .. l_tbl_supply.last
            LOOP
                l_tbl_p_supply.extend();
                l_tbl_p_supply(l_tbl_p_supply.count) := table_number();
            
                l_tbl_p_supply_set.extend();
                l_tbl_p_supply_set(l_tbl_p_supply_set.count) := table_number();
            
                l_tbl_p_supply_qty.extend();
                l_tbl_p_supply_qty(l_tbl_p_supply_qty.count) := table_number();
            
                l_tbl_p_dt_return.extend();
                l_tbl_p_dt_return(l_tbl_p_dt_return.count) := table_varchar();
            
                l_tbl_p_supply_loc.extend();
                l_tbl_p_supply_loc(l_tbl_p_supply_loc.count) := table_number();
            
                l_current_set := NULL;
            
                FOR j IN l_tbl_supply(i).first .. l_tbl_supply(i).last
                LOOP
                    IF l_tbl_supply_set(i).exists(j)
                        AND l_tbl_supply_set(i)
                      (j) IS NOT NULL
                        AND (l_tbl_supply_set(i) (j) <> l_current_set OR l_current_set IS NULL)
                    THEN
                        l_current_set := l_tbl_supply_set(i) (j);
                    
                        l_tbl_p_supply(i).extend();
                        l_tbl_p_supply(i)(l_tbl_p_supply(i).count) := l_current_set;
                    
                        l_tbl_p_supply_set(i).extend();
                        l_tbl_p_supply_set(i)(l_tbl_p_supply_set(i).count) := NULL;
                    
                        l_tbl_p_supply_qty(i).extend();
                        l_tbl_p_supply_qty(i)(l_tbl_p_supply_qty(i).count) := NULL;
                    
                        l_tbl_p_dt_return(i).extend();
                        l_tbl_p_dt_return(i)(l_tbl_p_dt_return(i).count) := NULL;
                    
                        l_tbl_p_supply_loc(i).extend();
                        l_tbl_p_supply_loc(i)(l_tbl_p_supply_loc(i).count) := NULL;
                    END IF;
                
                    l_tbl_p_supply(i).extend();
                    l_tbl_p_supply(i)(l_tbl_p_supply(i).count) := CASE
                                                                      WHEN l_tbl_supply(i).exists(j) THEN
                                                                       l_tbl_supply(i) (j)
                                                                      ELSE
                                                                       NULL
                                                                  END;
                
                    l_tbl_p_supply_set(i).extend();
                    l_tbl_p_supply_set(i)(l_tbl_p_supply_set(i).count) := CASE
                                                                              WHEN l_tbl_supply_set(i).exists(j) THEN
                                                                               l_tbl_supply_set(i) (j)
                                                                              ELSE
                                                                               NULL
                                                                          END;
                
                    l_tbl_p_supply_qty(i).extend();
                    l_tbl_p_supply_qty(i)(l_tbl_p_supply_qty(i).count) := CASE
                                                                              WHEN l_tbl_supply_qty(i).exists(j) THEN
                                                                               l_tbl_supply_qty(i) (j)
                                                                              ELSE
                                                                               NULL
                                                                          END;
                
                    l_tbl_p_dt_return(i).extend();
                    l_tbl_p_dt_return(i)(l_tbl_p_dt_return(i).count) := CASE
                                                                            WHEN l_tbl_dt_return(i).exists(j) THEN
                                                                             l_tbl_dt_return(i) (j)
                                                                            ELSE
                                                                             NULL
                                                                        END;
                
                    l_tbl_p_supply_loc(i).extend();
                    l_tbl_p_supply_loc(i)(l_tbl_p_supply_loc(i).count) := CASE
                                                                              WHEN l_tbl_supply_loc(i).exists(j) THEN
                                                                               l_tbl_supply_loc(i) (j)
                                                                              ELSE
                                                                               NULL
                                                                          END;
                END LOOP;
            END LOOP;
        END IF;
    
        g_error := 'ERROR EXTENDING CLINICAL QUESTIONS';
        --Clinical questions
        IF i_clinical_question_pk.count > 0
        THEN
            FOR i IN i_response.first .. i_response.last
            LOOP
                FOR j IN i_response(i).first .. i_response(i).last
                LOOP
                    l_tbl_cq_response.extend;
                    l_tbl_cq_response(l_tbl_cq_response.count) := t_cq_response(response => i_response(i) (j), rn => i);
                END LOOP;
            END LOOP;
        
            FOR i IN i_clinical_question.first .. i_clinical_question.last
            LOOP
                l_tbl_id_task.extend();
                l_tbl_id_task(l_tbl_id_task.count) := pk_orders_utils.get_cq_id(i_lang                   => i_lang,
                                                                                i_prof                   => i_prof,
                                                                                i_clinical_question_info => i_clinical_question(i),
                                                                                i_index                  => 1);
            
                l_tbl_questionnaire.extend();
                l_tbl_questionnaire(l_tbl_questionnaire.count) := pk_orders_utils.get_cq_id(i_lang                   => i_lang,
                                                                                            i_prof                   => i_prof,
                                                                                            i_clinical_question_info => i_clinical_question(i),
                                                                                            i_index                  => 2);
            END LOOP;
        
            SELECT t_rehab_question_response(id_intervention  => t.id_intervention,
                                              id_questionnaire => t.id_questionnaire,
                                              id_response      => CASE
                                                                      WHEN rq.flg_type IS NULL THEN
                                                                       to_number(t.response)
                                                                      ELSE
                                                                       rq.id_response
                                                                  END,
                                              notes            => CASE
                                                                      WHEN rq.flg_type IS NOT NULL THEN
                                                                       t.response
                                                                  END,
                                              rank             => rq.rank)
              BULK COLLECT
              INTO l_tbl_cq
              FROM (SELECT t_questionnaire.id_questionnaire, t_intervention.id_intervention, t_response.response
                      FROM (SELECT /*+opt_estimate (table t rows=1)*/
                             t.column_value AS id_questionnaire, rownum AS rn
                              FROM TABLE(l_tbl_questionnaire) t) t_questionnaire
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            t.column_value AS id_intervention, rownum AS rn
                             FROM TABLE(l_tbl_id_task) t) t_intervention
                        ON t_intervention.rn = t_questionnaire.rn
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            t.response, t.rn
                             FROM TABLE(l_tbl_cq_response) t) t_response
                        ON t_response.rn = t_questionnaire.rn) t
              LEFT JOIN interv_questionnaire rq
                ON rq.id_intervention = t.id_intervention
               AND rq.id_questionnaire = t.id_questionnaire
               AND rq.flg_time = 'O'
               AND rq.flg_available = pk_alert_constant.g_yes
               AND rq.id_institution = i_prof.institution
               AND rq.flg_type IN ('T', 'D');
        
            IF i_flg_update = pk_alert_constant.g_no
            THEN
                FOR i IN i_tbl_data.first .. i_tbl_data.last
                LOOP
                    l_clinical_question.extend();
                    l_response.extend();
                    l_clinical_question_notes.extend();
                
                    SELECT t.id_questionnaire, to_char(t.id_response), t.notes
                      BULK COLLECT
                      INTO l_clinical_question(i), l_response(i), l_clinical_question_notes(i)
                      FROM TABLE(l_tbl_cq) t
                     WHERE t.id_intervention = to_number(i_tbl_data(i) (1));
                
                END LOOP;
            ELSE
                FOR i IN i_tbl_id_pk.first .. i_tbl_id_pk.last
                LOOP
                    l_clinical_question.extend();
                    l_response.extend();
                    l_clinical_question_notes.extend();
                
                    SELECT t.id_questionnaire, t.id_response, t.notes
                      BULK COLLECT
                      INTO l_clinical_question(i), l_response(i), l_clinical_question_notes(i)
                      FROM interv_presc_det ipd
                      JOIN TABLE(l_tbl_cq) t
                        ON t.id_intervention = ipd.id_intervention
                     WHERE ipd.id_interv_presc_det = i_tbl_id_pk(i);
                END LOOP;
            END IF;
        ELSE
            FOR i IN i_tbl_id_pk.first .. i_tbl_id_pk.last
            LOOP
                l_clinical_question.extend();
                l_clinical_question(l_clinical_question.count) := table_number();
            
                l_response.extend();
                l_response(l_response.count) := table_varchar();
            
                l_clinical_question_notes.extend();
                l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar();
            END LOOP;
        END IF;
    
        IF i_flg_update = pk_alert_constant.g_no
        THEN
            RETURN pk_procedures_core.create_procedure_order(i_lang                    => i_lang,
                                                             i_prof                    => i_prof,
                                                             i_patient                 => i_patient,
                                                             i_episode                 => i_episode,
                                                             i_intervention            => l_tbl_intervention,
                                                             i_flg_time                => l_tbl_flg_time,
                                                             i_dt_begin                => l_dt_begin,
                                                             i_episode_destination     => l_tbl_episode_destination, --VER MELHOR
                                                             i_order_recurrence        => l_tbl_order_recurrence,
                                                             i_diagnosis_notes         => l_tbl_diagnosis_notes,
                                                             i_diagnosis               => pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                                                                    i_prof   => i_prof,
                                                                                                                    i_params => l_tbl_diagnosis),
                                                             i_clinical_purpose        => l_tbl_clinical_purpose,
                                                             i_clinical_purpose_notes  => l_tbl_clinical_purpose_notes,
                                                             i_laterality              => l_tbl_laterality,
                                                             i_priority                => l_tbl_priority,
                                                             i_flg_prn                 => l_tbl_flg_prn,
                                                             i_notes_prn               => l_tbl_notes_prn,
                                                             i_exec_institution        => l_tbl_exec_institution,
                                                             i_flg_location            => l_tbl_flg_location,
                                                             i_supply                  => l_tbl_p_supply,
                                                             i_supply_set              => l_tbl_p_supply_set,
                                                             i_supply_qty              => l_tbl_p_supply_qty,
                                                             i_dt_return               => l_tbl_p_dt_return,
                                                             i_supply_loc              => l_tbl_p_supply_loc,
                                                             i_not_order_reason        => l_tbl_not_order_reason,
                                                             i_notes                   => l_tbl_notes,
                                                             i_prof_order              => l_tbl_prof_order,
                                                             i_dt_order                => l_tbl_dt_order,
                                                             i_order_type              => l_tbl_order_type,
                                                             i_codification            => l_tbl_codification,
                                                             i_health_plan             => l_tbl_health_plan,
                                                             i_exemption               => l_tbl_exemption,
                                                             i_clinical_question       => l_clinical_question,
                                                             i_response                => l_response,
                                                             i_clinical_question_notes => l_clinical_question_notes,
                                                             i_clinical_decision_rule  => l_tbl_clinical_decision_rule,
                                                             i_flg_origin_req          => CASE
                                                                                              WHEN i_root_name =
                                                                                                   pk_orders_constant.g_ds_procedure_os_creation THEN
                                                                                               'O'
                                                                                              ELSE
                                                                                               i_flg_origin_req
                                                                                          END,
                                                             i_test                    => i_test,
                                                             o_flg_show                => o_flg_show,
                                                             o_msg_title               => o_msg_title,
                                                             o_msg_req                 => o_msg_req,
                                                             o_interv_presc_array      => o_interv_presc_array,
                                                             o_interv_presc_det_array  => o_interv_presc_det_array,
                                                             o_error                   => o_error);
        ELSE
            IF i_root_name = pk_orders_constant.g_ds_procedure_request
            THEN
                SELECT DISTINCT ipd.id_interv_prescription
                  INTO l_id_interv_prescription
                  FROM interv_presc_det ipd
                 WHERE ipd.id_interv_presc_det IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                    t.*
                                                     FROM TABLE(i_tbl_id_pk) t);
            
                l_tbl_interv_presc_det := i_tbl_id_pk;
            ELSE
                --Note: Order Sets send id_interv_prescription in i_tbl_id_pk
                l_id_interv_prescription := i_tbl_id_pk(1);
            
                SELECT ipd.id_interv_presc_det
                  BULK COLLECT
                  INTO l_tbl_interv_presc_det
                  FROM interv_presc_det ipd
                 WHERE ipd.id_interv_prescription IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                       t.*
                                                        FROM TABLE(i_tbl_id_pk) t);
            END IF;
        
            IF l_tbl_diagnosis.exists(1)
            THEN
                IF l_tbl_diagnosis(1) IS NULL
                THEN
                    l_tbl_diagnosis(l_tbl_diagnosis.count) := '<EPIS_DIAGNOSES ID_PATIENT="' || i_patient ||
                                                              '" ID_EPISODE="' || i_episode || '" 
                PROF_CAT_TYPE="' ||
                                                              pk_prof_utils.get_category(i_lang, i_prof) ||
                                                              '" FLG_TYPE="P" FLG_EDIT_MODE="" ID_CDR_CALL="">
	                    <EPIS_DIAGNOSIS ID_EPIS_DIAGNOSIS="" ID_EPIS_DIAGNOSIS_HIST="" FLG_TRANSF_FINAL="">
		                     <CANCEL_REASON ID_CANCEL_REASON="" FLG_CANCEL_DIFF_DIAG="" />
	                    </EPIS_DIAGNOSIS>
	                 <GENERAL_NOTES ID="" ID_CANCEL_REASON="" />
                </EPIS_DIAGNOSES>';
                END IF;
            END IF;
        
            RETURN pk_procedures_core.update_procedure_order(i_lang                    => i_lang,
                                                             i_prof                    => i_prof,
                                                             i_episode                 => i_episode,
                                                             i_interv_prescription     => l_id_interv_prescription,
                                                             i_interv_presc_det        => l_tbl_interv_presc_det,
                                                             i_flg_time                => l_tbl_flg_time,
                                                             i_dt_begin                => l_dt_begin,
                                                             i_order_recurrence        => l_tbl_order_recurrence,
                                                             i_diagnosis_notes         => l_tbl_diagnosis_notes,
                                                             i_diagnosis               => pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                                                                    i_prof   => i_prof,
                                                                                                                    i_params => l_tbl_diagnosis),
                                                             i_clinical_purpose        => l_tbl_clinical_purpose,
                                                             i_clinical_purpose_notes  => l_tbl_clinical_purpose_notes,
                                                             i_laterality              => l_tbl_laterality,
                                                             i_priority                => l_tbl_priority,
                                                             i_flg_prn                 => l_tbl_flg_prn,
                                                             i_notes_prn               => l_tbl_notes_prn,
                                                             i_exec_institution        => l_tbl_exec_institution,
                                                             i_flg_location            => l_tbl_flg_location,
                                                             i_supply                  => l_tbl_p_supply,
                                                             i_supply_set              => l_tbl_p_supply_set,
                                                             i_supply_qty              => l_tbl_p_supply_qty,
                                                             i_dt_return               => l_tbl_p_dt_return,
                                                             i_not_order_reason        => l_tbl_not_order_reason,
                                                             i_notes                   => l_tbl_notes,
                                                             i_prof_order              => l_tbl_prof_order,
                                                             i_dt_order                => l_tbl_dt_order,
                                                             i_order_type              => l_tbl_order_type,
                                                             i_codification            => l_tbl_codification,
                                                             i_health_plan             => l_tbl_health_plan,
                                                             i_exemption               => l_tbl_exemption,
                                                             i_clinical_question       => l_clinical_question,
                                                             i_response                => l_response,
                                                             i_clinical_question_notes => l_clinical_question_notes,
                                                             o_error                   => o_error);
        END IF;
    EXCEPTION
        WHEN g_user_exception THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     g_error_code,
                                                     NULL,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'CREATE_PROCEDURE_ORDER',
                                                     'U',
                                                     NULL,
                                                     CASE WHEN g_error_code = 'INTERV_M010' THEN
                                                     pk_message.get_message(i_lang, 'COMMON_T006') ELSE '' END,
                                                     NULL,
                                                     o_error);
        
            o_interv_presc_array     := table_number();
            o_interv_presc_det_array := table_number();
        
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_PROCEDURE_ORDER',
                                              o_error);
            RETURN FALSE;
    END create_procedure_order;

    FUNCTION create_procedure_request
    (
        i_lang                    IN language.id_language%TYPE, --1
        i_prof                    IN profissional,
        i_patient                 IN patient.id_patient%TYPE,
        i_episode                 IN episode.id_episode%TYPE,
        i_interv_prescription     IN interv_prescription.id_interv_prescription%TYPE, --5
        i_intervention            IN intervention.id_intervention%TYPE,
        i_flg_time                IN interv_prescription.flg_time%TYPE,
        i_dt_begin                IN VARCHAR2,
        i_episode_destination     IN interv_prescription.id_episode_destination%TYPE,
        i_order_recurrence        IN interv_presc_det.id_order_recurrence%TYPE, --10
        i_diagnosis_notes         IN interv_presc_det.diagnosis_notes%TYPE,
        i_diagnosis               IN pk_edis_types.rec_in_epis_diagnosis,
        i_clinical_purpose        IN interv_presc_det.id_clinical_purpose%TYPE,
        i_clinical_purpose_notes  IN interv_presc_det.clinical_purpose_notes%TYPE,
        i_laterality              IN interv_presc_det.flg_laterality%TYPE, --15
        i_priority                IN interv_presc_det.flg_prty%TYPE,
        i_flg_prn                 IN interv_presc_det.flg_prn%TYPE,
        i_notes_prn               IN interv_presc_det.prn_notes%TYPE,
        i_exec_institution        IN interv_presc_det.id_exec_institution%TYPE,
        i_flg_location            IN interv_presc_det.flg_location%TYPE, --20
        i_supply                  IN table_number,
        i_supply_set              IN table_number,
        i_supply_qty              IN table_number,
        i_dt_return               IN table_varchar,
        i_supply_loc              IN table_number,
        i_not_order_reason        IN not_order_reason.id_not_order_reason%TYPE, --25
        i_notes                   IN interv_presc_det.notes%TYPE,
        i_prof_order              IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_order                IN VARCHAR2,
        i_order_type              IN co_sign.id_order_type%TYPE,
        i_codification            IN codification.id_codification%TYPE, --30
        i_health_plan             IN interv_presc_det.id_pat_health_plan%TYPE,
        i_exemption               IN interv_presc_det.id_pat_exemption%TYPE,
        i_clinical_question       IN table_number,
        i_response                IN table_varchar,
        i_clinical_question_notes IN table_varchar, --35
        i_clinical_decision_rule  IN interv_presc_det.id_cdr_event%TYPE,
        i_flg_origin_req          IN VARCHAR2 DEFAULT 'D', --35        
        o_interv_presc            OUT interv_prescription.id_interv_prescription%TYPE,
        o_interv_presc_det        OUT interv_presc_det.id_interv_presc_det%TYPE,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_interv_presc IS
            SELECT ip.id_interv_prescription
              FROM interv_prescription ip
             WHERE ip.id_interv_prescription = i_interv_prescription;
    
        CURSOR c_room IS
            SELECT ir.id_room
              FROM interv_room ir
             WHERE ir.id_intervention = i_intervention;
    
        TYPE request_movement IS RECORD(
            id_room room.id_room%TYPE,
            id_mov  interv_presc_det.id_movement%TYPE);
    
        TYPE rm IS TABLE OF request_movement INDEX BY BINARY_INTEGER;
        req_mov rm;
        k       NUMBER := 0;
    
        l_next_presc interv_prescription.id_interv_prescription%TYPE;
        l_next_det   interv_presc_det.id_interv_presc_det%TYPE;
        l_next_plan  interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_status      interv_prescription.flg_status%TYPE;
        l_status_det  interv_presc_det.flg_status%TYPE;
        l_status_plan interv_presc_plan.flg_status%TYPE;
    
        l_dt_req   interv_prescription.dt_interv_prescription_tstz%TYPE;
        l_dt_begin interv_presc_det.dt_begin_tstz%TYPE;
    
        l_dt_end         interv_presc_det.dt_end_tstz%TYPE;
        l_dt_begin_presc TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_order_recurr_option order_recurr_option.id_order_recurr_option%TYPE;
    
        l_exec_institution institution.id_institution%TYPE;
    
        l_not_order_reason not_order_reason.id_not_order_reason%TYPE;
    
        l_interv_codification interv_codification.id_interv_codification%TYPE;
        l_dt_entrance_room    VARCHAR2(200 CHAR);
        l_dt_last_interaction VARCHAR2(50 CHAR);
        l_dt_movement         VARCHAR2(50 CHAR);
        l_dt_first_interv     VARCHAR2(50 CHAR);
        l_id_co_sign          co_sign.id_co_sign%TYPE;
        l_id_co_sign_hist     co_sign_hist.id_co_sign_hist%TYPE;
        l_id_mov              movement.id_movement%TYPE;
        l_req_mov             BOOLEAN;
        l_id_room             epis_info.id_room%TYPE;
        l_desc_room           VARCHAR2(1000 CHAR);
        l_new_room            room.id_room%TYPE;
        l_flg_mov_pat         exam_dep_clin_serv.flg_mov_pat%TYPE;
        l_flg_type            episode.id_epis_type%TYPE;
        l_flg_status          episode.flg_status%TYPE;
        l_aux                 table_varchar2;
    
        l_flg_profile     profile_template.flg_profile%TYPE;
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        l_flg_show  VARCHAR2(1 CHAR);
        l_msg_text  VARCHAR2(1000 CHAR);
        l_msg_title VARCHAR2(1000 CHAR);
        l_button    VARCHAR2(6 CHAR);
    
        l_supply_request    supply_request.id_supply_request%TYPE;
        l_supply_dt_request table_varchar := table_varchar();
    
        l_sup_loc          table_number := table_number();
        l_req_reason       table_number := table_number();
        l_notes            table_varchar := table_varchar();
        l_supply_soft_inst table_number := table_number();
        l_flg_cons_type    table_varchar := table_varchar();
    
        l_tbl_supply_workflow table_number;
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        l_dt_req   := g_sysdate_tstz;
        l_dt_begin := pk_date_utils.trunc_insttimezone(i_prof,
                                                       pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_begin, NULL),
                                                       'MI');
    
        l_order_recurr_option := pk_order_recurrence_api_db.get_recurr_order_option(i_lang              => i_lang,
                                                                                    i_prof              => i_prof,
                                                                                    i_order_recurr_plan => i_order_recurrence);
    
        g_error := 'FLG_TIME';
        IF i_flg_time NOT IN (pk_procedures_constant.g_flg_time_e,
                              pk_procedures_constant.g_flg_time_a,
                              pk_procedures_constant.g_flg_time_h)
        THEN
            l_status     := pk_procedures_constant.g_interv_pending;
            l_status_det := pk_procedures_constant.g_interv_pending;
        
            IF i_flg_time = pk_procedures_constant.g_flg_time_b
            THEN
                l_dt_first_interv := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
                l_dt_begin_presc  := l_dt_begin;
            ELSE
                l_dt_first_interv := NULL;
                l_dt_begin_presc  := NULL;
            END IF;
        ELSE
            -- realização neste epis.
            IF i_episode IS NOT NULL
            THEN
                IF pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = pk_procedures_constant.g_no
                THEN
                    IF (pk_date_utils.trunc_insttimezone(i_prof, nvl(l_dt_begin, g_sysdate_tstz), 'DD') !=
                       pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz, 'DD') AND
                       i_flg_time NOT IN (pk_procedures_constant.g_flg_time_a, pk_procedures_constant.g_flg_time_h))
                       OR (l_order_recurr_option NOT IN
                       (pk_order_recurrence_core.g_order_recurr_option_once,
                            pk_order_recurrence_core.g_order_recurr_option_no_sched) AND
                       i_flg_time NOT IN (pk_procedures_constant.g_flg_time_a, pk_procedures_constant.g_flg_time_h))
                    THEN
                        g_error_code := 'INTERV_M010';
                        g_error      := pk_message.get_message(i_lang, i_prof, 'INTERV_M010');
                        RAISE g_user_exception;
                    END IF;
                END IF;
            END IF;
        
            l_dt_first_interv := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
        
            IF nvl(l_dt_begin, g_sysdate_tstz) > g_sysdate_tstz
            THEN
                l_dt_begin_presc := l_dt_begin;
                l_status         := pk_procedures_constant.g_interv_pending;
                l_status_det     := pk_procedures_constant.g_interv_pending;
            ELSE
                l_dt_begin_presc := l_dt_begin;
                l_status         := pk_procedures_constant.g_interv_req;
                l_status_det     := pk_procedures_constant.g_interv_req;
            END IF;
        END IF;
    
        l_exec_institution := CASE
                                  WHEN i_exec_institution = pk_procedures_constant.g_id_location_hhc THEN
                                   i_prof.institution
                                  ELSE
                                   i_exec_institution
                              END;
    
        IF l_exec_institution != i_prof.institution
        THEN
            l_dt_begin_presc := l_dt_begin;
            l_status         := pk_procedures_constant.g_interv_req;
            l_status_det     := pk_procedures_constant.g_interv_exterior;
        END IF;
    
        IF i_flg_prn = pk_procedures_constant.g_yes
        THEN
            l_status     := pk_procedures_constant.g_interv_sos;
            l_status_det := pk_procedures_constant.g_interv_sos;
        END IF;
    
        IF i_flg_origin_req = pk_alert_constant.g_task_origin_order_set
        THEN
            l_status     := pk_procedures_constant.g_interv_predefined;
            l_status_det := pk_procedures_constant.g_interv_predefined;
        ELSIF i_flg_origin_req = pk_alert_constant.g_task_origin_cpoe
        THEN
            l_status     := pk_procedures_constant.g_interv_draft;
            l_status_det := pk_procedures_constant.g_interv_draft;
        
            l_dt_req := NULL;
        END IF;
    
        -- getting not order reason id                                              
        IF i_not_order_reason IS NOT NULL
        THEN
            l_status     := pk_procedures_constant.g_interv_not_ordered;
            l_status_det := pk_procedures_constant.g_interv_not_ordered;
        
            g_error := 'CALL TO PK_NOT_ORDER_REASON_DB.SET_NOT_ORDER_REASON';
            IF NOT pk_not_order_reason_db.set_not_order_reason(i_lang                => i_lang,
                                                               i_prof                => i_prof,
                                                               i_not_order_reason_ea => i_not_order_reason,
                                                               o_id_not_order_reason => l_not_order_reason,
                                                               o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        IF l_dt_begin > l_dt_end
        THEN
            l_dt_begin := l_dt_end;
        END IF;
    
        OPEN c_interv_presc;
        FETCH c_interv_presc
            INTO l_next_presc;
        g_found := c_interv_presc%FOUND;
        CLOSE c_interv_presc;
    
        IF i_interv_prescription IS NOT NULL
        THEN
            l_next_presc   := i_interv_prescription;
            o_interv_presc := i_interv_prescription;
        ELSE
            l_next_presc := ts_interv_prescription.next_key();
        END IF;
    
        IF NOT g_found
        THEN
            g_error := 'INSERT INTERV_PRESCRIPTION';
            ts_interv_prescription.ins(id_interv_prescription_in      => l_next_presc,
                                       id_patient_in                  => i_patient,
                                       id_episode_in                  => CASE
                                                                             WHEN i_flg_time IN
                                                                                  (pk_procedures_constant.g_flg_time_e,
                                                                                   pk_procedures_constant.g_flg_time_a,
                                                                                   pk_procedures_constant.g_flg_time_h) THEN
                                                                              i_episode
                                                                             ELSE
                                                                              NULL
                                                                         END,
                                       id_episode_origin_in           => CASE
                                                                             WHEN i_flg_time IN
                                                                                  (pk_procedures_constant.g_flg_time_e,
                                                                                   pk_procedures_constant.g_flg_time_a,
                                                                                   pk_procedures_constant.g_flg_time_h) THEN
                                                                              NULL
                                                                             ELSE
                                                                              i_episode
                                                                         END,
                                       id_episode_destination_in      => CASE
                                                                             WHEN i_flg_time =
                                                                                  pk_procedures_constant.g_flg_time_n THEN
                                                                              i_episode_destination
                                                                             ELSE
                                                                              NULL
                                                                         END,
                                       id_institution_in              => i_prof.institution,
                                       flg_time_in                    => i_flg_time,
                                       flg_status_in                  => l_status,
                                       id_professional_in             => i_prof.id,
                                       dt_interv_prescription_tstz_in => l_dt_req,
                                       dt_begin_tstz_in               => l_dt_begin_presc,
                                       id_prof_last_update_in         => i_prof.id,
                                       rows_out                       => l_rows_out);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESCRIPTION',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            o_interv_presc := l_next_presc;
        END IF;
    
        IF i_episode IS NOT NULL
        THEN
            g_error := 'CALL TO PK_VISIT.GET_EPIS_INFO';
            IF NOT pk_visit.get_epis_info(i_lang                => i_lang,
                                          i_id_episode          => i_episode,
                                          i_prof                => i_prof,
                                          o_flg_type            => l_flg_type,
                                          o_flg_status          => l_flg_status,
                                          o_id_room             => l_id_room,
                                          o_desc_room           => l_desc_room,
                                          o_dt_entrance_room    => l_dt_entrance_room,
                                          o_dt_last_interaction => l_dt_last_interaction,
                                          o_dt_movement         => l_dt_movement,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'CHECK MOVEMENT';
            IF i_flg_time IN (pk_procedures_constant.g_flg_time_e,
                              pk_procedures_constant.g_flg_time_a,
                              pk_procedures_constant.g_flg_time_h)
               AND l_status = pk_procedures_constant.g_interv_req
            THEN
                BEGIN
                    SELECT nvl(i.flg_mov_pat, pk_procedures_constant.g_yes)
                      INTO l_flg_mov_pat
                      FROM intervention i
                     WHERE i.id_intervention = i_intervention;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_flg_mov_pat := pk_procedures_constant.g_no;
                END;
            
                IF l_flg_mov_pat = pk_procedures_constant.g_yes
                THEN
                    g_error := 'OPEN C_ROOM';
                    OPEN c_room;
                    FETCH c_room
                        INTO l_new_room;
                    g_found := c_room%NOTFOUND;
                    CLOSE c_room;
                
                    IF g_found
                    THEN
                        g_error_code := 'INTERV_M006';
                        g_error      := REPLACE(pk_message.get_message(i_lang, i_prof, 'INTERV_M006'),
                                                '@1',
                                                pk_procedures_utils.get_alias_translation(i_lang,
                                                                                          i_prof,
                                                                                          'INTERVENTION.CODE_INTERVENTION.' ||
                                                                                          i_intervention,
                                                                                          NULL));
                        RAISE g_user_exception;
                    END IF;
                
                    IF l_id_room != l_new_room
                    THEN
                        -- localização actual do doente ñ é a sala de realização do procedimento
                        -- Verificar se já foi requisitado mov para essa sala, nesta mesma requisição
                        -- (se um detalhe já registado tem é realizado na mm sala)
                        l_req_mov := TRUE;
                        l_id_mov  := NULL;
                        IF k != 0
                        THEN
                            FOR j IN 1 .. k
                            LOOP
                                IF req_mov(j).id_room = l_new_room
                                THEN
                                    l_req_mov := FALSE;
                                    l_id_mov  := req_mov(j).id_mov;
                                    EXIT;
                                END IF;
                            END LOOP;
                        END IF;
                    
                        IF l_req_mov
                        THEN
                            g_error := 'CALL TO PK_MOVEMENT.CREATE_MOVEMENT';
                            IF NOT
                                pk_movement.create_movement(i_lang          => i_lang,
                                                            i_episode       => i_episode,
                                                            i_prof          => i_prof,
                                                            i_room          => l_new_room,
                                                            i_necessity     => NULL,
                                                            i_dt_req_str    => pk_date_utils.date_send_tsz(i_lang,
                                                                                                           l_dt_begin,
                                                                                                           i_prof),
                                                            i_prof_cat_type => pk_prof_utils.get_category(i_lang, i_prof),
                                                            o_id_mov        => l_id_mov,
                                                            o_flg_show      => l_flg_show,
                                                            o_msg           => l_msg_text,
                                                            o_msg_title     => l_msg_title,
                                                            o_button        => l_button,
                                                            o_error         => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            g_error := 'CALL TO PK_MOVEMENT.INSERT_MOVEMENT_TASK';
                            IF NOT pk_movement.insert_movement_task(i_lang          => i_lang,
                                                                    i_episode       => i_episode,
                                                                    i_prof          => i_prof,
                                                                    i_prof_cat_type => pk_prof_utils.get_category(i_lang,
                                                                                                                  i_prof),
                                                                    o_error         => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            g_error := 'SET MOV VECTOR';
                            k := k + 1;
                            req_mov(k).id_room := l_new_room;
                            req_mov(k).id_mov := l_id_mov;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        l_next_det := ts_interv_presc_det.next_key(sequence_in => 'SEQ_INTERV_PRESC_DET');
    
        BEGIN
            SELECT ic.id_interv_codification
              INTO l_interv_codification
              FROM interv_codification ic
             WHERE ic.id_codification = i_codification
               AND ic.id_intervention = i_intervention
               AND ic.flg_available = pk_procedures_constant.g_available;
        EXCEPTION
            WHEN no_data_found THEN
                l_interv_codification := NULL;
        END;
    
        IF i_order_type IS NOT NULL
        THEN
            IF l_status = pk_procedures_constant.g_interv_draft
            THEN
                g_error := 'CALL PK_CO_SIGN_API.SET_DRAFT_CO_SIGN_TASK';
                IF NOT pk_co_sign_api.set_draft_co_sign_task(i_lang               => i_lang,
                                                             i_prof               => i_prof,
                                                             i_episode            => i_episode,
                                                             i_id_task_type       => pk_alert_constant.g_task_proc_interv,
                                                             i_id_task            => l_next_det,
                                                             i_id_task_group      => l_next_det,
                                                             i_id_order_type      => i_order_type,
                                                             i_id_prof_created    => i_prof.id,
                                                             i_id_prof_ordered_by => i_prof_order,
                                                             i_dt_created         => g_sysdate_tstz,
                                                             i_dt_ordered_by      => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                   i_prof,
                                                                                                                   i_dt_order,
                                                                                                                   NULL),
                                                             o_id_co_sign         => l_id_co_sign,
                                                             o_id_co_sign_hist    => l_id_co_sign_hist,
                                                             o_error              => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            ELSE
                g_error := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                               i_prof                   => i_prof,
                                                               i_episode                => i_episode,
                                                               i_id_task_type           => pk_alert_constant.g_task_proc_interv,
                                                               i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                               i_id_task                => l_next_det,
                                                               i_id_task_group          => l_next_det,
                                                               i_id_order_type          => i_order_type,
                                                               i_id_prof_created        => i_prof.id,
                                                               i_id_prof_ordered_by     => i_prof_order,
                                                               i_dt_created             => g_sysdate_tstz,
                                                               i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                         i_prof,
                                                                                                                         i_dt_order,
                                                                                                                         NULL),
                                                               o_id_co_sign             => l_id_co_sign,
                                                               o_id_co_sign_hist        => l_id_co_sign_hist,
                                                               o_error                  => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        l_rows_out := NULL;
    
        g_error := 'INSERT INTO INTERV_PRESC_DET';
        ts_interv_presc_det.ins(id_interv_presc_det_in    => l_next_det,
                                id_interv_prescription_in => l_next_presc,
                                id_intervention_in        => i_intervention,
                                flg_status_in             => l_status_det,
                                dt_interv_presc_det_in    => l_dt_req,
                                dt_begin_tstz_in          => l_dt_begin,
                                dt_order_tstz_in          => pk_date_utils.get_string_tstz(i_lang,
                                                                                           i_prof,
                                                                                           i_dt_order,
                                                                                           NULL),
                                id_order_recurrence_in    => i_order_recurrence,
                                flg_prty_in               => i_priority,
                                flg_prn_in                => i_flg_prn,
                                prn_notes_in              => i_notes_prn,
                                id_clinical_purpose_in    => i_clinical_purpose,
                                clinical_purpose_notes_in => i_clinical_purpose_notes,
                                flg_laterality_in         => i_laterality,
                                id_exec_institution_in    => l_exec_institution,
                                id_movement_in            => l_id_mov,
                                notes_in                  => i_notes,
                                id_interv_codification_in => l_interv_codification,
                                id_not_order_reason_in    => l_not_order_reason,
                                id_pat_health_plan_in     => i_health_plan,
                                id_pat_exemption_in       => i_exemption,
                                id_cdr_event_in           => i_clinical_decision_rule,
                                id_co_sign_order_in       => l_id_co_sign_hist,
                                flg_req_origin_module_in  => i_flg_origin_req,
                                id_prof_last_update_in    => i_prof.id,
                                dt_last_update_tstz_in    => g_sysdate_tstz,
                                flg_location_in           => i_flg_location,
                                diagnosis_notes_in        => i_diagnosis_notes,
                                rows_out                  => l_rows_out);
    
        g_error := 'CALL PROCESS_INSERT';
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'INTERV_PRESC_DET',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        o_interv_presc_det := l_next_det;
    
        IF i_episode IS NOT NULL
        THEN
            IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                    i_prof       => i_prof,
                                    i_id_episode => i_episode,
                                    i_flg_status => l_status_det,
                                    i_id_record  => l_next_det,
                                    i_flg_type   => pk_procedures_constant.g_interv_type_req,
                                    o_error      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            IF i_diagnosis.tbl_diagnosis IS NOT NULL
               AND i_diagnosis.tbl_diagnosis.count != 0
            THEN
                g_error := 'CALL TO PK_DIAGNOSIS.SET_MCDT_REQ_DIAG_NO_COMMIT';
                IF NOT pk_diagnosis.set_mcdt_req_diag_no_commit(i_lang             => i_lang,
                                                                i_prof             => i_prof,
                                                                i_epis             => i_episode,
                                                                i_diag             => i_diagnosis,
                                                                i_exam_req         => NULL,
                                                                i_analysis_req     => NULL,
                                                                i_interv_presc     => l_next_presc,
                                                                i_exam_req_det     => NULL,
                                                                i_analysis_req_det => NULL,
                                                                i_interv_presc_det => l_next_det,
                                                                o_error            => o_error)
                THEN
                    IF o_error.err_desc IS NOT NULL
                    THEN
                        g_error_code := o_error.ora_sqlerrm;
                        g_error      := o_error.err_action;
                    
                        RAISE g_user_exception;
                    ELSE
                        g_error_code := o_error.ora_sqlerrm;
                        g_error      := o_error.err_action;
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        IF i_clinical_question.count != 0
        THEN
            FOR i IN 1 .. i_clinical_question.count
            LOOP
                IF i_clinical_question(i) IS NOT NULL
                THEN
                    IF i_response(i) IS NOT NULL
                    THEN
                        l_aux := pk_utils.str_split(i_response(i), '|');
                    
                        FOR j IN 1 .. l_aux.count
                        LOOP
                            g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                            INSERT INTO interv_question_response
                                (id_interv_question_response,
                                 id_episode,
                                 id_interv_presc_det,
                                 flg_time,
                                 id_questionnaire,
                                 id_response,
                                 notes,
                                 id_prof_last_update,
                                 dt_last_update_tstz)
                            VALUES
                                (seq_interv_question_response.nextval,
                                 i_episode,
                                 l_next_det,
                                 pk_procedures_constant.g_interv_cq_on_order,
                                 i_clinical_question(i),
                                 to_number(l_aux(j)),
                                 i_clinical_question_notes(i),
                                 i_prof.id,
                                 g_sysdate_tstz);
                        END LOOP;
                    ELSE
                        g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                        INSERT INTO interv_question_response
                            (id_interv_question_response,
                             id_episode,
                             id_interv_presc_det,
                             flg_time,
                             id_questionnaire,
                             id_response,
                             notes,
                             id_prof_last_update,
                             dt_last_update_tstz)
                        VALUES
                            (seq_interv_question_response.nextval,
                             i_episode,
                             l_next_det,
                             pk_procedures_constant.g_interv_cq_on_order,
                             i_clinical_question(i),
                             NULL,
                             i_clinical_question_notes(i),
                             i_prof.id,
                             g_sysdate_tstz);
                    END IF;
                END IF;
            END LOOP;
        END IF;
    
        IF i_flg_prn = pk_procedures_constant.g_no
           OR i_flg_prn IS NULL
        THEN
            g_error     := 'GET NEXT_KEY';
            l_next_plan := ts_interv_presc_plan.next_key;
        
            l_status_plan := CASE i_flg_time
                                 WHEN pk_procedures_constant.g_flg_time_n THEN
                                  pk_procedures_constant.g_interv_plan_pending
                                 ELSE
                                  CASE sign(extract(DAY FROM(nvl(l_dt_begin, g_sysdate_tstz) - g_sysdate_tstz)))
                                      WHEN 1 THEN
                                       pk_procedures_constant.g_interv_plan_pending
                                      ELSE
                                       pk_procedures_constant.g_interv_plan_req
                                  END
                             END;
        
            l_rows_out := NULL;
        
            g_error := 'INSERT INTERV_PRESC_PLAN';
            ts_interv_presc_plan.ins(id_interv_presc_plan_in => l_next_plan,
                                     id_interv_presc_det_in  => l_next_det,
                                     dt_interv_presc_plan_in => g_sysdate_tstz,
                                     dt_plan_tstz_in         => CASE i_flg_time
                                                                    WHEN pk_procedures_constant.g_flg_time_n THEN
                                                                     NULL
                                                                    ELSE
                                                                     CASE l_order_recurr_option
                                                                         WHEN -2 THEN
                                                                          NULL
                                                                         ELSE
                                                                          nvl(l_dt_begin, g_sysdate_tstz)
                                                                     END
                                                                END,
                                     exec_number_in          => 1,
                                     flg_status_in           => l_status_plan,
                                     rows_out                => l_rows_out);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESC_PLAN',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            IF l_status_det != pk_procedures_constant.g_interv_predefined
            THEN
                g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_NEW';
                pk_ia_event_prescription.procedure_new(i_id_interv_presc_plan => l_next_plan);
            END IF;
        
            IF i_episode IS NOT NULL
            THEN
                IF i_flg_time IN (pk_procedures_constant.g_flg_time_b,
                                  pk_procedures_constant.g_flg_time_e,
                                  pk_procedures_constant.g_flg_time_a,
                                  pk_procedures_constant.g_flg_time_h)
                   AND l_status_det IN (pk_procedures_constant.g_interv_req,
                                        pk_procedures_constant.g_interv_exec,
                                        pk_procedures_constant.g_interv_pending)
                   AND l_status_plan IN
                   (pk_procedures_constant.g_interv_plan_req, pk_procedures_constant.g_interv_plan_pending)
                THEN
                    l_sys_alert_event.id_sys_alert    := 6;
                    l_sys_alert_event.id_software     := i_prof.software;
                    l_sys_alert_event.id_institution  := i_prof.institution;
                    l_sys_alert_event.id_episode      := i_episode;
                    l_sys_alert_event.id_record       := l_next_plan;
                    l_sys_alert_event.dt_record       := nvl(l_dt_begin, g_sysdate_tstz);
                    l_sys_alert_event.id_professional := NULL;
                    l_sys_alert_event.id_room         := NULL;
                    l_sys_alert_event.replace1        := 'INTERVENTION.CODE_INTERVENTION.' || i_intervention;
                
                    g_error := 'INSERT INTO SYS_ALERT_EVENT';
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            i_flg_type_dest   => 'C',
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    IF l_status_det != pk_procedures_constant.g_interv_exec
                    THEN
                        l_sys_alert_event.id_sys_alert := 41;
                    
                        g_error := 'INSERT INTO SYS_ALERT_EVENT';
                        IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                                i_prof            => i_prof,
                                                                i_sys_alert_event => l_sys_alert_event,
                                                                i_flg_type_dest   => 'C',
                                                                o_error           => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    END IF;
                END IF;
            
                IF l_flg_profile = pk_prof_utils.g_flg_profile_template_student
                   AND i_flg_origin_req != pk_alert_constant.g_task_origin_order_set
                THEN
                    l_sys_alert_event.id_sys_alert    := pk_alert_constant.g_alert_cpoe_draft;
                    l_sys_alert_event.id_software     := i_prof.software;
                    l_sys_alert_event.id_institution  := i_prof.institution;
                    l_sys_alert_event.id_episode      := i_episode;
                    l_sys_alert_event.id_patient      := i_patient;
                    l_sys_alert_event.id_record       := i_episode;
                    l_sys_alert_event.id_visit        := pk_visit.get_visit(i_episode => i_episode, o_error => o_error);
                    l_sys_alert_event.dt_record       := g_sysdate_tstz;
                    l_sys_alert_event.id_professional := pk_hand_off.get_episode_responsible(i_lang       => i_lang,
                                                                                             i_prof       => i_prof,
                                                                                             i_id_episode => i_episode,
                                                                                             o_error      => o_error);
                
                    g_error := 'CALL PK_ALERTS.INSERT_SYS_ALERT_EVENT';
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        -- origin E: create_procedure_for_execution
        IF i_episode IS NOT NULL
        THEN
            IF i_flg_origin_req != 'E'
            THEN
                IF i_supply IS NOT NULL
                   AND i_supply.count > 0
                THEN
                    FOR j IN 1 .. i_supply.count
                    LOOP
                        l_supply_dt_request.extend;
                        l_supply_dt_request(j) := i_dt_begin;
                    END LOOP;
                
                    g_error := 'CALL PK_SUPPLIES_API_DB.CREATE_REQUEST';
                    IF NOT pk_supplies_api_db.create_supply_order(i_lang              => i_lang,
                                                             i_prof              => i_prof,
                                                             i_episode           => i_episode,
                                                             i_supply            => i_supply,
                                                             i_supply_set        => i_supply_set,
                                                             i_supply_qty        => i_supply_qty,
                                                             i_dt_request        => l_supply_dt_request,
                                                             i_dt_return         => i_dt_return,
                                                             i_id_context        => l_next_det,
                                                             i_flg_context       => pk_supplies_constant.g_context_procedure_req,
                                                             i_supply_flg_status => CASE
                                                                                        WHEN i_flg_origin_req =
                                                                                             pk_alert_constant.g_task_origin_cpoe THEN
                                                                                         pk_supplies_constant.g_srt_draft
                                                                                        WHEN l_status_det =
                                                                                             pk_procedures_constant.g_interv_draft THEN
                                                                                         pk_supplies_constant.g_srt_draft
                                                                                        ELSE
                                                                                         NULL
                                                                                    END,
                                                             i_supply_loc        => i_supply_loc,
                                                             o_supply_request    => l_supply_request,
                                                             o_error             => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                IF l_status != pk_procedures_constant.g_interv_draft
                   AND i_flg_time != pk_procedures_constant.g_flg_time_n
                THEN
                    g_error := 'CALL PK_CPOE.SYNC_TASK';
                    IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                             i_prof                 => i_prof,
                                             i_episode              => i_episode,
                                             i_task_type            => pk_alert_constant.g_task_type_procedure,
                                             i_task_request         => l_next_det,
                                             i_task_start_timestamp => l_dt_begin,
                                             o_error                => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        
            g_error := to_char('CALL TO PK_VISIT.UPD_EPIS_INFO_INTERV');
            IF NOT pk_visit.upd_epis_info_interv(i_lang                       => i_lang,
                                                 i_id_episode                 => i_episode,
                                                 i_id_prof                    => i_prof,
                                                 i_dt_first_intervention_prsc => l_dt_first_interv,
                                                 i_dt_first_intervention_take => NULL,
                                                 i_prof_cat_type              => pk_prof_utils.get_category(i_lang, i_prof),
                                                 o_error                      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := to_char('CALL TO PK_VISIT.SET_FIRST_OBS');
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_episode,
                                          i_pat                 => i_patient,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        ELSE
            IF i_supply IS NOT NULL
               AND i_supply.count > 0
            THEN
                IF i_supply(1) IS NOT NULL
                THEN
                    FOR i IN 1 .. i_supply.count
                    LOOP
                        l_sup_loc.extend;
                        l_sup_loc(i) := NULL;
                        l_req_reason.extend;
                        l_req_reason(i) := NULL;
                        l_notes.extend;
                        l_notes(i) := NULL;
                        l_supply_soft_inst.extend;
                        l_supply_soft_inst(i) := NULL;
                        l_flg_cons_type.extend;
                        l_flg_cons_type(i) := NULL;
                    END LOOP;
                
                    IF NOT pk_supplies_order_sets.create_predefined_task(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_id_supply_area     => pk_supplies_constant.g_area_supplies,
                                                                         i_supply             => i_supply,
                                                                         i_supply_set         => i_supply_set,
                                                                         i_supply_qty         => i_supply_qty,
                                                                         i_supply_loc         => l_sup_loc,
                                                                         i_id_req_reason      => l_req_reason,
                                                                         i_notes              => l_notes,
                                                                         i_supply_soft_inst   => l_supply_soft_inst,
                                                                         i_flg_cons_type      => l_flg_cons_type,
                                                                         o_id_supply_workflow => l_tbl_supply_workflow,
                                                                         o_error              => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    FOR i IN 1 .. l_tbl_supply_workflow.count
                    LOOP
                    
                        ts_supply_workflow.upd(id_supply_workflow_in => l_tbl_supply_workflow(i),
                                               id_context_in         => l_next_det,
                                               id_context_nin        => FALSE,
                                               flg_context_in        => pk_supplies_constant.g_context_procedure_req,
                                               flg_context_nin       => FALSE,
                                               rows_out              => l_rows_out);
                    
                    END LOOP;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_user_exception THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     g_error_code,
                                                     NULL,
                                                     g_error,
                                                     g_package_owner,
                                                     g_package_name,
                                                     'CREATE_PROCEDURE_REQUEST',
                                                     'U',
                                                     NULL,
                                                     CASE WHEN g_error_code = 'INTERV_M010' THEN
                                                     pk_message.get_message(i_lang, 'COMMON_T006') ELSE '' END,
                                                     NULL,
                                                     o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_PROCEDURE_REQUEST',
                                              o_error);
            RETURN FALSE;
    END create_procedure_request;

    FUNCTION create_procedure_for_execution
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_patient                 IN patient.id_patient%TYPE,
        i_episode                 IN episode.id_episode%TYPE,
        i_intervention            IN table_number,
        i_prof_performed          IN interv_presc_plan.id_prof_performed%TYPE,
        i_start_time              IN VARCHAR2,
        i_end_time                IN VARCHAR2,
        i_dt_next                 IN VARCHAR2,
        i_modifiers               IN table_varchar,
        i_supply_workflow         IN table_number,
        i_supply                  IN table_number,
        i_supply_set              IN table_number,
        i_supply_qty              IN table_number,
        i_supply_type             IN table_varchar,
        i_barcode_scanned         IN table_varchar,
        i_deliver_needed          IN table_varchar,
        i_flg_cons_type           IN table_varchar,
        i_flg_supplies_reg        IN VARCHAR2,
        i_dt_expiration           IN table_varchar,
        i_flg_validation          IN table_varchar,
        i_lot                     IN table_varchar,
        i_notes                   IN epis_interv.notes%TYPE,
        i_doc_template            IN doc_template.id_doc_template%TYPE,
        i_flg_type                IN doc_template_context.flg_type%TYPE,
        i_id_documentation        IN table_number,
        i_id_doc_element          IN table_number,
        i_id_doc_element_crit     IN table_number,
        i_value                   IN table_varchar,
        i_id_doc_element_qualif   IN table_table_number,
        i_vs_element_list         IN table_number,
        i_vs_save_mode_list       IN table_varchar,
        i_vs_list                 IN table_number,
        i_vs_value_list           IN table_number,
        i_vs_uom_list             IN table_number,
        i_vs_scales_list          IN table_number,
        i_vs_date_list            IN table_varchar,
        i_vs_read_list            IN table_number,
        i_clinical_decision_rule  IN cdr_call.id_cdr_call%TYPE,
        i_clinical_question       IN table_table_number,
        i_response                IN table_table_varchar,
        i_clinical_question_notes IN table_table_varchar,
        o_interv_presc_det        OUT table_number,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_presc      interv_prescription.id_interv_prescription%TYPE;
        l_interv_presc_det  interv_presc_det.id_interv_presc_det%TYPE;
        l_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_clinical_question       table_number := table_number();
        l_response                table_varchar := table_varchar();
        l_clinical_question_notes table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        o_interv_presc_det := table_number();
    
        FOR i IN 1 .. i_intervention.count
        LOOP
        
            l_clinical_question := table_number();
            IF i_clinical_question.count > 0
               AND i_clinical_question(i).count > 0
            THEN
                FOR j IN i_clinical_question(i).first .. i_clinical_question(i).last
                LOOP
                    l_clinical_question.extend;
                    l_clinical_question(j) := i_clinical_question(i) (j);
                END LOOP;
            END IF;
        
            l_response := table_varchar();
            IF i_response.count > 0
               AND i_response(i).count > 0
            THEN
                FOR j IN i_response(i).first .. i_response(i).last
                LOOP
                    l_response.extend;
                    l_response(j) := i_response(i) (j);
                END LOOP;
            END IF;
        
            l_clinical_question_notes := table_varchar();
            IF i_clinical_question_notes.count > 0
               AND i_clinical_question_notes(i).count > 0
            THEN
                FOR j IN i_clinical_question_notes(i).first .. i_clinical_question_notes(i).last
                LOOP
                    l_clinical_question_notes.extend;
                    l_clinical_question_notes(j) := i_clinical_question_notes(i) (j);
                END LOOP;
            END IF;
        
            g_error := 'CREATE PROCEDURE REQUEST';
            IF NOT pk_procedures_core.create_procedure_request(i_lang                    => i_lang,
                                                               i_prof                    => i_prof,
                                                               i_patient                 => i_patient,
                                                               i_episode                 => i_episode,
                                                               i_interv_prescription     => l_interv_presc,
                                                               i_intervention            => i_intervention(i),
                                                               i_flg_time                => pk_procedures_constant.g_flg_time_e,
                                                               i_dt_begin                => i_start_time,
                                                               i_episode_destination     => NULL,
                                                               i_order_recurrence        => NULL,
                                                               i_diagnosis_notes         => NULL,
                                                               i_diagnosis               => NULL,
                                                               i_clinical_purpose        => NULL,
                                                               i_clinical_purpose_notes  => NULL,
                                                               i_laterality              => NULL,
                                                               i_priority                => NULL,
                                                               i_flg_prn                 => NULL,
                                                               i_notes_prn               => NULL,
                                                               i_exec_institution        => i_prof.institution,
                                                               i_flg_location            => NULL,
                                                               i_supply                  => NULL,
                                                               i_supply_set              => NULL,
                                                               i_supply_qty              => NULL,
                                                               i_dt_return               => NULL,
                                                               i_supply_loc              => NULL,
                                                               i_not_order_reason        => NULL,
                                                               i_notes                   => NULL,
                                                               i_prof_order              => NULL,
                                                               i_dt_order                => NULL,
                                                               i_order_type              => NULL,
                                                               i_codification            => NULL,
                                                               i_health_plan             => NULL,
                                                               i_exemption               => NULL,
                                                               i_clinical_question       => table_number(NULL),
                                                               i_response                => table_varchar(''),
                                                               i_clinical_question_notes => table_varchar(''),
                                                               i_clinical_decision_rule  => NULL,
                                                               i_flg_origin_req          => 'E',
                                                               o_interv_presc            => l_interv_presc,
                                                               o_interv_presc_det        => l_interv_presc_det,
                                                               o_error                   => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            SELECT ipp.id_interv_presc_plan
              INTO l_interv_presc_plan
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_det = l_interv_presc_det;
        
            g_error := 'CALL PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION';
            IF NOT pk_procedures_core.set_procedure_execution(i_lang                    => i_lang,
                                                              i_prof                    => i_prof,
                                                              i_episode                 => i_episode,
                                                              i_interv_presc_det        => l_interv_presc_det,
                                                              i_interv_presc_plan       => l_interv_presc_plan,
                                                              i_prof_performed          => i_prof_performed,
                                                              i_start_time              => i_start_time,
                                                              i_end_time                => i_end_time,
                                                              i_dt_next                 => i_dt_next,
                                                              i_flg_next_change         => pk_procedures_constant.g_no,
                                                              i_modifiers               => i_modifiers,
                                                              i_supply_workflow         => i_supply_workflow,
                                                              i_supply                  => i_supply,
                                                              i_supply_set              => i_supply_set,
                                                              i_supply_qty              => i_supply_qty,
                                                              i_supply_type             => i_supply_type,
                                                              i_barcode_scanned         => i_barcode_scanned,
                                                              i_deliver_needed          => i_deliver_needed,
                                                              i_flg_cons_type           => i_flg_cons_type,
                                                              i_flg_supplies_reg        => i_flg_supplies_reg,
                                                              i_dt_expiration           => i_dt_expiration,
                                                              i_flg_validation          => i_flg_validation,
                                                              i_lot                     => i_lot,
                                                              i_notes                   => i_notes,
                                                              i_doc_template            => i_doc_template,
                                                              i_flg_type                => i_flg_type,
                                                              i_id_documentation        => i_id_documentation,
                                                              i_id_doc_element          => i_id_doc_element,
                                                              i_id_doc_element_crit     => i_id_doc_element_crit,
                                                              i_value                   => i_value,
                                                              i_id_doc_element_qualif   => i_id_doc_element_qualif,
                                                              i_vs_element_list         => i_vs_element_list,
                                                              i_vs_save_mode_list       => i_vs_save_mode_list,
                                                              i_vs_list                 => i_vs_list,
                                                              i_vs_value_list           => i_vs_value_list,
                                                              i_vs_uom_list             => i_vs_uom_list,
                                                              i_vs_scales_list          => i_vs_scales_list,
                                                              i_vs_date_list            => i_vs_date_list,
                                                              i_vs_read_list            => i_vs_read_list,
                                                              i_clinical_decision_rule  => i_clinical_decision_rule,
                                                              i_clinical_question       => l_clinical_question,
                                                              i_response                => l_response,
                                                              i_clinical_question_notes => l_clinical_question_notes,
                                                              o_error                   => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            ts_interv_presc_det.upd(id_interv_presc_det_in => l_interv_presc_det, flg_req_origin_module_in => 'D');
        
            o_interv_presc_det.extend;
            o_interv_presc_det(o_interv_presc_det.count) := l_interv_presc_det;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_PROCEDURE_FOR_EXECUTION',
                                              o_error);
            RETURN FALSE;
    END create_procedure_for_execution;

    FUNCTION create_procedure_visit
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_patient          IN patient.id_patient%TYPE,
        i_episode          IN episode.id_episode%TYPE,
        i_schedule         IN schedule_intervention.id_schedule%TYPE,
        i_interv_presc_det IN table_number,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_interv_presc(l_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT ip.id_interv_prescription, ipd.id_intervention, ip.flg_time
              FROM interv_presc_det ipd, interv_prescription ip
             WHERE ipd.id_interv_presc_det = l_interv_presc_det
               AND ipd.id_interv_prescription = ip.id_interv_prescription;
    
        l_interv_presc c_interv_presc%ROWTYPE;
    
        l_dt_entrance_room    VARCHAR2(200);
        l_dt_last_interaction VARCHAR2(50);
        l_dt_movement         VARCHAR2(50);
        l_id_room             epis_info.id_room%TYPE;
        l_desc_room           VARCHAR2(200);
    
        l_flg_type   episode.id_epis_type%TYPE;
        l_flg_status episode.flg_status%TYPE;
        l_episode    episode.id_episode%TYPE;
    
        l_rows_out_req table_varchar := table_varchar();
        l_value_ees    epis_ext_sys.value%TYPE;
    
        l_id_epis_ext_sys epis_ext_sys.id_epis_ext_sys%TYPE;
        l_id_interv_presc interv_prescription.id_interv_prescription%TYPE;
        l_id_epis_orig    interv_prescription.id_episode_origin%TYPE;
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF i_episode IS NULL
        THEN
            g_error := 'CALL TO PK_VISIT.CREATE_VISIT';
            IF NOT pk_visit.call_create_visit(i_lang                 => i_lang,
                                              i_id_pat               => i_patient,
                                              i_id_institution       => i_prof.institution,
                                              i_id_sched             => i_schedule,
                                              i_id_professional      => i_prof,
                                              i_id_episode           => i_episode,
                                              i_external_cause       => NULL,
                                              i_health_plan          => NULL,
                                              i_epis_type            => pk_procedures_constant.g_episode_type_interv,
                                              i_dep_clin_serv        => NULL,
                                              i_origin               => NULL,
                                              i_flg_ehr              => pk_procedures_constant.g_no,
                                              i_dt_begin             => g_sysdate_tstz,
                                              i_flg_appointment_type => NULL,
                                              i_transaction_id       => NULL,
                                              i_ext_value            => NULL,
                                              i_id_prof_in_charge    => NULL,
                                              o_episode              => l_episode,
                                              o_error                => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            FOR i IN 1 .. i_interv_presc_det.count
            LOOP
                g_error := 'OPEN C_INTERV_PRESC';
                OPEN c_interv_presc(i_interv_presc_det(i));
                FETCH c_interv_presc
                    INTO l_interv_presc;
                CLOSE c_interv_presc;
            
                g_error := 'CALL TO PK_VISIT.GET_EPIS_INFO';
                IF NOT pk_visit.get_epis_info(i_lang                => i_lang,
                                              i_id_episode          => l_episode,
                                              i_prof                => i_prof,
                                              o_flg_type            => l_flg_type,
                                              o_flg_status          => l_flg_status,
                                              o_id_room             => l_id_room,
                                              o_desc_room           => l_desc_room,
                                              o_dt_entrance_room    => l_dt_entrance_room,
                                              o_dt_last_interaction => l_dt_last_interaction,
                                              o_dt_movement         => l_dt_movement,
                                              o_error               => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                g_error := 'UPDATE INTERV_PRESCRIPTION';
                ts_interv_prescription.upd(id_interv_prescription_in => l_interv_presc.id_interv_prescription,
                                           id_episode_in             => l_episode,
                                           rows_out                  => l_rows_out_req);
            END LOOP;
        
            g_error := 'CALL PROCESS_UPDATE';
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'INTERV_PRESCRIPTION',
                                          i_rowids       => l_rows_out_req,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('ID_EPISODE'));
        
            BEGIN
                SELECT ees.value, ees.id_epis_ext_sys, ip.id_interv_prescription, ip.id_episode_origin
                  INTO l_value_ees, l_id_epis_ext_sys, l_id_interv_presc, l_id_epis_orig
                  FROM interv_prescription ip
                  JOIN epis_ext_sys ees
                    ON ees.id_episode = ip.id_episode_origin
                 WHERE ip.id_episode = l_episode
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_value_ees := NULL;
            END;
        
            IF l_value_ees IS NOT NULL
            THEN
                UPDATE epis_ext_sys ees
                   SET ees.value = l_value_ees
                 WHERE ees.id_episode = l_episode;
            END IF;
        
            g_error := 'CALL TO PK_VISIT.SET_FIRST_OBS';
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => l_episode,
                                          i_pat                 => i_patient,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_PROCEDURE_VISIT',
                                              o_error);
            RETURN FALSE;
    END create_procedure_visit;

    FUNCTION set_procedure_time_out
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_episode               IN episode.id_episode%TYPE,
        i_interv_presc_det      IN interv_presc_plan.id_interv_presc_det%TYPE,
        i_interv_presc_plan     IN interv_presc_plan.id_interv_presc_plan%TYPE,
        i_doc_area              IN doc_area.id_doc_area%TYPE,
        i_doc_template          IN doc_template.id_doc_template%TYPE,
        i_epis_documentation    IN epis_documentation.id_epis_documentation%TYPE,
        i_flg_type              IN VARCHAR2,
        i_id_documentation      IN table_number,
        i_id_doc_element        IN table_number,
        i_id_doc_element_crit   IN table_number,
        i_value                 IN table_varchar,
        i_notes                 IN epis_documentation.notes%TYPE,
        i_id_doc_element_qualif IN table_table_number,
        i_epis_context          IN epis_documentation.id_epis_context%TYPE,
        i_summary_and_notes     IN epis_recomend.desc_epis_recomend_clob%TYPE,
        i_episode_context       IN epis_documentation.id_episode_context%TYPE DEFAULT NULL,
        i_flg_test              IN VARCHAR2,
        o_flg_show              OUT VARCHAR2,
        o_msg_title             OUT sys_message.desc_message%TYPE,
        o_msg_body              OUT pk_types.cursor_type,
        o_epis_documentation    OUT epis_documentation.id_epis_documentation%TYPE,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_msg_body VARCHAR2(4000);
        l_score    PLS_INTEGER;
        l_all_yes  PLS_INTEGER;
    
        FUNCTION insert_procedure_time_out
        (
            i_id_interv_presc_det   IN interv_presc_plan.id_interv_presc_det%TYPE,
            i_id_interv_presc_plan  IN interv_presc_plan.id_interv_presc_plan%TYPE,
            i_id_epis_documentation IN epis_documentation.id_epis_documentation%TYPE
        ) RETURN BOOLEAN IS
        
        BEGIN
            g_error := 'CREATE TIME OUT';
            INSERT INTO interv_time_out
                (id_interv_presc_det, id_interv_presc_plan, id_epis_documentation, flg_complete)
            VALUES
                (i_id_interv_presc_det,
                 i_id_interv_presc_plan,
                 i_id_epis_documentation,
                 decode(l_score, l_all_yes, pk_procedures_constant.g_yes, pk_procedures_constant.g_no));
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                RETURN FALSE;
        END insert_procedure_time_out;
    
    BEGIN
    
        o_flg_show := pk_procedures_constant.g_no;
    
        SELECT SUM(score)
          INTO l_all_yes
          FROM (SELECT DISTINCT d.id_documentation, de.score
                  FROM doc_template dt
                  JOIN doc_template_area_doc dtad
                    ON dtad.id_doc_template = dt.id_doc_template
                  JOIN documentation d
                    ON dtad.id_documentation = d.id_documentation
                  JOIN doc_element de
                    ON d.id_documentation = de.id_documentation
                 WHERE dtad.id_doc_template = pk_sysconfig.get_config('PROCEDURES_TIME_OUT_TEMPLATE', i_prof)
                   AND dtad.id_doc_area = pk_procedures_constant.g_doc_area_intervention
                   AND de.flg_available = pk_alert_constant.g_available
                   AND de.score > 0);
    
        g_error := 'DECODE FLG_SHOW';
        SELECT SUM(de.score)
          INTO l_score
          FROM doc_element de
         WHERE de.id_doc_element IN (SELECT /*+opt_estimate(table t rows=1)*/
                                      t.column_value
                                       FROM TABLE(i_id_doc_element_crit) t)
           AND de.flg_available = pk_alert_constant.g_available
           AND de.score > 0;
    
        IF i_flg_test = pk_procedures_constant.g_no
           OR l_score = l_all_yes
        THEN
            pk_types.open_my_cursor(o_msg_body);
        
            IF NOT pk_touch_option.set_epis_documentation(i_lang                  => i_lang,
                                                          i_prof                  => i_prof,
                                                          i_prof_cat_type         => pk_prof_utils.get_category(i_lang,
                                                                                                                i_prof),
                                                          i_epis                  => i_episode,
                                                          i_doc_area              => i_doc_area,
                                                          i_doc_template          => i_doc_template,
                                                          i_epis_documentation    => i_epis_documentation,
                                                          i_flg_type              => i_flg_type,
                                                          i_id_documentation      => i_id_documentation,
                                                          i_id_doc_element        => i_id_doc_element,
                                                          i_id_doc_element_crit   => i_id_doc_element_crit,
                                                          i_value                 => i_value,
                                                          i_notes                 => i_notes,
                                                          i_id_doc_element_qualif => i_id_doc_element_qualif,
                                                          i_epis_context          => i_epis_context,
                                                          i_summary_and_notes     => i_summary_and_notes,
                                                          i_episode_context       => i_episode_context,
                                                          o_epis_documentation    => o_epis_documentation,
                                                          o_error                 => o_error)
               AND insert_procedure_time_out(i_interv_presc_det, i_interv_presc_plan, o_epis_documentation)
            THEN
                RAISE g_other_exception;
            END IF;
        
        ELSE
            o_flg_show := pk_procedures_constant.g_yes;
        
            g_error := 'GET UNCONFIRMED';
            SELECT concatenate(component || chr(10))
              INTO l_msg_body
              FROM (SELECT pk_translation.get_translation(i_lang, dc.code_doc_component) component
                      FROM doc_element_crit decr
                      JOIN doc_element de
                        ON de.id_doc_element = decr.id_doc_element
                      JOIN documentation d
                        ON d.id_documentation = de.id_documentation
                      JOIN doc_component dc
                        ON dc.id_doc_component = d.id_doc_component
                     WHERE decr.id_doc_element_crit IN
                           (SELECT /*+ opt_estimate(table t rows=5)*/
                             t.column_value
                              FROM TABLE(i_id_doc_element_crit) t)
                     GROUP BY dc.code_doc_component
                    HAVING abs(SUM(de.score)) != 1);
        
            o_msg_title := pk_message.get_message(i_lang, i_prof, 'PROCEDURES_TIMEOUT_T001');
        
            OPEN o_msg_body FOR
                SELECT pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M001') head,
                       pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M002') items_title,
                       substr(l_msg_body, 0, length(l_msg_body) - 1) items,
                       pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M003') foot
                  FROM dual;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_TIME_OUT',
                                              o_error);
            RETURN FALSE;
    END set_procedure_time_out;

    FUNCTION set_procedure_history
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_interv_prescription IN interv_prescription.id_interv_prescription%TYPE,
        i_interv_presc_det    IN table_number,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_diagnosis_list(l_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT mrd.id_mcdt_req_diagnosis
              FROM mcdt_req_diagnosis mrd
             WHERE mrd.id_interv_presc_det = l_interv_presc_det
               AND nvl(mrd.flg_status, '@') != pk_alert_constant.g_cancelled;
    
        CURSOR c_supplies_list(l_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT sw.id_supply_workflow
              FROM supply_workflow sw
             WHERE sw.id_context = l_interv_presc_det
               AND sw.flg_context = pk_supplies_constant.g_context_procedure_req
               AND sw.flg_status != pk_supplies_constant.g_sww_updated;
    
        l_interv_prescription interv_prescription%ROWTYPE;
        l_interv_presc_det    interv_presc_det%ROWTYPE;
    
        l_interv_presc_det_hist interv_presc_det_hist%ROWTYPE;
    
        l_diagnosis_list interv_presc_det_hist.id_diagnosis_list%TYPE;
        l_supplies_list  interv_presc_det_hist.id_supplies_list%TYPE;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        IF i_interv_prescription IS NOT NULL
        THEN
            g_error := 'GET INTERV_PRESCRIPTION';
            SELECT ip.*
              INTO l_interv_prescription
              FROM interv_prescription ip
             WHERE ip.id_interv_prescription = i_interv_prescription;
        END IF;
    
        g_error := 'OPEN LOOP';
        FOR i IN 1 .. i_interv_presc_det.count
        LOOP
            IF i_interv_presc_det(i) IS NOT NULL
            THEN
                g_error := 'GET INTERV_PRESC_DET';
                SELECT ipd.*
                  INTO l_interv_presc_det
                  FROM interv_presc_det ipd
                 WHERE ipd.id_interv_presc_det = i_interv_presc_det(i);
            
                IF l_interv_presc_det.flg_status != pk_procedures_constant.g_interv_predefined
                THEN
                    l_diagnosis_list := NULL;
                    g_error          := 'CREATE DIAGNOSIS LIST';
                    FOR rec IN c_diagnosis_list(i_interv_presc_det(i))
                    LOOP
                        IF l_diagnosis_list IS NULL
                        THEN
                            l_diagnosis_list := rec.id_mcdt_req_diagnosis;
                        ELSE
                            l_diagnosis_list := l_diagnosis_list || ';' || rec.id_mcdt_req_diagnosis;
                        END IF;
                    END LOOP;
                
                    l_supplies_list := NULL;
                    g_error         := 'CREATE SUPPLIES LIST';
                    BEGIN
                        FOR rec IN c_supplies_list(i_interv_presc_det(i))
                        LOOP
                            IF l_supplies_list IS NULL
                            THEN
                                l_supplies_list := rec.id_supply_workflow;
                            ELSE
                                l_supplies_list := l_supplies_list || ';' || rec.id_supply_workflow;
                            END IF;
                        END LOOP;
                    EXCEPTION
                        WHEN OTHERS THEN
                            NULL;
                    END;
                
                    l_interv_presc_det_hist.id_interv_presc_det_hist    := ts_interv_presc_det_hist.next_key;
                    l_interv_presc_det_hist.dt_interv_prescription_hist := g_sysdate_tstz;
                    l_interv_presc_det_hist.id_interv_presc_det         := l_interv_presc_det.id_interv_presc_det;
                    l_interv_presc_det_hist.id_interv_prescription      := l_interv_presc_det.id_interv_prescription;
                    l_interv_presc_det_hist.id_intervention             := l_interv_presc_det.id_intervention;
                    l_interv_presc_det_hist.id_movement                 := l_interv_presc_det.id_movement;
                    l_interv_presc_det_hist.flg_interv_type             := l_interv_presc_det.flg_interv_type;
                    l_interv_presc_det_hist.flg_status                  := l_interv_presc_det.flg_status;
                    l_interv_presc_det_hist.notes                       := l_interv_presc_det.notes;
                    l_interv_presc_det_hist.id_prof_cancel              := l_interv_presc_det.id_prof_cancel;
                    l_interv_presc_det_hist.notes_cancel                := l_interv_presc_det.notes_cancel;
                    l_interv_presc_det_hist.interval                    := l_interv_presc_det.interval;
                    l_interv_presc_det_hist.num_take                    := l_interv_presc_det.num_take;
                    l_interv_presc_det_hist.dosage                      := l_interv_presc_det.dosage;
                    l_interv_presc_det_hist.id_drug_presc_det           := l_interv_presc_det.id_drug_presc_det;
                    l_interv_presc_det_hist.id_nurse_actv_req_det       := l_interv_presc_det.id_nurse_actv_req_det;
                    l_interv_presc_det_hist.num_freq                    := l_interv_presc_det.num_freq;
                    l_interv_presc_det_hist.flg_freq                    := l_interv_presc_det.flg_freq;
                    l_interv_presc_det_hist.num_sess                    := l_interv_presc_det.num_sess;
                    l_interv_presc_det_hist.flg_prty                    := l_interv_presc_det.flg_prty;
                    l_interv_presc_det_hist.dt_end_tstz                 := l_interv_presc_det.dt_end_tstz;
                    l_interv_presc_det_hist.dt_begin_tstz               := l_interv_presc_det.dt_begin_tstz;
                    l_interv_presc_det_hist.dt_cancel_tstz              := l_interv_presc_det.dt_cancel_tstz;
                    l_interv_presc_det_hist.dt_interv_presc_det         := l_interv_presc_det.dt_interv_presc_det;
                    l_interv_presc_det_hist.code_intervention_alias     := l_interv_presc_det.code_intervention_alias;
                    l_interv_presc_det_hist.flg_referral                := l_interv_presc_det.flg_referral;
                    l_interv_presc_det_hist.dt_pend_req_tstz            := l_interv_presc_det.dt_pend_req_tstz;
                    l_interv_presc_det_hist.id_interv_codification      := l_interv_presc_det.id_interv_codification;
                    l_interv_presc_det_hist.id_exec_institution         := l_interv_presc_det.id_exec_institution;
                    l_interv_presc_det_hist.flg_location                := l_interv_presc_det.flg_location;
                    l_interv_presc_det_hist.flg_laterality              := l_interv_presc_det.flg_laterality;
                    l_interv_presc_det_hist.id_clinical_purpose         := l_interv_presc_det.id_clinical_purpose;
                    l_interv_presc_det_hist.clinical_purpose_notes      := l_interv_presc_det.clinical_purpose_notes;
                    l_interv_presc_det_hist.id_presc_plan_task          := l_interv_presc_det.id_presc_plan_task;
                    l_interv_presc_det_hist.id_not_order_reason         := l_interv_presc_det.id_not_order_reason;
                    l_interv_presc_det_hist.id_cdr_event                := l_interv_presc_det.id_cdr_event;
                    l_interv_presc_det_hist.id_co_sign_order            := l_interv_presc_det.id_co_sign_order;
                    l_interv_presc_det_hist.id_cancel_reason            := l_interv_presc_det.id_cancel_reason;
                    l_interv_presc_det_hist.id_co_sign_cancel           := l_interv_presc_det.id_co_sign_cancel;
                    l_interv_presc_det_hist.id_prof_last_update         := l_interv_presc_det.id_prof_last_update;
                    l_interv_presc_det_hist.dt_last_update_tstz         := l_interv_presc_det.dt_last_update_tstz;
                    l_interv_presc_det_hist.id_order_recurrence         := l_interv_presc_det.id_order_recurrence;
                    l_interv_presc_det_hist.flg_fasting                 := l_interv_presc_det.flg_fasting;
                    l_interv_presc_det_hist.flg_prn                     := l_interv_presc_det.flg_prn;
                    l_interv_presc_det_hist.prn_notes                   := l_interv_presc_det.prn_notes;
                    l_interv_presc_det_hist.id_pat_health_plan          := l_interv_presc_det.id_pat_health_plan;
                    l_interv_presc_det_hist.id_pat_exemption            := l_interv_presc_det.id_pat_exemption;
                    l_interv_presc_det_hist.flg_req_origin_module       := l_interv_presc_det.flg_req_origin_module;
                    l_interv_presc_det_hist.dt_order_tstz               := l_interv_presc_det.dt_order_tstz;
                    l_interv_presc_det_hist.id_diagnosis_list           := l_diagnosis_list;
                    l_interv_presc_det_hist.id_supplies_list            := l_supplies_list;
                    l_interv_presc_det_hist.diagnosis_notes             := l_interv_presc_det.diagnosis_notes;
                
                    g_error := 'INSERT INTERV_PRESC_DET_HIST';
                    ts_interv_presc_det_hist.ins(rec_in => l_interv_presc_det_hist);
                END IF;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_HISTORY',
                                              o_error);
            RETURN FALSE;
    END set_procedure_history;

    FUNCTION set_procedure_execution_hist
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_interv_presc_plan      IN interv_presc_plan_hist.id_interv_presc_plan%TYPE,
        o_interv_presc_plan_hist OUT interv_presc_plan_hist.id_interv_presc_plan_hist%TYPE,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_presc_plan interv_presc_plan%ROWTYPE;
    
        l_interv_presc_plan_hist   interv_presc_plan_hist%ROWTYPE;
        l_interv_pp_modifiers_hist interv_pp_modifiers_hist%ROWTYPE;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'GET INTERV_PRESC_PLAN';
        SELECT ipp.*
          INTO l_interv_presc_plan
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_plan = i_interv_presc_plan;
    
        l_interv_presc_plan_hist.id_interv_presc_plan_hist := ts_interv_presc_plan_hist.next_key();
        l_interv_presc_plan_hist.dt_interv_presc_plan_hist := g_sysdate_tstz;
        l_interv_presc_plan_hist.id_interv_presc_plan      := l_interv_presc_plan.id_interv_presc_plan;
        l_interv_presc_plan_hist.id_interv_presc_det       := l_interv_presc_plan.id_interv_presc_det;
        l_interv_presc_plan_hist.id_prof_take              := l_interv_presc_plan.id_prof_take;
        l_interv_presc_plan_hist.notes                     := l_interv_presc_plan.notes;
        l_interv_presc_plan_hist.flg_status                := l_interv_presc_plan.flg_status;
        l_interv_presc_plan_hist.id_prof_cancel            := l_interv_presc_plan.id_prof_cancel;
        l_interv_presc_plan_hist.notes_cancel              := l_interv_presc_plan.notes_cancel;
        l_interv_presc_plan_hist.id_wound_treat            := l_interv_presc_plan.id_wound_treat;
        l_interv_presc_plan_hist.id_episode_write          := l_interv_presc_plan.id_episode_write;
        l_interv_presc_plan_hist.dt_plan_tstz              := l_interv_presc_plan.dt_plan_tstz;
        l_interv_presc_plan_hist.dt_take_tstz              := l_interv_presc_plan.dt_take_tstz;
        l_interv_presc_plan_hist.dt_cancel_tstz            := l_interv_presc_plan.dt_cancel_tstz;
        l_interv_presc_plan_hist.id_prof_performed         := l_interv_presc_plan.id_prof_performed;
        l_interv_presc_plan_hist.start_time                := l_interv_presc_plan.start_time;
        l_interv_presc_plan_hist.end_time                  := l_interv_presc_plan.end_time;
        l_interv_presc_plan_hist.id_schedule_intervention  := l_interv_presc_plan.id_schedule_intervention;
        l_interv_presc_plan_hist.dt_interv_presc_plan      := l_interv_presc_plan.dt_interv_presc_plan;
        l_interv_presc_plan_hist.flg_supplies_reg          := l_interv_presc_plan.flg_supplies_reg;
        l_interv_presc_plan_hist.id_cancel_reason          := l_interv_presc_plan.id_cancel_reason;
        l_interv_presc_plan_hist.id_epis_documentation     := l_interv_presc_plan.id_epis_documentation;
        l_interv_presc_plan_hist.id_cdr_event              := l_interv_presc_plan.id_cdr_event;
        l_interv_presc_plan_hist.exec_number               := l_interv_presc_plan.exec_number;
        l_interv_presc_plan_hist.id_prof_last_update       := l_interv_presc_plan.id_prof_last_update;
        l_interv_presc_plan_hist.dt_last_update_tstz       := l_interv_presc_plan.dt_last_update_tstz;
    
        g_error := 'INSERT INTERV_PRESC_PLAN_HIST';
        ts_interv_presc_plan_hist.ins(rec_in => l_interv_presc_plan_hist);
    
        g_error := 'GET INTERV_PRESC_PLAN';
        FOR l_interv_pp_modifiers IN (SELECT ippm.*
                                        FROM interv_pp_modifiers ippm
                                       WHERE ippm.id_interv_presc_plan = i_interv_presc_plan)
        LOOP
        
            l_interv_pp_modifiers_hist.dt_interv_pp_modifiers_hist := g_sysdate_tstz;
            l_interv_pp_modifiers_hist.id_interv_presc_plan_hist   := l_interv_presc_plan_hist.id_interv_presc_plan_hist;
            l_interv_pp_modifiers_hist.id_modifier                 := l_interv_pp_modifiers.id_modifier;
            l_interv_pp_modifiers_hist.id_inst_owner               := l_interv_pp_modifiers.id_inst_owner;
            l_interv_pp_modifiers_hist.id_prof_last_update         := l_interv_pp_modifiers.id_prof_last_update;
            l_interv_pp_modifiers_hist.dt_last_update_tstz         := l_interv_pp_modifiers.dt_last_update_tstz;
        
            g_error := 'INSERT INTERV_PP_MODIFIERS_HIST';
            ts_interv_pp_modifiers_hist.ins(rec_in => l_interv_pp_modifiers_hist);
        END LOOP;
    
        o_interv_presc_plan_hist := l_interv_presc_plan_hist.id_interv_presc_plan_hist;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_EXECUTION_HIST',
                                              o_error);
            RETURN FALSE;
    END set_procedure_execution_hist;

    FUNCTION set_procedure_execution
    (
        i_lang                    IN language.id_language%TYPE, --1
        i_prof                    IN profissional,
        i_episode                 IN episode.id_episode%TYPE,
        i_interv_presc_det        IN interv_presc_det.id_interv_presc_det%TYPE,
        i_interv_presc_plan       IN interv_presc_plan.id_interv_presc_plan%TYPE, --5
        i_prof_performed          IN interv_presc_plan.id_prof_performed%TYPE,
        i_start_time              IN VARCHAR2,
        i_end_time                IN VARCHAR2,
        i_dt_next                 IN VARCHAR2,
        i_flg_next_change         IN VARCHAR2, --10
        i_modifiers               IN table_varchar,
        i_supply_workflow         IN table_number,
        i_supply                  IN table_number,
        i_supply_set              IN table_number,
        i_supply_qty              IN table_number, --15
        i_supply_type             IN table_varchar,
        i_barcode_scanned         IN table_varchar,
        i_deliver_needed          IN table_varchar,
        i_flg_cons_type           IN table_varchar,
        i_flg_supplies_reg        IN VARCHAR2, --20
        i_dt_expiration           IN table_varchar,
        i_flg_validation          IN table_varchar,
        i_lot                     IN table_varchar,
        i_notes                   IN epis_interv.notes%TYPE,
        i_doc_template            IN doc_template.id_doc_template%TYPE, --25
        i_flg_type                IN doc_template_context.flg_type%TYPE,
        i_id_documentation        IN table_number,
        i_id_doc_element          IN table_number,
        i_id_doc_element_crit     IN table_number,
        i_value                   IN table_varchar, --30
        i_id_doc_element_qualif   IN table_table_number,
        i_vs_element_list         IN table_number,
        i_vs_save_mode_list       IN table_varchar,
        i_vs_list                 IN table_number,
        i_vs_value_list           IN table_number, --35
        i_vs_uom_list             IN table_number,
        i_vs_scales_list          IN table_number,
        i_vs_date_list            IN table_varchar,
        i_vs_read_list            IN table_number,
        i_clinical_decision_rule  IN cdr_call.id_cdr_call%TYPE, --40
        i_clinical_question       IN table_number,
        i_response                IN table_varchar,
        i_clinical_question_notes IN table_varchar,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_presc_det interv_presc_det%ROWTYPE;
        l_id_patient       patient.id_patient%TYPE;
    
        l_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_is_edit     NUMBER := 0;
        l_exec_number NUMBER := 1;
    
        l_flg_recurr_control order_recurr_control.flg_status%TYPE;
        l_plan_start_date    order_recurr_plan.start_date%TYPE;
        l_finish_recurr      VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
    
        l_epis_documentation epis_documentation.id_epis_documentation%TYPE;
        l_id_documentation   table_number := table_number();
    
        l_aux table_varchar2;
    
        l_modifier   interv_pp_modifiers.id_modifier%TYPE;
        l_inst_owner interv_pp_modifiers.id_inst_owner%TYPE;
    
        l_id_supply_request   supply_request.id_supply_request%TYPE;
        l_id_supply_soft_inst table_number := table_number();
        l_id_supply           table_number := table_number();
        l_id_supply_set       table_number := table_number();
        l_quantity            table_number := table_number();
        l_has_supplies        VARCHAR2(1 CHAR);
        l_id_supply_plan      table_number := table_number();
        l_id_supply_workflow  table_number := table_number();
        l_id_supply_del       table_number := table_number();
        l_id_supply_upd       table_number := table_number();
        l_id_supply_ins       table_number := table_number();
    
        l_empty_array_number  table_number := table_number();
        l_empty_array_varchar table_varchar := table_varchar();
    
        l_rows_out table_varchar;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        l_id_patient := pk_episode.get_id_patient(i_episode => i_episode);
    
        SELECT ipd.*
          INTO l_interv_presc_det
          FROM interv_presc_det ipd
         WHERE ipd.id_interv_presc_det = i_interv_presc_det;
    
        SELECT COUNT(*)
          INTO l_is_edit
          FROM interv_presc_plan
         WHERE id_interv_presc_plan = i_interv_presc_plan
           AND flg_status = pk_procedures_constant.g_interv_plan_executed;
    
        l_id_documentation := nvl(i_id_documentation, table_number());
    
        IF nvl(l_id_documentation.count, 0) > 0
           OR
           (nvl(l_id_documentation.count, 0) = 0 AND i_notes IS NOT NULL AND dbms_lob.getlength(i_notes) > 0 /*AND i_doc_template IS NOT NULL*/)
        THEN
            g_error := 'CALL PK_TOUCH_OPTION.SET_EPIS_DOCUMENTATION';
            IF NOT pk_touch_option.set_epis_document_internal(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_prof_cat_type         => pk_prof_utils.get_category(i_lang,
                                                                                                                    i_prof),
                                                              i_epis                  => i_episode,
                                                              i_doc_area              => pk_procedures_constant.g_doc_area_intervention,
                                                              i_doc_template          => i_doc_template,
                                                              i_epis_documentation    => NULL,
                                                              i_flg_type              => i_flg_type,
                                                              i_id_documentation      => l_id_documentation,
                                                              i_id_doc_element        => i_id_doc_element,
                                                              i_id_doc_element_crit   => i_id_doc_element_crit,
                                                              i_value                 => i_value,
                                                              i_notes                 => i_notes,
                                                              i_id_epis_complaint     => NULL,
                                                              i_id_doc_element_qualif => i_id_doc_element_qualif,
                                                              i_epis_context          => i_interv_presc_plan,
                                                              i_vs_element_list       => i_vs_element_list,
                                                              i_vs_save_mode_list     => i_vs_save_mode_list,
                                                              i_vs_list               => i_vs_list,
                                                              i_vs_value_list         => i_vs_value_list,
                                                              i_vs_uom_list           => i_vs_uom_list,
                                                              i_vs_scales_list        => i_vs_scales_list,
                                                              i_vs_date_list          => i_vs_date_list,
                                                              i_vs_read_list          => i_vs_read_list,
                                                              o_epis_documentation    => l_epis_documentation,
                                                              o_error                 => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        g_error := 'CALL PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION';
        IF NOT pk_procedures_core.set_procedure_execution(i_lang                    => i_lang,
                                                     i_prof                    => i_prof,
                                                     i_episode                 => i_episode,
                                                     i_interv_presc_det        => i_interv_presc_det,
                                                     i_interv_presc_plan       => i_interv_presc_plan,
                                                     i_dt_next                 => i_dt_next,
                                                     i_prof_performed          => i_prof_performed,
                                                     i_start_time              => i_start_time,
                                                     i_end_time                => i_end_time,
                                                     i_flg_supplies            => i_flg_supplies_reg,
                                                     i_notes                   => CASE
                                                                                      WHEN l_epis_documentation IS NULL THEN
                                                                                       i_notes
                                                                                      ELSE
                                                                                       NULL
                                                                                  END,
                                                     i_epis_documentation      => l_epis_documentation,
                                                     i_clinical_decision_rule  => i_clinical_decision_rule,
                                                     i_clinical_question       => i_clinical_question,
                                                     i_response                => i_response,
                                                     i_clinical_question_notes => i_clinical_question_notes,
                                                     o_interv_presc_plan       => l_interv_presc_plan,
                                                     o_error                   => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        IF i_modifiers.count > 0
           AND i_modifiers IS NOT NULL
        THEN
            ts_interv_pp_modifiers.del_by(where_clause_in => 'id_interv_presc_plan = ' || i_interv_presc_plan);
        
            FOR i IN 1 .. i_modifiers.count
            LOOP
                l_aux := pk_utils.str_split(i_modifiers(i), '|');
            
                FOR j IN 1 .. l_aux.count
                LOOP
                    IF j = 1
                    THEN
                        l_modifier := l_aux(j);
                    ELSIF j = 2
                    THEN
                        l_inst_owner := l_aux(j);
                    END IF;
                END LOOP;
            
                g_error := 'INSERT INTERV_PP_MODIFIERS';
                ts_interv_pp_modifiers.ins(id_interv_presc_plan_in => i_interv_presc_plan,
                                           id_modifier_in          => l_modifier,
                                           id_inst_owner_in        => l_inst_owner,
                                           id_prof_last_update_in  => i_prof.id,
                                           dt_last_update_tstz_in  => g_sysdate_tstz);
            END LOOP;
        END IF;
    
        -- Controlo dos materiais para a edição uma execução de um procedimento
        IF l_interv_presc_det.flg_status IN
           (pk_procedures_constant.g_interv_finished, pk_procedures_constant.g_interv_exec)
        THEN
            IF i_supply IS NOT NULL
               AND i_supply.count > 0
            THEN
                -- Retorna os materiais consumidos para o i_interv_presc_plan não cancelados
                g_error := 'CALL PK_SUPPLIES_EXTERNAL_API_DB.GET_INF_SUPPLY_WORKFLOW';
                IF NOT pk_supplies_external_api_db.get_inf_supply_workflow(i_lang               => i_lang,
                                                                           i_prof               => i_prof,
                                                                           i_id_context         => i_interv_presc_plan,
                                                                           i_flg_context        => pk_supplies_constant.g_context_procedure_exec,
                                                                           i_id_supply          => l_empty_array_number,
                                                                           i_flg_status         => pk_supplies_constant.g_flg_status_can_cancel,
                                                                           o_has_supplies       => l_has_supplies,
                                                                           o_id_supply_workflow => l_id_supply_workflow,
                                                                           o_id_supply          => l_id_supply_plan,
                                                                           o_error              => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_has_supplies = pk_procedures_constant.g_yes
                THEN
                    -- Verifica quais os materiais que pretende retirar e só no caso de estes já existirem na i_interv_presc_plan os cancela                            
                    IF nvl(i_supply_workflow.count, 0) > 0
                       AND i_supply(1) IS NOT NULL
                    THEN
                        l_id_supply_del := l_id_supply_plan MULTISET except i_supply;
                    ELSE
                        l_id_supply_del := l_id_supply_plan;
                    END IF;
                
                    IF l_id_supply_del IS NOT NULL
                       AND l_id_supply_del.count > 0
                    THEN
                        FOR i IN 1 .. l_id_supply_del.count
                        LOOP
                            FOR j IN 1 .. l_id_supply_plan.count
                            LOOP
                                IF l_id_supply_del(i) = l_id_supply_plan(j)
                                THEN
                                    g_error := 'CALL PK_SUPPLIES_API_DB.CANCEL_SUPPLY_ORDER';
                                    IF NOT pk_supplies_api_db.cancel_supply_order(i_lang             => i_lang,
                                                                                  i_prof             => i_prof,
                                                                                  i_supplies         => table_number(l_id_supply_workflow(j)),
                                                                                  i_id_prof_cancel   => i_prof.id,
                                                                                  i_cancel_notes     => NULL,
                                                                                  i_id_cancel_reason => NULL,
                                                                                  i_dt_cancel        => g_sysdate_tstz,
                                                                                  o_error            => o_error)
                                    THEN
                                        RAISE g_other_exception;
                                    END IF;
                                
                                    -- Altera o id_context=id_interv_presc_plan dos materiais consumidos já existentes para o id_interv_presc_plan_hist    
                                    g_error := 'CALL PK_SUPPLIES_API_DB.SET_SUPPLY_WORKFLOW_HIST';
                                    pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(j),
                                                                                i_id_context         => l_interv_presc_plan,
                                                                                i_flg_context        => pk_supplies_constant.g_context_procedure_exec);
                                END IF;
                            END LOOP;
                        END LOOP;
                    END IF;
                END IF;
            
                -- Verifica quais os materiais que pretende adicionar e só no caso de estes não existirem na i_interv_presc_plan os adiciona
                IF nvl(i_supply_workflow.count, 0) > 0
                   AND i_supply(1) IS NOT NULL
                THEN
                    l_empty_array_varchar.extend(i_supply_workflow.count);
                
                    SELECT t.column_value
                      BULK COLLECT
                      INTO l_id_supply_upd
                      FROM TABLE(i_supply) t
                      JOIN TABLE(l_id_supply_plan) tt
                        ON tt.column_value = t.column_value;
                
                    SELECT t.column_value
                      BULK COLLECT
                      INTO l_id_supply_ins
                      FROM TABLE(i_supply) t
                      LEFT JOIN TABLE(l_id_supply_plan) tt
                        ON tt.column_value = t.column_value
                     WHERE tt.column_value IS NULL;
                
                    IF l_id_supply_upd IS NOT NULL
                       AND l_id_supply_upd.count > 0
                    THEN
                        FOR i IN 1 .. l_id_supply_upd.count
                        LOOP
                            FOR j IN 1 .. l_id_supply_plan.count
                            LOOP
                                IF l_id_supply_upd(i) = l_id_supply_plan(j)
                                THEN
                                    g_error := 'CALL PK_SUPPLIES_API_DB.CANCEL_SUPPLY_ORDER';
                                    IF NOT pk_supplies_api_db.update_supply_order(i_lang            => i_lang,
                                                                                  i_prof            => i_prof,
                                                                                  i_id_episode      => i_episode,
                                                                                  i_supply_workflow => table_number(i_supply_workflow(j)),
                                                                                  i_supply          => table_number(i_supply(j)),
                                                                                  i_supply_set      => table_number(i_supply_set(j)),
                                                                                  i_supply_qty      => table_number(i_supply_qty(j)),
                                                                                  i_supply_loc      => table_number(NULL),
                                                                                  i_dt_request      => table_varchar(NULL),
                                                                                  i_dt_return       => table_varchar(NULL),
                                                                                  i_id_req_reason   => table_number(NULL),
                                                                                  i_flg_reason_req  => NULL,
                                                                                  i_id_context      => i_interv_presc_plan,
                                                                                  i_flg_context     => pk_supplies_constant.g_context_procedure_exec,
                                                                                  i_notes           => table_varchar(NULL),
                                                                                  o_error           => o_error)
                                    THEN
                                        RAISE g_other_exception;
                                    END IF;
                                END IF;
                            END LOOP;
                        END LOOP;
                    END IF;
                
                    IF l_id_supply_ins IS NOT NULL
                       AND l_id_supply_ins.count > 0
                    THEN
                        FOR i IN 1 .. l_id_supply_ins.count
                        LOOP
                            FOR j IN 1 .. i_supply.count
                            LOOP
                                IF l_id_supply_ins(i) = i_supply(j)
                                THEN
                                    g_error := 'CALL PK_SUPPLIES_API_DB.SET_SUPPLY_CONSUMPTION';
                                    IF NOT pk_supplies_api_db.set_supply_consumption(i_lang               => i_lang,
                                                                                     i_prof               => i_prof,
                                                                                     i_id_episode         => i_episode,
                                                                                     i_id_context         => i_interv_presc_plan,
                                                                                     i_flg_context        => pk_supplies_constant.g_context_procedure_exec,
                                                                                     i_id_supply_workflow => table_number(i_supply_workflow(j)),
                                                                                     i_supply             => table_number(i_supply(j)),
                                                                                     i_supply_set         => table_number(i_supply_set(j)),
                                                                                     i_supply_qty         => table_number(i_supply_qty(j)),
                                                                                     i_flg_supply_type    => table_varchar(i_supply_type(j)),
                                                                                     i_barcode_scanned    => table_varchar(i_barcode_scanned(j)),
                                                                                     i_fixed_asset_number => NULL,
                                                                                     i_deliver_needed     => table_varchar(i_deliver_needed(j)),
                                                                                     i_flg_cons_type      => table_varchar(i_flg_cons_type(j)),
                                                                                     i_notes              => table_varchar(NULL),
                                                                                     i_dt_expected_date   => NULL,
                                                                                     i_check_quantities   => pk_alert_constant.g_no,
                                                                                     i_dt_expiration      => table_varchar(i_dt_expiration(j)),
                                                                                     i_flg_validation     => table_varchar(i_flg_validation(j)),
                                                                                     i_lot                => table_varchar(i_lot(j)),
                                                                                     o_error              => o_error)
                                    THEN
                                        RAISE g_other_exception;
                                    END IF;
                                END IF;
                            END LOOP;
                        END LOOP;
                    END IF;
                END IF;
            
                -- Insere no histórico dos materiais consumidos já existentes com id_context = id_interv_presc_plan_hist   
                FOR k IN 1 .. l_id_supply_workflow.count
                LOOP
                    g_error := 'CALL PK_SUPPLIES_API_DB.SET_SUPPLY_WORKFLOW_HIST';
                    pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(k),
                                                                i_id_context         => l_interv_presc_plan,
                                                                i_flg_context        => pk_supplies_constant.g_context_procedure_exec);
                END LOOP;
            ELSE
                -- Retorna os materiais consumidos para o i_interv_presc_plan não cancelados
                g_error := 'CALL PK_SUPPLIES_EXTERNAL_API_DB.GET_INF_SUPPLY_WORKFLOW';
                IF NOT pk_supplies_external_api_db.get_inf_supply_workflow(i_lang               => i_lang,
                                                                           i_prof               => i_prof,
                                                                           i_id_context         => i_interv_presc_plan,
                                                                           i_flg_context        => pk_supplies_constant.g_context_procedure_exec,
                                                                           i_id_supply          => l_empty_array_number,
                                                                           i_flg_status         => pk_supplies_constant.g_flg_status_can_cancel,
                                                                           o_has_supplies       => l_has_supplies,
                                                                           o_id_supply_workflow => l_id_supply_workflow,
                                                                           o_id_supply          => l_id_supply_plan,
                                                                           o_error              => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_has_supplies = pk_procedures_constant.g_yes
                THEN
                    -- Verifica quais os materiais que pretende retirar e só no caso de estes já existirem na i_interv_presc_plan os cancela                            
                    IF nvl(i_supply_workflow.count, 0) > 0
                       AND i_supply(1) IS NOT NULL
                    THEN
                        l_id_supply_del := l_id_supply_plan MULTISET except i_supply;
                    ELSE
                        l_id_supply_del := l_id_supply_plan;
                    END IF;
                
                    IF l_id_supply_del IS NOT NULL
                       AND l_id_supply_del.count > 0
                    THEN
                        FOR i IN 1 .. l_id_supply_del.count
                        LOOP
                            FOR j IN 1 .. l_id_supply_plan.count
                            LOOP
                                IF l_id_supply_del(i) = l_id_supply_plan(j)
                                THEN
                                    g_error := 'CALL PK_SUPPLIES_API_DB.CANCEL_SUPPLY_ORDER';
                                    IF NOT pk_supplies_api_db.cancel_supply_order(i_lang             => i_lang,
                                                                                  i_prof             => i_prof,
                                                                                  i_supplies         => table_number(l_id_supply_workflow(j)),
                                                                                  i_id_prof_cancel   => i_prof.id,
                                                                                  i_cancel_notes     => NULL,
                                                                                  i_id_cancel_reason => NULL,
                                                                                  i_dt_cancel        => g_sysdate_tstz,
                                                                                  o_error            => o_error)
                                    THEN
                                        RAISE g_other_exception;
                                    END IF;
                                
                                    -- Altera o id_context=id_interv_presc_plan dos materiais consumidos já existentes para o id_interv_presc_plan_hist    
                                    g_error := 'CALL PK_SUPPLIES_API_DB.SET_SUPPLY_WORKFLOW_HIST';
                                    pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(j),
                                                                                i_id_context         => l_interv_presc_plan,
                                                                                i_flg_context        => pk_supplies_constant.g_context_procedure_exec);
                                END IF;
                            END LOOP;
                        END LOOP;
                    END IF;
                END IF;
            END IF;
        ELSE
        
            -- Controlo dos materiais para a execução de uma toma planeada 
            IF nvl(i_supply_workflow.count, 0) > 0
               AND i_supply(1) IS NOT NULL
            THEN
                l_empty_array_varchar.extend(i_supply_workflow.count);
            
                g_error := 'CALL PK_SUPPLIES_API_DB.SET_SUPPLY_CONSUMPTION';
                IF NOT pk_supplies_api_db.set_supply_consumption(i_lang               => i_lang,
                                                                 i_prof               => i_prof,
                                                                 i_id_episode         => i_episode,
                                                                 i_id_context         => CASE l_interv_presc_det.flg_prn
                                                                                             WHEN pk_procedures_constant.g_yes THEN
                                                                                              l_interv_presc_plan
                                                                                             ELSE
                                                                                              i_interv_presc_plan
                                                                                         END,
                                                                 i_flg_context        => pk_supplies_constant.g_context_procedure_exec,
                                                                 i_id_supply_workflow => i_supply_workflow,
                                                                 i_supply             => i_supply,
                                                                 i_supply_set         => i_supply_set,
                                                                 i_supply_qty         => i_supply_qty,
                                                                 i_flg_supply_type    => i_supply_type,
                                                                 i_barcode_scanned    => i_barcode_scanned,
                                                                 i_fixed_asset_number => NULL,
                                                                 i_deliver_needed     => i_deliver_needed,
                                                                 i_flg_cons_type      => i_flg_cons_type,
                                                                 i_notes              => l_empty_array_varchar,
                                                                 i_dt_expected_date   => NULL,
                                                                 i_check_quantities   => pk_alert_constant.g_no,
                                                                 i_dt_expiration      => i_dt_expiration,
                                                                 i_flg_validation     => i_flg_validation,
                                                                 i_lot                => i_lot,
                                                                 o_error              => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        
            IF i_interv_presc_det IS NOT NULL
               AND l_interv_presc_plan IS NOT NULL
               AND i_supply IS NOT NULL
            THEN
                BEGIN
                    SELECT sw.id_supply, sw.id_supply_set, sw.quantity, ssi.id_supply_soft_inst
                      BULK COLLECT
                      INTO l_id_supply, l_id_supply_set, l_quantity, l_id_supply_soft_inst
                      FROM supply_request sr, supply_soft_inst ssi, supply_workflow sw
                     WHERE sw.id_supply_request = sr.id_supply_request
                       AND ssi.id_supply = sw.id_supply
                       AND sr.id_context = i_interv_presc_det
                       AND ssi.id_institution = i_prof.institution
                       AND (ssi.id_software = i_prof.software OR ssi.id_software = 0)
                       AND ssi.flg_cons_type IN (SELECT /*+ opt_estimate(table t rows=1)*/
                                                  *
                                                   FROM TABLE(i_flg_cons_type) t)
                       AND sr.id_supply_request = (SELECT MIN(srq.id_supply_request)
                                                     FROM supply_request srq
                                                    WHERE srq.id_context = i_interv_presc_det);
                
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_supply_soft_inst := l_empty_array_number;
                END;
            
                IF l_id_supply.count > 0
                THEN
                    l_empty_array_number.extend(l_id_supply.count);
                    l_empty_array_varchar.extend(l_id_supply.count);
                
                    g_error := 'CALL PK_SUPPLIES_API_DB.CREATE_REQUEST';
                    IF NOT pk_supplies_api_db.create_request(i_lang              => i_lang,
                                                             i_prof              => i_prof,
                                                             i_id_supply_area    => pk_supplies_constant.g_area_supplies,
                                                             i_id_episode        => i_episode,
                                                             i_supply            => l_id_supply,
                                                             i_supply_set        => l_id_supply_set,
                                                             i_supply_qty        => l_quantity,
                                                             i_supply_loc        => l_empty_array_number,
                                                             i_dt_request        => l_empty_array_varchar,
                                                             i_dt_return         => l_empty_array_varchar,
                                                             i_id_req_reason     => l_empty_array_number,
                                                             i_flg_reason_req    => NULL,
                                                             i_id_context        => i_interv_presc_det,
                                                             i_flg_context       => pk_supplies_constant.g_context_procedure_req,
                                                             i_notes             => l_empty_array_varchar,
                                                             i_flg_cons_type     => NULL,
                                                             i_flg_reusable      => NULL,
                                                             i_flg_editable      => NULL,
                                                             i_flg_preparing     => NULL,
                                                             i_flg_countable     => NULL,
                                                             i_supply_soft_inst  => l_id_supply_soft_inst,
                                                             i_supply_flg_status => pk_supplies_constant.g_srt_requested,
                                                             i_id_inst_dest      => NULL,
                                                             o_id_supply_request => l_id_supply_request,
                                                             o_error             => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.GET_NEXT_EXECUTION';
        IF NOT pk_order_recurrence_api_db.get_next_execution(i_lang                => i_lang,
                                                             i_prof                => i_prof,
                                                             i_is_edit             => l_is_edit,
                                                             i_to_execute          => pk_procedures_constant.g_yes,
                                                             i_id_order_recurrence => l_interv_presc_det.id_order_recurrence,
                                                             i_dt_next             => i_dt_next,
                                                             i_flg_next_change     => i_flg_next_change,
                                                             o_flag_recurr_control => l_flg_recurr_control,
                                                             o_finish_recurr       => l_finish_recurr,
                                                             o_plan_start_date     => l_plan_start_date,
                                                             o_error               => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        IF l_flg_recurr_control = pk_order_recurrence_core.g_flg_status_control_active
           AND l_is_edit < 1
        THEN
            IF l_finish_recurr = pk_procedures_constant.g_yes
            THEN
                l_rows_out := NULL;
            
                g_error := 'UPDATE INTERV_PRESC_DET';
                ts_interv_presc_det.upd(flg_status_in          => pk_procedures_constant.g_interv_finished,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_end_tstz_in         => pk_date_utils.get_string_tstz(i_lang,
                                                                                                i_prof,
                                                                                                i_end_time,
                                                                                                NULL),
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        where_in               => ' flg_status NOT IN ( ''' ||
                                                                  pk_procedures_constant.g_interv_finished || ''', ''' ||
                                                                  pk_procedures_constant.g_interv_expired ||
                                                                  ''' ) AND id_interv_presc_det = ' ||
                                                                  l_interv_presc_det.id_interv_presc_det,
                                        rows_out               => l_rows_out);
            
                g_error := 'CALL PROCESS_UPDATE';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_DET',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                l_rows_out := NULL;
            
                g_error := 'UPDATE INTERV_PRESCRIPTION';
                ts_interv_prescription.upd(id_interv_prescription_in => l_interv_presc_det.id_interv_prescription,
                                           flg_status_in             => pk_procedures_constant.g_interv_finished,
                                           id_prof_last_update_in    => i_prof.id,
                                           dt_last_update_tstz_in    => g_sysdate_tstz,
                                           rows_out                  => l_rows_out);
            
                g_error := 'CALL PROCESS_UPDATE';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESCRIPTION',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            ELSE
                l_rows_out := NULL;
            
                -- retorna numero máximo da execução
                SELECT MAX(ipp.exec_number)
                  INTO l_exec_number
                  FROM interv_presc_plan ipp
                 WHERE ipp.id_interv_presc_det = i_interv_presc_det
                   AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed;
            
                IF l_exec_number IS NULL
                THEN
                    l_exec_number := 1;
                ELSE
                    l_exec_number := l_exec_number + 1;
                END IF;
            
                g_error := 'UPDATE INTERV_PRESC_PLAN';
                ts_interv_presc_plan.ins(id_interv_presc_det_in  => i_interv_presc_det,
                                         dt_interv_presc_plan_in => g_sysdate_tstz,
                                         dt_plan_tstz_in         => l_plan_start_date,
                                         flg_status_in           => pk_procedures_constant.g_interv_req,
                                         exec_number_in          => l_exec_number,
                                         rows_out                => l_rows_out);
            
                g_error := 'CALL PROCESS_UPDATE';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            END IF;
        END IF;
    
        g_error := 'CALL TO PK_EA_LOGIC_PROCEDURES.SET_GRID_TASK_PROCEDURES_ACROSS';
        IF NOT pk_ea_logic_procedures.set_grid_task_procedures_across(i_lang    => i_lang,
                                                                      i_prof    => i_prof,
                                                                      i_patient => l_id_patient,
                                                                      o_error   => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_EXECUTION',
                                              o_error);
            RETURN FALSE;
    END set_procedure_execution;

    FUNCTION set_procedure_execution
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_episode                 IN episode.id_episode%TYPE,
        i_interv_presc_det        IN interv_presc_plan.id_interv_presc_det%TYPE,
        i_interv_presc_plan       IN interv_presc_plan.id_interv_presc_plan%TYPE,
        i_dt_next                 IN VARCHAR2,
        i_prof_performed          IN interv_presc_plan.id_prof_performed%TYPE,
        i_start_time              IN VARCHAR2,
        i_end_time                IN VARCHAR2,
        i_flg_supplies            IN VARCHAR2,
        i_notes                   IN interv_presc_plan.notes%TYPE,
        i_epis_documentation      IN interv_presc_plan.id_epis_documentation%TYPE DEFAULT NULL,
        i_clinical_decision_rule  IN cdr_call.id_cdr_call%TYPE,
        i_clinical_question       IN table_number,
        i_response                IN table_varchar,
        i_clinical_question_notes IN table_varchar,
        o_interv_presc_plan       OUT interv_presc_plan.id_interv_presc_plan%TYPE,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_interv IS
            SELECT ipd.id_interv_prescription,
                   ipd.id_interv_presc_det,
                   ipd.id_intervention,
                   ipd.flg_status,
                   ip.flg_time,
                   ipd.flg_prn,
                   ipd.num_take,
                   ip.id_patient,
                   ip.id_episode,
                   ip.id_episode_origin,
                   ipd.flg_req_origin_module
              FROM interv_presc_det ipd, interv_presc_plan ipp, interv_prescription ip
             WHERE ipd.id_interv_presc_det = i_interv_presc_det
               AND ipd.id_interv_presc_det = ipp.id_interv_presc_det(+)
               AND ipp.id_interv_presc_plan(+) = i_interv_presc_plan
               AND ipd.id_interv_prescription = ip.id_interv_prescription;
    
        CURSOR c_interv_presc_plan IS
            SELECT ipp.*
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan;
    
        CURSOR c_interv_presc_plan_count IS
            SELECT COUNT(*)
              FROM interv_presc_plan
             WHERE id_interv_presc_det = i_interv_presc_det
               AND flg_status = pk_procedures_constant.g_interv_plan_executed;
    
        l_interv            c_interv%ROWTYPE;
        l_interv_presc_plan c_interv_presc_plan%ROWTYPE;
    
        l_id_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_plan_hist     interv_presc_plan_hist.id_interv_presc_plan_hist%TYPE;
    
        l_interv_presc_plan_count NUMBER;
    
        l_char VARCHAR2(1 CHAR);
    
        l_flg_status interv_prescription.flg_status%TYPE;
    
        l_next_interv_plan interv_presc_plan.id_interv_presc_plan%TYPE;
        l_start_time       interv_presc_plan.start_time%TYPE;
        l_end_time         interv_presc_plan.end_time%TYPE;
        l_dt_plan          interv_presc_plan.dt_plan_tstz%TYPE;
        l_dt_take          interv_presc_plan.dt_take_tstz%TYPE;
        l_aux              table_varchar2;
    
        l_exec_number NUMBER := 1;
    
        l_order_recurr_control order_recurr_control%ROWTYPE;
    
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'CALL PK_PROCEDURES_CORE.SET_PROCEDURE_HISTORY';
        IF NOT pk_procedures_core.set_procedure_history(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_interv_prescription => NULL,
                                                        i_interv_presc_det    => table_number(i_interv_presc_det),
                                                        o_error               => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        l_dt_plan    := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_next, NULL);
        l_start_time := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_time, NULL);
        l_end_time   := pk_date_utils.get_string_tstz(i_lang, i_prof, i_end_time, NULL);
    
        g_error := 'OPEN C_INTERV';
        OPEN c_interv;
        FETCH c_interv
            INTO l_interv;
        CLOSE c_interv;
    
        IF l_interv.flg_req_origin_module = 'E'
        THEN
            l_dt_take := pk_date_utils.get_string_tstz(i_lang, i_prof, i_start_time, NULL);
        ELSE
            l_dt_take := g_sysdate_tstz;
        END IF;
    
        g_error := 'OPEN C_INTERV_PRESC_PLAN';
        OPEN c_interv_presc_plan;
        FETCH c_interv_presc_plan
            INTO l_interv_presc_plan;
        CLOSE c_interv_presc_plan;
    
        -- retorna numero máximo da execução
        SELECT MAX(ipp.exec_number)
          INTO l_exec_number
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_det = i_interv_presc_det
           AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed;
    
        IF l_exec_number IS NULL
        THEN
            l_exec_number := 1;
        ELSE
            l_exec_number := l_exec_number + 1;
        END IF;
    
        SELECT id_order_recurrence
          INTO l_order_recurr_control.id_order_recurr_plan
          FROM interv_presc_det
         WHERE id_interv_presc_det = i_interv_presc_det;
    
        g_error := 'CALL TO PK_ORDER_RECURRENCE_API_DB.GET_ORDER_RECURR_PLAN_STATUS';
        IF NOT pk_order_recurrence_api_db.get_order_recurr_plan_status(i_lang              => i_lang,
                                                                       i_prof              => i_prof,
                                                                       i_order_recurr_plan => l_order_recurr_control.id_order_recurr_plan,
                                                                       o_flg_status        => l_order_recurr_control.flg_status,
                                                                       o_last_exec_order   => l_order_recurr_control.last_exec_order,
                                                                       o_dt_last_exec      => l_order_recurr_control.dt_last_exec,
                                                                       o_error             => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        IF l_interv.flg_status = pk_procedures_constant.g_interv_expired
        THEN
            -- This task was expired by CPOE.
            -- Should be possible to record the last execution made after the task expiration (not more than one excecution).
        
            IF l_interv.flg_prn = pk_procedures_constant.g_yes
            THEN
                --Because SOS prescriptions do not have a prior entry in the planning table, a new entry is created
                g_error := 'Record an execution in a post-expired SOS task';
                IF l_start_time > l_end_time
                THEN
                    l_start_time := l_end_time;
                END IF;
            
                g_error := 'INSERT INTO INTERV_PRESC_PLAN';
                ts_interv_presc_plan.ins(id_interv_presc_plan_out => l_next_interv_plan,
                                         id_interv_presc_det_in   => l_interv.id_interv_presc_det,
                                         dt_interv_presc_plan_in  => g_sysdate_tstz,
                                         dt_plan_tstz_in          => g_sysdate_tstz,
                                         flg_status_in            => pk_procedures_constant.g_interv_plan_executed,
                                         dt_take_tstz_in          => g_sysdate_tstz,
                                         id_prof_take_in          => i_prof.id,
                                         notes_in                 => i_notes,
                                         id_prof_performed_in     => CASE i_prof_performed
                                                                         WHEN -1 THEN
                                                                          NULL
                                                                         ELSE
                                                                          i_prof_performed
                                                                     END,
                                         start_time_in            => l_start_time,
                                         end_time_in              => l_end_time,
                                         flg_supplies_reg_in      => i_flg_supplies,
                                         id_epis_documentation_in => i_epis_documentation,
                                         id_episode_write_in      => i_episode,
                                         exec_number_in           => l_exec_number,
                                         id_prof_last_update_in   => i_prof.id,
                                         dt_last_update_tstz_in   => g_sysdate_tstz,
                                         rows_out                 => l_rows_out);
            
                g_error := 'PROCESS UPDATE';
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_EXECUTED';
                pk_ia_event_prescription.procedure_executed(i_id_interv_presc_plan => l_next_interv_plan);
            
            ELSIF l_interv_presc_plan.flg_status = pk_procedures_constant.g_interv_plan_expired
            THEN
                -- For safety, validate that we are updating an execution plan already expired         
                g_error := 'Record an execution in a post-expired task';
                ts_interv_presc_plan.upd(id_interv_presc_plan_in => i_interv_presc_plan,
                                         flg_status_in           => pk_procedures_constant.g_interv_plan_executed,
                                         dt_take_tstz_in         => g_sysdate_tstz,
                                         id_prof_take_in         => i_prof.id,
                                         notes_in                => i_notes,
                                         notes_nin               => FALSE,
                                         id_prof_performed_in    => CASE i_prof_performed
                                                                        WHEN -1 THEN
                                                                         NULL
                                                                        ELSE
                                                                         i_prof_performed
                                                                    END,
                                         start_time_in           => l_start_time,
                                         start_time_nin          => FALSE,
                                         end_time_in             => l_end_time,
                                         end_time_nin            => FALSE,
                                         flg_supplies_reg_in     => i_flg_supplies,
                                         -- Clear cancel information that was automatically filled by expire_task method
                                         id_prof_cancel_in         => NULL,
                                         id_prof_cancel_nin        => FALSE,
                                         notes_cancel_in           => NULL,
                                         notes_cancel_nin          => FALSE,
                                         dt_cancel_tstz_in         => NULL,
                                         dt_cancel_tstz_nin        => FALSE,
                                         id_epis_documentation_in  => i_epis_documentation,
                                         id_epis_documentation_nin => FALSE,
                                         id_episode_write_in       => i_episode,
                                         id_prof_last_update_in    => i_prof.id,
                                         dt_last_update_tstz_in    => g_sysdate_tstz,
                                         rows_out                  => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_EXECUTED';
                pk_ia_event_prescription.procedure_executed(i_id_interv_presc_plan => i_interv_presc_plan);
            
            END IF;
        
            g_error := 'CALL pk_visit.upd_epis_info_interv';
            IF NOT pk_visit.upd_epis_info_interv(i_lang                       => i_lang,
                                                 i_id_episode                 => i_episode,
                                                 i_id_prof                    => i_prof,
                                                 i_dt_first_intervention_prsc => pk_date_utils.date_send_tsz(i_lang,
                                                                                                             g_sysdate_tstz,
                                                                                                             i_prof),
                                                 i_dt_first_intervention_take => pk_date_utils.date_send_tsz(i_lang,
                                                                                                             g_sysdate_tstz,
                                                                                                             i_prof),
                                                 i_prof_cat_type              => pk_prof_utils.get_category(i_lang, i_prof),
                                                 o_error                      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => NULL,
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
            -- End post-expired execution
        
        ELSIF l_interv.flg_prn = pk_procedures_constant.g_yes
              OR l_interv_presc_plan.flg_status IN
              (pk_procedures_constant.g_interv_plan_req,
                  pk_procedures_constant.g_interv_plan_pending,
                  pk_procedures_constant.g_interv_plan_executed)
        THEN
            IF l_interv.flg_prn IS NULL
               OR l_interv.flg_prn != pk_procedures_constant.g_yes
            THEN
                IF l_interv_presc_plan.flg_status = pk_procedures_constant.g_interv_plan_executed
                THEN
                    -- Editar a execução 
                    g_error := 'CALL TO PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION_HIST';
                    IF NOT pk_procedures_core.set_procedure_execution_hist(i_lang                   => i_lang,
                                                                           i_prof                   => i_prof,
                                                                           i_interv_presc_plan      => i_interv_presc_plan,
                                                                           o_interv_presc_plan_hist => l_interv_plan_hist,
                                                                           o_error                  => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    g_error := 'UPDATE INTERV_PRESC_PLAN';
                    ts_interv_presc_plan.upd(id_interv_presc_plan_in  => i_interv_presc_plan,
                                             dt_take_tstz_in          => l_dt_take,
                                             notes_in                 => i_notes,
                                             notes_nin                => FALSE,
                                             id_prof_performed_in     => CASE i_prof_performed
                                                                             WHEN -1 THEN
                                                                              NULL
                                                                             ELSE
                                                                              i_prof_performed
                                                                         END,
                                             id_prof_take_in          => i_prof.id,
                                             start_time_in            => l_start_time,
                                             start_time_nin           => FALSE,
                                             end_time_in              => l_end_time,
                                             end_time_nin             => FALSE,
                                             id_cdr_event_in          => i_clinical_decision_rule,
                                             id_epis_documentation_in => i_epis_documentation,
                                             id_episode_write_in      => i_episode,
                                             id_prof_last_update_in   => i_prof.id,
                                             dt_last_update_tstz_in   => g_sysdate_tstz,
                                             rows_out                 => l_rows_out);
                
                    g_error := 'UPDATE INTERV_PRESC_PLAN - NEXT';
                    ts_interv_presc_plan.upd(dt_plan_tstz_in => l_dt_plan,
                                             where_in        => ' id_interv_presc_det = ' ||
                                                                l_interv_presc_plan.id_interv_presc_det ||
                                                                ' AND exec_number = ' ||
                                                                to_number(l_interv_presc_plan.exec_number + 1),
                                             rows_out        => l_rows_out);
                
                ELSE
                    SELECT id_interv_presc_plan
                      INTO l_id_interv_presc_plan
                      FROM (SELECT ipp.id_interv_presc_plan,
                                   row_number() over(PARTITION BY ipp.id_interv_presc_det ORDER BY ipp.exec_number DESC, ipp.dt_interv_presc_plan DESC) rn
                              FROM interv_presc_det ipd, interv_presc_plan ipp
                             WHERE ipd.id_interv_presc_det = i_interv_presc_det
                               AND ipd.id_interv_presc_det = ipp.id_interv_presc_det)
                     WHERE rn = 1;
                
                    g_error := 'UPDATE INTERV_PRESC_PLAN';
                    ts_interv_presc_plan.upd(id_interv_presc_plan_in  => l_id_interv_presc_plan,
                                             flg_status_in            => pk_procedures_constant.g_interv_plan_executed,
                                             dt_take_tstz_in          => l_dt_take,
                                             id_prof_take_in          => i_prof.id,
                                             notes_in                 => i_notes,
                                             notes_nin                => FALSE,
                                             id_prof_performed_in     => CASE i_prof_performed
                                                                             WHEN -1 THEN
                                                                              NULL
                                                                             ELSE
                                                                              i_prof_performed
                                                                         END,
                                             start_time_in            => l_start_time,
                                             start_time_nin           => FALSE,
                                             end_time_in              => l_end_time,
                                             end_time_nin             => FALSE,
                                             flg_supplies_reg_in      => i_flg_supplies,
                                             id_cdr_event_in          => i_clinical_decision_rule,
                                             id_epis_documentation_in => i_epis_documentation,
                                             id_episode_write_in      => i_episode,
                                             id_prof_last_update_in   => i_prof.id,
                                             dt_last_update_tstz_in   => g_sysdate_tstz,
                                             rows_out                 => l_rows_out);
                
                    g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_EXECUTED';
                    pk_ia_event_prescription.procedure_executed(i_id_interv_presc_plan => l_id_interv_presc_plan);
                END IF;
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            END IF;
        
            g_error := 'OPEN C_INTERV_PRESC_PLAN_COUNT';
            OPEN c_interv_presc_plan_count;
            FETCH c_interv_presc_plan_count
                INTO l_interv_presc_plan_count;
            CLOSE c_interv_presc_plan_count;
        
            l_interv.flg_status := pk_procedures_constant.g_interv_exec;
        
            l_rows_out := NULL;
        
            IF l_interv.flg_prn = pk_procedures_constant.g_no
               AND l_interv_presc_plan_count != l_interv.num_take
               AND l_interv_presc_plan.flg_status != pk_procedures_constant.g_interv_plan_executed
            THEN
                g_error := 'INSERT INTERV_PRESC_PLAN';
                ts_interv_presc_plan.ins(id_interv_presc_plan_out => l_next_interv_plan,
                                         id_interv_presc_det_in   => l_interv.id_interv_presc_det,
                                         dt_interv_presc_plan_in  => g_sysdate_tstz,
                                         dt_plan_tstz_in          => l_dt_plan,
                                         flg_status_in            => pk_procedures_constant.g_interv_plan_pending,
                                         id_prof_performed_in     => CASE i_prof_performed
                                                                         WHEN -1 THEN
                                                                          NULL
                                                                         ELSE
                                                                          i_prof_performed
                                                                     END,
                                         start_time_in            => NULL,
                                         end_time_in              => NULL,
                                         flg_supplies_reg_in      => i_flg_supplies,
                                         id_cdr_event_in          => i_clinical_decision_rule,
                                         id_prof_last_update_in   => i_prof.id,
                                         dt_last_update_tstz_in   => g_sysdate_tstz,
                                         rows_out                 => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                l_interv.flg_status := pk_procedures_constant.g_interv_exec;
            
            ELSIF l_interv.flg_prn = pk_procedures_constant.g_yes
            THEN
                IF l_start_time > l_end_time
                THEN
                    l_start_time := l_end_time;
                END IF;
            
                IF l_interv_presc_plan.flg_status = pk_procedures_constant.g_interv_plan_executed
                THEN
                    -- Editar a execução sos
                    g_error := 'CALL TO PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION_HIST';
                    IF NOT pk_procedures_core.set_procedure_execution_hist(i_lang                   => i_lang,
                                                                           i_prof                   => i_prof,
                                                                           i_interv_presc_plan      => i_interv_presc_plan,
                                                                           o_interv_presc_plan_hist => l_interv_plan_hist,
                                                                           o_error                  => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    g_error := 'UPDATE INTERV_PRESC_PLAN';
                    ts_interv_presc_plan.upd(id_interv_presc_plan_in  => i_interv_presc_plan,
                                             dt_take_tstz_in          => l_dt_take,
                                             notes_in                 => i_notes,
                                             notes_nin                => FALSE,
                                             id_prof_performed_in     => CASE i_prof_performed
                                                                             WHEN -1 THEN
                                                                              NULL
                                                                             ELSE
                                                                              i_prof_performed
                                                                         END,
                                             start_time_in            => l_start_time,
                                             start_time_nin           => FALSE,
                                             end_time_in              => l_end_time,
                                             end_time_nin             => FALSE,
                                             dt_plan_tstz_in          => g_sysdate_tstz,
                                             id_cdr_event_in          => i_clinical_decision_rule,
                                             id_epis_documentation_in => i_epis_documentation,
                                             id_episode_write_in      => i_episode,
                                             id_prof_last_update_in   => i_prof.id,
                                             dt_last_update_tstz_in   => g_sysdate_tstz,
                                             rows_out                 => l_rows_out);
                ELSE
                    -- TAKE = sos
                    g_error := 'INSERT INTERV_PRESC_PLAN (2)';
                    ts_interv_presc_plan.ins(id_interv_presc_plan_out => l_next_interv_plan,
                                             id_interv_presc_det_in   => l_interv.id_interv_presc_det,
                                             dt_interv_presc_plan_in  => g_sysdate_tstz,
                                             dt_plan_tstz_in          => g_sysdate_tstz,
                                             flg_status_in            => pk_procedures_constant.g_interv_plan_executed,
                                             dt_take_tstz_in          => g_sysdate_tstz,
                                             id_prof_take_in          => i_prof.id,
                                             notes_in                 => i_notes,
                                             id_prof_performed_in     => CASE i_prof_performed
                                                                             WHEN -1 THEN
                                                                              NULL
                                                                             ELSE
                                                                              i_prof_performed
                                                                         END,
                                             start_time_in            => l_start_time,
                                             end_time_in              => l_end_time,
                                             flg_supplies_reg_in      => i_flg_supplies,
                                             id_cdr_event_in          => i_clinical_decision_rule,
                                             id_epis_documentation_in => i_epis_documentation,
                                             id_episode_write_in      => i_episode,
                                             exec_number_in           => l_exec_number,
                                             id_prof_last_update_in   => i_prof.id,
                                             dt_last_update_tstz_in   => g_sysdate_tstz,
                                             rows_out                 => l_rows_out);
                
                    g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_EXECUTED';
                    pk_ia_event_prescription.procedure_executed(i_id_interv_presc_plan => l_next_interv_plan);
                
                END IF;
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                l_interv.flg_status := pk_procedures_constant.g_interv_exec;
            
            ELSIF l_interv_presc_plan_count = l_interv.num_take
                  OR l_order_recurr_control.flg_status IS NULL
            THEN
                l_interv.flg_status := pk_procedures_constant.g_interv_finished;
            END IF;
        
            IF l_order_recurr_control.flg_status = pk_order_recurrence_core.g_flg_status_control_active
            THEN
                l_interv.flg_status := pk_procedures_constant.g_interv_exec;
            END IF;
        
            l_rows_out := NULL;
        
            IF l_interv.flg_status = pk_procedures_constant.g_interv_finished
            THEN
                g_error := 'UPDATE INTERV_PRESC_DET';
                ts_interv_presc_det.upd(flg_status_in          => l_interv.flg_status,
                                        dt_end_tstz_in         => l_end_time,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        where_in               => ' flg_status NOT IN ( ''' || l_interv.flg_status ||
                                                                  ''', ''' || pk_procedures_constant.g_interv_expired ||
                                                                  ''' ) AND id_interv_presc_det = ' ||
                                                                  l_interv.id_interv_presc_det,
                                        rows_out               => l_rows_out);
            ELSE
                g_error := 'UPDATE INTERV_PRESC_DET';
                ts_interv_presc_det.upd(flg_status_in          => l_interv.flg_status,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        where_in               => ' flg_status NOT IN ( ''' || l_interv.flg_status ||
                                                                  ''', ''' || pk_procedures_constant.g_interv_expired ||
                                                                  ''' ) AND id_interv_presc_det = ' ||
                                                                  l_interv.id_interv_presc_det,
                                        rows_out               => l_rows_out);
            END IF;
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESC_DET',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            IF i_clinical_question.count != 0
            THEN
                FOR i IN 1 .. i_clinical_question.count
                LOOP
                    IF i_clinical_question(i) IS NOT NULL
                    THEN
                        IF i_response(i) IS NOT NULL
                        THEN
                            l_aux := pk_utils.str_split(i_response(i), '|');
                        
                            FOR j IN 1 .. l_aux.count
                            LOOP
                                g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                                INSERT INTO interv_question_response
                                    (id_interv_question_response,
                                     id_episode,
                                     id_interv_presc_det,
                                     flg_time,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (seq_interv_question_response.nextval,
                                     i_episode,
                                     l_interv.id_interv_presc_det,
                                     pk_procedures_constant.g_interv_cq_on_order,
                                     i_clinical_question(i),
                                     to_number(l_aux(j)),
                                     i_clinical_question_notes(i),
                                     i_prof.id,
                                     g_sysdate_tstz);
                            END LOOP;
                        ELSE
                            g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                            INSERT INTO interv_question_response
                                (id_interv_question_response,
                                 id_episode,
                                 id_interv_presc_det,
                                 flg_time,
                                 id_questionnaire,
                                 id_response,
                                 notes,
                                 id_prof_last_update,
                                 dt_last_update_tstz)
                            VALUES
                                (seq_interv_question_response.nextval,
                                 i_episode,
                                 l_interv.id_interv_presc_det,
                                 pk_procedures_constant.g_interv_cq_on_order,
                                 i_clinical_question(i),
                                 NULL,
                                 i_clinical_question_notes(i),
                                 i_prof.id,
                                 g_sysdate_tstz);
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        
            l_flg_status := pk_procedures_constant.g_interv_partial;
        
            -- inserir em log de estados
            IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                    i_prof       => i_prof,
                                    i_id_episode => i_episode,
                                    i_flg_status => l_interv.flg_status,
                                    i_id_record  => l_interv.id_interv_presc_det,
                                    i_flg_type   => pk_procedures_constant.g_interv_type_req,
                                    o_error      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            -- Verifica se existem outros detalhes do mm cab., ñ cancelados nem terminados
            g_error := 'OPEN C_REQ_FIN';
            BEGIN
                SELECT 'X'
                  INTO l_char
                  FROM interv_presc_det
                 WHERE id_interv_prescription = l_interv.id_interv_prescription
                   AND flg_status NOT IN (pk_procedures_constant.g_interv_finished,
                                          pk_procedures_constant.g_interv_cancel,
                                          pk_procedures_constant.g_interv_expired)
                   AND rownum = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_flg_status := pk_procedures_constant.g_interv_finished;
            END;
        
            IF l_order_recurr_control.flg_status = pk_order_recurrence_core.g_flg_status_control_active
            THEN
                l_interv.flg_status := pk_procedures_constant.g_interv_exec;
            END IF;
        
            l_rows_out := NULL;
        
            g_error := 'UPDATE INTERV_PRESCRIPTION - FLG_STATUS';
            ts_interv_prescription.upd(id_interv_prescription_in => l_interv.id_interv_prescription,
                                       flg_status_in             => l_flg_status,
                                       id_prof_last_update_in    => i_prof.id,
                                       dt_last_update_tstz_in    => g_sysdate_tstz,
                                       rows_out                  => l_rows_out);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESCRIPTION',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            IF nvl(l_interv.id_episode_origin, 0) != 0
               AND l_interv.flg_prn = pk_procedures_constant.g_no
            THEN
                l_rows_out := NULL;
            
                g_error := 'UPDATE INTERV_PRESCRIPTION - DT_BEGIN';
                ts_interv_prescription.upd(id_interv_prescription_in => l_interv.id_interv_prescription,
                                           dt_begin_tstz_in          => l_dt_plan,
                                           id_prof_last_update_in    => i_prof.id,
                                           dt_last_update_tstz_in    => g_sysdate_tstz,
                                           rows_out                  => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESCRIPTION',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            END IF;
        
            g_error := 'OPEN C_INTERV_PRESC_PLAN';
            OPEN c_interv_presc_plan;
            FETCH c_interv_presc_plan
                INTO l_interv_presc_plan;
            CLOSE c_interv_presc_plan;
        
            -- ALTERACOES DOS ALERTAS                 
            IF l_interv.flg_time IN (pk_procedures_constant.g_flg_time_b, pk_procedures_constant.g_flg_time_e)
               AND l_interv.flg_status IN (pk_procedures_constant.g_interv_req,
                                           pk_procedures_constant.g_interv_exec,
                                           pk_procedures_constant.g_interv_plan_pending)
               AND l_interv_presc_plan.flg_status IN
               (pk_procedures_constant.g_interv_plan_req, pk_procedures_constant.g_interv_plan_pending)
            THEN
                l_sys_alert_event.id_sys_alert        := 6;
                l_sys_alert_event.id_software         := i_prof.software;
                l_sys_alert_event.id_institution      := i_prof.institution;
                l_sys_alert_event.id_episode          := i_episode;
                l_sys_alert_event.id_record           := l_next_interv_plan;
                l_sys_alert_event.dt_record           := g_sysdate_tstz;
                l_sys_alert_event.id_professional     := NULL;
                l_sys_alert_event.id_room             := NULL;
                l_sys_alert_event.id_clinical_service := NULL;
                l_sys_alert_event.replace1            := 'INTERVENTION.CODE_INTERVENTION.' || l_interv.id_intervention;
            
                --Insere evento na tabela de alertas
                g_error := 'INSERT INTO SYS_ALERT_EVENT - ID_SYS_ALERT 6';
                IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        i_flg_type_dest   => 'C',
                                                        o_error           => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_interv.flg_status != pk_procedures_constant.g_interv_exec
                THEN
                    l_sys_alert_event.id_sys_alert := 41;
                
                    --Insere evento na tabela de alertas
                    g_error := 'INSERT INTO SYS_ALERT_EVENT - ID_SYS_ALERT 41';
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            i_flg_type_dest   => 'C',
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        
            IF (l_interv.flg_time NOT IN (pk_procedures_constant.g_flg_time_b, pk_procedures_constant.g_flg_time_e) OR
               l_interv.flg_status NOT IN
               (pk_procedures_constant.g_interv_req, pk_procedures_constant.g_interv_plan_pending) OR
               l_interv_presc_plan.flg_status NOT IN
               (pk_procedures_constant.g_interv_plan_req, pk_procedures_constant.g_interv_plan_pending))
            THEN
                --Retira o alerta de procedimentos
                g_error                        := 'DELETE FROM SYS_ALERT_EVENT - ID_SYS_ALERT 6';
                l_sys_alert_event.id_sys_alert := 6;
                l_sys_alert_event.id_episode   := i_episode;
                l_sys_alert_event.id_record    := i_interv_presc_plan;
            
                g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT - ID_SYS_ALERT 6';
                IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        o_error           => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_interv.flg_status != pk_procedures_constant.g_interv_exec
                THEN
                    --Retira o alerta de procedimentos
                    g_error                        := 'DELETE FROM SYS_ALERT_EVENT - ID_SYS_ALERT 41';
                    l_sys_alert_event.id_sys_alert := 41;
                    l_sys_alert_event.id_episode   := i_episode;
                    l_sys_alert_event.id_record    := i_interv_presc_plan;
                
                    g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT - ID_SYS_ALERT 41';
                    IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF; -- ALERTAS END             
        
            --AM March 7,2008 Em procedimentos agendados para o próximo episódio ao executar 
            --a data da prescrição é a de execução 
            --(exepto se for re-agendado a data de prescrição é a do reagendamento)
            g_error := 'CALL PK_VISIT.UPD_EPIS_INFO_INTERV';
            IF NOT pk_visit.upd_epis_info_interv(i_lang                       => i_lang,
                                                 i_id_episode                 => i_episode,
                                                 i_id_prof                    => i_prof,
                                                 i_dt_first_intervention_prsc => pk_date_utils.date_send_tsz(i_lang,
                                                                                                             g_sysdate_tstz,
                                                                                                             i_prof),
                                                 i_dt_first_intervention_take => pk_date_utils.date_send_tsz(i_lang,
                                                                                                             g_sysdate_tstz,
                                                                                                             i_prof),
                                                 i_prof_cat_type              => pk_prof_utils.get_category(i_lang, i_prof),
                                                 o_error                      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => NULL,
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF; --SOS OU PENDENTE/REQUISITADO
    
        IF l_interv_plan_hist IS NOT NULL
        THEN
            o_interv_presc_plan := l_interv_plan_hist;
        ELSE
            o_interv_presc_plan := l_next_interv_plan;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_EXECUTION',
                                              o_error);
            RETURN FALSE;
    END set_procedure_execution;

    FUNCTION set_procedure_doc_associated
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_interv_presc_det     IN interv_presc_det.id_interv_presc_det%TYPE,
        i_interv_presc_plan    IN interv_presc_plan.id_interv_presc_plan%TYPE,
        i_flg_import           IN table_varchar,
        i_id_doc               IN table_number,
        i_tbl_ds_internal_name IN table_varchar DEFAULT NULL,
        i_tbl_val              IN table_table_varchar DEFAULT NULL,
        i_tbl_real_val         IN table_table_varchar DEFAULT NULL,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        IF i_flg_import.count > 0
        THEN
            FOR i IN 1 .. i_flg_import.count
            LOOP
                IF i_flg_import(i) = pk_procedures_constant.g_yes
                THEN
                    g_error := 'CALL TO PK_DOC.CREATE_DOCUMENT';
                    IF NOT pk_doc.create_document(i_lang                 => i_lang,
                                                  i_prof                 => i_prof,
                                                  i_id_episode           => i_episode,
                                                  i_id_patient           => i_patient,
                                                  i_id_doc               => i_id_doc(i),
                                                  i_ext_req              => NULL,
                                                  i_tbl_ds_internal_name => i_tbl_ds_internal_name,
                                                  i_tbl_val              => i_tbl_val,
                                                  i_tbl_real_val         => i_tbl_real_val,
                                                  o_error                => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    g_error := 'INSERTO INTO INTERV_MEDIA_ARCHIVE 1';
                    ts_interv_media_archive.ins(id_interv_presc_det_in  => i_interv_presc_det,
                                                id_interv_presc_plan_in => i_interv_presc_plan,
                                                id_doc_external_in      => i_id_doc(i),
                                                flg_type_in             => CASE
                                                                               WHEN i_interv_presc_det IS NOT NULL THEN
                                                                                pk_procedures_constant.g_media_archive_interv_doc
                                                                               ELSE
                                                                                pk_procedures_constant.g_media_archive_interv_exec
                                                                           END,
                                                flg_status_in           => pk_procedures_constant.g_active,
                                                id_prof_last_update_in  => i_prof.id,
                                                dt_last_update_tstz_in  => g_sysdate_tstz,
                                                rows_out                => l_rows_out);
                
                ELSE
                    g_error := 'INSERTO INTO INTERV_MEDIA_ARCHIVE 2';
                    ts_interv_media_archive.ins(id_interv_presc_det_in  => i_interv_presc_det,
                                                id_interv_presc_plan_in => i_interv_presc_plan,
                                                id_doc_external_in      => i_id_doc(i),
                                                flg_type_in             => CASE
                                                                               WHEN i_interv_presc_det IS NOT NULL THEN
                                                                                pk_procedures_constant.g_media_archive_interv_doc
                                                                               ELSE
                                                                                pk_procedures_constant.g_media_archive_interv_exec
                                                                           END,
                                                flg_status_in           => pk_procedures_constant.g_active,
                                                id_prof_last_update_in  => i_prof.id,
                                                dt_last_update_tstz_in  => g_sysdate_tstz,
                                                rows_out                => l_rows_out);
                END IF;
            END LOOP;
        
            g_error := 'CALL PROCESS_INSERT';
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_MEDIA_ARCHIVE',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROCEDURE_DOC_ASSOCIATED',
                                              o_error);
            RETURN FALSE;
    END set_procedure_doc_associated;

    FUNCTION update_procedure_order
    (
        i_lang                    IN language.id_language%TYPE, --1
        i_prof                    IN profissional,
        i_episode                 IN episode.id_episode%TYPE,
        i_interv_prescription     IN interv_prescription.id_interv_prescription%TYPE,
        i_interv_presc_det        IN table_number, --5
        i_flg_time                IN table_varchar,
        i_dt_begin                IN table_varchar,
        i_order_recurrence        IN table_number,
        i_diagnosis_notes         IN table_varchar,
        i_diagnosis               IN pk_edis_types.table_in_epis_diagnosis, --10
        i_clinical_purpose        IN table_number,
        i_clinical_purpose_notes  IN table_varchar,
        i_laterality              IN table_varchar,
        i_priority                IN table_varchar,
        i_flg_prn                 IN table_varchar, --15
        i_notes_prn               IN table_varchar,
        i_exec_institution        IN table_number,
        i_flg_location            IN table_varchar,
        i_supply                  IN table_table_number,
        i_supply_set              IN table_table_number, --20
        i_supply_qty              IN table_table_number,
        i_dt_return               IN table_table_varchar,
        i_not_order_reason        IN table_number,
        i_notes                   IN table_varchar,
        i_prof_order              IN table_number, --25
        i_dt_order                IN table_varchar,
        i_order_type              IN table_number,
        i_codification            IN table_number,
        i_health_plan             IN table_number,
        i_exemption               IN table_number, --30
        i_clinical_question       IN table_table_number,
        i_response                IN table_table_varchar,
        i_clinical_question_notes IN table_table_varchar,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_prescription      interv_prescription%ROWTYPE;
        l_interv_presc_det         interv_presc_det%ROWTYPE;
        l_interv_presc_plan        interv_presc_plan%ROWTYPE;
        l_interv_presc_plan_count  NUMBER := 1;
        l_interv_question_response interv_question_response%ROWTYPE;
    
        l_order_recurrence        order_recurr_plan.id_order_recurr_plan%TYPE;
        l_order_recurrence_option order_recurr_plan.id_order_recurr_option%TYPE;
    
        l_status_det interv_presc_det.flg_status%TYPE;
    
        l_dt_begin interv_presc_det.dt_begin_tstz%TYPE;
    
        l_not_order_reason not_order_reason.id_not_order_reason%TYPE;
    
        l_id_co_sign      co_sign.id_co_sign%TYPE;
        l_id_co_sign_hist co_sign_hist.id_co_sign_hist%TYPE;
    
        l_count PLS_INTEGER := 0;
    
        l_diagnosis           table_number := table_number();
        l_tbl_alert_diagnosis table_number := table_number();
        l_diagnosis_new       table_number := table_number();
        l_epis_diagnosis      table_varchar := table_varchar();
        l_tbl_diag_desc       table_varchar := table_varchar();
    
        l_interv_codification interv_codification.id_interv_codification%TYPE;
    
        l_supply_request    supply_request.id_supply_request%TYPE;
        l_supply_dt_request table_varchar := table_varchar();
    
        l_clinical_question       table_number := table_number();
        l_response                table_varchar := table_varchar();
        l_clinical_question_notes table_varchar := table_varchar();
        l_aux                     table_varchar2;
    
        l_status_plan interv_presc_plan.flg_status%TYPE;
        l_next_plan   interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_rows_out table_varchar := table_varchar();
    
        FUNCTION get_sub_diag_table
        (
            i_tbl_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
            i_sub_diag_list IN table_number
        ) RETURN pk_edis_types.rec_in_epis_diagnosis IS
            l_ret      pk_edis_types.rec_in_epis_diagnosis;
            l_tbl_diag pk_edis_types.table_in_diagnosis;
        BEGIN
            l_ret := i_tbl_diagnosis;
        
            IF i_sub_diag_list.exists(1)
            THEN
                l_tbl_diag          := l_ret.tbl_diagnosis;
                l_ret.tbl_diagnosis := pk_edis_types.table_in_diagnosis();
            
                IF l_tbl_diag.exists(1)
                THEN
                    FOR j IN i_sub_diag_list.first .. i_sub_diag_list.last
                    LOOP
                        FOR i IN l_tbl_diag.first .. l_tbl_diag.last
                        LOOP
                            IF l_tbl_diag(i).id_diagnosis = i_sub_diag_list(j)
                            THEN
                                l_ret.tbl_diagnosis.extend;
                                l_ret.tbl_diagnosis(l_ret.tbl_diagnosis.count) := l_tbl_diag(i);
                                EXIT;
                            END IF;
                        END LOOP;
                    END LOOP;
                END IF;
            END IF;
        
            RETURN l_ret;
        END get_sub_diag_table;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'CALL PK_PROCEDURES_CORE.SET_PROCEDURE_HISTORY';
        IF NOT pk_procedures_core.set_procedure_history(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_interv_prescription => NULL,
                                                        i_interv_presc_det    => i_interv_presc_det,
                                                        o_error               => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'OPEN LOOP';
        FOR i IN 1 .. i_interv_presc_det.count
        LOOP
            g_error := 'GET INTERV_PRESC_DET';
            SELECT ipd.*
              INTO l_interv_presc_det
              FROM interv_presc_det ipd
             WHERE ipd.id_interv_presc_det = i_interv_presc_det(i);
        
            g_error := 'GET INTERV_PRESCRIPTION';
            SELECT ip.*
              INTO l_interv_prescription
              FROM interv_prescription ip
             WHERE ip.id_interv_prescription = l_interv_presc_det.id_interv_prescription;
        
            BEGIN
                SELECT ipp.*
                  INTO l_interv_presc_plan
                  FROM interv_presc_plan ipp
                 WHERE ipp.id_interv_presc_det = i_interv_presc_det(i);
            
                l_interv_presc_plan_count := SQL%ROWCOUNT;
            EXCEPTION
                WHEN OTHERS THEN
                    l_interv_presc_plan_count := 0;
            END;
        
            IF i_order_recurrence(i) IS NOT NULL
            THEN
                -- set order recurrence plan as finished or cancel plan (order_recurr_option - 0 OR -2 ---- order_recurr_area NOT IN (7,8,9)
                g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.SET_ORDER_RECURR_PLAN';
                IF NOT pk_order_recurrence_api_db.set_order_recurr_plan(i_lang                    => i_lang,
                                                                        i_prof                    => i_prof,
                                                                        i_order_recurr_plan       => i_order_recurrence(i),
                                                                        o_order_recurr_option     => l_order_recurrence_option,
                                                                        o_final_order_recurr_plan => l_order_recurrence,
                                                                        o_error                   => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_order_recurrence IS NOT NULL
                THEN
                    g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.PREPARE_ORDER_RECURR_PLAN';
                    IF NOT pk_order_recurrence_api_db.prepare_order_recurr_plan(i_lang       => i_lang,
                                                                                i_prof       => i_prof,
                                                                                i_order_plan => table_number(l_order_recurrence),
                                                                                o_error      => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        
            l_dt_begin := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_begin(i), NULL);
        
            g_error := 'FLG_TIME';
            IF i_flg_time(i) != pk_procedures_constant.g_flg_time_e
            THEN
                l_status_det := pk_procedures_constant.g_interv_pending;
            
                IF i_flg_time(i) = pk_procedures_constant.g_flg_time_n
                THEN
                    l_dt_begin := NULL;
                END IF;
            ELSE
                -- realização neste epis.
                IF i_episode IS NOT NULL
                THEN
                    IF pk_sysconfig.get_config('REQ_NEXT_DAY', i_prof) = pk_procedures_constant.g_no
                    THEN
                        IF pk_date_utils.trunc_insttimezone(i_prof, nvl(l_dt_begin, g_sysdate_tstz), 'DD') !=
                           pk_date_utils.trunc_insttimezone(i_prof, g_sysdate_tstz, 'DD')
                        THEN
                            g_error_code := 'INTERV_M010';
                            g_error      := pk_message.get_message(i_lang, i_prof, 'INTERV_M010');
                            RAISE g_user_exception;
                        END IF;
                    END IF;
                END IF;
            
                IF nvl(l_dt_begin, g_sysdate_tstz) > g_sysdate_tstz
                THEN
                    l_status_det := pk_procedures_constant.g_interv_pending;
                ELSE
                    IF pk_date_utils.trunc_insttimezone_str(i_prof, l_interv_prescription.dt_begin_tstz, 'MI') !=
                       pk_date_utils.trunc_insttimezone_str(i_prof, l_dt_begin, 'MI')
                    THEN
                        l_dt_begin := g_sysdate_tstz;
                    END IF;
                
                    l_status_det := pk_procedures_constant.g_interv_req;
                END IF;
            END IF;
        
            IF i_exec_institution(i) NOT IN (i_prof.institution, pk_procedures_constant.g_id_location_hhc)
            THEN
                l_status_det := pk_procedures_constant.g_interv_exterior;
            END IF;
        
            -- getting not order reason id                                              
            IF i_not_order_reason(i) IS NOT NULL
            THEN
                l_status_det := pk_procedures_constant.g_interv_not_ordered;
            
                g_error := 'CALL TO PK_NOT_ORDER_REASON_DB.SET_NOT_ORDER_REASON';
                IF NOT pk_not_order_reason_db.set_not_order_reason(i_lang                => i_lang,
                                                                   i_prof                => i_prof,
                                                                   i_not_order_reason_ea => i_not_order_reason(i),
                                                                   o_id_not_order_reason => l_not_order_reason,
                                                                   o_error               => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        
            IF l_interv_presc_det.flg_status IN
               (pk_procedures_constant.g_interv_predefined, pk_procedures_constant.g_interv_draft)
               OR l_status_det IS NULL
            THEN
                l_status_det := l_interv_presc_det.flg_status;
            END IF;
        
            g_error := 'UPDATE INTERV_PRESCRIPTION';
            ts_interv_prescription.upd(id_interv_prescription_in => l_interv_presc_det.id_interv_prescription,
                                       id_institution_in         => i_prof.institution,
                                       flg_time_in               => CASE
                                                                        WHEN i_flg_time IS NOT NULL
                                                                             AND i_flg_time.count > 0 THEN
                                                                         i_flg_time(i)
                                                                        ELSE
                                                                         l_interv_prescription.flg_time
                                                                    END,
                                       flg_status_in             => CASE
                                                                        WHEN i_flg_prn(i) = pk_procedures_constant.g_yes THEN
                                                                         pk_procedures_constant.g_interv_sos
                                                                        ELSE
                                                                         l_status_det
                                                                    END,
                                       dt_begin_tstz_in          => l_dt_begin,
                                       dt_begin_tstz_nin         => FALSE,
                                       id_prof_last_update_in    => i_prof.id,
                                       dt_last_update_tstz_in    => g_sysdate_tstz,
                                       rows_out                  => l_rows_out);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESCRIPTION',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            IF l_interv_presc_plan_count > 0
            THEN
                l_rows_out := NULL;
            
                ts_interv_presc_plan.upd(id_interv_presc_plan_in => l_interv_presc_plan.id_interv_presc_plan,
                                         id_interv_presc_det_in  => l_interv_presc_plan.id_interv_presc_det,
                                         dt_plan_tstz_in         => CASE l_interv_prescription.flg_time
                                                                        WHEN pk_procedures_constant.g_flg_time_n THEN
                                                                         NULL
                                                                        ELSE
                                                                         nvl(l_dt_begin, l_interv_presc_plan.dt_plan_tstz)
                                                                    END,
                                         dt_plan_tstz_nin        => FALSE,
                                         exec_number_in          => 1,
                                         flg_status_in           => l_interv_presc_plan.flg_status,
                                         rows_out                => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            ELSIF l_interv_presc_plan_count = 0
                  AND i_flg_prn(i) = pk_alert_constant.g_no
            THEN
            
                l_next_plan := ts_interv_presc_plan.next_key;
            
                l_status_plan := CASE l_interv_prescription.flg_time
                                     WHEN pk_procedures_constant.g_flg_time_n THEN
                                      pk_procedures_constant.g_interv_plan_pending
                                     ELSE
                                      CASE sign(extract(DAY FROM(nvl(l_dt_begin, g_sysdate_tstz) - g_sysdate_tstz)))
                                          WHEN 1 THEN
                                           pk_procedures_constant.g_interv_plan_pending
                                          ELSE
                                           pk_procedures_constant.g_interv_plan_req
                                      END
                                 END;
            
                l_rows_out := NULL;
            
                g_error := 'INSERT INTERV_PRESC_PLAN';
                ts_interv_presc_plan.ins(id_interv_presc_plan_in => l_next_plan,
                                         id_interv_presc_det_in  => l_interv_presc_det.id_interv_presc_det,
                                         dt_interv_presc_plan_in => g_sysdate_tstz,
                                         dt_plan_tstz_in         => CASE l_interv_prescription.flg_time
                                                                        WHEN pk_procedures_constant.g_flg_time_n THEN
                                                                         NULL
                                                                        ELSE
                                                                         nvl(l_dt_begin, l_interv_presc_plan.dt_plan_tstz)
                                                                    END,
                                         exec_number_in          => 1,
                                         flg_status_in           => l_status_plan,
                                         rows_out                => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_PLAN',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
            END IF;
        
            BEGIN
                SELECT ic.id_interv_codification
                  INTO l_interv_codification
                  FROM interv_codification ic
                 WHERE ic.id_codification = i_codification(i)
                   AND ic.id_intervention = l_interv_presc_det.id_intervention
                   AND ic.flg_available = pk_procedures_constant.g_available;
            EXCEPTION
                WHEN no_data_found THEN
                    l_interv_codification := NULL;
            END;
        
            IF l_interv_presc_det.id_co_sign_order IS NOT NULL
               OR i_order_type(i) IS NOT NULL
            THEN
                IF i_order_type(i) IS NOT NULL
                THEN
                    IF l_status_det = pk_procedures_constant.g_interv_draft
                    THEN
                        g_error := 'CALL PK_CO_SIGN_API.SET_DRAFT_CO_SIGN_TASK';
                        IF NOT pk_co_sign_api.set_draft_co_sign_task(i_lang               => i_lang,
                                                                     i_prof               => i_prof,
                                                                     i_episode            => i_episode,
                                                                     i_id_co_sign_hist    => l_interv_presc_det.id_co_sign_order,
                                                                     i_id_task_type       => pk_alert_constant.g_task_proc_interv,
                                                                     i_id_task            => i_interv_presc_det(i),
                                                                     i_id_task_group      => i_interv_presc_det(i),
                                                                     i_id_order_type      => i_order_type(i),
                                                                     i_id_prof_created    => i_prof.id,
                                                                     i_id_prof_ordered_by => i_prof_order(i),
                                                                     i_dt_created         => g_sysdate_tstz,
                                                                     i_dt_ordered_by      => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                           i_prof,
                                                                                                                           i_dt_order(i),
                                                                                                                           NULL),
                                                                     o_id_co_sign         => l_id_co_sign,
                                                                     o_id_co_sign_hist    => l_id_co_sign_hist,
                                                                     o_error              => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    ELSE
                        g_error := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                        IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                                       i_prof                   => i_prof,
                                                                       i_episode                => i_episode,
                                                                       i_id_co_sign_hist        => l_interv_presc_det.id_co_sign_order,
                                                                       i_id_task_type           => pk_alert_constant.g_task_proc_interv,
                                                                       i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_add,
                                                                       i_id_task                => i_interv_presc_det(i),
                                                                       i_id_task_group          => i_interv_presc_det(i),
                                                                       i_id_order_type          => i_order_type(i),
                                                                       i_id_prof_created        => i_prof.id,
                                                                       i_id_prof_ordered_by     => i_prof_order(i),
                                                                       i_dt_created             => g_sysdate_tstz,
                                                                       i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                 i_prof,
                                                                                                                                 i_dt_order(i),
                                                                                                                                 NULL),
                                                                       o_id_co_sign             => l_id_co_sign,
                                                                       o_id_co_sign_hist        => l_id_co_sign_hist,
                                                                       o_error                  => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    END IF;
                ELSE
                    g_error := 'CALL PK_CO_SIGN_API.SET_TASK_OUTDATED';
                    IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_episode         => i_episode,
                                                            i_id_co_sign      => NULL,
                                                            i_id_co_sign_hist => l_interv_presc_det.id_co_sign_order,
                                                            i_dt_update       => g_sysdate_tstz,
                                                            o_id_co_sign_hist => l_id_co_sign_hist,
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        
            l_rows_out := NULL;
        
            g_error := 'UPDATE INTERV_PRESC_DET';
            ts_interv_presc_det.upd(id_interv_presc_det_in     => i_interv_presc_det(i),
                                    flg_status_in              => CASE
                                                                      WHEN i_flg_prn(i) = pk_procedures_constant.g_yes THEN
                                                                       pk_procedures_constant.g_interv_sos
                                                                      ELSE
                                                                       l_status_det
                                                                  END,
                                    dt_begin_tstz_in           => l_dt_begin,
                                    dt_order_tstz_in           => pk_date_utils.get_string_tstz(i_lang,
                                                                                                i_prof,
                                                                                                i_dt_order(i),
                                                                                                NULL),
                                    id_order_recurrence_in     => l_order_recurrence,
                                    id_order_recurrence_nin    => FALSE,
                                    flg_prty_in                => i_priority(i),
                                    flg_prn_in                 => i_flg_prn(i),
                                    prn_notes_in               => i_notes_prn(i),
                                    prn_notes_nin              => FALSE,
                                    id_clinical_purpose_in     => i_clinical_purpose(i),
                                    id_clinical_purpose_nin    => FALSE,
                                    clinical_purpose_notes_in  => i_clinical_purpose_notes(i),
                                    clinical_purpose_notes_nin => FALSE,
                                    flg_laterality_in          => i_laterality(i),
                                    id_exec_institution_in     => CASE
                                                                      WHEN i_exec_institution(i) =
                                                                           pk_procedures_constant.g_id_location_hhc THEN
                                                                       i_prof.institution
                                                                      ELSE
                                                                       i_exec_institution(i)
                                                                  END,
                                    flg_location_in            => i_flg_location(i),
                                    notes_in                   => i_notes(i),
                                    notes_nin                  => FALSE,
                                    id_interv_codification_in  => l_interv_codification,
                                    id_not_order_reason_in     => l_not_order_reason,
                                    id_not_order_reason_nin    => FALSE,
                                    id_pat_health_plan_in      => i_health_plan(i),
                                    id_pat_health_plan_nin     => FALSE,
                                    id_pat_exemption_in        => i_exemption(i),
                                    id_pat_exemption_nin       => FALSE,
                                    id_co_sign_order_in        => l_id_co_sign_hist,
                                    id_co_sign_order_nin       => FALSE,
                                    id_prof_last_update_in     => i_prof.id,
                                    id_prof_last_update_nin    => FALSE,
                                    dt_last_update_tstz_in     => g_sysdate_tstz,
                                    dt_last_update_tstz_nin    => FALSE,
                                    diagnosis_notes_in         => CASE
                                                                      WHEN i_diagnosis_notes.exists(i) THEN
                                                                       i_diagnosis_notes(i)
                                                                      ELSE
                                                                       NULL
                                                                  END,
                                    diagnosis_notes_nin        => FALSE,
                                    rows_out                   => l_rows_out);
        
            g_error := 'CALL PROCESS_UPDATE';
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESC_DET',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            IF i_episode IS NOT NULL
            THEN
                IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                        i_prof       => i_prof,
                                        i_id_episode => i_episode,
                                        i_flg_status => l_status_det,
                                        i_id_record  => i_interv_presc_det(i),
                                        i_flg_type   => pk_procedures_constant.g_interv_type_req,
                                        o_error      => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF cardinality(i_diagnosis(i).tbl_diagnosis) > 0
                THEN
                    g_error     := 'VALIDATE DIAGNOSIS';
                    l_diagnosis := table_number();
                    IF i_diagnosis(i).tbl_diagnosis.count > 0
                    THEN
                        FOR j IN i_diagnosis(i).tbl_diagnosis.first .. i_diagnosis(i).tbl_diagnosis.last
                        LOOP
                            IF i_diagnosis(i).tbl_diagnosis(j).id_diagnosis IS NOT NULL
                                OR i_diagnosis(i).tbl_diagnosis(j).id_diagnosis != -1
                            THEN
                                l_diagnosis.extend;
                                l_diagnosis(l_diagnosis.count) := i_diagnosis(i).tbl_diagnosis(j).id_diagnosis;
                            
                                l_tbl_alert_diagnosis.extend;
                                l_tbl_alert_diagnosis(l_tbl_alert_diagnosis.count) := i_diagnosis(i).tbl_diagnosis(j).id_alert_diagnosis;
                            
                                l_tbl_diag_desc.extend();
                                l_tbl_diag_desc(l_tbl_diag_desc.count) := i_diagnosis(i).tbl_diagnosis(j).desc_diagnosis;
                            END IF;
                        END LOOP;
                    END IF;
                
                    --Counts not null records
                    g_error := 'COUNT EPIS_DIAGNOSIS';
                    SELECT COUNT(*)
                      INTO l_count
                      FROM (SELECT /*+opt_estimate(table t rows=1)*/
                             *
                              FROM TABLE(l_diagnosis) t);
                
                    --Cancels previously associated diagnosis that don't apply
                    IF l_count > 0
                    THEN
                        g_error := 'CANCEL MCTD_REQ_DIAGNOSIS 1';
                        UPDATE mcdt_req_diagnosis
                           SET flg_status     = pk_alert_constant.g_cancelled,
                               id_prof_cancel = i_prof.id,
                               dt_cancel_tstz = g_sysdate_tstz
                         WHERE (id_mcdt_req_diagnosis IN
                               (SELECT mrd.id_mcdt_req_diagnosis
                                   FROM mcdt_req_diagnosis mrd
                                   JOIN epis_diagnosis ed
                                     ON ed.id_epis_diagnosis = mrd.id_epis_diagnosis
                                   LEFT JOIN (SELECT /*+ opt_estimate(table t rows=1) */
                                              column_value, rownum AS rn
                                               FROM TABLE(l_tbl_diag_desc) t) t_desc
                                     ON t_desc.column_value = ed.desc_epis_diagnosis
                                  WHERE mrd.id_interv_presc_det = i_interv_presc_det(i)
                                    AND mrd.flg_status != pk_alert_constant.g_cancelled
                                    AND ((t_desc.column_value IS NULL AND ed.desc_epis_diagnosis IS NOT NULL) OR
                                        (mrd.id_alert_diagnosis NOT IN
                                        (SELECT /*+ opt_estimate(table t rows=1) */
                                            *
                                             FROM TABLE(l_tbl_alert_diagnosis)) AND ed.desc_epis_diagnosis IS NULL))));
                    ELSE
                        g_error := 'CANCEL MCTD_REQ_DIAGNOSIS 2';
                        UPDATE mcdt_req_diagnosis
                           SET flg_status     = pk_alert_constant.g_cancelled,
                               id_prof_cancel = i_prof.id,
                               dt_cancel_tstz = g_sysdate_tstz
                         WHERE id_interv_presc_det = i_interv_presc_det(i)
                           AND flg_status != pk_alert_constant.g_cancelled;
                    END IF;
                
                    g_error := 'I_DIAGNOSIS LOOP';
                    IF i_diagnosis(i).tbl_diagnosis IS NOT NULL
                    THEN
                        IF i_diagnosis(i).tbl_diagnosis.count > 0
                        THEN
                            g_error := 'CALL PK_DIAGNOSIS.CONCAT_DIAG_ID';
                            l_epis_diagnosis.extend;
                            l_epis_diagnosis := pk_diagnosis.concat_diag_id(i_lang             => i_lang,
                                                                            i_prof             => i_prof,
                                                                            i_exam_req_det     => NULL,
                                                                            i_analysis_req_det => NULL,
                                                                            i_interv_presc_det => i_interv_presc_det(i),
                                                                            i_type             => 'E');
                        
                            l_count := 0;
                            IF l_epis_diagnosis IS NOT NULL
                               AND l_epis_diagnosis.count > 0
                            THEN
                                --Verifies if diagnosis exist
                                g_error := 'SELECT COUNT(*)';
                                SELECT COUNT(*)
                                  INTO l_count
                                  FROM mcdt_req_diagnosis mrd
                                 WHERE mrd.id_interv_presc_det = i_interv_presc_det(i)
                                   AND nvl(mrd.flg_status, '@') != pk_alert_constant.g_cancelled
                                   AND mrd.id_diagnosis IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                             *
                                                              FROM TABLE(l_diagnosis) t)
                                   AND mrd.id_epis_diagnosis IN
                                       (SELECT /*+opt_estimate (table t rows=1)*/
                                         *
                                          FROM TABLE(l_epis_diagnosis) t);
                            END IF;
                        
                            IF l_count = 0
                            THEN
                                --Inserts new diagnosis code
                                g_error := 'CALL TO PK_DIAGNOSIS.SET_MCDT_REQ_DIAGNOSIS';
                                IF NOT pk_diagnosis.set_mcdt_req_diag_no_commit(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_epis             => i_episode,
                                                                                i_diag             => i_diagnosis(i),
                                                                                i_exam_req         => NULL,
                                                                                i_analysis_req     => NULL,
                                                                                i_interv_presc     => l_interv_presc_det.id_interv_prescription,
                                                                                i_exam_req_det     => NULL,
                                                                                i_analysis_req_det => NULL,
                                                                                i_interv_presc_det => i_interv_presc_det(i),
                                                                                o_error            => o_error)
                                THEN
                                    IF o_error.err_desc IS NOT NULL
                                    THEN
                                        g_error_code := o_error.ora_sqlerrm;
                                        g_error      := o_error.err_action;
                                    
                                        RAISE g_user_exception;
                                    ELSE
                                        RAISE g_other_exception;
                                    END IF;
                                END IF;
                            ELSIF l_count > 0
                                  AND l_count < i_diagnosis(i).tbl_diagnosis.count
                            THEN
                                SELECT DISTINCT t.column_value
                                  BULK COLLECT
                                  INTO l_diagnosis_new
                                  FROM (SELECT /*+opt_estimate(table t rows=1)*/
                                         *
                                          FROM TABLE(l_diagnosis) t) t
                                 WHERE t.column_value NOT IN
                                       (SELECT mrd.id_diagnosis
                                          FROM mcdt_req_diagnosis mrd
                                         WHERE mrd.id_interv_presc_det = i_interv_presc_det(i)
                                           AND mrd.id_epis_diagnosis IN
                                               (SELECT /*+opt_estimate (table t rows=1)*/
                                                 *
                                                  FROM TABLE(l_epis_diagnosis) t)
                                           AND nvl(mrd.flg_status, '@') != pk_alert_constant.g_cancelled);
                            
                                --Inserts new diagnosis code
                                g_error := 'CALL TO PK_DIAGNOSIS.SET_MCDT_REQ_DIAGNOSIS';
                                IF NOT pk_diagnosis.set_mcdt_req_diag_no_commit(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_epis             => i_episode,
                                                                                i_diag             => get_sub_diag_table(i_tbl_diagnosis => i_diagnosis(i),
                                                                                                                         i_sub_diag_list => l_diagnosis_new),
                                                                                i_exam_req         => NULL,
                                                                                i_analysis_req     => NULL,
                                                                                i_interv_presc     => l_interv_presc_det.id_interv_prescription,
                                                                                i_exam_req_det     => NULL,
                                                                                i_analysis_req_det => NULL,
                                                                                i_interv_presc_det => i_interv_presc_det(i),
                                                                                o_error            => o_error)
                                THEN
                                    IF o_error.err_desc IS NOT NULL
                                    THEN
                                        g_error_code := o_error.ora_sqlerrm;
                                        g_error      := o_error.err_action;
                                    
                                        RAISE g_user_exception;
                                    ELSE
                                        RAISE g_other_exception;
                                    END IF;
                                END IF;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            
                IF l_status_det = pk_procedures_constant.g_interv_draft
                THEN
                    g_error := 'CALL PK_SUPPLIES_API_DB.DELETE_SUPPLY_ORDER';
                    IF NOT pk_supplies_external_api_db.delete_supply_order(i_lang        => i_lang,
                                                                           i_prof        => i_prof,
                                                                           i_id_context  => i_interv_presc_det(i),
                                                                           i_flg_context => pk_supplies_constant.g_context_procedure_req,
                                                                           o_error       => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    FOR j IN 1 .. i_supply(i).count
                    LOOP
                        l_supply_dt_request.extend;
                        l_supply_dt_request(j) := i_dt_begin(i);
                    END LOOP;
                
                    g_error := 'CALL PK_SUPPLIES_API_DB.CREATE_SUPPLY_ORDER';
                    IF NOT pk_supplies_api_db.create_supply_order(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_episode           => i_episode,
                                                                  i_supply            => i_supply(i),
                                                                  i_supply_set        => i_supply_set(i),
                                                                  i_supply_qty        => i_supply_qty(i),
                                                                  i_dt_request        => l_supply_dt_request,
                                                                  i_dt_return         => i_dt_return(i),
                                                                  i_id_context        => i_interv_presc_det(i),
                                                                  i_flg_context       => pk_supplies_constant.g_context_procedure_req,
                                                                  i_supply_flg_status => pk_supplies_constant.g_srt_draft,
                                                                  o_supply_request    => l_supply_request,
                                                                  o_error             => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                ELSE
                    FOR j IN 1 .. i_supply(i).count
                    LOOP
                        l_supply_dt_request.extend;
                        l_supply_dt_request(j) := i_dt_begin(i);
                    END LOOP;
                
                    g_error := 'CALL PK_SUPPLIES_EXTERNAL_API_DB.UPDATE_SUPPLY_ORDER';
                    IF NOT pk_supplies_external_api_db.update_supply_order(i_lang           => i_lang,
                                                                           i_prof           => i_prof,
                                                                           i_episode        => i_episode,
                                                                           i_supply         => i_supply(i),
                                                                           i_supply_set     => i_supply_set(i),
                                                                           i_supply_qty     => i_supply_qty(i),
                                                                           i_dt_request     => l_supply_dt_request,
                                                                           i_dt_return      => i_dt_return(i),
                                                                           i_id_context     => i_interv_presc_det(i),
                                                                           i_flg_context    => pk_supplies_constant.g_context_procedure_req,
                                                                           o_supply_request => l_supply_request,
                                                                           o_error          => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    IF i_flg_time(i) != pk_procedures_constant.g_flg_time_n
                    THEN
                        g_error := 'CALL PK_CPOE.SYNC_TASK';
                        IF NOT pk_cpoe.sync_task(i_lang                 => i_lang,
                                                 i_prof                 => i_prof,
                                                 i_episode              => i_episode,
                                                 i_task_type            => pk_alert_constant.g_task_type_procedure,
                                                 i_task_request         => i_interv_presc_det(i),
                                                 i_task_start_timestamp => l_dt_begin,
                                                 o_error                => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    END IF;
                
                END IF;
            ELSE
                FOR j IN 1 .. i_supply(i).count
                LOOP
                    l_supply_dt_request.extend;
                    l_supply_dt_request(j) := i_dt_begin(i);
                END LOOP;
            
                g_error := 'CALL PK_SUPPLIES_EXTERNAL_API_DB.UPDATE_SUPPLY_ORDER';
                IF NOT pk_supplies_external_api_db.update_supply_order(i_lang           => i_lang,
                                                                       i_prof           => i_prof,
                                                                       i_episode        => i_episode,
                                                                       i_supply         => i_supply(i),
                                                                       i_supply_set     => i_supply_set(i),
                                                                       i_supply_qty     => i_supply_qty(i),
                                                                       i_dt_request     => l_supply_dt_request,
                                                                       i_dt_return      => i_dt_return(i),
                                                                       i_id_context     => i_interv_presc_det(i),
                                                                       i_flg_context    => pk_supplies_constant.g_context_procedure_req,
                                                                       o_supply_request => l_supply_request,
                                                                       o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        
            ts_procedures_ea.upd(id_interv_presc_det_in => i_interv_presc_det(i), flg_prn_in => i_flg_prn(i));
        
            g_error             := 'VALIDATE CLINICAL QUESTIONS';
            l_clinical_question := table_number();
            IF i_clinical_question(i).count > 0
            THEN
                FOR j IN i_clinical_question(i).first .. i_clinical_question(i).last
                LOOP
                    l_clinical_question.extend;
                    l_clinical_question(j) := i_clinical_question(i) (j);
                END LOOP;
            END IF;
        
            l_response := table_varchar();
            IF i_response(i).count > 0
            THEN
                FOR j IN i_response(i).first .. i_response(i).last
                LOOP
                    l_response.extend;
                    l_response(j) := i_response(i) (j);
                END LOOP;
            END IF;
        
            l_clinical_question_notes := table_varchar();
            IF i_clinical_question_notes(i).count > 0
            THEN
                FOR j IN i_clinical_question_notes(i).first .. i_clinical_question_notes(i).last
                LOOP
                    l_clinical_question_notes.extend;
                    l_clinical_question_notes(j) := i_clinical_question_notes(i) (j);
                END LOOP;
            END IF;
        
            IF l_clinical_question.count != 0
            THEN
                FOR k IN 1 .. l_clinical_question.count
                LOOP
                    IF l_clinical_question(k) IS NOT NULL
                    THEN
                        IF l_response(k) IS NOT NULL
                        THEN
                            IF instr(l_response(k), '|') = 0
                            THEN
                                l_aux := pk_utils.str_split(l_response(k), ';');
                            ELSE
                                l_aux := pk_utils.str_split(l_response(k), '|');
                            END IF;
                        
                            FOR j IN 1 .. l_aux.count
                            LOOP
                                SELECT COUNT(*)
                                  INTO l_count
                                  FROM (SELECT iqr.*,
                                               row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                          FROM interv_question_response iqr
                                         WHERE iqr.id_interv_presc_det = i_interv_presc_det(i)
                                           AND iqr.id_questionnaire = l_clinical_question(k)
                                           AND (iqr.id_response = to_number(l_aux(j)) OR
                                               dbms_lob.substr(iqr.notes, 3800) = l_clinical_question_notes(k)))
                                 WHERE rn = 1;
                            
                                IF l_count = 0
                                THEN
                                    g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                                    INSERT INTO interv_question_response
                                        (id_interv_question_response,
                                         id_episode,
                                         id_interv_presc_det,
                                         flg_time,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (seq_interv_question_response.nextval,
                                         i_episode,
                                         i_interv_presc_det(i),
                                         pk_procedures_constant.g_interv_cq_on_order,
                                         l_clinical_question(k),
                                         to_number(l_aux(j)),
                                         l_clinical_question_notes(k),
                                         i_prof.id,
                                         g_sysdate_tstz);
                                ELSE
                                    SELECT id_interv_question_response,
                                           id_episode,
                                           id_interv_presc_det,
                                           flg_time,
                                           id_questionnaire,
                                           id_response,
                                           notes,
                                           id_prof_last_update,
                                           dt_last_update_tstz,
                                           create_user,
                                           create_time,
                                           create_institution,
                                           update_user,
                                           update_time,
                                           update_institution
                                      INTO l_interv_question_response
                                      FROM (SELECT iqr.*,
                                                   row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                              FROM interv_question_response iqr
                                             WHERE iqr.id_interv_presc_det = i_interv_presc_det(i)
                                               AND iqr.id_questionnaire = l_clinical_question(k)
                                               AND (iqr.id_response = to_number(l_aux(j)) OR
                                                   dbms_lob.substr(iqr.notes, 3800) = l_clinical_question_notes(k)))
                                     WHERE rn = 1;
                                
                                    g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE_HIST';
                                    INSERT INTO interv_question_response_hist
                                        (dt_interv_question_resp_hist,
                                         id_interv_question_response,
                                         id_episode,
                                         id_interv_presc_det,
                                         flg_time,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (g_sysdate_tstz,
                                         l_interv_question_response.id_interv_question_response,
                                         l_interv_question_response.id_episode,
                                         l_interv_question_response.id_interv_presc_det,
                                         l_interv_question_response.flg_time,
                                         l_interv_question_response.id_questionnaire,
                                         l_interv_question_response.id_response,
                                         l_interv_question_response.notes,
                                         l_interv_question_response.id_prof_last_update,
                                         l_interv_question_response.dt_last_update_tstz);
                                
                                    g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                                    INSERT INTO interv_question_response
                                        (id_interv_question_response,
                                         id_episode,
                                         id_interv_presc_det,
                                         flg_time,
                                         id_questionnaire,
                                         id_response,
                                         notes,
                                         id_prof_last_update,
                                         dt_last_update_tstz)
                                    VALUES
                                        (seq_interv_question_response.nextval,
                                         i_episode,
                                         i_interv_presc_det(i),
                                         pk_procedures_constant.g_interv_cq_on_order,
                                         l_clinical_question(k),
                                         to_number(l_aux(j)),
                                         l_clinical_question_notes(k),
                                         i_prof.id,
                                         g_sysdate_tstz);
                                END IF;
                            END LOOP;
                        ELSE
                            SELECT COUNT(*)
                              INTO l_count
                              FROM (SELECT iqr.*,
                                           row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                      FROM interv_question_response iqr
                                     WHERE iqr.id_interv_presc_det = i_interv_presc_det(i)
                                       AND iqr.id_questionnaire = l_clinical_question(k)
                                       AND (iqr.id_response IS NULL OR
                                           to_char(dbms_lob.substr(iqr.notes, 3800)) = l_clinical_question_notes(k)))
                             WHERE rn = 1;
                        
                            IF l_count = 0
                            THEN
                                g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                                INSERT INTO interv_question_response
                                    (id_interv_question_response,
                                     id_episode,
                                     id_interv_presc_det,
                                     flg_time,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (seq_interv_question_response.nextval,
                                     i_episode,
                                     i_interv_presc_det(i),
                                     pk_procedures_constant.g_interv_cq_on_order,
                                     l_clinical_question(k),
                                     NULL,
                                     l_clinical_question_notes(k),
                                     i_prof.id,
                                     g_sysdate_tstz);
                            ELSE
                                SELECT id_interv_question_response,
                                       id_episode,
                                       id_interv_presc_det,
                                       flg_time,
                                       id_questionnaire,
                                       id_response,
                                       notes,
                                       id_prof_last_update,
                                       dt_last_update_tstz,
                                       create_user,
                                       create_time,
                                       create_institution,
                                       update_user,
                                       update_time,
                                       update_institution
                                  INTO l_interv_question_response
                                  FROM (SELECT iqr.*,
                                               row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                          FROM interv_question_response iqr
                                         WHERE iqr.id_interv_presc_det = i_interv_presc_det(i)
                                           AND iqr.id_questionnaire = l_clinical_question(k)
                                           AND (iqr.id_response IS NULL OR
                                               dbms_lob.substr(iqr.notes, 3800) = l_clinical_question_notes(k)))
                                 WHERE rn = 1;
                            
                                g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE_HIST';
                                INSERT INTO interv_question_response_hist
                                    (dt_interv_question_resp_hist,
                                     id_interv_question_response,
                                     id_episode,
                                     id_interv_presc_det,
                                     flg_time,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (g_sysdate_tstz,
                                     l_interv_question_response.id_interv_question_response,
                                     l_interv_question_response.id_episode,
                                     l_interv_question_response.id_interv_presc_det,
                                     l_interv_question_response.flg_time,
                                     l_interv_question_response.id_questionnaire,
                                     l_interv_question_response.id_response,
                                     l_interv_question_response.notes,
                                     l_interv_question_response.id_prof_last_update,
                                     l_interv_question_response.dt_last_update_tstz);
                            
                                g_error := 'INSERT INTO INTERV_QUESTION_RESPONSE';
                                INSERT INTO interv_question_response
                                    (id_interv_question_response,
                                     id_episode,
                                     id_interv_presc_det,
                                     flg_time,
                                     id_questionnaire,
                                     id_response,
                                     notes,
                                     id_prof_last_update,
                                     dt_last_update_tstz)
                                VALUES
                                    (seq_interv_question_response.nextval,
                                     i_episode,
                                     i_interv_presc_det(i),
                                     pk_procedures_constant.g_interv_cq_on_order,
                                     l_clinical_question(k),
                                     NULL,
                                     l_clinical_question_notes(k),
                                     i_prof.id,
                                     g_sysdate_tstz);
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_user_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              g_error_code,
                                              g_error,
                                              '',
                                              g_package_owner,
                                              g_package_name,
                                              'update_procedure_order',
                                              'U',
                                              '',
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_PROCEDURE_ORDER',
                                              o_error);
            RETURN FALSE;
    END update_procedure_order;

    FUNCTION cancel_procedure_request
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_interv_presc_det IN table_number,
        i_dt_cancel        IN VARCHAR2,
        i_cancel_reason    IN interv_presc_det.id_cancel_reason%TYPE,
        i_cancel_notes     IN interv_presc_det.notes_cancel%TYPE,
        i_prof_order       IN co_sign.id_prof_ordered_by%TYPE,
        i_dt_order         IN VARCHAR2,
        i_order_type       IN co_sign.id_order_type%TYPE,
        i_flg_cancel_event IN VARCHAR2 DEFAULT 'Y',
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_interv_prescription(i_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT ipd.id_interv_prescription,
                   ip.dt_interv_prescription_tstz,
                   ipd.flg_status,
                   ipd.flg_prn,
                   ipd.id_movement,
                   ipd.id_co_sign_order,
                   ip.id_patient,
                   nvl(ip.id_episode, ip.id_episode_origin) id_episode
              FROM interv_presc_det ipd, interv_prescription ip, movement m
             WHERE ipd.id_interv_presc_det = i_interv_presc_det
               AND ipd.id_interv_prescription = ip.id_interv_prescription
               AND ipd.id_movement = m.id_movement(+);
    
        -- Retorna todas as execuções não canceladas
        CURSOR c_interv_plan(i_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT ipp.id_interv_presc_plan
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_det = i_interv_presc_det
               AND ipp.flg_status NOT IN (pk_procedures_constant.g_interv_plan_executed,
                                          pk_procedures_constant.g_interv_plan_expired,
                                          pk_procedures_constant.g_interv_plan_cancel);
    
        --obter datas da 1ra prescrição
        CURSOR c_first_interv_prsc(i_episode IN interv_prescription.id_episode%TYPE) IS
            SELECT dt_first_interv_prsc_tstz
              FROM (SELECT ip.id_episode,
                           MIN(ip.dt_interv_prescription_tstz) dt_interv_prescription_tstz,
                           MAX(dt_first_interv_prsc_tstz) dt_first_interv_prsc_tstz
                      FROM interv_prescription ip
                     INNER JOIN epis_info ei
                        ON ip.id_episode = ei.id_episode
                     WHERE ip.id_episode = i_episode
                       AND ip.flg_status != pk_procedures_constant.g_interv_cancel
                     GROUP BY ip.id_episode)
             WHERE dt_interv_prescription_tstz != dt_first_interv_prsc_tstz
                OR dt_first_interv_prsc_tstz IS NULL;
    
        l_interv_prescription c_interv_prescription%ROWTYPE;
    
        l_flg_status interv_presc_det.flg_status%TYPE;
    
        l_dt_cancel       interv_presc_det.dt_cancel_tstz%TYPE;
        l_cancel_notes    interv_presc_det.notes_cancel%TYPE;
        l_id_co_sign      co_sign.id_co_sign%TYPE;
        l_id_co_sign_hist co_sign_hist.id_co_sign_hist%TYPE;
    
        l_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
        l_num_takes         NUMBER;
    
        l_interv_presc_plan_hist    interv_presc_plan_hist.id_interv_presc_plan_hist%TYPE;
        l_dt_first_interv_prsc_tstz epis_info.dt_first_interv_prsc_tstz%TYPE;
    
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        l_char VARCHAR2(1 CHAR);
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'CALL PK_PROCEDURES_CORE.SET_PROCEDURE_HISTORY';
        IF NOT pk_procedures_core.set_procedure_history(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_interv_prescription => NULL,
                                                        i_interv_presc_det    => i_interv_presc_det,
                                                        o_error               => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        FOR i IN 1 .. i_interv_presc_det.count
        LOOP
        
            g_error := 'COUNT INTERV_PRESC_PLAN';
            SELECT COUNT(*)
              INTO l_num_takes
              FROM interv_presc_plan
             WHERE id_interv_presc_det = i_interv_presc_det(i)
               AND flg_status = pk_procedures_constant.g_interv_plan_executed;
        
            IF l_num_takes = 0
            THEN
                l_flg_status := pk_procedures_constant.g_interv_cancel;
            ELSE
                l_flg_status := pk_procedures_constant.g_interv_interrupted;
            END IF;
        
            IF i_dt_cancel IS NOT NULL
            THEN
                IF i_dt_cancel IS NULL
                THEN
                    l_dt_cancel := g_sysdate_tstz;
                ELSE
                    l_dt_cancel := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_cancel, NULL);
                END IF;
            ELSE
                l_dt_cancel := g_sysdate_tstz;
            END IF;
        
            g_error := 'OPEN C_INTERV_DET';
            OPEN c_interv_prescription(i_interv_presc_det(i));
            FETCH c_interv_prescription
                INTO l_interv_prescription;
            g_found := c_interv_prescription%FOUND;
            CLOSE c_interv_prescription;
        
            -- New validation for ADW
            IF l_dt_cancel < l_interv_prescription.dt_interv_prescription_tstz
            THEN
                l_dt_cancel := l_interv_prescription.dt_interv_prescription_tstz;
            END IF;
        
            --IF no notes are provided and the cancel reason 
            --is the patient death then, fullfills the cancel notes.  
            IF i_cancel_notes IS NULL
               AND i_cancel_reason = 69
            THEN
                l_cancel_notes := pk_message.get_message(i_lang, i_prof, pk_death_registry.c_code_msg_death);
            ELSE
                l_cancel_notes := i_cancel_notes;
            END IF;
        
            IF l_interv_prescription.flg_status != pk_procedures_constant.g_interv_cancel
            THEN
                -- se o detalhe não está cancelado
                -- verifica se o detalhe existe            
                g_error := 'VALIDATE(1)';
                IF NOT g_found
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF l_interv_prescription.flg_prn = pk_procedures_constant.g_yes
                THEN
                    IF l_num_takes > 0
                    THEN
                        l_flg_status := pk_procedures_constant.g_interv_interrupted;
                    ELSE
                        l_flg_status := pk_procedures_constant.g_interv_cancel;
                    END IF;
                ELSE
                    IF l_flg_status = pk_procedures_constant.g_interv_interrupted
                    THEN
                        -- Cancela o registo da Interv_presc_plan não executado ('P' OU 'R')                                 
                        BEGIN
                            SELECT id_interv_presc_plan
                              INTO l_interv_presc_plan
                              FROM interv_presc_plan
                             WHERE id_interv_presc_det = i_interv_presc_det(i)
                               AND flg_status IN (pk_procedures_constant.g_interv_plan_req,
                                                  pk_procedures_constant.g_interv_plan_pending);
                        
                            g_error := 'CALL TO PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION_HIST';
                            IF NOT
                                pk_procedures_core.set_procedure_execution_hist(i_lang                   => i_lang,
                                                                                i_prof                   => i_prof,
                                                                                i_interv_presc_plan      => l_interv_presc_plan,
                                                                                o_interv_presc_plan_hist => l_interv_presc_plan_hist,
                                                                                o_error                  => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            l_rows_out := NULL;
                        
                            g_error := 'UPDATE INTERV_PRESC_PLAN';
                            ts_interv_presc_plan.upd(id_interv_presc_plan_in => l_interv_presc_plan,
                                                     flg_status_in           => pk_procedures_constant.g_interv_plan_not_executed,
                                                     dt_plan_tstz_in         => NULL,
                                                     dt_plan_tstz_nin        => FALSE,
                                                     id_prof_cancel_in       => i_prof.id,
                                                     dt_cancel_tstz_in       => g_sysdate_tstz,
                                                     id_prof_last_update_in  => i_prof.id,
                                                     dt_last_update_tstz_in  => g_sysdate_tstz,
                                                     rows_out                => l_rows_out);
                        
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'INTERV_PRESC_PLAN',
                                                          i_rowids     => l_rows_out,
                                                          o_error      => o_error);
                        
                            -- ALERTAS      
                            -- Retira o alerta de procedimentos                        
                            l_sys_alert_event.id_sys_alert := 6;
                            l_sys_alert_event.id_episode   := l_interv_prescription.id_episode;
                            l_sys_alert_event.id_record    := l_interv_presc_plan;
                        
                            g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT 6';
                            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                                    i_prof            => i_prof,
                                                                    i_sys_alert_event => l_sys_alert_event,
                                                                    o_error           => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            -- Retira o alerta de procedimentos
                            l_sys_alert_event.id_sys_alert := 41;
                        
                            g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT 41';
                            IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                                    i_prof            => i_prof,
                                                                    i_sys_alert_event => l_sys_alert_event,
                                                                    o_error           => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_interv_presc_plan := NULL;
                        END;
                    ELSE
                        -- Cancela todos o registos não executados
                        FOR rec IN c_interv_plan(i_interv_presc_det(i))
                        LOOP
                            g_error := 'CALL TO PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION_HIST';
                            IF NOT
                                pk_procedures_core.set_procedure_execution_hist(i_lang                   => i_lang,
                                                                                i_prof                   => i_prof,
                                                                                i_interv_presc_plan      => rec.id_interv_presc_plan,
                                                                                o_interv_presc_plan_hist => l_interv_presc_plan_hist,
                                                                                o_error                  => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                        
                            l_rows_out := NULL;
                        
                            g_error := 'UPDATE INTERV_PRESC_PLAN';
                            ts_interv_presc_plan.upd(id_interv_presc_plan_in => rec.id_interv_presc_plan,
                                                     flg_status_in           => pk_procedures_constant.g_interv_plan_cancel,
                                                     id_prof_cancel_in       => i_prof.id,
                                                     dt_cancel_tstz_in       => g_sysdate_tstz,
                                                     id_prof_last_update_in  => i_prof.id,
                                                     dt_last_update_tstz_in  => g_sysdate_tstz,
                                                     rows_out                => l_rows_out);
                        
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'INTERV_PRESC_PLAN',
                                                          i_rowids     => l_rows_out,
                                                          o_error      => o_error);
                        
                            g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_CANCEL';
                        
                            IF i_flg_cancel_event = pk_alert_constant.g_yes
                            THEN
                                pk_ia_event_prescription.procedure_cancel(i_id_interv_presc_plan => rec.id_interv_presc_plan);
                            END IF;
                        
                        END LOOP;
                    END IF;
                END IF;
            
                -- cancel co_sign
                IF l_interv_prescription.id_co_sign_order IS NOT NULL
                THEN
                    -- This means that the professional doesn't need co_sign to cancel the procedure
                    g_error := 'CALL PK_CO_SIGN_API.SET_TASK_OUTDATED';
                    IF NOT pk_co_sign_api.set_task_outdated(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_episode         => l_interv_prescription.id_episode,
                                                            i_id_co_sign      => NULL,
                                                            i_id_co_sign_hist => l_interv_prescription.id_co_sign_order,
                                                            i_dt_update       => g_sysdate_tstz,
                                                            o_id_co_sign_hist => l_id_co_sign_hist,
                                                            o_error           => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                IF i_order_type IS NOT NULL
                THEN
                    -- Professional needs co_sign to cancel the procedure
                    g_error := 'CALL PK_CO_SIGN_API.SET_PENDING_CO_SIGN_TASK';
                    IF NOT pk_co_sign_api.set_pending_co_sign_task(i_lang                   => i_lang,
                                                                   i_prof                   => i_prof,
                                                                   i_episode                => l_interv_prescription.id_episode,
                                                                   i_id_task_type           => pk_alert_constant.g_task_proc_interv,
                                                                   i_cosign_def_action_type => pk_co_sign_api.g_cosign_action_def_cancel,
                                                                   i_id_task                => i_interv_presc_det(i),
                                                                   i_id_task_group          => i_interv_presc_det(i),
                                                                   i_id_order_type          => i_order_type,
                                                                   i_id_prof_created        => i_prof.id,
                                                                   i_id_prof_ordered_by     => i_prof_order,
                                                                   i_dt_created             => g_sysdate_tstz,
                                                                   i_dt_ordered_by          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                             i_prof,
                                                                                                                             i_dt_order,
                                                                                                                             NULL),
                                                                   o_id_co_sign             => l_id_co_sign,
                                                                   o_id_co_sign_hist        => l_id_co_sign_hist,
                                                                   o_error                  => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                l_rows_out := NULL;
            
                g_error := 'UPDATE INTERV_PRESC_DET';
                ts_interv_presc_det.upd(id_interv_presc_det_in => i_interv_presc_det(i),
                                        flg_status_in          => l_flg_status,
                                        dt_cancel_tstz_in      => l_dt_cancel,
                                        id_prof_cancel_in      => i_prof.id,
                                        notes_cancel_in        => l_cancel_notes,
                                        notes_cancel_nin       => FALSE,
                                        id_cancel_reason_in    => i_cancel_reason,
                                        id_co_sign_cancel_in   => CASE
                                                                      WHEN i_order_type IS NOT NULL THEN
                                                                       l_id_co_sign_hist
                                                                      ELSE
                                                                       NULL
                                                                  END,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        rows_out               => l_rows_out);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'INTERV_PRESC_DET',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                -- inserir em log de estados
                IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                        i_prof       => i_prof,
                                        i_id_episode => l_interv_prescription.id_episode,
                                        i_flg_status => l_flg_status,
                                        i_id_record  => i_interv_presc_det(i),
                                        i_flg_type   => pk_procedures_constant.g_interv_type_req,
                                        o_error      => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                IF i_dt_cancel IS NULL
                THEN
                    -- Searches the existence of other details of the same order not cancelled
                    BEGIN
                        SELECT DISTINCT 'X'
                          INTO l_char
                          FROM interv_presc_det
                         WHERE id_interv_presc_det != i_interv_presc_det(i)
                           AND id_interv_prescription = l_interv_prescription.id_interv_prescription
                           AND flg_status NOT IN
                               (pk_procedures_constant.g_interv_interrupted, pk_procedures_constant.g_interv_cancel);
                    
                        -- Search for other details in the same order (not cancelled)
                        g_error := 'OPEN C_REQ_FIN';
                        BEGIN
                            SELECT DISTINCT 'X'
                              INTO l_char
                              FROM interv_presc_det
                             WHERE id_interv_presc_det != i_interv_presc_det(i)
                               AND id_interv_prescription = l_interv_prescription.id_interv_prescription
                               AND flg_status != pk_procedures_constant.g_interv_finished;
                        EXCEPTION
                            WHEN no_data_found THEN
                            
                                l_rows_out := NULL;
                            
                                -- If there are no more unfinished details, the procedure order (req) may be concluded
                                g_error := 'UPDATE INTERV_PRESCRIPTION(2)';
                                ts_interv_prescription.upd(id_interv_prescription_in => l_interv_prescription.id_interv_prescription,
                                                           flg_status_in             => l_flg_status,
                                                           dt_cancel_tstz_in         => l_dt_cancel,
                                                           id_prof_cancel_in         => i_prof.id,
                                                           notes_cancel_in           => l_cancel_notes,
                                                           id_prof_last_update_in    => i_prof.id,
                                                           dt_last_update_tstz_in    => g_sysdate_tstz,
                                                           rows_out                  => l_rows_out);
                            
                                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                              i_prof       => i_prof,
                                                              i_table_name => 'INTERV_PRESCRIPTION',
                                                              i_rowids     => l_rows_out,
                                                              o_error      => o_error);
                        END;
                    EXCEPTION
                        WHEN no_data_found THEN
                        
                            l_rows_out := NULL;
                        
                            -- If there are no more cancelled details, the procedure order (req) may be cancelled
                            g_error := 'UPDATE INTERV_PRESCRIPTION';
                            ts_interv_prescription.upd(dt_cancel_tstz_in      => l_dt_cancel,
                                                       id_prof_cancel_in      => i_prof.id,
                                                       flg_status_in          => l_flg_status,
                                                       notes_cancel_in        => l_cancel_notes,
                                                       id_prof_last_update_in => i_prof.id,
                                                       dt_last_update_tstz_in => g_sysdate_tstz,
                                                       where_in               => ' id_interv_prescription = ' ||
                                                                                 l_interv_prescription.id_interv_prescription ||
                                                                                 ' AND flg_status NOT IN (''' ||
                                                                                 pk_procedures_constant.g_interv_interrupted ||
                                                                                 ''', ''' ||
                                                                                 pk_procedures_constant.g_interv_cancel ||
                                                                                 ''')',
                                                       rows_out               => l_rows_out);
                        
                            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                          i_prof       => i_prof,
                                                          i_table_name => 'INTERV_PRESCRIPTION',
                                                          i_rowids     => l_rows_out,
                                                          o_error      => o_error);
                    END;
                END IF;
            
                IF l_interv_prescription.id_movement IS NOT NULL
                THEN
                    BEGIN
                        SELECT DISTINCT 'X'
                          INTO l_char
                          FROM interv_presc_det ipd
                         WHERE ipd.id_interv_presc_det != i_interv_presc_det(i)
                           AND ipd.id_movement = l_interv_prescription.id_movement
                           AND ipd.flg_status NOT IN
                               (pk_procedures_constant.g_interv_interrupted, pk_procedures_constant.g_interv_cancel);
                    EXCEPTION
                        WHEN no_data_found THEN
                        
                            g_error := 'CALL PK_MOVEMENT.CANCEL_MOVEMENT_REQUEST';
                            IF NOT pk_movement.cancel_movement_request(i_lang     => i_lang,
                                                                       i_prof     => i_prof,
                                                                       i_movement => l_interv_prescription.id_movement,
                                                                       i_notes    => l_cancel_notes,
                                                                       o_error    => o_error)
                            THEN
                                RAISE g_other_exception;
                            END IF;
                    END;
                END IF;
            
                g_error := 'CALL PK_SUPPLIES_API_DB.CANCEL_REQUEST';
                IF NOT pk_supplies_api_db.cancel_supply_order(i_lang          => i_lang,
                                                              i_prof          => i_prof,
                                                              i_id_context    => i_interv_presc_det(i),
                                                              i_flg_context   => pk_procedures_constant.g_type_interv,
                                                              i_cancel_reason => i_cancel_reason,
                                                              i_cancel_notes  => i_cancel_notes,
                                                              o_error         => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                g_error := 'CALL PK_ICNP_FO_API_DB.SET_SUGG_STATUS_CANCEL';
                pk_icnp_fo_api_db.set_sugg_status_cancel(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_request_id   => i_interv_presc_det(i),
                                                         i_task_type_id => pk_alert_constant.g_task_proc_interv,
                                                         i_sysdate_tstz => g_sysdate_tstz);
            
                -- AM March 07, 2008 - Updates date for first interv prescription (for ADW)
                g_error := 'OPEN C_REQ';
                OPEN c_first_interv_prsc(l_interv_prescription.id_episode);
                FETCH c_first_interv_prsc
                    INTO l_dt_first_interv_prsc_tstz;
                g_found := c_first_interv_prsc%FOUND;
                CLOSE c_first_interv_prsc;
            
                l_rows_out := NULL;
            
                IF g_found
                THEN
                    ts_epis_info.upd(id_episode_in                 => l_interv_prescription.id_episode,
                                     dt_first_interv_prsc_tstz_in  => l_dt_first_interv_prsc_tstz,
                                     dt_first_interv_prsc_tstz_nin => FALSE,
                                     rows_out                      => l_rows_out);
                ELSE
                    ts_epis_info.upd(id_episode_in                 => l_interv_prescription.id_episode,
                                     dt_first_interv_prsc_tstz_in  => NULL,
                                     dt_first_interv_prsc_tstz_nin => FALSE,
                                     rows_out                      => l_rows_out);
                END IF;
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_INFO',
                                              i_rowids     => l_rows_out,
                                              o_error      => o_error);
            
                g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
                IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                              i_id_episode          => l_interv_prescription.id_episode,
                                              i_pat                 => NULL,
                                              i_prof                => i_prof,
                                              i_prof_cat_type       => pk_prof_utils.get_category(i_lang, i_prof),
                                              i_dt_last_interaction => g_sysdate_tstz,
                                              i_dt_first_obs        => g_sysdate_tstz,
                                              o_error               => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_PROCEDURE_REQUEST',
                                              o_error);
            RETURN FALSE;
    END cancel_procedure_request;

    FUNCTION cancel_procedure_execution
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_interv_presc_plan IN interv_presc_plan.id_interv_presc_plan%TYPE,
        i_dt_plan           IN VARCHAR2,
        i_cancel_reason     IN interv_presc_plan.id_cancel_reason%TYPE,
        i_cancel_notes      IN interv_presc_plan.notes_cancel%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_interv_prescription IS
            SELECT ip.id_interv_prescription,
                   ipp.id_interv_presc_det,
                   ipd.id_intervention,
                   ip.flg_time,
                   ipd.flg_status flg_status_det,
                   ipd.flg_prn,
                   ipd.id_order_recurrence,
                   ipp.id_epis_documentation,
                   ipp.flg_status,
                   ipp.exec_number,
                   nvl(ip.id_episode, ip.id_episode_origin) id_episode
              FROM interv_presc_plan ipp, interv_presc_det ipd, interv_prescription ip
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
               AND ipp.id_interv_presc_det = ipd.id_interv_presc_det
               AND ipd.id_interv_prescription = ip.id_interv_prescription;
    
        l_interv_prescription c_interv_prescription%ROWTYPE;
    
        l_interv_presc_plan      interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_presc_plan_hist interv_presc_plan_hist.id_interv_presc_plan_hist%TYPE;
    
        l_flg_status_det   interv_presc_det.flg_status%TYPE;
        l_flg_status_presc interv_prescription.flg_status%TYPE;
    
        l_count_interv_plan_executed PLS_INTEGER := 0;
    
        l_decrement_order_control BOOLEAN := TRUE;
    
        l_epis_doc_timeout epis_documentation.id_epis_documentation%TYPE;
        l_flg_show         VARCHAR2(50 CHAR);
        l_msg_title        VARCHAR2(200 CHAR);
        l_msg_text         VARCHAR2(200 CHAR);
        l_button           VARCHAR2(50 CHAR);
    
        l_empty_array_number  table_number := table_number();
        l_found_supl_cons     VARCHAR2(1 CHAR);
        l_id_supply           table_number;
        l_id_supply_workflow  table_number;
        l_empty_array_varchar table_varchar := table_varchar();
    
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'OPEN C_INTERV_PRESCRIPTION';
        OPEN c_interv_prescription;
        FETCH c_interv_prescription
            INTO l_interv_prescription;
        CLOSE c_interv_prescription;
    
        -- retorna numero de procedimentos executados
        SELECT COUNT(1)
          INTO l_count_interv_plan_executed
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_det = l_interv_prescription.id_interv_presc_det
           AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed;
    
        IF l_interv_prescription.flg_status != pk_procedures_constant.g_interv_plan_cancel
        THEN
            g_error := 'CALL TO PK_PROCEDURES_CORE.SET_PROCEDURE_EXECUTION_HIST';
            IF NOT pk_procedures_core.set_procedure_execution_hist(i_lang                   => i_lang,
                                                                   i_prof                   => i_prof,
                                                                   i_interv_presc_plan      => i_interv_presc_plan,
                                                                   o_interv_presc_plan_hist => l_interv_presc_plan_hist,
                                                                   o_error                  => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'UPDATE INTERV_PRESC_PLAN';
            ts_interv_presc_plan.upd(id_interv_presc_plan_in => i_interv_presc_plan,
                                     flg_status_in           => pk_procedures_constant.g_interv_plan_cancel,
                                     id_prof_cancel_in       => i_prof.id,
                                     dt_cancel_tstz_in       => g_sysdate_tstz,
                                     notes_cancel_in         => i_cancel_notes,
                                     notes_cancel_nin        => FALSE,
                                     id_cancel_reason_in     => i_cancel_reason,
                                     id_prof_last_update_in  => i_prof.id,
                                     dt_last_update_tstz_in  => g_sysdate_tstz,
                                     rows_out                => l_rows_out);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESC_PLAN',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            g_error := 'CALL TO PK_IA_EVENT_PRESCRIPTION.PROCEDURE_CANCEL';
            pk_ia_event_prescription.procedure_cancel(i_id_interv_presc_plan => i_interv_presc_plan);
        
            IF l_interv_prescription.flg_status IN
               (pk_procedures_constant.g_interv_plan_req, pk_procedures_constant.g_interv_plan_pending)
            THEN
            
                --Retira o alerta de procedimentos, porque ele era um alerta
                g_error                        := 'DELETE FROM SYS_ALERT_EVENT';
                l_sys_alert_event.id_sys_alert := 6;
                l_sys_alert_event.id_episode   := l_interv_prescription.id_episode;
                l_sys_alert_event.id_record    := i_interv_presc_plan;
            
                g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT 6';
                IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        o_error           => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
                --Retira o alerta de procedimentos, porque ele era um alerta
                g_error                        := 'DELETE FROM SYS_ALERT_EVENT';
                l_sys_alert_event.id_sys_alert := 41;
            
                g_error := 'CALL PK_ALERTS.DELETE_SYS_ALERT_EVENT 41';
                IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        o_error           => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
            END IF;
        
            BEGIN
                SELECT ipp.id_interv_presc_plan
                  INTO l_interv_presc_plan
                  FROM interv_presc_plan ipp
                 WHERE ipp.id_interv_presc_det = l_interv_prescription.id_interv_presc_det
                   AND ipp.flg_status = pk_procedures_constant.g_interv_pending;
            EXCEPTION
                WHEN no_data_found THEN
                
                    IF l_interv_prescription.flg_prn = pk_procedures_constant.g_no
                    THEN
                        l_rows_out := NULL;
                    
                        BEGIN
                            SELECT ipp.id_interv_presc_plan
                              INTO l_interv_presc_plan
                              FROM interv_presc_plan ipp
                             WHERE ipp.id_interv_presc_det = l_interv_prescription.id_interv_presc_det
                               AND ipp.flg_status = pk_procedures_constant.g_interv_req;
                        
                            IF i_dt_plan IS NOT NULL
                            THEN
                                g_error := 'UPDATE INTERV_PRESC_PLAN';
                                ts_interv_presc_plan.upd(id_interv_presc_plan_in => l_interv_presc_plan,
                                                         dt_plan_tstz_in         => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                  i_prof,
                                                                                                                  i_dt_plan,
                                                                                                                  NULL),
                                                         id_prof_last_update_in  => i_prof.id,
                                                         dt_last_update_tstz_in  => g_sysdate_tstz,
                                                         rows_out                => l_rows_out);
                            
                                IF NOT
                                    pk_order_recurrence_api_db.update_order_control_last_exec(i_lang              => i_lang,
                                                                                              i_prof              => i_prof,
                                                                                              i_order_recurr_plan => l_interv_prescription.id_order_recurrence,
                                                                                              i_dt_last_processed => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                   i_prof,
                                                                                                                                                   i_dt_plan,
                                                                                                                                                   NULL),
                                                                                              o_error             => o_error)
                                THEN
                                    RAISE g_other_exception;
                                END IF;
                            END IF;
                        
                        EXCEPTION
                            WHEN no_data_found THEN
                            
                                g_error := 'INSERT INTERV_PRESC_PLAN';
                                ts_interv_presc_plan.ins(id_interv_presc_plan_out => l_interv_presc_plan,
                                                         id_interv_presc_det_in   => l_interv_prescription.id_interv_presc_det,
                                                         dt_interv_presc_plan_in  => g_sysdate_tstz,
                                                         dt_plan_tstz_in          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                   i_prof,
                                                                                                                   i_dt_plan,
                                                                                                                   NULL),
                                                         flg_status_in            => pk_procedures_constant.g_interv_plan_pending,
                                                         exec_number_in           => l_interv_prescription.exec_number,
                                                         rows_out                 => l_rows_out);
                            
                                l_decrement_order_control := FALSE;
                        END;
                    
                        --Insere evento na tabela de alertas
                        g_error := 'INSERT INTO SYS_ALERT_EVENT';
                        IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                                i_prof                => i_prof,
                                                                i_sys_alert           => 6,
                                                                i_id_episode          => l_interv_prescription.id_episode,
                                                                i_id_record           => l_interv_presc_plan,
                                                                i_dt_record           => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                       i_prof,
                                                                                                                       i_dt_plan,
                                                                                                                       NULL),
                                                                i_id_professional     => NULL,
                                                                i_id_room             => NULL,
                                                                i_id_clinical_service => NULL,
                                                                i_flg_type_dest       => 'C',
                                                                i_replace1            => 'INTERVENTION.CODE_INTERVENTION.' ||
                                                                                         l_interv_prescription.id_intervention,
                                                                o_error               => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    
                        --Insere evento na tabela de alertas
                        g_error := 'INSERT INTO SYS_ALERT_EVENT';
                        IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                                i_prof                => i_prof,
                                                                i_sys_alert           => 41,
                                                                i_id_episode          => l_interv_prescription.id_episode,
                                                                i_id_record           => l_interv_presc_plan,
                                                                i_dt_record           => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                       i_prof,
                                                                                                                       i_dt_plan,
                                                                                                                       NULL),
                                                                i_id_professional     => NULL,
                                                                i_id_room             => NULL,
                                                                i_id_clinical_service => NULL,
                                                                i_flg_type_dest       => 'C',
                                                                i_replace1            => 'INTERVENTION.CODE_INTERVENTION.' ||
                                                                                         l_interv_prescription.id_intervention,
                                                                o_error               => o_error)
                        THEN
                            RAISE g_other_exception;
                        END IF;
                    ELSE
                        IF l_interv_prescription.flg_prn = pk_procedures_constant.g_no
                        THEN
                            l_rows_out := NULL;
                        
                            -- Se interv_presc_plan pendente existe, então alterar a data do plano
                            g_error := 'UPDATE INTERV_PRESC_PLAN';
                            ts_interv_presc_plan.upd(id_interv_presc_plan_in => l_interv_presc_plan,
                                                     dt_plan_tstz_in         => pk_date_utils.get_string_tstz(i_lang,
                                                                                                              i_prof,
                                                                                                              i_dt_plan,
                                                                                                              NULL),
                                                     id_prof_last_update_in  => i_prof.id,
                                                     dt_last_update_tstz_in  => g_sysdate_tstz,
                                                     rows_out                => l_rows_out);
                        END IF;
                    END IF;
                
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'INTERV_PRESC_PLAN',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
            END;
        
            IF l_decrement_order_control
            THEN
                g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.CANCEL_EXECUTION_ORDER';
                IF NOT pk_order_recurrence_api_db.cancel_execution_order(i_lang              => i_lang,
                                                                         i_prof              => i_prof,
                                                                         i_order_recurr_plan => l_interv_prescription.id_order_recurrence,
                                                                         o_error             => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        
            l_rows_out := NULL;
        
            --AM actualiza a data de um procedimento agendado
            g_error := 'UPDATE INTERV_PRESCRIPTION';
            ts_interv_prescription.upd(dt_begin_tstz_in       => pk_date_utils.get_string_tstz(i_lang,
                                                                                               i_prof,
                                                                                               i_dt_plan,
                                                                                               NULL),
                                       id_prof_last_update_in => i_prof.id,
                                       dt_last_update_tstz_in => g_sysdate_tstz,
                                       where_in               => ' id_interv_prescription = ' ||
                                                                 l_interv_prescription.id_interv_prescription ||
                                                                 ' AND dt_begin_tstz IS NULL',
                                       rows_out               => l_rows_out);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'INTERV_PRESCRIPTION',
                                          i_rowids     => l_rows_out,
                                          o_error      => o_error);
        
            -- AM March 7,2008 Em procedimentos agendados para o próximo episódio ao reagendar no novo episódio
            -- a data da 1ra prescrição é a do reagendamento
            g_error := 'CALL PK_VISIT.UPD_EPIS_INFO_INTERV';
            IF NOT pk_visit.upd_epis_info_interv(i_lang                       => i_lang,
                                                 i_id_episode                 => l_interv_prescription.id_episode,
                                                 i_id_prof                    => i_prof,
                                                 i_dt_first_intervention_prsc => pk_date_utils.date_send_tsz(i_lang,
                                                                                                             g_sysdate_tstz,
                                                                                                             i_prof),
                                                 i_dt_first_intervention_take => NULL,
                                                 i_prof_cat_type              => pk_tools.get_prof_cat(i_prof),
                                                 o_error                      => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'CALL TO SET_FIRST_OBS';
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => l_interv_prescription.id_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => NULL,
                                          i_dt_last_interaction => g_sysdate_tstz,
                                          i_dt_first_obs        => g_sysdate_tstz,
                                          o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            --Deve ser possível cancelar procedimentos e execuções de processos concluídos.
            IF l_interv_prescription.flg_status = pk_procedures_constant.g_interv_plan_executed
            THEN
                -- Retorna os materiais consumidos para o id_interv_presc_plan
                g_error := 'CALL PK_SUPPLIES_EXTERNAL_API_DB.GET_INF_SUPPLY_WORKFLOW';
                IF NOT pk_supplies_external_api_db.get_inf_supply_workflow(i_lang               => i_lang,
                                                                           i_prof               => i_prof,
                                                                           i_id_context         => i_interv_presc_plan,
                                                                           i_flg_context        => pk_supplies_constant.g_context_procedure_exec,
                                                                           i_id_supply          => l_empty_array_number,
                                                                           i_flg_status         => pk_supplies_constant.g_flg_status_can_cancel,
                                                                           o_has_supplies       => l_found_supl_cons,
                                                                           o_id_supply_workflow => l_id_supply_workflow,
                                                                           o_id_supply          => l_id_supply,
                                                                           o_error              => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                -- Altera os estados dos materiais consumidos para requsitado 'A'
                IF l_found_supl_cons = pk_alert_constant.g_yes
                THEN
                    l_empty_array_varchar.extend(l_id_supply_workflow.count);
                
                    g_error := 'CALL PK_SUPPLIES_API_DB.UPDATE_SUPPLY_WORKFLOW_STATUS';
                    IF NOT pk_supplies_api_db.update_supply_workflow_status(i_lang             => i_lang,
                                                                            i_prof             => i_prof,
                                                                            i_supplies         => l_id_supply_workflow,
                                                                            i_id_prof_cancel   => i_prof.id,
                                                                            i_cancel_notes     => i_cancel_notes,
                                                                            i_id_cancel_reason => i_cancel_reason,
                                                                            i_dt_cancel        => g_sysdate_tstz,
                                                                            i_flg_status       => pk_supplies_constant.g_sww_request_local,
                                                                            i_notes            => l_empty_array_varchar,
                                                                            o_error            => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    FOR j IN 1 .. l_id_supply_workflow.count
                    LOOP
                        -- Altera o id_context=id_interv_presc_plan dos materiais consumidos já existentes para o id_interv_presc_plan_hist    
                        g_error := 'call set_supply_workflow_hist';
                        pk_supplies_api_db.set_supply_workflow_hist(i_id_supply_workflow => l_id_supply_workflow(j),
                                                                    i_id_context         => l_interv_presc_plan_hist,
                                                                    i_flg_context        => pk_supplies_constant.g_context_procedure_exec);
                    END LOOP;
                END IF;
            
                -- Cancelar documentação 
                IF l_interv_prescription.id_epis_documentation IS NOT NULL
                THEN
                    g_error := 'CALL PK_TOUCH_OPTION.CANCEL_EPIS_DOC_NO_COMMIT => I_ID_EPIS_DOC: ' ||
                               l_interv_prescription.id_epis_documentation;
                    IF NOT pk_touch_option.cancel_epis_doc_no_commit(i_lang          => i_lang,
                                                                     i_prof          => i_prof,
                                                                     i_id_epis_doc   => l_interv_prescription.id_epis_documentation,
                                                                     i_notes         => i_cancel_notes,
                                                                     i_test          => pk_procedures_constant.g_no,
                                                                     i_cancel_reason => i_cancel_reason,
                                                                     o_flg_show      => l_flg_show,
                                                                     o_msg_title     => l_msg_title,
                                                                     o_msg_text      => l_msg_text,
                                                                     o_button        => l_button,
                                                                     o_error         => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                -- Cancelar documentação de Timemout
                BEGIN
                    SELECT ito.id_epis_documentation
                      INTO l_epis_doc_timeout
                      FROM interv_time_out ito
                     WHERE ito.id_interv_presc_plan = i_interv_presc_plan
                       AND ito.flg_complete = pk_procedures_constant.g_yes;
                
                    g_error := 'CALL PK_TOUCH_OPTION.CANCEL_EPIS_DOC_NO_COMMIT => I_ID_EPIS_DOC: ' ||
                               l_epis_doc_timeout;
                    IF NOT pk_touch_option.cancel_epis_doc_no_commit(i_lang          => i_lang,
                                                                     i_prof          => i_prof,
                                                                     i_id_epis_doc   => l_epis_doc_timeout,
                                                                     i_notes         => i_cancel_notes,
                                                                     i_test          => pk_procedures_constant.g_no,
                                                                     i_cancel_reason => i_cancel_reason,
                                                                     o_flg_show      => l_flg_show,
                                                                     o_msg_title     => l_msg_title,
                                                                     o_msg_text      => l_msg_text,
                                                                     o_button        => l_button,
                                                                     o_error         => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            
                -- Tipo: Única
                IF l_interv_prescription.flg_status_det = pk_procedures_constant.g_interv_finished
                   AND l_interv_prescription.id_order_recurrence IS NULL
                   AND l_interv_prescription.flg_prn IS NULL
                THEN
                    l_flg_status_det   := pk_procedures_constant.g_interv_cancel;
                    l_flg_status_presc := pk_procedures_constant.g_interv_cancel;
                ELSIF l_interv_prescription.flg_status_det = pk_procedures_constant.g_interv_finished
                      AND l_interv_prescription.id_order_recurrence IS NULL
                THEN
                    l_flg_status_det   := pk_procedures_constant.g_interv_pending;
                    l_flg_status_presc := pk_procedures_constant.g_interv_pending;
                ELSIF l_interv_prescription.id_order_recurrence IS NOT NULL
                      AND l_count_interv_plan_executed = 1
                THEN
                    l_flg_status_det   := pk_procedures_constant.g_interv_pending;
                    l_flg_status_presc := pk_procedures_constant.g_interv_pending;
                    -- Tipo: != Única e restantes execuções
                ELSE
                    l_flg_status_det   := pk_procedures_constant.g_interv_exec;
                    l_flg_status_presc := pk_procedures_constant.g_interv_partial;
                END IF;
            
                IF l_flg_status_det IS NOT NULL
                   AND l_flg_status_presc IS NOT NULL
                   AND l_count_interv_plan_executed > 0
                THEN
                    l_rows_out := NULL;
                
                    g_error := 'UPDATE INTERV_PRESC_DET';
                    ts_interv_presc_det.upd(id_interv_presc_det_in => l_interv_prescription.id_interv_presc_det,
                                            flg_status_in          => l_flg_status_det,
                                            id_prof_last_update_in => i_prof.id,
                                            dt_last_update_tstz_in => g_sysdate_tstz,
                                            rows_out               => l_rows_out);
                
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'INTERV_PRESC_DET',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    l_rows_out := NULL;
                
                    g_error := 'UPDATE INTERV_PRESCRIPTION';
                    ts_interv_prescription.upd(id_interv_prescription_in => l_interv_prescription.id_interv_prescription,
                                               flg_status_in             => l_flg_status_presc,
                                               id_prof_last_update_in    => i_prof.id,
                                               dt_last_update_tstz_in    => g_sysdate_tstz,
                                               rows_out                  => l_rows_out);
                
                    t_data_gov_mnt.process_update(i_lang       => i_lang,
                                                  i_prof       => i_prof,
                                                  i_table_name => 'INTERV_PRESCRIPTION',
                                                  i_rowids     => l_rows_out,
                                                  o_error      => o_error);
                
                    -- inserir em log de estados
                    IF NOT t_ti_log.ins_log(i_lang       => i_lang,
                                            i_prof       => i_prof,
                                            i_id_episode => l_interv_prescription.id_episode,
                                            i_flg_status => l_flg_status_det,
                                            i_id_record  => l_interv_prescription.id_interv_presc_det,
                                            i_flg_type   => pk_procedures_constant.g_interv_type_req,
                                            o_error      => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_PROCEDURE_EXECUTION',
                                              o_error);
            RETURN FALSE;
    END cancel_procedure_execution;

    FUNCTION cancel_procedure_doc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_interv_presc_det  IN interv_presc_det.id_interv_presc_det%TYPE,
        i_interv_presc_plan IN interv_presc_plan.id_interv_presc_plan%TYPE,
        i_doc_external      IN doc_external.id_doc_external%TYPE,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_rows_out table_varchar := table_varchar();
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF i_interv_presc_det IS NOT NULL
        THEN
            g_error := 'UPDATE INTERV_MEDIA_ARCHIVE';
            ts_interv_media_archive.upd(flg_status_in          => pk_procedures_constant.g_inactive,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        where_in               => 'id_interv_presc_det = ' || i_interv_presc_det ||
                                                                  ' AND id_doc_external = ' || i_doc_external,
                                        rows_out               => l_rows_out);
        
        ELSE
            g_error := 'UPDATE INTERV_MEDIA_ARCHIVE';
            ts_interv_media_archive.upd(flg_status_in          => pk_procedures_constant.g_inactive,
                                        id_prof_last_update_in => i_prof.id,
                                        dt_last_update_tstz_in => g_sysdate_tstz,
                                        where_in               => 'id_interv_presc_plan = ' || i_interv_presc_plan ||
                                                                  ' AND id_doc_external = ' || i_doc_external,
                                        rows_out               => l_rows_out);
        END IF;
    
        g_error := 'CALL PROCESS_UPDATE';
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'INTERV_MEDIA_ARCHIVE',
                                      i_rowids     => l_rows_out,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_PROCEDURE_DOC',
                                              o_error);
            RETURN FALSE;
    END cancel_procedure_doc;

    FUNCTION get_procedure_selection_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_flg_type     IN VARCHAR2,
        i_flg_filter   IN VARCHAR2 DEFAULT pk_procedures_constant.g_interv_institution,
        i_codification IN codification.id_codification%TYPE,
        i_from_filter  IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_rank         IN NUMBER DEFAULT NULL
    ) RETURN t_tbl_procedures_for_selection IS
    
        PRAGMA AUTONOMOUS_TRANSACTION;
    
        CURSOR c_pat IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_pat c_pat%ROWTYPE;
    
        l_msg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T066');
    
        l_permission VARCHAR2(1 CHAR);
    
        l_list t_tbl_procedures_for_selection;
    
        l_error t_error_out;
    
    BEGIN
    
        IF i_patient IS NOT NULL
        THEN
            g_error := 'OPEN C_PAT';
            OPEN c_pat;
            FETCH c_pat
                INTO l_pat;
            CLOSE c_pat;
        END IF;
    
        g_error := 'SELECT PK_PROCEDURES_UTILS.GET_PROCEDURE_PERMISSION';
        SELECT pk_procedures_utils.get_procedure_permission(i_lang,
                                                            i_prof,
                                                            pk_procedures_constant.g_interv_area_procedures,
                                                            pk_procedures_constant.g_interv_button_create,
                                                            NULL,
                                                            NULL,
                                                            NULL,
                                                            NULL)
          INTO l_permission
          FROM dual;
    
        DELETE FROM tbl_temp;
    
        IF i_flg_filter = pk_procedures_constant.g_interv_institution
        THEN
            g_error := 'GET PROCEDURES 1';
            INSERT INTO tbl_temp
                (num_1, vc_1, vc_2, vc_3, num_2)
                SELECT id_intervention, desc_perform, flg_clinical_question, flg_timeout, rank
                  FROM (SELECT i.id_intervention,
                               decode(i.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                               flg_clinical_question,
                               nvl(i.flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                               coalesce(i_rank,
                                        (SELECT pk_procedures_utils.get_procedure_rank(i_lang,
                                                                                       i_prof,
                                                                                       i.id_intervention,
                                                                                       pk_procedures_constant.g_interv_can_req,
                                                                                       NULL)
                                           FROM dual)) rank
                          FROM (SELECT DISTINCT i.id_intervention,
                                                iis.flg_execute,
                                                decode(iq.id_intervention,
                                                       NULL,
                                                       pk_procedures_constant.g_no,
                                                       decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                                                    pk_procedures_constant.g_yes),
                                                              0,
                                                              pk_procedures_constant.g_yes,
                                                              'M')) flg_clinical_question,
                                                iis.flg_timeout
                                  FROM intervention i
                                  JOIN (SELECT id_intervention, flg_execute, flg_timeout
                                         FROM interv_dep_clin_serv
                                        WHERE flg_type = pk_procedures_constant.g_interv_can_req
                                          AND id_software = i_prof.software
                                          AND id_institution = i_prof.institution) iis
                                    ON i.id_intervention = iis.id_intervention
                                  LEFT JOIN (SELECT id_intervention, concatenate(flg_mandatory) flg_mandatory
                                              FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                                      FROM interv_questionnaire
                                                     WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                                       AND id_institution = i_prof.institution
                                                       AND flg_available = pk_procedures_constant.g_available)
                                             GROUP BY id_intervention) iq
                                    ON iq.id_intervention = i.id_intervention
                                 WHERE instr(i.flg_type, pk_procedures_constant.g_type_interv) > 0
                                   AND i.flg_status = pk_procedures_constant.g_active
                                   AND (iis.flg_execute = pk_procedures_constant.g_yes OR
                                        (iis.flg_execute = pk_procedures_constant.g_no AND
                                        l_permission = pk_procedures_constant.g_yes))
                                   AND (i_patient IS NULL OR
                                        (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                        ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                                        l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                        (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND
                                        nvl(i.age_max, nvl(l_pat.age, 0)) OR l_pat.age IS NULL)))
                                   AND rownum > 0) i); -- to solve performance problem when no records are returned)
        
        ELSIF i_flg_filter = pk_procedures_constant.g_interv_clinical_service
        THEN
            g_error := 'GET PROCEDURES 1';
            INSERT INTO tbl_temp
                (num_1, vc_1, vc_2, vc_3, num_2)
                SELECT id_intervention, desc_perform, flg_clinical_question, flg_timeout, rank
                  FROM (SELECT i.id_intervention,
                               decode(i.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                               flg_clinical_question,
                               nvl(i.flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                               coalesce(i_rank,
                                        (SELECT pk_procedures_utils.get_procedure_rank(i_lang,
                                                                                       i_prof,
                                                                                       i.id_intervention,
                                                                                       i_flg_type,
                                                                                       i.id_dep_clin_serv)
                                           FROM dual)) rank
                          FROM (SELECT DISTINCT i.id_intervention,
                                                idcs.flg_execute,
                                                decode(iq.id_intervention,
                                                       NULL,
                                                       pk_procedures_constant.g_no,
                                                       decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                                                    pk_procedures_constant.g_yes),
                                                              0,
                                                              pk_procedures_constant.g_yes,
                                                              'M')) flg_clinical_question,
                                                idcs.flg_timeout,
                                                idcs.id_dep_clin_serv
                                  FROM intervention i
                                  JOIN (SELECT idcs.id_intervention
                                         FROM interv_dep_clin_serv idcs
                                        WHERE flg_type = pk_procedures_constant.g_interv_can_req
                                          AND idcs.id_software = i_prof.software
                                          AND idcs.id_institution = i_prof.institution) iis
                                    ON i.id_intervention = iis.id_intervention
                                  JOIN interv_dep_clin_serv idcs
                                    ON i.id_intervention = idcs.id_intervention
                                   AND idcs.flg_type = i_flg_type
                                   AND idcs.id_software = i_prof.software
                                   AND idcs.id_institution = i_prof.institution
                                  LEFT JOIN (SELECT id_intervention, concatenate(flg_mandatory) flg_mandatory
                                              FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                                      FROM interv_questionnaire
                                                     WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                                       AND id_institution = i_prof.institution
                                                       AND flg_available = pk_procedures_constant.g_available)
                                             GROUP BY id_intervention) iq
                                    ON iq.id_intervention = i.id_intervention
                                 WHERE instr(i.flg_type, pk_procedures_constant.g_type_interv) > 0
                                   AND i.flg_status = pk_procedures_constant.g_active
                                   AND ((idcs.flg_execute = pk_procedures_constant.g_yes OR
                                        (idcs.flg_execute = pk_procedures_constant.g_no AND
                                        l_permission = pk_procedures_constant.g_yes)) AND
                                        (EXISTS (SELECT 1
                                                   FROM prof_dep_clin_serv pdcs
                                                  WHERE pdcs.id_professional = i_prof.id
                                                    AND pdcs.id_institution = i_prof.institution
                                                    AND pdcs.flg_status = pk_procedures_constant.g_selected
                                                    AND pdcs.id_dep_clin_serv = idcs.id_dep_clin_serv) OR
                                         idcs.id_professional = i_prof.id))
                                   AND (i_patient IS NULL OR
                                        (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                        ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                                        l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                        (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND
                                        nvl(i.age_max, nvl(l_pat.age, 0)) OR l_pat.age IS NULL)))
                                   AND rownum > 0) i); -- to solve performance problem when no records are returned)
        
        ELSIF i_flg_filter IN (pk_procedures_constant.g_interv_medical, pk_procedures_constant.g_interv_nursing)
        THEN
            g_error := 'GET PROCEDURES 2';
            INSERT INTO tbl_temp
                (num_1, vc_1, vc_2, vc_3, num_2)
                SELECT id_intervention, desc_perform, flg_clinical_question, flg_timeout, rank
                  FROM (SELECT i.id_intervention,
                               decode(i.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                               flg_clinical_question,
                               nvl(i.flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                               coalesce(i_rank,
                                        (SELECT pk_procedures_utils.get_procedure_rank(i_lang,
                                                                                       i_prof,
                                                                                       i.id_intervention,
                                                                                       i_flg_type,
                                                                                       i.id_dep_clin_serv)
                                           FROM dual)) rank
                          FROM (SELECT DISTINCT i.id_intervention,
                                                iis.flg_execute,
                                                decode(iq.id_intervention,
                                                       NULL,
                                                       pk_procedures_constant.g_no,
                                                       decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                                                    pk_procedures_constant.g_yes),
                                                              0,
                                                              pk_procedures_constant.g_yes,
                                                              'M')) flg_clinical_question,
                                                iis.flg_timeout,
                                                idcs.id_dep_clin_serv
                                  FROM intervention i
                                  JOIN (SELECT *
                                         FROM interv_dep_clin_serv
                                        WHERE flg_type = pk_procedures_constant.g_interv_can_req
                                          AND id_institution = i_prof.institution
                                          AND id_software = i_prof.software) iis
                                    ON i.id_intervention = iis.id_intervention
                                  JOIN interv_dep_clin_serv idcs
                                    ON i.id_intervention = idcs.id_intervention
                                   AND idcs.flg_type = i_flg_type
                                   AND idcs.id_software = i_prof.software
                                   AND idcs.id_institution = i_prof.institution
                                  JOIN interv_dcs_most_freq_except idmfe
                                    ON idcs.id_interv_dep_clin_serv = idmfe.id_interv_dep_clin_serv
                                  LEFT JOIN (SELECT id_intervention, concatenate(flg_mandatory) flg_mandatory
                                              FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                                      FROM interv_questionnaire
                                                     WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                                       AND id_institution = i_prof.institution
                                                       AND flg_available = pk_procedures_constant.g_available)
                                             GROUP BY id_intervention) iq
                                    ON i.id_intervention = iq.id_intervention
                                 WHERE instr(i.flg_type, pk_procedures_constant.g_type_interv) > 0
                                   AND i.flg_status = pk_procedures_constant.g_active
                                   AND ((idcs.flg_execute = pk_procedures_constant.g_yes OR
                                        (idcs.flg_execute = pk_procedures_constant.g_no AND
                                        l_permission = pk_procedures_constant.g_yes)) AND
                                        (EXISTS (SELECT 1
                                                   FROM prof_dep_clin_serv pdcs
                                                  WHERE pdcs.id_professional = i_prof.id
                                                    AND pdcs.id_institution = i_prof.institution
                                                    AND pdcs.flg_status = pk_procedures_constant.g_selected
                                                    AND pdcs.id_dep_clin_serv = idcs.id_dep_clin_serv) OR
                                         idcs.id_professional = i_prof.id))
                                   AND idmfe.flg_cat_prof = i_flg_filter
                                   AND (i_patient IS NULL OR
                                        (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                        ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                                        l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                        (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND
                                        nvl(i.age_max, nvl(l_pat.age, 0)) OR l_pat.age IS NULL)))
                                   AND rownum > 0) i); -- to solve performance problem when no records are returned)
        
        ELSIF i_flg_filter = pk_procedures_constant.g_interv_complaint
        THEN
            g_error := 'GET PROCEDURES 3';
            NULL;
        ELSIF i_flg_filter = pk_procedures_constant.g_interv_codification
              AND i_codification IS NOT NULL
        THEN
            g_error := 'GET PROCEDURES 4';
            INSERT INTO tbl_temp
                (num_1, vc_1, vc_2, vc_3, num_2)
                SELECT id_intervention, desc_perform, flg_clinical_question, flg_timeout, rank
                  FROM (SELECT i.id_intervention,
                               decode(i.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                               flg_clinical_question,
                               nvl(i.flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                               coalesce(i_rank,
                                        (SELECT pk_procedures_utils.get_procedure_rank(i_lang,
                                                                                       i_prof,
                                                                                       i.id_intervention,
                                                                                       i_flg_type,
                                                                                       NULL)
                                           FROM dual)) rank
                          FROM (SELECT DISTINCT i.id_intervention,
                                                iis.flg_execute,
                                                decode(iq.id_intervention,
                                                       NULL,
                                                       pk_procedures_constant.g_no,
                                                       decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                                                    pk_procedures_constant.g_yes),
                                                              0,
                                                              pk_procedures_constant.g_yes,
                                                              'M')) flg_clinical_question,
                                                iis.flg_timeout
                                  FROM intervention i
                                  JOIN (SELECT *
                                         FROM interv_dep_clin_serv
                                        WHERE flg_type = pk_procedures_constant.g_interv_can_req
                                          AND id_institution = i_prof.institution
                                          AND id_software = i_prof.software) iis
                                    ON i.id_intervention = iis.id_intervention
                                  LEFT JOIN (SELECT id_intervention, concatenate(flg_mandatory) flg_mandatory
                                              FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                                      FROM interv_questionnaire
                                                     WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                                       AND id_institution = i_prof.institution
                                                       AND flg_available = pk_procedures_constant.g_available)
                                             GROUP BY id_intervention) iq
                                    ON i.id_intervention = iq.id_intervention
                                 WHERE instr(i.flg_type, pk_procedures_constant.g_type_interv) > 0
                                   AND i.flg_status = pk_procedures_constant.g_active
                                   AND EXISTS
                                 (SELECT 1
                                          FROM codification_instit_soft cis, interv_codification ic
                                         WHERE cis.id_codification = i_codification
                                           AND cis.id_institution = i_prof.institution
                                           AND cis.id_software = i_prof.software
                                           AND cis.id_codification = ic.id_codification
                                           AND ic.flg_available = pk_procedures_constant.g_available
                                           AND ic.id_intervention = i.id_intervention)
                                   AND (i_patient IS NULL OR
                                        (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                        ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                                        l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                        (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND
                                        nvl(i.age_max, nvl(l_pat.age, 0)) OR l_pat.age IS NULL)))
                                   AND rownum > 0) i); -- to solve performance problem when no records are returned)        
        END IF;
    
        g_error := 'GET CURSOR';
        SELECT t_procedures_for_selection(id_intervention,
                                          desc_intervention,
                                          desc_perform,
                                          flg_clinical_question,
                                          flg_timeout,
                                          flg_laterality_mcdt,
                                          rank,
                                          i_codification)
          BULK COLLECT
          INTO l_list
          FROM (SELECT id_intervention,
                       CASE i_from_filter
                           WHEN pk_alert_constant.g_no THEN
                            pk_procedures_api_db.get_alias_translation(i_lang,
                                                                       i_prof,
                                                                       'INTERVENTION.CODE_INTERVENTION.' ||
                                                                       id_intervention,
                                                                       NULL) ||
                            decode(i_codification,
                                   NULL,
                                   pk_procedures_utils.get_procedure_with_codification(i_lang,
                                                                                       i_prof,
                                                                                       id_intervention,
                                                                                       NULL),
                                   pk_procedures_utils.get_procedure_code(i_lang,
                                                                          i_prof,
                                                                          id_intervention,
                                                                          i_codification,
                                                                          NULL))
                           ELSE
                            NULL
                       END desc_intervention,
                       desc_perform,
                       flg_clinical_question,
                       flg_timeout,
                       CASE i_from_filter
                           WHEN pk_alert_constant.g_no THEN
                            (SELECT pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', id_intervention)
                               FROM dual)
                           ELSE
                            NULL
                       END flg_laterality_mcdt,
                       rank
                  FROM (SELECT num_1 id_intervention,
                               vc_1 desc_perform,
                               vc_2 flg_clinical_question,
                               vc_3 flg_timeout,
                               num_2 rank,
                               row_number() over(PARTITION BY num_1, vc_2 ORDER BY num_2 DESC) rn
                          FROM tbl_temp) e
                 WHERE rn = 1
                 ORDER BY rank, desc_intervention);
    
        COMMIT;
    
        RETURN l_list;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_SELECTION_LIST',
                                              l_error);
            RETURN NULL;
    END get_procedure_selection_list;

    FUNCTION get_procedure_search
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_patient        IN patient.id_patient%TYPE,
        i_procedure_type IN intervention.flg_type%TYPE DEFAULT pk_procedures_constant.g_type_interv,
        i_flg_type       IN interv_dep_clin_serv.flg_type%TYPE DEFAULT pk_procedures_constant.g_interv_can_req,
        i_codification   IN codification.id_codification%TYPE,
        i_dep_clin_serv  IN dep_clin_serv.id_dep_clin_serv%TYPE DEFAULT NULL,
        i_value          IN VARCHAR2
    ) RETURN t_table_procedures_search IS
    
        PRAGMA AUTONOMOUS_TRANSACTION;
    
        CURSOR c_pat IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_pat c_pat%ROWTYPE;
    
        l_inst_dest institution.id_institution%TYPE := NULL;
    
        l_msg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T066');
    
        l_list t_table_procedures_search;
    
        l_error t_error_out;
    
    BEGIN
    
        IF i_patient IS NOT NULL
        THEN
            g_error := 'OPEN C_PAT';
            OPEN c_pat;
            FETCH c_pat
                INTO l_pat;
            CLOSE c_pat;
        END IF;
    
        IF i_dep_clin_serv IS NOT NULL
        THEN
            SELECT DISTINCT d.id_institution
              INTO l_inst_dest
              FROM dep_clin_serv dps
              JOIN department d
                ON d.id_department = dps.id_department
             WHERE dps.id_dep_clin_serv = i_dep_clin_serv;
        END IF;
    
        DELETE FROM tbl_temp;
    
        g_error := 'GET PROCEDURES';
        INSERT INTO tbl_temp
            (num_1, vc_1, vc_2, vc_3, num_2)
            WITH search AS
             (SELECT /*+materialize opt_estimate(table t rows=1)*/
               t.*, pk_lucene_utils.format_column_name(t.code_translation) table_name
                FROM TABLE(pk_translation.get_search_translation(i_lang,
                                                                 i_value,
                                                                 'INTERVENTION.CODE_INTERVENTION OR INTERVENTION_ALIAS.CODE_INTERVENTION_ALIAS')) t
              UNION
              SELECT 'INTERVENTION.CODE_INTERVENTION.' || ic.id_intervention code_translation,
                     pk_translation.get_translation(i_lang, 'INTERVENTION.CODE_INTERVENTION.' || id_intervention) desc_translation,
                     0 position,
                     NULL relevance,
                     'INTERVENTION.CODE_INTERVENTION' table_name
                FROM interv_codification ic
               WHERE translate(upper(to_char(ic.standard_code)), 'ÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÇÄËÏÖÜÑ', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                     '%' || translate(upper(i_value), 'ÁÉÍÓÚÀÈÌÒÙÂÊÎÔÛÃÕÇÄËÏÖÜÑ ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%')
            SELECT id_intervention, desc_perform, flg_clinical_question, flg_timeout, position
              FROM (SELECT i.id_intervention,
                           decode(iis.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                           decode(iq.id_intervention,
                                  NULL,
                                  pk_procedures_constant.g_no,
                                  decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                               pk_procedures_constant.g_yes),
                                         0,
                                         pk_procedures_constant.g_yes,
                                         'M')) flg_clinical_question,
                           flg_timeout,
                           t.position
                      FROM intervention i
                      JOIN (SELECT *
                             FROM search
                            WHERE table_name = 'INTERVENTION.CODE_INTERVENTION') t
                        ON t.code_translation = i.code_intervention
                     INNER JOIN (SELECT *
                                  FROM interv_dep_clin_serv
                                 WHERE (((flg_type = i_flg_type AND
                                       id_institution = coalesce(l_inst_dest, i_prof.institution) AND
                                       id_software IN (pk_alert_constant.g_soft_oris, i_prof.software))))) iis
                        ON i.id_intervention = iis.id_intervention
                      LEFT JOIN (SELECT id_intervention, listagg(flg_mandatory) within GROUP(ORDER BY 1) flg_mandatory
                                  FROM (SELECT /*+ index(iq iq_search01_idx) */
                                        DISTINCT id_intervention, flg_mandatory
                                          FROM interv_questionnaire iq
                                         WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                           AND id_institution = coalesce(l_inst_dest, i_prof.institution)
                                           AND flg_available = pk_procedures_constant.g_available)
                                 GROUP BY id_intervention) iq
                        ON i.id_intervention = iq.id_intervention
                     WHERE t.desc_translation IS NOT NULL
                       AND ((i_procedure_type IS NULL AND
                           instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0) OR
                           instr(i.flg_type, i_procedure_type) > 0)
                       AND i.flg_status = pk_procedures_constant.g_active
                       AND (i_codification IS NULL OR
                           (i_codification IS NOT NULL AND EXISTS
                            (SELECT 1
                                FROM codification_instit_soft cis, interv_codification ic
                               WHERE cis.id_codification = i_codification
                                 AND cis.id_institution = coalesce(l_inst_dest, i_prof.institution)
                                 AND cis.id_software = nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software)
                                 AND cis.id_codification = ic.id_codification
                                 AND ic.flg_available = pk_procedures_constant.g_available
                                 AND ic.id_intervention = i.id_intervention)))
                       AND (i_patient IS NULL OR
                           (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                           ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                           l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                           (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND nvl(i.age_max, nvl(l_pat.age, 0)) OR
                           l_pat.age IS NULL)))
                    UNION
                    SELECT i.id_intervention,
                           decode(iis.flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                           decode(iq.id_intervention,
                                  NULL,
                                  pk_procedures_constant.g_no,
                                  decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                               pk_procedures_constant.g_yes),
                                         0,
                                         pk_procedures_constant.g_yes,
                                         'M')) flg_clinical_question,
                           flg_timeout,
                           t.position
                      FROM intervention i
                     INNER JOIN (SELECT *
                                  FROM interv_dep_clin_serv
                                 WHERE (((flg_type = i_flg_type AND
                                       id_institution = coalesce(l_inst_dest, i_prof.institution) AND
                                       id_software IN (pk_alert_constant.g_soft_oris, i_prof.software))))) iis
                        ON i.id_intervention = iis.id_intervention
                      LEFT JOIN (SELECT id_intervention, listagg(flg_mandatory) within GROUP(ORDER BY 1) flg_mandatory
                                  FROM (SELECT /*+ index(iq iq_search01_idx) */
                                        DISTINCT id_intervention, flg_mandatory
                                          FROM interv_questionnaire iq
                                         WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                           AND id_institution = coalesce(l_inst_dest, i_prof.institution)
                                           AND flg_available = pk_procedures_constant.g_available)
                                 GROUP BY id_intervention) iq
                        ON i.id_intervention = iq.id_intervention
                     INNER JOIN intervention_alias ia
                        ON i.id_intervention = ia.id_intervention
                      JOIN (SELECT *
                             FROM search
                            WHERE table_name = 'INTERVENTION_ALIAS.CODE_INTERVENTION_ALIAS') t
                        ON t.code_translation = ia.code_intervention_alias
                     WHERE t.desc_translation IS NOT NULL
                       AND decode(nvl(ia.id_institution, coalesce(l_inst_dest, i_prof.institution)),
                                  0,
                                  nvl(coalesce(l_inst_dest, i_prof.institution), 0),
                                  nvl(ia.id_institution, coalesce(l_inst_dest, i_prof.institution))) =
                           nvl(coalesce(l_inst_dest, i_prof.institution), 0)
                       AND decode(nvl(ia.id_software, nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software)),
                                  0,
                                  nvl(nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software), 0),
                                  nvl(ia.id_software, nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software))) =
                           nvl(nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software), 0)
                       AND decode(nvl(nvl(ia.id_professional, i_prof.id), 0),
                                  0,
                                  nvl(i_prof.id, 0),
                                  nvl(ia.id_professional, i_prof.id)) = nvl(i_prof.id, 0)
                       AND ((i_procedure_type IS NULL AND
                           instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0) OR
                           instr(i.flg_type, i_procedure_type) > 0)
                       AND i.flg_status = pk_procedures_constant.g_active
                       AND (i_codification IS NULL OR
                           (i_codification IS NOT NULL AND EXISTS
                            (SELECT 1
                                FROM codification_instit_soft cis, interv_codification ic
                               WHERE cis.id_codification = i_codification
                                 AND cis.id_institution = coalesce(l_inst_dest, i_prof.institution)
                                 AND cis.id_software = nvl2(l_inst_dest, pk_alert_constant.g_soft_oris, i_prof.software)
                                 AND cis.id_codification = ic.id_codification
                                 AND ic.flg_available = pk_procedures_constant.g_available
                                 AND ic.id_intervention = i.id_intervention)))
                       AND (i_patient IS NULL OR
                           (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                           ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                           l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                           (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND nvl(i.age_max, nvl(l_pat.age, 0)) OR
                           l_pat.age IS NULL))));
    
        g_error := 'GET CURSOR';
        SELECT t_rec_procedures_search(id_intervention,
                                       desc_intervention,
                                       desc_perform,
                                       flg_clinical_question,
                                       flg_timeout,
                                       flg_laterality_mcdt,
                                       doc_template_intervention)
          BULK COLLECT
          INTO l_list
          FROM (SELECT i.id_intervention,
                       pk_procedures_api_db.get_alias_translation(i_lang,
                                                                  i_prof,
                                                                  'INTERVENTION.CODE_INTERVENTION.' || id_intervention,
                                                                  NULL) ||
                       decode(i_codification,
                              NULL,
                              pk_procedures_utils.get_procedure_with_codification(i_lang, i_prof, id_intervention, NULL),
                              pk_procedures_utils.get_procedure_code(i_lang,
                                                                     i_prof,
                                                                     id_intervention,
                                                                     i_codification,
                                                                     NULL)) desc_intervention,
                       i.desc_perform,
                       i.flg_clinical_question,
                       nvl(i.flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                       pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', i.id_intervention) flg_laterality_mcdt,
                       pk_touch_option.get_doc_template_internal(i_lang,
                                                                 i_prof,
                                                                 NULL,
                                                                 NULL,
                                                                 pk_procedures_constant.g_doc_area_intervention,
                                                                 i.id_intervention) doc_template_intervention
                  FROM (SELECT num_1 id_intervention,
                               vc_1 desc_perform,
                               vc_2 flg_clinical_question,
                               vc_3 flg_timeout,
                               num_2 position,
                               row_number() over(PARTITION BY num_1 ORDER BY num_2) rn
                          FROM tbl_temp) i
                 WHERE rn = 1
                 ORDER BY position, desc_intervention);
    
        COMMIT;
    
        RETURN l_list;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_SEARCH',
                                              l_error);
        
            RETURN NULL;
    END get_procedure_search;

    FUNCTION get_procedure_search
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_patient        IN patient.id_patient%TYPE,
        i_procedure_type IN intervention.flg_type%TYPE DEFAULT pk_procedures_constant.g_type_interv,
        i_flg_type       IN interv_dep_clin_serv.flg_type%TYPE DEFAULT pk_procedures_constant.g_interv_can_req,
        i_codification   IN codification.id_codification%TYPE,
        i_dep_clin_serv  IN dep_clin_serv.id_dep_clin_serv%TYPE DEFAULT NULL,
        i_value          IN VARCHAR2,
        o_flg_show       OUT VARCHAR2,
        o_msg            OUT VARCHAR2,
        o_msg_title      OUT VARCHAR2,
        o_list           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tbl_search t_table_procedures_search := t_table_procedures_search();
    
        l_count PLS_INTEGER;
    
        l_limit sys_config.desc_sys_config%TYPE := pk_sysconfig.get_config('NUM_RECORD_SEARCH', i_prof);
    
    BEGIN
    
        o_flg_show := pk_procedures_constant.g_no;
    
        g_error      := 'GET INTERV';
        l_tbl_search := pk_procedures_core.get_procedure_search(i_lang           => i_lang,
                                                                i_prof           => i_prof,
                                                                i_patient        => i_patient,
                                                                i_procedure_type => i_procedure_type,
                                                                i_flg_type       => i_flg_type,
                                                                i_codification   => i_codification,
                                                                i_dep_clin_serv  => i_dep_clin_serv,
                                                                i_value          => i_value);
    
        l_count := l_tbl_search.count;
    
        IF l_count > l_limit
        THEN
            o_flg_show  := pk_procedures_constant.g_yes;
            o_msg       := pk_search.get_overlimit_message(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_flg_has_action => pk_procedures_constant.g_yes,
                                                           i_limit          => l_limit);
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T011');
        ELSIF l_count = 0
        THEN
            o_flg_show  := pk_procedures_constant.g_yes;
            o_msg       := pk_message.get_message(i_lang, 'COMMON_M117');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T011');
        
            pk_types.open_my_cursor(o_list);
        
            RETURN TRUE;
        END IF;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT /*+opt_estimate(table t rows=1)*/
             id_intervention,
             desc_intervention,
             desc_perform,
             flg_clinical_question,
             flg_timeout,
             flg_laterality_mcdt,
             doc_template_intervention
              FROM TABLE(l_tbl_search) t
             WHERE rownum <= l_limit;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_SEARCH',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_search;

    FUNCTION get_procedure_category_search
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_patient        IN patient.id_patient%TYPE,
        i_procedure_type IN intervention.flg_type%TYPE,
        i_codification   IN codification.id_codification%TYPE,
        o_list           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_pat IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_pat c_pat%ROWTYPE;
    
    BEGIN
    
        g_error := 'OPEN C_PAT';
        OPEN c_pat;
        FETCH c_pat
            INTO l_pat;
        CLOSE c_pat;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT id_category, desc_category
              FROM (SELECT id_interv_category id_category,
                           pk_translation.get_translation(i_lang, code_interv_category) desc_category,
                           rank
                      FROM (SELECT DISTINCT ic.id_interv_category, ic.code_interv_category, ic.rank
                              FROM intervention i,
                                   (SELECT *
                                      FROM interv_dep_clin_serv
                                     WHERE flg_type = pk_procedures_constant.g_interv_can_req
                                       AND id_institution = i_prof.institution
                                       AND id_software = i_prof.software) idcs,
                                   (SELECT *
                                      FROM interv_int_cat
                                     WHERE id_institution = i_prof.institution
                                       AND id_software = i_prof.software) iic,
                                   interv_category ic
                             WHERE ((i_procedure_type IS NULL AND
                                   instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0) OR
                                   instr(i.flg_type, i_procedure_type) > 0)
                               AND i.flg_status = pk_procedures_constant.g_active
                               AND i.id_intervention = idcs.id_intervention
                               AND i.id_intervention = iic.id_intervention
                               AND iic.flg_add_remove = pk_procedures_constant.g_active
                               AND iic.id_interv_category = ic.id_interv_category
                               AND ic.flg_available = pk_procedures_constant.g_available
                               AND (i_codification IS NULL OR
                                   (i_codification IS NOT NULL AND EXISTS
                                    (SELECT 1
                                        FROM codification_instit_soft cis, interv_codification ic
                                       WHERE cis.id_codification = i_codification
                                         AND cis.id_institution = i_prof.institution
                                         AND cis.id_software = i_prof.software
                                         AND cis.id_codification = ic.id_codification
                                         AND ic.flg_available = pk_procedures_constant.g_available
                                         AND ic.id_intervention = i.id_intervention)))
                               AND (i_patient IS NULL OR
                                   (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                                   l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND nvl(i.age_max, nvl(l_pat.age, 0)) OR
                                   l_pat.age IS NULL)))
                               AND rownum > 0))
             WHERE desc_category IS NOT NULL
             ORDER BY rank, desc_category;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_CATEGORY_SEARCH',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_category_search;

    FUNCTION get_procedure_in_category
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_patient         IN patient.id_patient%TYPE,
        i_interv_category IN interv_category.id_interv_category%TYPE,
        i_procedure_type  IN intervention.flg_type%TYPE,
        i_codification    IN codification.id_codification%TYPE,
        o_list            OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_pat IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_pat c_pat%ROWTYPE;
    
        l_msg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T066');
    
    BEGIN
    
        g_error := 'OPEN C_PAT';
        OPEN c_pat;
        FETCH c_pat
            INTO l_pat;
        CLOSE c_pat;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT id_intervention,
                   pk_procedures_api_db.get_alias_translation(i_lang,
                                                              i_prof,
                                                              'INTERVENTION.CODE_INTERVENTION.' || id_intervention,
                                                              NULL) ||
                   pk_procedures_utils.get_procedure_with_codification(i_lang, i_prof, id_intervention, NULL) desc_intervention,
                   decode(flg_execute, pk_procedures_constant.g_no, l_msg, NULL) desc_perform,
                   flg_clinical_question,
                   nvl(flg_timeout, pk_procedures_constant.g_no) flg_timeout,
                   pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', id_intervention) flg_laterality_mcdt,
                   pk_touch_option.get_doc_template_internal(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             NULL,
                                                             pk_procedures_constant.g_doc_area_intervention,
                                                             id_intervention) doc_template_intervention
              FROM (SELECT DISTINCT i.id_intervention,
                                    idcs.flg_execute,
                                    decode(iq.id_intervention,
                                           NULL,
                                           pk_procedures_constant.g_no,
                                           decode(instr(nvl(iq.flg_mandatory, pk_procedures_constant.g_no),
                                                        pk_procedures_constant.g_yes),
                                                  0,
                                                  pk_procedures_constant.g_yes,
                                                  'M')) flg_clinical_question,
                                    idcs.flg_timeout,
                                    (SELECT pk_procedures_utils.get_procedure_rank(i_lang,
                                                                                   i_prof,
                                                                                   i.id_intervention,
                                                                                   NULL,
                                                                                   NULL)
                                       FROM dual) rank
                      FROM intervention i,
                           (SELECT *
                              FROM interv_dep_clin_serv
                             WHERE flg_type = pk_procedures_constant.g_interv_can_req
                               AND id_institution = i_prof.institution
                               AND id_software = i_prof.software) idcs,
                           (SELECT *
                              FROM interv_int_cat
                             WHERE id_institution = i_prof.institution
                               AND id_software = i_prof.software) iic,
                           interv_category ic,
                           (SELECT id_intervention, concatenate(flg_mandatory) flg_mandatory
                              FROM (SELECT DISTINCT id_intervention, flg_mandatory
                                      FROM interv_questionnaire
                                     WHERE flg_time = pk_procedures_constant.g_interv_cq_on_order
                                       AND id_institution = i_prof.institution
                                       AND flg_available = pk_procedures_constant.g_available)
                             GROUP BY id_intervention) iq
                     WHERE ic.id_interv_category = i_interv_category
                       AND ic.flg_available = pk_procedures_constant.g_available
                       AND i.flg_status = pk_procedures_constant.g_active
                       AND i.id_intervention = idcs.id_intervention
                       AND i.id_intervention = iic.id_intervention
                       AND iic.flg_add_remove = pk_procedures_constant.g_active
                       AND ((i_procedure_type IS NULL AND
                           instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0) OR
                           instr(i.flg_type, i_procedure_type) > 0)
                       AND iic.id_interv_category = ic.id_interv_category
                       AND (i_codification IS NULL OR
                           (i_codification IS NOT NULL AND EXISTS
                            (SELECT 1
                                FROM codification_instit_soft cis, interv_codification ic
                               WHERE cis.id_codification = i_codification
                                 AND cis.id_institution = i_prof.institution
                                 AND cis.id_software = i_prof.software
                                 AND cis.id_codification = ic.id_codification
                                 AND ic.flg_available = pk_procedures_constant.g_available
                                 AND ic.id_intervention = i.id_intervention)))
                       AND i.id_intervention = iq.id_intervention(+)
                       AND (i_patient IS NULL OR
                           (((l_pat.gender IS NOT NULL AND coalesce(i.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                           ('I', 'U', 'N', 'C', 'A', 'B', l_pat.gender)) OR l_pat.gender IS NULL OR
                           l_pat.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                           (nvl(l_pat.age, 0) BETWEEN nvl(i.age_min, 0) AND nvl(i.age_max, nvl(l_pat.age, 0)) OR
                           l_pat.age IS NULL)))
                       AND rownum > 0)
             ORDER BY rank, desc_intervention;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_IN_CATEGORY',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_in_category;

    FUNCTION get_procedure_timelineview
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_start_column IN PLS_INTEGER,
        i_end_column   IN PLS_INTEGER,
        i_last_column  IN PLS_INTEGER DEFAULT 9,
        o_task_list    OUT pk_types.cursor_type,
        o_list         OUT pk_types.cursor_type,
        o_count_list   OUT NUMBER,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_start_column PLS_INTEGER;
        l_end_column   PLS_INTEGER;
    
        l_tbl_dt table_timestamp_tstz := table_timestamp_tstz();
    
        l_list t_tbl_procedures_timelineview;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        g_error := 'SELECT T_PROCEDURES_TIMELINEVIEW';
        SELECT t_procedures_timelineview(id_intervention,
                                         id_interv_presc_det,
                                         id_interv_presc_plan,
                                         id_order_recurrence,
                                         flg_prty,
                                         flg_laterality,
                                         id_interv_codification,
                                         id_exec_institution,
                                         flg_status_det,
                                         flg_referral,
                                         flg_status,
                                         dt_interv_prescription,
                                         dt_plan_tstz,
                                         dt_cancel_tstz,
                                         dt_take_tstz,
                                         status_str,
                                         status_msg,
                                         status_icon,
                                         status_flg,
                                         id_episode,
                                         id_patient,
                                         flg_time)
          BULK COLLECT
          INTO l_list
          FROM (SELECT pea.id_intervention,
                       pea.id_interv_presc_det,
                       ipp.id_interv_presc_plan,
                       pea.id_order_recurrence,
                       pea.flg_prty,
                       pea.flg_laterality,
                       pea.id_interv_codification,
                       ipd.id_exec_institution,
                       pea.flg_status_det,
                       pea.flg_referral,
                       ipp.flg_status,
                       pea.dt_interv_prescription,
                       ipp.dt_plan_tstz,
                       ipp.dt_take_tstz,
                       ipp.dt_cancel_tstz,
                       pea.status_str,
                       pea.status_msg,
                       pea.status_icon,
                       pea.status_flg,
                       pea.id_episode,
                       pea.id_patient,
                       pea.flg_time
                  FROM procedures_ea pea,
                       interv_presc_det ipd,
                       (SELECT *
                          FROM interv_presc_plan
                         WHERE flg_status IN (pk_procedures_constant.g_interv_plan_executed,
                                              pk_procedures_constant.g_interv_plan_expired,
                                              pk_procedures_constant.g_interv_plan_cancel)) ipp
                 WHERE pea.id_patient = i_patient
                   AND pea.flg_status_det != pk_procedures_constant.g_interv_draft
                   AND pea.id_interv_presc_det = ipd.id_interv_presc_det
                   AND pea.id_interv_presc_det = ipp.id_interv_presc_det(+));
    
        IF i_start_column IS NULL
           AND i_end_column IS NULL
        THEN
            g_error := 'OPEN CURSOR';
            OPEN o_task_list FOR
                SELECT *
                  FROM (SELECT pea.id_intervention unique_id,
                               pea.id_interv_presc_det,
                               'P' name,
                               'P' flg_type,
                               pk_procedures_api_db.get_alias_translation(i_lang,
                                                                          i_prof,
                                                                          'INTERVENTION.CODE_INTERVENTION.' ||
                                                                          pea.id_intervention,
                                                                          NULL) desc_task,
                               nvl(pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang,
                                                                                          i_prof,
                                                                                          pea.id_order_recurrence),
                                    pk_translation.get_translation(i_lang,
                                                                   'ORDER_RECURR_OPTION.CODE_ORDER_RECURR_OPTION.0')) ||
                                (CASE
                                     WHEN pea.flg_time IN
                                          (pk_procedures_constant.g_flg_time_a, pk_procedures_constant.g_flg_time_h) THEN
                                      ', ' || pk_sysdomain.get_domain('INTERV_PRESCRIPTION.FLG_TIME', pea.flg_time, i_lang)
                                     ELSE
                                      NULL
                                 END) instructions,
                               pea.flg_prty flg_priority,
                               pea.flg_laterality flg_laterality,
                               pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', pea.flg_laterality, i_lang) desc_laterality,
                               pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', pea.id_intervention) flg_laterality_mcdt,
                               pea.id_interv_codification id_mcdt_codification,
                               pk_procedures_utils.get_procedure_codification(i_lang, i_prof, pea.id_interv_codification) id_codification,
                               pk_translation.get_translation(i_lang,
                                                              'CODIFICATION.CODE_CODIFICATION.' ||
                                                              pk_procedures_utils.get_procedure_codification(i_lang,
                                                                                                             i_prof,
                                                                                                             pea.id_interv_codification)) codification,
                               pea.id_exec_institution id_exec_institution,
                               pk_utils.get_institution_name(i_lang, pea.id_exec_institution) exec_institution,
                               pk_procedures_utils.get_procedure_timeout(i_lang, i_prof, pea.id_intervention) flg_timeout,
                               pea.flg_status_det task_flg_status,
                               pk_utils.get_status_string(i_lang,
                                                          i_prof,
                                                          pea.status_str,
                                                          pea.status_msg,
                                                          pea.status_icon,
                                                          pea.status_flg) status_string,
                               pk_procedures_utils.get_procedure_permission(i_lang,
                                                                            i_prof,
                                                                            pk_procedures_constant.g_interv_area_procedures,
                                                                            pk_procedures_constant.g_interv_button_ok,
                                                                            pea.id_episode,
                                                                            pea.id_interv_presc_det,
                                                                            NULL,
                                                                            decode(pea.id_episode,
                                                                                   i_episode,
                                                                                   pk_procedures_constant.g_yes,
                                                                                   pk_procedures_constant.g_no)) avail_button_ok,
                               pk_procedures_utils.get_procedure_permission(i_lang,
                                                                            i_prof,
                                                                            pk_procedures_constant.g_interv_area_procedures,
                                                                            pk_procedures_constant.g_interv_button_cancel,
                                                                            pea.id_episode,
                                                                            pea.id_interv_presc_det,
                                                                            NULL,
                                                                            decode(pea.id_episode,
                                                                                   i_episode,
                                                                                   pk_procedures_constant.g_yes,
                                                                                   pk_procedures_constant.g_no)) avail_button_cancel,
                               pk_procedures_utils.get_procedure_permission(i_lang,
                                                                            i_prof,
                                                                            pk_procedures_constant.g_interv_area_procedures,
                                                                            pk_procedures_constant.g_interv_button_edit,
                                                                            pea.id_episode,
                                                                            pea.id_interv_presc_det,
                                                                            NULL,
                                                                            decode(pea.id_episode,
                                                                                   i_episode,
                                                                                   pk_procedures_constant.g_yes,
                                                                                   pk_procedures_constant.g_no)) avail_button_edit,
                               pk_procedures_utils.get_procedure_permission(i_lang,
                                                                            i_prof,
                                                                            pk_procedures_constant.g_interv_area_procedures,
                                                                            pk_procedures_constant.g_interv_button_confirmation,
                                                                            pea.id_episode,
                                                                            pea.id_interv_presc_det,
                                                                            NULL,
                                                                            decode(pea.id_episode,
                                                                                   i_episode,
                                                                                   pk_procedures_constant.g_yes,
                                                                                   pk_procedures_constant.g_no)) avail_button_confirmation,
                               decode(pea.flg_status_det,
                                      pk_procedures_constant.g_interv_req,
                                      row_number()
                                      over(ORDER BY decode(nvl(pea.flg_referral, pk_procedures_constant.g_flg_referral_a),
                                                  pk_procedures_constant.g_flg_referral_a,
                                                  pk_sysdomain.get_rank(i_lang,
                                                                        'INTERV_PRESC_DET.FLG_STATUS',
                                                                        pea.flg_status_det),
                                                  pk_sysdomain.get_rank(i_lang,
                                                                        'INTERV_PRESC_DET.FLG_REFERRAL',
                                                                        pea.flg_referral)),
                                           pea.dt_interv_prescription),
                                      row_number()
                                      over(ORDER BY decode(nvl(pea.flg_referral, pk_procedures_constant.g_flg_referral_a),
                                                  pk_procedures_constant.g_flg_referral_a,
                                                  pk_sysdomain.get_rank(i_lang,
                                                                        'INTERV_PRESC_DET.FLG_STATUS',
                                                                        pea.flg_status_det),
                                                  pk_sysdomain.get_rank(i_lang,
                                                                        'INTERV_PRESC_DET.FLG_REFERRAL',
                                                                        pea.flg_referral)),
                                           pea.dt_interv_prescription DESC)) rank,
                               decode((SELECT 1
                                        FROM interv_question_response iqr
                                       WHERE iqr.id_interv_presc_det = pea.id_interv_presc_det
                                         AND rownum = 1),
                                      1,
                                      'Y',
                                      'N') flg_clinical_question
                          FROM TABLE(l_list) pea
                         WHERE pea.id_interv_presc_det = (SELECT id_interv_presc_det
                                                            FROM (SELECT *
                                                                    FROM (SELECT rank() over(PARTITION BY id_intervention, id_patient ORDER BY pk_sysdomain.get_rank(i_lang, 'INTERV_PRESC_DET.FLG_STATUS', flg_status_det), dt_plan ASC NULLS LAST, dt_begin_det ASC NULLS LAST, dt_interv_presc_det ASC NULLS LAST, dt_interv_prescription ASC NULLS LAST) rank,
                                                                                 id_interv_presc_det,
                                                                                 id_intervention,
                                                                                 id_patient,
                                                                                 1 AS rank_status -- higher priority when compared to closed states
                                                                            FROM procedures_ea
                                                                           WHERE flg_status_det NOT IN
                                                                                 (pk_procedures_constant.g_interv_draft,
                                                                                  pk_procedures_constant.g_interv_finished,
                                                                                  pk_procedures_constant.g_interv_not_ordered,
                                                                                  pk_procedures_constant.g_interv_expired,
                                                                                  pk_procedures_constant.g_interv_cancel)
                                                                             AND id_patient = i_patient
                                                                          UNION ALL
                                                                          SELECT rank() over(PARTITION BY id_intervention, id_patient ORDER BY - 1 DESC, dt_plan DESC NULLS LAST, dt_begin_det DESC NULLS LAST, dt_interv_presc_det DESC NULLS LAST, dt_interv_prescription DESC NULLS LAST) rank,
                                                                                 id_interv_presc_det,
                                                                                 id_intervention,
                                                                                 id_patient,
                                                                                 2 AS rank_status -- lower priority when compared to ongoing states
                                                                            FROM procedures_ea
                                                                           WHERE flg_status_det IN
                                                                                 (pk_procedures_constant.g_interv_finished,
                                                                                  pk_procedures_constant.g_interv_not_ordered,
                                                                                  pk_procedures_constant.g_interv_expired,
                                                                                  pk_procedures_constant.g_interv_cancel)
                                                                             AND id_patient = i_patient)
                                                                   WHERE rank = 1
                                                                   ORDER BY rank_status)
                                                           WHERE id_intervention = pea.id_intervention
                                                             AND id_patient = pea.id_patient
                                                             AND rownum = 1)
                         GROUP BY pea.id_intervention,
                                  pea.id_interv_presc_det,
                                  pea.id_order_recurrence,
                                  pea.flg_prty,
                                  pea.flg_laterality,
                                  pea.id_interv_codification,
                                  pea.id_exec_institution,
                                  pea.flg_status_det,
                                  pea.flg_referral,
                                  pea.dt_interv_prescription,
                                  pea.status_str,
                                  pea.status_msg,
                                  pea.status_icon,
                                  pea.status_flg,
                                  pea.id_episode,
                                  pea.id_patient,
                                  pea.flg_time)
                 ORDER BY rank, desc_task;
        ELSE
            pk_types.open_my_cursor(o_task_list);
        END IF;
    
        SELECT DISTINCT COUNT(DISTINCT pk_date_utils.trunc_insttimezone(i_prof,
                                                               coalesce(pea.dt_cancel_tstz,
                                                                        pea.dt_take_tstz,
                                                                        pea.dt_plan_tstz,
                                                                        pea.dt_interv_prescription),
                                                               'MI'))
          INTO o_count_list
          FROM TABLE(l_list) pea
         WHERE pea.id_interv_presc_plan IS NOT NULL;
    
        IF i_start_column IS NULL
           AND o_count_list > 0
           AND (o_count_list - (i_last_column - 1)) > 0
        THEN
            l_start_column := o_count_list - (i_last_column - 1);
        ELSIF (i_start_column IS NULL AND o_count_list <= 0)
        THEN
            l_start_column := 1;
        ELSE
            l_start_column := nvl(i_start_column, 1);
        END IF;
    
        IF i_end_column IS NULL
           AND o_count_list >= 1
        THEN
            l_end_column := o_count_list;
        ELSIF i_end_column IS NULL
              AND o_count_list <= 0
        THEN
            l_end_column := 1;
        ELSE
            l_end_column := nvl(i_end_column, 1);
        END IF;
    
        SELECT dt
          BULK COLLECT
          INTO l_tbl_dt
          FROM (SELECT dense_rank() over(PARTITION BY 'P' ORDER BY dt) rn, t.*
                  FROM (SELECT DISTINCT pk_date_utils.trunc_insttimezone(i_prof,
                                                                         coalesce(dt_cancel_tstz,
                                                                                  dt_take_tstz,
                                                                                  dt_plan_tstz,
                                                                                  dt_interv_prescription),
                                                                         'MI') dt
                          FROM TABLE(l_list) pea
                         WHERE pea.id_interv_presc_plan IS NOT NULL) t)
         WHERE rn BETWEEN l_start_column AND l_end_column;
    
        g_error := 'OPEN CURSOR';
        OPEN o_list FOR
            SELECT /*+opt_estimate(table t rows=1)*/
             pea.id_intervention unique_id,
             pea.id_interv_presc_det req_id,
             pea.id_interv_presc_plan exec_id,
             'P' name,
             dense_rank() over(PARTITION BY pea.id_interv_presc_det ORDER BY pea.id_interv_presc_plan) order_num,
             REPLACE(pk_date_utils.get_month_day(i_lang, i_prof, g_sysdate_tstz), ' ', '-') AS today,
             REPLACE(pk_date_utils.get_month_day(i_lang,
                                                 i_prof,
                                                 coalesce(pea.dt_cancel_tstz,
                                                          ipp.start_time,
                                                          pea.dt_take_tstz,
                                                          pea.dt_plan_tstz,
                                                          pea.dt_interv_prescription)),
                     ' ',
                     '-') AS dt_begin,
             pk_date_utils.dt_chr_hour_tsz(i_lang,
                                           coalesce(pea.dt_cancel_tstz,
                                                    ipp.start_time,
                                                    pea.dt_take_tstz,
                                                    pea.dt_plan_tstz,
                                                    pea.dt_interv_prescription),
                                           i_prof.institution,
                                           i_prof.software) AS hr_begin,
             extract(YEAR FROM
                     coalesce(pea.dt_cancel_tstz, pea.dt_take_tstz, pea.dt_plan_tstz, pea.dt_interv_prescription)) YEAR,
             pea.flg_status flg_status,
             pk_sysdomain.get_img(i_lang, 'INTERV_PRESC_PLAN.FLG_STATUS', pea.flg_status) icon_name,
             pk_date_utils.date_send_tsz(i_lang,
                                         coalesce(pea.dt_cancel_tstz,
                                                  ipp.start_time,
                                                  pea.dt_take_tstz,
                                                  pea.dt_plan_tstz,
                                                  pea.dt_interv_prescription),
                                         i_prof) dt_ord,
             pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof) dt_server
            
              FROM (SELECT pk_date_utils.trunc_insttimezone(i_prof,
                                                            coalesce(dt_cancel_tstz,
                                                                     dt_take_tstz,
                                                                     dt_plan_tstz,
                                                                     dt_interv_prescription),
                                                            'MI') dt,
                           id_intervention,
                           id_interv_presc_det,
                           id_interv_presc_plan,
                           flg_status,
                           dt_interv_prescription,
                           dt_plan_tstz,
                           dt_take_tstz,
                           dt_cancel_tstz,
                           status_str,
                           status_msg,
                           status_icon,
                           status_flg
                      FROM TABLE(l_list)
                     WHERE id_interv_presc_plan IS NOT NULL) pea
             INNER JOIN interv_presc_plan ipp
                ON pea.id_interv_presc_plan = ipp.id_interv_presc_plan, TABLE(l_tbl_dt) t
             WHERE pea.dt = t.column_value
             ORDER BY dt_ord;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TIMELINEVIEW',
                                              o_error);
            pk_types.open_my_cursor(o_task_list);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_timelineview;

    FUNCTION get_procedure_questionnaire
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_patient       IN patient.id_patient%TYPE,
        i_episode       IN episode.id_episode%TYPE,
        i_intervention  IN intervention.id_intervention%TYPE,
        i_flg_time      IN VARCHAR2,
        i_dep_clin_serv IN dep_clin_serv.id_dep_clin_serv%TYPE DEFAULT NULL,
        o_list          OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_patient IS
            SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
              FROM patient
             WHERE id_patient = i_patient;
    
        l_patient c_patient%ROWTYPE;
    
        l_inst_dest institution.id_institution%TYPE := NULL;
    
    BEGIN
    
        g_error := 'OPEN C_PATIENT';
        OPEN c_patient;
        FETCH c_patient
            INTO l_patient;
        CLOSE c_patient;
    
        IF i_dep_clin_serv IS NOT NULL
        THEN
            SELECT d.id_institution
              INTO l_inst_dest
              FROM dep_clin_serv dps
              JOIN department d
                ON d.id_department = dps.id_department
             WHERE dps.id_dep_clin_serv = i_dep_clin_serv;
        END IF;
    
        g_error := 'OPEN O_LIST BY ID_INTERVENTION';
        OPEN o_list FOR
            SELECT q.id_intervention,
                   q.id_questionnaire,
                   q.id_questionnaire_parent,
                   q.id_response_parent,
                   pk_mcdt.get_questionnaire_alias(i_lang,
                                                   i_prof,
                                                   'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' || q.id_questionnaire) desc_questionnaire,
                   q.flg_type,
                   q.flg_mandatory,
                   q.flg_copy flg_apply_to_all,
                   q.id_unit_measure,
                   CASE
                        WHEN l_inst_dest IS NOT NULL THEN
                         pk_mcdt.get_questionnaire_response(i_lang,
                                                            i_prof,
                                                            i_patient,
                                                            q.id_questionnaire,
                                                            i_intervention,
                                                            NULL,
                                                            i_flg_time,
                                                            'P',
                                                            l_inst_dest)
                        ELSE
                         pk_mcdt.get_questionnaire_response(i_lang,
                                                            i_prof,
                                                            i_patient,
                                                            q.id_questionnaire,
                                                            i_intervention,
                                                            NULL,
                                                            i_flg_time,
                                                            'P')
                    END desc_response,
                   decode(q.flg_validation,
                          pk_procedures_constant.g_yes,
                          --if date then should return the serialized value stored in the field "notes"
                          decode(instr(q.flg_type, 'D'), 0, to_char(iqr.id_response), to_char(iqr.notes)),
                          NULL) episode_id_response,
                   decode(q.flg_validation,
                          pk_procedures_constant.g_yes,
                          decode(dbms_lob.getlength(iqr.notes),
                                 NULL,
                                 to_clob(pk_mcdt.get_response_alias(i_lang,
                                                                    i_prof,
                                                                    'RESPONSE.CODE_RESPONSE.' || iqr.id_response)),
                                 pk_procedures_utils.get_procedure_response(i_lang, i_prof, iqr.notes)),
                          to_clob('')) episode_desc_response
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention = i_intervention
                       AND iq.flg_time = i_flg_time
                       AND iq.id_institution = nvl(l_inst_dest, i_prof.institution)
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q,
                   (SELECT id_questionnaire, id_response, notes
                      FROM (SELECT iqr.id_questionnaire,
                                   pk_procedures_utils.get_procedure_episode_response(i_lang,
                                                                                      i_prof,
                                                                                      i_episode,
                                                                                      iqr.id_questionnaire) id_response,
                                   iqr.notes,
                                   row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC) rn
                              FROM interv_question_response iqr
                             WHERE iqr.id_episode = i_episode)
                     WHERE rn = 1) iqr
             WHERE q.id_questionnaire = iqr.id_questionnaire(+)
             ORDER BY q.rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_QUESTIONNAIRE',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_questionnaire;

    FUNCTION get_procedure_codification_det
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_interv_presc_det IN table_number,
        o_list             OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        OPEN o_list FOR
            SELECT ipd.id_interv_presc_det,
                   pk_translation.get_translation(i_lang,
                                                  'CODIFICATION.CODE_CODIFICATION.' ||
                                                  pk_procedures_utils.get_procedure_codification(i_lang,
                                                                                                 i_prof,
                                                                                                 ipd.id_interv_codification)) desc_codification,
                   ipd.id_interv_codification,
                   ipd.flg_referral,
                   pk_diagnosis.concat_diag(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof) desc_diagnosis,
                   ipd.flg_prty priority,
                   pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', ipd.flg_prty, NULL) desc_priority,
                   ipd.id_exec_institution,
                   pk_translation.get_translation(i_lang, 'AB_INSTITUTION.CODE_INSTITUTION.' || ipd.id_exec_institution) desc_institution,
                   ipd.flg_laterality flg_laterality,
                   pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang) desc_laterality,
                   pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', ipd.id_intervention) flg_laterality_mcdt,
                   pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY',
                                           pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', ipd.id_intervention),
                                           i_lang) desc_laterality_mcdt
              FROM interv_presc_det ipd
             WHERE ipd.id_interv_presc_det IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                *
                                                 FROM TABLE(i_interv_presc_det) t);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_CODIFICATION_DET',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_codification_det;

    FUNCTION get_procedure_detail
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_episode                   IN episode.id_episode%TYPE,
        i_interv_presc_det          IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report                IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        o_interv_order              OUT t_tbl_procedures_detail,
        o_interv_co_sign            OUT pk_types.cursor_type,
        o_interv_clinical_questions OUT t_tbl_procedures_cq,
        o_interv_execution          OUT t_tbl_procedures_execution,
        o_interv_execution_images   OUT pk_types.cursor_type,
        o_interv_doc                OUT pk_types.cursor_type,
        o_interv_review             OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_interv_co_sign          t_tbl_procedures_co_sign;
        l_interv_execution_images t_tbl_procedures_execution_images;
        l_interv_doc              t_tbl_procedures_doc;
        l_interv_review           t_tbl_procedures_review;
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                             pk_message.get_message(i_lang,
                                                                                                                    i_prof,
                                                                                                                    pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                             '</b> ';
        END LOOP;
    
        g_error        := 'OPEN O_INTERV_ORDER';
        o_interv_order := pk_procedures_core.tf_get_procedure_order(i_lang             => i_lang,
                                                                    i_prof             => i_prof,
                                                                    i_episode          => i_episode,
                                                                    i_interv_presc_det => i_interv_presc_det,
                                                                    i_flg_report       => i_flg_report,
                                                                    i_aa_code_messages => aa_code_messages);
    
        g_error          := 'OPEN O_INTERV_CO_SIGN';
        l_interv_co_sign := pk_procedures_core.tf_get_procedure_co_sign(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_episode          => i_episode,
                                                                        i_interv_presc_det => i_interv_presc_det,
                                                                        i_flg_report       => i_flg_report,
                                                                        i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_co_sign FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.id_interv_presc_det, t.registry, t.flg_status, t.co_sign_notes
              FROM TABLE(l_interv_co_sign) t;
    
        g_error                     := 'OPEN O_INTERV_CLINICAL_QUESTIONS';
        o_interv_clinical_questions := pk_procedures_core.tf_get_procedure_cq(i_lang             => i_lang,
                                                                              i_prof             => i_prof,
                                                                              i_episode          => i_episode,
                                                                              i_interv_presc_det => i_interv_presc_det,
                                                                              i_flg_report       => i_flg_report,
                                                                              i_aa_code_messages => aa_code_messages);
    
        g_error            := 'OPEN O_INTERV_EXECUTION';
        o_interv_execution := pk_procedures_core.tf_get_procedure_execution(i_lang             => i_lang,
                                                                            i_prof             => i_prof,
                                                                            i_episode          => i_episode,
                                                                            i_interv_presc_det => i_interv_presc_det,
                                                                            i_flg_report       => i_flg_report,
                                                                            i_aa_code_messages => aa_code_messages);
    
        g_error                   := 'OPEN O_INTERV_EXECUTION_IMAGES';
        l_interv_execution_images := pk_procedures_core.tf_get_procedure_execution_images(i_lang             => i_lang,
                                                                                          i_prof             => i_prof,
                                                                                          i_episode          => i_episode,
                                                                                          i_interv_presc_det => i_interv_presc_det,
                                                                                          i_flg_report       => i_flg_report,
                                                                                          i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_execution_images FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_execution_images) t;
    
        g_error      := 'OPEN O_INTERV_DOC';
        l_interv_doc := pk_procedures_core.tf_get_procedure_doc(i_lang             => i_lang,
                                                                i_prof             => i_prof,
                                                                i_episode          => i_episode,
                                                                i_interv_presc_det => i_interv_presc_det,
                                                                i_flg_report       => i_flg_report,
                                                                i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_doc FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_doc) t;
    
        g_error         := 'OPEN O_INTERV_REVIEW';
        l_interv_review := pk_procedures_core.tf_get_procedure_review(i_lang             => i_lang,
                                                                      i_prof             => i_prof,
                                                                      i_episode          => i_episode,
                                                                      i_interv_presc_det => i_interv_presc_det,
                                                                      i_flg_report       => i_flg_report,
                                                                      i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_review FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_review) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DETAIL',
                                              o_error);
            pk_types.open_my_cursor(o_interv_co_sign);
            pk_types.open_my_cursor(o_interv_execution_images);
            pk_types.open_my_cursor(o_interv_doc);
            pk_types.open_my_cursor(o_interv_review);
            RETURN FALSE;
    END get_procedure_detail;

    FUNCTION get_procedure_detail
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        o_detail           OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_procedure_order            t_tbl_procedures_detail;
        l_procedure_cq               t_tbl_procedures_cq;
        l_procedure_co_sign          t_tbl_procedures_co_sign;
        l_procedure_execution        t_tbl_procedures_execution;
        l_procedure_execution_images t_tbl_procedures_execution_images;
        l_procedure_doc              t_tbl_procedures_doc;
        l_procedure_review           t_tbl_procedures_review;
    
        l_tab_order_data                   t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_co_sign_data                 t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_data                 t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_data_aux             t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_procedure_execution_data     t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_procedure_execution_data_aux t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_doc_data                     t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_doc_data_aux                 t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_review_data                  t_tab_dd_block_data := t_tab_dd_block_data();
    
        l_tab_dd_data      t_tab_dd_data := t_tab_dd_data();
        l_data_source_list table_varchar := table_varchar();
    
        l_clinical_questions CLOB := NULL;
        l_count_cq           PLS_INTEGER := 0;
    
        l_co_sign_notes    CLOB;
        l_perform_note     table_clob := table_clob();
        l_tbl_result_notes table_clob := table_clob();
    
        l_area dd_area.area%TYPE := 'PROCEDURES';
    
        l_id_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE := NULL;
        l_execution_index      PLS_INTEGER := 0;
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                             pk_message.get_message(i_lang,
                                                                                                                    i_prof,
                                                                                                                    pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                             '</b> ';
        END LOOP;
    
        --PROCEDURE ORDER
        g_error           := 'CALLING TF_GET_PROCEDURE_ORDER';
        l_procedure_order := pk_procedures_core.tf_get_procedure_order(i_lang             => i_lang,
                                                                       i_prof             => i_prof,
                                                                       i_episode          => i_episode,
                                                                       i_interv_presc_det => i_interv_presc_det,
                                                                       i_flg_report       => pk_alert_constant.g_no,
                                                                       i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_order.count > 0
        THEN
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       ddb.rank,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_order_data
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT t.*
                              FROM (SELECT ' ' AS title,
                                           l_procedure_order(1).desc_procedure desc_procedure,
                                           l_procedure_order(1).num_order num_order,
                                           CASE
                                                WHEN l_procedure_order(1).diagnosis_notes IS NOT NULL
                                                      OR l_procedure_order(1).desc_diagnosis IS NOT NULL
                                                      OR l_procedure_order(1).clinical_purpose IS NOT NULL
                                                      OR l_procedure_order(1).laterality IS NOT NULL THEN
                                                 l_procedure_order(1).clinical_indication
                                                ELSE
                                                 NULL
                                            END clinical_indication,
                                           l_procedure_order(1).diagnosis_notes diagnosis_notes,
                                           l_procedure_order(1).desc_diagnosis desc_diagnosis,
                                           l_procedure_order(1).clinical_purpose clinical_purpose,
                                           l_procedure_order(1).laterality laterality,
                                           l_procedure_order(1).instructions instructions,
                                           l_procedure_order(1).priority priority,
                                           l_procedure_order(1).desc_status desc_status,
                                           l_procedure_order(1).desc_time desc_time,
                                           l_procedure_order(1).desc_time_limit desc_time_limit,
                                           l_procedure_order(1).order_recurrence order_recurrence,
                                           l_procedure_order(1).prn prn,
                                           to_char(l_procedure_order(1).notes_prn) notes_prn,
                                           l_procedure_order(1).execution execution,
                                           l_procedure_order(1).perform_location perform_location,
                                           l_procedure_order(1).dt_req dt_req,
                                           l_procedure_order(1).desc_supplies desc_supplies,
                                           l_procedure_order(1).lab_result lab_result,
                                           l_procedure_order(1).weight weight,
                                           l_procedure_order(1).not_order_reason not_order_reason,
                                           l_procedure_order(1).notes notes,
                                           CASE
                                                WHEN l_procedure_order(1).prof_order IS NOT NULL
                                                      OR l_procedure_order(1).dt_order IS NOT NULL
                                                      OR l_procedure_order(1).order_type IS NOT NULL THEN
                                                 l_procedure_order(1).co_sign
                                                ELSE
                                                 NULL
                                            END co_sign,
                                           l_procedure_order(1).prof_order prof_order,
                                           l_procedure_order(1).dt_order dt_order,
                                           l_procedure_order(1).order_type order_type,
                                           CASE
                                                WHEN l_procedure_order(1).health_plan IS NOT NULL
                                                      OR l_procedure_order(1).insurance_number IS NOT NULL
                                                      OR l_procedure_order(1).exemption IS NOT NULL
                                                      OR l_procedure_order(1).financial_entity IS NOT NULL THEN
                                                 l_procedure_order(1).health_insurance
                                                ELSE
                                                 NULL
                                            END health_insurance,
                                           l_procedure_order(1).financial_entity financial_entity,
                                           l_procedure_order(1).health_plan health_plan,
                                           l_procedure_order(1).insurance_number insurance_number,
                                           l_procedure_order(1).exemption exemption,
                                           CASE
                                                WHEN l_procedure_order(1).cancel_reason IS NOT NULL
                                                      OR l_procedure_order(1).cancel_notes IS NOT NULL
                                                      OR l_procedure_order(1).cancel_prof_order IS NOT NULL
                                                      OR l_procedure_order(1).cancel_dt_order IS NOT NULL
                                                      OR l_procedure_order(1).cancel_order_type IS NOT NULL THEN
                                                 l_procedure_order(1).cancellation
                                                ELSE
                                                 NULL
                                            END cancellation,
                                           l_procedure_order(1).cancel_reason cancel_reason,
                                           l_procedure_order(1).cancel_notes cancel_notes,
                                           l_procedure_order(1).cancel_prof_order cancel_prof_order,
                                           l_procedure_order(1).cancel_dt_order cancel_dt_order,
                                           l_procedure_order(1).cancel_order_type cancel_order_type,
                                           l_procedure_order(1).registry AS registry,
                                           ' ' white_line
                                      FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                             desc_procedure, ---
                                                                                                             num_order,
                                                                                                             clinical_indication,
                                                                                                             diagnosis_notes,
                                                                                                             desc_diagnosis,
                                                                                                             clinical_purpose,
                                                                                                             laterality,
                                                                                                             instructions,
                                                                                                             priority,
                                                                                                             desc_status,
                                                                                                             desc_time,
                                                                                                             desc_time_limit,
                                                                                                             order_recurrence,
                                                                                                             prn,
                                                                                                             notes_prn,
                                                                                                             execution,
                                                                                                             perform_location,
                                                                                                             dt_req,
                                                                                                             desc_supplies,
                                                                                                             lab_result,
                                                                                                             weight,
                                                                                                             not_order_reason,
                                                                                                             notes,
                                                                                                             co_sign,
                                                                                                             prof_order,
                                                                                                             order_type,
                                                                                                             dt_order,
                                                                                                             health_insurance,
                                                                                                             financial_entity,
                                                                                                             health_plan,
                                                                                                             insurance_number,
                                                                                                             exemption,
                                                                                                             cancellation,
                                                                                                             cancel_reason,
                                                                                                             cancel_notes,
                                                                                                             cancel_prof_order,
                                                                                                             cancel_dt_order,
                                                                                                             cancel_order_type,
                                                                                                             registry,
                                                                                                             white_line))) dd
              JOIN dd_block ddb
                ON ddb.area = l_area
               AND ddb.internal_name = 'ORDER'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        --PROCEDURE CLINICAL QUESTIONS               
        g_error        := 'CALLING tf_get_procedure_cq';
        l_procedure_cq := pk_procedures_core.tf_get_procedure_cq(i_lang             => i_lang,
                                                                 i_prof             => i_prof,
                                                                 i_episode          => i_episode,
                                                                 i_interv_presc_det => i_interv_presc_det,
                                                                 i_flg_report       => pk_alert_constant.g_no,
                                                                 i_aa_code_messages => aa_code_messages);
        l_count_cq     := l_procedure_cq.count;
    
        IF l_procedure_cq.count > 0
        THEN
            FOR i IN l_procedure_cq.first .. l_procedure_cq.last
            LOOP
                l_clinical_questions := l_clinical_questions || l_procedure_cq(i).desc_clinical_question || chr(10);
            END LOOP;
        END IF;
    
        --PROCEDURE CO_SIGN
        g_error             := 'CALLING TF_GET_PROCEDURE_CO_SIGN';
        l_procedure_co_sign := pk_procedures_core.tf_get_procedure_co_sign(i_lang             => i_lang,
                                                                           i_prof             => i_prof,
                                                                           i_episode          => i_episode,
                                                                           i_interv_presc_det => i_interv_presc_det,
                                                                           i_flg_report       => pk_alert_constant.g_no,
                                                                           i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_co_sign.count > 0
        THEN
            l_co_sign_notes := l_procedure_co_sign(1).co_sign_notes;
        
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       ddb.rank,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_co_sign_data
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT t.*
                              FROM (SELECT ' ' AS title,
                                           ' ' notes,
                                           l_procedure_co_sign(1).registry AS registry,
                                           ' ' white_line
                                      FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                             notes,
                                                                                                             registry,
                                                                                                             white_line))) dd
              JOIN dd_block ddb
                ON ddb.area = l_area
               AND ddb.internal_name = 'ORDER_CO_SIGN'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        --PROCEDURE PERFORM
        g_error               := 'CALLING TF_GET_PROCEDURE_EXECUTION';
        l_procedure_execution := pk_procedures_core.tf_get_procedure_execution(i_lang             => i_lang,
                                                                               i_prof             => i_prof,
                                                                               i_episode          => i_episode,
                                                                               i_interv_presc_det => i_interv_presc_det,
                                                                               i_flg_report       => pk_alert_constant.g_no,
                                                                               i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_execution.count > 0
        THEN
            FOR i IN l_procedure_execution.first .. l_procedure_execution.last
            LOOP
                l_perform_note.extend();
                l_perform_note(l_perform_note.count) := l_procedure_execution(i).desc_perform;
            
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           ddb.rank + (i * 1000),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_perform_data_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT ' ' AS title,
                                               l_procedure_execution(i).desc_procedure desc_procedure,
                                               l_procedure_execution(i).prof_perform executed_by,
                                               l_procedure_execution(i).start_time start_time,
                                               l_procedure_execution(i).end_time end_time,
                                               l_procedure_execution(i).next_perform_date next_perform_date,
                                               l_procedure_execution(i).desc_modifiers desc_modifiers,
                                               ' ' notes,
                                               l_procedure_execution(i).desc_supplies supplies,
                                               l_procedure_execution(i).cancel_reason cancel_reason,
                                               l_procedure_execution(i).cancel_notes notes_cancel,
                                               l_procedure_execution(i).registry AS registry,
                                               ' ' white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                                 desc_procedure,
                                                                                                                 executed_by,
                                                                                                                 start_time,
                                                                                                                 end_time,
                                                                                                                 next_perform_date,
                                                                                                                 desc_modifiers,
                                                                                                                 notes,
                                                                                                                 supplies,
                                                                                                                 cancel_reason,
                                                                                                                 notes_cancel,
                                                                                                                 registry,
                                                                                                                 white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'PROCEDURE_PERFORM'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                FOR j IN l_tab_perform_data_aux.first .. l_tab_perform_data_aux.last
                LOOP
                    l_tab_perform_data.extend();
                    l_tab_perform_data(l_tab_perform_data.count()) := l_tab_perform_data_aux(j);
                END LOOP;
            END LOOP;
        END IF;
    
        --PROCEDURE PERFORM IMAGES
        g_error                      := 'CALLING TF_GET_PROCEDURE_EXECUTION_IMAGES';
        l_procedure_execution_images := pk_procedures_core.tf_get_procedure_execution_images(i_lang             => i_lang,
                                                                                             i_prof             => i_prof,
                                                                                             i_episode          => i_episode,
                                                                                             i_interv_presc_det => i_interv_presc_det,
                                                                                             i_flg_report       => pk_alert_constant.g_no,
                                                                                             i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_execution_images.count > 0
           AND l_procedure_execution.count > 0
        THEN
            FOR i IN l_procedure_execution_images.first .. l_procedure_execution_images.last
            LOOP
                IF l_procedure_execution_images(i).id_interv_presc_plan <> l_id_interv_presc_plan
                    OR l_id_interv_presc_plan IS NULL
                THEN
                    l_execution_index      := l_execution_index + 1;
                    l_id_interv_presc_plan := l_procedure_execution_images(i).id_interv_presc_plan;
                END IF;
            
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           ddb.rank + (l_execution_index * 1000) + (i * 100),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_procedure_execution_data_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT l_procedure_execution_images(i).doc_title doc_title,
                                               l_procedure_execution_images(i).doc_original_type doc_original_type,
                                               l_procedure_execution_images(i).dt_doc dt_doc,
                                               l_procedure_execution_images(i).perform_by perform_by,
                                               l_procedure_execution_images(i).num_img num_img,
                                               l_procedure_execution_images(i).doc_original_desc doc_original_desc,
                                               l_procedure_execution_images(i).doc_original_destination doc_original_destination,
                                               l_procedure_execution_images(i).notes doc_notes,
                                               l_procedure_execution_images(i).registry doc_registry,
                                               ' ' doc_white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(doc_title,
                                                                                                                 doc_original_type,
                                                                                                                 dt_doc,
                                                                                                                 perform_by,
                                                                                                                 num_img,
                                                                                                                 doc_original_desc,
                                                                                                                 doc_original_destination,
                                                                                                                 doc_notes,
                                                                                                                 doc_registry,
                                                                                                                 doc_white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'PROCEDURE_PERFORM'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                FOR j IN l_tab_procedure_execution_data_aux.first .. l_tab_procedure_execution_data_aux.last
                LOOP
                    l_tab_procedure_execution_data.extend();
                    l_tab_procedure_execution_data(l_tab_procedure_execution_data.count()) := l_tab_procedure_execution_data_aux(j);
                END LOOP;
            END LOOP;
        END IF;
    
        --EXAM DOCUMENTS
        g_error         := 'CALLING TF_GET_PROCEDURE_DOC';
        l_procedure_doc := pk_procedures_core.tf_get_procedure_doc(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_episode          => i_episode,
                                                                   i_interv_presc_det => i_interv_presc_det,
                                                                   i_flg_report       => pk_alert_constant.g_no,
                                                                   i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_doc.count > 0
        THEN
            FOR i IN l_procedure_doc.first .. l_procedure_doc.last
            LOOP
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           ddb.rank + (i * 1000),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_doc_data_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT ' ' AS title,
                                               l_procedure_doc(i).doc_title doc_title,
                                               l_procedure_doc(i).doc_original_type doc_original_type,
                                               l_procedure_doc(i).desc_status doc_status,
                                               l_procedure_doc(i).dt_doc dt_doc,
                                               l_procedure_doc(i).perform_by perform_by,
                                               l_procedure_doc(i).num_img num_img,
                                               l_procedure_doc(i).doc_original_desc doc_original_desc,
                                               l_procedure_doc(i).doc_original_destination doc_original_destination,
                                               l_procedure_doc(i).notes doc_notes,
                                               l_procedure_doc(i).registry registry,
                                               ' ' white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                                 doc_title,
                                                                                                                 doc_original_type,
                                                                                                                 doc_status,
                                                                                                                 dt_doc,
                                                                                                                 perform_by,
                                                                                                                 num_img,
                                                                                                                 doc_original_desc,
                                                                                                                 doc_original_destination,
                                                                                                                 doc_notes,
                                                                                                                 registry,
                                                                                                                 white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'PROCEDURE_DOCUMENT'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                FOR j IN l_tab_doc_data_aux.first .. l_tab_doc_data_aux.last
                LOOP
                    l_tab_doc_data.extend();
                    l_tab_doc_data(l_tab_doc_data.count()) := l_tab_doc_data_aux(j);
                END LOOP;
            END LOOP;
        END IF;
    
        --EXAM REVIEW
        g_error            := 'CALLING TF_GET_PROCEDURE_REVIEW';
        l_procedure_review := pk_procedures_core.tf_get_procedure_review(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_episode          => i_episode,
                                                                         i_interv_presc_det => i_interv_presc_det,
                                                                         i_flg_report       => pk_alert_constant.g_no,
                                                                         i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_review.count > 0
        THEN
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       ddb.rank,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_review_data
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT t.*
                              FROM (SELECT ' ' AS title,
                                           l_procedure_review(1).desc_procedure desc_procedure,
                                           l_procedure_review(1).review_notes review_notes,
                                           l_procedure_review(1).registry AS registry,
                                           ' ' white_line
                                      FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                             desc_procedure,
                                                                                                             review_notes,
                                                                                                             registry,
                                                                                                             white_line))) dd
              JOIN dd_block ddb
                ON ddb.area = l_area
               AND ddb.internal_name = 'PROCEDURE_REVIEW'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        SELECT t_rec_dd_data(CASE
                                  WHEN data_code_message IS NOT NULL THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message)
                                  ELSE
                                   NULL
                              END,
                              CASE
                                  WHEN flg_type = 'L1' THEN
                                   NULL
                                  ELSE
                                   data_source_val
                              END,
                              flg_type,
                              flg_html,
                              val_clob,
                              flg_clob),
               data_source
          BULK COLLECT
          INTO l_tab_dd_data, l_data_source_list
          FROM (SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 NULL val_clob,
                 flg_clob
                  FROM TABLE(l_tab_order_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 1
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                UNION ALL
                --clinical questions
                SELECT ddc.data_code_message,
                       ddc.flg_type,
                       NULL,
                       ddc.data_source,
                       db.rank               rnk,
                       ddc.rank,
                       db.id_dd_block,
                       flg_html,
                       l_clinical_questions  val_clob,
                       flg_clob
                  FROM dd_block db
                  JOIN dd_content ddc
                    ON ddc.area = db.area
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND db.id_dd_block = ddc.id_dd_block
                   AND ddc.internal_name = 'CLINICAL_QUESTIONS'
                 WHERE db.area = l_area
                   AND l_count_cq > 0
                UNION ALL
                --PROCEDURE CO_SIGN
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 CASE
                     WHEN ddc.flg_clob = pk_alert_constant.g_yes THEN
                      l_co_sign_notes
                 END val_clob,
                 flg_clob
                  FROM TABLE(l_tab_co_sign_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 2
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                --PROCEDURE PERFORM
                UNION ALL (SELECT /*+opt_estimate (table db rows=1)*/
                           ddc.data_code_message,
                           flg_type,
                           data_source_val,
                           ddc.data_source,
                           db.rnk,
                           ddc.rank,
                           db.id_dd_block,
                           flg_html,
                           CASE
                                WHEN ddc.flg_clob = pk_alert_constant.g_yes THEN
                                 lpn.column_value
                            END val_clob,
                           flg_clob
                            FROM TABLE(l_tab_perform_data) db
                            JOIN dd_content ddc
                              ON ddc.data_source = db.data_source
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = l_area
                             AND ddc.id_dd_block = 3
                            JOIN dd_block ddb
                              ON ddb.id_dd_block = ddc.id_dd_block
                             AND ddb.area = ddc.area
                            LEFT JOIN (SELECT column_value, rownum AS rn
                                        FROM TABLE(l_perform_note)) lpn
                              ON lpn.rn = ((db.rnk - ddb.rank) / 1000)
                           WHERE ddc.id_dd_block = db.id_dd_block
                             AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                          UNION ALL
                          SELECT /*+opt_estimate (table db rows=1)*/
                           ddc.data_code_message,
                           flg_type,
                           data_source_val,
                           ddc.data_source,
                           db.rnk,
                           ddc.rank,
                           db.id_dd_block,
                           flg_html,
                           NULL val_clob,
                           flg_clob
                            FROM TABLE(l_tab_procedure_execution_data) db
                            JOIN dd_content ddc
                              ON ddc.data_source = db.data_source
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = l_area
                             AND ddc.id_dd_block = 3
                           WHERE ddc.id_dd_block = db.id_dd_block
                             AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N')))
                --PROCEDURE DOCUMENT
                UNION ALL
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 NULL val_clob,
                 flg_clob
                  FROM TABLE(l_tab_doc_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 4
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                --PROCEDURE REVIEW
                UNION ALL
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 NULL val_clob,
                 flg_clob
                  FROM TABLE(l_tab_review_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 5
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N')))
         ORDER BY id_dd_block, rnk, rank;
    
        g_error := 'OPEN O_DETAIL';
        OPEN o_detail FOR
            SELECT descr, val, flg_type, flg_html, val_clob, flg_clob
              FROM (SELECT CASE
                                WHEN d.val IS NULL THEN
                                 d.descr
                                WHEN d.descr IS NULL THEN
                                 NULL
                                ELSE
                                 d.descr || decode(d.flg_type, 'LP', NULL, ': ')
                            END descr,
                           d.val,
                           d.flg_type,
                           flg_html,
                           val_clob,
                           flg_clob,
                           d.rn
                      FROM (SELECT /*+opt_estimate (table t rows=1)*/
                             rownum rn, descr, val, flg_type, flg_html, val_clob, flg_clob
                              FROM TABLE(l_tab_dd_data) t) d
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            rownum rn, column_value data_source
                             FROM TABLE(l_data_source_list) t) ds
                        ON ds.rn = d.rn);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_PROCEDURE_DETAIL',
                                              o_error    => o_error);
            pk_types.open_my_cursor(i_cursor => o_detail);
            RETURN FALSE;
    END get_procedure_detail;

    FUNCTION get_procedure_detail_history
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_episode                   IN episode.id_episode%TYPE,
        i_interv_presc_det          IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report                IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        o_interv_order              OUT t_tbl_procedures_detail,
        o_interv_co_sign            OUT pk_types.cursor_type,
        o_interv_clinical_questions OUT t_tbl_procedures_cq,
        o_interv_execution          OUT t_tbl_procedures_execution,
        o_interv_execution_images   OUT pk_types.cursor_type,
        o_interv_doc                OUT pk_types.cursor_type,
        o_interv_review             OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_interv_co_sign          t_tbl_procedures_co_sign;
        l_interv_execution_images t_tbl_procedures_execution_images;
        l_interv_doc              t_tbl_procedures_doc;
        l_interv_review           t_tbl_procedures_review;
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                             pk_message.get_message(i_lang,
                                                                                                                    i_prof,
                                                                                                                    pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                             '</b> ';
        END LOOP;
    
        g_error := 'GET MESSAGES UPDATE';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail_upd.first .. pk_procedures_constant.ga_code_messages_procedure_detail_upd.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) ||
                                                                                                 '</b> ';
        END LOOP;
    
        g_error        := 'OPEN O_INTERV_ORDER';
        o_interv_order := pk_procedures_core.tf_get_procedure_order_history(i_lang             => i_lang,
                                                                            i_prof             => i_prof,
                                                                            i_episode          => i_episode,
                                                                            i_interv_presc_det => i_interv_presc_det,
                                                                            i_flg_report       => i_flg_report,
                                                                            i_flg_html         => pk_alert_constant.g_no,
                                                                            i_aa_code_messages => aa_code_messages);
    
        g_error          := 'OPEN O_INTERV_CO_SIGN';
        l_interv_co_sign := pk_procedures_core.tf_get_procedure_co_sign(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_episode          => i_episode,
                                                                        i_interv_presc_det => i_interv_presc_det,
                                                                        i_flg_report       => i_flg_report,
                                                                        i_aa_code_messages => aa_code_messages);
        OPEN o_interv_co_sign FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.id_interv_presc_det, t.registry, t.flg_status, t.co_sign_notes
              FROM TABLE(l_interv_co_sign) t;
    
        g_error                     := 'OPEN O_INTERV_CLINICAL_QUESTIONS';
        o_interv_clinical_questions := pk_procedures_core.tf_get_procedure_cq_history(i_lang             => i_lang,
                                                                                      i_prof             => i_prof,
                                                                                      i_episode          => i_episode,
                                                                                      i_interv_presc_det => i_interv_presc_det,
                                                                                      i_flg_report       => i_flg_report,
                                                                                      i_flg_html         => pk_alert_constant.g_no,
                                                                                      i_aa_code_messages => aa_code_messages);
    
        g_error            := 'OPEN O_INTERV_EXECUTION';
        o_interv_execution := pk_procedures_core.tf_get_procedure_execution_history(i_lang             => i_lang,
                                                                                    i_prof             => i_prof,
                                                                                    i_episode          => i_episode,
                                                                                    i_interv_presc_det => i_interv_presc_det,
                                                                                    i_flg_report       => i_flg_report,
                                                                                    i_flg_html         => pk_alert_constant.g_no,
                                                                                    i_aa_code_messages => aa_code_messages);
    
        g_error                   := 'OPEN O_INTERV_EXECUTION_IMAGES';
        l_interv_execution_images := pk_procedures_core.tf_get_procedure_execution_images(i_lang             => i_lang,
                                                                                          i_prof             => i_prof,
                                                                                          i_episode          => i_episode,
                                                                                          i_interv_presc_det => i_interv_presc_det,
                                                                                          i_flg_report       => i_flg_report,
                                                                                          i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_execution_images FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_execution_images) t;
    
        OPEN o_interv_execution_images FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_execution_images) t;
    
        g_error      := 'OPEN O_INTERV_DOC';
        l_interv_doc := pk_procedures_core.tf_get_procedure_doc(i_lang             => i_lang,
                                                                i_prof             => i_prof,
                                                                i_episode          => i_episode,
                                                                i_interv_presc_det => i_interv_presc_det,
                                                                i_flg_report       => i_flg_report,
                                                                i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_doc FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_doc) t;
    
        g_error         := 'OPEN O_INTERV_REVIEW';
        l_interv_review := pk_procedures_core.tf_get_procedure_review(i_lang             => i_lang,
                                                                      i_prof             => i_prof,
                                                                      i_episode          => i_episode,
                                                                      i_interv_presc_det => i_interv_presc_det,
                                                                      i_flg_report       => i_flg_report,
                                                                      i_aa_code_messages => aa_code_messages);
    
        OPEN o_interv_review FOR
            SELECT /*+opt_estimate (table t rows=1)*/
             t.*
              FROM TABLE(l_interv_review) t;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DETAIL_HISTORY',
                                              o_error);
            pk_types.open_my_cursor(o_interv_co_sign);
            pk_types.open_my_cursor(o_interv_execution_images);
            pk_types.open_my_cursor(o_interv_doc);
            pk_types.open_my_cursor(o_interv_review);
            RETURN FALSE;
    END get_procedure_detail_history;

    FUNCTION get_procedure_detail_history
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        o_detail           OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_procedure_order_hist       t_tbl_procedures_detail;
        l_procedure_cq               t_tbl_procedures_cq;
        l_procedure_co_sign          t_tbl_procedures_co_sign;
        l_procedure_execution_hist   t_tbl_procedures_execution;
        l_procedure_execution_images t_tbl_procedures_execution_images;
        l_procedure_doc              t_tbl_procedures_doc;
        l_procedure_review           t_tbl_procedures_review;
    
        l_count_order_hist   PLS_INTEGER := 0;
        l_count_cq           PLS_INTEGER := 0;
        l_cq_offset          PLS_INTEGER := 0;
        l_count_perform_hist PLS_INTEGER := 0;
    
        l_tab_order_data              t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_order_aux               t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_co_sign_data            t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_data            t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_aux             t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_images_data     t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_perform_images_data_aux t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_doc_data                t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_doc_data_aux            t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_review_data             t_tab_dd_block_data := t_tab_dd_block_data();
    
        l_tab_dd_data      t_tab_dd_data := t_tab_dd_data();
        l_data_source_list table_varchar := table_varchar();
    
        l_clinical_questions table_clob := table_clob();
    
        l_co_sign_notes CLOB;
    
        l_tbl_perform_notes table_clob := table_clob();
    
        l_id_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE := NULL;
    
        l_area dd_area.area%TYPE := 'PROCEDURES';
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                             pk_message.get_message(i_lang,
                                                                                                                    i_prof,
                                                                                                                    pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                             '</b> ';
        END LOOP;
    
        g_error := 'GET MESSAGES UPDATE';
        FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail_upd.first .. pk_procedures_constant.ga_code_messages_procedure_detail_upd.last
        LOOP
            aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) := '<span class="emphasizedRedDetail">' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) ||
                                                                                                 '</span> ';
        END LOOP;
    
        --PROCEDURE ORDER HISTORY
        g_error                := 'CALLING TF_GET_PROCEDURE_ORDER_HISTORY';
        l_procedure_order_hist := pk_procedures_core.tf_get_procedure_order_history(i_lang             => i_lang,
                                                                                    i_prof             => i_prof,
                                                                                    i_episode          => i_episode,
                                                                                    i_interv_presc_det => i_interv_presc_det,
                                                                                    i_flg_report       => pk_alert_constant.g_no,
                                                                                    i_flg_html         => pk_alert_constant.g_yes,
                                                                                    i_aa_code_messages => aa_code_messages);
    
        l_count_order_hist := l_procedure_order_hist.count;
    
        IF l_procedure_order_hist.count > 0
        THEN
            FOR i IN l_procedure_order_hist.first .. l_procedure_order_hist.last
            LOOP
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           (ddb.rank * i),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_order_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT CASE
                                                   WHEN l_count_order_hist = 1
                                                        OR i = l_count_order_hist THEN
                                                    ' '
                                                   ELSE
                                                    NULL
                                               END AS title,
                                               CASE
                                                   WHEN l_count_order_hist > 1
                                                        AND i < l_count_order_hist THEN
                                                    ' '
                                                   ELSE
                                                    NULL
                                               END AS title_update,
                                               l_procedure_order_hist(i).desc_procedure desc_procedure,
                                               l_procedure_order_hist(i).num_order num_order,
                                               CASE
                                                   WHEN l_procedure_order_hist(i).diagnosis_notes IS NOT NULL
                                                         OR l_procedure_order_hist(i).desc_diagnosis IS NOT NULL
                                                         OR l_procedure_order_hist(i).clinical_purpose IS NOT NULL
                                                         OR l_procedure_order_hist(i).laterality IS NOT NULL THEN
                                                    l_procedure_order_hist(i).clinical_indication
                                                   ELSE
                                                    NULL
                                               END clinical_indication,
                                               l_procedure_order_hist(i).diagnosis_notes diagnosis_notes,
                                               l_procedure_order_hist(i).desc_diagnosis desc_diagnosis,
                                               l_procedure_order_hist(i).clinical_purpose clinical_purpose,
                                               l_procedure_order_hist(i).laterality laterality,
                                               --                                           
                                               CASE
                                                   WHEN l_procedure_order_hist(i).priority IS NOT NULL
                                                         OR l_procedure_order_hist(i).desc_status IS NOT NULL
                                                         OR l_procedure_order_hist(i).desc_time IS NOT NULL
                                                         OR l_procedure_order_hist(i).desc_time_limit IS NOT NULL
                                                         OR l_procedure_order_hist(i).order_recurrence IS NOT NULL
                                                         OR l_procedure_order_hist(i).prn IS NOT NULL
                                                         OR to_char(l_procedure_order_hist(i).notes_prn) IS NOT NULL THEN
                                                    l_procedure_order_hist(i).instructions
                                                   ELSE
                                                    NULL
                                               END instructions,
                                               l_procedure_order_hist(i).priority priority,
                                               l_procedure_order_hist(i).desc_status desc_status,
                                               l_procedure_order_hist(i).desc_time desc_time,
                                               l_procedure_order_hist(i).desc_time_limit desc_time_limit,
                                               l_procedure_order_hist(i).order_recurrence order_recurrence,
                                               l_procedure_order_hist(i).prn prn,
                                               to_char(l_procedure_order_hist(i).notes_prn) notes_prn,
                                               --
                                               CASE
                                                   WHEN l_procedure_order_hist(i).perform_location IS NOT NULL
                                                         OR l_procedure_order_hist(i).dt_req IS NOT NULL
                                                         OR l_procedure_order_hist(i).desc_supplies IS NOT NULL
                                                         OR l_procedure_order_hist(i).lab_result IS NOT NULL
                                                         OR l_procedure_order_hist(i).weight IS NOT NULL
                                                         OR l_procedure_order_hist(i).not_order_reason IS NOT NULL
                                                         OR l_procedure_order_hist(i).notes IS NOT NULL THEN
                                                    l_procedure_order_hist(i).execution
                                                   ELSE
                                                    NULL
                                               END execution,
                                               l_procedure_order_hist(i).perform_location perform_location,
                                               l_procedure_order_hist(i).dt_req dt_req,
                                               l_procedure_order_hist(i).desc_supplies desc_supplies,
                                               l_procedure_order_hist(i).lab_result lab_result,
                                               l_procedure_order_hist(i).weight weight,
                                               l_procedure_order_hist(i).not_order_reason not_order_reason,
                                               l_procedure_order_hist(i).notes notes,
                                               --
                                               CASE
                                                   WHEN l_procedure_order_hist(i).prof_order IS NOT NULL
                                                         OR l_procedure_order_hist(i).dt_order IS NOT NULL
                                                         OR l_procedure_order_hist(i).order_type IS NOT NULL THEN
                                                    l_procedure_order_hist(i).co_sign
                                                   ELSE
                                                    NULL
                                               END co_sign,
                                               l_procedure_order_hist(i).prof_order prof_order,
                                               l_procedure_order_hist(i).dt_order dt_order,
                                               l_procedure_order_hist(i).order_type order_type,
                                               --
                                               CASE
                                                   WHEN l_procedure_order_hist(i).health_plan IS NOT NULL
                                                         OR l_procedure_order_hist(i).insurance_number IS NOT NULL
                                                         OR l_procedure_order_hist(i).exemption IS NOT NULL
                                                         OR l_procedure_order_hist(i).financial_entity IS NOT NULL THEN
                                                    l_procedure_order_hist(i).health_insurance
                                                   ELSE
                                                    NULL
                                               END health_insurance,
                                               l_procedure_order_hist(i).financial_entity financial_entity,
                                               l_procedure_order_hist(i).health_plan health_plan,
                                               l_procedure_order_hist(i).insurance_number insurance_number,
                                               l_procedure_order_hist(i).exemption exemption,
                                               --
                                               CASE
                                                   WHEN l_procedure_order_hist(i).cancel_reason IS NOT NULL
                                                         OR l_procedure_order_hist(i).cancel_notes IS NOT NULL
                                                         OR l_procedure_order_hist(i).cancel_prof_order IS NOT NULL
                                                         OR l_procedure_order_hist(i).cancel_dt_order IS NOT NULL
                                                         OR l_procedure_order_hist(i).cancel_order_type IS NOT NULL THEN
                                                    l_procedure_order_hist(i).cancellation
                                                   ELSE
                                                    NULL
                                               END cancellation,
                                               l_procedure_order_hist(i).cancel_reason cancel_reason,
                                               l_procedure_order_hist(i).cancel_notes cancel_notes,
                                               l_procedure_order_hist(i).cancel_prof_order cancel_prof_order,
                                               l_procedure_order_hist(i).cancel_dt_order cancel_dt_order,
                                               l_procedure_order_hist(i).cancel_order_type cancel_order_type,
                                               l_procedure_order_hist(i).registry AS registry,
                                               ' ' white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                                 title_update,
                                                                                                                 desc_procedure,
                                                                                                                 num_order,
                                                                                                                 clinical_indication,
                                                                                                                 diagnosis_notes,
                                                                                                                 desc_diagnosis,
                                                                                                                 clinical_purpose,
                                                                                                                 laterality,
                                                                                                                 instructions,
                                                                                                                 priority,
                                                                                                                 desc_status,
                                                                                                                 desc_time,
                                                                                                                 desc_time_limit,
                                                                                                                 order_recurrence,
                                                                                                                 prn,
                                                                                                                 notes_prn,
                                                                                                                 execution,
                                                                                                                 perform_location,
                                                                                                                 dt_req,
                                                                                                                 desc_supplies,
                                                                                                                 lab_result,
                                                                                                                 weight,
                                                                                                                 not_order_reason,
                                                                                                                 notes,
                                                                                                                 co_sign,
                                                                                                                 prof_order,
                                                                                                                 dt_order,
                                                                                                                 order_type,
                                                                                                                 health_insurance,
                                                                                                                 financial_entity,
                                                                                                                 health_plan,
                                                                                                                 insurance_number,
                                                                                                                 exemption,
                                                                                                                 cancellation,
                                                                                                                 cancel_reason,
                                                                                                                 cancel_notes,
                                                                                                                 cancel_prof_order,
                                                                                                                 cancel_dt_order,
                                                                                                                 cancel_order_type,
                                                                                                                 registry,
                                                                                                                 white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'ORDER'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                IF l_tab_order_aux.count > 0
                THEN
                    FOR j IN l_tab_order_aux.first .. l_tab_order_aux.last
                    LOOP
                        l_tab_order_data.extend();
                        l_tab_order_data(l_tab_order_data.count) := l_tab_order_aux(j);
                    END LOOP;
                END IF;
            
            END LOOP;
        END IF;
    
        --PROCEDURE CLINICAL QUESTIONS               
        g_error        := 'CALLING TF_GET_PROCEDURE_CQ_HISTORY';
        l_procedure_cq := pk_procedures_core.tf_get_procedure_cq_history(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_episode          => i_episode,
                                                                         i_interv_presc_det => i_interv_presc_det,
                                                                         i_flg_report       => pk_alert_constant.g_no,
                                                                         i_flg_html         => pk_alert_constant.g_yes,
                                                                         i_aa_code_messages => aa_code_messages);
        SELECT COUNT(1)
          INTO l_count_cq
          FROM (SELECT DISTINCT (t.rn)
                  FROM TABLE(l_procedure_cq) t);
    
        --An offset is needed because not all the Order blocks should present the clinical questions
        --example: transition from pending to complete.
        l_cq_offset := l_procedure_order_hist.count - l_count_cq;
    
        IF l_procedure_order_hist.exists(1)
        THEN
            FOR i IN l_procedure_order_hist.first .. l_procedure_order_hist.last
            LOOP
                l_clinical_questions.extend();
                IF l_procedure_cq.exists(i)
                THEN
                    FOR j IN l_procedure_cq.first .. l_procedure_cq.last
                    LOOP
                        IF i = l_procedure_cq(j).rn + l_cq_offset
                        THEN
                            l_clinical_questions(l_clinical_questions.count) := l_clinical_questions(l_clinical_questions.count) || l_procedure_cq(j).desc_clinical_question ||
                                                                                chr(10);
                        END IF;
                    END LOOP;
                ELSE
                    l_clinical_questions(i) := NULL;
                END IF;
            END LOOP;
        END IF;
    
        --PROCEDURE CO_SIGN
        g_error             := 'CALLING TF_GET_PROCEDURE_CO_SIGN';
        l_procedure_co_sign := pk_procedures_core.tf_get_procedure_co_sign(i_lang             => i_lang,
                                                                           i_prof             => i_prof,
                                                                           i_episode          => i_episode,
                                                                           i_interv_presc_det => i_interv_presc_det,
                                                                           i_flg_report       => pk_alert_constant.g_no,
                                                                           i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_co_sign.count > 0
        THEN
            l_co_sign_notes := l_procedure_co_sign(1).co_sign_notes;
        
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       ddb.rank,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_co_sign_data
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT t.*
                              FROM (SELECT ' ' AS title,
                                           ' ' notes,
                                           l_procedure_co_sign(1).registry AS registry,
                                           ' ' white_line
                                      FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                             notes,
                                                                                                             registry,
                                                                                                             white_line))) dd
              JOIN dd_block ddb
                ON ddb.area = l_area
               AND ddb.internal_name = 'ORDER_CO_SIGN'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        --PROCEDURE PERFORM HISTORY
        g_error                    := 'CALLING TF_GET_PROCEDURE_EXECUTION_HISTORY';
        l_procedure_execution_hist := pk_procedures_core.tf_get_procedure_execution_history(i_lang             => i_lang,
                                                                                            i_prof             => i_prof,
                                                                                            i_episode          => i_episode,
                                                                                            i_interv_presc_det => i_interv_presc_det,
                                                                                            i_flg_report       => pk_alert_constant.g_no,
                                                                                            i_flg_html         => pk_alert_constant.g_yes,
                                                                                            i_aa_code_messages => aa_code_messages);
    
        l_count_perform_hist := l_procedure_execution_hist.count;
    
        IF l_procedure_execution_hist.count > 0
        THEN
            FOR i IN l_procedure_execution_hist.first .. l_procedure_execution_hist.last
            LOOP
            
                l_tbl_perform_notes.extend();
                l_tbl_perform_notes(l_tbl_perform_notes.count) := l_procedure_execution_hist(i).desc_perform;
            
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           (ddb.rank * i),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_perform_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT CASE
                                                    WHEN l_count_perform_hist = 1
                                                         OR i = l_count_perform_hist THEN
                                                     ' '
                                                    ELSE
                                                     NULL
                                                END AS title,
                                               CASE
                                                    WHEN l_count_perform_hist > 1
                                                         AND i < l_count_perform_hist THEN
                                                     ' '
                                                    ELSE
                                                     NULL
                                                END AS title_update,
                                               l_procedure_execution_hist(i).desc_procedure desc_procedure,
                                               l_procedure_execution_hist(i).prof_perform executed_by,
                                               l_procedure_execution_hist(i).start_time start_time,
                                               l_procedure_execution_hist(i).end_time end_time,
                                               l_procedure_execution_hist(i).next_perform_date next_perform_date,
                                               l_procedure_execution_hist(i).desc_modifiers desc_modifiers,
                                               ' ' notes,
                                               l_procedure_execution_hist(i).desc_supplies supplies,
                                               l_procedure_execution_hist(i).cancel_reason cancel_reason,
                                               l_procedure_execution_hist(i).cancel_notes notes_cancel,
                                               l_procedure_execution_hist(i).registry AS registry,
                                               ' ' white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                                 title_update,
                                                                                                                 desc_procedure,
                                                                                                                 executed_by,
                                                                                                                 start_time,
                                                                                                                 end_time,
                                                                                                                 next_perform_date,
                                                                                                                 desc_modifiers,
                                                                                                                 notes,
                                                                                                                 supplies,
                                                                                                                 cancel_reason,
                                                                                                                 notes_cancel,
                                                                                                                 registry,
                                                                                                                 white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'PROCEDURE_PERFORM'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                IF l_tab_perform_aux.count > 0
                THEN
                    FOR j IN l_tab_perform_aux.first .. l_tab_perform_aux.last
                    LOOP
                        l_tab_perform_data.extend();
                        l_tab_perform_data(l_tab_perform_data.count) := l_tab_perform_aux(j);
                    END LOOP;
                END IF;
            END LOOP;
        
            --PROCEDURE_EXECUTION_IMAGES
            g_error                      := 'CALLING TF_GET_PROCEDURE_EXECUTION_IMAGES';
            l_procedure_execution_images := pk_procedures_core.tf_get_procedure_execution_images(i_lang             => i_lang,
                                                                                                 i_prof             => i_prof,
                                                                                                 i_episode          => i_episode,
                                                                                                 i_interv_presc_det => i_interv_presc_det,
                                                                                                 i_flg_report       => pk_alert_constant.g_no,
                                                                                                 i_aa_code_messages => aa_code_messages);
        
            IF l_procedure_execution_images.count > 0
            THEN
                FOR j IN l_procedure_execution_hist.first .. l_procedure_execution_hist.last
                LOOP
                    FOR i IN l_procedure_execution_images.first .. l_procedure_execution_images.last
                    LOOP
                        IF l_procedure_execution_images(i).id_interv_presc_plan = l_procedure_execution_hist(j).id_interv_presc_plan
                        THEN
                            IF l_procedure_execution_images(i).dt_last_update <= l_procedure_execution_hist(j).dt_last_update ----
                            THEN
                                IF l_procedure_execution_images(i).id_interv_presc_plan <> l_id_interv_presc_plan
                                    OR l_id_interv_presc_plan IS NULL
                                THEN
                                    l_id_interv_presc_plan := l_procedure_execution_images(i).id_interv_presc_plan;
                                END IF;
                            
                                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                                           ddb.rank + (j * 1000) + (i * 100),
                                                           NULL,
                                                           NULL,
                                                           ddb.condition_val,
                                                           NULL,
                                                           NULL,
                                                           dd.data_source,
                                                           dd.data_source_val,
                                                           NULL)
                                  BULK COLLECT
                                  INTO l_tab_perform_images_data_aux
                                  FROM (SELECT data_source, data_source_val
                                          FROM (SELECT t.*
                                                  FROM (SELECT l_procedure_execution_images(i).doc_title doc_title,
                                                               l_procedure_execution_images(i).doc_original_type doc_original_type,
                                                               l_procedure_execution_images(i).dt_doc dt_doc,
                                                               l_procedure_execution_images(i).perform_by perform_by,
                                                               l_procedure_execution_images(i).num_img num_img,
                                                               l_procedure_execution_images(i).doc_original_desc doc_original_desc,
                                                               l_procedure_execution_images(i).doc_original_destination doc_original_destination,
                                                               l_procedure_execution_images(i).notes doc_notes,
                                                               l_procedure_execution_images(j).registry doc_registry,
                                                               ' ' doc_white_line
                                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(doc_title,
                                                                                                                                 doc_original_type,
                                                                                                                                 dt_doc,
                                                                                                                                 perform_by,
                                                                                                                                 num_img,
                                                                                                                                 doc_original_desc,
                                                                                                                                 doc_original_destination,
                                                                                                                                 doc_notes,
                                                                                                                                 doc_registry,
                                                                                                                                 doc_white_line))) dd
                                  JOIN dd_block ddb
                                    ON ddb.area = l_area
                                   AND ddb.internal_name = 'PROCEDURE_PERFORM'
                                   AND ddb.flg_available = pk_alert_constant.g_yes;
                            
                                FOR j IN l_tab_perform_images_data_aux.first .. l_tab_perform_images_data_aux.last
                                LOOP
                                    l_tab_perform_images_data.extend();
                                    l_tab_perform_images_data(l_tab_perform_images_data.count()) := l_tab_perform_images_data_aux(j);
                                END LOOP;
                            END IF;
                        END IF;
                    END LOOP;
                END LOOP;
            END IF;
        END IF;
    
        --ASSOCIATED DOCUMENTS
        g_error         := 'CALLING TF_GET_PROCEDURE_DOC';
        l_procedure_doc := pk_procedures_core.tf_get_procedure_doc(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_episode          => i_episode,
                                                                   i_interv_presc_det => i_interv_presc_det,
                                                                   i_flg_report       => pk_alert_constant.g_no,
                                                                   i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_doc.count > 0
        THEN
            FOR i IN l_procedure_doc.first .. l_procedure_doc.last
            LOOP
                SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                           ddb.rank + (i * 1000),
                                           NULL,
                                           NULL,
                                           ddb.condition_val,
                                           NULL,
                                           NULL,
                                           dd.data_source,
                                           dd.data_source_val,
                                           NULL)
                  BULK COLLECT
                  INTO l_tab_doc_data_aux
                  FROM (SELECT data_source, data_source_val
                          FROM (SELECT t.*
                                  FROM (SELECT ' ' AS title,
                                               l_procedure_doc(i).doc_title doc_title,
                                               l_procedure_doc(i).doc_original_type doc_original_type,
                                               l_procedure_doc(i).desc_status doc_status,
                                               l_procedure_doc(i).dt_doc dt_doc,
                                               l_procedure_doc(i).perform_by perform_by,
                                               l_procedure_doc(i).num_img num_img,
                                               l_procedure_doc(i).doc_original_desc doc_original_desc,
                                               l_procedure_doc(i).doc_original_destination doc_original_destination,
                                               l_procedure_doc(i).notes doc_notes,
                                               l_procedure_doc(i).registry registry,
                                               ' ' white_line
                                          FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                                 doc_title,
                                                                                                                 doc_original_type,
                                                                                                                 doc_status,
                                                                                                                 dt_doc,
                                                                                                                 perform_by,
                                                                                                                 num_img,
                                                                                                                 doc_original_desc,
                                                                                                                 doc_original_destination,
                                                                                                                 doc_notes,
                                                                                                                 registry,
                                                                                                                 white_line))) dd
                  JOIN dd_block ddb
                    ON ddb.area = l_area
                   AND ddb.internal_name = 'PROCEDURE_DOCUMENT'
                   AND ddb.flg_available = pk_alert_constant.g_yes;
            
                FOR j IN l_tab_doc_data_aux.first .. l_tab_doc_data_aux.last
                LOOP
                    l_tab_doc_data.extend();
                    l_tab_doc_data(l_tab_doc_data.count()) := l_tab_doc_data_aux(j);
                END LOOP;
            END LOOP;
        END IF;
    
        --PROCEDURE REVIEW
        g_error            := 'CALLING TF_GET_PROCEDURE_REVIEW';
        l_procedure_review := pk_procedures_core.tf_get_procedure_review(i_lang             => i_lang,
                                                                         i_prof             => i_prof,
                                                                         i_episode          => i_episode,
                                                                         i_interv_presc_det => i_interv_presc_det,
                                                                         i_flg_report       => pk_alert_constant.g_no,
                                                                         i_aa_code_messages => aa_code_messages);
    
        IF l_procedure_review.count > 0
        THEN
            SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                       ddb.rank,
                                       NULL,
                                       NULL,
                                       ddb.condition_val,
                                       NULL,
                                       NULL,
                                       dd.data_source,
                                       dd.data_source_val,
                                       NULL)
              BULK COLLECT
              INTO l_tab_review_data
              FROM (SELECT data_source, data_source_val
                      FROM (SELECT t.*
                              FROM (SELECT ' ' AS title,
                                           l_procedure_review(1).desc_procedure desc_procedure,
                                           l_procedure_review(1).review_notes review_notes,
                                           l_procedure_review(1).registry AS registry,
                                           ' ' white_line
                                      FROM dual) t) unpivot include NULLS(data_source_val FOR data_source IN(title,
                                                                                                             desc_procedure,
                                                                                                             review_notes,
                                                                                                             registry,
                                                                                                             white_line))) dd
              JOIN dd_block ddb
                ON ddb.area = l_area
               AND ddb.internal_name = 'PROCEDURE_REVIEW'
               AND ddb.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        SELECT t_rec_dd_data(CASE
                                  WHEN data_code_message IS NOT NULL THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message)
                                  ELSE
                                   NULL
                              END,
                              CASE
                                  WHEN flg_type = 'L1' THEN
                                   NULL
                                  ELSE
                                   data_source_val
                              END,
                              flg_type,
                              flg_html,
                              val_clob,
                              flg_clob),
               data_source
          BULK COLLECT
          INTO l_tab_dd_data, l_data_source_list
          FROM (SELECT ddc.data_code_message,
                       flg_type,
                       data_source_val,
                       ddc.data_source,
                       db.rnk,
                       ddc.rank,
                       db.id_dd_block,
                       flg_html,
                       NULL val_clob,
                       flg_clob
                  FROM TABLE(l_tab_order_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 1
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                UNION ALL
                --clinical questions
                SELECT /*+opt_estimate (table tt rows=1)*/
                 ddc.data_code_message,
                 ddc.flg_type,
                 NULL,
                 ddc.data_source,
                 (db.rank * tt.rn),
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 tt.column_value val_clob,
                 flg_clob
                  FROM (SELECT column_value, rownum AS rn
                          FROM TABLE(l_clinical_questions) t) tt
                  JOIN dd_block db
                    ON db.area = l_area
                   AND db.internal_name = 'ORDER'
                  JOIN dd_content ddc
                    ON ddc.area = db.area
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.id_dd_block = 1
                   AND ddc.internal_name = 'CLINICAL_QUESTIONS'
                 WHERE db.area = l_area
                   AND l_count_cq > 0
                --CO_SIGN
                UNION ALL
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 CASE
                     WHEN ddc.flg_clob = pk_alert_constant.g_yes THEN
                      l_co_sign_notes
                 END val_clob,
                 flg_clob
                  FROM TABLE(l_tab_co_sign_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 2
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                --PERFORM
                UNION ALL (SELECT /*+opt_estimate (table db rows=1)*/
                           ddc.data_code_message,
                           flg_type,
                           data_source_val,
                           ddc.data_source,
                           db.rnk,
                           ddc.rank,
                           db.id_dd_block,
                           flg_html,
                           CASE
                                WHEN ddc.flg_clob = pk_alert_constant.g_yes THEN
                                 t_notes.column_value
                            END val_clob,
                           flg_clob
                            FROM (SELECT /*+opt_estimate (table t rows=1)*/
                                   t.*, row_number() over(PARTITION BY t.data_source ORDER BY t.rnk) AS rn
                                    FROM TABLE(l_tab_perform_data) t) db
                            LEFT JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                                       t.column_value, rownum AS rn
                                        FROM TABLE(l_tbl_perform_notes) t) t_notes
                              ON t_notes.rn = db.rn
                            JOIN dd_content ddc
                              ON ddc.data_source = db.data_source
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = l_area
                             AND ddc.id_dd_block = 3
                           WHERE ddc.id_dd_block = db.id_dd_block
                             AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                          UNION ALL
                          SELECT /*+opt_estimate (table db rows=1)*/
                           ddc.data_code_message,
                           flg_type,
                           data_source_val,
                           ddc.data_source,
                           db.rnk,
                           ddc.rank,
                           db.id_dd_block,
                           flg_html,
                           NULL val_clob,
                           flg_clob
                            FROM TABLE(l_tab_perform_images_data) db
                            JOIN dd_content ddc
                              ON ddc.data_source = db.data_source
                             AND ddc.flg_available = pk_alert_constant.g_yes
                             AND ddc.area = l_area
                             AND ddc.id_dd_block = 3
                           WHERE ddc.id_dd_block = db.id_dd_block
                             AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N')))
                --EXAM DOCUMENT
                UNION ALL
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 NULL val_clob,
                 flg_clob
                  FROM TABLE(l_tab_doc_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 4
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N'))
                --PROCEDURE_REVIEW
                UNION ALL
                SELECT /*+opt_estimate (table db rows=1)*/
                 ddc.data_code_message,
                 flg_type,
                 data_source_val,
                 ddc.data_source,
                 db.rnk,
                 ddc.rank,
                 db.id_dd_block,
                 flg_html,
                 NULL val_clob,
                 flg_clob
                  FROM TABLE(l_tab_review_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = l_area
                   AND ddc.id_dd_block = 5
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L2N')))
         ORDER BY id_dd_block DESC, rnk, rank;
    
        g_error := 'OPEN O_DETAIL';
        OPEN o_detail FOR
            SELECT descr, val, flg_type, flg_html, val_clob, flg_clob
              FROM (SELECT CASE
                                WHEN d.val IS NULL THEN
                                 d.descr
                                WHEN d.descr IS NULL THEN
                                 NULL
                                ELSE
                                 d.descr || decode(d.flg_type, 'LP', NULL, ': ')
                            END descr,
                           d.val,
                           d.flg_type,
                           flg_html,
                           val_clob,
                           flg_clob,
                           d.rn
                      FROM (SELECT rownum rn, descr, val, flg_type, flg_html, val_clob, flg_clob
                              FROM TABLE(l_tab_dd_data)) d
                      JOIN (SELECT rownum rn, column_value data_source
                             FROM TABLE(l_data_source_list)) ds
                        ON ds.rn = d.rn);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_package_owner,
                                              i_package  => g_package_name,
                                              i_function => 'GET_PROCEDURE_DETAIL_HISTORY',
                                              o_error    => o_error);
            pk_types.open_my_cursor(i_cursor => o_detail);
            RETURN FALSE;
    END get_procedure_detail_history;

    FUNCTION get_procedure_order
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_episode                   IN episode.id_episode%TYPE,
        i_interv_presc_det          IN interv_presc_det.id_interv_presc_det%TYPE,
        o_interv                    OUT pk_types.cursor_type,
        o_interv_clinical_questions OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_code_messages IS TABLE OF VARCHAR2(1000 CHAR) INDEX BY sys_message.code_message%TYPE;
    
        aa_code_messages t_code_messages;
    
        va_code_messages table_varchar := table_varchar('PROCEDURES_T096',
                                                        'PROCEDURES_T058',
                                                        'PROCEDURES_T081',
                                                        'PROCEDURES_T104',
                                                        'PROCEDURES_T122',
                                                        'PROCEDURES_T082',
                                                        'PROCEDURES_T091',
                                                        'PROCEDURES_T011',
                                                        'PROCEDURES_T143',
                                                        'PROCEDURES_T023',
                                                        'PROCEDURES_T025',
                                                        'PROCEDURES_T130',
                                                        'PROCEDURES_T131',
                                                        'PROCEDURES_T144',
                                                        'SUPPLIES_T076',
                                                        'PROCEDURES_T139',
                                                        'PROCEDURES_T092',
                                                        'PROCEDURES_T090',
                                                        'PROCEDURES_T123',
                                                        'PROCEDURES_T100',
                                                        'PROCEDURES_T138',
                                                        'PROCEDURES_T077',
                                                        'PROCEDURES_T010',
                                                        'PROCEDURES_T038',
                                                        'PROCEDURES_T133',
                                                        'PROCEDURES_T134',
                                                        'PROCEDURES_T135',
                                                        'PROCEDURES_T136',
                                                        'PROCEDURES_T137',
                                                        'PROCEDURES_T164',
                                                        'PROCEDURES_T185',
                                                        'PROCEDURES_T089',
                                                        'PROCEDURES_T029',
                                                        'PROCEDURES_T186',
                                                        'PROCEDURES_T024',
                                                        'PROCEDURES_T187',
                                                        'PROCEDURES_T036',
                                                        'PROCEDURES_T096',
                                                        'PROCEDURES_T151',
                                                        'PROCEDURES_T148',
                                                        'PROCEDURES_T149',
                                                        'PROCEDURES_T150',
                                                        'PROCEDURES_T152',
                                                        'PROCEDURES_T145');
    
        l_health_insurance sys_config.value%TYPE := pk_sysconfig.get_config('MCDT_HEALTH_INSURANCE', i_prof);
    
        l_intervention    intervention.id_intervention%TYPE;
        l_weight          VARCHAR2(50 CHAR);
        l_analysis_result pk_types.cursor_type;
    
        l_id     NUMBER;
        l_result VARCHAR2(100 CHAR);
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN va_code_messages.first .. va_code_messages.last
        LOOP
            aa_code_messages(va_code_messages(i)) := '<b>' ||
                                                     pk_message.get_message(i_lang, i_prof, va_code_messages(i)) ||
                                                     '</b> ';
        END LOOP;
    
        SELECT ipd.id_intervention
          INTO l_intervention
          FROM interv_presc_det ipd
         WHERE ipd.id_interv_presc_det = i_interv_presc_det;
    
        g_error := 'CALL PK_PROCEDURES_CORE.GET_PROCEDURE_PARAMETER_LIST';
        IF NOT pk_procedures_core.get_procedure_parameter_list(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_patient         => pk_episode.get_id_patient(i_episode),
                                                               i_intervention    => table_number(l_intervention),
                                                               o_weight          => l_weight,
                                                               o_analysis_result => l_analysis_result,
                                                               o_error           => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        FETCH l_analysis_result
            INTO l_id, l_result;
        CLOSE l_analysis_result;
    
        g_error := 'OPEN O_INTERV';
        OPEN o_interv FOR
            WITH cso_table AS
             (SELECT *
                FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang,
                                                                    i_prof,
                                                                    i_episode,
                                                                    NULL,
                                                                    NULL,
                                                                    NULL,
                                                                    i_interv_presc_det)))
            SELECT /*+ opt_estimate(table cso rows=2) opt_estimate(table csc rows=2) */
             ipd.id_interv_presc_det,
             pk_date_utils.date_char_tsz(i_lang, ip.dt_interv_prescription_tstz, i_prof.institution, i_prof.software) dt_reg,
             pk_prof_utils.get_name_signature(i_lang, i_prof, ip.id_professional) prof_reg,
             pk_prof_utils.get_spec_signature(i_lang,
                                              i_prof,
                                              ip.id_professional,
                                              ip.dt_interv_prescription_tstz,
                                              ip.id_episode) prof_spec_reg,
             aa_code_messages('PROCEDURES_T096') ||
             pk_procedures_utils.get_alias_translation(i_lang,
                                                       i_prof,
                                                       'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                       NULL) desc_procedure,
             NULL num_order,
             decode(pk_diagnosis.concat_diag(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof),
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T081') ||
                    pk_diagnosis.concat_diag(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof)) desc_diagnosis,
             decode(ipd.id_clinical_purpose,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T104') ||
                    decode(ipd.id_clinical_purpose,
                           0,
                           ipd.clinical_purpose_notes,
                           pk_translation.get_translation(i_lang,
                                                          'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                          ipd.id_clinical_purpose))) clinical_purpose,
             decode(ipd.flg_laterality,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T122') ||
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang)) laterality,
             decode(ipd.flg_prty,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T091') ||
                    pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', ipd.flg_prty, NULL)) priority,
             aa_code_messages('PROCEDURES_T011') ||
             decode(ipd.flg_referral,
                    pk_procedures_constant.g_flg_referral_r,
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                    pk_procedures_constant.g_flg_referral_s,
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                    pk_procedures_constant.g_flg_referral_i,
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS', ipd.flg_status, i_lang)) desc_status,
             decode(pk_api_order_sets.get_order_set_title(i_lang,
                                                          i_prof,
                                                          ipd.id_interv_presc_det,
                                                          pk_order_sets.g_odst_task_procedure),
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T143') ||
                    pk_api_order_sets.get_order_set_title(i_lang,
                                                          i_prof,
                                                          ipd.id_interv_presc_det,
                                                          pk_order_sets.g_odst_task_procedure)) title_order_set,
             NULL task_depend,
             aa_code_messages('PROCEDURES_T023') ||
             pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ip.flg_time, NULL) || ' (' ||
             pk_date_utils.date_char_tsz(i_lang, ipd.dt_begin_tstz, i_prof.institution, i_prof.software) || ')' desc_time,
             NULL desc_time_limit,
             aa_code_messages('PROCEDURES_T025') ||
             decode(ipd.id_order_recurrence,
                    NULL,
                    pk_message.get_message(i_lang, i_prof, 'ORDER_RECURRENCE_M004'),
                    pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang, i_prof, ipd.id_order_recurrence)) order_recurrence,
             decode(ipd.flg_prn,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T130') ||
                    pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang)) prn,
             decode(dbms_lob.getlength(ipd.prn_notes),
                    NULL,
                    to_clob(''),
                    aa_code_messages('PROCEDURES_T131') || ipd.prn_notes) notes_prn,
             aa_code_messages('PROCEDURES_T144') ||
             decode(ipd.id_exec_institution,
                    i_prof.institution,
                    pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                    pk_translation.get_translation(i_lang, 'AB_INSTITUTION.CODE_INSTITUTION.' || ipd.id_exec_institution)) perform_location,
             decode(cso.dt_ordered_by,
                    NULL,
                    decode(ipd.dt_order_tstz,
                           NULL,
                           NULL,
                           aa_code_messages('PROCEDURES_T010') ||
                           pk_date_utils.date_char_tsz(i_lang, ipd.dt_order_tstz, i_prof.institution, i_prof.software)),
                    NULL) dt_req,
             decode(pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                     i_prof,
                                                                     ipd.id_interv_presc_det,
                                                                     pk_supplies_constant.g_context_procedure_req),
                    NULL,
                    NULL,
                    aa_code_messages('SUPPLIES_T076') ||
                    pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                     i_prof,
                                                                     ipd.id_interv_presc_det,
                                                                     pk_supplies_constant.g_context_procedure_req)) desc_supplies,
             decode(l_result, NULL, NULL, aa_code_messages('PROCEDURES_T092') || l_result) lab_result,
             decode(l_weight, NULL, NULL, aa_code_messages('PROCEDURES_T090') || l_weight) weight,
             decode(pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason),
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T123') ||
                    pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason)) not_order_reason,
             decode(ipd.notes, NULL, NULL, aa_code_messages('PROCEDURES_T100') || ipd.notes) notes,
             decode(cso.desc_prof_ordered_by,
                    NULL,
                    NULL,
                    pk_procedures_constant.g_no,
                    aa_code_messages('PROCEDURES_T077') || cso.desc_prof_ordered_by) prof_order,
             decode(cso.dt_ordered_by,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T010') ||
                    pk_date_utils.date_char_tsz(i_lang, cso.dt_ordered_by, i_prof.institution, i_prof.software)) dt_order,
             decode(cso.id_order_type, NULL, NULL, aa_code_messages('PROCEDURES_T038') || cso.desc_order_type) order_type,
             decode(l_health_insurance,
                    pk_procedures_constant.g_no,
                    NULL,
                    decode(ipd.id_pat_health_plan,
                           NULL,
                           NULL,
                           aa_code_messages('PROCEDURES_T134') ||
                           pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'F'))) financial_entity,
             decode(l_health_insurance,
                    pk_procedures_constant.g_no,
                    NULL,
                    decode(ipd.id_pat_health_plan,
                           NULL,
                           NULL,
                           aa_code_messages('PROCEDURES_T135') ||
                           pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'H'))) health_plan,
             decode(l_health_insurance,
                    pk_procedures_constant.g_no,
                    NULL,
                    decode(ipd.id_pat_health_plan,
                           NULL,
                           NULL,
                           aa_code_messages('PROCEDURES_T136') ||
                           pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'N'))) insurance_number,
             decode(l_health_insurance,
                    pk_procedures_constant.g_no,
                    NULL,
                    decode(ipd.id_pat_exemption,
                           NULL,
                           NULL,
                           aa_code_messages('PROCEDURES_T137') ||
                           pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption))) exemption,
             decode(ipd.id_cancel_reason,
                    NULL,
                    NULL,
                    decode(ipd.flg_status,
                           pk_procedures_constant.g_interv_interrupted,
                           aa_code_messages('PROCEDURES_T186'),
                           aa_code_messages('PROCEDURES_T029')) ||
                    pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ipd.id_cancel_reason)) cancel_reason,
             decode(ipd.notes_cancel,
                    NULL,
                    NULL,
                    decode(ipd.flg_status,
                           pk_procedures_constant.g_interv_interrupted,
                           aa_code_messages('PROCEDURES_T187'),
                           aa_code_messages('PROCEDURES_T024')) || ipd.notes_cancel) cancel_notes,
             decode(csc.desc_prof_ordered_by,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T036') || csc.desc_prof_ordered_by) cancel_prof_order,
             decode(csc.dt_ordered_by,
                    NULL,
                    NULL,
                    aa_code_messages('PROCEDURES_T010') ||
                    pk_date_utils.date_char_tsz(i_lang, csc.dt_ordered_by, i_prof.institution, i_prof.software)) cancel_dt_order,
             decode(csc.id_order_type, NULL, NULL, aa_code_messages('PROCEDURES_T038') || csc.desc_order_type) cancel_order_type,
             pk_date_utils.date_send_tsz(i_lang, ip.dt_interv_prescription_tstz, i_prof) dt_ord
              FROM interv_presc_det ipd, interv_prescription ip, cso_table cso, cso_table csc
             WHERE ipd.id_interv_presc_det = i_interv_presc_det
               AND ipd.id_interv_prescription = ip.id_interv_prescription
               AND ipd.id_co_sign_order = cso.id_co_sign_hist(+)
               AND ipd.id_co_sign_cancel = csc.id_co_sign_hist(+);
    
        g_error := 'OPEN O_INTERV_CLINICAL_QUESTIONS';
        OPEN o_interv_clinical_questions FOR
            SELECT id_interv_presc_det, desc_clinical_question, to_clob(desc_response) desc_response
              FROM (SELECT DISTINCT iqr1.id_interv_presc_det,
                                    '<b>' || pk_mcdt.get_questionnaire_alias(i_lang,
                                                                             i_prof,
                                                                             'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' ||
                                                                             iqr1.id_questionnaire) || ':</b>' desc_clinical_question,
                                    dbms_lob.substr(decode(dbms_lob.getlength(iqr.notes),
                                                           NULL,
                                                           to_clob(decode(iqr1.desc_response,
                                                                          NULL,
                                                                          '---',
                                                                          iqr1.desc_response)),
                                                           pk_procedures_utils.get_procedure_response(i_lang,
                                                                                                      i_prof,
                                                                                                      iqr.notes)),
                                                    3800) desc_response,
                                    pk_procedures_utils.get_procedure_question_rank(i_lang,
                                                                                    i_prof,
                                                                                    ipd.id_intervention,
                                                                                    iqr.id_questionnaire,
                                                                                    iqr.flg_time) rank
                      FROM (SELECT iqr.id_interv_presc_det,
                                   iqr.id_questionnaire,
                                   listagg(pk_mcdt.get_response_alias(i_lang,
                                                                      i_prof,
                                                                      'RESPONSE.CODE_RESPONSE.' || iqr.id_response),
                                           '; ') within GROUP(ORDER BY iqr.id_response) desc_response,
                                   iqr.dt_last_update_tstz,
                                   row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                              FROM interv_question_response iqr
                             WHERE iqr.id_interv_presc_det = i_interv_presc_det
                               AND iqr.flg_time = pk_procedures_constant.g_interv_cq_on_order
                             GROUP BY iqr.id_interv_presc_det, iqr.id_questionnaire, iqr.dt_last_update_tstz) iqr1,
                           interv_question_response iqr,
                           interv_presc_det ipd
                     WHERE iqr1.rn = 1
                       AND iqr1.id_interv_presc_det = iqr.id_interv_presc_det
                       AND iqr1.id_questionnaire = iqr.id_questionnaire
                       AND iqr1.dt_last_update_tstz = iqr.dt_last_update_tstz
                       AND iqr.flg_time = pk_procedures_constant.g_interv_cq_on_order
                       AND iqr.id_interv_presc_det = ipd.id_interv_presc_det)
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_ORDER',
                                              o_error);
            pk_types.open_my_cursor(o_interv);
            pk_types.open_my_cursor(o_interv_clinical_questions);
            RETURN FALSE;
    END get_procedure_order;

    FUNCTION get_procedure_execution
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_interv_presc_plan     IN interv_presc_plan.id_interv_presc_plan%TYPE,
        o_interv                OUT pk_types.cursor_type,
        o_interv_images         OUT pk_types.cursor_type,
        o_interv_history        OUT pk_types.cursor_type,
        o_interv_images_history OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_code_messages IS TABLE OF VARCHAR2(1000 CHAR) INDEX BY sys_message.code_message%TYPE;
    
        aa_code_messages t_code_messages;
    
        va_code_messages table_varchar := table_varchar('PROCEDURES_T096',
                                                        'PROCEDURES_T110',
                                                        'PROCEDURES_T151',
                                                        'PROCEDURES_T111',
                                                        'PROCEDURES_T148',
                                                        'PROCEDURES_T112',
                                                        'PROCEDURES_T149',
                                                        'PROCEDURES_T113',
                                                        'PROCEDURES_T150',
                                                        'PROCEDURES_T114',
                                                        'PROCEDURES_T153',
                                                        'PROCEDURES_T120',
                                                        'PROCEDURES_T152',
                                                        'PROCEDURES_T115',
                                                        'PROCEDURES_T100',
                                                        'PROCEDURES_T116',
                                                        'PROCEDURES_T024',
                                                        'PROCEDURES_T029',
                                                        'PROCEDURES_T159',
                                                        'PROCEDURES_T162',
                                                        'PROCEDURES_T158',
                                                        'PROCEDURES_T155',
                                                        'PROCEDURES_T156',
                                                        'PROCEDURES_T161',
                                                        'PROCEDURES_T157',
                                                        'PROCEDURES_T160');
    
        l_msg_reg            sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
        l_msg_not_applicable sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M018');
        l_msg_del            sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M106');
    
        l_epis_documentation table_number := table_number();
        l_notes1             CLOB;
        l_notes2             CLOB;
    
        l_cur_interv_time_out_val pk_touch_option_out.t_cur_plain_text_entry;
        l_interv_time_out_val     pk_touch_option_out.t_rec_plain_text_entry;
        l_cur_interv_doc_val      pk_touch_option_out.t_cur_plain_text_entry;
        l_interv_doc_val          pk_touch_option_out.t_rec_plain_text_entry;
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        FOR i IN va_code_messages.first .. va_code_messages.last
        LOOP
            aa_code_messages(va_code_messages(i)) := '<b>' ||
                                                     pk_message.get_message(i_lang, i_prof, va_code_messages(i)) ||
                                                     '</b> ';
        END LOOP;
    
        SELECT ito.id_epis_documentation
          BULK COLLECT
          INTO l_epis_documentation
          FROM interv_time_out ito
         WHERE ito.id_interv_presc_plan = i_interv_presc_plan;
    
        FOR i IN 1 .. l_epis_documentation.count
        LOOP
            g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 1';
            pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                       i_prof                    => i_prof,
                                                       i_epis_documentation_list => table_number(l_epis_documentation(i)),
                                                       i_use_html_format         => pk_procedures_constant.g_yes,
                                                       o_entries                 => l_cur_interv_time_out_val);
        
            FETCH l_cur_interv_time_out_val
                INTO l_interv_time_out_val;
            CLOSE l_cur_interv_time_out_val;
        
            l_notes1 := REPLACE(l_interv_time_out_val.plain_text_entry, chr(10) || chr(10), chr(10));
            l_notes1 := REPLACE(l_notes1, chr(10), chr(10) || chr(9));
        END LOOP;
    
        SELECT ipp.id_epis_documentation
          BULK COLLECT
          INTO l_epis_documentation
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
           AND ipp.id_epis_documentation IS NOT NULL;
    
        FOR i IN 1 .. l_epis_documentation.count
        LOOP
            g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 2';
            pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                       i_prof                    => i_prof,
                                                       i_epis_documentation_list => table_number(l_epis_documentation(i)),
                                                       i_use_html_format         => pk_procedures_constant.g_yes,
                                                       o_entries                 => l_cur_interv_doc_val);
        
            FETCH l_cur_interv_doc_val
                INTO l_interv_doc_val;
            CLOSE l_cur_interv_doc_val;
        
            l_notes2 := REPLACE(l_interv_doc_val.plain_text_entry, chr(10) || chr(10), chr(10));
            l_notes2 := REPLACE(l_notes2, chr(10), chr(10) || chr(9));
        END LOOP;
    
        IF dbms_lob.getlength(l_notes2) IS NULL
           OR dbms_lob.getlength(l_notes2) = 0
        THEN
            SELECT to_clob(ipp.notes)
              INTO l_notes2
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan;
        END IF;
    
        g_error := 'OPEN O_INTERV';
        OPEN o_interv FOR
            SELECT ipp.id_interv_presc_plan,
                   l_msg_reg || ' ' ||
                   pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ipp.id_prof_take, ipp.id_prof_cancel)) ||
                   decode(pk_prof_utils.get_spec_signature(i_lang,
                                                           i_prof,
                                                           nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                           nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                           ipp.id_episode_write),
                          NULL,
                          '; ',
                          ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                   i_prof,
                                                                   nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                                   nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                                   ipp.id_episode_write) || '); ') ||
                   pk_date_utils.date_char_tsz(i_lang,
                                               nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                               i_prof.institution,
                                               i_prof.software) registry,
                   aa_code_messages('PROCEDURES_T096') ||
                   pk_procedures_utils.get_alias_translation(i_lang,
                                                             i_prof,
                                                             'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                             NULL) desc_procedure,
                   decode(ipp.id_prof_performed,
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T151') ||
                          pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed)) prof_perform,
                   decode(ipp.start_time,
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T148') ||
                          pk_date_utils.date_char_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software)) start_time,
                   decode(ipp.end_time,
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T149') ||
                          pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software)) end_time,
                   aa_code_messages('PROCEDURES_T150') ||
                   decode(ipd.flg_prn,
                          pk_procedures_constant.g_yes,
                          l_msg_not_applicable,
                          nvl((SELECT pk_date_utils.date_char_tsz(i_lang,
                                                                 i.dt_plan_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software)
                                FROM interv_presc_plan i
                               WHERE i.id_interv_presc_det = ipd.id_interv_presc_det
                                 AND i.exec_number = ipp.exec_number + 1),
                              l_msg_not_applicable)) next_perform_date,
                   decode(pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan),
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T153') ||
                          pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan)) desc_modifiers,
                   decode(pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                           i_prof,
                                                                           i_interv_presc_plan,
                                                                           pk_supplies_constant.g_context_procedure_exec),
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T152') ||
                          pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                           i_prof,
                                                                           i_interv_presc_plan,
                                                                           pk_supplies_constant.g_context_procedure_exec)) desc_supplies,
                   decode(dbms_lob.getlength(l_notes1), NULL, to_clob(''), l_notes1) desc_time_out,
                   decode(dbms_lob.getlength(l_notes2),
                          NULL,
                          to_clob(''),
                          decode(instr(lower(l_notes2), '<b>'),
                                 0,
                                 to_clob(aa_code_messages('PROCEDURES_T100')) || l_notes2,
                                 l_notes2)) desc_perform,
                   decode(ipp.id_cancel_reason,
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T029') ||
                          pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ipp.id_cancel_reason)) cancel_reason,
                   decode(ipp.notes_cancel, NULL, NULL, aa_code_messages('PROCEDURES_T024') || ipp.notes_cancel) cancel_notes,
                   pk_date_utils.date_send_tsz(i_lang, ipp.dt_plan_tstz, i_prof) dt_ord
              FROM interv_presc_plan ipp, interv_presc_det ipd
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
               AND ipp.id_interv_presc_det = ipd.id_interv_presc_det
             ORDER BY dt_ord DESC;
    
        g_error := 'OPEN O_INTERV_IMAGES';
        OPEN o_interv_images FOR
            SELECT ipp.id_interv_presc_plan,
                   ipp.id_interv_presc_det,
                   ima.id_doc_external,
                   decode(de.title, NULL, NULL, aa_code_messages('PROCEDURES_T158') || de.title) doc_title,
                   decode(de.desc_perf_by,
                          NULL,
                          decode(ipp.id_prof_performed,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T155') ||
                                 pk_prof_utils.get_nickname(i_lang, ipp.id_prof_performed)),
                          aa_code_messages('PROCEDURES_T155') || de.desc_perf_by) perform_by,
                   decode(de.dt_emited,
                          NULL,
                          decode(ipp.dt_interv_presc_plan,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T156') ||
                                 pk_date_utils.dt_chr_tsz(i_lang, ipp.dt_interv_presc_plan, i_prof)),
                          aa_code_messages('PROCEDURES_T156') || pk_date_utils.dt_chr(i_lang, de.dt_emited, i_prof)) dt_doc,
                   decode(de.desc_doc_destination,
                          NULL,
                          decode(de.id_doc_destination,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T161') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_TYPE.CODE_DOC_DESTINATION.' || de.id_doc_destination)),
                          aa_code_messages('PROCEDURES_T161') || de.desc_doc_destination) doc_original_destination,
                   decode(de.desc_doc_ori_type,
                          NULL,
                          decode(de.id_doc_ori_type,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T162') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type)),
                          aa_code_messages('PROCEDURES_T162') || de.desc_doc_ori_type) doc_original_type,
                   aa_code_messages('PROCEDURES_T157') || pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                   decode(de.desc_doc_original,
                          NULL,
                          decode(de.id_doc_original,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T160') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original)),
                          aa_code_messages('PROCEDURES_T160') || de.desc_doc_original) doc_original_desc,
                   decode(pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external),
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T100') ||
                          pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external)) notes,
                   NULL thumbnail_img,
                   NULL thumbnail_report,
                   pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                   NULL thumbnail_img_icon,
                   NULL thumbnail_report_icon,
                   to_char(pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external)) thumbnail_icon,
                   pk_date_utils.date_send_tsz(i_lang, ipp.dt_last_update_tstz, i_prof) dt_ord
              FROM interv_presc_plan ipp, interv_media_archive ima, doc_external de
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
               AND ipp.id_interv_presc_plan = ima.id_interv_presc_plan
               AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_exec
               AND ima.id_doc_external = de.id_doc_external
               AND de.flg_status = pk_alert_constant.g_active
             ORDER BY dt_ord DESC;
    
        DELETE tbl_temp;
    
        SELECT ito.id_epis_documentation
          BULK COLLECT
          INTO l_epis_documentation
          FROM interv_time_out ito
         WHERE ito.id_interv_presc_plan = i_interv_presc_plan;
    
        FOR i IN 1 .. l_epis_documentation.count
        LOOP
            g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 1';
            pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                       i_prof                    => i_prof,
                                                       i_epis_documentation_list => table_number(l_epis_documentation(i)),
                                                       i_use_html_format         => pk_procedures_constant.g_yes,
                                                       o_entries                 => l_cur_interv_time_out_val);
        
            FETCH l_cur_interv_time_out_val
                INTO l_interv_time_out_val;
            CLOSE l_cur_interv_time_out_val;
        
            l_notes1 := REPLACE(l_interv_time_out_val.plain_text_entry, chr(10) || chr(10), chr(10));
            l_notes1 := REPLACE(l_notes1, chr(10), chr(10) || chr(9));
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2)
            VALUES
                ((SELECT ito.id_interv_presc_plan
                   FROM interv_time_out ito
                  WHERE ito.id_epis_documentation = l_interv_time_out_val.id_epis_documentation),
                 l_interv_time_out_val.id_epis_documentation,
                 l_notes1,
                 'ITO');
        END LOOP;
    
        l_epis_documentation := NULL;
    
        SELECT id_epis_documentation
          BULK COLLECT
          INTO l_epis_documentation
          FROM (SELECT ipp.id_epis_documentation
                  FROM interv_presc_plan ipp
                 WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
                   AND ipp.id_epis_documentation IS NOT NULL
                UNION ALL
                SELECT ipph.id_epis_documentation
                  FROM interv_presc_plan_hist ipph
                 WHERE ipph.id_interv_presc_plan = i_interv_presc_plan
                   AND ipph.id_epis_documentation IS NOT NULL);
    
        g_error := 'OPEN O_INTERV_HISTORY';
        OPEN o_interv_history FOR
            SELECT ipp.id_interv_presc_plan,
                   l_msg_reg || ' ' ||
                   pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ipp.id_prof_take, ipp.id_prof_cancel)) ||
                   decode(pk_prof_utils.get_spec_signature(i_lang,
                                                           i_prof,
                                                           nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                           nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                           ipp.id_episode_write),
                          NULL,
                          '; ',
                          ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                   i_prof,
                                                                   nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                                   nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                                   ipp.id_episode_write) || '); ') ||
                   pk_date_utils.date_char_tsz(i_lang,
                                               nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                               i_prof.institution,
                                               i_prof.software) registry,
                   decode(cnt,
                          rn,
                          aa_code_messages('PROCEDURES_T096') ||
                          pk_procedures_utils.get_alias_translation(i_lang,
                                                                    i_prof,
                                                                    'INTERVENTION.CODE_INTERVENTION.' ||
                                                                    ipp.id_intervention,
                                                                    NULL),
                          NULL) desc_procedure,
                   decode(cnt,
                          rn,
                          aa_code_messages('PROCEDURES_T151') ||
                          pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed),
                          decode(ipp.id_prof_performed,
                                 ipp.id_prof_performed_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T114') || '§' ||
                                 pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed) || chr(10) ||
                                 chr(9) || aa_code_messages('PROCEDURES_T151') ||
                                 pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed_new))) prof_perform,
                   decode(cnt,
                          rn,
                          decode(ipp.start_time,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T148') ||
                                 pk_date_utils.date_char_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software)),
                          decode(ipp.start_time,
                                 ipp.start_time_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T111') || '§' ||
                                 pk_date_utils.date_char_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software) ||
                                 chr(10) || chr(9) || aa_code_messages('PROCEDURES_T148') ||
                                 pk_date_utils.date_char_tsz(i_lang,
                                                             ipp.start_time_new,
                                                             i_prof.institution,
                                                             i_prof.software))) start_time,
                   decode(cnt,
                          rn,
                          decode(ipp.start_time,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T149') ||
                                 pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software)),
                          decode(ipp.end_time,
                                 ipp.end_time_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T112') || '§' ||
                                 pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software) ||
                                 chr(10) || chr(9) || aa_code_messages('PROCEDURES_T149') ||
                                 pk_date_utils.date_char_tsz(i_lang,
                                                             ipp.end_time_new,
                                                             i_prof.institution,
                                                             i_prof.software))) end_time,
                   decode(cnt,
                          rn,
                          aa_code_messages('PROCEDURES_T150') ||
                          decode(ipp.flg_prn,
                                 pk_procedures_constant.g_yes,
                                 l_msg_not_applicable,
                                 nvl(pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.dt_plan_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software),
                                     l_msg_not_applicable)),
                          decode(ipp.dt_plan_tstz,
                                 ipp.dt_plan_tstz_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T113') || '§' ||
                                 pk_date_utils.date_char_tsz(i_lang,
                                                             ipp.dt_plan_tstz,
                                                             i_prof.institution,
                                                             i_prof.software) || chr(10) || chr(9) ||
                                 aa_code_messages('PROCEDURES_T150') ||
                                 pk_date_utils.date_char_tsz(i_lang,
                                                             ipp.dt_plan_tstz_new,
                                                             i_prof.institution,
                                                             i_prof.software))) next_perform_date,
                   decode(cnt,
                          rn,
                          decode(ipp.desc_modifiers,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T153') || ipp.desc_modifiers),
                          decode(ipp.desc_modifiers,
                                 ipp.desc_modifiers_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T120') || '§' ||
                                 decode(ipp.desc_modifiers, NULL, l_msg_del, ipp.desc_modifiers) ||
                                 decode(ipp.desc_modifiers_new,
                                        NULL,
                                        NULL,
                                        chr(10) || chr(9) || aa_code_messages('PROCEDURES_T153') || ipp.desc_modifiers_new))) desc_modifiers,
                   decode(cnt,
                          rn,
                          decode(ipp.desc_supplies, NULL, NULL, aa_code_messages('PROCEDURES_T152') || ipp.desc_supplies),
                          decode(ipp.desc_supplies,
                                 ipp.desc_supplies_new,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T152') || '§' ||
                                 decode(ipp.desc_supplies, NULL, l_msg_del, ipp.desc_supplies) ||
                                 decode(ipp.desc_supplies_new,
                                        NULL,
                                        NULL,
                                        chr(10) || chr(9) || aa_code_messages('PROCEDURES_T152') || ipp.desc_supplies_new))) desc_supplies,
                   decode(cnt,
                          rn,
                          decode(ipp.time_out_notes, NULL, NULL, ipp.time_out_notes),
                          decode(ipp.time_out_notes,
                                 ipp.time_out_notes_new,
                                 NULL,
                                 '§' || decode(ipp.time_out_notes, NULL, l_msg_del, ipp.time_out_notes) ||
                                 decode(ipp.time_out_notes_new, NULL, NULL, ipp.time_out_notes_new))) desc_time_out,
                   decode(cnt,
                          rn,
                          decode(dbms_lob.getlength(edd.notes),
                                 NULL,
                                 to_clob(''),
                                 decode(instr(lower(edd.notes), '<b>'),
                                        0,
                                        to_clob(aa_code_messages('PROCEDURES_T100') || edd.notes),
                                        edd.notes)),
                          decode(dbms_lob.compare(edd.notes, edd_n.notes),
                                 0,
                                 to_clob(''),
                                 decode(instr(lower(edd.notes), '<b>'),
                                        0,
                                        aa_code_messages('PROCEDURES_T116') || '§' ||
                                        decode(dbms_lob.getlength(edd.notes), NULL, l_msg_del, edd.notes) ||
                                        decode(dbms_lob.getlength(edd_n.notes),
                                               NULL,
                                               to_clob(''),
                                               chr(10) || chr(9) || aa_code_messages('PROCEDURES_T100') || edd_n.notes),
                                        edd.notes))) desc_perform,
                   NULL cancel_reason,
                   NULL cancel_notes
              FROM (SELECT row_number() over(ORDER BY t.dt_interv_presc_plan_hist DESC NULLS FIRST) rn,
                           COUNT(1) over() cnt,
                           t.id_interv_presc_plan,
                           t.id_interv_presc_det,
                           t.id_episode_write,
                           first_value(t.id_episode_write) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_episode_write_new,
                           t.id_intervention,
                           t.dt_interv_presc_plan,
                           first_value(t.dt_interv_presc_plan) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_interv_presc_plan_new,
                           t.flg_status,
                           first_value(t.flg_status) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_status_new,
                           t.flg_prn,
                           t.id_wound_treat,
                           first_value(t.id_wound_treat) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_wound_treat_new,
                           t.id_prof_take,
                           first_value(t.id_prof_take) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_take_new,
                           t.dt_take_tstz,
                           first_value(t.dt_take_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_take_tstz_new,
                           t.id_prof_performed,
                           first_value(t.id_prof_performed) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_performed_new,
                           t.start_time,
                           first_value(t.start_time) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) start_time_new,
                           t.end_time,
                           first_value(t.end_time) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) end_time_new,
                           t.dt_plan_tstz,
                           first_value(t.dt_plan_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_plan_tstz_new,
                           t.flg_supplies_reg,
                           first_value(t.flg_supplies_reg) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_supplies_reg_new,
                           t.time_out_notes,
                           first_value(t.time_out_notes) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) time_out_notes_new,
                           t.id_epis_documentation,
                           first_value(t.id_epis_documentation) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_epis_documentation_new,
                           t.id_epis_documentation notes,
                           first_value(t.id_epis_documentation) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_new,
                           t.id_prof_cancel,
                           first_value(t.id_prof_cancel) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_cancel_new,
                           t.dt_cancel_tstz,
                           first_value(t.dt_cancel_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_cancel_tstz_new,
                           t.id_cancel_reason,
                           first_value(t.id_cancel_reason) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cancel_reason_new,
                           t.notes_cancel,
                           first_value(t.notes_cancel) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_cancel_new,
                           t.id_cdr_event,
                           first_value(t.id_cdr_event) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cdr_event_new,
                           t.exec_number,
                           first_value(t.exec_number) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) exec_number_new,
                           t.desc_supplies,
                           first_value(t.desc_supplies) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_supplies_new,
                           t.desc_modifiers,
                           first_value(t.desc_modifiers) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_modifiers_new
                      FROM (SELECT NULL dt_interv_presc_plan_hist,
                                   ipp.id_interv_presc_plan,
                                   ipp.id_interv_presc_det,
                                   ipp.id_episode_write,
                                   ipd.id_intervention,
                                   ipp.dt_interv_presc_plan,
                                   ipp.flg_status,
                                   ipd.flg_prn,
                                   ipp.id_wound_treat,
                                   ipp.id_prof_take,
                                   ipp.dt_take_tstz,
                                   ipp.id_prof_performed,
                                   ipp.start_time,
                                   ipp.end_time,
                                   (SELECT i.dt_plan_tstz
                                      FROM interv_presc_plan i
                                     WHERE i.id_interv_presc_det = ipd.id_interv_presc_det
                                       AND i.exec_number = ipp.exec_number + 1) dt_plan_tstz,
                                   ipp.flg_supplies_reg,
                                   ito.time_out_notes,
                                   ipp.id_epis_documentation,
                                   ipp.id_prof_cancel,
                                   ipp.dt_cancel_tstz,
                                   ipp.id_cancel_reason,
                                   ipp.notes_cancel,
                                   ipp.id_cdr_event,
                                   ipp.exec_number,
                                   pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                    i_prof,
                                                                                    ipp.id_interv_presc_plan,
                                                                                    pk_supplies_constant.g_context_procedure_exec) desc_supplies,
                                   pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan) desc_modifiers
                              FROM interv_presc_plan ipp,
                                   (SELECT tt.num_1 id_interv_presc_plan,
                                           tt.num_2 id_epis_documentation,
                                           tt.vc_1  time_out_notes
                                      FROM tbl_temp tt
                                     WHERE tt.vc_2 = 'ITO') ito,
                                   interv_presc_det ipd
                             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
                               AND ipp.id_interv_presc_plan = ito.id_interv_presc_plan(+)
                               AND ipp.id_interv_presc_det = ipd.id_interv_presc_det
                            UNION ALL
                            SELECT ipph.dt_interv_presc_plan_hist,
                                   ipph.id_interv_presc_plan,
                                   ipph.id_interv_presc_det,
                                   ipph.id_episode_write,
                                   ipd.id_intervention,
                                   ipph.dt_interv_presc_plan,
                                   ipph.flg_status,
                                   ipd.flg_prn,
                                   ipph.id_wound_treat,
                                   ipph.id_prof_take,
                                   ipph.dt_take_tstz,
                                   ipph.id_prof_performed,
                                   ipph.start_time,
                                   ipph.end_time,
                                   (SELECT i.dt_plan_tstz
                                      FROM interv_presc_plan i
                                     WHERE i.id_interv_presc_det = ipd.id_interv_presc_det
                                       AND i.exec_number = ipph.exec_number + 1) dt_plan_tstz,
                                   ipph.flg_supplies_reg,
                                   ito.time_out_notes,
                                   ipph.id_epis_documentation,
                                   ipph.id_prof_cancel,
                                   ipph.dt_cancel_tstz,
                                   ipph.id_cancel_reason,
                                   ipph.notes_cancel,
                                   ipph.id_cdr_event,
                                   ipph.exec_number,
                                   pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                    i_prof,
                                                                                    ipph.id_interv_presc_plan,
                                                                                    pk_supplies_constant.g_context_procedure_exec) desc_supplies,
                                   pk_procedures_utils.get_procedure_modifiers(i_lang,
                                                                               i_prof,
                                                                               ipph.id_interv_presc_plan_hist) desc_modifiers
                              FROM interv_presc_plan_hist ipph,
                                   (SELECT tt.num_1 id_interv_presc_plan,
                                           tt.num_2 id_epis_documentation,
                                           tt.vc_1  time_out_notes
                                      FROM tbl_temp tt
                                     WHERE tt.vc_2 = 'ITO') ito,
                                   interv_presc_det ipd
                             WHERE ipph.id_interv_presc_plan = i_interv_presc_plan
                               AND ipph.id_interv_presc_plan = ito.id_interv_presc_plan(+)
                               AND ipph.id_interv_presc_det = ipd.id_interv_presc_det
                               AND NOT EXISTS
                             (SELECT 1
                                      FROM interv_presc_plan ipp
                                     WHERE ipph.id_interv_presc_plan = ipp.id_interv_presc_plan
                                       AND ipp.flg_status = pk_procedures_constant.g_interv_cancel)
                             ORDER BY dt_interv_presc_plan_hist DESC NULLS FIRST) t
                     ORDER BY rn) ipp
              LEFT JOIN epis_documentation edd
                ON edd.id_epis_documentation = ipp.notes
              LEFT JOIN epis_documentation edd_n
                ON edd_n.id_epis_documentation = ipp.notes_new;
    
        g_error := 'OPEN O_INTERV_IMAGES_HISTORY';
        OPEN o_interv_images_history FOR
            SELECT ipp.id_interv_presc_plan,
                   ipp.id_interv_presc_det,
                   ima.id_doc_external,
                   decode(de.title, NULL, NULL, aa_code_messages('PROCEDURES_T158') || de.title) doc_title,
                   decode(de.desc_perf_by,
                          NULL,
                          decode(ipp.id_prof_performed,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T155') ||
                                 pk_prof_utils.get_nickname(i_lang, ipp.id_prof_performed)),
                          aa_code_messages('PROCEDURES_T155') || de.desc_perf_by) perform_by,
                   decode(de.dt_emited,
                          NULL,
                          decode(ipp.dt_interv_presc_plan,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T156') ||
                                 pk_date_utils.dt_chr_tsz(i_lang, ipp.dt_interv_presc_plan, i_prof)),
                          aa_code_messages('PROCEDURES_T156') || pk_date_utils.dt_chr(i_lang, de.dt_emited, i_prof)) dt_doc,
                   decode(de.desc_doc_destination,
                          NULL,
                          decode(de.id_doc_destination,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T161') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_TYPE.CODE_DOC_DESTINATION.' || de.id_doc_destination)),
                          aa_code_messages('PROCEDURES_T161') || de.desc_doc_destination) doc_original_destination,
                   decode(de.desc_doc_ori_type,
                          NULL,
                          decode(de.id_doc_ori_type,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T162') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type)),
                          aa_code_messages('PROCEDURES_T162') || de.desc_doc_ori_type) doc_original_type,
                   aa_code_messages('PROCEDURES_T157') || pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                   decode(de.desc_doc_original,
                          NULL,
                          decode(de.id_doc_original,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T160') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original)),
                          aa_code_messages('PROCEDURES_T160') || de.desc_doc_original) doc_original_desc,
                   decode(pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external),
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T100') ||
                          pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external)) notes,
                   NULL thumbnail_img,
                   NULL thumbnail_report,
                   pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                   NULL thumbnail_img_icon,
                   NULL thumbnail_report_icon,
                   to_char(pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external)) thumbnail_icon,
                   pk_date_utils.date_send_tsz(i_lang, ipp.dt_last_update_tstz, i_prof) dt_ord
              FROM interv_presc_plan ipp, interv_media_archive ima, doc_external de
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
               AND ipp.id_interv_presc_plan = ima.id_interv_presc_plan
               AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_exec
               AND ima.id_doc_external = de.id_doc_external
               AND de.flg_status = pk_alert_constant.g_active
            UNION ALL
            SELECT ipph.id_interv_presc_plan,
                   ipph.id_interv_presc_det,
                   ima.id_doc_external,
                   decode(de.title, NULL, NULL, aa_code_messages('PROCEDURES_T158') || de.title) doc_title,
                   decode(de.desc_perf_by,
                          NULL,
                          decode(ipph.id_prof_performed,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T155') ||
                                 pk_prof_utils.get_nickname(i_lang, ipph.id_prof_performed)),
                          aa_code_messages('PROCEDURES_T155') || de.desc_perf_by) perform_by,
                   decode(de.dt_emited,
                          NULL,
                          decode(ipph.dt_interv_presc_plan,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T156') ||
                                 pk_date_utils.dt_chr_tsz(i_lang, ipph.dt_interv_presc_plan, i_prof)),
                          aa_code_messages('PROCEDURES_T156') || pk_date_utils.dt_chr(i_lang, de.dt_emited, i_prof)) dt_doc,
                   decode(de.desc_doc_destination,
                          NULL,
                          decode(de.id_doc_destination,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T161') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_TYPE.CODE_DOC_DESTINATION.' || de.id_doc_destination)),
                          aa_code_messages('PROCEDURES_T161') || de.desc_doc_destination) doc_original_destination,
                   decode(de.desc_doc_ori_type,
                          NULL,
                          decode(de.id_doc_ori_type,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T162') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type)),
                          aa_code_messages('PROCEDURES_T162') || de.desc_doc_ori_type) doc_original_type,
                   aa_code_messages('PROCEDURES_T157') || pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                   decode(de.desc_doc_original,
                          NULL,
                          decode(de.id_doc_original,
                                 NULL,
                                 NULL,
                                 aa_code_messages('PROCEDURES_T160') ||
                                 pk_translation.get_translation(i_lang,
                                                                'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original)),
                          aa_code_messages('PROCEDURES_T160') || de.desc_doc_original) doc_original_desc,
                   decode(pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external),
                          NULL,
                          NULL,
                          aa_code_messages('PROCEDURES_T100') ||
                          pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external)) notes,
                   NULL thumbnail_img,
                   NULL thumbnail_report,
                   pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                   NULL thumbnail_img_icon,
                   NULL thumbnail_report_icon,
                   to_char(pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external)) thumbnail_icon,
                   pk_date_utils.date_send_tsz(i_lang, ipph.dt_last_update_tstz, i_prof) dt_ord
              FROM interv_presc_plan_hist ipph, interv_media_archive ima, doc_external de
             WHERE ipph.id_interv_presc_plan = i_interv_presc_plan
               AND ipph.id_interv_presc_plan = ima.id_interv_presc_plan
               AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_exec
               AND ima.id_doc_external = de.id_doc_external
               AND de.flg_status = pk_alert_constant.g_active
               AND NOT EXISTS (SELECT 1
                      FROM interv_presc_plan ipp
                     WHERE ipph.id_interv_presc_plan = ipp.id_interv_presc_plan)
             ORDER BY dt_ord DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_EXECUTION',
                                              o_error);
            pk_types.open_my_cursor(o_interv);
            pk_types.open_my_cursor(o_interv_images);
            pk_types.open_my_cursor(o_interv_history);
            pk_types.open_my_cursor(o_interv_images_history);
            RETURN FALSE;
    END get_procedure_execution;

    FUNCTION get_procedure_doc_associated
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_interv_presc_det  IN interv_presc_det.id_interv_presc_det%TYPE,
        i_interv_presc_plan IN interv_presc_plan.id_interv_presc_plan%TYPE,
        o_interv_doc        OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        -- Obter detalhes
        g_error := 'OPEN O_INTERV_DOC';
        OPEN o_interv_doc FOR
            SELECT ima.id_interv_presc_det,
                   ima.id_doc_external,
                   pk_date_utils.date_char_tsz(i_lang, de.dt_inserted, i_prof.institution, i_prof.software) dt_reg,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, de.id_professional) prof_reg,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, de.id_professional, de.dt_inserted, NULL) prof_spec_reg,
                   de.title doc_title,
                   decode(de.desc_doc_ori_type,
                          NULL,
                          pk_translation.get_translation(i_lang, 'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type),
                          de.desc_doc_ori_type) doc_original_type,
                   pk_sysdomain.get_domain('DOC_EXTERNAL.FLG_STATUS', de.flg_status, i_lang) desc_status,
                   pk_date_utils.dt_chr(i_lang, de.dt_emited, i_prof) dt_doc,
                   de.desc_perf_by perform_by,
                   pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                   decode(de.desc_doc_original,
                          NULL,
                          pk_translation.get_translation(i_lang, 'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original),
                          de.desc_doc_original) doc_original_desc,
                   decode(de.desc_doc_destination,
                          NULL,
                          pk_translation.get_translation(i_lang,
                                                         'DOC_TYPE.CODE_DOC_DESTINATION.' || de.id_doc_destination),
                          de.desc_doc_destination) doc_original_destination,
                   pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external) notes,
                   pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                   pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) thumbnail_icon
              FROM interv_media_archive ima, doc_external de
             WHERE ((ima.id_interv_presc_det = i_interv_presc_det AND
                   ima.flg_type = pk_procedures_constant.g_media_archive_interv_doc AND i_interv_presc_plan IS NULL) OR
                   (ima.id_interv_presc_plan = i_interv_presc_plan AND
                   ima.flg_type = pk_procedures_constant.g_media_archive_interv_exec AND i_interv_presc_det IS NULL))
               AND ima.flg_status = pk_procedures_constant.g_active
               AND ima.id_doc_external = de.id_doc_external
             ORDER BY de.flg_status, de.dt_inserted DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DOC_ASSOCIATED',
                                              o_error);
            pk_types.open_my_cursor(o_interv_doc);
            RETURN FALSE;
    END get_procedure_doc_associated;

    FUNCTION get_procedure_to_edit
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_episode                   IN episode.id_episode%TYPE,
        i_interv_presc_det          IN table_number,
        o_interv                    OUT pk_types.cursor_type,
        o_interv_supplies           OUT pk_types.cursor_type,
        o_interv_clinical_questions OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'OPEN O_INTERV';
        OPEN o_interv FOR
            WITH cso_table AS
             (SELECT *
                FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang, i_prof, i_episode, NULL)))
            SELECT /*+ opt_estimate(table cso rows=1) */
             ip.id_interv_prescription,
             ipd.id_interv_presc_det,
             ipd.id_intervention,
             ipd.flg_status,
             pk_procedures_utils.get_alias_translation(i_lang,
                                                       i_prof,
                                                       'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                       NULL) desc_intervention,
             ipd.diagnosis_notes,
             pk_diagnosis.concat_diag_id(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof, 'D') id_diagnosis,
             pk_diagnosis.concat_diag_id(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof, 'S') id_alert_diagnosis,
             pk_diagnosis.concat_diag_id(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof, 'C') code_diagnosis,
             pk_diagnosis.concat_diag_id(i_lang,
                                         NULL,
                                         NULL,
                                         ipd.id_interv_presc_det,
                                         i_prof,
                                         'T',
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         pk_alert_constant.g_no) desc_diagnosis,
             ipd.id_clinical_purpose,
             ipd.clinical_purpose_notes,
             decode(ipd.id_clinical_purpose,
                    0,
                    ipd.clinical_purpose_notes,
                    pk_translation.get_translation(i_lang,
                                                   'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                   ipd.id_clinical_purpose)) clinical_purpose,
             ipd.flg_laterality,
             pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', ipd.id_intervention) flg_laterality_mcdt,
             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang) laterality,
             ipd.flg_prty flg_priority,
             pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', ipd.flg_prty, NULL) priority,
             decode(nvl(ip.id_episode, ip.id_episode_origin), NULL, NULL, ip.flg_time) flg_time,
             decode(nvl(ip.id_episode, ip.id_episode_origin),
                    NULL,
                    NULL,
                    pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ip.flg_time, NULL)) desc_time,
             CASE
                  WHEN ip.flg_time IN (pk_procedures_constant.g_flg_time_e,
                                       pk_procedures_constant.g_flg_time_a,
                                       pk_procedures_constant.g_flg_time_h,
                                       pk_procedures_constant.g_flg_time_b) THEN
                   pk_date_utils.trunc_insttimezone_str(i_prof, ip.dt_begin_tstz, 'MI')
                  ELSE
                   pk_date_utils.trunc_insttimezone_str(i_prof, ipd.dt_begin_tstz, 'MI')
              END dt_begin_str,
             CASE
                  WHEN ip.flg_time IN (pk_procedures_constant.g_flg_time_e,
                                       pk_procedures_constant.g_flg_time_a,
                                       pk_procedures_constant.g_flg_time_h,
                                       pk_procedures_constant.g_flg_time_b) THEN
                   pk_date_utils.date_char_tsz(i_lang, ip.dt_begin_tstz, i_prof.institution, i_prof.software)
                  ELSE
                   pk_date_utils.date_char_tsz(i_lang, ipd.dt_begin_tstz, i_prof.institution, i_prof.software)
              END dt_begin,
             ipd.flg_prn,
             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang) prn,
             ipd.prn_notes notes_prn,
             nvl(ipd.id_order_recurrence, 0) id_order_recurrence,
             decode(ipd.id_order_recurrence,
                    NULL,
                    pk_translation.get_translation(i_lang, 'ORDER_RECURR_OPTION.CODE_ORDER_RECURR_OPTION.0'),
                    pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang, i_prof, ipd.id_order_recurrence)) order_recurrence,
             decode(ipd.flg_location,
                    pk_procedures_constant.g_flg_location_hhc,
                    pk_procedures_constant.g_id_location_hhc,
                    ipd.id_exec_institution) id_exec_institution,
             decode(ipd.flg_location,
                    pk_procedures_constant.g_flg_location_hhc,
                    pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                    decode(ipd.id_exec_institution,
                           i_prof.institution,
                           pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                           pk_translation.get_translation(i_lang,
                                                          'AB_INSTITUTION.CODE_INSTITUTION.' || ipd.id_exec_institution))) perform_location,
             ipd.flg_location,
             ipd.id_not_order_reason,
             pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason) not_order_reason,
             ipd.notes notes,
             ipd.id_co_sign_order,
             cso.id_prof_ordered_by id_prof_order,
             cso.desc_prof_ordered_by prof_order,
             pk_date_utils.date_send_tsz(i_lang, nvl(cso.dt_ordered_by, ipd.dt_order_tstz), i_prof) dt_order_str,
             pk_date_utils.date_char_tsz(i_lang,
                                         nvl(cso.dt_ordered_by, ipd.dt_order_tstz),
                                         i_prof.institution,
                                         i_prof.software) dt_order,
             cso.id_order_type,
             cso.desc_order_type order_type,
             pk_procedures_utils.get_procedure_codification(i_lang, i_prof, ipd.id_interv_codification) id_codification,
             pk_translation.get_translation(i_lang,
                                            'CODIFICATION.CODE_CODIFICATION.' ||
                                            pk_procedures_utils.get_procedure_codification(i_lang,
                                                                                           i_prof,
                                                                                           ipd.id_interv_codification)) desc_codification,
             ipd.id_pat_health_plan,
             pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'F') financial_entity,
             pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'H') health_plan,
             pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'N') insurance_number,
             ipd.id_pat_exemption,
             pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption) exemption
              FROM interv_presc_det ipd, interv_prescription ip, cso_table cso
             WHERE ipd.id_interv_presc_det IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                *
                                                 FROM TABLE(i_interv_presc_det) t)
               AND ipd.id_interv_prescription = ip.id_interv_prescription
               AND ipd.id_co_sign_order = cso.id_co_sign_hist(+);
    
        g_error := 'OPEN O_INTERV_SUPPLIES';
        OPEN o_interv_supplies FOR
            SELECT *
              FROM (SELECT sw.id_context id_interv_presc_det,
                           listagg(sw.id_supply_workflow, ';') within GROUP(ORDER BY sw.id_supply_workflow) id_supply_workflow,
                           sw.id_supply id_supply,
                           sw.id_supply_set id_parent_supply,
                           pk_translation.get_translation(i_lang, s.code_supply) desc_supply,
                           pk_supplies_api_db.get_attributes(i_lang, i_prof, sw.id_supply_area, sw.id_supply) desc_supply_attribute,
                           sw.flg_cons_type,
                           pk_sysdomain.get_domain('SUPPLY_SOFT_INST.FLG_CONS_TYPE', sw.flg_cons_type, i_lang) desc_consumption_type,
                           SUM(sw.quantity) quantity,
                           pk_date_utils.date_char_tsz(i_lang, sw.dt_returned, i_prof.institution, i_prof.software) dt_return,
                           pk_date_utils.date_send_tsz(i_lang, sw.dt_returned, i_prof) dt_return_str,
                           s.flg_type flg_type
                      FROM supply_workflow sw
                      JOIN supply s
                        ON s.id_supply = sw.id_supply
                     WHERE sw.id_context IN (SELECT /*+ opt_estimate(table t rows=1) */
                                              *
                                               FROM TABLE(i_interv_presc_det) t)
                       AND sw.flg_context = pk_supplies_constant.g_context_procedure_req
                       AND sw.flg_status != pk_supplies_constant.g_sww_updated
                       AND ((sw.id_supply_request IS NOT NULL AND
                           sw.id_supply_request IN
                           (SELECT sw.id_supply_request
                                FROM supply_workflow sw
                               WHERE sw.id_context IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                        *
                                                         FROM TABLE(i_interv_presc_det) t)
                                 AND (sw.flg_context = pk_supplies_constant.g_context_procedure_req OR
                                     pk_supplies_constant.g_context_procedure_req IS NULL))) OR
                           (sw.id_supply_request IS NULL AND
                           sw.id_context IN (SELECT /*+ opt_estimate(table t rows=1) */
                                                *
                                                 FROM TABLE(i_interv_presc_det) t)))
                     GROUP BY sw.id_context,
                              sw.id_supply,
                              sw.id_supply_set,
                              s.code_supply,
                              sw.id_supply_area,
                              sw.flg_cons_type,
                              sw.quantity,
                              sw.dt_returned,
                              s.flg_type);
    
        g_error := 'GET CURSOR O_INTERV_CLINICAL_QUESTIONS';
        OPEN o_interv_clinical_questions FOR
            SELECT iqr.id_interv_presc_det,
                   iqr.id_questionnaire,
                   pk_mcdt.get_questionnaire_alias(i_lang,
                                                   i_prof,
                                                   'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' || iqr.id_questionnaire) desc_questionnaire,
                   decode(instr(pk_procedures_utils.get_procedure_question_type(i_lang,
                                                                                i_prof,
                                                                                ipd.id_intervention,
                                                                                pk_procedures_constant.g_interv_cq_on_order,
                                                                                iqr.id_questionnaire,
                                                                                iqr.id_response),
                                'D'),
                          0,
                          to_char(iqr1.id_response),
                          to_char(iqr.notes)) id_response,
                   decode(dbms_lob.getlength(iqr.notes),
                          NULL,
                          iqr1.desc_response,
                          pk_procedures_utils.get_procedure_response(i_lang, i_prof, iqr.notes)) desc_response
              FROM (SELECT iqr.id_interv_presc_det,
                           iqr.id_questionnaire,
                           substr(concatenate(iqr.id_response || '; '),
                                  1,
                                  length(concatenate(iqr.id_response || '; ')) - 2) id_response,
                           listagg(pk_mcdt.get_response_alias(i_lang,
                                                              i_prof,
                                                              'RESPONSE.CODE_RESPONSE.' || iqr.id_response),
                                   '; ') within GROUP(ORDER BY iqr.id_response) desc_response,
                           iqr.dt_last_update_tstz,
                           row_number() over(PARTITION BY iqr.id_questionnaire ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                      FROM interv_question_response iqr
                     WHERE iqr.id_interv_presc_det IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                        *
                                                         FROM TABLE(i_interv_presc_det) t)
                     GROUP BY iqr.id_interv_presc_det, iqr.id_questionnaire, iqr.dt_last_update_tstz) iqr1,
                   interv_question_response iqr,
                   interv_presc_det ipd
             WHERE iqr1.rn = 1
               AND iqr1.id_interv_presc_det = iqr.id_interv_presc_det
               AND iqr1.id_questionnaire = iqr.id_questionnaire
               AND iqr1.dt_last_update_tstz = iqr.dt_last_update_tstz
               AND iqr.id_interv_presc_det = ipd.id_interv_presc_det;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TO_EDIT',
                                              o_error);
            pk_types.open_my_cursor(o_interv);
            pk_types.open_my_cursor(o_interv_supplies);
            pk_types.open_my_cursor(o_interv_clinical_questions);
            RETURN FALSE;
    END get_procedure_to_edit;

    FUNCTION get_procedure_to_edit
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        i_tbl_result     IN OUT t_tbl_ds_get_value,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    
        l_id_interv_presc_det interv_presc_det.id_interv_presc_det%TYPE;
        l_id_intervention     intervention.id_intervention%TYPE;
        l_id_intervention_out VARCHAR2(1000 CHAR);
        l_weight              VARCHAR2(100 CHAR);
        l_analysis_result     VARCHAR2(4000 CHAR);
        l_dummy_cursor        pk_types.cursor_type;
        l_struct_supply       pk_supplies_core.tbl_supplies_by_context := pk_supplies_core.tbl_supplies_by_context();
        l_supply_desc         VARCHAR2(4000 CHAR) := NULL;
    
        l_clinical_purpose_mandatory sys_config.value%TYPE := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_P',
                                                                                      i_prof);
        l_laterality_mandatory       sys_config.value%TYPE := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY',
                                                                                      i_prof);
    
        --Not_Ordering
        l_flg_show_reason_not_order sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'SHOW_REASON_NOT_ORDERING',
                                                                                     i_prof    => i_prof);
    
        --Healthcare insurance     
        l_show_healthcare_insurance sys_config.id_sys_config%TYPE := pk_sysconfig.get_config(i_code_cf => 'MCDT_HEALTH_INSURANCE',
                                                                                             i_prof    => i_prof);
        l_id_exemption              NUMBER(24);
        l_id_health_plan_entity     health_plan.id_health_plan_entity%TYPE;
        l_has_catalogue             VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_tbl_catalogue             t_tbl_core_domain := t_tbl_core_domain();
    
        --CO_SIGN 
        l_co_sign_available VARCHAR2(1 CHAR);
    
        --ORDER RECURRENCE
        l_order_recurr_desc   VARCHAR2(4000 CHAR);
        l_order_recurr_option order_recurr_plan.id_order_recurr_option%TYPE;
        l_start_date          VARCHAR2(100 CHAR);
        l_occurrences         order_recurr_plan.occurrences%TYPE;
        l_duration            order_recurr_plan.duration%TYPE;
        l_unit_meas_duration  order_recurr_plan.id_unit_meas_duration%TYPE;
        l_duration_desc       VARCHAR2(100 CHAR);
        l_end_date            VARCHAR2(100 CHAR);
        l_flg_end_by_editable VARCHAR2(1 CHAR);
        l_order_recurr_plan   order_recurr_plan.id_order_recurr_plan%TYPE;
    
        CURSOR c_interv(i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE) IS
            WITH cso_table AS
             (SELECT *
                FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang, i_prof, i_episode, NULL)))
            SELECT /*+ opt_estimate(table cso rows=1) */
             ipd.diagnosis_notes,
             pk_diagnosis.concat_diag_id(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof, 'S') id_alert_diagnosis,
             pk_diagnosis.concat_diag_id(i_lang,
                                         NULL,
                                         NULL,
                                         ipd.id_interv_presc_det,
                                         i_prof,
                                         'T',
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         pk_alert_constant.g_no) desc_diagnosis,
             ipd.id_clinical_purpose,
             pk_translation.get_translation(i_lang,
                                            'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' || ipd.id_clinical_purpose) clinical_purpose,
             ipd.clinical_purpose_notes,
             ipd.flg_laterality,
             pk_mcdt.check_mcdt_laterality(i_lang, i_prof, 'I', ipd.id_intervention) flg_laterality_mcdt,
             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang) laterality,
             ipd.flg_prty flg_priority,
             pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', ipd.flg_prty, NULL) priority,
             decode(i_root_name,
                    pk_orders_constant.g_ds_order_set_procedure,
                    ip.flg_time,
                    decode(nvl(ip.id_episode, ip.id_episode_origin), NULL, NULL, ip.flg_time)) flg_time,
             decode(i_root_name,
                    pk_orders_constant.g_ds_order_set_procedure,
                    pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ip.flg_time, NULL),
                    decode(nvl(ip.id_episode, ip.id_episode_origin),
                           NULL,
                           NULL,
                           pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ip.flg_time, NULL))) desc_time,
             CASE
                  WHEN ip.flg_time IN (pk_procedures_constant.g_flg_time_e,
                                       pk_procedures_constant.g_flg_time_a,
                                       pk_procedures_constant.g_flg_time_h,
                                       pk_procedures_constant.g_flg_time_b) THEN
                   pk_date_utils.trunc_insttimezone_str(i_prof, ip.dt_begin_tstz, 'MI')
                  ELSE
                   pk_date_utils.trunc_insttimezone_str(i_prof, ipd.dt_begin_tstz, 'MI')
              END dt_begin_str,
             CASE
                  WHEN ip.flg_time IN (pk_procedures_constant.g_flg_time_e,
                                       pk_procedures_constant.g_flg_time_a,
                                       pk_procedures_constant.g_flg_time_h,
                                       pk_procedures_constant.g_flg_time_b) THEN
                   pk_date_utils.date_char_tsz(i_lang, ip.dt_begin_tstz, i_prof.institution, i_prof.software)
                  ELSE
                   pk_date_utils.date_char_tsz(i_lang, ipd.dt_begin_tstz, i_prof.institution, i_prof.software)
              END dt_begin,
             ipd.flg_prn,
             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang) prn,
             ipd.prn_notes notes_prn,
             nvl(ipd.id_order_recurrence, 0) id_order_recurrence,
             decode(ipd.id_order_recurrence,
                    NULL,
                    pk_translation.get_translation(i_lang, 'ORDER_RECURR_OPTION.CODE_ORDER_RECURR_OPTION.0'),
                    pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang, i_prof, ipd.id_order_recurrence)) order_recurrence,
             decode(ipd.flg_location,
                    pk_procedures_constant.g_flg_location_hhc,
                    pk_procedures_constant.g_id_location_hhc,
                    ipd.id_exec_institution) id_exec_institution,
             decode(ipd.flg_location,
                    pk_procedures_constant.g_flg_location_hhc,
                    pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                    decode(ipd.id_exec_institution,
                           i_prof.institution,
                           pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                           pk_translation.get_translation(i_lang,
                                                          'AB_INSTITUTION.CODE_INSTITUTION.' || ipd.id_exec_institution))) perform_location,
             ipd.flg_location,
             ipd.id_not_order_reason,
             pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason) not_order_reason,
             ipd.notes notes,
             ipd.id_co_sign_order,
             cso.id_prof_ordered_by id_prof_order,
             cso.desc_prof_ordered_by prof_order,
             pk_date_utils.date_send_tsz(i_lang, nvl(cso.dt_ordered_by, ipd.dt_order_tstz), i_prof) dt_order_str,
             pk_date_utils.date_char_tsz(i_lang,
                                         nvl(cso.dt_ordered_by, ipd.dt_order_tstz),
                                         i_prof.institution,
                                         i_prof.software) dt_order,
             cso.id_order_type,
             cso.desc_order_type order_type,
             pk_procedures_utils.get_procedure_codification(i_lang, i_prof, ipd.id_interv_codification) id_codification,
             pk_translation.get_translation(i_lang,
                                            'CODIFICATION.CODE_CODIFICATION.' ||
                                            pk_procedures_utils.get_procedure_codification(i_lang,
                                                                                           i_prof,
                                                                                           ipd.id_interv_codification)) desc_codification,
             ipd.id_pat_health_plan,
             decode(ipd.id_pat_health_plan,
                    NULL,
                    NULL,
                    pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'F')) financial_entity,
             decode(ipd.id_pat_health_plan,
                    NULL,
                    NULL,
                    pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'H')) health_plan,
             decode(ipd.id_pat_health_plan,
                    NULL,
                    NULL,
                    pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'N')) insurance_number,
             ipd.id_pat_exemption,
             decode(ipd.id_pat_exemption,
                    NULL,
                    NULL,
                    pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption)) exemption,
             ipd.id_intervention
              FROM interv_presc_det ipd, interv_prescription ip, cso_table cso
             WHERE ipd.id_interv_presc_det = i_interv_presc_det
               AND ipd.id_interv_prescription = ip.id_interv_prescription
               AND ipd.id_co_sign_order = cso.id_co_sign_hist(+);
    
        l_row_interv c_interv%ROWTYPE;
    
        CURSOR c_interv_supplies(i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE) IS
            SELECT *
              FROM (SELECT sw.id_supply id_supply,
                           sw.id_supply_set id_parent_supply,
                           pk_translation.get_translation(i_lang, s.code_supply) desc_supply,
                           --pk_supplies_api_db.get_attributes(i_lang, i_prof, sw.id_supply_area, sw.id_supply) desc_supply_attribute,
                           --pk_sysdomain.get_domain('SUPPLY_SOFT_INST.FLG_CONS_TYPE', sw.flg_cons_type, i_lang) desc_consumption_type,
                           SUM(sw.quantity) quantity,
                           pk_date_utils.date_char_tsz(i_lang, sw.dt_returned, i_prof.institution, i_prof.software) dt_return,
                           sw.id_supply_location,
                           sw.dt_returned AS dt_returned_tstz
                      FROM supply_workflow sw
                      JOIN supply s
                        ON s.id_supply = sw.id_supply
                     WHERE sw.id_context = i_interv_presc_det
                       AND sw.flg_context = pk_supplies_constant.g_context_procedure_req
                       AND sw.flg_status != pk_supplies_constant.g_sww_updated
                       AND ((sw.id_supply_request IS NOT NULL AND
                           sw.id_supply_request IN
                           (SELECT sw.id_supply_request
                                FROM supply_workflow sw
                               WHERE sw.id_context = i_interv_presc_det
                                 AND (sw.flg_context = pk_supplies_constant.g_context_procedure_req OR
                                     pk_supplies_constant.g_context_procedure_req IS NULL))) OR
                           (sw.id_supply_request IS NULL AND sw.id_context = i_interv_presc_det))
                       AND s.flg_type NOT IN ('S')
                     GROUP BY sw.id_context,
                              sw.id_supply,
                              sw.id_supply_set,
                              s.code_supply,
                              sw.id_supply_area,
                              sw.quantity,
                              sw.dt_returned,
                              sw.id_supply_location);
    
        l_row_interv_supplies c_interv_supplies%ROWTYPE;
    
    BEGIN
        g_sysdate_tstz := nvl(g_sysdate_tstz, current_timestamp);
    
        IF i_root_name = pk_orders_constant.g_ds_procedure_request
        THEN
            g_error := 'CALLING PK_CO_SIGN_UX.CHECK_PROF_NEEDS_COSIGN_ORDER';
            IF NOT pk_co_sign_ux.check_prof_needs_cosign_order(i_lang                 => i_lang,
                                                               i_prof                 => i_prof,
                                                               i_episode              => i_episode,
                                                               i_task_type            => 43,
                                                               o_flg_prof_need_cosign => l_co_sign_available,
                                                               o_error                => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            l_id_interv_presc_det := i_tbl_id_pk(i_idx);
        ELSE
            --ORDER SETS
            l_co_sign_available := pk_alert_constant.g_no;
        
            --In the order set, the id that is saved, and then sent in the tblk_pk array, is the id_interv_presc.   
            --It is necessary to obtaint the id_interv_presc_det
            SELECT ipd.id_interv_presc_det
              INTO l_id_interv_presc_det
              FROM interv_presc_det ipd
             WHERE ipd.id_interv_prescription = i_tbl_id_pk(i_idx);
        END IF;
    
        g_error := 'OPEN C_INTERV';
        OPEN c_interv(l_id_interv_presc_det);
        LOOP
            FETCH c_interv
                INTO l_row_interv;
            EXIT WHEN c_interv%NOTFOUND;
        END LOOP;
        CLOSE c_interv;
    
        g_error := 'ERROR GETTING ID_INTERVENTION';
        SELECT ipd.id_intervention
          INTO l_id_intervention
          FROM interv_presc_det ipd
         WHERE ipd.id_interv_presc_det = l_id_interv_presc_det;
    
        IF i_root_name = pk_orders_constant.g_ds_procedure_request
           OR i_episode IS NOT NULL
        THEN
            g_error := 'ERROR CALLING PK_PROCEDURES_API_UX.GET_PROCEDURE_PARAMETER_LIST';
            IF NOT pk_procedures_api_ux.get_procedure_parameter_list(i_lang            => i_lang,
                                                                     i_prof            => i_prof,
                                                                     i_patient         => i_patient,
                                                                     i_intervention    => table_number(l_id_intervention),
                                                                     o_weight          => l_weight,
                                                                     o_analysis_result => l_dummy_cursor,
                                                                     o_error           => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'ERROR FETCHING CURSOR';
            LOOP
                FETCH l_dummy_cursor
                    INTO l_id_intervention_out, l_analysis_result;
                EXIT WHEN l_dummy_cursor%NOTFOUND;
            END LOOP;
        END IF;
    
        IF l_row_interv.id_order_recurrence IS NOT NULL
           AND l_row_interv.id_order_recurrence <> 0
        THEN
            g_error := 'ERROR CALLING PK_ORDER_RECURRENCE_API_UX.GET_ORDER_RECURR_INSTRUCTIONS';
            IF NOT pk_order_recurrence_api_ux.get_order_recurr_instructions(i_lang                => i_lang,
                                                                            i_prof                => i_prof,
                                                                            i_order_plan          => l_row_interv.id_order_recurrence,
                                                                            o_order_recurr_desc   => l_order_recurr_desc,
                                                                            o_order_recurr_option => l_order_recurr_option,
                                                                            o_start_date          => l_start_date,
                                                                            o_occurrences         => l_occurrences,
                                                                            o_duration            => l_duration,
                                                                            o_unit_meas_duration  => l_unit_meas_duration,
                                                                            o_duration_desc       => l_duration_desc,
                                                                            o_end_date            => l_end_date,
                                                                            o_flg_end_by_editable => l_flg_end_by_editable,
                                                                            o_order_recurr_plan   => l_order_recurr_plan,
                                                                            o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        ELSE
            --ONCE
            l_flg_end_by_editable := pk_alert_constant.g_no;
            l_order_recurr_option := 0;
            l_occurrences         := 1;
        
            SELECT pk_translation.get_translation(i_lang, orp.code_order_recurr_option)
              INTO l_order_recurr_desc
              FROM order_recurr_option orp
             WHERE orp.id_order_recurr_option = 0;
        
            SELECT pk_date_utils.date_send_tsz(i_lang => i_lang,
                                               i_date => nvl(ipd.dt_begin_tstz, g_sysdate_tstz),
                                               i_prof => i_prof)
              INTO l_start_date
              FROM interv_presc_det ipd
             WHERE ipd.id_interv_presc_det = l_id_interv_presc_det;
        END IF;
    
        g_error := 'ERROR TRUNCATING START DATE';
        IF l_start_date IS NOT NULL
        THEN
            l_start_date := pk_date_utils.trunc_insttimezone_str(i_prof,
                                                                 pk_date_utils.get_string_tstz(i_lang,
                                                                                               i_prof,
                                                                                               l_start_date,
                                                                                               NULL),
                                                                 'MI');
        END IF;
    
        g_error := 'ERROR TRUNCATING END DATE';
        IF l_end_date IS NOT NULL
        THEN
            l_end_date := pk_date_utils.trunc_insttimezone_str(i_prof,
                                                               pk_date_utils.get_string_tstz(i_lang,
                                                                                             i_prof,
                                                                                             l_end_date,
                                                                                             NULL),
                                                               'MI');
        END IF;
    
        IF i_root_name = pk_orders_constant.g_ds_procedure_request
           OR i_episode IS NOT NULL
        THEN
            --Obtain the id_exemption
            --In interv_presc_dir it is saved the id_pat_exemption, but we need to obtain the id_exemption
            IF l_row_interv.id_pat_exemption IS NOT NULL
            THEN
                SELECT p.id_isencao
                  INTO l_id_exemption
                  FROM pat_isencao p
                 WHERE p.id_pat_isencao = l_row_interv.id_pat_exemption;
            
            END IF;
        
            --Obtain the id for the financial entity
            IF l_row_interv.id_pat_health_plan IS NOT NULL
            THEN
                SELECT hp.id_health_plan_entity
                  INTO l_id_health_plan_entity
                  FROM pat_health_plan php
                  JOIN health_plan hp
                    ON hp.id_health_plan = php.id_health_plan
                 WHERE php.id_pat_health_plan = l_row_interv.id_pat_health_plan;
            END IF;
        END IF;
    
        --Check if the field 'Catalogue' should be active
        IF l_show_healthcare_insurance = pk_alert_constant.g_yes
        THEN
            g_error         := 'ERROR CALLING PK_PROCEDURES_CORE.GET_PROCEDURE_CODIFICATION_LIST';
            l_tbl_catalogue := pk_procedures_core.get_procedure_codification_list(i_lang         => i_lang,
                                                                                  i_prof         => i_prof,
                                                                                  i_intervention => l_id_intervention,
                                                                                  i_flg_default  => pk_alert_constant.g_no);
        
            IF l_tbl_catalogue.count > 0
            THEN
                l_has_catalogue := pk_alert_constant.g_yes;
            END IF;
        END IF;
    
        SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                   id_ds_component    => t.id_ds_component_child,
                                   internal_name      => t.internal_name_child,
                                   VALUE              => CASE
                                                              WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_indication_ft THEN
                                                               l_row_interv.diagnosis_notes
                                                              WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose THEN
                                                               to_char(l_row_interv.id_clinical_purpose)
                                                              WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose_ft THEN
                                                               decode(l_row_interv.id_clinical_purpose, '0', l_row_interv.clinical_purpose_notes, NULL)
                                                              WHEN t.internal_name_child = pk_orders_constant.g_ds_laterality THEN
                                                               l_row_interv.flg_laterality
                                                              WHEN t.internal_name_child IN (pk_orders_constant.g_ds_default_laterality) THEN
                                                              --Auxiliar variable to list the options from the laterality multichoice (pk_mcdt.get_laterality_all)
                                                              --When the value is 'O' all options should be listed, when it's 'R' only the 'Right' option
                                                             --should be listed, etc.
                                                              coalesce(l_row_interv.flg_laterality_mcdt, 'O')
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_priority THEN
                                                              l_row_interv.flg_priority
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                              l_row_interv.flg_time
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_flg_time THEN
                                                              l_row_interv.flg_time
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_prn THEN
                                                              l_row_interv.flg_prn
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_prn_specify THEN
                                                              to_char(l_row_interv.notes_prn)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                              to_char(l_order_recurr_option)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_other_frequency THEN
                                                              CASE l_order_recurr_option
                                                                  WHEN -1 THEN
                                                                   to_char(l_order_recurr_option)
                                                              END
                                                             WHEN t.internal_name_child IN
                                                                  (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_date_dummy) THEN
                                                              l_start_date
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_executions THEN
                                                              to_char(l_occurrences)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_duration THEN
                                                              to_char(l_duration)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_end_date THEN
                                                              l_end_date
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                              to_char(l_row_interv.id_exec_institution)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_lab_test_result THEN
                                                              l_analysis_result
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_weight_kg THEN
                                                              l_weight
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_notes_execution THEN
                                                              l_row_interv.notes
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_reason_not_ordering THEN
                                                              to_char(l_row_interv.id_not_order_reason)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_co_sign_control THEN
                                                              CASE
                                                                  WHEN l_co_sign_available = pk_alert_constant.g_yes THEN
                                                                   pk_alert_constant.g_yes
                                                                  ELSE
                                                                   pk_alert_constant.g_no
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_order_type
                                                                  AND l_co_sign_available = pk_alert_constant.g_yes THEN
                                                              to_char(l_row_interv.id_order_type)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_ordered_by
                                                                  AND l_co_sign_available = pk_alert_constant.g_yes THEN
                                                              to_char(l_row_interv.id_prof_order)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_ordered_at THEN
                                                              coalesce(l_row_interv.dt_order_str,
                                                                       pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => g_sysdate_tstz, i_prof => i_prof))
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_healthcare_insurance_cat_control THEN
                                                              CASE
                                                                  WHEN l_show_healthcare_insurance = pk_alert_constant.g_yes
                                                                       OR l_row_interv.id_codification IS NOT NULL
                                                                       OR l_row_interv.insurance_number IS NOT NULL
                                                                       OR l_row_interv.id_pat_exemption IS NOT NULL THEN
                                                                   pk_alert_constant.g_yes
                                                                  ELSE
                                                                   pk_alert_constant.g_no
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                              to_char(l_row_interv.id_codification)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                              to_char(l_id_health_plan_entity)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                              to_char(l_row_interv.id_pat_health_plan)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                              l_row_interv.insurance_number
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                              to_char(l_id_exemption)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_dummy_number THEN
                                                              to_char(l_order_recurr_plan)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_flg_edition THEN
                                                              pk_alert_constant.g_yes
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_root_name THEN
                                                              i_root_name
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_tbl_records THEN
                                                              to_char(l_row_interv.id_intervention)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_has_catalogue THEN
                                                              l_has_catalogue
                                                             ELSE
                                                              NULL
                                                         END,
                                   value_clob         => NULL,
                                   min_value          => NULL,
                                   max_value          => NULL,
                                   desc_value         => CASE
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_indication_ft THEN
                                                              l_row_interv.diagnosis_notes
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose THEN
                                                              l_row_interv.clinical_purpose
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose_ft THEN
                                                              decode(l_row_interv.id_clinical_purpose, '0', l_row_interv.clinical_purpose_notes, NULL)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_laterality THEN
                                                              l_row_interv.laterality
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_priority THEN
                                                              l_row_interv.priority
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                              l_row_interv.desc_time
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_prn THEN
                                                              l_row_interv.prn
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_prn_specify THEN
                                                              to_char(l_row_interv.notes_prn)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                              CASE l_order_recurr_option
                                                                  WHEN -1 THEN
                                                                   pk_translation.get_translation(i_lang, 'ORDER_RECURR_OPTION.CODE_ORDER_RECURR_OPTION.-1')
                                                                  ELSE
                                                                   l_order_recurr_desc
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_other_frequency THEN
                                                              CASE l_order_recurr_option
                                                                  WHEN -1 THEN
                                                                   l_order_recurr_desc
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_executions THEN
                                                              to_char(l_occurrences)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_duration THEN
                                                              to_char(l_duration) || ' ' ||
                                                              pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                           i_prof         => i_prof,
                                                                                                           i_unit_measure => l_unit_meas_duration)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                              l_row_interv.perform_location
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_lab_test_result THEN
                                                              l_analysis_result
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_weight_kg THEN
                                                              l_weight
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_notes_execution THEN
                                                              l_row_interv.notes
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_reason_not_ordering THEN
                                                              l_row_interv.not_order_reason
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_order_type
                                                                  AND l_co_sign_available = pk_alert_constant.g_yes THEN
                                                              l_row_interv.order_type
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_ordered_by
                                                                  AND l_co_sign_available = pk_alert_constant.g_yes THEN
                                                              l_row_interv.prof_order
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                              l_row_interv.desc_codification
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                              l_row_interv.financial_entity
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                              l_row_interv.health_plan
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                              l_row_interv.insurance_number
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                              to_char(l_row_interv.exemption)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_dummy_number THEN
                                                              to_char(l_order_recurr_plan)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_root_name THEN
                                                              i_root_name
                                                             ELSE
                                                              NULL
                                                         END,
                                   desc_clob          => NULL,
                                   id_unit_measure    => t.id_unit_measure,
                                   desc_unit_measure  => CASE
                                                             WHEN t.id_unit_measure IS NOT NULL THEN
                                                              pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                           i_prof         => i_prof,
                                                                                                           i_unit_measure => t.id_unit_measure)
                                                             ELSE
                                                              NULL
                                                         END,
                                   flg_validation     => pk_orders_constant.g_component_valid,
                                   err_msg            => NULL,
                                   flg_event_type     => CASE
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_indication_ft THEN
                                                              CASE
                                                                  WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   pk_orders_constant.g_component_active
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose THEN
                                                              CASE l_clinical_purpose_mandatory
                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                   pk_orders_constant.g_component_mandatory
                                                                  ELSE
                                                                   pk_orders_constant.g_component_active
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_clinical_purpose_ft THEN
                                                              decode(l_row_interv.id_clinical_purpose,
                                                                     '0',
                                                                     pk_orders_constant.g_component_mandatory,
                                                                     pk_orders_constant.g_component_inactive)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_laterality THEN
                                                              CASE l_laterality_mandatory
                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                   pk_orders_constant.g_component_mandatory
                                                                  ELSE
                                                                   pk_orders_constant.g_component_active
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                              CASE
                                                                  WHEN i_episode IS NULL THEN
                                                                   pk_orders_constant.g_component_read_only
                                                                  ELSE
                                                                   pk_orders_constant.g_component_mandatory
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_prn_specify THEN
                                                              decode(l_row_interv.flg_prn,
                                                                     pk_alert_constant.g_yes,
                                                                     pk_orders_constant.g_component_active,
                                                                     pk_orders_constant.g_component_inactive)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                              CASE l_row_interv.flg_prn
                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                   pk_orders_constant.g_component_read_only
                                                                  ELSE
                                                                   pk_orders_constant.g_component_mandatory
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_other_frequency THEN
                                                              decode(l_order_recurr_option,
                                                                     -1,
                                                                     pk_orders_constant.g_component_mandatory,
                                                                     pk_orders_constant.g_component_inactive)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_start_date THEN
                                                              CASE
                                                                  WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure
                                                                       AND i_episode IS NULL THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   CASE l_row_interv.flg_prn
                                                                       WHEN pk_alert_constant.g_yes THEN
                                                                        pk_orders_constant.g_component_read_only
                                                                       ELSE
                                                                        CASE
                                                                            WHEN l_row_interv.flg_time = pk_alert_constant.g_flg_time_b THEN
                                                                             pk_orders_constant.g_component_active
                                                                            WHEN l_row_interv.flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                             pk_orders_constant.g_component_inactive
                                                                            ELSE
                                                                             pk_orders_constant.g_component_mandatory
                                                                        END
                                                                   END
                                                              END
                                                             WHEN t.internal_name_child IN (pk_orders_constant.g_ds_executions) THEN
                                                             --If l_flg_end_by_editable = 'N', field 'Executions' must be Read Only and present the value given by l_occurrences
                                                              decode(l_flg_end_by_editable,
                                                                     pk_alert_constant.g_yes,
                                                                     pk_orders_constant.g_component_active,
                                                                     pk_orders_constant.g_component_read_only)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_duration THEN
                                                             --If l_flg_end_by_editable = 'N', fields duration and end date must be inactive
                                                              decode(l_flg_end_by_editable,
                                                                     pk_alert_constant.g_yes,
                                                                     pk_orders_constant.g_component_active,
                                                                     pk_orders_constant.g_component_inactive)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_end_date THEN
                                                              CASE
                                                                  WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure
                                                                       AND i_episode IS NULL THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                  --If l_flg_end_by_editable = 'N', fields duration and end date must be inactive
                                                                   decode(l_flg_end_by_editable,
                                                                          pk_alert_constant.g_yes,
                                                                          pk_orders_constant.g_component_active,
                                                                          pk_orders_constant.g_component_inactive)
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                              pk_orders_constant.g_component_mandatory
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_execution_ordered_at THEN
                                                              pk_orders_constant.g_component_mandatory
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_lab_test_result THEN
                                                              CASE
                                                                  WHEN l_analysis_result IS NULL THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   pk_orders_constant.g_component_read_only
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_weight_kg THEN
                                                              CASE
                                                                  WHEN l_weight IS NULL THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   pk_orders_constant.g_component_read_only
                                                              END
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_reason_not_ordering THEN
                                                              decode(l_flg_show_reason_not_order,
                                                                     pk_alert_constant.g_no,
                                                                     pk_orders_constant.g_component_hidden,
                                                                     pk_orders_constant.g_component_active)
                                                             WHEN t.internal_name_child IN (pk_orders_constant.g_ds_order_type,
                                                                                            pk_orders_constant.g_ds_ordered_by,
                                                                                            pk_orders_constant.g_ds_ordered_at) THEN
                                                              decode(l_co_sign_available,
                                                                     pk_alert_constant.g_yes,
                                                                     pk_orders_constant.g_component_mandatory,
                                                                     pk_orders_constant.g_component_active)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                              decode(l_has_catalogue,
                                                                     pk_alert_constant.g_yes,
                                                                     pk_orders_constant.g_component_active,
                                                                     pk_orders_constant.g_component_inactive)
                                                             WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                              CASE
                                                                  WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   CASE
                                                                       WHEN l_row_interv.insurance_number IS NOT NULL THEN
                                                                        pk_orders_constant.g_component_read_only
                                                                       ELSE
                                                                        pk_orders_constant.g_component_inactive
                                                                   END
                                                              END
                                                             WHEN t.internal_name_child IN (pk_orders_constant.g_ds_financial_entity,
                                                                                            pk_orders_constant.g_ds_health_coverage_plan,
                                                                                            pk_orders_constant.g_ds_exemption) THEN
                                                              CASE
                                                                  WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure
                                                                       AND i_episode IS NULL THEN
                                                                   pk_orders_constant.g_component_inactive
                                                                  ELSE
                                                                   pk_orders_constant.g_component_active
                                                              END
                                                             ELSE
                                                              pk_orders_constant.g_component_active
                                                         END,
                                   flg_multi_status   => pk_alert_constant.g_no,
                                   idx                => i_idx)
          BULK COLLECT
          INTO tbl_result
          FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_patient        => NULL,
                                             i_component_name => i_root_name,
                                             i_action         => NULL)) t
          LEFT JOIN ds_def_event def
            ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
         WHERE (t.internal_name_child NOT IN
               (pk_orders_constant.g_ds_clinical_indication_mw,
                 pk_orders_constant.g_ds_execution_ordered_at,
                 pk_orders_constant.g_ds_supply_order_mw,
                 pk_orders_constant.g_ds_id_supply,
                 pk_orders_constant.g_ds_supply_set,
                 pk_orders_constant.g_ds_supply_quantity,
                 pk_orders_constant.g_ds_supply_dt_return,
                 pk_orders_constant.g_ds_ok_button_control,
                 pk_orders_constant.g_ds_healthcare_insurance_cat_control) AND t.flg_component_type_child = 'L')
            OR (t.internal_name_child IN (pk_orders_constant.g_ds_healthcare_insurance_cat_control) AND i_idx = 1);
    
        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
        LOOP
            IF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
            THEN
                IF i_root_name = pk_orders_constant.g_ds_procedure_request
                THEN
                    IF l_row_interv.id_alert_diagnosis.count > 0
                       AND l_row_interv.id_alert_diagnosis.count = l_row_interv.desc_diagnosis.count
                    THEN
                        FOR j IN l_row_interv.id_alert_diagnosis.first .. l_row_interv.id_alert_diagnosis.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_row_interv.id_alert_diagnosis(j),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_row_interv.desc_diagnosis(j),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                ELSE
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => NULL,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                END IF;
            ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_execution_ordered_at
            THEN
                tbl_result.extend();
                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                   internal_name      => i_tbl_int_name(i),
                                                                   VALUE              => coalesce(l_row_interv.dt_order_str,
                                                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                              i_date => g_sysdate_tstz,
                                                                                                                              i_prof => i_prof)),
                                                                   value_clob         => NULL,
                                                                   min_value          => NULL,
                                                                   max_value          => NULL,
                                                                   desc_value         => NULL,
                                                                   desc_clob          => NULL,
                                                                   id_unit_measure    => NULL,
                                                                   desc_unit_measure  => NULL,
                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                   err_msg            => NULL,
                                                                   flg_event_type     => CASE
                                                                                             WHEN i_root_name = pk_orders_constant.g_ds_order_set_procedure
                                                                                                  AND i_episode IS NULL THEN
                                                                                              pk_orders_constant.g_component_inactive
                                                                                             WHEN l_co_sign_available = pk_alert_constant.g_yes THEN
                                                                                              pk_orders_constant.g_component_hidden
                                                                                             ELSE
                                                                                              pk_orders_constant.g_component_mandatory
                                                                                         END,
                                                                   flg_multi_status   => NULL,
                                                                   idx                => i_idx);
            ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_supply_order_mw
            THEN
                OPEN c_interv_supplies(l_id_interv_presc_det);
                LOOP
                    FETCH c_interv_supplies
                        INTO l_row_interv_supplies;
                    EXIT WHEN c_interv_supplies%NOTFOUND;
                
                    l_struct_supply.extend();
                    l_struct_supply(l_struct_supply.count).id_supply := l_row_interv_supplies.id_supply;
                    l_struct_supply(l_struct_supply.count).desc_supply := l_row_interv_supplies.desc_supply;
                    l_struct_supply(l_struct_supply.count).id_parent_supply := l_row_interv_supplies.id_parent_supply;
                    l_struct_supply(l_struct_supply.count).quantity := l_row_interv_supplies.quantity;
                    l_struct_supply(l_struct_supply.count).dt_return := pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                    i_date => l_row_interv_supplies.dt_returned_tstz,
                                                                                                    i_prof => i_prof);
                    l_struct_supply(l_struct_supply.count).id_supply_location := l_row_interv_supplies.id_supply_location;
                END LOOP;
                CLOSE c_interv_supplies;
            
                IF l_struct_supply.exists(1)
                THEN
                    FOR j IN l_struct_supply.first .. l_struct_supply.last
                    LOOP
                        l_supply_desc := l_supply_desc || l_struct_supply(j).desc_supply || ' (' || l_struct_supply(j).quantity || ')' || CASE
                                             WHEN l_struct_supply.first = l_struct_supply.last
                                                  OR j = l_struct_supply.last THEN
                                              '.'
                                             ELSE
                                              '; '
                                         END;
                    END LOOP;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => pk_supplies_api_db.get_supplies_for_modal_window(i_lang     => i_lang,
                                                                                                                                              i_prof     => i_prof,
                                                                                                                                              i_supplies => l_struct_supply),
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_supply_desc,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_unique,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                
                    FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(j) = pk_orders_constant.g_ds_id_supply
                        THEN
                            FOR k IN l_struct_supply.first .. l_struct_supply.last
                            LOOP
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                   internal_name      => i_tbl_int_name(j),
                                                                                   VALUE              => l_struct_supply(k).id_supply,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END LOOP;
                        ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_set
                        THEN
                            FOR k IN l_struct_supply.first .. l_struct_supply.last
                            LOOP
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                   internal_name      => i_tbl_int_name(j),
                                                                                   VALUE              => l_struct_supply(k).id_parent_supply,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END LOOP;
                        ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_quantity
                        THEN
                            FOR k IN l_struct_supply.first .. l_struct_supply.last
                            LOOP
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                   internal_name      => i_tbl_int_name(j),
                                                                                   VALUE              => l_struct_supply(k).quantity,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END LOOP;
                        ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_dt_return
                        THEN
                            FOR k IN l_struct_supply.first .. l_struct_supply.last
                            LOOP
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                   internal_name      => i_tbl_int_name(j),
                                                                                   VALUE              => l_struct_supply(k).dt_return,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END LOOP;
                        ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_location
                        THEN
                            FOR k IN l_struct_supply.first .. l_struct_supply.last
                            LOOP
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                   internal_name      => i_tbl_int_name(j),
                                                                                   VALUE              => l_struct_supply(k).id_supply_location,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END LOOP;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END LOOP;
    
        i_tbl_result := i_tbl_result MULTISET UNION ALL tbl_result;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TO_EDIT',
                                              o_error);
            RETURN FALSE;
    END get_procedure_to_edit;

    FUNCTION get_procedure_default_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        i_tbl_result     IN OUT t_tbl_ds_get_value,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_epis_type             epis_type.id_epis_type%TYPE;
        l_value_to_execute      VARCHAR2(4000 CHAR);
        l_value_to_execute_desc VARCHAR2(4000 CHAR);
        l_flg_time              sys_config.value%TYPE;
        l_supply_desc           VARCHAR2(4000 CHAR);
    
        l_ds_internal_name ds_component.internal_name%TYPE;
        l_id_ds_component  ds_component.id_ds_component%TYPE;
    
        l_value      VARCHAR2(4000);
        l_value_desc VARCHAR2(4000);
    
        l_tbl_varchar_aux table_varchar := table_varchar();
    
        l_dummy_cursor pk_types.cursor_type;
    
        l_tbl_supplies pk_supplies_core.tbl_supplies_by_context := pk_supplies_core.tbl_supplies_by_context();
    
    BEGIN
    
        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
        LOOP
            IF i_tbl_int_name(i) = pk_orders_constant.g_ds_priority
            THEN
                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                IF NOT pk_procedures_core.get_procedure_default_priority(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_intervention => to_number(i_tbl_data(i_idx) (1)),
                                                                         i_value        => l_value,
                                                                         i_desc_value   => l_value_desc)
                THEN
                    l_value      := NULL;
                    l_value_desc := NULL;
                END IF;
            
                i_tbl_result.extend();
                i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_value,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_value_desc,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                       idx                => i_idx);
            ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_prn
            THEN
                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                SELECT data, label
                  INTO l_value, l_value_desc
                  FROM (SELECT data, label
                          FROM (SELECT s.val data,
                                       s.rank,
                                       s.desc_val label,
                                       decode(s.val,
                                              pk_lab_tests_constant.g_no,
                                              pk_lab_tests_constant.g_yes,
                                              pk_lab_tests_constant.g_no) flg_default
                                  FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang,
                                                                                      i_prof,
                                                                                      'INTERV_PRESC_DET.FLG_PRN',
                                                                                      NULL)) s)
                         WHERE (flg_default = pk_alert_constant.g_yes AND rownum = 1)
                            OR rownum = 1);
            
                i_tbl_result.extend();
                i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_value,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       value_clob         => NULL,
                                                                       desc_value         => l_value_desc,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
            ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_place_service
            THEN
                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                IF NOT pk_procedures_core.get_procedure_default_location(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_intervention => to_number(i_tbl_data(i_idx) (1)),
                                                                         i_flg_time     => 'E',
                                                                         i_value        => l_value,
                                                                         i_desc_value   => l_value_desc)
                THEN
                    l_value      := NULL;
                    l_value_desc := NULL;
                END IF;
            
                IF l_value IS NOT NULL
                THEN
                    i_tbl_result.extend();
                    i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => l_value,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => l_value_desc,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                END IF;
            ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_supply_order_mw
            THEN
                l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
            
                IF NOT pk_supplies_core.get_supplies_by_context(i_lang          => i_lang,
                                                                i_prof          => i_prof,
                                                                i_id_context    => table_varchar(i_tbl_data(i_idx) (1)),
                                                                i_flg_context   => 'P',
                                                                i_dep_clin_serv => NULL,
                                                                o_supplies      => l_dummy_cursor,
                                                                o_error         => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                FETCH l_dummy_cursor BULK COLLECT
                    INTO l_tbl_supplies;
            
                IF l_tbl_supplies.count > 0
                THEN
                    FOR j IN l_tbl_supplies.first .. l_tbl_supplies.last
                    LOOP
                        l_supply_desc := l_supply_desc || l_tbl_supplies(j).desc_supply || ' (' || l_tbl_supplies(j).quantity || ')' || CASE
                                             WHEN l_tbl_supplies.first = l_tbl_supplies.last
                                                  OR j = l_tbl_supplies.last THEN
                                              '.'
                                             ELSE
                                              '; '
                                         END;
                    END LOOP;
                
                    i_tbl_result.extend();
                    i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => pk_supplies_api_db.get_supplies_for_modal_window(i_lang     => i_lang,
                                                                                                                                                  i_prof     => i_prof,
                                                                                                                                                  i_supplies => l_tbl_supplies),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => l_supply_desc,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_unique,
                                                                           flg_multi_status   => pk_alert_constant.g_no,
                                                                           idx                => i_idx);
                ELSE
                    i_tbl_result.extend();
                    i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => NULL,
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_unique,
                                                                           flg_multi_status   => pk_alert_constant.g_no,
                                                                           idx                => i_idx);
                END IF;
            
                FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                LOOP
                    l_ds_internal_name := pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j));
                
                    IF l_ds_internal_name IN (pk_orders_constant.g_ds_id_supply,
                                              pk_orders_constant.g_ds_supply_set,
                                              pk_orders_constant.g_ds_supply_quantity,
                                              pk_orders_constant.g_ds_supply_dt_return,
                                              pk_orders_constant.g_ds_supply_location)
                    THEN
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j));
                    
                        IF l_tbl_supplies.count > 0
                        THEN
                            FOR k IN l_tbl_supplies.first .. l_tbl_supplies.last
                            LOOP
                                i_tbl_result.extend();
                                i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => l_ds_internal_name,
                                                                                       VALUE              => CASE
                                                                                                              l_ds_internal_name
                                                                                                                 WHEN
                                                                                                                  pk_orders_constant.g_ds_id_supply THEN
                                                                                                                  to_char(l_tbl_supplies(k).id_supply)
                                                                                                                 WHEN
                                                                                                                  pk_orders_constant.g_ds_supply_set THEN
                                                                                                                  to_char(coalesce(l_tbl_supplies(k).id_parent_supply,
                                                                                                                                   -1))
                                                                                                                 WHEN
                                                                                                                  pk_orders_constant.g_ds_supply_quantity THEN
                                                                                                                  to_char(coalesce(l_tbl_supplies(k).quantity,
                                                                                                                                   -1))
                                                                                                                 WHEN
                                                                                                                  pk_orders_constant.g_ds_supply_dt_return THEN
                                                                                                                  coalesce(l_tbl_supplies(k).dt_return,
                                                                                                                           -1)
                                                                                                                 WHEN
                                                                                                                  pk_orders_constant.g_ds_supply_location THEN
                                                                                                                  to_char(coalesce(l_tbl_supplies(k).id_supply_location,
                                                                                                                                   -1))
                                                                                                             END,
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => NULL,
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => pk_orders_constant.g_component_valid,
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                                       flg_multi_status   => pk_alert_constant.g_no,
                                                                                       idx                => i_idx);
                            END LOOP;
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DEFAULT_VALUES',
                                              o_error);
            RETURN FALSE;
    END get_procedure_default_values;

    FUNCTION get_procedure_for_execution
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_interv_presc_det  IN interv_presc_det.id_interv_presc_det%TYPE,
        i_interv_presc_plan IN interv_presc_plan.id_interv_presc_plan%TYPE,
        o_interv            OUT pk_types.cursor_type,
        o_supplies          OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_supplies_mandatory sys_config.value%TYPE := pk_sysconfig.get_config('SUPPLIES_INTERV_MANDATORY_FIELD', i_prof);
    
        l_msg_not_applicable sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M018');
        l_msg_supplies       sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'SUPPLIES_T085');
    
        l_interv_presc_plan_last interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_presc_plan_next interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_interv_presc_det_cancel interv_presc_det.dt_cancel_tstz%TYPE;
    
        l_count PLS_INTEGER := 0;
    
        l_plan_next_date order_recurr_plan.start_date%TYPE;
    
        l_finish_recurr VARCHAR2(1 CHAR);
    
        l_id_order_recurrence order_recurr_plan.id_order_recurr_plan%TYPE;
        l_flag_recurr_control order_recurr_control.flg_status%TYPE;
    
        l_id_interv_presc_det interv_presc_plan.id_interv_presc_det%TYPE;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        SELECT COUNT(1)
          INTO l_count
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_det = i_interv_presc_det
           AND ipp.flg_status != pk_procedures_constant.g_interv_cancel;
    
        -- Retorna a utima execução 
        BEGIN
            SELECT id_interv_presc_plan
              INTO l_interv_presc_plan_last
              FROM (SELECT ipp.id_interv_presc_plan,
                           row_number() over(PARTITION BY ipp.id_interv_presc_det ORDER BY ipp.exec_number DESC, ipp.dt_interv_presc_plan DESC) rn
                      FROM interv_presc_det ipd, interv_presc_plan ipp
                     WHERE ipd.id_interv_presc_det = i_interv_presc_det
                       AND ipd.id_interv_presc_det = ipp.id_interv_presc_det
                       AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed)
             WHERE rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_interv_presc_plan_last := NULL;
        END;
    
        -- Retorna execução seguinte 
        BEGIN
            SELECT id_interv_presc_plan
              INTO l_interv_presc_plan_next
              FROM (SELECT ipp.id_interv_presc_plan,
                           row_number() over(PARTITION BY ipp.id_interv_presc_det ORDER BY ipp.exec_number DESC, ipp.dt_interv_presc_plan DESC) rn
                      FROM interv_presc_det ipd, interv_presc_plan ipp
                     WHERE ipd.id_interv_presc_det = i_interv_presc_det
                       AND ipd.id_interv_presc_det = ipp.id_interv_presc_det
                       AND ipp.flg_status IN
                           (pk_procedures_constant.g_interv_plan_pending, pk_procedures_constant.g_interv_plan_req))
             WHERE rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_interv_presc_plan_last := NULL;
        END;
    
        -- When a prescription is expired DT_CANCEL_TSTZ represents the expiration timestamp 
        BEGIN
            SELECT ipd.dt_cancel_tstz
              INTO l_interv_presc_det_cancel
              FROM interv_presc_det ipd
             WHERE ipd.id_interv_presc_det = i_interv_presc_det
               AND ipd.flg_status = pk_procedures_constant.g_interv_expired;
        EXCEPTION
            WHEN no_data_found THEN
                l_interv_presc_det_cancel := NULL;
        END;
    
        IF i_interv_presc_plan IS NOT NULL
           AND i_interv_presc_det IS NULL
        THEN
            SELECT ipp.id_interv_presc_det
              INTO l_id_interv_presc_det
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan;
        END IF;
    
        BEGIN
            SELECT id_order_recurrence
              INTO l_id_order_recurrence
              FROM interv_presc_det
             WHERE id_interv_presc_det = i_interv_presc_det;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_order_recurrence := NULL;
        END;
        /*
        1 - Create and execute
        2 - Execute
        3 - Execution edition
        */
    
        IF l_id_order_recurrence IS NOT NULL
        THEN
            g_error := 'CALL PK_ORDER_RECURRENCE_API_DB.GET_NEXT_EXECUTION';
            IF NOT pk_order_recurrence_api_db.get_next_execution(i_lang                => i_lang,
                                                                 i_prof                => i_prof,
                                                                 i_id_order_recurrence => l_id_order_recurrence,
                                                                 i_dt_next             => NULL,
                                                                 o_flag_recurr_control => l_flag_recurr_control,
                                                                 o_finish_recurr       => l_finish_recurr,
                                                                 o_plan_start_date     => l_plan_next_date,
                                                                 o_error               => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        g_error := 'GET CURSOR';
        OPEN o_interv FOR
            SELECT NULL id_intervention,
                   NULL desc_procedure,
                   i_prof.id id_prof_perform,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, i_prof.id) desc_prof_perform,
                   NULL dt_start,
                   NULL dt_start_min,
                   pk_date_utils.get_timestamp_str(i_lang, i_prof, g_sysdate_tstz, NULL) dt_start_max,
                   NULL dt_end,
                   l_msg_not_applicable dt_plan_show,
                   NULL dt_plan,
                   NULL id_modifiers,
                   NULL desc_modifiers,
                   NULL id_epis_documentation,
                   NULL id_doc_template,
                   NULL desc_notes,
                   l_supplies_mandatory flg_supplies_mandatory,
                   NULL desc_supplies
              FROM dual
             WHERE i_interv_presc_det IS NULL
               AND i_interv_presc_plan IS NULL
            UNION ALL
            SELECT pea.id_intervention,
                   pk_procedures_utils.get_alias_translation(i_lang,
                                                             i_prof,
                                                             'INTERVENTION.CODE_INTERVENTION.' || pea.id_intervention,
                                                             NULL) desc_procedure,
                   i_prof.id id_prof_perform,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, i_prof.id) desc_prof_perform,
                   NULL dt_start,
                   pk_date_utils.get_timestamp_str(i_lang,
                                                   i_prof,
                                                   coalesce(pea.dt_order, pea.dt_interv_prescription, g_sysdate_tstz),
                                                   NULL) dt_start_min,
                   pk_date_utils.get_timestamp_str(i_lang,
                                                   i_prof,
                                                   decode(pea.flg_status_plan,
                                                          pk_procedures_constant.g_interv_expired,
                                                          l_interv_presc_det_cancel,
                                                          g_sysdate_tstz),
                                                   NULL) dt_start_max,
                   NULL dt_end,
                   decode(l_plan_next_date,
                          NULL,
                          l_msg_not_applicable,
                          pk_date_utils.date_char_tsz(i_lang, l_plan_next_date, i_prof.institution, i_prof.software)) dt_plan_show,
                   pk_date_utils.to_char_insttimezone(i_prof, l_plan_next_date, pk_alert_constant.g_dt_yyyymmddhh24miss) dt_plan,
                   NULL id_modifiers,
                   NULL desc_modifiers,
                   NULL id_epis_documentation,
                   pk_touch_option.get_doc_template_internal(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             pea.id_episode,
                                                             pk_procedures_constant.g_doc_area_intervention,
                                                             pea.id_intervention) id_doc_template,
                   NULL desc_notes,
                   l_supplies_mandatory flg_supplies_mandatory,
                   NULL desc_supplies
              FROM procedures_ea pea
             WHERE pea.id_interv_presc_det = i_interv_presc_det
            UNION ALL
            SELECT pea.id_intervention,
                   pk_procedures_utils.get_alias_translation(i_lang,
                                                             i_prof,
                                                             'INTERVENTION.CODE_INTERVENTION.' || pea.id_intervention,
                                                             NULL) desc_procedure,
                   ipp.id_prof_performed id_prof_perform,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed) desc_prof_perform,
                   pk_date_utils.date_send_tsz(i_lang, ipp.start_time, i_prof) dt_start,
                   nvl((SELECT pk_date_utils.to_char_insttimezone(i_prof, ipp1.dt_plan_tstz, 'YYYYMMDDHH24MISS')
                         FROM interv_presc_plan ipp1
                        WHERE ipp1.id_interv_presc_plan = l_interv_presc_plan_last),
                       pk_date_utils.to_char_insttimezone(i_prof,
                                                          nvl(pea.dt_order, pea.dt_interv_prescription),
                                                          'YYYYMMDDHH24MISS')) dt_start_min,
                   decode(ipp.id_interv_presc_plan,
                          l_interv_presc_plan_last,
                          NULL,
                          nvl((SELECT pk_date_utils.to_char_insttimezone(i_prof, ipp1.start_time, 'YYYYMMDDHH24MISS')
                                FROM interv_presc_plan ipp1
                               WHERE ipp1.id_interv_presc_plan = l_interv_presc_plan_next),
                              NULL)) dt_start_max,
                   pk_date_utils.date_send_tsz(i_lang, ipp.end_time, i_prof) dt_end,
                   decode(pea.flg_prn,
                          pk_procedures_constant.g_yes,
                          l_msg_not_applicable,
                          nvl((SELECT pk_date_utils.date_char_tsz(i_lang,
                                                                 i.dt_plan_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software)
                                FROM interv_presc_plan i
                               WHERE i.id_interv_presc_det = pea.id_interv_presc_det
                                 AND i.exec_number = ipp.exec_number + 1),
                              l_msg_not_applicable)) dt_plan_show,
                   (SELECT pk_date_utils.to_char_insttimezone(i_prof,
                                                              i.dt_plan_tstz,
                                                              pk_alert_constant.g_dt_yyyymmddhh24miss)
                      FROM interv_presc_plan i
                     WHERE i.id_interv_presc_det = pea.id_interv_presc_det
                       AND i.exec_number = ipp.exec_number + 1) dt_plan,
                   ippm.id_modifiers,
                   pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan) desc_modifiers,
                   ipp.id_epis_documentation,
                   pk_touch_option.get_doc_template_internal(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             pea.id_episode,
                                                             pk_procedures_constant.g_doc_area_intervention,
                                                             pea.id_intervention) id_doc_template,
                   --ipp.notes desc_notes,
                   ed.notes desc_notes,
                   l_supplies_mandatory flg_supplies_mandatory,
                   decode(ipp.flg_supplies_reg,
                          pk_procedures_constant.g_yes,
                          nvl(pk_supplies_external_api_db.get_context_supplies_str(i_lang,
                                                                                   i_prof,
                                                                                   i_interv_presc_plan,
                                                                                   pk_supplies_constant.g_context_procedure_exec,
                                                                                   table_varchar(pk_supplies_constant.g_sww_cancelled)),
                              l_msg_supplies)) desc_supplies
              FROM interv_presc_plan ipp,
                   (SELECT ippm.id_interv_presc_plan,
                           CAST(COLLECT(to_number(ippm.id_modifier)) AS table_number) id_modifiers
                      FROM interv_pp_modifiers ippm
                     WHERE ippm.id_interv_presc_plan = i_interv_presc_plan
                     GROUP BY ippm.id_interv_presc_plan) ippm,
                   procedures_ea pea,
                   epis_documentation ed
             WHERE ipp.id_interv_presc_plan = i_interv_presc_plan
               AND ipp.id_epis_documentation = ed.id_epis_documentation(+)
               AND ipp.id_interv_presc_plan = ippm.id_interv_presc_plan(+)
               AND ipp.id_interv_presc_det = pea.id_interv_presc_det;
    
        OPEN o_supplies FOR
            SELECT sw.id_supply_workflow id_supply_workflow,
                   s.id_supply id_supply,
                   s.flg_type,
                   pk_translation.get_translation(i_lang, s.code_supply) desc_supply,
                   sw.quantity quantity,
                   sw.flg_status flg_status,
                   sw.barcode_req barcode_req,
                   sw.flg_reusable,
                   sw.id_supply_set id_set,
                   pk_translation.get_translation(i_lang, sd.code_supply) set_description,
                   sw.flg_cons_type flg_comsumption_type,
                   pk_supplies_core.get_attributes(i_lang, i_prof, NULL, s.id_supply) desc_supply_attrib,
                   sd.id_supply id_parent_supply,
                   CASE
                        WHEN i_interv_presc_det IS NULL THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_consumed
              FROM supply_request sr
              JOIN supply_workflow sw
                ON sw.id_supply_request = sr.id_supply_request
              JOIN supply s
                ON s.id_supply = sw.id_supply
              LEFT JOIN supply sd
                ON sw.id_supply_set = sd.id_supply
             WHERE sr.id_context = nvl(i_interv_presc_det, l_id_interv_presc_det)
               AND sr.flg_context = 'P'
               AND sr.dt_request =
                   (SELECT MAX(srq.dt_request)
                      FROM supply_request srq
                     WHERE srq.id_context = nvl(i_interv_presc_det, l_id_interv_presc_det))
               AND ((sw.id_context = i_interv_presc_det AND i_interv_presc_det IS NOT NULL) OR
                   (sw.id_context = i_interv_presc_plan AND i_interv_presc_plan IS NOT NULL))
             ORDER BY desc_supply;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_FOR_EXECUTION',
                                              o_error);
            pk_types.open_my_cursor(o_interv);
            RETURN FALSE;
    END get_procedure_for_execution;

    FUNCTION get_procedure_to_cancel
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_interv_presc_plan IN interv_presc_plan.id_interv_presc_plan%TYPE,
        o_interv            OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_start_date sys_config.value%TYPE := nvl(pk_sysconfig.get_config('INTERV_START_DATE', i_prof),
                                                         pk_procedures_constant.g_interv_system_date);
    
        l_interv_presc_plan interv_presc_plan.id_interv_presc_plan%TYPE;
        l_interv_presc_det  interv_presc_det.id_interv_presc_det%TYPE;
    
    BEGIN
    
        g_sysdate_tstz := current_timestamp;
    
        BEGIN
            -- Verificar se existe id_interv_presc_plan na procedures_ea   
            SELECT pea.id_interv_presc_plan
              INTO l_interv_presc_plan
              FROM procedures_ea pea
              JOIN intervention it
                ON it.id_intervention = pea.id_intervention
             WHERE pea.id_interv_presc_plan = i_interv_presc_plan;
        
            -- JM 2008/03/26
            -- Alteração para indicar a data da próxima execução quando se efectua um 
            -- cancelamento dum procedimento agendado numa consulta anterior
            g_error := 'OPEN O_INTERV 1';
            OPEN o_interv FOR
                SELECT decode(pea.flg_prn,
                              NULL,
                              NULL,
                              pk_date_utils.to_char_insttimezone(i_prof,
                                                                 decode(pea.interval,
                                                                        NULL,
                                                                        g_sysdate_tstz,
                                                                        nvl2(pea.dt_plan,
                                                                             CASE l_interv_start_date
                                                                                 WHEN
                                                                                  pk_procedures_constant.g_interv_planned_date THEN
                                                                                  pea.dt_plan
                                                                                 ELSE
                                                                                  g_sysdate_tstz
                                                                             END +
                                                                             numtodsinterval(nvl(pea.interval, 0), 'SECOND'),
                                                                             nvl2(pea.id_episode_origin,
                                                                                  CASE l_interv_start_date
                                                                                      WHEN
                                                                                       pk_procedures_constant.g_interv_planned_date THEN
                                                                                       pea.dt_plan
                                                                                      ELSE
                                                                                       g_sysdate_tstz
                                                                                  END + numtodsinterval(nvl(pea.interval, 0),
                                                                                                        'SECOND'),
                                                                                  NULL))),
                                                                 'YYYYMMDDHH24MISS')) dt_plan,
                       nvl((SELECT pk_date_utils.to_char_insttimezone(i_prof, ipp.end_time, 'YYYYMMDDHH24MISS')
                             FROM interv_presc_plan ipp
                            WHERE ipp.id_interv_presc_plan =
                                  (SELECT MAX(ipp.id_interv_presc_plan)
                                     FROM interv_presc_plan ipp
                                    WHERE ipp.id_interv_presc_det =
                                          (SELECT ipp.id_interv_presc_det
                                             FROM interv_presc_plan ipp
                                            WHERE ipp.id_interv_presc_plan = i_interv_presc_plan)
                                      AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed)),
                           pk_date_utils.to_char_insttimezone(i_prof, pea.dt_order, 'YYYYMMDDHH24MISS')) dt_last_execution
                  FROM procedures_ea pea
                 WHERE pea.id_interv_presc_plan = i_interv_presc_plan;
        
        EXCEPTION
            WHEN no_data_found THEN
            
                SELECT ipp.id_interv_presc_det
                  INTO l_interv_presc_det
                  FROM interv_presc_plan ipp
                 WHERE ipp.id_interv_presc_plan = i_interv_presc_plan;
            
                g_error := 'OPEN O_INTERV 2';
                OPEN o_interv FOR
                    SELECT (SELECT pk_date_utils.to_char_insttimezone(i_prof,
                                                                      nvl(ipp.dt_plan_tstz, g_sysdate_tstz),
                                                                      'YYYYMMDDHH24MISS')
                              FROM interv_presc_plan ipp
                             WHERE ipp.id_interv_presc_det = l_interv_presc_det
                               AND ipp.flg_status = pk_procedures_constant.g_interv_plan_pending) dt_plan,
                           nvl((SELECT pk_date_utils.to_char_insttimezone(i_prof, ipp.dt_take_tstz, 'YYYYMMDDHH24MISS')
                                 FROM interv_presc_plan ipp
                                WHERE ipp.id_interv_presc_plan =
                                      (SELECT MAX(ipp.id_interv_presc_plan)
                                         FROM interv_presc_plan ipp
                                        WHERE ipp.id_interv_presc_det = l_interv_presc_det
                                          AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed
                                          AND ipp.id_interv_presc_plan != i_interv_presc_plan)),
                               (SELECT DISTINCT pk_date_utils.to_char_insttimezone(i_prof,
                                                                                   pea.dt_order,
                                                                                   'YYYYMMDDHH24MISS')
                                  FROM procedures_ea pea
                                 WHERE pea.id_interv_presc_det = l_interv_presc_det)) dt_last_execution
                      FROM dual;
        END;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TO_CANCEL',
                                              o_error);
            RETURN FALSE;
    END get_procedure_to_cancel;

    FUNCTION get_procedure_execution_list
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        o_interv           OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_interv_presc_plan_last interv_presc_plan.id_interv_presc_plan%TYPE;
    
        l_msg_notes         sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M097');
        l_msg_not_aplicable sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M036');
    
    BEGIN
    
        -- Retorna a utima execução 
        BEGIN
            SELECT id_interv_presc_plan
              INTO l_interv_presc_plan_last
              FROM (SELECT ipp.id_interv_presc_plan,
                           row_number() over(PARTITION BY ipp.id_interv_presc_det ORDER BY ipp.exec_number DESC, ipp.dt_interv_presc_plan DESC) rn
                      FROM interv_presc_det ipd, interv_presc_plan ipp
                     WHERE ipd.id_interv_presc_det = i_interv_presc_det
                       AND ipd.id_presc_plan_task IS NULL -- Só pode cancelar execuções que não sejam da medicação
                       AND ipd.id_interv_presc_det = ipp.id_interv_presc_det
                       AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed
                       AND ipp.id_prof_take = i_prof.id) -- Só pode cancelar o profissional que efectuou a execução)
             WHERE rn = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_interv_presc_plan_last := NULL;
        END;
    
        g_error := 'OPEN O_INTERV';
        OPEN o_interv FOR
            SELECT ipp.id_interv_presc_plan,
                   pea.id_interv_presc_det,
                   pea.id_intervention,
                   ipp.flg_status,
                   pk_procedures_api_db.get_alias_translation(i_lang,
                                                              i_prof,
                                                              'INTERVENTION.CODE_INTERVENTION.' || pea.id_intervention,
                                                              NULL) desc_procedure,
                   decode(pea.flg_prn,
                          pk_procedures_constant.g_yes,
                          NULL,
                          nvl(pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang,
                                                                                    i_prof,
                                                                                    pea.id_order_recurrence),
                              pk_translation.get_translation(i_lang, 'ORDER_RECURR_OPTION.CODE_ORDER_RECURR_OPTION.0'))) to_be_perform,
                   decode(pea.flg_prn,
                          pk_procedures_constant.g_yes,
                          NULL,
                          decode(ipp.dt_plan_tstz,
                                 NULL,
                                 NULL,
                                 pk_date_utils.dt_chr_tsz(i_lang, ipp.dt_plan_tstz, i_prof.institution, i_prof.software))) dt_begin,
                   decode(pea.flg_prn,
                          pk_procedures_constant.g_yes,
                          decode(ipp.id_interv_presc_plan, NULL, NULL, l_msg_not_aplicable),
                          decode(ipp.dt_plan_tstz,
                                 NULL,
                                 l_msg_not_aplicable,
                                 pk_date_utils.date_char_hour_tsz(i_lang,
                                                                  ipp.dt_plan_tstz,
                                                                  i_prof.institution,
                                                                  i_prof.software))) hr_begin,
                   decode(ipp.flg_status,
                          pk_procedures_constant.g_interv_plan_cancel,
                          pk_date_utils.dt_chr_tsz(i_lang, ipp.dt_cancel_tstz, i_prof.institution, i_prof.software),
                          pk_date_utils.dt_chr_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software)) dt_perform,
                   decode(ipp.flg_status,
                          pk_procedures_constant.g_interv_plan_cancel,
                          pk_date_utils.date_char_hour_tsz(i_lang,
                                                           ipp.dt_cancel_tstz,
                                                           i_prof.institution,
                                                           i_prof.software),
                          pk_date_utils.date_char_hour_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software)) hr_perform,
                   decode(ipp.flg_status,
                          pk_procedures_constant.g_interv_plan_cancel,
                          pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_cancel),
                          pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed)) prof_performed,
                   pk_utils.get_status_string(i_lang,
                                              i_prof,
                                              pk_ea_logic_procedures.get_procedure_plan_status_str(i_lang,
                                                                                                   i_prof,
                                                                                                   ipp.flg_status,
                                                                                                   ipp.dt_plan_tstz),
                                              pk_ea_logic_procedures.get_procedure_plan_status_msg(i_lang,
                                                                                                   i_prof,
                                                                                                   ipp.flg_status,
                                                                                                   ipp.dt_plan_tstz),
                                              pk_ea_logic_procedures.get_procedure_plan_status_icon(i_lang,
                                                                                                    i_prof,
                                                                                                    ipp.flg_status,
                                                                                                    ipp.dt_plan_tstz),
                                              pk_ea_logic_procedures.get_procedure_plan_status_flg(i_lang,
                                                                                                   i_prof,
                                                                                                   ipp.flg_status,
                                                                                                   ipp.dt_plan_tstz)) status_string,
                   decode(ipp.flg_status,
                          pk_procedures_constant.g_interv_plan_cancel,
                          decode(ipp.notes_cancel, NULL, NULL, l_msg_notes),
                          decode(ipp.id_epis_documentation,
                                 NULL,
                                 decode(ipp.notes, NULL, NULL, l_msg_notes),
                                 l_msg_notes)) msg_notes,
                   decode(ipp.notes_cancel,
                          NULL,
                          decode(ipp.id_epis_documentation,
                                 NULL,
                                 to_clob(ipp.notes),
                                 pk_touch_option_core.get_plain_text_entry(i_lang, i_prof, ipp.id_epis_documentation)),
                          to_clob(ipp.notes_cancel)) notes,
                   pk_procedures_utils.get_procedure_permission(i_lang,
                                                                i_prof,
                                                                pk_procedures_constant.g_interv_area_execution,
                                                                pk_procedures_constant.g_interv_button_create,
                                                                pea.id_episode,
                                                                pea.id_interv_presc_det,
                                                                ipp.id_interv_presc_plan,
                                                                NULL) avail_button_create,
                   pk_procedures_utils.get_procedure_permission(i_lang,
                                                                i_prof,
                                                                pk_procedures_constant.g_interv_area_execution,
                                                                pk_procedures_constant.g_interv_button_ok,
                                                                pea.id_episode,
                                                                pea.id_interv_presc_det,
                                                                ipp.id_interv_presc_plan,
                                                                NULL) avail_button_ok,
                   decode(ipp.flg_status,
                          pk_procedures_constant.g_interv_plan_executed,
                          decode(ipp.id_interv_presc_plan,
                                 l_interv_presc_plan_last,
                                 pk_procedures_constant.g_yes,
                                 pk_procedures_constant.g_no),
                          pk_procedures_utils.get_procedure_permission(i_lang,
                                                                       i_prof,
                                                                       pk_procedures_constant.g_interv_area_execution,
                                                                       pk_procedures_constant.g_interv_button_cancel,
                                                                       pea.id_episode,
                                                                       pea.id_interv_presc_det,
                                                                       ipp.id_interv_presc_plan,
                                                                       NULL)) avail_button_cancel,
                   pk_touch_option.get_doc_template_internal(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             i_episode,
                                                             pk_procedures_constant.g_doc_area_intervention,
                                                             pea.id_intervention) doc_template_interv,
                   row_number() over(ORDER BY pk_sysdomain.get_rank(i_lang, 'INTERV_PRESC_PLAN.FLG_STATUS', ipp.flg_status), nvl(ipp.exec_number, 1) DESC, nvl(ipp.dt_plan_tstz, ipp.start_time) DESC) rank
              FROM procedures_ea pea, interv_presc_plan ipp
             WHERE pea.id_interv_presc_det = i_interv_presc_det
               AND pea.id_interv_presc_det = ipp.id_interv_presc_det(+)
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_EXECUTION_LIST',
                                              o_error);
            RETURN FALSE;
    END get_procedure_execution_list;

    FUNCTION get_procedure_filter_list
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE,
        i_episode IN episode.id_episode%TYPE,
        o_list    OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_complaint table_number;
    
        l_has_complaint_results        VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
        l_has_specialty_results        VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
        l_has_med_procedures_results   VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
        l_has_nurse_procedures_results VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
        l_has_codification_results     VARCHAR2(1 CHAR) := pk_procedures_constant.g_no;
    
    BEGIN
    
        IF i_episode IS NOT NULL
        THEN
            g_error := 'GET PK_COMPLAINT.GET_EPIS_ACT_COMPLAINT';
            IF NOT pk_complaint.get_epis_act_complaint(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_episode      => i_episode,
                                                       o_id_complaint => l_complaint,
                                                       o_error        => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        END IF;
    
        IF l_complaint IS NOT NULL
           AND l_complaint.count > 0
        THEN
            g_error := 'PK_PROCEDURES_CORE.GET_PROCEDURE_SELECTION_LIST';
            BEGIN
                SELECT /*+opt_estimate(table t rows=1)*/
                DISTINCT pk_procedures_constant.g_yes
                  INTO l_has_complaint_results
                  FROM TABLE(pk_procedures_core.get_procedure_selection_list(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_patient      => i_patient,
                                                                             i_episode      => i_episode,
                                                                             i_flg_type     => NULL,
                                                                             i_flg_filter   => pk_procedures_constant.g_interv_complaint,
                                                                             i_codification => NULL,
                                                                             i_rank         => 0)) t;
            EXCEPTION
                WHEN no_data_found THEN
                    l_has_complaint_results := pk_procedures_constant.g_no;
            END;
        END IF;
    
        IF l_has_complaint_results = pk_procedures_constant.g_no
        THEN
            g_error := 'GET PK_PROCEDURES_CORE.GET_PROCEDURE_SELECTION_LIST';
            BEGIN
                SELECT /*+opt_estimate(table t rows=1)*/
                DISTINCT pk_procedures_constant.g_yes
                  INTO l_has_specialty_results
                  FROM TABLE(pk_procedures_core.get_procedure_selection_list(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_patient      => i_patient,
                                                                             i_episode      => i_episode,
                                                                             i_flg_type     => pk_procedures_constant.g_interv_freq,
                                                                             i_flg_filter   => pk_procedures_constant.g_interv_clinical_service,
                                                                             i_codification => NULL,
                                                                             i_rank         => 0)) t;
            EXCEPTION
                WHEN no_data_found THEN
                    l_has_specialty_results := pk_procedures_constant.g_no;
            END;
        END IF;
    
        BEGIN
            SELECT DISTINCT pk_procedures_constant.g_yes
              INTO l_has_med_procedures_results
              FROM interv_dcs_most_freq_except idmfe
              JOIN interv_dep_clin_serv idcs
                ON idcs.id_interv_dep_clin_serv = idmfe.id_interv_dep_clin_serv
             WHERE idcs.flg_type = pk_procedures_constant.g_interv_freq
               AND idmfe.flg_cat_prof = pk_alert_constant.g_cat_type_doc
               AND idmfe.flg_available = pk_procedures_constant.g_yes
               AND idmfe.flg_status = pk_procedures_constant.g_active;
        EXCEPTION
            WHEN no_data_found THEN
                l_has_med_procedures_results := pk_procedures_constant.g_no;
        END;
    
        BEGIN
            SELECT DISTINCT pk_procedures_constant.g_yes
              INTO l_has_nurse_procedures_results
              FROM interv_dcs_most_freq_except idmfe
              JOIN interv_dep_clin_serv idcs
                ON idcs.id_interv_dep_clin_serv = idmfe.id_interv_dep_clin_serv
             WHERE idcs.flg_type = pk_procedures_constant.g_interv_freq
               AND idmfe.flg_cat_prof = pk_alert_constant.g_cat_type_nurse
               AND idmfe.flg_available = pk_procedures_constant.g_yes
               AND idmfe.flg_status = pk_procedures_constant.g_active;
        EXCEPTION
            WHEN no_data_found THEN
                l_has_nurse_procedures_results := pk_procedures_constant.g_no;
        END;
    
        BEGIN
            SELECT DISTINCT pk_procedures_constant.g_yes
              INTO l_has_codification_results
              FROM codification_instit_soft cis
             WHERE cis.id_institution = i_prof.institution
               AND cis.id_software = i_prof.software
               AND cis.flg_available = pk_procedures_constant.g_available
               AND EXISTS (SELECT 1
                      FROM interv_codification ic,
                           (SELECT i.id_intervention
                              FROM intervention i, interv_dep_clin_serv idcs
                             WHERE i.flg_status = pk_procedures_constant.g_active
                               AND instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0
                               AND i.id_intervention = idcs.id_intervention
                               AND idcs.flg_type = pk_procedures_constant.g_interv_can_req
                               AND idcs.id_software = i_prof.software
                               AND idcs.id_institution = i_prof.institution) idcs
                     WHERE cis.id_codification = ic.id_codification
                       AND ic.flg_available = pk_procedures_constant.g_available
                       AND ic.id_intervention = idcs.id_intervention);
        EXCEPTION
            WHEN no_data_found THEN
                l_has_codification_results := pk_procedures_constant.g_no;
        END;
    
        g_error := 'OPEN CURSOR';
        OPEN o_list FOR
            SELECT id_action, id_parent, to_state, desc_action, icon, flg_default, flg_active, action
              FROM (SELECT a.from_state id_action,
                           NULL id_parent,
                           NULL to_state,
                           a.desc_action,
                           NULL icon,
                           decode(a.from_state,
                                  pk_procedures_constant.g_interv_institution,
                                  pk_procedures_constant.g_yes,
                                  pk_procedures_constant.g_no) flg_default,
                           CASE
                                WHEN a.from_state = pk_procedures_constant.g_interv_institution THEN
                                 pk_procedures_constant.g_active
                                WHEN a.from_state = pk_procedures_constant.g_interv_codification
                                     AND l_has_codification_results = pk_procedures_constant.g_yes THEN
                                 pk_procedures_constant.g_active
                                WHEN a.from_state = pk_procedures_constant.g_interv_clinical_service
                                     AND l_has_specialty_results = pk_procedures_constant.g_yes THEN
                                 pk_procedures_constant.g_active
                                WHEN a.from_state = pk_procedures_constant.g_interv_medical
                                     AND l_has_med_procedures_results = pk_procedures_constant.g_yes THEN
                                 pk_procedures_constant.g_active
                                WHEN a.from_state = pk_procedures_constant.g_interv_nursing
                                     AND l_has_nurse_procedures_results = pk_procedures_constant.g_yes THEN
                                 pk_procedures_constant.g_active
                                ELSE
                                 pk_procedures_constant.g_inactive
                            END flg_active,
                           a.action,
                           NULL rank
                      FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, 'PROCEDURES_FILTERS', NULL)) a
                    UNION ALL
                    SELECT to_char(cis.id_codification) id_action,
                           pk_procedures_constant.g_interv_codification id_parent,
                           NULL to_state,
                           pk_translation.get_translation(i_lang,
                                                          'CODIFICATION.CODE_CODIFICATION.' || cis.id_codification) desc_action,
                           NULL icon,
                           pk_procedures_constant.g_no flg_default,
                           pk_procedures_constant.g_active flg_active,
                           NULL action,
                           NULL rank
                      FROM codification_instit_soft cis
                     WHERE cis.id_institution = i_prof.institution
                       AND cis.id_software = i_prof.software
                       AND cis.flg_available = pk_procedures_constant.g_available
                       AND EXISTS (SELECT 1
                              FROM interv_codification ic,
                                   (SELECT i.id_intervention
                                      FROM intervention i, interv_dep_clin_serv idcs
                                     WHERE i.flg_status = pk_procedures_constant.g_active
                                       AND instr(i.flg_type, pk_procedures_constant.g_type_interv_surgical) = 0
                                       AND i.id_intervention = idcs.id_intervention
                                       AND idcs.flg_type = pk_procedures_constant.g_interv_can_req
                                       AND idcs.id_software = i_prof.software
                                       AND idcs.id_institution = i_prof.institution) idcs
                             WHERE cis.id_codification = ic.id_codification
                               AND ic.flg_available = pk_procedures_constant.g_available
                               AND ic.id_intervention = idcs.id_intervention)
                       AND l_has_codification_results = pk_procedures_constant.g_yes) t
             ORDER BY rank, desc_action;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_FILTER_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_filter_list;

    FUNCTION get_procedure_time_list
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_epis_type IN epis_type.id_epis_type%TYPE,
        o_list      OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_software software.id_software%TYPE;
        l_flg_time sys_config.value%TYPE;
    
    BEGIN
    
        l_flg_time := pk_sysconfig.get_config('FLG_TIME_E', i_prof.institution, i_prof.software);
    
        SELECT MAX(etsi.id_software) keep(dense_rank FIRST ORDER BY etsi.id_institution DESC) id_software
          INTO l_software
          FROM epis_type_soft_inst etsi
         WHERE etsi.id_institution IN (0, i_prof.institution)
           AND etsi.id_epis_type = i_epis_type;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT val data,
                   rank,
                   desc_val label,
                   decode(l_flg_time, val, pk_procedures_constant.g_yes, pk_procedures_constant.g_no) flg_default
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang,
                                                                  decode(i_epis_type,
                                                                         NULL,
                                                                         i_prof,
                                                                         profissional(i_prof.id,
                                                                                      i_prof.institution,
                                                                                      l_software)),
                                                                  'INTERV_PRESCRIPTION.FLG_TIME',
                                                                  NULL))
             WHERE val != pk_procedures_constant.g_flg_time_r;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN g_user_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TIME_LIST',
                                              'U',
                                              g_error,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TIME_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_time_list;

    FUNCTION get_procedure_priority_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN table_number,
        o_list         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT val data,
                   rank,
                   desc_val label,
                   (CAST(MULTISET
                         (SELECT idcs.id_intervention
                            FROM interv_dep_clin_serv idcs
                           WHERE idcs.id_institution = i_prof.institution
                             AND idcs.id_software = i_prof.software
                             AND idcs.flg_type = pk_procedures_constant.g_interv_can_req
                             AND idcs.flg_execute = pk_procedures_constant.g_yes
                             AND idcs.flg_priority = s.val
                             AND idcs.id_intervention IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                           *
                                                            FROM TABLE(i_intervention) t)) AS table_number)) id_default
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', NULL)) s
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_PRIORITY_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_priority_list;

    FUNCTION get_procedure_default_priority
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN intervention.id_intervention%TYPE,
        i_value        IN OUT VARCHAR2,
        i_desc_value   IN OUT VARCHAR2
    ) RETURN BOOLEAN IS
        l_error t_error_out;
    BEGIN
    
        g_error := 'GET DEFAULT PRIORITY VALUE';
        SELECT t.data, t.label
          INTO i_value, i_desc_value
          FROM (SELECT idcs.flg_priority data,
                       -1 rank,
                       pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRTY', idcs.flg_priority, i_lang) label
                  FROM interv_dep_clin_serv idcs
                 WHERE idcs.id_institution = i_prof.institution
                   AND idcs.id_software = i_prof.software
                   AND idcs.flg_type = pk_procedures_constant.g_interv_can_req
                   AND idcs.flg_execute = pk_procedures_constant.g_yes
                   AND idcs.id_intervention = i_intervention
                UNION ALL
                SELECT val data, rank, desc_val label
                  FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', NULL)) s
                 ORDER BY rank) t
         WHERE t.data IS NOT NULL
           AND t.label IS NOT NULL
           AND rownum = 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DEFAULT_PRIORITY',
                                              l_error);
            RETURN FALSE;
    END get_procedure_default_priority;

    FUNCTION get_procedure_prn_list
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_list  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT s.val data,
                   s.rank,
                   s.desc_val label,
                   decode(s.val, pk_procedures_constant.g_no, pk_procedures_constant.g_yes, pk_procedures_constant.g_no) flg_default
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRN', NULL)) s
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_PRN_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_prn_list;

    FUNCTION get_procedure_diagnosis_list
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        o_list    OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_search_diagnosis sys_config.value%TYPE := pk_sysconfig.get_config('PERMISSION_FOR_SEARCH_DIAGNOSIS', i_prof);
    
        l_profile_template profile_template.id_profile_template%TYPE := pk_prof_utils.get_prof_profile_template(i_prof);
    
        l_tbl_diags t_coll_diagnosis_config := t_coll_diagnosis_config();
    
    BEGIN
    
        IF i_episode IS NOT NULL
        THEN
            l_tbl_diags := pk_diagnosis.get_associated_diagnosis_tf(i_lang, i_prof, i_episode, pk_alert_constant.g_yes);
        END IF;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT id_diagnosis, desc_diagnosis, code_icd, flg_other, rank, id_alert_diagnosis
              FROM (SELECT NULL id_diagnosis,
                           pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T073') desc_diagnosis,
                           NULL code_icd,
                           NULL flg_other,
                           10 rank,
                           NULL id_alert_diagnosis
                      FROM dual
                     WHERE instr(nvl(l_search_diagnosis, '#'), l_profile_template) != 0
                    UNION ALL
                    SELECT /*+opt_estimate (table t rows=1)*/
                     t.id_diagnosis, t.desc_diagnosis, t.code_icd, t.flg_other, 20 rank, t.id_alert_diagnosis
                      FROM TABLE(l_tbl_diags) t)
             ORDER BY rank ASC, desc_diagnosis ASC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DIAGNOSIS_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_diagnosis_list;

    FUNCTION get_procedure_clinical_purpose
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        o_list  OUT pk_types.cursor_type,
        o_error OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT id_multichoice_option data, rank, desc_option label, NULL flg_default
              FROM TABLE(pk_multichoice.tf_multichoice_options(i_lang, i_prof, 'INTERV_PRESC_DET.ID_CLINICAL_PURPOSE'))
             ORDER BY rank ASC, desc_option;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_CLINICAL_PURPOSE',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_clinical_purpose;

    FUNCTION get_procedure_location_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN table_number,
        i_flg_time     IN interv_prescription.flg_time%TYPE,
        o_list         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_inst pk_types.cursor_type;
    
        l_id_institution           institution.id_institution%TYPE;
        l_institution_name         pk_translation.t_desc_translation;
        l_institution_abbreviation institution.abbreviation%TYPE;
    
        l_default VARCHAR2(1 CHAR);
    
    BEGIN
    
        IF NOT pk_p1_interv.get_interv_inst(i_lang    => i_lang,
                                            i_prof    => i_prof,
                                            i_intervs => i_intervention,
                                            o_inst    => l_inst,
                                            o_error   => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, vc_2, vc_3)
            SELECT /*+opt_estimate(table t rows=1)*/
             i_prof.institution,
             10,
             pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
             decode(i_flg_time,
                    pk_procedures_constant.g_flg_time_h,
                    pk_procedures_constant.g_no,
                    pk_procedures_constant.g_yes),
             'I'
              FROM TABLE(i_intervention) t,
                   (SELECT *
                      FROM interv_dep_clin_serv
                     WHERE flg_type = pk_procedures_constant.g_interv_can_req
                       AND nvl(id_professional, 0) IN (0, i_prof.id)
                       AND id_institution = i_prof.institution
                       AND id_software = i_prof.software
                       AND flg_execute = pk_procedures_constant.g_yes) idcs
             WHERE idcs.id_intervention = t.column_value
            UNION ALL
            SELECT pk_procedures_constant.g_id_location_hhc,
                   100,
                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T191'),
                   decode(i_flg_time,
                          pk_procedures_constant.g_flg_time_h,
                          pk_procedures_constant.g_yes,
                          pk_procedures_constant.g_no),
                   pk_procedures_constant.g_flg_location_hhc
              FROM dual
             WHERE i_flg_time = pk_procedures_constant.g_flg_time_h;
    
        IF SQL%ROWCOUNT = 0
        THEN
            l_default := pk_procedures_constant.g_yes;
        ELSE
            l_default := pk_procedures_constant.g_no;
        END IF;
    
        LOOP
            FETCH l_inst
                INTO l_id_institution, l_institution_name, l_institution_abbreviation;
            EXIT WHEN l_inst%NOTFOUND;
        
            IF l_id_institution = pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof)
               AND l_default = pk_procedures_constant.g_yes
            THEN
                l_default := pk_procedures_constant.g_yes;
            ELSE
                l_default := pk_procedures_constant.g_no;
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2, vc_3)
            VALUES
                (l_id_institution, 20, l_institution_name, l_default, 'I');
        END LOOP;
        CLOSE l_inst;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT DISTINCT data, rank, label, flg_default, flg_type
              FROM (SELECT num_1 data, num_2 rank, vc_1 label, vc_2 flg_default, vc_3 flg_type
                      FROM tbl_temp)
             ORDER BY rank, label;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_LOCATION_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_location_list;

    FUNCTION get_procedure_location_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN table_number,
        i_flg_time     IN interv_prescription.flg_time%TYPE
    ) RETURN t_tbl_core_domain IS
    
        l_inst pk_types.cursor_type;
    
        l_id_institution           institution.id_institution%TYPE;
        l_institution_name         pk_translation.t_desc_translation;
        l_institution_abbreviation institution.abbreviation%TYPE;
    
        l_default VARCHAR2(1 CHAR);
    
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    BEGIN
    
        IF NOT pk_p1_interv.get_interv_inst(i_lang    => i_lang,
                                            i_prof    => i_prof,
                                            i_intervs => i_intervention,
                                            o_inst    => l_inst,
                                            o_error   => l_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, vc_2, vc_3)
            SELECT /*+opt_estimate(table t rows=1)*/
             i_prof.institution,
             10,
             pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
             decode(i_flg_time,
                    pk_procedures_constant.g_flg_time_h,
                    pk_procedures_constant.g_no,
                    pk_procedures_constant.g_yes),
             'I'
              FROM TABLE(i_intervention) t,
                   (SELECT *
                      FROM interv_dep_clin_serv
                     WHERE flg_type = pk_procedures_constant.g_interv_can_req
                       AND nvl(id_professional, 0) IN (0, i_prof.id)
                       AND id_institution = i_prof.institution
                       AND id_software = i_prof.software
                       AND flg_execute = pk_procedures_constant.g_yes) idcs
             WHERE idcs.id_intervention = t.column_value
            UNION ALL
            SELECT pk_procedures_constant.g_id_location_hhc,
                   100,
                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T191'),
                   decode(i_flg_time,
                          pk_procedures_constant.g_flg_time_h,
                          pk_procedures_constant.g_yes,
                          pk_procedures_constant.g_no),
                   pk_procedures_constant.g_flg_location_hhc
              FROM dual
             WHERE i_flg_time = pk_procedures_constant.g_flg_time_h;
    
        IF SQL%ROWCOUNT = 0
        THEN
            l_default := pk_procedures_constant.g_yes;
        ELSE
            l_default := pk_procedures_constant.g_no;
        END IF;
    
        LOOP
            FETCH l_inst
                INTO l_id_institution, l_institution_name, l_institution_abbreviation;
            EXIT WHEN l_inst%NOTFOUND;
        
            IF l_id_institution = pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof)
               AND l_default = pk_procedures_constant.g_yes
            THEN
                l_default := pk_procedures_constant.g_yes;
            ELSE
                l_default := pk_procedures_constant.g_no;
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2, vc_3)
            VALUES
                (l_id_institution, 20, l_institution_name, l_default, 'I');
        END LOOP;
        CLOSE l_inst;
    
        g_error := 'OPEN L_RET';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => t.label,
                                         domain_value  => t.data,
                                         order_rank    => t.rank,
                                         img_name      => NULL)
                  FROM (SELECT DISTINCT data, rank, label
                          FROM (SELECT num_1 data, num_2 rank, vc_1 label, vc_2 flg_default, vc_3 flg_type
                                  FROM tbl_temp)
                         ORDER BY rank, label) t);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_LOCATION_LIST',
                                              l_error);
            RETURN t_tbl_core_domain();
    END get_procedure_location_list;

    FUNCTION get_procedure_default_location
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN intervention.id_intervention%TYPE,
        i_flg_time     IN interv_prescription.flg_time%TYPE,
        i_value        IN OUT VARCHAR2,
        i_desc_value   IN OUT VARCHAR2
    ) RETURN BOOLEAN IS
    
        l_inst pk_types.cursor_type;
    
        l_id_institution           institution.id_institution%TYPE;
        l_institution_name         pk_translation.t_desc_translation;
        l_institution_abbreviation institution.abbreviation%TYPE;
    
        l_default VARCHAR2(1 CHAR);
    
        l_error t_error_out;
    
    BEGIN
    
        IF NOT pk_p1_interv.get_interv_inst(i_lang    => i_lang,
                                            i_prof    => i_prof,
                                            i_intervs => table_number(i_intervention),
                                            o_inst    => l_inst,
                                            o_error   => l_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, vc_2, vc_3)
            SELECT /*+opt_estimate(table t rows=1)*/
             i_prof.institution,
             10,
             pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
             decode(i_flg_time,
                    pk_procedures_constant.g_flg_time_h,
                    pk_procedures_constant.g_no,
                    pk_procedures_constant.g_yes),
             'I'
              FROM TABLE(table_number(i_intervention)) t,
                   (SELECT *
                      FROM interv_dep_clin_serv
                     WHERE flg_type = pk_procedures_constant.g_interv_can_req
                       AND nvl(id_professional, 0) IN (0, i_prof.id)
                       AND id_institution = i_prof.institution
                       AND id_software = i_prof.software
                       AND flg_execute = pk_procedures_constant.g_yes) idcs
             WHERE idcs.id_intervention = t.column_value
            UNION ALL
            SELECT pk_procedures_constant.g_id_location_hhc,
                   100,
                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T191'),
                   decode(i_flg_time,
                          pk_procedures_constant.g_flg_time_h,
                          pk_procedures_constant.g_yes,
                          pk_procedures_constant.g_no),
                   pk_procedures_constant.g_flg_location_hhc
              FROM dual
             WHERE i_flg_time = pk_procedures_constant.g_flg_time_h;
    
        IF SQL%ROWCOUNT = 0
        THEN
            l_default := pk_procedures_constant.g_yes;
        ELSE
            l_default := pk_procedures_constant.g_no;
        END IF;
    
        LOOP
            FETCH l_inst
                INTO l_id_institution, l_institution_name, l_institution_abbreviation;
            EXIT WHEN l_inst%NOTFOUND;
        
            IF l_id_institution = pk_sysconfig.get_config('REF_EXTERNAL_INST', i_prof)
               AND l_default = pk_procedures_constant.g_yes
            THEN
                l_default := pk_procedures_constant.g_yes;
            ELSE
                l_default := pk_procedures_constant.g_no;
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, vc_2, vc_3)
            VALUES
                (l_id_institution, 20, l_institution_name, l_default, 'I');
        END LOOP;
        CLOSE l_inst;
    
        g_error := 'GET VALUE';
        SELECT data, label
          INTO i_value, i_desc_value
          FROM (SELECT DISTINCT data, rank, label, flg_default, flg_type
                  FROM (SELECT num_1 data, num_2 rank, vc_1 label, vc_2 flg_default, vc_3 flg_type
                          FROM tbl_temp)
                 WHERE flg_default = pk_alert_constant.g_yes
                 ORDER BY rank, label)
         WHERE rownum = 1;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_DEFAULT_LOCATION',
                                              l_error);
            RETURN FALSE;
    END get_procedure_default_location;

    FUNCTION get_procedure_parameter_list
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_patient         IN patient.id_patient%TYPE,
        i_intervention    IN table_number,
        o_weight          OUT VARCHAR2,
        o_analysis_result OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_vs_weight          vital_sign.id_vital_sign%TYPE := 29;
        l_dt_vital_sign_read TIMESTAMP WITH LOCAL TIME ZONE;
    
        l_dt_result VARCHAR2(200 CHAR);
    
        l_analysis_param table_number := table_number();
    
        l_list                   pk_types.cursor_type;
        l_analysis_result        VARCHAR2(1000 CHAR);
        l_analysis_result_list   table_varchar := table_varchar();
        l_id_analysis_param_list table_number := table_number();
    
        l_analysis     table_varchar := table_varchar();
        l_intervention table_number := table_number();
    
    BEGIN
        g_sysdate_tstz := current_timestamp;
    
        IF i_patient IS NOT NULL
        THEN
            g_error := 'CALL PK_VITAL_SIGN.GET_PAT_LST_VSR_VALUE';
            IF NOT pk_vital_sign.get_pat_lst_vsr_value(i_lang               => i_lang,
                                                       i_prof               => i_prof,
                                                       i_id_vital_sign      => l_vs_weight,
                                                       i_patient            => i_patient,
                                                       i_dt_max_reg         => g_sysdate_tstz,
                                                       o_value_desc         => o_weight,
                                                       o_dt_vital_sign_read => l_dt_vital_sign_read,
                                                       o_error              => o_error)
            THEN
                NULL;
            END IF;
        
            l_dt_result := pk_date_utils.date_send_tsz(i_lang, g_sysdate_tstz, i_prof);
        
            FOR i IN 1 .. i_intervention.count
            LOOP
                -- begin
                SELECT iap.id_analysis_param
                  BULK COLLECT
                  INTO l_analysis_param
                  FROM interv_analysis_param iap
                 WHERE iap.id_intervention = i_intervention(i)
                   AND iap.id_institution = i_prof.institution
                   AND iap.id_software = i_prof.software;
            
                g_error := 'CALL PK_LAB_TESTS_EXTERNAL_API_DB.GET_LAB_TEST_RESULT_PARAM';
                IF NOT pk_lab_tests_external_api_db.get_lab_test_result_param(i_lang           => i_lang,
                                                                              i_prof           => i_prof,
                                                                              i_patient        => i_patient,
                                                                              i_analysis_param => l_analysis_param,
                                                                              i_dt_result      => l_dt_result,
                                                                              o_list           => l_list,
                                                                              o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                FETCH l_list BULK COLLECT
                    INTO l_analysis_result_list, l_id_analysis_param_list;
                CLOSE l_list;
            
                FOR j IN 1 .. l_analysis_result_list.count
                LOOP
                    IF j = 1
                    THEN
                        l_analysis_result := l_analysis_result_list(j);
                    ELSE
                        l_analysis_result := l_analysis_result || '; ' || l_analysis_result_list(j);
                    END IF;
                END LOOP;
            
                IF l_analysis_result_list.count != 0
                THEN
                    l_intervention.extend();
                    l_analysis.extend();
                
                    l_intervention(l_intervention.count) := i_intervention(i);
                    l_analysis(l_analysis.count) := l_analysis_result;
                END IF;
            END LOOP;
        
            OPEN o_analysis_result FOR
                SELECT i.column_value id_intervention, ar.column_value analysis_result
                  FROM (SELECT rownum rn, column_value
                          FROM TABLE(l_intervention)) i
                  JOIN (SELECT rownum rn, column_value
                          FROM TABLE(l_analysis)) ar
                    ON (i.rn = ar.rn);
        ELSE
            o_weight := NULL;
            pk_types.open_my_cursor(o_analysis_result);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_PARAMETER_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_analysis_result);
            RETURN FALSE;
    END get_procedure_parameter_list;

    FUNCTION get_procedure_codification_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN table_number,
        o_list         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT DISTINCT ic.id_codification data,
                            NULL rank,
                            pk_translation.get_translation(i_lang,
                                                           'CODIFICATION.CODE_CODIFICATION.' || ic.id_codification) label,
                            cis.flg_default
              FROM interv_codification ic, codification_instit_soft cis
             WHERE ic.id_intervention IN (SELECT /*+opt_estimate(table t rows=1)*/
                                           *
                                            FROM TABLE(i_intervention) t)
               AND ic.flg_available = pk_procedures_constant.g_available
               AND ic.id_codification = cis.id_codification
               AND cis.id_institution = i_prof.institution
               AND cis.id_software = i_prof.software
               AND cis.flg_available = pk_procedures_constant.g_available
               AND EXISTS (SELECT 1
                      FROM codification c
                     WHERE cis.id_codification = c.id_codification
                       AND c.flg_available = pk_procedures_constant.g_available)
             ORDER BY label;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_CODIFICATION_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_codification_list;

    FUNCTION get_procedure_codification_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN VARCHAR2,
        i_flg_default  IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN t_tbl_core_domain IS
    
        l_tbl_intervention table_number := table_number();
    
        l_ret t_tbl_core_domain;
    
        l_error t_error_out;
    
    BEGIN
    
        l_tbl_intervention := pk_utils.str_split_n(i_list => i_intervention, i_delim => '|');
    
        g_error := 'OPEN L_RET';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(NULL, t.label, t.data, t.rank, NULL)
                  FROM (SELECT DISTINCT ic.id_codification data,
                                        NULL rank,
                                        pk_translation.get_translation(i_lang,
                                                                       'CODIFICATION.CODE_CODIFICATION.' ||
                                                                       ic.id_codification) label,
                                        cis.flg_default
                          FROM interv_codification ic, codification_instit_soft cis
                         WHERE ic.id_intervention IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                       *
                                                        FROM TABLE(l_tbl_intervention) t)
                           AND ic.flg_available = pk_procedures_constant.g_available
                           AND ic.id_codification = cis.id_codification
                           AND cis.id_institution = i_prof.institution
                           AND cis.id_software = i_prof.software
                           AND cis.flg_available = pk_procedures_constant.g_available
                           AND EXISTS
                         (SELECT 1
                                  FROM codification c
                                 WHERE cis.id_codification = c.id_codification
                                   AND c.flg_available = pk_procedures_constant.g_available)
                           AND (i_flg_default = pk_alert_constant.g_no OR
                               (i_flg_default = pk_alert_constant.g_yes AND cis.flg_default = pk_alert_constant.g_yes))
                         ORDER BY label) t);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_CODIFICATION_LIST',
                                              l_error);
            RETURN t_tbl_core_domain();
    END get_procedure_codification_list;

    FUNCTION get_procedure_health_plan_list
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE,
        o_list    OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_list                    pk_types.cursor_type;
        l_id_pat_health_plan      pat_health_plan.id_pat_health_plan%TYPE;
        l_id_health_plan_entity   health_plan.id_health_plan_entity%TYPE;
        l_desc_health_plan_entity pk_translation.t_desc_translation;
        l_id_health_plan          health_plan.id_health_plan%TYPE;
        l_desc_health_plan        pk_translation.t_desc_translation;
        l_num_health_plan         pat_health_plan.num_health_plan%TYPE;
    
    BEGIN
    
        IF NOT pk_adt.get_pat_health_plans(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_id_patient      => i_patient,
                                           o_pat_health_plan => l_list,
                                           o_error           => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        DELETE tbl_temp;
    
        INSERT INTO tbl_temp
            (num_1, num_2, vc_1, num_3, vc_2, vc_3, num_4)
        VALUES
            (NULL, NULL, pk_message.get_message(i_lang, i_prof, 'PROCEDURES_M011'), NULL, NULL, NULL, 10);
    
        LOOP
            FETCH l_list
                INTO l_id_pat_health_plan,
                     l_id_health_plan,
                     l_desc_health_plan,
                     l_desc_health_plan_entity,
                     l_id_health_plan_entity,
                     l_num_health_plan;
            EXIT WHEN l_list%NOTFOUND;
        
            INSERT INTO tbl_temp
                (num_1, num_2, vc_1, num_3, vc_2, vc_3, num_4)
            VALUES
                (l_id_pat_health_plan,
                 l_id_health_plan_entity,
                 l_desc_health_plan_entity,
                 l_id_health_plan,
                 l_desc_health_plan,
                 l_num_health_plan,
                 20);
        END LOOP;
    
        g_error := 'GET CURSOR';
        OPEN o_list FOR
            SELECT num_1 id_pat_health_plan,
                   num_2 id_health_plan_entity,
                   vc_1  desc_health_plan_entity,
                   num_2 id_health_plan,
                   vc_2  desc_health_plan,
                   vc_3  num_health_plan
              FROM tbl_temp
             ORDER BY num_3;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_HEALTH_PLAN_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_health_plan_list;

    FUNCTION get_procedure_time_out_list
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        o_id_doc_template  OUT doc_template.id_doc_template%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        SELECT pk_touch_option.get_doc_template_internal(i_lang,
                                                         i_prof,
                                                         NULL,
                                                         i_episode,
                                                         pk_procedures_constant.g_doc_area_interv_time_out,
                                                         pea.id_intervention) doc_template_interv
          INTO o_id_doc_template
          FROM procedures_ea pea
         WHERE pea.id_interv_presc_det = i_interv_presc_det;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_TIME_OUT_LIST',
                                              o_error);
            RETURN FALSE;
    END get_procedure_time_out_list;

    FUNCTION get_procedure_modifiers_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_intervention IN table_number,
        o_list         OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_procedures_modifiers sys_config.value%TYPE := pk_sysconfig.get_config('PROCEDURES_MODIFIERS_AVAILABLE',
                                                                                i_prof);
    
        l_task_type  table_number;
        l_id_content table_varchar;
    
    BEGIN
    
        IF l_procedures_modifiers = pk_procedures_constant.g_yes
        THEN
            SELECT pk_alert_constant.g_task_procedure, i.id_content
              BULK COLLECT
              INTO l_task_type, l_id_content
              FROM intervention i
             WHERE i.id_intervention IN (SELECT /*+opt_estimate (table t rows=1)*/
                                          *
                                           FROM TABLE(i_intervention) t);
        
            g_error := 'GET CURSOR';
            OPEN o_list FOR
                SELECT data, id_inst_owner, rank, label, NULL flg_default
                  FROM (SELECT t.id_concept_term data,
                               t.id_cncpt_trm_inst_owner id_inst_owner,
                               pk_api_termin_server_func.get_concept_term_desc(i_lang,
                                                                               t.id_task_type,
                                                                               t.id_concept_term,
                                                                               t.id_cncpt_trm_inst_owner) label,
                               10 rank,
                               NULL flg_default
                          FROM TABLE(pk_terminology_search.tf_concept_by_id_content(i_lang,
                                                                                    i_prof,
                                                                                    l_task_type,
                                                                                    l_id_content,
                                                                                    'HAS_MODIFIER')) t)
                 ORDER BY rank, label;
        ELSE
            pk_types.open_my_cursor(o_list);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_MODIFIERS_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
    END get_procedure_modifiers_list;

    FUNCTION get_full_items_by_screen
    (
        i_lang        IN NUMBER,
        i_prof        IN profissional,
        i_patient     IN NUMBER,
        i_episode     IN NUMBER,
        i_screen_name IN VARCHAR2,
        i_action      IN NUMBER,
        o_components  OUT pk_types.cursor_type,
        o_ds_target   OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_patient patient%ROWTYPE;
    
        l_tbl_id_intervention table_number;
    
    BEGIN
    
        l_tbl_id_intervention := pk_utils.str_split_n(i_list => i_screen_name, i_delim => '|');
    
        OPEN o_components FOR
            SELECT 0 id_ds_cmpt_mkt_rel,
                   NULL id_ds_component_parent,
                   NULL code_alt_desc,
                   pk_message.get_message(i_lang, 'PROCEDURES_T163') desc_component,
                   i_screen_name internal_name,
                   NULL flg_data_type,
                   NULL internal_sample_text_type,
                   --to_number(i_screen_name) id_ds_component_child,
                   0    id_ds_component_child,
                   1    rank,
                   NULL max_len,
                   NULL min_len,
                   NULL min_value,
                   NULL max_value,
                   1    position,
                   NULL flg_multichoice,
                   NULL comp_size,
                   NULL flg_wrap_text,
                   NULL multichoice_code,
                   NULL service_params,
                   NULL flg_event_type,
                   NULL flg_exp_type,
                   NULL input_expression,
                   NULL input_mask,
                   NULL comp_offset,
                   NULL flg_hidden,
                   NULL placeholder,
                   NULL validation_message,
                   NULL flg_clearable,
                   NULL crate_identifier,
                   1    rn,
                   NULL flg_repeatable,
                   NULL flg_data_type2
              FROM dual
            UNION ALL
            SELECT t.column_value id_ds_cmpt_mkt_rel,
                   0 id_ds_component_parent,
                   NULL code_alt_desc,
                   pk_translation.get_translation(i_lang, 'INTERVENTION.CODE_INTERVENTION.' || to_number(i_screen_name)) desc_component,
                   pk_translation.get_translation(i_lang, 'INTERVENTION.CODE_INTERVENTION.' || to_number(i_screen_name)) internal_name,
                   NULL flg_data_type,
                   NULL internal_sample_text_type,
                   t.column_value id_ds_component_child,
                   2 rank,
                   NULL max_len,
                   NULL min_len,
                   NULL min_value,
                   NULL max_value,
                   2 position,
                   NULL flg_multichoice,
                   NULL comp_size,
                   NULL flg_wrap_text,
                   NULL multichoice_code,
                   NULL service_params,
                   NULL flg_event_type,
                   NULL flg_exp_type,
                   NULL input_expression,
                   NULL input_mask,
                   NULL comp_offset,
                   NULL flg_hidden,
                   NULL placeholder,
                   NULL validation_message,
                   NULL flg_clearable,
                   NULL crate_identifier,
                   1 rn,
                   NULL flg_repeatable,
                   NULL flg_data_type2
              FROM TABLE(l_tbl_id_intervention) t
            UNION ALL
            SELECT q.id_questionnaire id_ds_cmpt_mkt_rel,
                   q.id_intervention id_ds_component_parent,
                   NULL code_alt_desc,
                   pk_mcdt.get_questionnaire_alias(i_lang,
                                                   i_prof,
                                                   'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' || q.id_questionnaire) desc_component,
                   to_char(q.id_questionnaire) internal_name,
                   decode(q.flg_type, 'D', 'DT', 'ME', 'MS', 'MI', 'MS', 'N', 'K', NULL) flg_data_type,
                   NULL internal_sample_text_type,
                   q.id_questionnaire id_ds_component_child,
                   q.id_questionnaire rank,
                   NULL max_len,
                   NULL min_len,
                   NULL min_value,
                   NULL max_value,
                   q.id_questionnaire position,
                   decode(q.flg_type, 'ME', 'SRV', 'MI', 'SRV', NULL) flg_multichoice,
                   NULL comp_size,
                   NULL flg_wrap_text,
                   decode(q.flg_type, 'ME', 'GET_PROCEDURE_CQ', 'MI', 'GET_PROCEDURE_CQ', NULL) multichoice_code,
                   q.id_questionnaire || '|' || q.id_questionnaire service_params,
                   decode(q.id_questionnaire_parent,
                          NULL,
                          decode(q.flg_mandatory, pk_procedures_constant.g_yes, 'M', NULL),
                          'I') flg_event_type,
                   NULL flg_exp_type,
                   NULL input_expression,
                   NULL input_mask,
                   NULL comp_offset,
                   pk_alert_constant.g_no flg_hidden,
                   NULL placeholder,
                   NULL validation_message,
                   pk_alert_constant.g_yes flg_clearable,
                   NULL crate_identifier,
                   q.id_questionnaire rn,
                   NULL flg_repeatable,
                   NULL flg_data_type2
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention IN (SELECT *
                                                    FROM TABLE(l_tbl_id_intervention))
                       AND iq.flg_time = pk_procedures_constant.g_interv_cq_on_order
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q
             ORDER BY rank;
    
        OPEN o_ds_target FOR
            SELECT q.id_questionnaire id_cmpt_mkt_origin,
                   q.id_questionnaire id_cmpt_origin,
                   q.id_questionnaire id_ds_event,
                   'S' flg_type,
                   NULL VALUE,
                   NULL id_cmpt_mkt_dest,
                   NULL id_cmpt_dest,
                   NULL field_mask,
                   NULL flg_event_target_type,
                   NULL validation_message,
                   1 rn
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention IN (SELECT *
                                                    FROM TABLE(l_tbl_id_intervention))
                       AND iq.flg_time = pk_procedures_constant.g_interv_cq_on_order
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q
             WHERE q.id_response_parent IS NULL
               AND q.flg_type IN ('ME', 'MI')
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_FULL_ITEMS_BY_SCREEN',
                                              o_error);
            RETURN FALSE;
    END get_full_items_by_screen;

    FUNCTION get_multichoice_options
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_field IN VARCHAR2
    ) RETURN t_tbl_core_domain IS
    
        l_list t_tbl_core_domain;
    
        l_error t_error_out;
    
    BEGIN
    
        g_error := 'OPEN L_LIST';
        SELECT *
          BULK COLLECT
          INTO l_list
          FROM (SELECT t_row_core_domain(NULL, t.label, t.data, t.rank, NULL)
                  FROM (SELECT qr.id_response data,
                               pk_mcdt.get_response_alias(i_lang, i_prof, 'RESPONSE.CODE_RESPONSE.' || qr.id_response) label,
                               r.flg_free_text,
                               qr.rank rank
                          FROM questionnaire_response qr, response r
                         WHERE qr.id_questionnaire = to_number(i_field)
                           AND qr.flg_available = pk_procedures_constant.g_available
                           AND qr.id_response = r.id_response
                           AND r.flg_available = pk_procedures_constant.g_available) t);
    
        RETURN l_list;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_MULTICHOICE_OPTIONS',
                                              l_error);
            RETURN l_list;
    END get_multichoice_options;

    FUNCTION get_procedure_unit_measure_list
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN t_tbl_core_domain IS
    
        l_tbl_unit_measure table_number := table_number(10374, 1041, 1039, 10375, 1127, 10373);
        l_tbl_list         table_table_varchar := table_table_varchar();
    
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    BEGIN
        g_error := 'OPEN L_RET';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => tt.label,
                                         domain_value  => tt.data,
                                         order_rank    => NULL,
                                         img_name      => NULL)
                  FROM (SELECT t.column_value data,
                               pk_unit_measure.get_unit_measure_description(i_lang, i_prof, t.column_value) label
                          FROM TABLE(l_tbl_unit_measure) t
                         ORDER BY t.column_value) tt);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_UNIT_MEASURE_LIST',
                                              l_error);
            RETURN t_tbl_core_domain();
    END get_procedure_unit_measure_list;

    FUNCTION get_procedure_cq_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_tbl_int_name   IN table_varchar,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_value          IN table_table_varchar,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_PROCEDURE_CQ_VALUES';
    
        l_req_id    NUMBER;
        l_int_n     NUMBER;
        l_id_interv NUMBER;
        l_patient   patient%ROWTYPE;
    BEGIN
    
        SELECT p.*
          INTO l_patient
          FROM patient p
         WHERE id_patient = i_patient;
    
        IF i_action = pk_dyn_form_constant.get_submit_action()
        THEN
        
            FOR i IN 1 .. i_tbl_mkt_rel.count
            LOOP
                IF i_tbl_mkt_rel(i) = i_curr_component
                THEN
                    l_req_id := i_value(i) (1);
                    l_int_n  := to_number(i_tbl_int_name(i));
                END IF;
            END LOOP;
        
            l_id_interv := i_curr_component - l_int_n;
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => (q.id_questionnaire + q.id_intervention),
                                       id_ds_component    => NULL, --t.id_ds_component_child,
                                       internal_name      => NULL, --t.internal_name_child,
                                       VALUE              => NULL,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => NULL,
                                       desc_clob          => NULL,
                                       id_unit_measure    => NULL,
                                       desc_unit_measure  => NULL,
                                       flg_validation     => pk_alert_constant.g_yes,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE
                                                                 WHEN q.id_response_parent = l_req_id THEN
                                                                  'A'
                                                                 ELSE
                                                                  'I'
                                                             END,
                                       flg_multi_status   => NULL,
                                       idx                => 1)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank
                      FROM interv_questionnaire iq, questionnaire_response qr
                     WHERE iq.id_intervention = l_id_interv
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                       AND iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                          --AND qr.id_response_parent = l_req_id
                       AND qr.id_questionnaire_parent = l_int_n
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND EXISTS
                     (SELECT 1
                              FROM questionnaire q
                             WHERE q.id_questionnaire = iq.id_questionnaire
                               AND q.flg_available = pk_procedures_constant.g_available
                               AND (((l_patient.gender IS NOT NULL AND coalesce(q.gender, 'I', 'U', 'N', 'C', 'A', 'B') IN
                                   ('I', 'U', 'N', 'C', 'A', 'B', l_patient.gender)) OR l_patient.gender IS NULL OR
                                   l_patient.gender IN ('I', 'U', 'N', 'C', 'A', 'B')) AND
                                   (nvl(l_patient.age, 0) BETWEEN nvl(q.age_min, 0) AND
                                   nvl(q.age_max, nvl(l_patient.age, 0)) OR nvl(l_patient.age, 0) = 0)))) q;
        ELSIF i_action = pk_orders_constant.g_action_cq_edition
        THEN
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => (q.id_questionnaire + q.id_intervention),
                                       id_ds_component    => NULL, --t.id_ds_component_child,
                                       internal_name      => NULL, --t.internal_name_child,
                                       VALUE              => CASE
                                                                 WHEN q.flg_type IN ('MI', 'ME') THEN
                                                                  to_char(q.id_response)
                                                                 ELSE
                                                                  decode(is_text, pk_alert_constant.g_yes, desc_response, q.id_response)
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => desc_response,
                                       desc_clob          => NULL,
                                       id_unit_measure    => NULL,
                                       desc_unit_measure  => NULL,
                                       flg_validation     => 'Y',
                                       err_msg            => NULL,
                                       flg_event_type     => decode(q.id_response,
                                                                    NULL,
                                                                    decode(q.id_questionnaire_parent,
                                                                           NULL,
                                                                           decode(q.flg_mandatory, 'Y', 'M', NULL),
                                                                           'I'),
                                                                    'A'),
                                       flg_multi_status   => NULL,
                                       idx                => 1)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT DISTINCT iq.id_intervention,
                                    iq.id_questionnaire,
                                    qr.id_questionnaire_parent,
                                    qr.id_response_parent,
                                    iq.flg_type,
                                    iq.flg_mandatory,
                                    iq.flg_copy,
                                    iq.flg_validation,
                                    iq.id_unit_measure,
                                    iq.rank,
                                    t.id_response,
                                    decode(dbms_lob.getlength(t.notes),
                                           NULL,
                                           pk_alert_constant.g_no,
                                           pk_alert_constant.g_yes) is_text,
                                    CASE
                                         WHEN iq.flg_type IN ('MI', 'ME') THEN
                                          pk_mcdt.get_response_alias(i_lang,
                                                                     i_prof,
                                                                     'RESPONSE.CODE_RESPONSE.' || t.id_response)
                                         ELSE
                                          decode(dbms_lob.getlength(t.notes),
                                                 NULL,
                                                 pk_mcdt.get_response_alias(i_lang,
                                                                            i_prof,
                                                                            'RESPONSE.CODE_RESPONSE.' || t.id_response),
                                                 dbms_lob.substr(t.notes, 3800))
                                     END desc_response
                      FROM interv_questionnaire iq
                      JOIN questionnaire_response qr
                        ON iq.id_questionnaire = qr.id_questionnaire
                       AND iq.id_response = qr.id_response
                      LEFT JOIN (SELECT *
                                  FROM (SELECT iqr.*,
                                               row_number() over(PARTITION BY iqr.id_interv_presc_det, iqr.id_questionnaire, iqr.id_response ORDER BY iqr.dt_last_update_tstz DESC) AS rn
                                          FROM interv_question_response iqr
                                         WHERE iqr.id_interv_presc_det = i_tbl_id_pk(1))) t
                        ON t.id_questionnaire = iq.id_questionnaire
                       AND t.id_response = iq.id_response
                       AND t.rn = 1
                     WHERE iq.id_intervention IN (SELECT ipd.id_intervention
                                                    FROM interv_presc_det ipd
                                                   WHERE ipd.id_interv_presc_det = i_tbl_id_pk(1))
                       AND iq.flg_time = 'O'
                       AND iq.id_institution = i_prof.institution
                       AND iq.flg_available = pk_procedures_constant.g_available
                          --AND qr.id_questionnaire_parent = l_int_n
                       AND qr.flg_available = pk_procedures_constant.g_available
                       AND t.rn = 1
                       AND dbms_lob.getlength(t.notes) IS NOT NULL) q;
        END IF;
    
        --For each action (New form, Component submit, Selecting/Deselecting in the viewer, Edition)
        --it is necessary to tell the UX layer if the form is valid. This will allow the UX to activete/inactivate the OK button,
        --and also to activate/inactivate the pencil from the viewer for each record.
        --For this function to perform the verification, the hidden component DS_OK_CONTROL_BUTTON must be configured in the form.
        g_error := 'ERROR CALLING PK_ORDERS_UTILS.GET_OK_BUTTON_CONTROL';
        IF NOT pk_orders_utils.get_ok_button_control(i_lang           => i_lang,
                                                     i_prof           => i_prof,
                                                     i_episode        => i_episode,
                                                     i_patient        => i_patient,
                                                     i_action         => i_action,
                                                     i_root_name      => i_root_name,
                                                     i_curr_component => i_curr_component,
                                                     i_idx            => 1,
                                                     i_tbl_id_pk      => i_tbl_id_pk,
                                                     i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                     i_tbl_int_name   => i_tbl_int_name,
                                                     i_value          => i_value,
                                                     i_value_desc     => NULL,
                                                     i_tbl_data       => NULL,
                                                     i_value_clob     => NULL,
                                                     i_tbl_result     => tbl_result,
                                                     o_error          => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_procedure_cq_values;

    FUNCTION tf_get_procedure_order
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_detail IS
    
        l_ret t_tbl_procedures_detail := t_tbl_procedures_detail();
    
        l_health_insurance sys_config.value%TYPE := pk_sysconfig.get_config('MCDT_HEALTH_INSURANCE', i_prof);
    
        l_intervention    intervention.id_intervention%TYPE;
        l_weight          VARCHAR2(50 CHAR);
        l_analysis_result pk_types.cursor_type;
    
        l_id     NUMBER;
        l_result VARCHAR2(100 CHAR);
    
        l_error t_error_out;
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
        l_msg_upd sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M127');
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        g_error := 'GET ID_INTERVENTION';
        SELECT ipd.id_intervention
          INTO l_intervention
          FROM interv_presc_det ipd
         WHERE ipd.id_interv_presc_det = i_interv_presc_det;
    
        g_error := 'CALL PK_PROCEDURES_CORE.GET_PROCEDURE_PARAMETER_LIST';
        IF NOT pk_procedures_core.get_procedure_parameter_list(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_patient         => pk_episode.get_id_patient(i_episode),
                                                               i_intervention    => table_number(l_intervention),
                                                               o_weight          => l_weight,
                                                               o_analysis_result => l_analysis_result,
                                                               o_error           => l_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'FETCH L_ANALYSIS_RESULT';
        FETCH l_analysis_result
            INTO l_id, l_result;
        CLOSE l_analysis_result;
    
        g_error := 'OPEN O_INTERV_ORDER';
        WITH cso_table AS
         (SELECT *
            FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang,
                                                                i_prof,
                                                                i_episode,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                i_interv_presc_det)))
        SELECT t_procedures_detail(id_interv_presc_det,
                                   registry,
                                   desc_procedure,
                                   num_order,
                                   clinical_indication,
                                   diagnosis_notes,
                                   desc_diagnosis,
                                   clinical_purpose,
                                   laterality,
                                   instructions,
                                   priority,
                                   desc_status,
                                   title_order_set,
                                   task_depend,
                                   desc_time,
                                   desc_time_limit,
                                   order_recurrence,
                                   prn,
                                   notes_prn,
                                   execution,
                                   perform_location,
                                   dt_req,
                                   desc_supplies,
                                   lab_result,
                                   weight,
                                   not_order_reason,
                                   notes,
                                   co_sign,
                                   prof_order,
                                   dt_order,
                                   order_type,
                                   health_insurance,
                                   financial_entity,
                                   health_plan,
                                   insurance_number,
                                   exemption,
                                   cancellation,
                                   cancel_reason,
                                   cancel_notes,
                                   cancel_prof_order,
                                   cancel_dt_order,
                                   cancel_order_type,
                                   dt_last_update,
                                   dt_ord)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT /*+ opt_estimate(table cso rows=2) opt_estimate(table csc rows=2) */
                 ipd.id_interv_presc_det,
                 nvl2(ip.dt_last_update_tstz, l_msg_upd, l_msg_reg) || ' ' ||
                 pk_prof_utils.get_name_signature(i_lang,
                                                  i_prof,
                                                  coalesce(ipd.id_prof_cancel,
                                                           ipd.id_prof_last_update,
                                                           ip.id_professional)) ||
                 decode(pk_prof_utils.get_spec_signature(i_lang,
                                                         i_prof,
                                                         coalesce(ipd.id_prof_cancel,
                                                                  ipd.id_prof_last_update,
                                                                  ip.id_professional),
                                                         coalesce(ipd.dt_cancel_tstz,
                                                                  ipd.dt_last_update_tstz,
                                                                  ip.dt_interv_prescription_tstz),
                                                         ip.id_episode),
                        NULL,
                        '; ',
                        ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                 i_prof,
                                                                 coalesce(ipd.id_prof_cancel,
                                                                          ipd.id_prof_last_update,
                                                                          ip.id_professional),
                                                                 coalesce(ipd.dt_cancel_tstz,
                                                                          ipd.dt_last_update_tstz,
                                                                          ip.dt_interv_prescription_tstz),
                                                                 ip.id_episode) || '); ') ||
                 pk_date_utils.date_char_tsz(i_lang,
                                             coalesce(ipd.dt_cancel_tstz,
                                                      ipd.dt_last_update_tstz,
                                                      ip.dt_interv_prescription_tstz),
                                             i_prof.institution,
                                             i_prof.software) registry,
                 aa_code_messages('PROCEDURES_T096') ||
                 pk_procedures_utils.get_alias_translation(i_lang,
                                                           i_prof,
                                                           'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                           NULL) desc_procedure,
                 NULL num_order,
                 aa_code_messages('PROCEDURES_T058') clinical_indication,
                 decode(ipd.diagnosis_notes, NULL, NULL, aa_code_messages('PROCEDURES_T081') || ipd.diagnosis_notes) diagnosis_notes,
                 decode(pk_diagnosis.concat_diag(i_lang, NULL, NULL, ipd.id_interv_presc_det, i_prof),
                        NULL,
                        NULL,
                        aa_code_messages('COMMON_T062') ||
                        pk_diagnosis.concat_diag(i_lang,
                                                 NULL,
                                                 NULL,
                                                 ipd.id_interv_presc_det,
                                                 i_prof,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 pk_alert_constant.g_yes)) desc_diagnosis,
                 decode(ipd.id_clinical_purpose,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T104') ||
                        decode(ipd.id_clinical_purpose,
                               0,
                               ipd.clinical_purpose_notes,
                               pk_translation.get_translation(i_lang,
                                                              'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                              ipd.id_clinical_purpose))) clinical_purpose,
                 decode(ipd.flg_laterality,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T122') ||
                        pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang)) laterality,
                 aa_code_messages('PROCEDURES_T082') instructions,
                 decode(ipd.flg_prty,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T091') ||
                        pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESC_DET.FLG_PRTY', ipd.flg_prty, NULL)) priority,
                 aa_code_messages('PROCEDURES_T011') ||
                 decode(ipd.flg_referral,
                        pk_procedures_constant.g_flg_referral_r,
                        pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                        pk_procedures_constant.g_flg_referral_s,
                        pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                        pk_procedures_constant.g_flg_referral_i,
                        pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang),
                        decode(ipd.flg_status,
                               pk_procedures_constant.g_interv_sos,
                               pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS',
                                                       pk_procedures_constant.g_interv_req,
                                                       i_lang),
                               pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS', ipd.flg_status, i_lang))) desc_status,
                 decode(pk_api_order_sets.get_order_set_title(i_lang,
                                                              i_prof,
                                                              ipd.id_interv_presc_det,
                                                              pk_order_sets.g_odst_task_procedure),
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T143') ||
                        pk_api_order_sets.get_order_set_title(i_lang,
                                                              i_prof,
                                                              ipd.id_interv_presc_det,
                                                              pk_order_sets.g_odst_task_procedure)) title_order_set,
                 NULL task_depend,
                 aa_code_messages('PROCEDURES_T023') ||
                  pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ip.flg_time, NULL) || CASE
                      WHEN ipd.dt_begin_tstz IS NOT NULL THEN
                       ' (' || decode(i_flg_report, pk_exam_constant.g_yes, '<b>') ||
                       pk_date_utils.date_char_tsz(i_lang, ipd.dt_begin_tstz, i_prof.institution, i_prof.software) ||
                       decode(i_flg_report, pk_exam_constant.g_yes, '</b> ') || ')'
                  END desc_time,
                 NULL desc_time_limit,
                 aa_code_messages('PROCEDURES_T025') ||
                 decode(ipd.id_order_recurrence,
                        NULL,
                        pk_message.get_message(i_lang, i_prof, 'ORDER_RECURRENCE_M004'),
                        pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang, i_prof, ipd.id_order_recurrence)) order_recurrence,
                 decode(ipd.flg_prn,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T130') ||
                        pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang)) prn,
                 decode(dbms_lob.getlength(ipd.prn_notes),
                        NULL,
                        to_clob(''),
                        aa_code_messages('PROCEDURES_T131') || ipd.prn_notes) notes_prn,
                 aa_code_messages('PROCEDURES_T139') execution,
                 
                 aa_code_messages('PROCEDURES_T144') ||
                 decode(ipd.flg_location,
                        pk_procedures_constant.g_flg_location_hhc,
                        pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                        decode(ipd.id_exec_institution,
                               i_prof.institution,
                               pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                               pk_translation.get_translation(i_lang,
                                                              'AB_INSTITUTION.CODE_INSTITUTION.' || ipd.id_exec_institution))) perform_location,
                 decode(cso.dt_ordered_by,
                        NULL,
                        decode(ipd.dt_order_tstz,
                               NULL,
                               NULL,
                               aa_code_messages('PROCEDURES_T010') ||
                               pk_date_utils.date_char_tsz(i_lang, ipd.dt_order_tstz, i_prof.institution, i_prof.software)),
                        NULL) dt_req,
                 decode(pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                         i_prof,
                                                                         ipd.id_interv_presc_det,
                                                                         pk_supplies_constant.g_context_procedure_req),
                        NULL,
                        NULL,
                        aa_code_messages('SUPPLIES_T076') ||
                        pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                         i_prof,
                                                                         ipd.id_interv_presc_det,
                                                                         pk_supplies_constant.g_context_procedure_req)) desc_supplies,
                 decode(l_result, NULL, NULL, aa_code_messages('PROCEDURES_T092') || l_result) lab_result,
                 decode(l_weight, NULL, NULL, aa_code_messages('PROCEDURES_T090') || l_weight) weight,
                 decode(pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason),
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T123') ||
                        pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason)) not_order_reason,
                 decode(ipd.notes, NULL, NULL, aa_code_messages('PROCEDURES_T100') || ipd.notes) notes,
                 aa_code_messages('PROCEDURES_T138') co_sign,
                 decode(cso.desc_prof_ordered_by,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T077') || cso.desc_prof_ordered_by) prof_order,
                 decode(cso.dt_ordered_by,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T010') ||
                        pk_date_utils.date_char_tsz(i_lang, cso.dt_ordered_by, i_prof.institution, i_prof.software)) dt_order,
                 decode(cso.id_order_type, NULL, NULL, aa_code_messages('PROCEDURES_T038') || cso.desc_order_type) order_type,
                 aa_code_messages('PROCEDURES_T133') health_insurance,
                 decode(l_health_insurance,
                        pk_procedures_constant.g_no,
                        NULL,
                        decode(ipd.id_pat_health_plan,
                               NULL,
                               NULL,
                               aa_code_messages('PROCEDURES_T134') ||
                               pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'F'))) financial_entity,
                 decode(l_health_insurance,
                        pk_procedures_constant.g_no,
                        NULL,
                        decode(ipd.id_pat_health_plan,
                               NULL,
                               NULL,
                               aa_code_messages('PROCEDURES_T135') ||
                               pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'H'))) health_plan,
                 decode(l_health_insurance,
                        pk_procedures_constant.g_no,
                        NULL,
                        decode(ipd.id_pat_health_plan,
                               NULL,
                               NULL,
                               aa_code_messages('PROCEDURES_T136') ||
                               pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'N'))) insurance_number,
                 decode(l_health_insurance,
                        pk_procedures_constant.g_no,
                        NULL,
                        decode(ipd.id_pat_exemption,
                               NULL,
                               NULL,
                               aa_code_messages('PROCEDURES_T137') ||
                               pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption))) exemption,
                 decode(ipd.flg_status,
                        pk_procedures_constant.g_interv_expired,
                        aa_code_messages('PROCEDURES_T089'),
                        pk_procedures_constant.g_interv_interrupted,
                        aa_code_messages('PROCEDURES_T185'),
                        aa_code_messages('PROCEDURES_T164')) cancellation,
                 decode(ipd.id_cancel_reason,
                        NULL,
                        NULL,
                        decode(ipd.flg_status,
                               pk_procedures_constant.g_interv_interrupted,
                               aa_code_messages('PROCEDURES_T186'),
                               aa_code_messages('PROCEDURES_T029')) ||
                        pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ipd.id_cancel_reason)) cancel_reason,
                 decode(ipd.notes_cancel,
                        NULL,
                        NULL,
                        decode(ipd.flg_status,
                               pk_procedures_constant.g_interv_expired,
                               aa_code_messages('PROCEDURES_T100'),
                               pk_procedures_constant.g_interv_interrupted,
                               aa_code_messages('PROCEDURES_T187'),
                               aa_code_messages('PROCEDURES_T024')) || ipd.notes_cancel) cancel_notes,
                 decode(csc.desc_prof_ordered_by,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T036') || csc.desc_prof_ordered_by) cancel_prof_order,
                 decode(csc.dt_ordered_by,
                        NULL,
                        NULL,
                        aa_code_messages('PROCEDURES_T010') ||
                        pk_date_utils.date_char_tsz(i_lang, csc.dt_ordered_by, i_prof.institution, i_prof.software)) cancel_dt_order,
                 decode(csc.id_order_type, NULL, NULL, aa_code_messages('PROCEDURES_T038') || csc.desc_order_type) cancel_order_type,
                 NULL dt_last_update,
                 pk_date_utils.date_send_tsz(i_lang, ip.dt_interv_prescription_tstz, i_prof) dt_ord
                  FROM interv_presc_det ipd, interv_prescription ip, cso_table cso, cso_table csc
                 WHERE ipd.id_interv_presc_det = i_interv_presc_det
                   AND ipd.id_interv_prescription = ip.id_interv_prescription
                   AND ipd.id_co_sign_order = cso.id_co_sign_hist(+)
                   AND ipd.id_co_sign_cancel = csc.id_co_sign_hist(+));
    
        RETURN l_ret;
    
    END tf_get_procedure_order;

    FUNCTION tf_get_procedure_order_history
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_flg_html         IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_detail IS
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
        l_msg_del sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M106');
    
        l_health_insurance sys_config.value%TYPE := pk_sysconfig.get_config('MCDT_HEALTH_INSURANCE', i_prof);
    
        l_intervention    intervention.id_intervention%TYPE;
        l_weight          VARCHAR2(50 CHAR);
        l_analysis_result pk_types.cursor_type;
    
        l_id     NUMBER;
        l_result VARCHAR2(100 CHAR);
    
        l_formated_text VARCHAR2(100 CHAR) := CASE i_flg_html
                                                  WHEN pk_alert_constant.g_yes THEN
                                                   '<br> '
                                                  ELSE
                                                   '<br>' || chr(9) || chr(32) || chr(32)
                                              END;
    
        l_update_tag_flash VARCHAR2(1 CHAR) := CASE i_flg_html
                                                   WHEN pk_alert_constant.g_yes THEN
                                                    NULL
                                                   ELSE
                                                    '§'
                                               END;
    
        l_ret   t_tbl_procedures_detail := t_tbl_procedures_detail();
        l_error t_error_out;
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        
            g_error := 'GET MESSAGES UPDATE';
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail_upd.first .. pk_procedures_constant.ga_code_messages_procedure_detail_upd.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) := CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '<span class="emphasizedRedDetail">'
                                                                                                         ELSE
                                                                                                          '<b>'
                                                                                                     END ||
                                                                                                     pk_message.get_message(i_lang,
                                                                                                                            i_prof,
                                                                                                                            pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) ||
                                                                                                     CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '</span> '
                                                                                                         ELSE
                                                                                                          '</b> '
                                                                                                     END;
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        g_error := 'GET ID_INTERVENTION';
        SELECT ipd.id_intervention
          INTO l_intervention
          FROM interv_presc_det ipd
         WHERE ipd.id_interv_presc_det = i_interv_presc_det;
    
        g_error := 'CALL PK_PROCEDURES_CORE.GET_PROCEDURE_PARAMETER_LIST';
        IF NOT pk_procedures_core.get_procedure_parameter_list(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_patient         => pk_episode.get_id_patient(i_episode),
                                                               i_intervention    => table_number(l_intervention),
                                                               o_weight          => l_weight,
                                                               o_analysis_result => l_analysis_result,
                                                               o_error           => l_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'FETCH L_ANALYSIS_RESULT';
        FETCH l_analysis_result
            INTO l_id, l_result;
        CLOSE l_analysis_result;
    
        g_error := 'OPEN O_INTERV_ORDER';
        WITH cso_table AS
         (SELECT *
            FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang,
                                                                i_prof,
                                                                i_episode,
                                                                NULL,
                                                                NULL,
                                                                NULL,
                                                                i_interv_presc_det)))
        SELECT t_procedures_detail(id_interv_presc_det,
                                   registry,
                                   desc_procedure,
                                   num_order,
                                   clinical_indication,
                                   diagnosis_notes,
                                   desc_diagnosis,
                                   clinical_purpose,
                                   laterality,
                                   instructions,
                                   priority,
                                   desc_status,
                                   title_order_set,
                                   task_depend,
                                   desc_time,
                                   desc_time_limit,
                                   order_recurrence,
                                   prn,
                                   notes_prn,
                                   execution,
                                   perform_location,
                                   dt_req,
                                   desc_supplies,
                                   lab_result,
                                   weight,
                                   not_order_reason,
                                   notes,
                                   co_sign,
                                   prof_order,
                                   dt_order,
                                   order_type,
                                   health_insurance,
                                   financial_entity,
                                   health_plan,
                                   insurance_number,
                                   exemption,
                                   cancellation,
                                   cancel_reason,
                                   cancel_notes,
                                   cancel_prof_order,
                                   cancel_dt_order,
                                   cancel_order_type,
                                   dt_last_update,
                                   dt_ord)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ipd.id_interv_presc_det,
                       decode(cnt,
                              rn,
                              l_msg_reg || ' ' ||
                              pk_prof_utils.get_name_signature(i_lang, i_prof, ipd.id_prof_last_update) ||
                              decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                      i_prof,
                                                                      ipd.id_prof_last_update,
                                                                      ipd.dt_last_update_tstz,
                                                                      ipd.id_episode),
                                     NULL,
                                     '; ',
                                     ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                              i_prof,
                                                                              ipd.id_prof_last_update,
                                                                              ipd.dt_last_update_tstz,
                                                                              ipd.id_episode) || '); ') ||
                              pk_date_utils.date_char_tsz(i_lang,
                                                          ipd.dt_last_update_tstz,
                                                          i_prof.institution,
                                                          i_prof.software),
                              l_msg_reg || ' ' ||
                              pk_prof_utils.get_name_signature(i_lang,
                                                               i_prof,
                                                               nvl(ipd.id_prof_cancel, ipd.id_prof_last_update)) ||
                              decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                      i_prof,
                                                                      nvl(ipd.id_prof_cancel, ipd.id_prof_last_update),
                                                                      nvl(ipd.dt_cancel_tstz, ipd.dt_last_update_tstz),
                                                                      ipd.id_episode),
                                     NULL,
                                     '; ',
                                     ' (' ||
                                     pk_prof_utils.get_spec_signature(i_lang,
                                                                      i_prof,
                                                                      nvl(ipd.id_prof_cancel, ipd.id_prof_last_update),
                                                                      nvl(ipd.dt_cancel_tstz, ipd.dt_last_update_tstz),
                                                                      ipd.id_episode) || '); ') ||
                              pk_date_utils.date_char_tsz(i_lang,
                                                          nvl(ipd.dt_cancel_tstz, ipd.dt_last_update_tstz),
                                                          i_prof.institution,
                                                          i_prof.software)) registry,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T096') ||
                              pk_procedures_utils.get_alias_translation(i_lang,
                                                                        i_prof,
                                                                        'INTERVENTION.CODE_INTERVENTION.' ||
                                                                        ipd.id_intervention,
                                                                        NULL),
                              decode(ipd.id_intervention,
                                     ipd.id_intervention_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T110') || l_update_tag_flash ||
                                     pk_procedures_utils.get_alias_translation(i_lang,
                                                                               i_prof,
                                                                               'INTERVENTION.CODE_INTERVENTION.' ||
                                                                               ipd.id_intervention,
                                                                               NULL) || l_formated_text ||
                                     aa_code_messages('PROCEDURES_T096') ||
                                     pk_procedures_utils.get_alias_translation(i_lang,
                                                                               i_prof,
                                                                               'INTERVENTION.CODE_INTERVENTION.' ||
                                                                               ipd.id_intervention_new,
                                                                               NULL))) desc_procedure,
                       NULL num_order,
                       aa_code_messages('PROCEDURES_T058') clinical_indication,
                       decode(cnt,
                              rn,
                              decode(ipd.diagnosis_notes,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T081') || ipd.diagnosis_notes),
                              decode(ipd.diagnosis_notes,
                                     ipd.diagnosis_notes_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T168') || l_update_tag_flash ||
                                     decode(ipd.diagnosis_notes, NULL, l_msg_del, ipd.diagnosis_notes) ||
                                     decode(ipd.diagnosis_notes_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T081') ||
                                            ipd.diagnosis_notes_new))) diagnosis_notes,
                       decode(cnt,
                              rn,
                              decode(ipd.id_diagnosis_list,
                                     NULL,
                                     decode(pk_diagnosis.concat_diag(i_lang, NULL, ipd.id_interv_presc_det, NULL, i_prof),
                                            NULL,
                                            NULL,
                                            aa_code_messages('COMMON_T062') ||
                                            pk_diagnosis.concat_diag(i_lang, NULL, ipd.id_interv_presc_det, NULL, i_prof)),
                                     aa_code_messages('COMMON_T062') ||
                                     pk_procedures_utils.get_procedure_diagnosis(i_lang, i_prof, ipd.id_diagnosis_list)),
                              decode(ipd.id_diagnosis_list,
                                     ipd.id_diagnosis_list_new,
                                     NULL,
                                     aa_code_messages('COMMON_T061') || l_update_tag_flash ||
                                     decode(ipd.id_diagnosis_list,
                                            NULL,
                                            l_msg_del,
                                            pk_procedures_utils.get_procedure_diagnosis(i_lang,
                                                                                        i_prof,
                                                                                        ipd.id_diagnosis_list)) ||
                                     decode(ipd.id_diagnosis_list_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('COMMON_T062') ||
                                            pk_procedures_utils.get_procedure_diagnosis(i_lang,
                                                                                        i_prof,
                                                                                        ipd.id_diagnosis_list_new)))) desc_diagnosis,
                       decode(cnt,
                              rn,
                              decode(ipd.id_clinical_purpose,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T104') ||
                                     decode(ipd.id_clinical_purpose,
                                            0,
                                            ipd.clinical_purpose_notes,
                                            pk_translation.get_translation(i_lang,
                                                                           'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                                           ipd.id_clinical_purpose))),
                              decode(ipd.id_clinical_purpose,
                                     ipd.id_clinical_purpose_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T169') || l_update_tag_flash ||
                                     decode(ipd.id_clinical_purpose,
                                            NULL,
                                            l_msg_del,
                                            decode(ipd.id_clinical_purpose,
                                                   0,
                                                   ipd.clinical_purpose_notes,
                                                   pk_translation.get_translation(i_lang,
                                                                                  'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                                                  ipd.id_clinical_purpose))) ||
                                     decode(ipd.id_clinical_purpose_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T104') ||
                                            decode(ipd.id_clinical_purpose,
                                                   0,
                                                   ipd.clinical_purpose_notes,
                                                   pk_translation.get_translation(i_lang,
                                                                                  'MULTICHOICE_OPTION.CODE_MULTICHOICE_OPTION.' ||
                                                                                  ipd.id_clinical_purpose_new))))) clinical_purpose,
                       decode(cnt,
                              rn,
                              decode(ipd.flg_laterality,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T122') ||
                                     pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY', ipd.flg_laterality, i_lang)),
                              decode(ipd.flg_laterality,
                                     ipd.flg_laterality_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T170') || l_update_tag_flash ||
                                     decode(ipd.flg_laterality,
                                            NULL,
                                            l_msg_del,
                                            pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY',
                                                                    ipd.flg_laterality,
                                                                    i_lang)) ||
                                     decode(ipd.flg_laterality_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T122') ||
                                            pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_LATERALITY',
                                                                    ipd.flg_laterality_new,
                                                                    i_lang)))) laterality,
                       aa_code_messages('PROCEDURES_T082') instructions,
                       decode(cnt,
                              rn,
                              decode(ipd.flg_prty,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T091') ||
                                     pk_sysdomain.get_domain(i_lang,
                                                             i_prof,
                                                             'INTERV_PRESC_DET.FLG_PRTY',
                                                             ipd.flg_prty,
                                                             NULL)),
                              decode(ipd.flg_prty,
                                     ipd.flg_prty_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T171') || l_update_tag_flash ||
                                     decode(ipd.flg_prty,
                                            NULL,
                                            l_msg_del,
                                            pk_sysdomain.get_domain(i_lang,
                                                                    i_prof,
                                                                    'INTERV_PRESC_DET.FLG_PRTY',
                                                                    ipd.flg_prty,
                                                                    NULL)) ||
                                     decode(ipd.flg_prty_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T091') ||
                                            pk_sysdomain.get_domain(i_lang,
                                                                    i_prof,
                                                                    'INTERV_PRESC_DET.FLG_PRTY',
                                                                    ipd.flg_prty_new,
                                                                    NULL)))) priority,
                       decode(cnt,
                               rn,
                               decode(ipd.flg_referral,
                                      NULL,
                                      aa_code_messages('PROCEDURES_T011') ||
                                      decode(ipd.flg_status,
                                             pk_procedures_constant.g_interv_sos,
                                             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS',
                                                                     pk_procedures_constant.g_interv_req,
                                                                     i_lang),
                                             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS', ipd.flg_status, i_lang)),
                                      aa_code_messages('PROCEDURES_T011') ||
                                      pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL', ipd.flg_referral, i_lang)),
                               decode(ipd.flg_referral,
                                      ipd.flg_referral_new,
                                      decode(ipd.flg_status,
                                             ipd.flg_status_new,
                                             NULL,
                                             CASE
                                                 WHEN (ipd.flg_status = pk_procedures_constant.g_interv_sos AND
                                                      ipd.flg_status_new = pk_procedures_constant.g_interv_req)
                                                      OR (ipd.flg_status = pk_procedures_constant.g_interv_req AND
                                                      ipd.flg_status_new = pk_procedures_constant.g_interv_sos) THEN
                                                  NULL
                                                 ELSE
                                                  aa_code_messages('PROCEDURES_T172') || l_update_tag_flash ||
                                                  decode(ipd.flg_status,
                                                         pk_procedures_constant.g_interv_sos,
                                                         pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS',
                                                                                 pk_procedures_constant.g_interv_req,
                                                                                 i_lang),
                                                         pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS', ipd.flg_status, i_lang)) ||
                                                  decode(ipd.flg_status_new,
                                                         NULL,
                                                         NULL,
                                                         l_formated_text || aa_code_messages('PROCEDURES_T011') ||
                                                         decode(ipd.flg_status_new,
                                                                pk_procedures_constant.g_interv_sos,
                                                                pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS',
                                                                                        pk_procedures_constant.g_interv_req,
                                                                                        i_lang),
                                                                pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_STATUS', ipd.flg_status_new, i_lang)))
                                             END),
                                      aa_code_messages('PROCEDURES_T172') || l_update_tag_flash ||
                                      decode(ipd.flg_referral,
                                             NULL,
                                             l_msg_del,
                                             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL',
                                                                     ipd.flg_referral,
                                                                     i_lang)) ||
                                      decode(ipd.flg_referral_new,
                                             NULL,
                                             NULL,
                                             l_formated_text || aa_code_messages('PROCEDURES_T011') ||
                                             pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_REFERRAL',
                                                                     ipd.flg_referral_new,
                                                                     i_lang)))) desc_status,
                       decode(cnt,
                              rn,
                              decode(pk_api_order_sets.get_order_set_title(i_lang,
                                                                           i_prof,
                                                                           ipd.id_interv_presc_det,
                                                                           pk_order_sets.g_odst_task_procedure),
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T143') ||
                                     pk_api_order_sets.get_order_set_title(i_lang,
                                                                           i_prof,
                                                                           ipd.id_interv_presc_det,
                                                                           pk_order_sets.g_odst_task_procedure)),
                              NULL) title_order_set,
                       NULL task_depend,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T023') ||
                              pk_sysdomain.get_domain(i_lang, i_prof, 'INTERV_PRESCRIPTION.FLG_TIME', ipd.flg_time, NULL) ||
                              decode(ipd.dt_begin_tstz,
                                     NULL,
                                     NULL,
                                     ' (' || pk_date_utils.date_char_tsz(i_lang,
                                                                         ipd.dt_begin_tstz,
                                                                         i_prof.institution,
                                                                         i_prof.software) || ')'),
                              decode(ipd.dt_begin_tstz,
                                     ipd.dt_begin_tstz_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T179') || l_update_tag_flash ||
                                     decode(ipd.dt_begin_tstz,
                                            NULL,
                                            l_msg_del,
                                            pk_sysdomain.get_domain(i_lang,
                                                                    i_prof,
                                                                    'INTERV_PRESCRIPTION.FLG_TIME',
                                                                    ipd.flg_time,
                                                                    NULL) || ' (' ||
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipd.dt_begin_tstz,
                                                                        i_prof.institution,
                                                                        i_prof.software) || ')') ||
                                     decode(ipd.dt_begin_tstz_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T023') ||
                                            pk_sysdomain.get_domain(i_lang,
                                                                    i_prof,
                                                                    'INTERV_PRESCRIPTION.FLG_TIME',
                                                                    ipd.flg_time,
                                                                    NULL) || ' (' ||
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipd.dt_begin_tstz_new,
                                                                        i_prof.institution,
                                                                        i_prof.software) || ')'))) desc_time,
                       NULL desc_time_limit,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T025') ||
                              decode(ipd.id_order_recurrence,
                                     NULL,
                                     pk_message.get_message(i_lang, i_prof, 'ORDER_RECURRENCE_M004'),
                                     pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang,
                                                                                           i_prof,
                                                                                           ipd.id_order_recurrence)),
                              decode(ipd.id_order_recurrence,
                                     ipd.id_order_recurrence_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T173') || l_update_tag_flash ||
                                     decode(ipd.id_order_recurrence,
                                            NULL,
                                            pk_message.get_message(i_lang, i_prof, 'ORDER_RECURRENCE_M004'),
                                            pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang,
                                                                                                  i_prof,
                                                                                                  ipd.id_order_recurrence)) ||
                                     l_formated_text || aa_code_messages('PROCEDURES_T025') ||
                                     decode(ipd.id_order_recurrence_new,
                                            NULL,
                                            pk_message.get_message(i_lang, i_prof, 'ORDER_RECURRENCE_M004'),
                                            pk_order_recurrence_api_db.get_order_recurr_plan_desc(i_lang,
                                                                                                  i_prof,
                                                                                                  ipd.id_order_recurrence_new)))) order_recurrence,
                       decode(cnt,
                              rn,
                              decode(ipd.flg_prn,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T130') ||
                                     pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang)),
                              decode(ipd.flg_prn,
                                     ipd.flg_prn_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T174') || l_update_tag_flash ||
                                     decode(ipd.flg_prn,
                                            NULL,
                                            l_msg_del,
                                            pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn, i_lang)) ||
                                     decode(ipd.flg_prn_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T130') ||
                                            pk_sysdomain.get_domain('INTERV_PRESC_DET.FLG_PRN', ipd.flg_prn_new, i_lang)))) prn,
                       decode(cnt,
                              rn,
                              decode(ipd.notes_prn,
                                     NULL,
                                     to_clob(''),
                                     aa_code_messages('PROCEDURES_T131') || ipd.notes_prn),
                              decode(ipd.notes_prn,
                                     ipd.notes_prn_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T175') || l_update_tag_flash ||
                                     decode(ipd.notes_prn, NULL, l_msg_del, ipd.notes_prn) ||
                                     decode(ipd.notes_prn_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T131') || ipd.notes_prn_new))) notes_prn,
                       aa_code_messages('PROCEDURES_T139') execution,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T144') ||
                              decode(ipd.id_exec_institution,
                                     NULL,
                                     NULL,
                                     decode(ipd.flg_location_new,
                                            pk_procedures_constant.g_flg_location_hhc,
                                            pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                                            decode(ipd.id_exec_institution,
                                                   i_prof.institution,
                                                   pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                                                   pk_translation.get_translation(i_lang,
                                                                                  'AB_INSTITUTION.CODE_INSTITUTION.' ||
                                                                                  ipd.id_exec_institution)))),
                              decode(ipd.id_exec_institution,
                                     ipd.id_exec_institution_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T180') || l_update_tag_flash ||
                                     decode(ipd.id_exec_institution,
                                            NULL,
                                            l_msg_del,
                                            decode(ipd.flg_location_new,
                                                   pk_procedures_constant.g_flg_location_hhc,
                                                   pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                                                   decode(ipd.id_exec_institution,
                                                          i_prof.institution,
                                                          pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                                                          pk_translation.get_translation(i_lang,
                                                                                         'AB_INSTITUTION.CODE_INSTITUTION.' ||
                                                                                         ipd.id_exec_institution)))) ||
                                     decode(ipd.id_exec_institution_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T144') ||
                                            decode(ipd.flg_location_new,
                                                   pk_procedures_constant.g_flg_location_hhc,
                                                   pk_message.get_message(i_lang, 'PROCEDURES_T191'),
                                                   decode(ipd.id_exec_institution_new,
                                                          i_prof.institution,
                                                          pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T078'),
                                                          pk_translation.get_translation(i_lang,
                                                                                         'AB_INSTITUTION.CODE_INSTITUTION.' ||
                                                                                         ipd.id_exec_institution_new)))))) perform_location,
                       decode(ipd.dt_ordered_by,
                              NULL,
                              decode(cnt,
                                     rn,
                                     decode(ipd.dt_order_tstz,
                                            NULL,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T010') ||
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipd.dt_order_tstz,
                                                                        i_prof.institution,
                                                                        i_prof.software)),
                                     decode(ipd.dt_order_tstz,
                                            ipd.dt_order_tstz_new,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T177') || l_update_tag_flash ||
                                            decode(ipd.dt_order_tstz,
                                                   NULL,
                                                   l_msg_del,
                                                   pk_date_utils.date_char_tsz(i_lang,
                                                                               ipd.dt_order_tstz,
                                                                               i_prof.institution,
                                                                               i_prof.software)) ||
                                            decode(ipd.dt_order_tstz_new,
                                                   NULL,
                                                   NULL,
                                                   l_formated_text || aa_code_messages('PROCEDURES_T010') ||
                                                   pk_date_utils.date_char_tsz(i_lang,
                                                                               ipd.dt_order_tstz_new,
                                                                               i_prof.institution,
                                                                               i_prof.software))))) dt_req,
                       decode(cnt,
                              rn,
                              decode(ipd.supplies_list,
                                     NULL,
                                     decode(pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                             i_prof,
                                                                                             ipd.id_interv_presc_det,
                                                                                             pk_supplies_constant.g_context_procedure_req),
                                            NULL,
                                            NULL,
                                            aa_code_messages('SUPPLIES_T076') ||
                                            pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                             i_prof,
                                                                                             ipd.id_interv_presc_det,
                                                                                             pk_supplies_constant.g_context_procedure_req)),
                                     aa_code_messages('SUPPLIES_T076') || ipd.supplies_list),
                              decode(ipd.supplies_list,
                                     ipd.supplies_list_new,
                                     NULL,
                                     aa_code_messages('SUPPLIES_T137') || l_update_tag_flash ||
                                     decode(ipd.supplies_list, NULL, l_msg_del, ipd.supplies_list) ||
                                     decode(ipd.supplies_list_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('SUPPLIES_T076') || ipd.supplies_list_new))) desc_supplies,
                       decode(cnt,
                              rn,
                              decode(l_result, NULL, NULL, aa_code_messages('PROCEDURES_T092') || l_result),
                              NULL) lab_result,
                       decode(cnt,
                              rn,
                              decode(l_weight, NULL, NULL, aa_code_messages('PROCEDURES_T090') || l_weight),
                              NULL) weight,
                       decode(pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason),
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T123') ||
                              pk_not_order_reason_db.get_not_order_reason_desc(i_lang, ipd.id_not_order_reason)) not_order_reason,
                       decode(cnt,
                              rn,
                              decode(ipd.notes, NULL, NULL, aa_code_messages('PROCEDURES_T100') || ipd.notes),
                              decode(ipd.notes,
                                     ipd.notes_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T116') || l_update_tag_flash ||
                                     decode(ipd.notes, NULL, l_msg_del, ipd.notes) ||
                                     decode(ipd.notes_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T100') || ipd.notes_new))) notes,
                       aa_code_messages('PROCEDURES_T138') co_sign,
                       decode(cnt,
                              rn,
                              decode(ipd.prof_ordered_by,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T077') || ipd.prof_ordered_by),
                              decode(ipd.prof_ordered_by,
                                     ipd.prof_ordered_by_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T176') || l_update_tag_flash ||
                                     decode(ipd.prof_ordered_by, NULL, l_msg_del, ipd.prof_ordered_by) ||
                                     decode(ipd.prof_ordered_by_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T077') ||
                                            ipd.prof_ordered_by_new))) prof_order,
                       decode(cnt,
                              rn,
                              decode(ipd.dt_ordered_by,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T010') ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipd.dt_ordered_by,
                                                                 i_prof.institution,
                                                                 i_prof.software)),
                              decode(ipd.dt_ordered_by,
                                     ipd.dt_ordered_by_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T177') || l_update_tag_flash ||
                                     decode(ipd.dt_ordered_by,
                                            NULL,
                                            l_msg_del,
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipd.dt_ordered_by,
                                                                        i_prof.institution,
                                                                        i_prof.software)) ||
                                     decode(ipd.dt_ordered_by_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T010') ||
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipd.dt_ordered_by_new,
                                                                        i_prof.institution,
                                                                        i_prof.software)))) dt_order,
                       decode(cnt,
                              rn,
                              decode(ipd.id_order_type,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T038') || ipd.desc_order_type),
                              decode(ipd.id_order_type,
                                     ipd.id_order_type_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T178') || l_update_tag_flash ||
                                     decode(ipd.id_order_type, NULL, l_msg_del, ipd.desc_order_type) ||
                                     decode(ipd.id_order_type_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T038') ||
                                            ipd.desc_order_type_new))) order_type,
                       aa_code_messages('PROCEDURES_T133') health_insurance,
                       decode(l_health_insurance,
                              pk_procedures_constant.g_no,
                              NULL,
                              decode(cnt,
                                     rn,
                                     decode(ipd.id_pat_health_plan,
                                            NULL,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T134') ||
                                            pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'F')),
                                     decode(ipd.id_pat_health_plan,
                                            ipd.id_pat_health_plan_new,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T181') || l_update_tag_flash ||
                                            decode(ipd.id_pat_health_plan,
                                                   NULL,
                                                   l_msg_del,
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan,
                                                                                   'F')) ||
                                            decode(ipd.id_pat_health_plan_new,
                                                   NULL,
                                                   NULL,
                                                   l_formated_text || aa_code_messages('PROCEDURES_T134') ||
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan_new,
                                                                                   'F'))))) financial_entity,
                       decode(l_health_insurance,
                              pk_procedures_constant.g_no,
                              NULL,
                              decode(cnt,
                                     rn,
                                     decode(ipd.id_pat_health_plan,
                                            NULL,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T135') ||
                                            pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'H')),
                                     decode(ipd.id_pat_health_plan,
                                            ipd.id_pat_health_plan_new,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T182') || l_update_tag_flash ||
                                            decode(ipd.id_pat_health_plan,
                                                   NULL,
                                                   l_msg_del,
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan,
                                                                                   'H')) ||
                                            decode(ipd.id_pat_health_plan_new,
                                                   NULL,
                                                   NULL,
                                                   l_formated_text || aa_code_messages('PROCEDURES_T135') ||
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan_new,
                                                                                   'H'))))) health_plan,
                       decode(l_health_insurance,
                              pk_procedures_constant.g_no,
                              NULL,
                              decode(cnt,
                                     rn,
                                     decode(ipd.id_pat_health_plan,
                                            NULL,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T136') ||
                                            pk_adt.get_pat_health_plan_info(i_lang, i_prof, ipd.id_pat_health_plan, 'N')),
                                     decode(ipd.id_pat_health_plan,
                                            ipd.id_pat_health_plan_new,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T183') || l_update_tag_flash ||
                                            decode(ipd.id_pat_health_plan,
                                                   NULL,
                                                   l_msg_del,
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan,
                                                                                   'N')) ||
                                            decode(ipd.id_pat_health_plan_new,
                                                   NULL,
                                                   NULL,
                                                   l_formated_text || aa_code_messages('PROCEDURES_T136') ||
                                                   pk_adt.get_pat_health_plan_info(i_lang,
                                                                                   i_prof,
                                                                                   ipd.id_pat_health_plan_new,
                                                                                   'N'))))) insurance_number,
                       decode(l_health_insurance,
                              pk_procedures_constant.g_no,
                              NULL,
                              decode(cnt,
                                     rn,
                                     decode(ipd.id_pat_exemption,
                                            NULL,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T137') ||
                                            pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption)),
                                     decode(ipd.id_pat_exemption,
                                            ipd.id_pat_exemption_new,
                                            NULL,
                                            aa_code_messages('PROCEDURES_T184') || l_update_tag_flash ||
                                            decode(ipd.id_pat_exemption,
                                                   NULL,
                                                   l_msg_del,
                                                   pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption)) ||
                                            decode(ipd.id_pat_exemption_new,
                                                   NULL,
                                                   NULL,
                                                   l_formated_text || aa_code_messages('PROCEDURES_T137') ||
                                                   pk_adt.get_pat_exemption_detail(i_lang, i_prof, ipd.id_pat_exemption_new))))) exemption,
                       decode(ipd.flg_status,
                              pk_procedures_constant.g_interv_expired,
                              aa_code_messages('PROCEDURES_T089'),
                              pk_procedures_constant.g_interv_interrupted,
                              aa_code_messages('PROCEDURES_T185'),
                              aa_code_messages('PROCEDURES_T164')) cancellation,
                       decode(cnt,
                              rn,
                              NULL,
                              decode(ipd.id_cancel_reason,
                                     NULL,
                                     NULL,
                                     decode(ipd.flg_status,
                                            pk_procedures_constant.g_interv_interrupted,
                                            aa_code_messages('PROCEDURES_T186'),
                                            aa_code_messages('PROCEDURES_T029')) || l_update_tag_flash ||
                                     pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ipd.id_cancel_reason))) cancel_reason,
                       decode(cnt,
                              rn,
                              NULL,
                              decode(ipd.notes_cancel,
                                     NULL,
                                     NULL,
                                     decode(ipd.flg_status,
                                            pk_procedures_constant.g_interv_expired,
                                            aa_code_messages('PROCEDURES_T100'),
                                            pk_procedures_constant.g_interv_interrupted,
                                            aa_code_messages('PROCEDURES_T187'),
                                            aa_code_messages('PROCEDURES_T024')) || l_update_tag_flash || ipd.notes_cancel)) cancel_notes,
                       decode(cnt,
                              rn,
                              NULL,
                              decode(ipd.prof_ordered_by_cancel,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T036') || l_update_tag_flash ||
                                     ipd.prof_ordered_by_cancel)) cancel_prof_order,
                       decode(cnt,
                              rn,
                              NULL,
                              decode(ipd.dt_ordered_cancel,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T010') || l_update_tag_flash ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipd.dt_ordered_cancel,
                                                                 i_prof.institution,
                                                                 i_prof.software))) cancel_dt_order,
                       decode(cnt,
                              rn,
                              NULL,
                              decode(ipd.id_order_type_cancel,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T038') || l_update_tag_flash ||
                                     ipd.desc_order_type_cancel)) cancel_order_type,
                       ipd.dt_last_update,
                       NULL dt_ord
                  FROM (SELECT row_number() over(ORDER BY t.dt_interv_prescription_hist DESC NULLS FIRST) rn,
                               MAX(rownum) over() cnt,
                               t.dt_interv_prescription_hist,
                               t.id_interv_presc_det,
                               first_value(t.id_interv_presc_det) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_interv_presc_det_new,
                               t.id_interv_prescription,
                               first_value(t.id_interv_prescription) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_interv_prescription_new,
                               t.id_intervention,
                               first_value(t.id_intervention) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_intervention_new,
                               t.id_episode,
                               t.flg_time,
                               t.flg_status,
                               first_value(t.flg_status) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_status_new,
                               t.notes,
                               first_value(t.notes) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_new,
                               t.id_prof_cancel,
                               t.dt_last_update dt_last_update,
                               first_value(t.id_prof_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_cancel_new,
                               t.notes_cancel,
                               first_value(t.notes_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_cancel_new,
                               t.num_take,
                               first_value(t.num_take) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) num_take_new,
                               t.id_nurse_actv_req_det,
                               first_value(t.id_nurse_actv_req_det) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_nurse_actv_req_det_new,
                               t.flg_prty,
                               first_value(t.flg_prty) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_prty_new,
                               t.dt_end_tstz,
                               first_value(t.dt_end_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_end_tstz_new,
                               t.dt_begin_tstz,
                               first_value(t.dt_begin_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_begin_tstz_new,
                               t.dt_cancel_tstz,
                               first_value(t.dt_cancel_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_cancel_tstz_new,
                               t.dt_interv_presc_det,
                               first_value(t.dt_interv_presc_det) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_interv_presc_det_new,
                               t.dt_pend_req_tstz,
                               first_value(t.dt_pend_req_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_pend_req_tstz_new,
                               t.flg_referral,
                               first_value(t.flg_referral) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_referral_new,
                               t.id_interv_codification,
                               first_value(t.id_interv_codification) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_interv_codification_new,
                               t.id_exec_institution,
                               first_value(t.id_exec_institution) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_exec_institution_new,
                               t.flg_location,
                               first_value(t.flg_location) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_location_new,
                               t.id_cancel_reason,
                               first_value(t.id_cancel_reason) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cancel_reason_new,
                               t.id_cdr_event,
                               first_value(t.id_cdr_event) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cdr_event_new,
                               t.flg_laterality,
                               first_value(t.flg_laterality) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_laterality_new,
                               t.id_clinical_purpose,
                               first_value(t.id_clinical_purpose) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_clinical_purpose_new,
                               t.clinical_purpose_notes,
                               first_value(t.clinical_purpose_notes) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) clinical_purpose_notes_new,
                               t.id_not_order_reason,
                               first_value(t.id_not_order_reason) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_not_order_reason_new,
                               t.id_presc_plan_task,
                               first_value(t.id_presc_plan_task) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_presc_plan_task_new,
                               t.id_co_sign_order,
                               first_value(t.id_co_sign_order) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_co_sign_order_new,
                               t.id_co_sign_cancel,
                               first_value(t.id_co_sign_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_co_sign_cancel_new,
                               t.id_prof_last_update,
                               first_value(t.id_prof_last_update) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_last_update_new,
                               t.dt_last_update_tstz,
                               first_value(t.dt_last_update_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_last_update_tstz_new,
                               t.id_order_recurrence,
                               first_value(t.id_order_recurrence) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_order_recurrence_new,
                               t.flg_fasting,
                               first_value(t.flg_fasting) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_fasting_new,
                               t.flg_prn,
                               first_value(t.flg_prn) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_prn_new,
                               dbms_lob.substr(t.prn_notes, 3800) notes_prn,
                               first_value(dbms_lob.substr(t.prn_notes, 3800)) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_prn_new,
                               t.id_pat_health_plan,
                               first_value(t.id_pat_health_plan) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_pat_health_plan_new,
                               t.id_pat_exemption,
                               first_value(t.id_pat_exemption) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_pat_exemption_new,
                               t.flg_req_origin_module,
                               first_value(t.flg_req_origin_module) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_req_origin_module_new,
                               t.dt_order_tstz,
                               first_value(t.dt_order_tstz) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_order_tstz_new,
                               t.id_diagnosis_list,
                               first_value(t.id_diagnosis_list) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_diagnosis_list_new,
                               t.diagnosis_notes,
                               first_value(t.diagnosis_notes) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) diagnosis_notes_new,
                               t.supplies_list,
                               first_value(t.supplies_list) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) supplies_list_new,
                               t.id_prof_ordered_by,
                               first_value(t.id_prof_ordered_by) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_ordered_by_new,
                               t.prof_ordered_by,
                               first_value(t.prof_ordered_by) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) prof_ordered_by_new,
                               t.dt_ordered_by,
                               first_value(t.dt_ordered_by) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_ordered_by_new,
                               t.id_order_type,
                               first_value(t.id_order_type) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_order_type_new,
                               t.desc_order_type,
                               first_value(t.desc_order_type) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_order_type_new,
                               t.id_prof_ordered_by_cancel,
                               first_value(t.id_prof_ordered_by_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_ordered_by_cancel_new,
                               t.prof_ordered_by_cancel,
                               first_value(t.prof_ordered_by_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) prof_ordered_by_cancel_new,
                               t.dt_ordered_cancel,
                               first_value(t.dt_ordered_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_ordered_cancel_new,
                               t.id_order_type_cancel,
                               first_value(t.id_order_type_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_order_type_cancel_new,
                               t.desc_order_type_cancel,
                               first_value(t.desc_order_type_cancel) over(ORDER BY dt_interv_prescription_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_order_type_cancel_new
                          FROM (SELECT /*+ opt_estimate(table cso rows=1) opt_estimate(table csc rows=2) */
                                 NULL dt_interv_prescription_hist,
                                 ipd.id_interv_presc_det,
                                 ipd.id_interv_prescription,
                                 ipd.id_intervention,
                                 ip.id_episode,
                                 ip.flg_time,
                                 ipd.flg_status,
                                 ipd.notes,
                                 ipd.id_prof_cancel,
                                 ipd.notes_cancel,
                                 ipd.num_take,
                                 ipd.id_nurse_actv_req_det,
                                 ipd.flg_prty,
                                 ipd.dt_end_tstz,
                                 ipd.dt_begin_tstz,
                                 ipd.dt_cancel_tstz,
                                 ipd.dt_interv_presc_det,
                                 pk_date_utils.date_send_tsz(i_lang, ipd.dt_last_update_tstz, i_prof) dt_last_update,
                                 ipd.dt_pend_req_tstz,
                                 ipd.flg_referral,
                                 ipd.id_interv_codification,
                                 ipd.id_exec_institution,
                                 ipd.flg_location,
                                 ipd.id_cancel_reason,
                                 ipd.id_cdr_event,
                                 ipd.flg_laterality,
                                 ipd.id_clinical_purpose,
                                 ipd.clinical_purpose_notes,
                                 ipd.id_not_order_reason,
                                 ipd.id_presc_plan_task,
                                 ipd.id_co_sign_order,
                                 ipd.id_co_sign_cancel,
                                 ipd.id_prof_last_update,
                                 ipd.dt_last_update_tstz,
                                 ipd.id_order_recurrence,
                                 ipd.flg_fasting,
                                 ipd.flg_prn,
                                 ipd.prn_notes,
                                 ipd.id_pat_health_plan,
                                 ipd.id_pat_exemption,
                                 ipd.flg_req_origin_module,
                                 ipd.dt_order_tstz,
                                 pk_utils.concat_table(CAST(MULTISET
                                                            (SELECT mrd.id_mcdt_req_diagnosis
                                                               FROM mcdt_req_diagnosis mrd
                                                              WHERE mrd.id_interv_presc_det = ipd.id_interv_presc_det
                                                                AND nvl(mrd.flg_status, '@') !=
                                                                    pk_alert_constant.g_cancelled) AS table_number),
                                                       ';') id_diagnosis_list,
                                 ipd.diagnosis_notes,
                                 pk_procedures_utils.get_procedure_supplies(i_lang,
                                                                            i_prof,
                                                                            pk_utils.concat_table(CAST(MULTISET
                                                                                                       (SELECT sw.id_supply_workflow
                                                                                                          FROM supply_workflow sw
                                                                                                         WHERE sw.id_context =
                                                                                                               ipd.id_interv_presc_det
                                                                                                           AND sw.flg_context =
                                                                                                               pk_supplies_constant.g_context_procedure_req
                                                                                                           AND nvl(sw.flg_status,
                                                                                                                   '@') !=
                                                                                                               pk_supplies_constant.g_sww_updated) AS
                                                                                                       table_number),
                                                                                                  ';')) supplies_list,
                                 cso.id_prof_ordered_by,
                                 cso.desc_prof_ordered_by prof_ordered_by,
                                 cso.dt_ordered_by,
                                 cso.id_order_type,
                                 cso.desc_order_type,
                                 csc.id_prof_ordered_by id_prof_ordered_by_cancel,
                                 csc.desc_prof_ordered_by prof_ordered_by_cancel,
                                 csc.dt_ordered_by dt_ordered_cancel,
                                 csc.id_order_type id_order_type_cancel,
                                 csc.desc_order_type desc_order_type_cancel
                                  FROM interv_presc_det ipd, interv_prescription ip, cso_table cso, cso_table csc
                                 WHERE ipd.id_interv_presc_det = i_interv_presc_det
                                   AND ipd.id_interv_prescription = ip.id_interv_prescription
                                   AND ipd.id_co_sign_order = cso.id_co_sign_hist(+)
                                   AND ipd.id_co_sign_cancel = csc.id_co_sign_hist(+)
                                UNION ALL
                                SELECT /*+ opt_estimate(table cso rows=1) opt_estimate(table csc rows=2) */
                                 ipdh.dt_interv_prescription_hist,
                                 ipdh.id_interv_presc_det,
                                 ipdh.id_interv_prescription,
                                 ipdh.id_intervention,
                                 ip.id_episode,
                                 ip.flg_time,
                                 ipdh.flg_status,
                                 ipdh.notes,
                                 ipdh.id_prof_cancel,
                                 ipdh.notes_cancel,
                                 ipdh.num_take,
                                 ipdh.id_nurse_actv_req_det,
                                 ipdh.flg_prty,
                                 ipdh.dt_end_tstz,
                                 ipdh.dt_begin_tstz,
                                 ipdh.dt_cancel_tstz,
                                 ipdh.dt_interv_presc_det,
                                 pk_date_utils.date_send_tsz(i_lang, ipdh.dt_last_update_tstz, i_prof) dt_last_update,
                                 ipdh.dt_pend_req_tstz,
                                 ipdh.flg_referral,
                                 ipdh.id_interv_codification,
                                 ipdh.id_exec_institution,
                                 ipdh.flg_location,
                                 ipdh.id_cancel_reason,
                                 ipdh.id_cdr_event,
                                 ipdh.flg_laterality,
                                 ipdh.id_clinical_purpose,
                                 ipdh.clinical_purpose_notes,
                                 ipdh.id_not_order_reason,
                                 ipdh.id_presc_plan_task,
                                 ipdh.id_co_sign_order,
                                 ipdh.id_co_sign_cancel,
                                 ipdh.id_prof_last_update,
                                 ipdh.dt_last_update_tstz,
                                 ipdh.id_order_recurrence,
                                 ipdh.flg_fasting,
                                 ipdh.flg_prn,
                                 ipdh.prn_notes,
                                 ipdh.id_pat_health_plan,
                                 ipdh.id_pat_exemption,
                                 ipdh.flg_req_origin_module,
                                 ipdh.dt_order_tstz,
                                 ipdh.id_diagnosis_list,
                                 ipdh.diagnosis_notes,
                                 pk_procedures_utils.get_procedure_supplies(i_lang, i_prof, ipdh.id_supplies_list) supplies_list,
                                 cso.id_prof_ordered_by,
                                 cso.desc_prof_ordered_by prof_ordered_by,
                                 cso.dt_ordered_by,
                                 cso.id_order_type,
                                 cso.desc_order_type,
                                 csc.id_prof_ordered_by id_prof_ordered_by_cancel,
                                 csc.desc_prof_ordered_by prof_ordered_by_cancel,
                                 csc.dt_ordered_by dt_ordered_cancel,
                                 csc.id_order_type id_order_type_cancel,
                                 csc.desc_order_type desc_order_type_cancel
                                  FROM interv_presc_det_hist ipdh, interv_prescription ip, cso_table cso, cso_table csc
                                 WHERE ipdh.id_interv_presc_det = i_interv_presc_det
                                   AND ipdh.id_interv_prescription = ip.id_interv_prescription
                                   AND ipdh.id_co_sign_order = cso.id_co_sign_hist(+)
                                   AND ipdh.id_co_sign_cancel = csc.id_co_sign_hist(+)
                                   AND ipdh.flg_status != pk_procedures_constant.g_interv_draft
                                 ORDER BY dt_interv_prescription_hist DESC NULLS FIRST) t
                         ORDER BY rn) ipd);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_detail();
    END tf_get_procedure_order_history;

    FUNCTION tf_get_procedure_co_sign
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_co_sign IS
    
        l_ret t_tbl_procedures_co_sign := t_tbl_procedures_co_sign();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedure_co_sign(id_interv_presc_det => t.id_interv_presc_det,
                                   registry            => t.registry,
                                   flg_status          => t.flg_status,
                                   co_sign_notes       => t.co_sign_notes,
                                   rn                  => t.rn)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT i_interv_presc_det id_interv_presc_det,
                       l_msg_reg || ' ' || pk_prof_utils.get_name_signature(i_lang, i_prof, cs.id_prof_co_signed) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang,
                                                               i_prof,
                                                               cs.id_prof_co_signed,
                                                               cs.dt_co_signed,
                                                               cs.id_episode),
                              NULL,
                              '; ',
                              ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                       i_prof,
                                                                       cs.id_prof_co_signed,
                                                                       cs.dt_co_signed,
                                                                       cs.id_episode) || '); ') ||
                       pk_date_utils.date_char_tsz(i_lang, cs.dt_co_signed, i_prof.institution, i_prof.software) registry,
                       decode(pk_co_sign.get_id_action(pk_co_sign_api.g_cosign_action_def_add, NULL),
                              cs.id_action,
                              pk_procedures_constant.g_interv_req,
                              pk_procedures_constant.g_interv_cancel) flg_status,
                       decode(dbms_lob.getlength(cs.co_sign_notes),
                              NULL,
                              to_clob(''),
                              0,
                              to_clob(''),
                              aa_code_messages('PROCEDURES_T100') || cs.co_sign_notes) co_sign_notes,
                       row_number() over(PARTITION BY cs.id_action ORDER BY cs.dt_created DESC NULLS FIRST) rn
                  FROM TABLE(pk_co_sign_api.tf_co_sign_task_hist_info(i_lang,
                                                                      i_prof,
                                                                      i_episode,
                                                                      NULL,
                                                                      NULL,
                                                                      NULL,
                                                                      i_interv_presc_det)) cs
                 WHERE cs.flg_status = pk_co_sign_api.g_cosign_flg_status_cs) t;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_co_sign();
    END tf_get_procedure_co_sign;

    FUNCTION tf_get_procedure_cq
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_cq IS
    
        l_ret t_tbl_procedures_cq := t_tbl_procedures_cq();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedures_cq(id_interv_presc_det, id_content, flg_time, desc_clinical_question, NULL, NULL, NULL)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT id_interv_presc_det,
                       id_content,
                       flg_time,
                       id_questionnaire,
                       decode(i_flg_report,
                              pk_procedures_constant.g_no,
                              decode(rownum, 1, aa_code_messages('PROCEDURES_T163') || chr(10), NULL) || '    ' ||
                              desc_clinical_question || desc_response,
                              desc_clinical_question || desc_response) desc_clinical_question
                  FROM (SELECT id_interv_presc_det,
                               id_content,
                               flg_time,
                               id_questionnaire,
                               desc_clinical_question,
                               desc_response
                          FROM (SELECT DISTINCT iqr1.id_interv_presc_det,
                                                iqr1.id_content,
                                                iqr1.flg_time,
                                                iqr1.id_questionnaire,
                                                '<b>' || pk_mcdt.get_questionnaire_alias(i_lang,
                                                                                         i_prof,
                                                                                         'QUESTIONNAIRE.CODE_QUESTIONNAIRE.' ||
                                                                                         iqr1.id_questionnaire) ||
                                                ':</b> ' desc_clinical_question,
                                                dbms_lob.substr(decode(dbms_lob.getlength(iqr.notes),
                                                                       NULL,
                                                                       to_clob(decode(iqr1.desc_response,
                                                                                      NULL,
                                                                                      '---',
                                                                                      iqr1.desc_response)),
                                                                       pk_procedures_utils.get_procedure_response(i_lang,
                                                                                                                  i_prof,
                                                                                                                  iqr.notes)),
                                                                3800) desc_response,
                                                pk_procedures_utils.get_procedure_question_rank(i_lang,
                                                                                                i_prof,
                                                                                                ipd.id_intervention,
                                                                                                iqr.id_questionnaire,
                                                                                                iqr.flg_time) rank
                                  FROM (SELECT iqr.id_interv_presc_det,
                                               iqr.id_questionnaire,
                                               listagg(pk_procedures_utils.get_questionnaire_id_content(i_lang,
                                                                                                        i_prof,
                                                                                                        iqr.id_questionnaire,
                                                                                                        iqr.id_response),
                                                       '; ') within GROUP(ORDER BY iqr.id_response) id_content,
                                               iqr.flg_time,
                                               listagg(pk_mcdt.get_response_alias(i_lang,
                                                                                  i_prof,
                                                                                  'RESPONSE.CODE_RESPONSE.' ||
                                                                                  iqr.id_response),
                                                       '; ') within GROUP(ORDER BY iqr.id_response) desc_response,
                                               iqr.dt_last_update_tstz,
                                               row_number() over(PARTITION BY iqr.id_questionnaire, iqr.flg_time ORDER BY iqr.dt_last_update_tstz DESC NULLS FIRST) rn
                                          FROM interv_question_response iqr
                                         WHERE iqr.id_interv_presc_det = i_interv_presc_det
                                         GROUP BY iqr.id_interv_presc_det,
                                                  iqr.id_questionnaire,
                                                  iqr.flg_time,
                                                  iqr.dt_last_update_tstz) iqr1,
                                       interv_question_response iqr,
                                       interv_presc_det ipd
                                 WHERE iqr1.rn = 1
                                   AND iqr1.id_interv_presc_det = iqr.id_interv_presc_det
                                   AND iqr1.id_questionnaire = iqr.id_questionnaire
                                   AND iqr1.dt_last_update_tstz = iqr.dt_last_update_tstz
                                   AND iqr1.flg_time = iqr.flg_time
                                   AND iqr.id_interv_presc_det = ipd.id_interv_presc_det)
                         ORDER BY flg_time, rank));
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_cq();
    END tf_get_procedure_cq;

    FUNCTION tf_get_procedure_cq_history
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_flg_html         IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_cq IS
    
        l_ret t_tbl_procedures_cq := t_tbl_procedures_cq();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        
            g_error := 'GET MESSAGES UPDATE';
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail_upd.first .. pk_procedures_constant.ga_code_messages_procedure_detail_upd.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) := CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '<span class="emphasizedRedDetail">'
                                                                                                         ELSE
                                                                                                          '<b>'
                                                                                                     END ||
                                                                                                     pk_message.get_message(i_lang,
                                                                                                                            i_prof,
                                                                                                                            pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) ||
                                                                                                     CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '</span> '
                                                                                                         ELSE
                                                                                                          '</b> '
                                                                                                     END;
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedures_cq(id_interv_presc_det,
                               id_content,
                               flg_time,
                               desc_clinical_question,
                               dt_last_update,
                               num_clinical_question,
                               rn)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT id_interv_presc_det,
                       id_content,
                       flg_time,
                       desc_clinical_question,
                       dt_last_update,
                       num_clinical_question,
                       rn
                  FROM (SELECT t.id_interv_presc_det,
                               t.id_content,
                               t.flg_time,
                               t.desc_clinical_question desc_clinical_question,
                               t.dt_last_update,
                               row_number() over(PARTITION BY t.id_interv_presc_det, t.current_rownum ORDER BY t.current_rownum DESC) + 1 num_clinical_question,
                               t.current_rownum rn,
                               rank
                          FROM (SELECT iqr.id_interv_presc_det,
                                       q.id_content,
                                       iqr.flg_time,
                                       CASE
                                            WHEN iqr.previous_rownum IS NULL THEN
                                             '<b>' || CASE i_flg_html
                                                 WHEN pk_alert_constant.g_yes THEN
                                                  '     '
                                                 ELSE
                                                  chr(9) || '  '
                                             END || pk_translation.get_translation(i_lang, q.code_questionnaire) || ':</b> ' || CASE
                                                 WHEN iqr.current_questionnaire IS NULL THEN
                                                  '---'
                                                 ELSE
                                                  to_char(iqr.current_questionnaire)
                                             END
                                            WHEN iqr.flg_new = pk_procedures_constant.g_yes THEN
                                             CASE i_flg_html
                                                 WHEN pk_alert_constant.g_no THEN
                                                  '<b>'
                                                 ELSE
                                                  '<span class="emphasizedRedDetail">'
                                             END || CASE i_flg_html
                                                 WHEN pk_alert_constant.g_yes THEN
                                                  '     '
                                                 ELSE
                                                  chr(9) || '  '
                                             END || pk_translation.get_translation(i_lang, q.code_questionnaire) || ' (' ||
                                             lower(pk_message.get_message(i_lang, i_prof, 'CODING_LABEL_UPDATED')) || '):' ||
                                             CASE i_flg_html
                                                 WHEN pk_alert_constant.g_no THEN
                                                  '</b>' || '§'
                                                 ELSE
                                                  '</span>'
                                             END || CASE
                                                 WHEN iqr.current_questionnaire IS NULL THEN
                                                  '---'
                                                 ELSE
                                                  to_char(iqr.current_questionnaire)
                                             END || chr(10) || '<b>' || CASE i_flg_html
                                                 WHEN pk_alert_constant.g_yes THEN
                                                  '     '
                                                 ELSE
                                                  chr(9) || '  '
                                             END || pk_translation.get_translation(i_lang, q.code_questionnaire) || ':</b> ' || CASE
                                                 WHEN iqr.previous_questionnaire IS NULL THEN
                                                  '---'
                                                 ELSE
                                                  to_char(iqr.previous_questionnaire)
                                             END
                                            ELSE --WHEN THE ANSWER HAS NOT BEEN CHANGED => SHOW NONTHELESS
                                             '<b>' || CASE i_flg_html
                                                 WHEN pk_alert_constant.g_yes THEN
                                                  '     '
                                                 ELSE
                                                  chr(9) || '  '
                                             END || pk_translation.get_translation(i_lang, q.code_questionnaire) || ':</b> ' || CASE
                                                 WHEN iqr.previous_questionnaire IS NULL THEN
                                                  '---'
                                                 ELSE
                                                  to_char(iqr.previous_questionnaire)
                                             END
                                        END desc_clinical_question,
                                       iqr.current_rownum current_rownum,
                                       iqr.id_questionnaire,
                                       iqr.dt_last_update,
                                       rank
                                  FROM (SELECT ird1.id_questionnaire id_questionnaire,
                                               ird1.id_interv_presc_det,
                                               pk_procedures_utils.get_procedure_response(i_lang, i_prof, ird1.notes) AS current_questionnaire,
                                               ird1.flg_time,
                                               ird1.dt_last_update_tstz,
                                               ird1.rn AS current_rownum,
                                               pk_procedures_utils.get_procedure_response(i_lang, i_prof, ird2.notes) AS previous_questionnaire,
                                               ird2.rn AS previous_rownum,
                                               ird1.dt_last_update AS dt_last_update,
                                               CASE
                                                    WHEN ird2.rn IS NULL THEN
                                                     pk_procedures_constant.g_yes
                                                    WHEN to_char(ird1.notes) IS NULL
                                                         AND to_char(ird2.notes) IS NULL THEN
                                                     pk_procedures_constant.g_no
                                                    WHEN to_char(ird1.notes) = to_char(ird2.notes) THEN
                                                     pk_procedures_constant.g_no
                                                    ELSE
                                                     pk_procedures_constant.g_yes
                                                END AS flg_new,
                                               pk_procedures_utils.get_procedure_question_rank(i_lang,
                                                                                               i_prof,
                                                                                               id_intervention,
                                                                                               ird1.id_questionnaire,
                                                                                               ird1.flg_time) rank
                                          FROM (SELECT id_questionnaire,
                                                       id_interv_presc_det,
                                                       notes,
                                                       flg_time,
                                                       dt_last_update_tstz,
                                                       row_number() over(PARTITION BY id_questionnaire ORDER BY id_questionnaire ASC, dt_last_update_tstz DESC) rn,
                                                       id_intervention,
                                                       dt_last_update
                                                  FROM (SELECT *
                                                          FROM (SELECT iqr.id_interv_question_response,
                                                                       iqr.id_interv_presc_det,
                                                                       iqr.id_questionnaire,
                                                                       iqr.dt_last_update_tstz,
                                                                       iqr.notes,
                                                                       iqr.flg_time,
                                                                       row_number() over(PARTITION BY iqr.id_questionnaire, iqr.dt_last_update_tstz ORDER BY iqr.id_interv_question_response) AS rn,
                                                                       ipd.id_intervention,
                                                                       pk_date_utils.date_send_tsz(i_lang,
                                                                                                   iqr.dt_last_update_tstz,
                                                                                                   i_prof) dt_last_update
                                                                  FROM interv_question_response iqr
                                                                  JOIN interv_presc_det ipd
                                                                    ON ipd.id_interv_presc_det = iqr.id_interv_presc_det
                                                                 WHERE iqr.id_interv_presc_det = i_interv_presc_det)
                                                         WHERE rn = 1)) ird1
                                          LEFT JOIN (SELECT id_questionnaire,
                                                           id_interv_presc_det,
                                                           notes,
                                                           dt_last_update_tstz,
                                                           row_number() over(PARTITION BY id_questionnaire ORDER BY id_questionnaire ASC, dt_last_update_tstz DESC) rn
                                                      FROM (SELECT *
                                                              FROM (SELECT iqr.id_interv_question_response,
                                                                           iqr.id_interv_presc_det,
                                                                           iqr.id_questionnaire,
                                                                           iqr.dt_last_update_tstz,
                                                                           iqr.notes,
                                                                           row_number() over(PARTITION BY iqr.id_questionnaire, iqr.dt_last_update_tstz ORDER BY iqr.id_interv_question_response) AS rn --Because of multichoice options
                                                                      FROM interv_question_response iqr
                                                                     WHERE iqr.id_interv_presc_det = i_interv_presc_det)
                                                             WHERE rn = 1)) ird2
                                            ON ird2.id_questionnaire = ird1.id_questionnaire
                                           AND ird2.id_interv_presc_det = ird1.id_interv_presc_det
                                           AND ird1.rn = (ird2.rn - 1)
                                         ORDER BY ird1.rn ASC, rank ASC) iqr
                                  JOIN questionnaire q
                                    ON q.id_questionnaire = iqr.id_questionnaire) t
                        UNION ALL
                        SELECT t.id_interv_presc_det,
                               NULL id_content,
                               t.flg_time,
                               '<b>' || pk_message.get_message(i_lang, i_prof, 'PROCEDURES_T163') || '</b> ' desc_clinical_question,
                               t.dt_last_update,
                               1 num_clinical_question, --First row of every set
                               row_number() over(PARTITION BY t.id_interv_presc_det ORDER BY t.id_interv_presc_det) rn,
                               0 rank
                          FROM (SELECT DISTINCT iqr.id_interv_presc_det,
                                                iqr.flg_time,
                                                iqr.dt_last_update_tstz,
                                                pk_date_utils.date_send_tsz(i_lang, iqr.dt_last_update_tstz, i_prof) dt_last_update
                                  FROM interv_question_response iqr
                                 WHERE iqr.id_interv_presc_det = i_interv_presc_det) t)
                 ORDER BY flg_time, rn, num_clinical_question ASC);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_cq();
    END tf_get_procedure_cq_history;

    FUNCTION tf_get_procedure_execution
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_execution IS
    
        l_ret t_tbl_procedures_execution := t_tbl_procedures_execution();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
    
        l_epis_documentation table_number := table_number();
        l_notes1             CLOB;
        l_notes2             CLOB;
    
        l_cur_interv_time_out_val pk_touch_option_out.t_cur_plain_text_entry;
        l_interv_time_out_val     pk_touch_option_out.t_rec_plain_text_entry;
        l_cur_interv_doc_val      pk_touch_option_out.t_cur_plain_text_entry;
        l_interv_doc_val          pk_touch_option_out.t_rec_plain_text_entry;
    
        l_count           NUMBER := 0;
        l_execution_notes t_tbl_execution_notes := t_tbl_execution_notes();
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        l_epis_documentation := NULL;
    
        SELECT ito.id_epis_documentation
          BULK COLLECT
          INTO l_epis_documentation
          FROM interv_time_out ito
         WHERE ito.id_interv_presc_det = i_interv_presc_det;
    
        FOR i IN 1 .. l_epis_documentation.count
        LOOP
            g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 1';
            pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                       i_prof                    => i_prof,
                                                       i_epis_documentation_list => table_number(l_epis_documentation(i)),
                                                       i_use_html_format         => pk_procedures_constant.g_yes,
                                                       o_entries                 => l_cur_interv_time_out_val);
        
            FETCH l_cur_interv_time_out_val
                INTO l_interv_time_out_val;
            CLOSE l_cur_interv_time_out_val;
        
            l_notes1 := REPLACE(l_interv_time_out_val.plain_text_entry, chr(10) || chr(10), chr(10));
        
            IF i_flg_report = pk_procedures_constant.g_no
            THEN
                l_notes1 := REPLACE(l_notes1, chr(10), chr(10) || chr(9));
            END IF;
        
            INSERT INTO tbl_temp
                (num_1, vc_1, vc_2)
            VALUES
                ((SELECT ito.id_interv_presc_plan
                   FROM interv_time_out ito
                  WHERE ito.id_epis_documentation = l_interv_time_out_val.id_epis_documentation),
                 l_notes1,
                 'ITO');
        END LOOP;
    
        l_execution_notes := NULL;
    
        SELECT COUNT(1)
          INTO l_count
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_det = i_interv_presc_det
           AND ipp.id_epis_documentation IS NOT NULL;
    
        IF l_count > 0
        THEN
        
            SELECT t_execution_notes(ipp.id_interv_presc_plan, ipp.id_epis_documentation, NULL)
              BULK COLLECT
              INTO l_execution_notes
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_det = i_interv_presc_det
               AND ipp.id_epis_documentation IS NOT NULL;
        
            FOR i IN l_execution_notes.first .. l_execution_notes.last
            LOOP
                g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 2';
                pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                           i_prof                    => i_prof,
                                                           i_epis_documentation_list => table_number(l_execution_notes(i).l_documentation),
                                                           i_use_html_format         => pk_procedures_constant.g_yes,
                                                           o_entries                 => l_cur_interv_doc_val);
            
                FETCH l_cur_interv_doc_val
                    INTO l_interv_doc_val;
                CLOSE l_cur_interv_doc_val;
            
                l_notes2 := REPLACE(l_interv_doc_val.plain_text_entry, chr(10));
                l_notes2 := REPLACE(l_notes2, chr(10), chr(10) || chr(9));
            
                l_execution_notes(i).l_notes := l_notes2;
            END LOOP;
        END IF;
    
        g_error := 'OPEN O_INTERV_EXECUTION';
        SELECT t_procedures_execution(id_interv_presc_plan,
                                      registry,
                                      desc_procedure,
                                      prof_perform,
                                      start_time,
                                      end_time,
                                      next_perform_date,
                                      desc_modifiers,
                                      desc_supplies,
                                      desc_time_out,
                                      desc_perform,
                                      cancel_reason,
                                      cancel_notes,
                                      dt_ord,
                                      NULL)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ipp.id_interv_presc_plan,
                       l_msg_reg || ' ' ||
                       pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ipp.id_prof_take, ipp.id_prof_cancel)) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang,
                                                               i_prof,
                                                               nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                               nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                               ipp.id_episode_write),
                              NULL,
                              '; ',
                              ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                       i_prof,
                                                                       nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                                       nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                                       ipp.id_episode_write) || '); ') ||
                       pk_date_utils.date_char_tsz(i_lang,
                                                   nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                   i_prof.institution,
                                                   i_prof.software) registry,
                       aa_code_messages('PROCEDURES_T096') ||
                       pk_procedures_utils.get_alias_translation(i_lang,
                                                                 i_prof,
                                                                 'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                                 NULL) desc_procedure,
                       decode(ipp.id_prof_performed,
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T151') ||
                              pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed)) prof_perform,
                       decode(ipp.start_time,
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T148') ||
                              pk_date_utils.date_char_tsz(i_lang, ipp.start_time, i_prof.institution, i_prof.software)) start_time,
                       decode(ipp.end_time,
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T149') ||
                              pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software)) end_time,
                       NULL next_perform_date,
                       decode(pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan),
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T153') ||
                              pk_procedures_utils.get_procedure_modifiers(i_lang, i_prof, ipp.id_interv_presc_plan)) desc_modifiers,
                       decode(pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                               i_prof,
                                                                               ipp.id_interv_presc_plan,
                                                                               pk_supplies_constant.g_context_procedure_exec),
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T152') ||
                              pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                               i_prof,
                                                                               ipp.id_interv_presc_plan,
                                                                               pk_supplies_constant.g_context_procedure_exec)) desc_supplies,
                       decode(dbms_lob.getlength(time_out_notes), NULL, to_clob(''), time_out_notes) desc_time_out,
                       decode(dbms_lob.getlength(t.l_notes),
                              NULL,
                              to_clob(''),
                              decode(instr(lower(decode(i_flg_report,
                                                        pk_procedures_constant.g_no,
                                                        REPLACE((REPLACE(t.l_notes, chr(10) || chr(10), chr(10))),
                                                                chr(10),
                                                                chr(10) || chr(9)),
                                                        REPLACE(t.l_notes, chr(10) || chr(10), chr(10)))),
                                           '<b>'),
                                     0,
                                     to_clob(aa_code_messages('PROCEDURES_T100') ||
                                             decode(i_flg_report,
                                                    pk_procedures_constant.g_no,
                                                    REPLACE((REPLACE(t.l_notes, chr(10) || chr(10), chr(10))),
                                                            chr(10),
                                                            chr(10) || chr(9)),
                                                    REPLACE(t.l_notes, chr(10) || chr(10), chr(10)))),
                                     decode(i_flg_report,
                                            pk_procedures_constant.g_no,
                                            REPLACE((REPLACE(t.l_notes, chr(10) || chr(10), chr(10))),
                                                    chr(10),
                                                    chr(10) || chr(9)),
                                            REPLACE(t.l_notes, chr(10) || chr(10), chr(10))))) desc_perform,
                       
                       decode(ipp.id_cancel_reason,
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T029') ||
                              pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ipp.id_cancel_reason)) cancel_reason,
                       decode(ipp.notes_cancel, NULL, NULL, aa_code_messages('PROCEDURES_T024') || ipp.notes_cancel) cancel_notes,
                       pk_date_utils.date_send_tsz(i_lang, ipp.dt_plan_tstz, i_prof) dt_ord
                  FROM interv_presc_det ipd,
                       interv_presc_plan ipp,
                       (SELECT tt.num_1 id_interv_presc_plan, tt.vc_1 time_out_notes
                          FROM tbl_temp tt
                         WHERE tt.vc_2 = 'ITO') ito,
                       (SELECT *
                          FROM (SELECT epd.id_epis_context,
                                       epd.notes,
                                       row_number() over(PARTITION BY epd.id_epis_context ORDER BY epd.dt_last_update_tstz DESC) rn
                                  FROM epis_documentation epd
                                 WHERE epd.id_episode = i_episode) epe
                         WHERE epe.rn = 1) ed,
                       TABLE(l_execution_notes) t
                 WHERE ipd.id_interv_presc_det = i_interv_presc_det
                   AND ipd.id_interv_presc_det = ipp.id_interv_presc_det
                   AND ipp.flg_status = pk_procedures_constant.g_interv_plan_executed
                   AND ipp.id_interv_presc_plan = ito.id_interv_presc_plan(+)
                   AND ipp.id_interv_presc_plan = ed.id_epis_context(+)
                   AND ipp.id_interv_presc_plan = t.l_presc_plan(+)
                 ORDER BY dt_ord ASC);
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_execution();
    END tf_get_procedure_execution;

    FUNCTION tf_get_procedure_execution_history
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_flg_html         IN VARCHAR2 DEFAULT pk_exam_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_execution IS
    
        l_ret t_tbl_procedures_execution := t_tbl_procedures_execution();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_update_tag_flash VARCHAR2(1 CHAR) := CASE i_flg_html
                                                   WHEN pk_alert_constant.g_yes THEN
                                                    NULL
                                                   ELSE
                                                    '§'
                                               END;
    
        l_formated_text VARCHAR2(100 CHAR) := CASE i_flg_html
                                                  WHEN pk_alert_constant.g_yes THEN
                                                   chr(10) || ' '
                                                  ELSE
                                                   chr(9) || chr(10)
                                              END;
    
        l_msg_reg            sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
        l_msg_not_applicable sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M018');
        l_msg_del            sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M106');
    
        l_cur_interv_doc_val pk_touch_option_out.t_cur_plain_text_entry;
        l_interv_doc_val     pk_touch_option_out.t_rec_plain_text_entry;
    
        l_notes1 CLOB;
    
        l_count           NUMBER := 0;
        l_execution_notes t_tbl_execution_notes := t_tbl_execution_notes();
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        
            g_error := 'GET MESSAGES UPDATE';
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail_upd.first .. pk_procedures_constant.ga_code_messages_procedure_detail_upd.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) := CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '<span class="emphasizedRedDetail">'
                                                                                                         ELSE
                                                                                                          '<b>'
                                                                                                     END ||
                                                                                                     pk_message.get_message(i_lang,
                                                                                                                            i_prof,
                                                                                                                            pk_procedures_constant.ga_code_messages_procedure_detail_upd(i)) ||
                                                                                                     CASE i_flg_html
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          '</span> '
                                                                                                         ELSE
                                                                                                          '</b> '
                                                                                                     END;
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        l_execution_notes := NULL;
    
        SELECT COUNT(1)
          INTO l_count
          FROM interv_presc_plan ipp
         WHERE ipp.id_interv_presc_det = i_interv_presc_det
           AND ipp.id_epis_documentation IS NOT NULL;
    
        IF l_count > 0
        THEN
        
            SELECT t_execution_notes(ipp.id_interv_presc_plan, ipp.id_epis_documentation, NULL)
              BULK COLLECT
              INTO l_execution_notes
              FROM interv_presc_plan ipp
             WHERE ipp.id_interv_presc_det = i_interv_presc_det
               AND ipp.id_epis_documentation IS NOT NULL;
        
            FOR i IN l_execution_notes.first .. l_execution_notes.last
            LOOP
                g_error := 'CALL PK_TOUCH_OPTION_OUT.GET_PLAIN_TEXT_ENTRIES 2';
                pk_touch_option_out.get_plain_text_entries(i_lang                    => i_lang,
                                                           i_prof                    => i_prof,
                                                           i_epis_documentation_list => table_number(l_execution_notes(i).l_documentation),
                                                           i_use_html_format         => pk_procedures_constant.g_yes,
                                                           o_entries                 => l_cur_interv_doc_val);
            
                FETCH l_cur_interv_doc_val
                    INTO l_interv_doc_val;
                CLOSE l_cur_interv_doc_val;
            
                l_notes1 := REPLACE(l_interv_doc_val.plain_text_entry, chr(10));
                l_notes1 := REPLACE(l_notes1, chr(10), chr(10) || chr(9));
            
                l_execution_notes(i).l_notes := l_notes1;
            END LOOP;
        END IF;
    
        g_error := 'OPEN O_INTERV_EXECUTION';
        SELECT t_procedures_execution(id_interv_presc_plan,
                                      registry,
                                      desc_procedure,
                                      prof_perform,
                                      start_time,
                                      end_time,
                                      next_perform_date,
                                      desc_modifiers,
                                      desc_supplies,
                                      desc_time_out,
                                      desc_perform,
                                      cancel_reason,
                                      cancel_notes,
                                      dt_ord,
                                      dt_last_update_tstz)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ipp.id_interv_presc_plan,
                       l_msg_reg || ' ' ||
                       pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ipp.id_prof_take, ipp.id_prof_cancel)) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang,
                                                               i_prof,
                                                               nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                               nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                               ipp.id_episode_write),
                              NULL,
                              '; ',
                              ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                       i_prof,
                                                                       nvl(ipp.id_prof_take, ipp.id_prof_cancel),
                                                                       nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                                       ipp.id_episode_write) || '); ') ||
                       pk_date_utils.date_char_tsz(i_lang,
                                                   nvl(ipp.dt_take_tstz, ipp.dt_cancel_tstz),
                                                   i_prof.institution,
                                                   i_prof.software) registry,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T096') ||
                              pk_procedures_utils.get_alias_translation(i_lang,
                                                                        i_prof,
                                                                        'INTERVENTION.CODE_INTERVENTION.' ||
                                                                        ipp.id_intervention,
                                                                        NULL),
                              NULL) desc_procedure,
                       decode(cnt,
                              rn,
                              decode(ipp.id_prof_performed,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T151') ||
                                     pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed)),
                              decode(ipp.id_prof_performed,
                                     ipp.id_prof_performed_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T114') || l_update_tag_flash ||
                                     pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed) ||
                                     l_formated_text || aa_code_messages('PROCEDURES_T151') ||
                                     pk_prof_utils.get_name_signature(i_lang, i_prof, ipp.id_prof_performed_new))) prof_perform,
                       decode(cnt,
                              rn,
                              decode(ipp.start_time,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T148') ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.start_time,
                                                                 i_prof.institution,
                                                                 i_prof.software)),
                              decode(ipp.start_time,
                                     ipp.start_time_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T111') || l_update_tag_flash ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.start_time,
                                                                 i_prof.institution,
                                                                 i_prof.software) || l_formated_text ||
                                     aa_code_messages('PROCEDURES_T148') ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.start_time_new,
                                                                 i_prof.institution,
                                                                 i_prof.software))) start_time,
                       decode(cnt,
                              rn,
                              decode(ipp.start_time,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T149') ||
                                     pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software)),
                              decode(ipp.end_time,
                                     ipp.end_time_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T112') || l_update_tag_flash ||
                                     pk_date_utils.date_char_tsz(i_lang, ipp.end_time, i_prof.institution, i_prof.software) ||
                                     l_formated_text || aa_code_messages('PROCEDURES_T149') ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.end_time_new,
                                                                 i_prof.institution,
                                                                 i_prof.software))) end_time,
                       decode(cnt,
                              rn,
                              aa_code_messages('PROCEDURES_T150') ||
                              decode(ipp.num_take,
                                     ipp.exec_number,
                                     l_msg_not_applicable,
                                     decode(ipp.flg_status,
                                            pk_procedures_constant.g_interv_sos,
                                            l_msg_not_applicable,
                                            pk_date_utils.date_char_tsz(i_lang,
                                                                        ipp.dt_plan_tstz,
                                                                        i_prof.institution,
                                                                        i_prof.software))),
                              decode(ipp.dt_plan_tstz,
                                     ipp.dt_plan_tstz_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T113') || l_update_tag_flash ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.dt_plan_tstz,
                                                                 i_prof.institution,
                                                                 i_prof.software) || l_formated_text ||
                                     aa_code_messages('PROCEDURES_T150') ||
                                     pk_date_utils.date_char_tsz(i_lang,
                                                                 ipp.dt_plan_tstz_new,
                                                                 i_prof.institution,
                                                                 i_prof.software))) next_perform_date,
                       decode(cnt,
                              rn,
                              decode(ipp.desc_modifiers,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T153') || ipp.desc_modifiers),
                              decode(ipp.desc_modifiers,
                                     ipp.desc_modifiers_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T120') || l_update_tag_flash ||
                                     decode(ipp.desc_modifiers, NULL, l_msg_del, ipp.desc_modifiers) ||
                                     decode(ipp.desc_modifiers_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T153') ||
                                            ipp.desc_modifiers_new))) desc_modifiers,
                       decode(cnt,
                              rn,
                              decode(ipp.desc_supplies,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T152') || ipp.desc_supplies),
                              decode(ipp.desc_supplies,
                                     ipp.desc_supplies_new,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T152') || l_update_tag_flash ||
                                     decode(ipp.desc_supplies, NULL, l_msg_del, ipp.desc_supplies) ||
                                     decode(ipp.desc_supplies_new,
                                            NULL,
                                            NULL,
                                            l_formated_text || aa_code_messages('PROCEDURES_T152') || ipp.desc_supplies_new))) desc_supplies,
                       decode(cnt,
                              rn,
                              decode(ipp.time_out_notes, NULL, NULL, ipp.time_out_notes),
                              decode(ipp.time_out_notes,
                                     ipp.time_out_notes_new,
                                     NULL,
                                     l_update_tag_flash || decode(ipp.time_out_notes, NULL, l_msg_del, ipp.time_out_notes) ||
                                     decode(ipp.time_out_notes_new, NULL, NULL, ipp.time_out_notes_new))) desc_time_out,
                       
                       decode(dbms_lob.getlength(ta.l_notes),
                              NULL,
                              to_clob(''),
                              decode(instr(lower(ta.l_notes), '<b>'),
                                     0,
                                     to_clob(aa_code_messages('PROCEDURES_T100')) || ta.l_notes,
                                     ta.l_notes)) desc_perform,
                       
                       NULL                    cancel_reason,
                       NULL                    cancel_notes,
                       NULL                    dt_ord,
                       ipp.dt_last_update_tstz
                  FROM (SELECT row_number() over(ORDER BY t.id_interv_presc_plan, t.dt_interv_presc_plan_hist DESC NULLS FIRST) rn,
                               MAX(rownum) over(ORDER BY t.id_interv_presc_plan) cnt,
                               t.id_interv_presc_plan,
                               t.id_interv_presc_det,
                               t.id_episode_write,
                               first_value(t.id_episode_write) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_episode_write_new,
                               t.id_intervention,
                               t.dt_interv_presc_plan,
                               first_value(t.dt_interv_presc_plan) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_interv_presc_plan_new,
                               t.flg_status,
                               first_value(t.flg_status) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_status_new,
                               t.flg_interv_type,
                               t.num_take,
                               t.id_wound_treat,
                               first_value(t.id_wound_treat) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_wound_treat_new,
                               t.id_prof_take,
                               first_value(t.id_prof_take) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_take_new,
                               t.dt_take_tstz,
                               first_value(t.dt_take_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_take_tstz_new,
                               t.id_prof_performed,
                               first_value(t.id_prof_performed) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_performed_new,
                               t.start_time,
                               first_value(t.start_time) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) start_time_new,
                               t.end_time,
                               first_value(t.end_time) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) end_time_new,
                               t.dt_plan_tstz,
                               first_value(t.dt_plan_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_plan_tstz_new,
                               t.flg_supplies_reg,
                               first_value(t.flg_supplies_reg) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) flg_supplies_reg_new,
                               t.time_out_notes,
                               first_value(t.time_out_notes) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) time_out_notes_new,
                               t.id_epis_documentation,
                               first_value(t.id_epis_documentation) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_epis_documentation_new,
                               --t.notes notes,
                               --first_value(dbms_lob.substr(t.notes, 3800)) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_new,
                               t.id_epis_documentation notes,
                               first_value(t.id_epis_documentation) over(PARTITION BY t.id_interv_presc_plan ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_new,
                               t.id_prof_cancel,
                               first_value(t.id_prof_cancel) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_prof_cancel_new,
                               t.dt_cancel_tstz,
                               first_value(t.dt_cancel_tstz) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) dt_cancel_tstz_new,
                               t.id_cancel_reason,
                               first_value(t.id_cancel_reason) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cancel_reason_new,
                               t.notes_cancel,
                               first_value(t.notes_cancel) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) notes_cancel_new,
                               t.id_cdr_event,
                               first_value(t.id_cdr_event) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) id_cdr_event_new,
                               t.exec_number,
                               first_value(t.exec_number) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) exec_number_new,
                               t.desc_supplies,
                               first_value(t.desc_supplies) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_supplies_new,
                               t.desc_modifiers,
                               first_value(t.desc_modifiers) over(ORDER BY dt_interv_presc_plan_hist rows BETWEEN 1 preceding AND CURRENT ROW) desc_modifiers_new,
                               t.dt_last_update_tstz
                          FROM (SELECT NULL dt_interv_presc_plan_hist,
                                       ipp.id_interv_presc_plan,
                                       ipp.id_interv_presc_det,
                                       ipp.id_episode_write,
                                       ipd.id_intervention,
                                       ipp.dt_interv_presc_plan,
                                       ipp.flg_status,
                                       ipd.flg_interv_type,
                                       ipd.num_take,
                                       ipp.id_wound_treat,
                                       ipp.id_prof_take,
                                       ipp.dt_take_tstz,
                                       ipp.id_prof_performed,
                                       ipp.start_time,
                                       ipp.end_time,
                                       nvl((SELECT i.dt_plan_tstz
                                             FROM interv_presc_plan i
                                            WHERE i.id_interv_presc_det = ipd.id_interv_presc_det
                                              AND i.flg_status = pk_procedures_constant.g_interv_plan_pending),
                                           ipp.dt_plan_tstz) dt_plan_tstz,
                                       ipp.flg_supplies_reg,
                                       ito.time_out_notes,
                                       ipp.id_epis_documentation,
                                       decode(dbms_lob.getlength(ed.notes), NULL, to_clob(''), ed.notes) notes,
                                       ipp.id_prof_cancel,
                                       ipp.dt_cancel_tstz,
                                       ipp.id_cancel_reason,
                                       ipp.notes_cancel,
                                       ipp.id_cdr_event,
                                       ipp.exec_number,
                                       pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                        i_prof,
                                                                                        ipp.id_interv_presc_plan,
                                                                                        pk_supplies_constant.g_context_procedure_exec) desc_supplies,
                                       pk_procedures_utils.get_procedure_modifiers(i_lang,
                                                                                   i_prof,
                                                                                   ipp.id_interv_presc_plan) desc_modifiers,
                                       ipp.dt_last_update_tstz
                                  FROM interv_presc_plan ipp,
                                       (SELECT tt.num_1 id_interv_presc_plan,
                                               tt.num_2 id_epis_documentation,
                                               tt.vc_1  time_out_notes
                                          FROM tbl_temp tt
                                         WHERE tt.vc_2 = 'ITO') ito,
                                       (SELECT *
                                          FROM (SELECT epd.id_epis_context,
                                                       epd.notes,
                                                       row_number() over(PARTITION BY epd.id_epis_context ORDER BY epd.dt_last_update_tstz DESC) rn
                                                  FROM epis_documentation epd
                                                 WHERE epd.id_episode = i_episode) epe
                                         WHERE epe.rn = 1) ed,
                                       interv_presc_det ipd
                                 WHERE ipp.id_interv_presc_det = i_interv_presc_det
                                   AND ipp.flg_status IN
                                       (pk_procedures_constant.g_interv_plan_executed,
                                        pk_procedures_constant.g_interv_plan_not_executed)
                                   AND ipp.id_interv_presc_det = ipd.id_interv_presc_det
                                   AND ipp.id_interv_presc_plan = ito.id_interv_presc_plan(+)
                                   AND ipp.id_interv_presc_plan = ed.id_epis_context(+)
                                
                                UNION ALL
                                SELECT ipph.dt_interv_presc_plan_hist,
                                       ipph.id_interv_presc_plan,
                                       ipph.id_interv_presc_det,
                                       ipph.id_episode_write,
                                       ipd.id_intervention,
                                       ipph.dt_interv_presc_plan,
                                       ipph.flg_status,
                                       ipd.flg_interv_type,
                                       ipd.num_take,
                                       ipph.id_wound_treat,
                                       ipph.id_prof_take,
                                       ipph.dt_take_tstz,
                                       ipph.id_prof_performed,
                                       ipph.start_time,
                                       ipph.end_time,
                                       ipph.dt_plan_tstz,
                                       ipph.flg_supplies_reg,
                                       ito.time_out_notes,
                                       ipph.id_epis_documentation,
                                       decode(dbms_lob.getlength(ed.notes), NULL, to_clob(''), ed.notes) notes,
                                       ipph.id_prof_cancel,
                                       ipph.dt_cancel_tstz,
                                       ipph.id_cancel_reason,
                                       ipph.notes_cancel,
                                       ipph.id_cdr_event,
                                       ipph.exec_number,
                                       pk_supplies_external_api_db.get_supplies_request(i_lang,
                                                                                        i_prof,
                                                                                        ipph.id_interv_presc_plan,
                                                                                        pk_supplies_constant.g_context_procedure_exec) desc_supplies,
                                       pk_procedures_utils.get_procedure_modifiers(i_lang,
                                                                                   i_prof,
                                                                                   ipph.id_interv_presc_plan_hist) desc_modifiers,
                                       ipph.dt_last_update_tstz
                                  FROM interv_presc_plan_hist ipph,
                                       (SELECT tt.num_1 id_interv_presc_plan,
                                               tt.num_2 id_epis_documentation,
                                               tt.vc_1  time_out_notes
                                          FROM tbl_temp tt
                                         WHERE tt.vc_2 = 'ITO') ito,
                                       (SELECT *
                                          FROM (SELECT epd.id_epis_context,
                                                       epd.notes,
                                                       row_number() over(PARTITION BY epd.id_epis_context ORDER BY epd.dt_last_update_tstz DESC) rn
                                                  FROM epis_documentation epd
                                                 WHERE epd.id_episode = i_episode) epe
                                         WHERE epe.rn = 1) ed,
                                       interv_presc_det ipd
                                 WHERE ipph.id_interv_presc_det = i_interv_presc_det
                                   AND ipph.id_interv_presc_det = ipd.id_interv_presc_det
                                   AND NOT EXISTS
                                 (SELECT 1
                                          FROM interv_presc_plan ipp
                                         WHERE ipph.id_interv_presc_plan = ipp.id_interv_presc_plan
                                           AND ipp.flg_status IN (pk_procedures_constant.g_interv_plan_not_executed,
                                                                  pk_procedures_constant.g_interv_interrupted,
                                                                  pk_procedures_constant.g_interv_cancel))
                                   AND ipph.id_interv_presc_plan = ito.id_interv_presc_plan(+)
                                   AND ipph.id_epis_documentation = ed.id_epis_context(+)
                                 ORDER BY id_interv_presc_plan, dt_interv_presc_plan_hist DESC NULLS FIRST) t
                         ORDER BY rn) ipp
                  LEFT JOIN epis_documentation edd
                    ON ipp.notes = edd.id_epis_documentation
                  LEFT JOIN epis_documentation edd_n
                    ON ipp.notes_new = edd_n.id_epis_documentation
                  LEFT JOIN TABLE(l_execution_notes) ta
                    ON ta.l_presc_plan = ipp.id_interv_presc_plan)
         ORDER BY id_interv_presc_plan DESC;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_execution();
    END tf_get_procedure_execution_history;

    FUNCTION tf_get_procedure_execution_images
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_execution_images IS
    
        l_ret t_tbl_procedures_execution_images := t_tbl_procedures_execution_images();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedure_execution_images(id_interv_presc_plan     => t.id_interv_presc_plan,
                                            id_doc_external          => t.id_doc_external,
                                            doc_title                => t.doc_title,
                                            perform_by               => t.perform_by,
                                            dt_doc                   => t.dt_doc,
                                            doc_original_destination => t.doc_original_destination,
                                            doc_original_type        => t.doc_original_type,
                                            num_img                  => t.num_img,
                                            doc_original_desc        => t.doc_original_desc,
                                            notes                    => t.notes,
                                            thumbnail_img            => t.thumbnail_img,
                                            thumbnail_report         => t.thumbnail_report,
                                            thumbnail                => t.thumbnail,
                                            thumbnail_img_icon       => t.thumbnail_img_icon,
                                            thumbnail_report_icon    => t.thumbnail_report_icon,
                                            thumbnail_icon           => t.thumbnail_icon,
                                            dt_ord                   => t.dt_ord,
                                            dt_last_update           => t.dt_last_update_tstz,
                                            registry                 => t.registry)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ipp.id_interv_presc_plan,
                       ima.id_doc_external,
                       decode(de.title, NULL, NULL, aa_code_messages('PROCEDURES_T158') || de.title) doc_title,
                       decode(de.desc_perf_by,
                              NULL,
                              decode(ipp.id_prof_performed,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T155') ||
                                     pk_prof_utils.get_nickname(i_lang, ipp.id_prof_performed)),
                              aa_code_messages('PROCEDURES_T155') || de.desc_perf_by) perform_by,
                       decode(de.dt_emited,
                              NULL,
                              decode(ipp.dt_interv_presc_plan,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T156') ||
                                     pk_date_utils.dt_chr_tsz(i_lang, ipp.dt_interv_presc_plan, i_prof)),
                              aa_code_messages('PROCEDURES_T156') || pk_date_utils.dt_chr(i_lang, de.dt_emited, i_prof)) dt_doc,
                       decode(de.desc_doc_destination,
                              NULL,
                              decode(de.id_doc_destination,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T161') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_TYPE.CODE_DOC_DESTINATION.' ||
                                                                    de.id_doc_destination)),
                              aa_code_messages('PROCEDURES_T161') || de.desc_doc_destination) doc_original_destination,
                       decode(de.desc_doc_ori_type,
                              NULL,
                              decode(de.id_doc_ori_type,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T162') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type)),
                              aa_code_messages('PROCEDURES_T162') || de.desc_doc_ori_type) doc_original_type,
                       aa_code_messages('PROCEDURES_T157') ||
                       pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                       decode(de.desc_doc_original,
                              NULL,
                              decode(de.id_doc_original,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T160') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original)),
                              aa_code_messages('PROCEDURES_T160') || de.desc_doc_original) doc_original_desc,
                       decode(pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external),
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T100') ||
                              pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external)) notes,
                       NULL thumbnail_img,
                       NULL thumbnail_report,
                       pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                       NULL thumbnail_img_icon,
                       NULL thumbnail_report_icon,
                       to_char(pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external)) thumbnail_icon,
                       pk_date_utils.date_send_tsz(i_lang, ipp.dt_interv_presc_plan, i_prof) dt_ord,
                       ipp.dt_last_update_tstz,
                       l_msg_reg || ' ' || pk_prof_utils.get_name_signature(i_lang, i_prof, de.id_professional) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang, i_prof, de.id_professional, de.dt_inserted, NULL),
                              NULL,
                              '; ',
                              ' (' ||
                              pk_prof_utils.get_spec_signature(i_lang, i_prof, de.id_professional, de.dt_inserted, NULL) ||
                              '); ') ||
                       pk_date_utils.date_char_tsz(i_lang, de.dt_inserted, i_prof.institution, i_prof.software) registry
                  FROM interv_presc_plan ipp, interv_media_archive ima, doc_external de
                 WHERE ipp.id_interv_presc_det = i_interv_presc_det
                   AND ipp.id_interv_presc_plan = ima.id_interv_presc_plan
                   AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_exec
                   AND ima.id_doc_external = de.id_doc_external
                   AND de.flg_status = pk_alert_constant.g_active
                 ORDER BY dt_ord DESC) t;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_execution_images();
    END tf_get_procedure_execution_images;

    FUNCTION tf_get_procedure_doc
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_doc IS
    
        l_ret t_tbl_procedures_doc := t_tbl_procedures_doc();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedure_doc(id_interv_presc_det      => t.id_interv_presc_det,
                               id_doc_external          => t.id_doc_external,
                               registry                 => t.registry,
                               doc_title                => t.doc_title,
                               doc_original_type        => t.doc_original_type,
                               desc_status              => t.desc_status,
                               dt_doc                   => t.dt_doc,
                               perform_by               => t.perform_by,
                               num_img                  => t.num_img,
                               doc_original_desc        => t.doc_original_desc,
                               doc_original_destination => t.doc_original_destination,
                               notes                    => t.notes,
                               thumbnail                => t.thumbnail,
                               thumbnail_icon           => t.thumbnail_icon,
                               dt_ord                   => t.dt_ord)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ima.id_interv_presc_det,
                       ima.id_doc_external,
                       l_msg_reg || ' ' || pk_prof_utils.get_name_signature(i_lang, i_prof, de.id_professional) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang, i_prof, de.id_professional, de.dt_inserted, NULL),
                              NULL,
                              '; ',
                              ' (' ||
                              pk_prof_utils.get_spec_signature(i_lang, i_prof, de.id_professional, de.dt_inserted, NULL) ||
                              '); ') ||
                       pk_date_utils.date_char_tsz(i_lang, de.dt_inserted, i_prof.institution, i_prof.software) registry,
                       decode(de.title, NULL, NULL, aa_code_messages('PROCEDURES_T158') || de.title) doc_title,
                       decode(de.desc_doc_ori_type,
                              NULL,
                              decode(de.id_doc_ori_type,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T162') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_ORI_TYPE.CODE_DOC_ORI_TYPE.' || de.id_doc_ori_type)),
                              aa_code_messages('PROCEDURES_T162') || de.desc_doc_ori_type) doc_original_type,
                       aa_code_messages('PROCEDURES_T011') ||
                       pk_sysdomain.get_domain('DOC_EXTERNAL.FLG_STATUS', de.flg_status, i_lang) desc_status,
                       decode(de.dt_emited,
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T156') ||
                              pk_date_utils.dt_chr_tsz(i_lang, de.dt_emited, i_prof)) dt_doc,
                       decode(de.desc_perf_by, NULL, NULL, aa_code_messages('PROCEDURES_T155') || de.desc_perf_by) perform_by,
                       aa_code_messages('PROCEDURES_T157') ||
                       pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) num_img,
                       decode(de.desc_doc_original,
                              NULL,
                              decode(de.id_doc_original,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T160') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_ORIGINAL.CODE_DOC_ORIGINAL.' || de.id_doc_original)),
                              aa_code_messages('PROCEDURES_T160') || de.desc_doc_original) doc_original_desc,
                       decode(de.desc_doc_destination,
                              NULL,
                              decode(de.id_doc_destination,
                                     NULL,
                                     NULL,
                                     aa_code_messages('PROCEDURES_T161') ||
                                     pk_translation.get_translation(i_lang,
                                                                    'DOC_TYPE.CODE_DOC_DESTINATION.' ||
                                                                    de.id_doc_destination)),
                              aa_code_messages('PROCEDURES_T161') || de.desc_doc_destination) doc_original_destination,
                       decode(pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external),
                              NULL,
                              NULL,
                              aa_code_messages('PROCEDURES_T100') ||
                              pk_doc.get_doc_last_comment(i_lang, i_prof, ima.id_doc_external)) notes,
                       pk_doc.get_main_thumb_url(i_lang, i_prof, ima.id_doc_external) thumbnail,
                       pk_doc.get_count_image(i_lang, i_prof, ima.id_doc_external) thumbnail_icon,
                       pk_date_utils.date_send_tsz(i_lang, de.dt_inserted, i_prof) dt_ord
                  FROM interv_media_archive ima, doc_external de
                 WHERE ima.id_interv_presc_det = i_interv_presc_det
                   AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_doc
                   AND ima.flg_status = pk_procedures_constant.g_active
                   AND ima.id_doc_external = de.id_doc_external
                 ORDER BY dt_ord DESC) t;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_doc();
    END tf_get_procedure_doc;

    FUNCTION tf_get_procedure_review
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_interv_presc_det IN interv_presc_det.id_interv_presc_det%TYPE,
        i_flg_report       IN VARCHAR2 DEFAULT pk_procedures_constant.g_no,
        i_aa_code_messages IN pk_procedures_constant.t_code_messages DEFAULT pk_procedures_constant.t_code_messages()
    ) RETURN t_tbl_procedures_review IS
    
        l_ret t_tbl_procedures_review := t_tbl_procedures_review();
    
        aa_code_messages pk_procedures_constant.t_code_messages;
    
        l_msg_reg sys_message.desc_message%TYPE := pk_message.get_message(i_lang, i_prof, 'COMMON_M107');
    
    BEGIN
    
        g_error := 'GET MESSAGES';
        IF i_aa_code_messages.count = 0
        THEN
            FOR i IN pk_procedures_constant.ga_code_messages_procedure_detail.first .. pk_procedures_constant.ga_code_messages_procedure_detail.last
            LOOP
                aa_code_messages(pk_procedures_constant.ga_code_messages_procedure_detail(i)) := '<b>' ||
                                                                                                 pk_message.get_message(i_lang,
                                                                                                                        i_prof,
                                                                                                                        pk_procedures_constant.ga_code_messages_procedure_detail(i)) ||
                                                                                                 '</b> ';
            END LOOP;
        ELSE
            aa_code_messages := i_aa_code_messages;
        END IF;
    
        SELECT t_procedure_review(id_interv_presc_det => t.id_interv_presc_det,
                                  registry            => t.registry,
                                  desc_procedure      => t.desc_procedure,
                                  review_notes        => t.review_notes,
                                  dt_ord              => t.dt_ord)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT ipd.id_interv_presc_det,
                       l_msg_reg || ' ' || pk_prof_utils.get_name_signature(i_lang, i_prof, tm.id_professional) ||
                       decode(pk_prof_utils.get_spec_signature(i_lang,
                                                               i_prof,
                                                               tm.id_professional,
                                                               tm.dt_creation_tstz,
                                                               NULL),
                              NULL,
                              '; ',
                              ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                       i_prof,
                                                                       tm.id_professional,
                                                                       tm.dt_creation_tstz,
                                                                       NULL) || '); ') ||
                       pk_date_utils.date_char_tsz(i_lang, tm.dt_creation_tstz, i_prof.institution, i_prof.software) registry,
                       aa_code_messages('PROCEDURES_T096') ||
                       pk_procedures_utils.get_alias_translation(i_lang,
                                                                 i_prof,
                                                                 'INTERVENTION.CODE_INTERVENTION.' || ipd.id_intervention,
                                                                 NULL) desc_procedure,
                       aa_code_messages('PROCEDURES_T145') || tm.desc_treatment_management review_notes,
                       pk_date_utils.date_send_tsz(i_lang, tm.dt_creation_tstz, i_prof) dt_ord
                  FROM interv_presc_det ipd, treatment_management tm
                 WHERE ipd.id_interv_presc_det = i_interv_presc_det
                   AND ipd.id_interv_presc_det = tm.id_treatment
                   AND tm.flg_type = pk_medical_decision.g_treat_type_interv
                 ORDER BY dt_ord DESC) t;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_tbl_procedures_review();
    END tf_get_procedure_review;

    FUNCTION get_docs_by_request
    (
        i_lang    IN NUMBER,
        i_prof    IN profissional,
        i_episode IN NUMBER,
        i_request IN NUMBER, -- edit, new, submit
        o_docs    OUT pk_types.cursor_type,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        OPEN o_docs FOR
            SELECT ima.id_doc_external id_doc,
                   pk_doc.get_main_thumb_extension(i_lang, i_prof, de.id_doc_external) desc_doc_type,
                   de.title
              FROM interv_media_archive ima, doc_external de
             WHERE ima.id_interv_presc_det = i_request
               AND ima.flg_type = pk_procedures_constant.g_media_archive_interv_doc
               AND ima.flg_status = pk_procedures_constant.g_active
               AND ima.id_doc_external = de.id_doc_external
             ORDER BY ima.id_doc_external DESC;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_DOCS_BY_REQUEST',
                                              o_error);
            RETURN FALSE;
    END get_docs_by_request;

BEGIN

    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);

END pk_procedures_core;
/
