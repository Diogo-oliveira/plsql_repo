/*-- Last Change Revision: $Rev: 2026951 $*/
/*-- Last Change by: $Author: mario.fernandes $*/
/*-- Date of last change: $Date: 2022-08-02 18:40:32 +0100 (ter, 02 ago 2022) $*/

CREATE OR REPLACE PACKAGE BODY pk_diagnosis_core IS

    -- Private types declarations

    -- Private constants declarations
    g_default_stag_basis_num PLS_INTEGER := 1;

    g_staging_basis_prior_stage   CONSTANT PLS_INTEGER := -1;
    g_staging_basis_same_stage    CONSTANT PLS_INTEGER := 0;
    g_staging_basis_forward_stage CONSTANT PLS_INTEGER := 1;

    g_code_stag_group_not_avail CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M040'; --Not available

    g_leaf_path_typ_int_name CONSTANT VARCHAR2(2 CHAR) := 'IN';
    g_leaf_path_typ_id_ds_mk CONSTANT VARCHAR2(2 CHAR) := 'ID';

    g_null_replace_value CONSTANT PLS_INTEGER := -999;

    g_diag_active_detail CONSTANT VARCHAR2(1 CHAR) := 'A';

    -- Private variable declarations
    g_processed_episodes table_number;

    CURSOR c_existing_diag
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_diagnosis           IN epis_diagnosis.id_diagnosis%TYPE,
        i_alert_diagnosis     IN epis_diagnosis.id_alert_diagnosis%TYPE DEFAULT NULL,
        i_flg_type            IN epis_diagnosis.flg_type%TYPE,
        i_desc_diag           IN epis_diagnosis.desc_epis_diagnosis%TYPE,
        i_flg_cancer_diag     IN VARCHAR2,
        i_diagnosis_condition IN epis_diagnosis.id_diagnosis_condition%TYPE,
        i_sub_analysis        IN epis_diagnosis.id_sub_analysis%TYPE,
        i_anatomical_area     IN epis_diagnosis.id_anatomical_area%TYPE,
        i_anatomical_side     IN epis_diagnosis.id_anatomical_side%TYPE
    ) IS
        SELECT ed.id_epis_diagnosis,
               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                  i_prof,
                                                  ed.flg_status,
                                                  ed.dt_epis_diagnosis_tstz,
                                                  ed.dt_confirmed_tstz,
                                                  ed.dt_cancel_tstz,
                                                  ed.dt_base_tstz,
                                                  ed.dt_rulled_out_tstz) dt_diagnosis,
               ed.flg_status,
               ed.flg_final_type,
               ed.flg_add_problem
          FROM epis_diagnosis ed
          JOIN diagnosis d
            ON d.id_diagnosis = ed.id_diagnosis
         WHERE ed.id_episode = i_episode
           AND ed.id_diagnosis = i_diagnosis
           AND (i_alert_diagnosis IS NULL OR ed.id_alert_diagnosis = i_alert_diagnosis)
           AND ((ed.flg_type = i_flg_type AND ed.flg_status != pk_diagnosis.g_diag_type_b) OR
               ed.flg_status = pk_diagnosis.g_diag_type_b)
           AND ((ed.desc_epis_diagnosis = i_desc_diag AND
               nvl(d.flg_other, pk_alert_constant.g_no) = pk_alert_constant.g_yes) OR
               (nvl(d.flg_other, pk_alert_constant.g_no) != pk_alert_constant.g_yes AND i_desc_diag IS NULL))
           AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca
           AND nvl(ed.id_diagnosis_condition, g_null_replace_value) = nvl(i_diagnosis_condition, g_null_replace_value)
           AND nvl(ed.id_sub_analysis, g_null_replace_value) = nvl(i_sub_analysis, g_null_replace_value)
           AND nvl(ed.id_anatomical_area, g_null_replace_value) = nvl(i_anatomical_area, g_null_replace_value)
           AND nvl(ed.id_anatomical_side, g_null_replace_value) = nvl(i_anatomical_side, g_null_replace_value);

    /* CAN'T TOUCH THIS */
    g_error   VARCHAR2(4000 CHAR);
    g_owner   VARCHAR2(30 CHAR);
    g_package VARCHAR2(30 CHAR);

    g_exception EXCEPTION;

    -- Function and procedure implementations

    /**
    * Check if diagnosis is registered by area
    *
    * @param i_lang                Language identifier
    * @param i_prof                Professional identifier
    * @param i_episode             Episode identifier
    * @param i_diagnosis           Diagnosis identifier
    * @param i_flg_type            Diagnosis type
    * @param i_desc_diag           Diagnosis description
    * @param i_diagnosis_condition Diagnosis condition id
    * @param i_sub_analysis        Sub analisys identifier
    * @param i_anatomical_area     Anatomical area id
    * @param i_anatomical_side     Anatomical side ir
    *
    * @return               'Y' - yes; 'N' - no
    *
    * @author               Gisela Couto
    * @version              2.6.4.2.1
    * @since                2014/10/17
    */
    FUNCTION check_if_diag_registered
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_diagnosis           IN epis_diagnosis.id_diagnosis%TYPE,
        i_flg_type            IN epis_diagnosis.flg_type%TYPE,
        i_desc_diag           IN epis_diagnosis.desc_epis_diagnosis%TYPE,
        i_diagnosis_condition IN epis_diagnosis.id_diagnosis_condition%TYPE,
        i_sub_analysis        IN epis_diagnosis.id_sub_analysis%TYPE,
        i_anatomical_area     IN epis_diagnosis.id_anatomical_area%TYPE,
        i_anatomical_side     IN epis_diagnosis.id_anatomical_side%TYPE
    ) RETURN VARCHAR2 IS
    
        r_existing_diag c_existing_diag%ROWTYPE;
        l_resp          VARCHAR2(1 CHAR);
        l_func_name CONSTANT VARCHAR2(30) := 'IS_REGISTERED_AS_FINAL_DIAG';
    BEGIN
    
        g_error := 'GET WORKING DIAGNOSIS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_existing_diag(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_episode             => i_episode,
                             i_diagnosis           => i_diagnosis,
                             i_flg_type            => i_flg_type,
                             i_desc_diag           => i_desc_diag,
                             i_flg_cancer_diag     => pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                                          i_prof         => i_prof,
                                                                                          i_concept_type => NULL,
                                                                                          i_diagnosis    => i_diagnosis),
                             i_diagnosis_condition => i_diagnosis_condition,
                             i_sub_analysis        => i_sub_analysis,
                             i_anatomical_area     => i_anatomical_area,
                             i_anatomical_side     => i_anatomical_side);
        FETCH c_existing_diag
            INTO r_existing_diag;
        CLOSE c_existing_diag;
    
        g_error := 'VERIFY IF DIAGNOSIS EXISTS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF r_existing_diag.id_epis_diagnosis IS NOT NULL
           AND r_existing_diag.flg_status NOT IN
           (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r, pk_diagnosis.g_ed_flg_status_b)
        THEN
            l_resp := pk_alert_constant.g_yes;
        ELSE
            l_resp := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_resp;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN pk_alert_constant.g_no;
    END check_if_diag_registered;

    /**
    * Check if diagnosis gender is valid for the current patient
    *
    * @param i_pat_gender   Patient gender
    * @param i_diag_gender  Diagnosis gender
    *
    * @return               Y - yes; N - no
    *
    * @author               Alexandre Santos
    * @version              2.6.3
    * @since                2013/11/07
    */
    FUNCTION check_pat_gender
    (
        i_pat_gender  IN patient.gender%TYPE,
        i_diag_gender IN patient.gender%TYPE
    ) RETURN VARCHAR2 IS
        l_ret VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
    BEGIN
        IF ((i_pat_gender IS NOT NULL AND nvl(i_diag_gender, 'I') IN ('I', i_pat_gender)) OR i_pat_gender IS NULL OR
           i_pat_gender IN ('I', 'U', 'N'))
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSE
            l_ret := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_ret;
    END check_pat_gender;

    /**
    * Check if patient age is between diagnosis set of ages
    *
    * @param i_pat_age       Patient age
    * @param i_diag_age_min  Diagnosis minimum age
    * @param i_diag_age_max  Diagnosis maximum age
    *
    * @return               Y - yes; N - no
    *
    * @author               Alexandre Santos
    * @version              2.6.3
    * @since                2013/11/07
    */
    FUNCTION check_pat_age
    (
        i_pat_age      IN patient.age%TYPE,
        i_diag_age_min IN patient.age%TYPE,
        i_diag_age_max IN patient.age%TYPE
    ) RETURN VARCHAR2 IS
        l_ret VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
    BEGIN
        IF (nvl(i_pat_age, 0) BETWEEN nvl(i_diag_age_min, 0) AND nvl(i_diag_age_max, nvl(i_pat_age, 0)) OR
           nvl(i_pat_age, 0) = 0)
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSE
            l_ret := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_ret;
    END check_pat_age;

    /**
    * Gets the terminologies available in the given functionality
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_task_type                 Functionality id
    *
    * @return  Terminologies flags table
    *
    * @author  Alexandre Santos
    * @version v2.6.3
    * @since   05-11-2013
    */
    FUNCTION get_diag_terminologies
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task_type IN task_type.id_task_type%TYPE DEFAULT pk_alert_constant.g_task_diagnosis
    ) RETURN table_varchar IS
        l_func_name VARCHAR2(30) := 'GET_DIAG_TERMINOLOGIES';
        --
        l_inst institution.id_institution%TYPE;
        l_soft software.id_software%TYPE;
        --
        l_tbl_flg_terminologies table_varchar;
        l_birth_hist_mechanism  sys_config.value%TYPE := pk_sysconfig.get_config(pk_alert_constant.g_birth_hist_search_mechanism,
                                                                                 i_prof);
        l_surg_hist_mechanism   sys_config.value%TYPE := pk_sysconfig.get_config(pk_alert_constant.g_surg_hist_search_mechanism,
                                                                                 i_prof);
        l_med_hist_mechanism    sys_config.value%TYPE := pk_sysconfig.get_config(pk_alert_constant.g_med_hist_search_mechanism,
                                                                                 i_prof);
    BEGIN
        IF (i_task_type <> pk_alert_constant.g_task_congenital_anomalies OR
           l_birth_hist_mechanism <> pk_alert_constant.g_diag_new_search_mechanism)
           AND (i_task_type <> pk_alert_constant.g_task_surgical_history OR
           l_surg_hist_mechanism <> pk_alert_constant.g_diag_new_search_mechanism)
           AND (i_task_type <> pk_alert_constant.g_task_medical_history OR
           l_med_hist_mechanism <> pk_alert_constant.g_diag_new_search_mechanism)
        THEN
            BEGIN
                g_error := 'GET DIAGNOSIS_CONF_EA CFG_VARS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT id_institution, id_software
                  INTO l_inst, l_soft
                  FROM (SELECT c.id_institution,
                               c.id_software,
                               row_number() over(ORDER BY decode(c.id_institution, i_prof.institution, 1, 2), decode(c.id_software, i_prof.software, 1, 2)) line_number
                          FROM diagnosis_conf_ea c
                         WHERE c.id_institution IN (i_prof.institution, 0)
                           AND c.id_software IN (i_prof.software, 0)
                           AND c.id_task_type = nvl(i_task_type, pk_alert_constant.g_task_diagnosis))
                 WHERE line_number = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    l_inst := i_prof.institution;
                    l_soft := i_prof.software;
            END;
        ELSE
            l_inst := i_prof.institution;
            l_soft := i_prof.software;
        END IF;
    
        g_error := 'GET DIAGNOSIS_CONF_EA FLG_TERMINOLOGIES';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF (i_task_type = pk_alert_constant.g_task_congenital_anomalies AND
           l_birth_hist_mechanism = pk_alert_constant.g_diag_new_search_mechanism)
           OR (i_task_type = pk_alert_constant.g_task_surgical_history AND
           l_surg_hist_mechanism = pk_alert_constant.g_diag_new_search_mechanism)
           OR (i_task_type = pk_alert_constant.g_task_medical_history AND
           l_med_hist_mechanism = pk_alert_constant.g_diag_new_search_mechanism)
        THEN
        
            SELECT t.termin_version_int_name
              BULK COLLECT
              INTO l_tbl_flg_terminologies
              FROM TABLE(pk_ts3_search.tf_get_termin_versions(i_id_language      => i_lang,
                                                              i_id_institution   => l_inst,
                                                              i_id_software      => l_soft,
                                                              i_concept_type     => 'DIAGNOSIS',
                                                              i_id_task_types_or => table_number(i_task_type),
                                                              i_dt_filter        => NULL)) t;
        
        ELSE
            SELECT c.flg_terminology
              BULK COLLECT
              INTO l_tbl_flg_terminologies
              FROM diagnosis_conf_ea c
             WHERE c.id_task_type = nvl(i_task_type, pk_alert_constant.g_task_diagnosis)
               AND c.id_institution = l_inst
               AND c.id_software = l_soft
               AND EXISTS (SELECT 1
                      FROM diagnosis_ea d
                     WHERE d.id_institution = CASE
                               WHEN i_task_type IN (pk_alert_constant.g_task_surgical_history,
                                                    pk_alert_constant.g_task_medical_history) THEN
                                pk_alert_constant.g_inst_all
                               ELSE
                                c.id_institution
                           END
                       AND d.id_software = CASE
                               WHEN i_task_type IN (pk_alert_constant.g_task_surgical_history,
                                                    pk_alert_constant.g_task_medical_history) THEN
                                pk_alert_constant.g_soft_all
                               ELSE
                                c.id_software
                           END
                       AND d.flg_terminology = c.flg_terminology
                       AND d.id_language = c.id_language
                       AND d.flg_is_diagnosis = pk_alert_constant.g_yes);
        END IF;
    
        RETURN l_tbl_flg_terminologies;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN table_varchar();
        WHEN OTHERS THEN
            RETURN NULL;
    END get_diag_terminologies;

    /**
    * Get the terminologies data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_tbl_task_type             Table with functionalities id's
    *
    * @return  Table with terminologies data
    *
    * @author  Alexandre Santos
    * @version v2.6.3
    * @since   05-11-2013
    */
    FUNCTION tf_diag_terminologies
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_tbl_task_type IN table_number DEFAULT table_number(pk_alert_constant.g_task_diagnosis)
    ) RETURN t_table_terminology IS
        l_func_name VARCHAR2(30) := 'TF_DIAG_TERMINOLOGIES';
        --
        l_tbl_task_type table_number;
        --
        l_tbl_flg_terminologies t_table_terminology := t_table_terminology();
        r_term_info             pk_api_termin_server_func.g_rec_terminology_info;
        l_rank                  PLS_INTEGER := 10;
        l_aux_tab               table_varchar := table_varchar();
    BEGIN
        l_tbl_task_type := i_tbl_task_type;
    
        IF l_tbl_task_type IS NULL
           OR l_tbl_task_type.count = 0
        THEN
            l_tbl_task_type := table_number(pk_alert_constant.g_task_diagnosis);
        END IF;
    
        g_error := 'GET TERMINOLOGIES DATA';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR r_term IN (SELECT DISTINCT dr.column_value flg_terminology
                         FROM TABLE(l_tbl_task_type) tt
                        CROSS JOIN TABLE(pk_diagnosis_core.get_diag_terminologies(i_lang => i_lang, i_prof => i_prof, i_task_type => tt.column_value)) dr)
        LOOP
            l_aux_tab   := pk_string_utils.str_split(i_list => r_term.flg_terminology, i_delim => '|');
            r_term_info := pk_api_pfh_diagnosis_in.get_terminology_information(i_terminology => pk_api_diagnosis_func.get_id_terminology(i_flg_type => l_aux_tab(1)));
        
            l_tbl_flg_terminologies.extend();
            l_tbl_flg_terminologies(l_tbl_flg_terminologies.count) := t_rec_terminology(id_terminology   => r_term_info.id_terminology,
                                                                                        desc_terminology => pk_translation.get_translation(i_lang      => i_lang,
                                                                                                                                           i_code_mess => r_term_info.code_abbreviation),
                                                                                        flg_terminology  => r_term.flg_terminology,
                                                                                        rank             => l_rank);
            l_rank := l_rank + 10;
        END LOOP;
    
        RETURN l_tbl_flg_terminologies;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_table_terminology();
    END tf_diag_terminologies;

    /**
    * Get the terminologies data
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_tbl_task_type             Table with functionalities id's
    * @param   i_id_content                string id content
    *
    * @return  Table with terminologies data
    *
    * @author  Pedro Fernandes
    * @version v2.6.5.0.6
    * @since   06-10-2015
    */
    FUNCTION tf_diag_terminologies
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_tbl_task_type  IN table_number,
        i_tbl_id_content IN table_varchar,
        i_relation_type  IN VARCHAR2
    ) RETURN t_table_diag_terminology IS
        l_empty                  NUMBER(2) := 0;
        l_table_diag_terminology t_table_diag_terminology := t_table_diag_terminology();
    
    BEGIN
        IF i_tbl_task_type IS NULL
           OR i_tbl_task_type.count = 0
           OR i_tbl_id_content IS NULL
           OR i_tbl_id_content.count = 0
           OR i_tbl_id_content IS NULL
        THEN
            l_empty := 1;
        END IF;
    
        IF l_empty = 0
        THEN
            SELECT t_rec_diag_terminology(tt.id_diagnosis,
                                          tt.desc_diagnosis,
                                          tt.id_alert_diagnosis,
                                          tt.code_icd,
                                          tt.flg_other,
                                          tt.rank)
              BULK COLLECT
              INTO l_table_diag_terminology
              FROM (SELECT /*+opt_param('_optimizer_use_feedback' 'false')*/
                     mcr.id_concept_version_1 id_diagnosis,
                     pk_translation.get_translation(i_lang      => i_lang,
                                                    i_code_mess => pk_api_pfh_diagnosis_in.get_diag_preferred_term(id_concept_version_1)) desc_diagnosis,
                     mcr.code_1 code_icd,
                     pk_api_pfh_diagnosis_in.get_diag_flg_other(mcr.id_terminology_1, mcr.id_concept1) flg_other,
                     20 rank,
                     mcttt.id_concept_term id_alert_diagnosis
                      FROM v_msi_concept_relations mcr
                      JOIN v_msi_concept_terms_task_types mcttt
                        ON (mcttt.id_terminology_version = mcr.id_terminology_version_1 AND
                           mcttt.id_concept = mcr.id_concept1 AND
                           mcttt.id_concept_inst_owner = mcr.id_concept_inst_owner1)
                     WHERE mcr.concept_rel_type = 'INTERPRETS'
                       AND mcr.code_2 IN (SELECT /*+opt_estimate (table t rows=1)*/
                                           *
                                            FROM TABLE(i_tbl_id_content) t)
                       AND mcr.id_institution = i_prof.institution
                       AND mcr.id_software = i_prof.software
                       AND mcr.flg_active = pk_alert_constant.g_yes
                       AND mcttt.flg_available = pk_alert_constant.g_yes
                       AND mcttt.flg_search_type = pk_diagnosis.g_diag_pesq
                       AND mcttt.id_institution = i_prof.institution
                       AND mcttt.id_software = i_prof.software
                       AND mcttt.id_task_type IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                   *
                                                    FROM TABLE(i_tbl_task_type) t)) tt;
        END IF;
    
        RETURN l_table_diag_terminology;
    END tf_diag_terminologies;

    --
    FUNCTION set_init_table_int(i_total_elem PLS_INTEGER) RETURN table_varchar IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_INIT_TABLE_INT';
        --
        l_tbl_str table_varchar := table_varchar();
    BEGIN
        g_error := 'ADD ' || i_total_elem || ' ELEMENT''S';
        <<init_tbl>>
        FOR i IN 1 .. i_total_elem
        LOOP
            l_tbl_str.extend();
            l_tbl_str(l_tbl_str.count) := NULL;
        END LOOP init_tbl;
    
        RETURN l_tbl_str;
    END set_init_table_int;
    --

    /**********************************************************************************************
    * Get the type of diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_concept_type           concept type (specified during content creation)
    * @param i_diagnosis              diagnosis ID
    *
    * @return                         Diagnosis type: C - Cancer
    *                                                 A - Accident and Emergency
    *                                                 D - Diagnosis
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          08-08-2013
    **********************************************************************************************/
    FUNCTION get_diag_type
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_concept_type IN diagnosis.concept_type_int_name%TYPE,
        i_diagnosis    IN diagnosis.id_diagnosis%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_TYPE';
        --
        l_error         t_error_out;
        l_flg_diag_type VARCHAR2(1 CHAR);
        l_concept_type  diagnosis.concept_type_int_name%TYPE;
    BEGIN
    
        g_error := 'CHECK DIAGNOSIS TYPE ' || i_diagnosis || ' - ' || i_concept_type;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF i_concept_type IS NULL
        THEN
            BEGIN
                SELECT t.concept_type_int_name
                  INTO l_concept_type
                  FROM (SELECT d.concept_type_int_name
                          FROM diagnosis_ea d
                         WHERE d.flg_is_diagnosis = pk_alert_constant.g_yes
                           AND d.id_concept_version = i_diagnosis
                           AND rownum = 1) t;
            EXCEPTION
                WHEN no_data_found THEN
                    BEGIN
                        SELECT d.concept_type_int_name
                          INTO l_concept_type
                          FROM diagnosis d
                         WHERE d.id_diagnosis = i_diagnosis;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_concept_type := g_diagn_type;
                    END;
            END;
        ELSE
            l_concept_type := i_concept_type;
        END IF;
    
        IF l_concept_type = g_diagn_type
        THEN
            l_flg_diag_type := pk_diagnosis_core.g_diag_type_diag;
        ELSIF l_concept_type = g_cancer_type
        THEN
            l_flg_diag_type := pk_diagnosis_core.g_diag_type_cancer;
        ELSIF l_concept_type IN (pk_diagnosis_form.g_diag_condition_type,
                                 pk_diagnosis_form.g_sub_analysis_type,
                                 pk_diagnosis_form.g_ae_diagnosis_type)
        THEN
            l_flg_diag_type := pk_diagnosis_core.g_diag_type_acc_emerg;
        ELSE
            l_flg_diag_type := NULL;
        END IF;
    
        RETURN l_flg_diag_type;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_diag_type;
    --
    /**********************************************************************************************
    * Checks if a specific diagnosis is a cancer diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_concept_type           concept type (specified during content creation)
    * @param i_diagnosis              diagnosis ID
    *
    * @return                         Is it a cancer diagnosis? (Y)es or (N)o
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          29-02-2012
    **********************************************************************************************/
    FUNCTION check_diag_cancer
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_concept_type IN diagnosis.concept_type_int_name%TYPE,
        i_diagnosis    IN diagnosis.id_diagnosis%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_DIAG_CANCER';
        --
        l_error         t_error_out;
        l_flg_is_cancer VARCHAR2(1 CHAR);
    BEGIN
        g_error := 'CALL GET_DIAG_TYPE';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF get_diag_type(i_lang         => i_lang,
                         i_prof         => i_prof,
                         i_concept_type => i_concept_type,
                         i_diagnosis    => i_diagnosis) = pk_diagnosis_core.g_diag_type_cancer
        THEN
            l_flg_is_cancer := pk_alert_constant.g_yes;
        ELSE
            l_flg_is_cancer := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_flg_is_cancer;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END check_diag_cancer;

    FUNCTION check_diag_trauma
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_diagnosis IN diagnosis.id_diagnosis%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_DIAG_TRAUMA';
        --
        l_error         t_error_out;
        l_flg_is_trauma VARCHAR2(1 CHAR);
        l_concept_type  VARCHAR2(200 CHAR);
    BEGIN
        g_error := 'CALL GET_EA_CONCEPT_TYPE_INT_NAME';
        BEGIN
            SELECT pk_api_diagnosis_func.get_ea_concept_type_int_name(i_id_terminology      => d.id_terminology_version,
                                                                      i_id_concept          => d.id_concept,
                                                                      i_id_cncpt_inst_owner => 0,
                                                                      i_filter_inst_owner   => 0,
                                                                      i_flg_type_main       => 'N')
              INTO l_concept_type
              FROM diagnosis d
             WHERE d.id_diagnosis = i_diagnosis;
        EXCEPTION
            WHEN OTHERS THEN
                l_concept_type := g_diagn_type;
        END;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF l_concept_type = pk_diagnosis_core.g_trauma_type
        THEN
            l_flg_is_trauma := pk_alert_constant.g_yes;
        ELSE
            l_flg_is_trauma := pk_alert_constant.g_no;
        END IF;
    
        RETURN l_flg_is_trauma;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END check_diag_trauma;
    --
    /**********************************************************************************************
    * Get node and leaf internal name
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_diag_type              Diagnosis type
    *
    * @i_diag_type                    C - Cancer
    *                                 A - Accident and Emergency
    *                                 D - Diagnosis
    *
    * @return                         Leaf path
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          22-08-2013
    **********************************************************************************************/
    FUNCTION get_ds_leaf_path
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_diag_type           IN VARCHAR2,
        i_allow_complications IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN CLOB IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DS_LEAF_PATH';
        --
        l_invest_stat_sufix      CONSTANT ds_component.internal_name%TYPE := 'INVESTIGATION_STATUS';
        l_princ_diag_sufix       CONSTANT ds_component.internal_name%TYPE := 'PRINCIPAL_DIAG';
        l_add_to_prob_sufix      CONSTANT ds_component.internal_name%TYPE := 'ADD_TO_PROBLEMS';
        l_diagnosis_rank         CONSTANT ds_component.internal_name%TYPE := 'RANK';
        l_diagnosis_complication CONSTANT ds_component.internal_name%TYPE := 'COMPLICATIONS';
        --
        l_doc              xmldom.domdocument;
        l_main_node        xmldom.domnode;
        l_ds_form_node     xmldom.domnode;
        l_root_node        xmldom.domnode;
        l_root_int_name    ds_component.internal_name%TYPE;
        l_section_node     xmldom.domnode;
        l_section_int_name ds_component.internal_name%TYPE;
        l_leaf_node        xmldom.domnode;
        l_item_elmt        xmldom.domelement;
        --
        l_root_name ds_component.internal_name%TYPE;
        --
        l_ret CLOB;
        --DISCHARGE DIAGNOSIS MANAGE BY RANK OR PRINCIPAL
        g_manage_principal CONSTANT VARCHAR2(1 CHAR) := 'P';
        g_manage_rank      CONSTANT VARCHAR2(1 CHAR) := 'R';
        l_diag_manage_type    VARCHAR2(100 CHAR) := nvl(pk_sysconfig.get_config('DISCHARGE_DIAGNOSIS_MANAGE_BY_RANK_OR_PRINCIPAL',
                                                                                i_prof),
                                                        g_manage_principal);
        l_enable_complication VARCHAR2(100 CHAR) := nvl(pk_sysconfig.get_config('DIAGNOSIS_ENABLE_COMPLICATION', i_prof),
                                                        pk_alert_constant.g_no);
        --
        PROCEDURE add_attribute
        (
            i_name       IN VARCHAR2,
            i_value      IN VARCHAR2,
            io_item_elmt IN OUT xmldom.domelement
        ) IS
        BEGIN
            IF i_value IS NOT NULL
            THEN
                xmldom.setattribute(io_item_elmt, i_name, i_value);
            END IF;
        END add_attribute;
    BEGIN
        g_error := 'SET DS ROOT NAME';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_root_name := CASE i_diag_type
                           WHEN pk_diagnosis_core.g_diag_type_diag THEN
                            pk_diagnosis_form.g_dsc_general_diagnosis
                           WHEN pk_diagnosis_core.g_diag_type_cancer THEN
                            pk_diagnosis_form.g_dsc_cancer_diagnosis
                           WHEN pk_diagnosis_core.g_diag_type_acc_emerg THEN
                            pk_diagnosis_form.g_dsc_acc_emerg_diagnosis
                           ELSE
                            NULL
                       END;
    
        IF l_root_name IS NOT NULL
        THEN
            l_doc          := xmldom.newdomdocument;
            l_main_node    := xmldom.makenode(l_doc);
            l_item_elmt    := xmldom.createelement(l_doc, 'DS_FORM');
            l_ds_form_node := xmldom.appendchild(l_main_node, xmldom.makenode(l_item_elmt));
        
            --Make sure that leafs are ordered by section
            FOR rec IN (SELECT b.id_ds_cmpt_mkt_rel,
                               b.internal_name,
                               b.lvl,
                               b.flg_component_type,
                               l_invest_stat_sufix node_name
                          FROM (SELECT a.id_ds_cmpt_mkt_rel, a.internal_name, a.lvl, a.flg_component_type
                                  FROM (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, LEVEL lvl, t.flg_component_type
                                          FROM TABLE(pk_dynamic_screen.tf_ds_sections(i_lang           => i_lang,
                                                                                      i_prof           => i_prof,
                                                                                      i_component_name => l_root_name,
                                                                                      i_component_type => pk_dynamic_screen.c_root_component)) t
                                         START WITH t.internal_name LIKE '%' || l_invest_stat_sufix
                                        CONNECT BY PRIOR t.id_ds_component_parent = t.id_ds_component) a
                                 ORDER BY a.lvl DESC) b
                        UNION ALL
                        SELECT b.id_ds_cmpt_mkt_rel,
                               b.internal_name,
                               b.lvl,
                               b.flg_component_type,
                               l_princ_diag_sufix node_name
                          FROM (SELECT a.id_ds_cmpt_mkt_rel, a.internal_name, a.lvl, a.flg_component_type
                                  FROM (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, LEVEL lvl, t.flg_component_type
                                          FROM TABLE(pk_dynamic_screen.tf_ds_sections(i_lang           => i_lang,
                                                                                      i_prof           => i_prof,
                                                                                      i_component_name => l_root_name,
                                                                                      i_component_type => pk_dynamic_screen.c_root_component)) t
                                         START WITH t.internal_name LIKE '%' || l_princ_diag_sufix
                                        CONNECT BY PRIOR t.id_ds_component_parent = t.id_ds_component) a
                                 ORDER BY a.lvl DESC) b
                         WHERE l_diag_manage_type = g_manage_principal
                        UNION ALL
                        SELECT b.id_ds_cmpt_mkt_rel,
                               b.internal_name,
                               b.lvl,
                               b.flg_component_type,
                               l_add_to_prob_sufix node_name
                          FROM (SELECT a.id_ds_cmpt_mkt_rel, a.internal_name, a.lvl, a.flg_component_type
                                  FROM (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, LEVEL lvl, t.flg_component_type
                                          FROM TABLE(pk_dynamic_screen.tf_ds_sections(i_lang           => i_lang,
                                                                                      i_prof           => i_prof,
                                                                                      i_component_name => l_root_name,
                                                                                      i_component_type => pk_dynamic_screen.c_root_component)) t
                                         START WITH t.internal_name LIKE '%' || l_add_to_prob_sufix
                                        CONNECT BY PRIOR t.id_ds_component_parent = t.id_ds_component) a
                                 ORDER BY a.lvl DESC) b
                        UNION ALL
                        -- RANK
                        SELECT b.id_ds_cmpt_mkt_rel,
                               b.internal_name,
                               b.lvl,
                               b.flg_component_type,
                               'DIAGNOSIS_RANK' node_name -- name of the filed returned in filter EpisDiagnosesList
                          FROM (SELECT a.id_ds_cmpt_mkt_rel, a.internal_name, a.lvl, a.flg_component_type
                                  FROM (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, LEVEL lvl, t.flg_component_type
                                          FROM TABLE(pk_dynamic_screen.tf_ds_sections(i_lang           => i_lang,
                                                                                      i_prof           => i_prof,
                                                                                      i_component_name => l_root_name,
                                                                                      i_component_type => pk_dynamic_screen.c_root_component)) t
                                         START WITH t.internal_name LIKE '%' || l_diagnosis_rank
                                        CONNECT BY PRIOR t.id_ds_component_parent = t.id_ds_component) a
                                 ORDER BY a.lvl DESC) b
                         WHERE l_diag_manage_type = g_manage_rank
                        UNION ALL
                        -- COMPLICATIONS
                        SELECT b.id_ds_cmpt_mkt_rel,
                               b.internal_name,
                               b.lvl,
                               b.flg_component_type,
                               'DESC_COMPLICATION' node_name -- name of the filed returned in filter EpisDiagnosesList
                          FROM (SELECT a.id_ds_cmpt_mkt_rel, a.internal_name, a.lvl, a.flg_component_type
                                  FROM (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, LEVEL lvl, t.flg_component_type
                                          FROM TABLE(pk_dynamic_screen.tf_ds_sections(i_lang           => i_lang,
                                                                                      i_prof           => i_prof,
                                                                                      i_component_name => l_root_name,
                                                                                      i_component_type => pk_dynamic_screen.c_root_component)) t
                                         START WITH t.internal_name LIKE '%' || l_diagnosis_complication
                                        CONNECT BY PRIOR t.id_ds_component_parent = t.id_ds_component) a
                                 ORDER BY a.lvl DESC) b
                         WHERE l_enable_complication = pk_alert_constant.g_yes
                           AND i_allow_complications = pk_alert_constant.g_yes
                        
                        )
            LOOP
                IF rec.flg_component_type = pk_dynamic_screen.c_root_component
                   AND (rec.internal_name != l_root_int_name OR l_root_int_name IS NULL)
                THEN
                    l_item_elmt := xmldom.createelement(l_doc, 'ROOT');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_DS_CMPT_MKT_REL',
                                  i_value      => rec.id_ds_cmpt_mkt_rel);
                    add_attribute(io_item_elmt => l_item_elmt, i_name => 'INTERNAL_NAME', i_value => rec.internal_name);
                
                    l_root_int_name := rec.internal_name;
                    l_root_node     := xmldom.appendchild(l_ds_form_node, xmldom.makenode(l_item_elmt));
                ELSIF rec.flg_component_type = pk_dynamic_screen.c_node_component
                      AND (rec.internal_name != l_section_int_name OR l_section_int_name IS NULL)
                THEN
                    l_item_elmt := xmldom.createelement(l_doc, 'SECTION');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_DS_CMPT_MKT_REL',
                                  i_value      => rec.id_ds_cmpt_mkt_rel);
                    add_attribute(io_item_elmt => l_item_elmt, i_name => 'INTERNAL_NAME', i_value => rec.internal_name);
                
                    l_section_int_name := rec.internal_name;
                    l_section_node     := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
                ELSIF rec.flg_component_type = pk_dynamic_screen.c_leaf_component
                THEN
                    l_item_elmt := xmldom.createelement(l_doc, 'LEAF');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_DS_CMPT_MKT_REL',
                                  i_value      => rec.id_ds_cmpt_mkt_rel);
                    add_attribute(io_item_elmt => l_item_elmt, i_name => 'INTERNAL_NAME', i_value => rec.internal_name);
                    add_attribute(io_item_elmt => l_item_elmt, i_name => 'NODE_NAME', i_value => rec.node_name);
                
                    l_leaf_node := xmldom.appendchild(l_section_node, xmldom.makenode(l_item_elmt));
                ELSE
                    NULL;
                END IF;
            END LOOP;
        
            --g_error := 'WRITE XML DOC TO CLOB';
            --pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            dbms_lob.createtemporary(l_ret, TRUE);
            xmldom.writetoclob(l_doc, l_ret);
            xmldom.freedocument(l_doc);
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_ds_leaf_path;
    --

    /**********************************************************************************************
    * Get node and leaf internal name
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_diagnosis              Diagnosis id
    *
    * @return                         Leaf path
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          02-04-2014
    **********************************************************************************************/
    FUNCTION get_ds_leaf_path
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_diagnosis IN diagnosis.id_diagnosis%TYPE
    ) RETURN CLOB IS
    BEGIN
        RETURN pk_diagnosis_core.get_ds_leaf_path(i_lang      => i_lang,
                                                  i_prof      => i_prof,
                                                  i_diag_type => pk_diagnosis_core.get_diag_type(i_lang         => i_lang,
                                                                                                 i_prof         => i_prof,
                                                                                                 i_concept_type => NULL,
                                                                                                 i_diagnosis    => i_diagnosis));
    END get_ds_leaf_path;
    --
    /**********************************************************************************************
    * Get diagnoses types
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_tbl_diagnosis          Table of diagnosis id's
    * @param o_diag_type              For each received diagnosis tells the diagnosis type and ds leaf path
    * @param o_error                  Error message
    *
    * @return                         true or false para sucesso ou erro
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          22-08-2013
    **********************************************************************************************/
    FUNCTION get_diag_type
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_tbl_diagnosis IN table_number,
        o_diag_type     OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'GET_DIAG_TYPE';
    BEGIN
        g_error := 'OPEN O_DIAG CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_diag_type FOR
            SELECT a.id_diagnosis,
                   a.flg_diag_type,
                   pk_diagnosis_core.get_ds_leaf_path(i_lang                => i_lang,
                                                      i_prof                => i_prof,
                                                      i_diag_type           => a.flg_diag_type,
                                                      i_allow_complications => pk_alert_constant.g_yes) ds_leafs_path
              FROM (SELECT t.column_value id_diagnosis,
                           pk_diagnosis_core.get_diag_type(i_lang         => i_lang,
                                                           i_prof         => i_prof,
                                                           i_concept_type => NULL,
                                                           i_diagnosis    => t.column_value) flg_diag_type
                      FROM TABLE(i_tbl_diagnosis) t) a;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_diag_type);
            RETURN FALSE;
    END get_diag_type;
    --
    /**********************************************************************************************
    * Actualizar o historico do episodio do diagnostico sempre que alterado o seu estado
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_episode                episode id
    * @param i_epis_diag              diagnosis episode id
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/11/24
    **********************************************************************************************/
    FUNCTION set_epis_diag_hist_internal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_sysdate        IN TIMESTAMP WITH LOCAL TIME ZONE,
        o_epis_diag_hist OUT epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_HIST_INTERNAL';
        --
        l_rec_epis_diag_hist epis_diagnosis_hist%ROWTYPE;
    BEGIN
        IF i_sysdate IS NULL
        THEN
            g_sysdate      := SYSDATE;
            g_sysdate_tstz := current_timestamp;
        ELSE
            g_sysdate      := i_sysdate;
            g_sysdate_tstz := i_sysdate;
        END IF;
        --
        g_error := 'GET TS_EPIS_DIAGNOSIS_HIST.NEXT_KEY';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        o_epis_diag_hist := ts_epis_diagnosis_hist.next_key;
        --
        g_error := 'GET EPIS_DIAG DATA';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT o_epis_diag_hist id_epis_diagnosis_hist,
               ed.id_epis_diagnosis,
               pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                    i_prof,
                                                    ed.flg_status,
                                                    ed.id_professional_diag,
                                                    ed.id_prof_confirmed,
                                                    ed.id_professional_cancel,
                                                    ed.id_prof_base,
                                                    ed.id_prof_rulled_out) id_professional,
               ed.flg_status,
               ed.flg_type,
               decode(ed.flg_status, pk_diagnosis.g_ed_flg_status_ca, notes_cancel, notes) notes,
               ed.flg_final_type,
               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                  i_prof,
                                                  ed.flg_status,
                                                  ed.dt_epis_diagnosis_tstz,
                                                  ed.dt_confirmed_tstz,
                                                  ed.dt_cancel_tstz,
                                                  ed.dt_base_tstz,
                                                  ed.dt_rulled_out_tstz) dt_creation_tstz,
               g_sysdate_tstz adw_last_update,
               ed.id_cancel_reason,
               ed.id_episode_origin,
               ed.flg_add_problem,
               ed.id_cdr_call,
               ed.dt_initial_diag,
               ed.id_diag_basis,
               ed.id_dbasis_inst_owner,
               ed.diag_basis_spec,
               ed.flg_recurrence,
               ed.flg_mult_tumors,
               ed.num_primary_tumors,
               ed.id_diagnosis_condition,
               ed.id_diagcond_inst_owner,
               ed.id_sub_analysis,
               ed.id_subanaly_inst_owner,
               ed.id_anatomical_area,
               ed.id_anatarea_inst_owner,
               ed.id_anatomical_side,
               ed.id_anatside_inst_owner,
               ed.id_lesion_location,
               ed.id_lesion_locat_inst_owner,
               ed.id_lesion_type,
               ed.id_lesion_type_inst_owner,
               ed.rank
          INTO l_rec_epis_diag_hist.id_epis_diagnosis_hist,
               l_rec_epis_diag_hist.id_epis_diagnosis,
               l_rec_epis_diag_hist.id_professional,
               l_rec_epis_diag_hist.flg_status,
               l_rec_epis_diag_hist.flg_type,
               l_rec_epis_diag_hist.notes,
               l_rec_epis_diag_hist.flg_final_type,
               l_rec_epis_diag_hist.dt_creation_tstz,
               l_rec_epis_diag_hist.adw_last_update,
               l_rec_epis_diag_hist.id_cancel_reason,
               l_rec_epis_diag_hist.id_episode_origin,
               l_rec_epis_diag_hist.flg_add_problem,
               l_rec_epis_diag_hist.id_cdr_call,
               l_rec_epis_diag_hist.dt_initial_diag,
               l_rec_epis_diag_hist.id_diag_basis,
               l_rec_epis_diag_hist.id_dbasis_inst_owner,
               l_rec_epis_diag_hist.diag_basis_spec,
               l_rec_epis_diag_hist.flg_recurrence,
               l_rec_epis_diag_hist.flg_mult_tumors,
               l_rec_epis_diag_hist.num_primary_tumors,
               l_rec_epis_diag_hist.id_diagnosis_condition,
               l_rec_epis_diag_hist.id_diagcond_inst_owner,
               l_rec_epis_diag_hist.id_sub_analysis,
               l_rec_epis_diag_hist.id_subanaly_inst_owner,
               l_rec_epis_diag_hist.id_anatomical_area,
               l_rec_epis_diag_hist.id_anatarea_inst_owner,
               l_rec_epis_diag_hist.id_anatomical_side,
               l_rec_epis_diag_hist.id_anatside_inst_owner,
               l_rec_epis_diag_hist.id_lesion_location,
               l_rec_epis_diag_hist.id_lesion_locat_inst_owner,
               l_rec_epis_diag_hist.id_lesion_type,
               l_rec_epis_diag_hist.id_lesion_type_inst_owner,
               l_rec_epis_diag_hist.rank
          FROM epis_diagnosis ed
         WHERE ed.id_epis_diagnosis = i_epis_diag;
    
        --
        g_error := 'INSERT EPIS_DIAGNOSIS_HIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        ts_epis_diagnosis_hist.ins(rec_in => l_rec_epis_diag_hist);
        --
    
        g_error := 'CALL TO SET_FIRST_OBS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => i_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => g_sysdate_tstz,
                                      i_dt_first_obs        => g_sysdate_tstz,
                                      o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diag_hist_internal;
    --
    /**********************************************************************************************
    * Sets a diagnosis history record. Used to insert records with a date prior to the current record date
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis_hist    List of attributes to save in the history record
    * @param o_epis_diag_hist         new history record ID
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.1.3
    * @since                          14-10-2011
    **********************************************************************************************/
    FUNCTION set_epis_diag_hist_internal
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_diagnosis_hist IN epis_diagnosis_hist%ROWTYPE,
        o_epis_diag_hist      OUT epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_HIST_INTERNAL';
        --
        l_rec_epis_diag_hist epis_diagnosis_hist%ROWTYPE;
    BEGIN
        l_rec_epis_diag_hist := i_epis_diagnosis_hist;
        --
        g_error := 'GET SEQ_EPIS_DIAGNOSIS_HIST.NEXTVAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_rec_epis_diag_hist.id_epis_diagnosis_hist := ts_epis_diagnosis_hist.next_key;
        --
        g_error := 'INSERT EPIS_DIAGNOSIS_HIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        ts_epis_diagnosis_hist.ins(rec_in => l_rec_epis_diag_hist);
        --
        o_epis_diag_hist := l_rec_epis_diag_hist.id_epis_diagnosis_hist;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diag_hist_internal;
    --
    /**********************************************************************************************
    * Gets the history specific notes
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids 
    * @param i_epis_diagnosis         episode diagnosis ID           
    * @param i_dt_creation            history creation date
    * @param i_flg_status             history diagnosis status
    * @param i_notes                  history diagnosis notes
    *
    * @return                         specific notes
    *                        
    * @author                         José Silva
    * @version                        1.0 
    * @since                          2009/11/06
    **********************************************************************************************/
    FUNCTION get_hist_specific_notes
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN epis_diagnosis_hist.id_epis_diagnosis%TYPE,
        i_dt_creation    IN epis_diagnosis_hist.dt_creation_tstz%TYPE,
        i_flg_status     IN epis_diagnosis_hist.flg_status%TYPE,
        i_notes          IN epis_diagnosis_hist.notes%TYPE
    ) RETURN VARCHAR2 IS
    
        l_notes epis_diagnosis_hist.notes%TYPE;
    
        CURSOR c_epis_diagnosis IS
            SELECT edh.notes
              FROM epis_diagnosis_hist edh
             WHERE edh.id_epis_diagnosis = i_epis_diagnosis
               AND edh.dt_creation_tstz < i_dt_creation
             ORDER BY edh.dt_creation_tstz DESC;
    
    BEGIN
    
        IF i_flg_status = pk_diagnosis.g_ed_flg_status_ca
        THEN
            OPEN c_epis_diagnosis;
            FETCH c_epis_diagnosis
                INTO l_notes;
            CLOSE c_epis_diagnosis;
        ELSE
            l_notes := i_notes;
        END IF;
    
        RETURN l_notes;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_hist_specific_notes;
    --
    /**********************************************************************************************
    * Gets the register date of a diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids 
    * @param i_flg_status             episode diagnosis status           
    * @param i_dt_epis_diagnosis      diagnosis date (in investigation)
    * @param i_dt_confirmed           diagnosis date (confirmed)
    * @param i_dt_cancel              diagnosis date (cancelled)
    * @param i_dt_base                diagnosis date (base)
    * @param i_dt_rulled_out          diagnosis date (rulled out)
    *
    * @return                         record date
    *                        
    * @author                         José Silva
    * @version                        2.6.1.3 
    * @since                          13-10-2011
    **********************************************************************************************/
    FUNCTION get_dt_diagnosis
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_flg_status        IN epis_diagnosis.flg_status%TYPE,
        i_dt_epis_diagnosis IN epis_diagnosis.dt_epis_diagnosis_tstz%TYPE,
        i_dt_confirmed      IN epis_diagnosis.dt_confirmed_tstz%TYPE,
        i_dt_cancel         IN epis_diagnosis.dt_cancel_tstz%TYPE,
        i_dt_base           IN epis_diagnosis.dt_base_tstz%TYPE,
        i_dt_rulled_out     IN epis_diagnosis.dt_rulled_out_tstz%TYPE
    ) RETURN epis_diagnosis.dt_epis_diagnosis_tstz%TYPE IS
    
        l_dt_diagnosis epis_diagnosis.dt_epis_diagnosis_tstz%TYPE;
    
    BEGIN
    
        l_dt_diagnosis := CASE i_flg_status
                              WHEN pk_diagnosis.g_ed_flg_status_d THEN
                               i_dt_epis_diagnosis
                              WHEN pk_diagnosis.g_ed_flg_status_co THEN
                               i_dt_confirmed
                              WHEN pk_diagnosis.g_ed_flg_status_ca THEN
                               i_dt_cancel
                              WHEN pk_diagnosis.g_ed_flg_status_b THEN
                               i_dt_base
                              WHEN pk_diagnosis.g_ed_flg_status_r THEN
                               i_dt_rulled_out
                              WHEN pk_diagnosis.g_ed_flg_status_p THEN
                               i_dt_epis_diagnosis
                              ELSE
                               NULL
                          END;
    
        RETURN l_dt_diagnosis;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_dt_diagnosis;
    --
    /**********************************************************************************************
    * Gets the professional that registered the diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids 
    * @param i_flg_status             episode diagnosis status           
    * @param i_professional_diag      professional ID (in investigation)
    * @param i_prof_confirmed         professional ID (confirmed)
    * @param i_professional_cancel    professional ID (cancelled)
    * @param i_prof_base              professional ID (base)
    * @param i_prof_rulled_out        professional ID (rulled out)
    *
    * @return                         professional ID
    *                        
    * @author                         José Silva
    * @version                        2.6.1.3 
    * @since                          13-10-2011
    **********************************************************************************************/
    FUNCTION get_prof_diagnosis
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_flg_status          IN epis_diagnosis.flg_status%TYPE,
        i_professional_diag   IN epis_diagnosis.id_professional_diag%TYPE,
        i_prof_confirmed      IN epis_diagnosis.id_prof_confirmed%TYPE,
        i_professional_cancel IN epis_diagnosis.id_professional_cancel%TYPE,
        i_prof_base           IN epis_diagnosis.id_prof_base%TYPE,
        i_prof_rulled_out     IN epis_diagnosis.id_prof_rulled_out%TYPE
    ) RETURN epis_diagnosis.id_professional_diag%TYPE IS
    
        l_id_professional epis_diagnosis.id_professional_diag%TYPE;
    
    BEGIN
    
        l_id_professional := CASE i_flg_status
                                 WHEN pk_diagnosis.g_ed_flg_status_d THEN
                                  i_professional_diag
                                 WHEN pk_diagnosis.g_ed_flg_status_co THEN
                                  i_prof_confirmed
                                 WHEN pk_diagnosis.g_ed_flg_status_ca THEN
                                  i_professional_cancel
                                 WHEN pk_diagnosis.g_ed_flg_status_b THEN
                                  i_prof_base
                                 WHEN pk_diagnosis.g_ed_flg_status_r THEN
                                  i_prof_rulled_out
                                 WHEN pk_diagnosis.g_ed_flg_status_p THEN
                                  i_professional_diag
                                 ELSE
                                  NULL
                             END;
    
        RETURN l_id_professional;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_prof_diagnosis;
    --
    /********************************************************************************************
    * Get the last history ID of an episode diagnosis record
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Professional identification and its context (institution and software)
    * @param i_epis_diagnosis         Episode diagnosis ID
    * 
    * @return                         Diagnosis history ID
    * 
    * @author                         José Silva
    * @version                        2.6.1.2   
    * @since                          2007/09/21
    **********************************************************************************************/
    FUNCTION get_last_epis_diag_hist
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE
    ) RETURN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE IS
    
        l_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
        l_error          t_error_out;
    
        CURSOR c_epis_diag IS
            SELECT eh.id_epis_diagnosis_hist
              FROM epis_diagnosis_hist eh
             WHERE eh.id_epis_diagnosis = i_epis_diagnosis
             ORDER BY eh.dt_creation_tstz DESC;
    
    BEGIN
    
        OPEN c_epis_diag;
    
        FETCH c_epis_diag
            INTO l_epis_diag_hist;
    
        CLOSE c_epis_diag;
    
        RETURN l_epis_diag_hist;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_LAST_EPIS_DIAG_HIST',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_last_epis_diag_hist;
    --
    /**
    * Get AE diagnosis description
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_epis_diagnosis            Epis diagnosis id
    * @param   i_ed_rowtype                Row type sent in Global search trigger
    *
    * @return  AE_Diagnosis description
    *
    * @author  Alexandre Santos
    * @version v2.6.3.7.1
    * @since   28-08-2013
    */
    FUNCTION get_ae_diag_desc
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_ed_rowtype     IN epis_diagnosis%ROWTYPE DEFAULT NULL
    ) RETURN pk_translation.t_desc_translation IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_AE_DIAG_DESC';
        --
        TYPE table_sub_analysis IS TABLE OF pk_diagnosis_form.c_sub_analysis%ROWTYPE;
        TYPE table_anatomical_area IS TABLE OF pk_diagnosis_form.c_anatomical_area%ROWTYPE;
        TYPE table_anatomical_side IS TABLE OF pk_diagnosis_form.c_anatomical_side%ROWTYPE;
        --
        l_tbl_sub_analysis table_sub_analysis;
        l_tbl_anat_area    table_anatomical_area;
        l_tbl_anat_side    table_anatomical_side;
        --
        l_diag_type               diagnosis.concept_type_int_name%TYPE;
        l_sub_analysis_concept    diagnosis_ea.id_concept_version%TYPE;
        l_anatomical_area_concept diagnosis_ea.id_concept_version%TYPE;
        --
        r_ed epis_diagnosis%ROWTYPE;
        --
        l_desc pk_translation.t_desc_translation;
        --
        PROCEDURE conc_desc
        (
            io_desc    IN OUT pk_translation.t_desc_translation,
            i_conc_str IN pk_translation.t_desc_translation
        ) IS
        BEGIN
            IF i_conc_str IS NOT NULL
            THEN
                IF io_desc IS NOT NULL
                THEN
                    io_desc := io_desc || ', ';
                END IF;
            
                io_desc := io_desc || i_conc_str;
            END IF;
        END conc_desc;
    BEGIN
        l_desc := NULL;
    
        IF i_epis_diagnosis IS NOT NULL
           OR i_ed_rowtype.id_epis_diagnosis IS NOT NULL
        THEN
            IF i_ed_rowtype.id_epis_diagnosis IS NOT NULL
            THEN
                r_ed := i_ed_rowtype;
            ELSE
                g_error := 'GET EPIS_DIAGNOSIS RECORD';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT *
                  INTO r_ed
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = i_epis_diagnosis;
            END IF;
        
            g_error := 'ADD SUB_ANALYSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF r_ed.id_sub_analysis IS NOT NULL
            THEN
                g_error := 'GET DIAG_TYPE OF ID_DIAG: ' || r_ed.id_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT d.concept_type_int_name
                  INTO l_diag_type
                  FROM diagnosis d
                 WHERE d.id_diagnosis = r_ed.id_diagnosis;
            
                g_error := 'OPEN CURSOR C_SUB_ANALYSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN pk_diagnosis_form.c_sub_analysis(i_lang            => i_lang,
                                                      i_prof            => i_prof,
                                                      i_diagnosis       => r_ed.id_diagnosis,
                                                      i_alert_diagnosis => r_ed.id_alert_diagnosis,
                                                      i_diag_type       => l_diag_type,
                                                      i_show_code       => pk_alert_constant.g_no);
            
                g_error := 'BULK COLLECT C_SUB_ANALYSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FETCH pk_diagnosis_form.c_sub_analysis BULK COLLECT
                    INTO l_tbl_sub_analysis;
            
                g_error := 'CLOSE C_SUB_ANALYSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                CLOSE pk_diagnosis_form.c_sub_analysis;
            
                IF l_tbl_sub_analysis.exists(1)
                   AND l_tbl_sub_analysis.count > 1
                THEN
                    g_error := 'FIND ID_SUB_ANALYSIS: ' || r_ed.id_sub_analysis;
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    FOR i IN l_tbl_sub_analysis.first .. l_tbl_sub_analysis.last
                    LOOP
                        IF l_tbl_sub_analysis(i).id_sub_analysis = r_ed.id_sub_analysis
                        THEN
                            g_error := 'CONCATENATE DESC: ' || l_tbl_sub_analysis(i).desc_sub_analysis;
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            conc_desc(io_desc => l_desc, i_conc_str => l_tbl_sub_analysis(i).desc_sub_analysis);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            g_error := 'ADD ANATOMICAL_AREA';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF r_ed.id_anatomical_area IS NOT NULL
            THEN
                g_error := 'GET DIAG_TYPE OF ID_DIAG: ' || r_ed.id_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT d.concept_type_int_name
                  INTO l_diag_type
                  FROM diagnosis d
                 WHERE d.id_diagnosis = r_ed.id_diagnosis;
            
                g_error := 'GET SUB_ANALYSIS CONCEPT_VERSION';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                BEGIN
                    SELECT d.id_diagnosis
                      INTO l_sub_analysis_concept
                      FROM alert_diagnosis d
                     WHERE d.id_alert_diagnosis = r_ed.id_sub_analysis;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_sub_analysis_concept := NULL;
                END;
            
                g_error := 'OPEN CURSOR C_ANATOMICAL_AREA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN pk_diagnosis_form.c_anatomical_area(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_diagnosis    => r_ed.id_diagnosis,
                                                         i_diag_type    => l_diag_type,
                                                         i_sub_analysis => l_sub_analysis_concept,
                                                         i_show_code    => pk_alert_constant.g_no);
            
                g_error := 'BULK COLLECT C_ANATOMICAL_AREA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FETCH pk_diagnosis_form.c_anatomical_area BULK COLLECT
                    INTO l_tbl_anat_area;
            
                g_error := 'CLOSE C_ANATOMICAL_AREA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                CLOSE pk_diagnosis_form.c_anatomical_area;
            
                IF l_tbl_anat_area.exists(1)
                   AND l_tbl_anat_area.count > 1
                THEN
                    g_error := 'FIND ID_ANATOMICAL_AREA: ' || r_ed.id_anatomical_area;
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    FOR i IN l_tbl_anat_area.first .. l_tbl_anat_area.last
                    LOOP
                        IF l_tbl_anat_area(i).id_anatomical_area = r_ed.id_anatomical_area
                        THEN
                            g_error := 'CONCATENATE DESC: ' || l_tbl_anat_area(i).desc_anatomical_area;
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            conc_desc(io_desc => l_desc, i_conc_str => l_tbl_anat_area(i).desc_anatomical_area);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            g_error := 'ADD ANATOMICAL_SIDE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF r_ed.id_anatomical_side IS NOT NULL
            THEN
                g_error := 'GET DIAG_TYPE OF ID_DIAG: ' || r_ed.id_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT d.concept_type_int_name
                  INTO l_diag_type
                  FROM diagnosis d
                 WHERE d.id_diagnosis = r_ed.id_diagnosis;
            
                g_error := 'GET ANATOMICAL_AREA CONCEPT_VERSION';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                BEGIN
                    SELECT d.id_diagnosis
                      INTO l_anatomical_area_concept
                      FROM alert_diagnosis d
                     WHERE d.id_alert_diagnosis = r_ed.id_anatomical_area;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_anatomical_area_concept := NULL;
                END;
            
                g_error := 'OPEN CURSOR C_ANATOMICAL_SIDE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN pk_diagnosis_form.c_anatomical_side(i_lang            => i_lang,
                                                         i_prof            => i_prof,
                                                         i_diagnosis       => r_ed.id_diagnosis,
                                                         i_diag_type       => l_diag_type,
                                                         i_anatomical_area => l_anatomical_area_concept,
                                                         i_show_code       => pk_alert_constant.g_no);
            
                g_error := 'BULK COLLECT C_ANATOMICAL_SIDE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FETCH pk_diagnosis_form.c_anatomical_side BULK COLLECT
                    INTO l_tbl_anat_side;
            
                g_error := 'CLOSE C_ANATOMICAL_SIDE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                CLOSE pk_diagnosis_form.c_anatomical_side;
            
                IF l_tbl_anat_side.exists(1)
                   AND l_tbl_anat_side.count > 1
                THEN
                    g_error := 'FIND ID_ANATOMICAL_SIDE: ' || r_ed.id_anatomical_side;
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    FOR i IN l_tbl_anat_side.first .. l_tbl_anat_side.last
                    LOOP
                        IF l_tbl_anat_side(i).id_anatomical_side = r_ed.id_anatomical_side
                        THEN
                            g_error := 'CONCATENATE DESC: ' || l_tbl_anat_side(i).desc_anatomical_side;
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            conc_desc(io_desc => l_desc, i_conc_str => l_tbl_anat_side(i).desc_anatomical_side);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    
        RETURN l_desc;
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  l_error);
            END;
        
            RETURN NULL;
    END get_ae_diag_desc;
    --
    /********************************************************************************************
    * Constroi a descricao do diagnostico que deve ser mostrada (com ou sem codigo)
    *
    * @param i_desc                   Descricao do diagnostico
    * @param i_code                   Codigo do ICD
    * @param i_show_code              Flag que indica se o codigoo do diagnostico deve ser visualizado
    * @param i_flg_other              Flag que indica se o diagnostico e do tipo "outro"
    * @param i_aditional_info         Aditional information regarding the diagnose (ALERT-81543)
    * 
    * @return                         Descricao que vai ser mostrada
    * 
    * @author                         Luis Oliveira
    * @version                        1.0   
    * @since                          2007/06/06
    **********************************************************************************************/
    FUNCTION diag_desc
    (
        i_desc           IN pk_translation.t_desc_translation,
        i_code           IN diagnosis.code_icd%TYPE,
        i_show_code      IN sys_config.value%TYPE,
        i_flg_other      IN diagnosis.flg_other%TYPE,
        i_aditional_info IN VARCHAR2 DEFAULT NULL,
        i_cancer_info    IN VARCHAR2 DEFAULT NULL,
        i_term_code      IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_desc pk_translation.t_desc_translation;
    BEGIN
        IF i_desc IS NULL
        THEN
            RETURN NULL;
        END IF;
        IF nvl(i_show_code, pk_alert_constant.g_no) = pk_alert_constant.g_no
           OR nvl(i_flg_other, pk_alert_constant.g_no) = pk_alert_constant.g_yes
           OR i_code IS NULL
        THEN
            l_desc := i_desc;
        ELSE
            -- Diagnosis code may appear before or after description,
            -- depending on the configuration ("S"tart or "E"nd);
            -- Should any previous configuration still be set to "Y",
            -- this process will treat it as if it was "E";
            IF i_show_code = pk_diagnosis.g_code_format_start
            THEN
                IF TRIM(i_code) IS NOT NULL
                THEN
                    l_desc := '(' || i_code || ') ';
                END IF;
            
                IF TRIM(i_term_code) IS NOT NULL
                THEN
                    l_desc := l_desc || ' (' || i_term_code || ') ';
                END IF;
            
                l_desc := l_desc || i_desc;
            ELSIF i_show_code = pk_diagnosis.g_code_format_end
            THEN
                IF TRIM(i_code) IS NOT NULL
                THEN
                    l_desc := i_desc || ' (' || i_code || ')';
                ELSE
                    l_desc := i_desc;
                END IF;
            
                IF TRIM(i_term_code) IS NOT NULL
                THEN
                    l_desc := l_desc || ' (' || i_term_code || ')';
                END IF;
            ELSE
                l_desc := i_desc;
            END IF;
        END IF;
    
        IF TRIM(i_cancer_info) IS NOT NULL
        THEN
            l_desc := l_desc || ' - ' || i_cancer_info;
        END IF;
    
        IF TRIM(i_aditional_info) IS NOT NULL
        THEN
            l_desc := l_desc || ' (' || i_aditional_info || ')';
        END IF;
    
        RETURN l_desc;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END diag_desc;

    /********************************************************************************************
    * Use diffrent type to get diagnosis description
    *
    * @param i_lang                   language id
    * @param i_prof                   professional id (type: professional id, institution id and software id)
    * @param i_desc                   Descricao do diagnostico
    * @param i_code                   Codigo do ICD
    * @param i_show_code              Flag que indica se o codigoo do diagnostico deve ser visualizado
    * @param i_flg_other              Flag que indica se o diagnostico e do tipo "outro"
    * @param i_aditional_info         Aditional information regarding the diagnose (ALERT-81543)
    * @param i_flg_status             For show Active,Inactive... status
    * @param i_flg_type               For show problem-P,past hisotry medical-H
    * 
    * @return                         Description
    * 
    * @author                         Amanda Lee
    * @version                        2.7.2.0   
    * @since                          2017/11/10
    **********************************************************************************************/
    FUNCTION diag_desc_from_para
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_desc       IN pk_translation.t_desc_translation,
        i_code       IN diagnosis.code_icd%TYPE,
        i_show_code  IN sys_config.value%TYPE,
        i_flg_other  IN diagnosis.flg_other%TYPE,
        i_term_code  IN VARCHAR2 DEFAULT NULL,
        i_flg_status IN VARCHAR2 DEFAULT NULL,
        i_flg_type   IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_desc pk_translation.t_desc_translation;
    
        l_status_desc VARCHAR2(100 CHAR);
        l_type_desc   VARCHAR2(200 CHAR);
        l_space       VARCHAR2(2 CHAR) := ' ';
    BEGIN
        l_desc := diag_desc(i_desc      => i_desc,
                            i_code      => i_code,
                            i_show_code => i_show_code,
                            i_flg_other => i_flg_other,
                            i_term_code => i_term_code);
    
        pk_alertlog.log_info('l_desc=' || l_desc || ',i_flg_type=' || i_flg_type);
        --For new filter description ex: Active(Past history Medical) 
        IF (i_flg_status IS NOT NULL AND i_flg_type IS NOT NULL)
        THEN
            --Get status description ex:A=Active, I=Inactive
            SELECT sd.desc_val
              INTO l_status_desc
              FROM sys_domain sd
             WHERE sd.id_language = i_lang
               AND sd.code_domain = 'PAT_PROBLEM.FLG_STATUS'
               AND sd.val = i_flg_status;
        
            --Regen status ex: (Active) 
            IF l_status_desc IS NOT NULL
            THEN
                l_status_desc := pk_problems.g_open_parentheses || l_status_desc || pk_problems.g_close_parentheses;
            END IF;
        
            --Conbine status and type ex: (Active) (Problems)
            --It is show(Ex.AAAA(A001)(Active)(Problems)) when the data in past_history_diagnosis and pat_problem 
            IF i_flg_type IN (pk_problems.g_prob, pk_problems.g_pat_problem)
            THEN
                l_type_desc := pk_problems.g_open_parentheses ||
                               pk_message.get_message(i_lang      => i_lang,
                                                      i_prof      => i_prof,
                                                      i_code_mess => 'PROBLEMS_T026') ||
                               pk_problems.g_close_parentheses;
            ELSIF i_flg_type = pk_problems.g_ph_medical_hist
            THEN
                l_type_desc := pk_problems.g_open_parentheses ||
                               pk_message.get_message(i_lang      => i_lang,
                                                      i_prof      => i_prof,
                                                      i_code_mess => 'PROBLEMS_T020') ||
                               pk_problems.g_close_parentheses;
            END IF;
        
            l_desc := l_desc || l_space || l_status_desc || l_space || l_type_desc;
        END IF;
        RETURN l_desc;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END diag_desc_from_para;
    --
    /********************************************************************************************
    * builds a standard formatted diagnosis description that is displayed to the user (with or without code and synonym indication)
    *
    * @param i_lang           language id
    * @param i_prof           professional id (type: professional id, institution id and software id)
    * @param i_desc           diagnosis description
    * @param i_code           diagnosis code
    * @param i_flg_other      flag which indicates if the diagnosis is "Other" or an official one
    * @param i_flg_std_diag   flag which indicates if the diagnosis is the standard one or one of the synonyms
    * @param i_epis_diag      When filled adds additional information to diagnosis, for instance, the state description and date (ALERT-81543)
    * @param i_flg_past_hist  Show the description in the past history area: Yes or No
    * @param i_ed_rowtype              Row type sent in Global search trigger
    * @param i_flg_show_if_principal   Show 'Principal diagnosis' when aplicable, i_show_aditional_info as to be 'Y'
    * @param i_flg_status              For show Active,Inactive... status
    * @param i_flg_type                For show problem-P,past hisotry medical-H
    * 
    * @return                 formatted text containing the diagnosis description
    * 
    * @author                 Sergio Dias
    * @version                2.0
    * @since                  7/Fev/2012
    **********************************************************************************************/
    FUNCTION std_diag_desc
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_diagnosis          IN diagnosis.id_diagnosis%TYPE DEFAULT NULL,
        i_desc                  IN pk_translation.t_desc_translation,
        i_code                  IN diagnosis.code_icd%TYPE,
        i_flg_other             IN diagnosis.flg_other%TYPE,
        i_flg_std_diag          IN alert_diagnosis.flg_icd9%TYPE,
        i_epis_diag             IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_show_aditional_info   IN VARCHAR2,
        i_flg_past_hist         IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_search_mode       IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_show_term_code    IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_show_ae_diag_info IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        i_ed_rowtype            IN epis_diagnosis%ROWTYPE DEFAULT NULL,
        i_flg_show_if_principal IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_show_dt_initial   IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_flg_status            IN VARCHAR2 DEFAULT NULL,
        i_flg_type              IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_desc           pk_translation.t_desc_translation;
        l_acc_emer_desc  pk_translation.t_desc_translation;
        l_aditional_info pk_translation.t_desc_translation;
        l_past_hist_info pk_translation.t_desc_translation;
        l_cancer_info    pk_translation.t_desc_translation;
        --
        l_msg_report  CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M037';
        l_cfg_diff    CONSTANT sys_config.id_sys_config%TYPE := 'DIAGNOSIS_DIFF_T022';
        l_cfg_final   CONSTANT sys_config.id_sys_config%TYPE := 'DIAGNOSIS_FINAL_T023';
        l_cfg_primary CONSTANT sys_config.id_sys_config%TYPE := 'PREV_EPISODE_T991';
        --
        l_code_diagnosis_condition diagnosis.code_icd%TYPE;
        l_code_sub_analysis        diagnosis.code_icd%TYPE;
        l_code_anatomical_area     diagnosis.code_icd%TYPE;
        l_code_anatomical_side     diagnosis.code_icd%TYPE;
        --
        l_diagnosis_condition epis_diagnosis.id_diagnosis_condition%TYPE;
        l_sub_analysis        epis_diagnosis.id_sub_analysis%TYPE;
        l_anatomical_area     epis_diagnosis.id_anatomical_area%TYPE;
        l_anatomical_side     epis_diagnosis.id_anatomical_side%TYPE;
        --
        l_code            diagnosis.code_icd%TYPE;
        l_tnm             pk_edis_types.rec_in_tnm;
        l_flg_diag_type   VARCHAR2(1 CHAR);
        l_staging_group   epis_diag_stag.id_staging_group%TYPE;
        l_other_stag_sys  epis_diag_stag.id_other_staging_sys%TYPE;
        l_flg_mult_tumors epis_diagnosis.flg_mult_tumors%TYPE;
        l_num_prim_tumors epis_diagnosis.num_primary_tumors%TYPE;
        --
        l_term_code          terminology.abbreviation%TYPE;
        l_id_diagnosis       diagnosis.id_diagnosis%TYPE;
        l_id_diag_inst_owner epis_diagnosis.id_diag_inst_owner%TYPE;
        l_diagnosis_language language.id_language%TYPE;
    BEGIN
        -- get alert_diagnosis language id
        BEGIN
            SELECT ad.id_language
              INTO l_diagnosis_language
              FROM alert_diagnosis ad
             WHERE ad.id_diagnosis = i_id_diagnosis
               AND rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                l_diagnosis_language := i_lang;
        END;
    
        IF i_flg_std_diag = g_diag_synonym_term
           AND pk_sysconfig.get_config('DIAGNOSIS_SYNONYMS_TAG', i_prof) = pk_alert_constant.g_yes
        THEN
            l_desc := i_desc || ' ' || pk_message.get_message(l_diagnosis_language, i_prof, 'COMMON_T014');
        ELSE
            l_desc := i_desc;
        END IF;
    
        IF i_flg_std_diag = g_diag_reportable_term
        THEN
            l_code := REPLACE(pk_message.get_message(i_lang, i_prof, l_msg_report), '@1', i_code);
        ELSE
            l_code := i_code;
        END IF;
    
        IF i_flg_show_term_code = pk_alert_constant.g_yes
        THEN
            IF i_id_diagnosis IS NOT NULL
            THEN
            
                l_id_diagnosis := i_id_diagnosis;
            ELSE
                IF i_ed_rowtype.id_diagnosis IS NOT NULL
                THEN
                    l_id_diagnosis := i_ed_rowtype.id_diagnosis;
                ELSIF i_epis_diag IS NOT NULL
                THEN
                    SELECT ed.id_diagnosis, ed.id_diag_inst_owner
                      INTO l_id_diagnosis, l_id_diag_inst_owner
                      FROM epis_diagnosis ed
                     WHERE ed.id_epis_diagnosis = i_epis_diag;
                END IF;
            END IF;
        
            IF l_id_diagnosis IS NOT NULL
            THEN
                l_term_code := pk_translation.get_translation(i_lang      => i_lang,
                                                              i_code_mess => pk_api_diagnosis_func.get_terminology_abbreviation(i_concept_version      => l_id_diagnosis,
                                                                                                                                i_cncpt_vrs_inst_owner => nvl(l_id_diag_inst_owner,
                                                                                                                                                              0)));
            END IF;
        END IF;
    
        -- If function was called in search mode, return the string with the propper format (different sys_config)
        IF i_flg_search_mode = pk_alert_constant.g_yes
        THEN
            RETURN diag_desc(i_desc      => l_desc,
                             i_code      => l_code,
                             i_show_code => pk_sysconfig.get_config('DIAGNOSIS_SHOW_CODE_SEARCH', i_prof),
                             i_flg_other => i_flg_other,
                             i_term_code => l_term_code);
        END IF;
    
        IF i_flg_search_mode = pk_alert_constant.g_diag_search_mode_x
        THEN
            RETURN diag_desc_from_para(i_lang       => i_lang,
                                       i_prof       => i_prof,
                                       i_desc       => l_desc,
                                       i_code       => l_code,
                                       i_show_code  => pk_sysconfig.get_config('DIAGNOSIS_SHOW_CODE_SEARCH', i_prof),
                                       i_flg_other  => i_flg_other,
                                       i_term_code  => l_term_code,
                                       i_flg_status => i_flg_status,
                                       i_flg_type   => i_flg_type);
        END IF;
        IF (i_epis_diag IS NOT NULL OR i_ed_rowtype.id_epis_diagnosis IS NOT NULL)
           AND i_show_aditional_info = pk_alert_constant.g_yes
        THEN
            IF i_ed_rowtype.id_epis_diagnosis IS NOT NULL
            THEN
                SELECT t.desc_diag_type || ', ' || lower(t.desc_flg_status) || nvl2(t.dt_diag, ', ' || t.dt_diag, ''),
                       lower(t.desc_flg_status)
                  INTO l_aditional_info, l_past_hist_info
                  FROM (SELECT CASE i_flg_show_if_principal
                                   WHEN pk_alert_constant.g_yes THEN
                                    pk_message.get_message(i_lang,
                                                           decode(i_ed_rowtype.flg_type,
                                                                  pk_diagnosis.g_diag_type_p,
                                                                  l_cfg_diff,
                                                                  decode(i_ed_rowtype.flg_final_type,
                                                                         pk_diagnosis.g_flg_final_type_p,
                                                                         l_cfg_primary,
                                                                         l_cfg_final)))
                                   ELSE
                                    pk_message.get_message(i_lang,
                                                           decode(i_ed_rowtype.flg_type,
                                                                  pk_diagnosis.g_diag_type_p,
                                                                  l_cfg_diff,
                                                                  l_cfg_final))
                               END desc_diag_type,
                               pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status, i_ed_rowtype.flg_status, i_lang) desc_flg_status,
                               pk_date_utils.dt_chr_tsz(i_lang,
                                                        decode(i_flg_show_dt_initial,
                                                               pk_alert_constant.g_yes,
                                                               i_ed_rowtype.dt_initial_diag,
                                                               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                                                                  i_prof,
                                                                                                  i_ed_rowtype.flg_status,
                                                                                                  i_ed_rowtype.dt_epis_diagnosis_tstz,
                                                                                                  i_ed_rowtype.dt_confirmed_tstz,
                                                                                                  i_ed_rowtype.dt_cancel_tstz,
                                                                                                  i_ed_rowtype.dt_base_tstz,
                                                                                                  i_ed_rowtype.dt_rulled_out_tstz)),
                                                        i_prof) dt_diag
                          FROM dual) t;
            ELSE
                SELECT t.desc_diag_type || ', ' || lower(t.desc_flg_status) || nvl2(t.dt_diag, ', ' || t.dt_diag, ''),
                       lower(t.desc_flg_status)
                  INTO l_aditional_info, l_past_hist_info
                  FROM (SELECT CASE i_flg_show_if_principal
                                   WHEN pk_alert_constant.g_yes THEN
                                    pk_message.get_message(i_lang,
                                                           decode(ed.flg_type,
                                                                  pk_diagnosis.g_diag_type_p,
                                                                  l_cfg_diff,
                                                                  decode(ed.flg_final_type,
                                                                         pk_diagnosis.g_flg_final_type_p,
                                                                         l_cfg_primary,
                                                                         l_cfg_final)))
                                   ELSE
                                    pk_message.get_message(i_lang,
                                                           decode(ed.flg_type,
                                                                  pk_diagnosis.g_diag_type_p,
                                                                  l_cfg_diff,
                                                                  l_cfg_final))
                               END desc_diag_type,
                               pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status, ed.flg_status, i_lang) desc_flg_status,
                               pk_date_utils.dt_chr_tsz(i_lang,
                                                        decode(i_flg_show_dt_initial,
                                                               pk_alert_constant.g_yes,
                                                               ed.dt_initial_diag,
                                                               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                                                                  i_prof,
                                                                                                  flg_status,
                                                                                                  dt_epis_diagnosis_tstz,
                                                                                                  dt_confirmed_tstz,
                                                                                                  dt_cancel_tstz,
                                                                                                  dt_base_tstz,
                                                                                                  dt_rulled_out_tstz)),
                                                        i_prof) dt_diag
                          FROM epis_diagnosis ed
                         WHERE ed.id_epis_diagnosis = i_epis_diag) t;
            END IF;
        ELSE
            l_aditional_info := NULL;
        END IF;
    
        IF i_flg_past_hist = pk_alert_constant.g_yes
        THEN
            l_aditional_info := l_past_hist_info;
        END IF;
    
        -- add cancer OR ae_diagnosis information
        IF (i_epis_diag IS NOT NULL OR i_ed_rowtype.id_epis_diagnosis IS NOT NULL)
           AND i_id_diagnosis IS NOT NULL
        THEN
            SELECT pk_diagnosis_core.get_diag_type(i_lang, i_prof, d.concept_type_int_name, i_id_diagnosis)
              INTO l_flg_diag_type
              FROM diagnosis d
             WHERE id_diagnosis = i_id_diagnosis;
        
            CASE
                WHEN l_flg_diag_type = pk_diagnosis_core.g_diag_type_cancer THEN
                    BEGIN
                        IF i_ed_rowtype.id_epis_diagnosis IS NOT NULL
                        THEN
                            l_flg_mult_tumors := i_ed_rowtype.flg_mult_tumors;
                            l_num_prim_tumors := i_ed_rowtype.num_primary_tumors;
                        ELSIF i_epis_diag IS NOT NULL
                        THEN
                            SELECT ed.flg_mult_tumors, ed.num_primary_tumors
                              INTO l_flg_mult_tumors, l_num_prim_tumors
                              FROM epis_diagnosis ed
                             WHERE ed.id_epis_diagnosis = i_epis_diag;
                        END IF;
                    
                        SELECT pk_diagnosis_core.get_term_diagnosis_id(ed.id_tnm_t, i_prof.institution, i_prof.software) id_tnm_t,
                               ed.code_tnm_t,
                               pk_diagnosis_core.get_term_diagnosis_id(ed.id_tnm_n, i_prof.institution, i_prof.software) id_tnm_n,
                               ed.code_tnm_n,
                               pk_diagnosis_core.get_term_diagnosis_id(ed.id_tnm_m, i_prof.institution, i_prof.software) id_tnm_m,
                               ed.code_tnm_m,
                               ed.id_staging_group,
                               ed.id_other_staging_sys
                          INTO l_tnm.t,
                               l_tnm.code_stage_t,
                               l_tnm.n,
                               l_tnm.code_stage_n,
                               l_tnm.m,
                               l_tnm.code_stage_m,
                               l_staging_group,
                               l_other_stag_sys
                          FROM epis_diag_stag ed
                         WHERE ed.id_epis_diagnosis = i_epis_diag;
                    
                        l_cancer_info := pk_diagnosis_core.get_desc_tnm(i_lang            => i_lang,
                                                                        i_prof            => i_prof,
                                                                        i_tnm             => l_tnm,
                                                                        i_flg_mult_tumors => l_flg_mult_tumors,
                                                                        i_num_prim_tumors => l_num_prim_tumors) ||
                                         pk_utils.append_str_if_not_null(nvl(pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                        i_prof               => i_prof,
                                                                                                        i_id_alert_diagnosis => l_staging_group,
                                                                                                        i_code               => NULL,
                                                                                                        i_flg_other          => pk_alert_constant.g_no,
                                                                                                        i_flg_std_diag       => pk_alert_constant.g_yes),
                                                                             pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                        i_prof               => i_prof,
                                                                                                        i_id_alert_diagnosis => l_other_stag_sys,
                                                                                                        i_code               => pk_diagnosis_core.get_term_diagnosis_code(l_other_stag_sys,
                                                                                                                                                                          i_prof.institution,
                                                                                                                                                                          i_prof.software),
                                                                                                        i_flg_other          => pk_alert_constant.g_no,
                                                                                                        i_flg_std_diag       => pk_alert_constant.g_yes)),
                                                                         '',
                                                                         ' ');
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_cancer_info := NULL;
                    END;
                WHEN l_flg_diag_type = pk_diagnosis_core.g_diag_type_acc_emerg
                     AND i_flg_show_ae_diag_info = pk_alert_constant.g_yes THEN
                    l_acc_emer_desc := get_ae_diag_desc(i_lang           => i_lang,
                                                        i_prof           => i_prof,
                                                        i_epis_diagnosis => i_epis_diag,
                                                        i_ed_rowtype     => i_ed_rowtype);
                
                    IF l_acc_emer_desc IS NOT NULL
                       AND l_desc IS NOT NULL
                    THEN
                        l_desc := l_desc || ', ' || l_acc_emer_desc;
                    ELSIF l_acc_emer_desc IS NOT NULL
                          AND l_desc IS NULL
                    THEN
                        l_desc := l_acc_emer_desc;
                    END IF;
                
                    IF i_ed_rowtype.id_epis_diagnosis IS NOT NULL
                    THEN
                        l_diagnosis_condition := i_ed_rowtype.id_diagnosis_condition;
                        l_sub_analysis        := i_ed_rowtype.id_sub_analysis;
                        l_anatomical_area     := i_ed_rowtype.id_anatomical_area;
                        l_anatomical_side     := i_ed_rowtype.id_anatomical_side;
                    ELSIF i_epis_diag IS NOT NULL
                    THEN
                        SELECT ed.id_diagnosis_condition,
                               ed.id_sub_analysis,
                               ed.id_anatomical_area,
                               ed.id_anatomical_side
                          INTO l_diagnosis_condition, l_sub_analysis, l_anatomical_area, l_anatomical_side
                          FROM epis_diagnosis ed
                         WHERE ed.id_epis_diagnosis = i_epis_diag;
                    END IF;
                
                    l_code_diagnosis_condition := nvl(pk_api_diagnosis_func.get_concept_code(i_concept_version => nvl(l_diagnosis_condition,
                                                                                                                      pk_diagnosis_core.get_id_diag_condition(i_prof      => i_prof,
                                                                                                                                                              i_diagnosis => i_id_diagnosis))),
                                                      '  ');
                    l_code_sub_analysis        := nvl(pk_api_diagnosis_func.get_concept_code(i_concept_version => l_sub_analysis),
                                                      ' ');
                    l_code_anatomical_area     := nvl(pk_api_diagnosis_func.get_concept_code(i_concept_version => l_anatomical_area),
                                                      '  ');
                    l_code_anatomical_side     := pk_api_diagnosis_func.get_concept_code(i_concept_version => l_anatomical_side);
                
                    l_code := rtrim(l_code_diagnosis_condition || --code_diagnosis_condition
                                    l_code_sub_analysis || --code_sub_analysis
                                    l_code_anatomical_area || --code_anatomical_area
                                    l_code_anatomical_side); --code_anatomical_side
                ELSE
                    NULL;
            END CASE;
        END IF;
    
        RETURN diag_desc(i_desc           => l_desc,
                         i_code           => l_code,
                         i_show_code      => pk_sysconfig.get_config('DIAGNOSIS_SHOW_CODE', i_prof),
                         i_flg_other      => i_flg_other,
                         i_aditional_info => l_aditional_info,
                         i_cancer_info    => l_cancer_info,
                         i_term_code      => l_term_code);
    END std_diag_desc;
    --
    /************************************************************************************************************
    * Gets the diagnosis description that is displayed to the user in a specific task and institution language
    *
    * @param i_lang                    language id
    * @param i_prof                    professional id (type: professional id, institution id and software id)
    * @param i_id_alert_diagnosis      alert_diagnosis id
    * @param i_code_diagnosis          Diagnosis code for translation
    * @param i_diagnosis_language      Diagnosis Language
    * @param i_id_task_type            Task Type ID
    * 
    * @return                          text containing the diagnosis description
    * 
    * @author                 Sergio Dias
    * @version                1.0   
    * @since                  13/Fev/2012
    *************************************************************************************************************/
    FUNCTION get_alert_diag_desc
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_alert_diagnosis IN alert_diagnosis.id_alert_diagnosis%TYPE,
        i_code_diagnosis     IN diagnosis.code_diagnosis%TYPE DEFAULT NULL,
        i_diagnosis_language IN language.id_language%TYPE DEFAULT NULL,
        i_id_task_type       IN task_type.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name   VARCHAR2(200 CHAR) := 'GET_ALERT_DIAG_DESC';
        l_description pk_translation.t_desc_translation;
        l_lang        language.id_language%TYPE := 0;
    BEGIN
        g_error := 'GET ALERT_DIAGNOSIS DESCRIPTION';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF i_code_diagnosis IS NOT NULL
        THEN
            IF nvl(i_diagnosis_language, 0) IN (0, -1)
            THEN
                l_lang := i_lang;
            ELSE
                l_lang := i_diagnosis_language;
            END IF;
        
            l_description := pk_translation.get_translation(l_lang, i_code_diagnosis);
        ELSE
            SELECT decode(id_language,
                          0,
                          pk_translation.get_translation(i_lang, code_diagnosis),
                          -1,
                          pk_translation.get_translation(i_lang, code_diagnosis),
                          pk_translation.get_translation(id_language, code_diagnosis))
              INTO l_description
              FROM (SELECT ad.id_language,
                           decode(i_id_task_type,
                                  pk_alert_constant.g_task_problems,
                                  ad.code_problems,
                                  pk_alert_constant.g_task_medical_history,
                                  ad.code_medical,
                                  pk_alert_constant.g_task_surgical_history,
                                  ad.code_surgical,
                                  pk_alert_constant.g_task_congenital_anomalies,
                                  ad.code_cong_anomalies,
                                  ad.code_alert_diagnosis) code_diagnosis
                      FROM alert_diagnosis ad
                     WHERE ad.id_alert_diagnosis = i_id_alert_diagnosis);
        END IF;
    
        RETURN l_description;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN 'DESC_DIAGNOSIS';
    END get_alert_diag_desc;
    --        
    /**********************************************************************************************
    * Gets the list of complications available in the pregnancy record creation/edition 
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_show_diagnosis         shows diagnosis list: Y - yes, N - no 
    *
    * @return                         diagnosis ID and description
    *                        
    * @author                         José Silva
    * @version                        1.0 
    * @since                          2011/03/25
    **********************************************************************************************/
    FUNCTION get_pregn_diag_diff_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_show_diagnosis IN VARCHAR2
    ) RETURN t_coll_values_domain_mkt IS
    
        l_error t_error_out;
        --
        l_synonym_list_enable sys_config.value%TYPE;
        --
        l_tbl_diagnoses t_coll_diagnosis_config;
        --
        CURSOR c_diagnosis IS
            SELECT t_rec_values_domain_mkt(desc_diagnosis, id_alert_diagnosis, '', rank, '')
              FROM (SELECT DISTINCT dc.id_alert_diagnosis, dc.desc_diagnosis, dc.code_icd, NULL rank
                      FROM TABLE(l_tbl_diagnoses) dc
                     WHERE rownum > 0) -- dummy condition in order to prevent performance issues
             WHERE desc_diagnosis IS NOT NULL
             ORDER BY desc_diagnosis;
    
        l_tbl t_coll_values_domain_mkt := t_coll_values_domain_mkt();
    BEGIN
    
        IF i_show_diagnosis = pk_alert_constant.g_yes
        THEN
        
            -- enable/disable synonyms in search and reply result sets
            l_synonym_list_enable := nvl(pk_sysconfig.get_config('DIAGNOSIS_SYNONYMS_LIST_ENABLE', i_prof),
                                         pk_alert_constant.g_no);
        
            l_tbl_diagnoses := pk_terminology_search.tf_diagnoses_list(i_lang                     => i_lang,
                                                                       i_prof                     => i_prof,
                                                                       i_patient                  => NULL,
                                                                       i_terminologies_task_types => table_number(pk_alert_constant.g_task_diagnosis),
                                                                       i_term_task_type           => pk_alert_constant.g_task_diagnosis,
                                                                       i_list_type                => pk_diagnosis_core.g_diag_list_preg_most_freq,
                                                                       i_synonym_list_enable      => l_synonym_list_enable);
        
            g_error := 'GET DIAGNOSIS';
            OPEN c_diagnosis;
            FETCH c_diagnosis BULK COLLECT
                INTO l_tbl;
            CLOSE c_diagnosis;
        END IF;
    
        RETURN l_tbl;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN t_coll_values_domain_mkt();
    END get_pregn_diag_diff_list;

    /********************************************************************************************
    * Function that returns diagnosis for an episode array
    * Note : used in admission surgery request functionality
    * Based in get_epis_diag function
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_id_episode             Array of episode ID
    * @param i_show_cancelled         Show cancelled/rulled out records: (Y)es or (N)o
    *
    * @param o_diag                   Cursor with diagnoses' information
    * @param o_error                  Error message
    *
    * @return                         true or false para sucesso ou erro
    *
    * @author                         Filipe Silva
    * @version                        2.5.1.5  
    * @since                          2011/03/31
    **********************************************************************************************/
    FUNCTION get_epis_diag
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_episode     IN table_number,
        i_show_cancelled IN VARCHAR2,
        o_diag           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'OPEN O_DIAG CURSOR';
        pk_alertlog.log_debug(g_error);
        OPEN o_diag FOR
            SELECT ed.id_diagnosis,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                              i_id_diagnosis        => d.id_diagnosis,
                                              i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9) diag_desc,
                   ed.flg_type,
                   pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_TYPE', ed.flg_type, i_lang) type_desc,
                   ed.flg_status,
                   pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', ed.flg_status, i_lang) status_desc,
                   ed.id_epis_diagnosis,
                   ed.flg_add_problem problem_status,
                   ed.notes,
                   ed.general_notes,
                   ed.notes_cancel,
                   d.flg_other,
                   ed.id_alert_diagnosis
              FROM (SELECT ed.id_diagnosis,
                           ed.flg_type,
                           ed.flg_status,
                           ed.id_alert_diagnosis,
                           ed.desc_epis_diagnosis,
                           ed.flg_add_problem,
                           ed.id_epis_diagnosis,
                           ed.notes,
                           pk_diagnosis_core.get_epis_diag_note(i_lang           => i_lang,
                                                                i_prof           => i_prof,
                                                                i_episode        => ed.id_episode,
                                                                i_epis_diag      => ed.id_epis_diagnosis,
                                                                i_epis_diag_hist => NULL) general_notes,
                           ed.notes_cancel,
                           row_number() over(PARTITION BY ed.id_diagnosis ORDER BY ed.flg_type) rn
                      FROM epis_diagnosis ed
                     WHERE ed.id_episode IN (SELECT /*+opt_estimate(table,t1,scale_rows=0.0000001))*/
                                              t1.column_value
                                               FROM TABLE(i_id_episode) t1)
                       AND (ed.flg_status NOT IN (pk_diagnosis.g_epis_status_c, pk_diagnosis.g_ed_flg_status_r) OR
                           i_show_cancelled = pk_alert_constant.g_yes)) ed
              JOIN diagnosis d
                ON (d.id_diagnosis = ed.id_diagnosis)
              LEFT OUTER JOIN alert_diagnosis ad
                ON (ad.id_alert_diagnosis = ed.id_alert_diagnosis)
             WHERE ed.rn = 1
             ORDER BY diag_desc;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_diag);
            RETURN FALSE;
    END get_epis_diag;
    --
    /********************************************************************************************
    * Function that gives all the information registered in a diagnosis record
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    *
    * @return                         diagnosis general info
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/27
    **********************************************************************************************/
    FUNCTION get_epis_diag
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE
    ) RETURN pk_edis_types.rec_epis_diagnosis IS
    
        l_rec_epis_diag pk_edis_types.rec_epis_diagnosis;
        l_error         t_error_out;
    
        l_patient patient.id_patient%TYPE;
    
    BEGIN
    
        l_patient := pk_episode.get_id_patient(i_episode => i_episode);
        BEGIN
            SELECT id_epis_diagnosis,
                   id_epis_diagnosis_hist,
                   id_diagnosis,
                   id_alert_diagnosis,
                   nvl2(id_diagnosis,
                        pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                   i_prof                => i_prof,
                                                   i_id_alert_diagnosis  => id_alert_diagnosis,
                                                   i_id_diagnosis        => id_diagnosis,
                                                   i_desc_epis_diagnosis => desc_epis_diagnosis,
                                                   i_code                => code_icd,
                                                   i_flg_other           => flg_other,
                                                   i_flg_std_diag        => flg_icd9,
                                                   i_epis_diag           => id_epis_diagnosis,
                                                   i_show_aditional_info => pk_alert_constant.g_no),
                        '') desc_diagnosis,
                   decode(pk_diagnosis_core.get_diag_type(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_concept_type => NULL,
                                                          i_diagnosis    => id_diagnosis),
                          pk_diagnosis_core.g_diag_type_acc_emerg,
                          NULL,
                          nvl2(id_diagnosis,
                               diag_desc(i_desc      => pk_diagnosis_core.get_alert_diag_desc(i_lang               => i_lang,
                                                                                              i_prof               => i_prof,
                                                                                              i_id_alert_diagnosis => pk_api_pfh_diagnosis_in.get_diag_preferred_term_id(i_concept_version => id_diagnosis,
                                                                                                                                                                         i_task_type       => pk_alert_constant.g_task_diagnosis),
                                                                                              i_id_task_type       => pk_alert_constant.g_task_diagnosis),
                                         i_code      => code_icd,
                                         i_show_code => pk_sysconfig.get_config('DIAGNOSIS_SHOW_CODE', i_prof),
                                         i_flg_other => flg_other),
                               '')) desc_diagnosis_original,
                   dt_initial_diag,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_initial_diag, i_prof) dt_initial_diag_chr,
                   nvl2(dt_initial_diag,
                        pk_diagnosis_form.get_pat_age(i_lang    => i_lang,
                                                      i_prof    => i_prof,
                                                      i_patient => l_patient,
                                                      i_when    => dt_initial_diag),
                        '') age_diag,
                   id_diag_basis,
                   pk_diagnosis.std_diag_basis_desc(i_lang               => i_lang,
                                                    i_prof               => i_prof,
                                                    i_id_diagnosis       => pk_diagnosis_core.get_term_diagnosis_id(id_diag_basis,
                                                                                                                    i_prof.institution,
                                                                                                                    i_prof.software),
                                                    i_id_alert_diagnosis => id_diag_basis,
                                                    i_code               => pk_diagnosis_core.get_term_diagnosis_code(id_diag_basis,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                    i_flg_other          => pk_alert_constant.g_no,
                                                    i_flg_std_diag       => pk_alert_constant.g_yes) desc_diag_basis,
                   diag_basis_spec,
                   flg_mult_tumors,
                   pk_sysdomain.get_domain(pk_diagnosis.g_code_domain_yes_no, flg_mult_tumors, i_lang) desc_mult_tumors,
                   num_primary_tumors,
                   flg_recurrence,
                   pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                       i_prof              => i_prof,
                                                       i_grp_internal_name => pk_diagnosis_form.g_sys_list_yes_no_unk,
                                                       i_flg_context       => flg_recurrence) desc_recurrence,
                   flg_final_type,
                   pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_type_d, flg_final_type, i_lang) desc_final_type,
                   flg_status,
                   pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status, flg_status, i_lang) desc_status,
                   notes,
                   flg_add_problem,
                   pk_sysdomain.get_domain(pk_diagnosis.g_code_domain_yes_no, flg_add_problem, i_lang) desc_add_problem,
                   dt_epis_diagnosis,
                   pk_date_utils.date_char_tsz(i_lang, dt_epis_diagnosis, i_prof.institution, i_prof.software) dt_epis_diagnosis_chr,
                   id_prof_diagnosis,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_diagnosis) name_prof_diag,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_diagnosis, dt_epis_diagnosis, i_episode) spec_prof_diag,
                   flg_type,
                   id_cancel_reason,
                   desc_cancel_reason,
                   notes_cancel,
                   id_diagnosis_condition,
                   nvl2(id_diagnosis_condition,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_diagnosis_condition,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_diagnosis_condition,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_diagnosis_condition,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_diagnosis_condition,
                   id_sub_analysis,
                   nvl2(id_sub_analysis,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_sub_analysis,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_sub_analysis,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_sub_analysis,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_sub_analysis,
                   id_anatomical_area,
                   nvl2(id_anatomical_area,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_anatomical_area,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_anatomical_area,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_anatomical_area,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_anatomical_area,
                   id_anatomical_side,
                   nvl2(id_anatomical_side,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_anatomical_side,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_anatomical_side,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_anatomical_side,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_anatomical_side,
                   id_lesion_type,
                   nvl2(id_lesion_type,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_lesion_type,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_lesion_type,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_lesion_type,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_lesion_type,
                   id_lesion_location,
                   nvl2(id_lesion_location,
                        pk_diagnosis.std_diag_desc(i_lang                  => i_lang,
                                                   i_prof                  => i_prof,
                                                   i_id_diagnosis          => pk_diagnosis_core.get_term_diagnosis_id(id_lesion_location,
                                                                                                                      i_prof.institution,
                                                                                                                      i_prof.software),
                                                   i_id_alert_diagnosis    => id_lesion_location,
                                                   i_code                  => pk_diagnosis_core.get_term_diagnosis_code(id_lesion_location,
                                                                                                                        i_prof.institution,
                                                                                                                        i_prof.software),
                                                   i_flg_other             => pk_alert_constant.g_no,
                                                   i_flg_std_diag          => pk_alert_constant.g_yes,
                                                   i_epis_diag             => id_epis_diagnosis,
                                                   i_show_aditional_info   => pk_alert_constant.g_no,
                                                   i_flg_show_ae_diag_info => pk_alert_constant.g_no),
                        '') desc_lesion_location,
                   rank,
                   rank desc_rank
              INTO l_rec_epis_diag
              FROM (SELECT ed.id_epis_diagnosis,
                           NULL id_epis_diagnosis_hist,
                           ed.dt_initial_diag,
                           ed.id_diag_basis,
                           ed.diag_basis_spec,
                           ed.flg_mult_tumors,
                           ed.num_primary_tumors,
                           ed.flg_recurrence,
                           ed.flg_final_type,
                           ed.flg_status,
                           ed.notes,
                           ed.flg_add_problem,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              flg_status,
                                                              dt_epis_diagnosis_tstz,
                                                              dt_confirmed_tstz,
                                                              dt_cancel_tstz,
                                                              dt_base_tstz,
                                                              dt_rulled_out_tstz) dt_epis_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                flg_status,
                                                                id_professional_diag,
                                                                id_prof_confirmed,
                                                                id_professional_cancel,
                                                                id_prof_base,
                                                                id_prof_rulled_out) id_prof_diagnosis,
                           -- diagnosis info
                           ed.id_diagnosis,
                           ed.id_alert_diagnosis,
                           d.flg_other,
                           d.code_icd,
                           ad.flg_icd9,
                           ed.flg_type,
                           ed.desc_epis_diagnosis,
                           ed.id_cancel_reason,
                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, ed.id_cancel_reason) desc_cancel_reason,
                           ed.notes_cancel,
                           ed.id_diagnosis_condition,
                           ed.id_sub_analysis,
                           ed.id_anatomical_area,
                           ed.id_anatomical_side,
                           ed.id_lesion_type,
                           ed.id_lesion_location,
                           ed.rank
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_epis_diagnosis = i_epis_diag
                       AND i_epis_diag_hist IS NULL
                    
                    UNION ALL
                    
                    SELECT eh.id_epis_diagnosis,
                           eh.id_epis_diagnosis_hist,
                           eh.dt_initial_diag,
                           eh.id_diag_basis,
                           eh.diag_basis_spec,
                           eh.flg_mult_tumors,
                           eh.num_primary_tumors,
                           eh.flg_recurrence,
                           eh.flg_final_type,
                           eh.flg_status,
                           eh.notes,
                           eh.flg_add_problem,
                           eh.dt_creation_tstz       dt_epis_diagnosis,
                           eh.id_professional        id_prof_diagnosis,
                           -- diagnosis info
                           ed.id_diagnosis,
                           ed.id_alert_diagnosis,
                           NULL flg_other,
                           NULL code_icd,
                           NULL flg_icd9,
                           ed.flg_type,
                           NULL desc_epis_diagnosis,
                           eh.id_cancel_reason,
                           pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, eh.id_cancel_reason) desc_cancel_reason,
                           '' notes_cancel, -- TODO: add this column
                           eh.id_diagnosis_condition,
                           eh.id_sub_analysis,
                           eh.id_anatomical_area,
                           eh.id_anatomical_side,
                           eh.id_lesion_type,
                           eh.id_lesion_location,
                           eh.rank
                      FROM epis_diagnosis_hist eh
                      JOIN epis_diagnosis ed
                        ON ed.id_epis_diagnosis = eh.id_epis_diagnosis
                     WHERE eh.id_epis_diagnosis_hist = i_epis_diag_hist);
        EXCEPTION
            WHEN no_data_found THEN
                l_rec_epis_diag := NULL;
        END;
    
        RETURN l_rec_epis_diag;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG',
                                              l_error);
            RETURN NULL;
    END get_epis_diag;

    --
    /********************************************************************************************
    * Function that returns diagnosis based on an record of Episode diagnosis records
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_epis_diag              Array of episode diagnosis ID
    * @param i_epis_diag_hist         Show cancelled/rulled out records: (Y)es or (N)o
    * @param o_epis_diag              Cursor with diagnoses' information
    * @param o_error                  Error message
    *
    * @return                         true or false
    *
    * @author                         José Silva
    * @version                        2.6.1.2  
    * @since                          2011/09/20
    **********************************************************************************************/
    FUNCTION get_epis_diag_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diag      IN table_number,
        i_epis_diag_hist IN table_number,
        o_epis_diag      OUT pk_edis_types.p_epis_diagnosis_cur,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_epis_diag      table_number := table_number();
        l_epis_diag_hist table_number := table_number();
        l_old_diag_hist  table_number := table_number();
    
        l_curr_ed_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    
        CURSOR c_epis_diag_hist
        (
            i_epis_diag    epis_diagnosis.id_epis_diagnosis%TYPE,
            i_prev_ed_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE
        ) IS
            SELECT id_epis_diagnosis_hist
              FROM epis_diagnosis_hist eh
             WHERE eh.id_epis_diagnosis = i_epis_diag
               AND (eh.dt_creation_tstz > (SELECT eh2.dt_creation_tstz
                                             FROM epis_diagnosis_hist eh2
                                            WHERE eh2.id_epis_diagnosis_hist = i_prev_ed_hist
                                              AND eh2.id_epis_diagnosis = i_epis_diag) OR
                   (eh.dt_creation_tstz = (SELECT MIN(eh2.dt_creation_tstz)
                                              FROM epis_diagnosis_hist eh2
                                             WHERE eh2.id_epis_diagnosis = i_epis_diag) AND
                   nvl(i_prev_ed_hist, -1) = -1))
             ORDER BY eh.dt_creation_tstz;
    
    BEGIN
    
        -- referral saves the history record from the previous data so we need to fetch the next record
        g_error := 'GET REFERRAL INFORMATION';
        pk_alertlog.log_debug(g_error);
        FOR i IN 1 .. i_epis_diag_hist.count
        LOOP
            OPEN c_epis_diag_hist(i_epis_diag(i), i_epis_diag_hist(i));
        
            FETCH c_epis_diag_hist
                INTO l_curr_ed_hist;
        
            CLOSE c_epis_diag_hist;
        
            IF l_curr_ed_hist IS NULL
            THEN
                l_epis_diag.extend;
                l_epis_diag(i) := i_epis_diag(i);
            ELSE
                l_epis_diag_hist.extend;
                l_epis_diag_hist(i) := l_curr_ed_hist;
            
                l_old_diag_hist.extend;
                l_old_diag_hist(i) := i_epis_diag_hist(i);
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN o_epis_diag';
        pk_alertlog.log_debug(g_error);
        OPEN o_epis_diag FOR
            SELECT ed.id_epis_diagnosis,
                   ed.id_epis_diagnosis_hist,
                   ed.id_diagnosis,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                              i_id_diagnosis        => d.id_diagnosis,
                                              i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9) diag_desc,
                   ed.flg_type,
                   pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_TYPE', ed.flg_type, i_lang) type_desc,
                   ed.flg_status,
                   pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', ed.flg_status, i_lang) status_desc,
                   ed.flg_add_problem problem_status,
                   ed.notes,
                   ed.general_notes,
                   ed.notes_cancel,
                   ed.flg_has_recent_data
              FROM (SELECT ed.id_diagnosis,
                           ed.flg_type,
                           ed.flg_status,
                           ed.id_alert_diagnosis,
                           ed.desc_epis_diagnosis,
                           ed.flg_add_problem,
                           ed.id_epis_diagnosis,
                           NULL id_epis_diagnosis_hist,
                           ed.notes,
                           pk_diagnosis_core.get_epis_diag_note(i_lang           => i_lang,
                                                                i_prof           => i_prof,
                                                                i_episode        => ed.id_episode,
                                                                i_epis_diag      => ed.id_epis_diagnosis,
                                                                i_epis_diag_hist => NULL) general_notes,
                           ed.notes_cancel,
                           pk_alert_constant.g_no flg_has_recent_data
                      FROM epis_diagnosis ed
                      JOIN (SELECT /*+opt_estimate(table t2 rows=1)*/
                            column_value
                             FROM TABLE((CAST(l_epis_diag AS table_number))) t2) tab_ed
                        ON tab_ed.column_value = ed.id_epis_diagnosis
                    
                    UNION ALL
                    
                    SELECT ed.id_diagnosis,
                           eh.flg_type,
                           eh.flg_status,
                           ed.id_alert_diagnosis,
                           ed.desc_epis_diagnosis,
                           eh.flg_add_problem,
                           ed.id_epis_diagnosis,
                           tab_old_ed.column_value id_epis_diagnosis_hist,
                           get_hist_specific_notes(i_lang,
                                                   i_prof,
                                                   ed.id_epis_diagnosis,
                                                   eh.dt_creation_tstz,
                                                   eh.flg_status,
                                                   eh.notes) notes,
                           pk_diagnosis_core.get_epis_diag_note(i_lang           => i_lang,
                                                                i_prof           => i_prof,
                                                                i_episode        => ed.id_episode,
                                                                i_epis_diag      => NULL,
                                                                i_epis_diag_hist => eh.id_epis_diagnosis_hist) general_notes,
                           decode(eh.flg_status, pk_diagnosis.g_ed_flg_status_ca, eh.notes, NULL) notes_cancel,
                           pk_alert_constant.g_yes flg_has_recent_data
                      FROM epis_diagnosis_hist eh
                      JOIN epis_diagnosis ed
                        ON ed.id_epis_diagnosis = eh.id_epis_diagnosis
                      JOIN (SELECT /*+opt_estimate(table t2 rows=1)*/
                            column_value, rownum num1
                             FROM TABLE((CAST(l_epis_diag_hist AS table_number))) t2) tab_ed
                        ON tab_ed.column_value = eh.id_epis_diagnosis_hist
                      JOIN (SELECT /*+opt_estimate(table t2 rows=1)*/
                            column_value, rownum num2
                             FROM TABLE((CAST(l_old_diag_hist AS table_number))) t2) tab_old_ed
                        ON tab_ed.num1 = tab_old_ed.num2) ed
              JOIN diagnosis d
                ON (d.id_diagnosis = ed.id_diagnosis)
              LEFT OUTER JOIN alert_diagnosis ad
                ON (ad.id_alert_diagnosis = ed.id_alert_diagnosis)
             ORDER BY diag_desc;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_LIST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_epis_diag);
            RETURN FALSE;
    END get_epis_diag_list;
    --
    /**
    * Get final diagnoses (entries info) of patient's family members. 
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_current_episode    Current episode ID
    * @param   i_patient            Patient ID
    * @param   i_order              Indicates the chronological order of records returned ('ASC' Ascending , 'DESC' Descending) Default 'DESC'
    *
    * @return  Information about entries (professional, record date, status, etc.)
    *
    * @author  ARIEL.MACHADO
    * @version v2.6.0.4
    * @since   11/22/2010
    */
    FUNCTION tf_final_diag_pat_family_reg
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_current_episode IN episode.id_episode%TYPE,
        i_patient         IN patient.id_patient%TYPE,
        i_order           IN VARCHAR2 DEFAULT 'DESC'
    ) RETURN pk_touch_option.t_coll_doc_area_register
        PIPELINED IS
        l_coll_register pk_touch_option.t_coll_doc_area_register;
    
        CURSOR c_register IS
            SELECT decode(i_order, 'DESC', 1, 'ASC', -1, 1) *
                   (current_timestamp - nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz)) order_by_default,
                   trunc(SYSDATE) order_default,
                   ed.id_epis_diagnosis id_epis_documentation,
                   NULL PARENT,
                   NULL id_doc_template,
                   NULL template_desc,
                   pk_date_utils.date_send_tsz(i_lang, nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz), i_prof) dt_creation,
                   nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz) dt_creation_tstz,
                   pk_date_utils.date_char_tsz(i_lang,
                                               nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz),
                                               i_prof.institution,
                                               i_prof.software) dt_register,
                   nvl(ed.id_prof_confirmed, ed.id_professional_diag) id_professional,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ed.id_prof_confirmed, ed.id_professional_diag)) nick_name,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    nvl(ed.id_prof_confirmed, ed.id_professional_diag),
                                                    nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz),
                                                    ed.id_episode) desc_speciality,
                   pk_summary_page.g_doc_area_past_fam id_doc_area,
                   pk_alert_constant.g_active flg_status,
                   NULL desc_status,
                   ed.id_episode,
                   decode(ed.id_episode, i_current_episode, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_current_episode,
                   to_clob(ed.notes) notes,
                   pk_date_utils.date_send_tsz(i_lang,
                                               nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz),
                                               i_prof.institution,
                                               i_prof.software) dt_last_update,
                   nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz) dt_last_update_tstz,
                   pk_alert_constant.g_no flg_detail,
                   pk_alert_constant.g_yes flg_external,
                   pk_summary_page.g_free_text flg_type_register,
                   pk_touch_option.g_flg_tab_origin_epis_diags flg_table_origin,
                   NULL flg_reviewed,
                   NULL id_prof_cancel,
                   NULL dt_cancel_tstz,
                   NULL id_cancel_reason,
                   NULL cancel_reason,
                   NULL cancel_notes,
                   NULL flg_edition_type,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, nvl(ed.id_prof_confirmed, ed.id_professional_diag)) nick_name_prof_create,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    nvl(ed.id_prof_confirmed, ed.id_professional_diag),
                                                    nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz),
                                                    ed.id_episode) desc_speciality_prof_create,
                   NULL dt_clinical,
                   NULL dt_clinical_chr,
                   NULL signature
              FROM (SELECT pfm.id_pat_related,
                           pk_translation.get_translation(i_lang, fr.code_family_relationship) desc_relationship
                      FROM pat_family_member pfm
                     INNER JOIN family_relationship fr
                        ON fr.id_family_relationship = pfm.id_family_relationship
                     WHERE pfm.id_patient = i_patient
                       AND pfm.flg_status = pk_alert_constant.g_active) pfam
             INNER JOIN epis_diagnosis ed
                ON pfam.id_pat_related = ed.id_patient
             INNER JOIN diagnosis d
                ON d.id_diagnosis = ed.id_diagnosis
             WHERE ed.flg_type = pk_alert_constant.g_epis_diag_flg_type_d --Discharge diagnosis
               AND ed.flg_status IN
                   (pk_alert_constant.g_epis_diag_flg_status_f, pk_alert_constant.g_epis_diag_flg_status_d)
             ORDER BY order_by_default;
    
    BEGIN
        OPEN c_register;
    
        LOOP
            FETCH c_register BULK COLLECT
                INTO l_coll_register LIMIT 500;
            FOR i IN 1 .. l_coll_register.count
            LOOP
                PIPE ROW(l_coll_register(i));
            END LOOP;
            EXIT WHEN c_register%NOTFOUND;
        END LOOP;
        CLOSE c_register;
    
        RETURN;
    EXCEPTION
        WHEN no_data_needed THEN
            -- when we run a pipelined function without exhausting it we see this exception being rased to clean up (releasing any resources that need be released).
            IF c_register%ISOPEN
            THEN
                CLOSE c_register;
            END IF;
            RETURN;
    END tf_final_diag_pat_family_reg;

    /**
    * Get final diagnoses (entries values) of patient's family members. 
    *
    * @param   i_lang               Professional preferred language
    * @param   i_prof               Professional identification and its context (institution and software)
    * @param   i_patient            Patient ID
    *
    * @return  Information about data values saved in entries
    *
    * @author  ARIEL.MACHADO
    * @version v2.6.0.4
    * @since   11/22/2010
    */
    FUNCTION tf_final_diag_pat_family_val
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE
    ) RETURN pk_touch_option.t_coll_doc_area_val
        PIPELINED IS
        l_coll_val pk_touch_option.t_coll_doc_area_val;
        CURSOR c_val IS
            SELECT ed.id_epis_diagnosis id_epis_documentation,
                   NULL PARENT,
                   NULL id_documentation,
                   NULL id_doc_component,
                   NULL id_doc_element_crit,
                   pk_date_utils.date_send_tsz(i_lang, nvl(ed.dt_confirmed_tstz, ed.dt_epis_diagnosis_tstz), i_prof) dt_reg,
                   NULL desc_component,
                   NULL flg_type,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                              i_id_diagnosis        => d.id_diagnosis,
                                              i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9,
                                              i_epis_diag           => ed.id_epis_diagnosis) || ' (' ||
                   pfam.desc_relationship || ', ' ||
                   pk_patient.get_pat_name(i_lang, i_prof, pfam.id_pat_related, ed.id_episode) || ')' desc_element,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                              i_id_diagnosis        => d.id_diagnosis,
                                              i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9,
                                              i_epis_diag           => ed.id_epis_diagnosis) || ' (' ||
                   pfam.desc_relationship || ', ' ||
                   pk_patient.get_pat_name(i_lang, i_prof, pfam.id_pat_related, ed.id_episode) || ')' desc_element,
                   NULL VALUE,
                   NULL flg_type_element,
                   pk_summary_page.g_doc_area_past_fam id_doc_area,
                   NULL rank_component,
                   NULL rank_element,
                   NULL internal_name,
                   NULL desc_quantifier,
                   NULL desc_quantification,
                   NULL desc_qualification,
                   NULL display_format,
                   NULL separator,
                   pk_touch_option.g_flg_tab_origin_epis_diags flg_table_origin,
                   NULL flg_status,
                   NULL value_id, --ALERT-65600
                   NULL signature
              FROM (SELECT pfm.id_pat_related,
                           pk_translation.get_translation(i_lang, fr.code_family_relationship) desc_relationship
                      FROM pat_family_member pfm
                     INNER JOIN family_relationship fr
                        ON fr.id_family_relationship = pfm.id_family_relationship
                     WHERE pfm.id_patient = i_patient
                       AND pfm.flg_status = pk_alert_constant.g_active) pfam
             INNER JOIN epis_diagnosis ed
                ON pfam.id_pat_related = ed.id_patient
             INNER JOIN diagnosis d
                ON d.id_diagnosis = ed.id_diagnosis
              LEFT JOIN alert_diagnosis ad
                ON ed.id_alert_diagnosis = ad.id_alert_diagnosis
             WHERE ed.flg_type = pk_alert_constant.g_epis_diag_flg_type_d --Discharge diagnosis
               AND ed.flg_status IN
                   (pk_alert_constant.g_epis_diag_flg_status_f, pk_alert_constant.g_epis_diag_flg_status_d);
    BEGIN
        OPEN c_val;
        LOOP
            FETCH c_val BULK COLLECT
                INTO l_coll_val LIMIT 500;
            FOR i IN 1 .. l_coll_val.count
            LOOP
                PIPE ROW(l_coll_val(i));
            END LOOP;
            EXIT WHEN c_val%NOTFOUND;
        END LOOP;
        CLOSE c_val;
    
        RETURN;
    EXCEPTION
        WHEN no_data_needed THEN
            -- when we run a pipelined function without exhausting it we see this exception being rased to clean up (releasing any resources that need be released).
            IF c_val%ISOPEN
            THEN
                CLOSE c_val;
            END IF;
            RETURN;
    END tf_final_diag_pat_family_val;
    --
    FUNCTION get_diagnosis_path
    (
        i_lang      IN language.id_language%TYPE,
        i_diagnosis IN diagnosis.id_diagnosis%TYPE,
        i_diag_mode IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_error t_error_out;
        l_ret   VARCHAR2(200);
        l_sep   VARCHAR2(2 CHAR);
    
        CURSOR c_diagnosis_parent IS
            SELECT id_diagnosis, id_diagnosis_parent, LEVEL
              FROM diagnosis
            CONNECT BY PRIOR id_diagnosis_parent = id_diagnosis
             START WITH id_diagnosis = i_diagnosis
             ORDER BY LEVEL DESC;
    
    BEGIN
    
        IF i_diag_mode = pk_diagnosis_core.g_tree_mode
        THEN
            FOR r_diag IN c_diagnosis_parent
            LOOP
                l_ret := l_ret || l_sep || r_diag.id_diagnosis;
            
                l_sep := '->';
            END LOOP;
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_DIAGNOSIS_PATH',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_diagnosis_path;
    --
    /**********************************************************************************************
    * Get the histology description based in the morphology ID
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_morphology             morphology ID
    *
    * @return                         histology description
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/18
    **********************************************************************************************/
    FUNCTION get_desc_histology
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_morphology IN diagnosis.id_diagnosis%TYPE
    ) RETURN VARCHAR2 IS
    
        l_desc_histology pk_translation.t_desc_translation;
    
    BEGIN
        --
        SELECT pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                          i_prof               => i_prof,
                                          i_id_alert_diagnosis => d.id_concept_term,
                                          i_id_diagnosis       => d.id_concept_version,
                                          i_code_diagnosis     => d.code_diagnosis,
                                          i_diagnosis_language => d.id_language,
                                          i_code               => pk_api_diagnosis_func.get_concept_code(dr.id_concept_version_2),
                                          i_flg_other          => d.flg_other,
                                          i_flg_std_diag       => d.flg_icd9,
                                          i_flg_search_mode    => pk_alert_constant.g_yes)
          INTO l_desc_histology
          FROM diagnosis_relations_ea dr
          JOIN diagnosis_ea d
            ON d.id_concept_version = dr.id_concept_version_1
         WHERE dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
           AND dr.concept_type_int_name1 = pk_diagnosis_form.g_morphology_type
           AND dr.concept_type_int_name2 = pk_diagnosis_form.g_histology_type
           AND dr.id_concept_version_1 = i_morphology
           AND dr.id_institution = i_prof.institution
           AND dr.id_software = i_prof.software
           AND d.id_institution = i_prof.institution
           AND d.id_software = i_prof.software;
    
        RETURN l_desc_histology;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_desc_histology;

    /**********************************************************************************************
    * Get the histology code based in the morphology ID
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_morphology             morphology ID
    *
    * @return                         histology description
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/27
    **********************************************************************************************/
    FUNCTION get_code_histology
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_morphology IN diagnosis.id_diagnosis%TYPE
    ) RETURN diagnosis.code_icd%TYPE IS
    
        l_code_histology diagnosis.code_icd%TYPE;
    
    BEGIN
        --
        SELECT get_diagnosis_code(pk_api_pfh_diagnosis_in.get_hist_by_morphology(id_concept, id_terminology_version),
                                  i_prof.institution,
                                  i_prof.software)
          INTO l_code_histology
          FROM diagnosis d
         WHERE d.id_diagnosis = i_morphology;
    
        RETURN l_code_histology;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_code_histology;

    /**********************************************************************************************
    * Get the formatted icdo diagnosis
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_code_topography        topography concept code
    * @param i_code_histology         histology concept code
    * @param i_code_behaviour         behaviour concept code
    * @param i_code_hist_grade        histological grade code
    * @param i_desc_morphology        morphology description
    * @param i_desc_topography        topography description
    *
    * @return                         diagnosis description based in the ICDO standard
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/27
    **********************************************************************************************/
    FUNCTION get_desc_diag_icdo
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_code_topography IN diagnosis.code_icd%TYPE,
        i_code_histology  IN diagnosis.code_icd%TYPE,
        i_code_behaviour  IN diagnosis.code_icd%TYPE,
        i_code_hist_grade IN diagnosis.code_icd%TYPE,
        i_desc_morphology IN VARCHAR2,
        i_desc_topography IN VARCHAR2
    ) RETURN diagnosis.code_icd%TYPE IS
    
    BEGIN
    
        IF i_code_topography IS NOT NULL
           AND i_code_histology IS NOT NULL
        THEN
            RETURN i_code_topography || ' M-' || i_code_histology || '/' || i_code_behaviour || i_code_hist_grade || ' - ' || i_desc_morphology || '; ' || i_desc_topography;
        ELSE
            RETURN '';
        END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_desc_diag_icdo;

    /********************************************************************************************
    * Function that gives all the history records of a given episode diagnosis ID
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_epis_diag              episode diagnosis ID
    *
    * @return                         diagnosis history IDs
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/Apr/10
    **********************************************************************************************/
    FUNCTION get_epis_diag_hist
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE
    ) RETURN table_number IS
    
        l_table table_number;
        l_error t_error_out;
    BEGIN
    
        SELECT eh.id_epis_diagnosis_hist
          BULK COLLECT
          INTO l_table
          FROM epis_diagnosis_hist eh
         WHERE eh.id_epis_diagnosis = i_epis_diag
         ORDER BY eh.dt_creation_tstz DESC;
    
        RETURN l_table;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_HIST',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_epis_diag_hist;

    /********************************************************************************************
    * Function that gives the staging factors of a diagnosis record
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    * @param i_staging_basis          staging basis ID
    * @param i_num_staging_basis      Number of staging basis
    * @param i_topography             topography ID
    *
    * @return                         staging factors
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/27
    **********************************************************************************************/
    FUNCTION get_epis_diag_factors
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_episode           IN episode.id_episode%TYPE,
        i_epis_diag         IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist    IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        i_staging_basis     IN epis_diag_stag.id_staging_basis%TYPE,
        i_num_staging_basis IN epis_diag_stag.num_staging_basis%TYPE
    ) RETURN pk_edis_types.tab_diag_factors IS
    
        l_table pk_edis_types.tab_diag_factors;
        l_error t_error_out;
    
        CURSOR c_prog_factors IS
            SELECT epf.id_epis_diagnosis,
                   NULL id_epis_diagnosis_hist,
                   epf.id_staging_basis,
                   epf.num_staging_basis,
                   epf.id_field,
                   epf.id_value,
                   epf.desc_value,
                   1 is_current_val,
                   nvl2(epf.id_value, 1, 0) is_stage_factor,
                   epf.field_rank rank
              FROM epis_diag_stag_pfact epf
             WHERE i_epis_diag_hist IS NULL
               AND epf.id_epis_diagnosis = i_epis_diag
               AND epf.id_staging_basis = i_staging_basis
               AND epf.num_staging_basis = i_num_staging_basis
            
            UNION ALL
            
            SELECT eph.id_epis_diagnosis,
                   eph.id_epis_diagnosis_hist,
                   eph.id_staging_basis,
                   eph.num_staging_basis,
                   eph.id_field,
                   eph.id_value,
                   eph.desc_value,
                   0 is_current_val,
                   nvl2(eph.id_value, 1, 0) is_stage_factor,
                   eph.field_rank rank
              FROM epis_dstag_pfact_hist eph
             WHERE eph.id_epis_diagnosis_hist = i_epis_diag_hist
               AND eph.id_staging_basis = i_staging_basis
               AND eph.num_staging_basis = i_num_staging_basis
             ORDER BY is_stage_factor DESC, rank, is_current_val DESC;
    
        TYPE t_tal_staging_vals IS TABLE OF c_prog_factors%ROWTYPE;
    
        l_tab_staging_vals t_tal_staging_vals;
    
    BEGIN
    
        l_table := pk_edis_types.tab_diag_factors();
    
        OPEN c_prog_factors;
        FETCH c_prog_factors BULK COLLECT
            INTO l_tab_staging_vals;
        CLOSE c_prog_factors;
    
        FOR i IN 1 .. l_tab_staging_vals.count
        LOOP
            l_table.extend;
            l_table(i).id_epis_diagnosis := l_tab_staging_vals(i).id_epis_diagnosis;
            l_table(i).id_epis_diagnosis_hist := l_tab_staging_vals(i).id_epis_diagnosis_hist;
            l_table(i).id_staging_basis := l_tab_staging_vals(i).id_staging_basis;
            l_table(i).num_staging_basis := l_tab_staging_vals(i).num_staging_basis;
            l_table(i).id_field := l_tab_staging_vals(i).id_field;
            l_table(i).desc_field := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                i_prof               => i_prof,
                                                                i_id_alert_diagnosis => l_tab_staging_vals(i).id_field,
                                                                i_code               => NULL,
                                                                i_flg_other          => pk_alert_constant.g_no,
                                                                i_flg_std_diag       => pk_alert_constant.g_yes);
            l_table(i).id_value := l_tab_staging_vals(i).id_value;
        
            IF l_tab_staging_vals(i).id_value IS NOT NULL
            THEN
                l_table(i).desc_value_field := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                          i_prof               => i_prof,
                                                                          i_id_alert_diagnosis => l_tab_staging_vals(i).id_value,
                                                                          i_code               => NULL,
                                                                          i_flg_other          => pk_alert_constant.g_no,
                                                                          i_flg_std_diag       => pk_alert_constant.g_yes);
            END IF;
        
            l_table(i).desc_value := l_tab_staging_vals(i).desc_value;
            l_table(i).is_current_val := l_tab_staging_vals(i).is_current_val;
            l_table(i).is_stage_factor := l_tab_staging_vals(i).is_stage_factor;
        END LOOP;
    
        RETURN l_table;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_FACTORS',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_epis_diag_factors;

    /********************************************************************************************
    * Function that gives the tumors registered in a diagnosis record
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    *
    * @return                         tumor records
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/27
    **********************************************************************************************/
    FUNCTION get_epis_diag_tumors
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE
    ) RETURN pk_edis_types.tab_epis_diag_tumors IS
    
        l_table pk_edis_types.tab_epis_diag_tumors;
        l_error t_error_out;
    
        l_main_tumor CONSTANT epis_diag_tumors.tumor_num%TYPE := 1;
    
        r_tumor pk_edis_types.rec_epis_diag_tumors;
    BEGIN
    
        FOR r_tumor IN (SELECT id_epis_diagnosis,
                               id_epis_diagnosis_hist,
                               tumor_num,
                               decode(tumor_num,
                                      l_main_tumor,
                                      get_desc_diag_icdo(i_lang            => i_lang,
                                                         i_prof            => i_prof,
                                                         i_code_topography => code_topography,
                                                         i_code_histology  => get_code_histology(i_lang,
                                                                                                 i_prof,
                                                                                                 get_term_diagnosis_id(id_morphology,
                                                                                                                       i_prof.institution,
                                                                                                                       i_prof.software)),
                                                         i_code_behaviour  => code_behavior,
                                                         i_code_hist_grade => code_hist_grade,
                                                         i_desc_morphology => pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                         i_prof               => i_prof,
                                                                                                         i_id_alert_diagnosis => id_morphology,
                                                                                                         i_code               => NULL,
                                                                                                         i_flg_other          => pk_alert_constant.g_no,
                                                                                                         i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_morphology)),
                                                         i_desc_topography => pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                         i_prof               => i_prof,
                                                                                                         i_id_alert_diagnosis => id_topography,
                                                                                                         i_code               => NULL,
                                                                                                         i_flg_other          => pk_alert_constant.g_no,
                                                                                                         i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_topography)))) code_icdo,
                               id_topography,
                               pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_alert_diagnosis => id_topography,
                                                          i_code               => code_topography,
                                                          i_flg_other          => pk_alert_constant.g_no,
                                                          i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_topography)) AS desc_topography,
                               id_laterality,
                               pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_alert_diagnosis => id_laterality,
                                                          i_code               => NULL,
                                                          i_flg_other          => pk_alert_constant.g_no,
                                                          i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_laterality)) AS desc_laterality,
                               id_morphology,
                               pk_diagnosis_core.get_desc_histology(i_lang,
                                                                    i_prof,
                                                                    pk_diagnosis_core.get_term_diagnosis_id(id_morphology,
                                                                                                            i_prof.institution,
                                                                                                            i_prof.software)) AS desc_morphology,
                               id_behavior,
                               pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_alert_diagnosis => id_behavior,
                                                          i_code               => code_behavior,
                                                          i_flg_other          => pk_alert_constant.g_no,
                                                          i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_behavior)) AS desc_behaviour,
                               id_histological_grade,
                               pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_alert_diagnosis => id_histological_grade,
                                                          i_code               => pk_diagnosis_core.get_term_diagnosis_code(id_histological_grade,
                                                                                                                            i_prof.institution,
                                                                                                                            i_prof.software),
                                                          i_flg_other          => pk_alert_constant.g_no,
                                                          i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_histological_grade)) AS desc_histological_grade,
                               id_other_grading_sys,
                               pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                          i_prof               => i_prof,
                                                          i_id_alert_diagnosis => id_other_grading_sys,
                                                          i_code               => pk_diagnosis_core.get_term_diagnosis_code(id_other_grading_sys,
                                                                                                                            i_prof.institution,
                                                                                                                            i_prof.software),
                                                          i_flg_other          => pk_alert_constant.g_no,
                                                          i_flg_std_diag       => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_other_grading_sys)) AS desc_other_grading_sys,
                               pk_diagnosis.std_diag_desc(i_lang         => i_lang,
                                                          i_prof         => i_prof,
                                                          i_id_diagnosis => id_par_other_grading_sys,
                                                          i_code         => NULL,
                                                          i_flg_other    => pk_alert_constant.g_no,
                                                          i_flg_std_diag => pk_diagnosis_core.get_flg_std_diag(i_alert_diagnosis => id_par_other_grading_sys)) desc_grading_system,
                               flg_unknown_dimension,
                               pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                                   i_prof              => i_prof,
                                                                   i_grp_internal_name => pk_diagnosis_form.g_sys_list_yes_no_unk,
                                                                   i_flg_context       => flg_unknown_dimension) desc_unknown_dimension,
                               num_dimension,
                               desc_dimension,
                               additional_pathol_info
                          FROM (SELECT et.id_epis_diagnosis,
                                       NULL id_epis_diagnosis_hist,
                                       et.tumor_num,
                                       et.id_topography,
                                       pk_diagnosis_core.get_term_diagnosis_code(et.id_topography,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_topography,
                                       et.id_laterality,
                                       et.id_morphology,
                                       et.id_behavior,
                                       pk_diagnosis_core.get_term_diagnosis_code(et.id_behavior,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_behavior,
                                       et.id_histological_grade,
                                       pk_diagnosis_core.get_term_diagnosis_code(et.id_histological_grade,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_hist_grade,
                                       pk_api_pfh_diagnosis_in.get_diagnosis_parent(pk_diagnosis_core.get_term_diagnosis_id(et.id_other_grading_sys,
                                                                                                                            i_prof.institution,
                                                                                                                            i_prof.software)) id_par_other_grading_sys,
                                       et.id_other_grading_sys,
                                       et.flg_unknown_dimension,
                                       et.num_dimension,
                                       et.desc_dimension,
                                       et.additional_pathol_info
                                  FROM epis_diag_tumors et
                                 WHERE et.id_epis_diagnosis = i_epis_diag
                                   AND i_epis_diag_hist IS NULL
                                
                                UNION ALL
                                
                                SELECT eth.id_epis_diagnosis,
                                       eth.id_epis_diagnosis_hist,
                                       eth.tumor_num,
                                       eth.id_topography,
                                       pk_diagnosis_core.get_term_diagnosis_code(eth.id_topography,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_topography,
                                       eth.id_laterality,
                                       eth.id_morphology,
                                       eth.id_behavior,
                                       pk_diagnosis_core.get_term_diagnosis_code(eth.id_behavior,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_behavior,
                                       eth.id_histological_grade,
                                       pk_diagnosis_core.get_term_diagnosis_code(eth.id_histological_grade,
                                                                                 i_prof.institution,
                                                                                 i_prof.software) code_hist_grade,
                                       pk_api_pfh_diagnosis_in.get_diagnosis_parent(pk_diagnosis_core.get_term_diagnosis_id(eth.id_other_grading_sys,
                                                                                                                            i_prof.institution,
                                                                                                                            i_prof.software)) id_par_other_grading_sys,
                                       eth.id_other_grading_sys,
                                       eth.flg_unknown_dimension,
                                       eth.num_dimension,
                                       eth.desc_dimension,
                                       eth.additional_pathol_info
                                  FROM epis_diag_tumors_hist eth
                                 WHERE eth.id_epis_diagnosis_hist = i_epis_diag_hist)
                         ORDER BY tumor_num)
        LOOP
            l_table(r_tumor.tumor_num) := r_tumor;
        END LOOP;
    
        RETURN l_table;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_TUMORS',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            DECLARE
                l_tbl_aux pk_edis_types.tab_epis_diag_tumors;
            BEGIN
                RETURN l_tbl_aux;
            END;
    END get_epis_diag_tumors;

    /********************************************************************************************
    * Function that gives the staging general info of a specific diagnosis
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_flg_call               screen which called this method: V - viewer, D - detail
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    * @param i_flg_ret_type           type of info to return: F - full info, I - only IDs
    *
    * @return                         staging records
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/23
    **********************************************************************************************/
    FUNCTION get_epis_diag_stagings
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_flg_call       IN VARCHAR2,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        i_flg_ret_type   IN VARCHAR2 DEFAULT 'F'
    ) RETURN pk_edis_types.tab_epis_diag_staging IS
    
        l_table pk_edis_types.tab_epis_diag_staging;
        l_error t_error_out;
    
        l_tnm                pk_edis_types.rec_in_tnm;
        l_diag_staging_basis diagnosis.id_diagnosis%TYPE;
    
        l_id_patient     patient.id_patient%TYPE;
        l_id_diagnosis   diagnosis.id_diagnosis%TYPE;
        l_is_cancer_diag VARCHAR2(1 CHAR);
        l_flg_type       epis_diagnosis.flg_type%TYPE;
    
        l_code_tnm_considered_crit CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M032'; --TNM Considered criteria
    
        l_desc_tnm_considered_crit sys_message.desc_message%TYPE;
        l_desc_group_na            sys_message.desc_message%TYPE;
    
        -- fetch all active statings
        CURSOR c_all_stagings IS
            SELECT t.*, rank, pk_diagnosis_core.get_staging_basis_type(i_prof, id_staging_basis) staging_basis_type
              FROM (SELECT staging.*,
                           row_number() over(PARTITION BY id_staging_basis, num_staging_basis ORDER BY dt_epis_diagnosis_stag DESC) rn
                      FROM (SELECT ed.id_epis_diagnosis,
                                   NULL id_epis_diagnosis_hist,
                                   eg.num_staging_basis,
                                   eg.id_staging_basis,
                                   ed.flg_mult_tumors,
                                   ed.num_primary_tumors,
                                   id_tnm_t,
                                   code_tnm_t,
                                   id_tnm_n,
                                   code_tnm_n,
                                   id_tnm_m,
                                   code_tnm_m,
                                   id_metastatic_sites,
                                   id_residual_tumor,
                                   id_surgical_margins,
                                   id_lymph_vasc_inv,
                                   id_other_staging_sys,
                                   id_staging_group,
                                   pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                                      i_prof,
                                                                      ed.flg_status,
                                                                      ed.dt_epis_diagnosis_tstz,
                                                                      ed.dt_confirmed_tstz,
                                                                      ed.dt_cancel_tstz,
                                                                      ed.dt_base_tstz,
                                                                      ed.dt_rulled_out_tstz) dt_epis_diagnosis_stag,
                                   id_prof_create,
                                   ed.flg_status,
                                   -- if the staging is not cancelled the status is retrieved by the epis_diagnosis record
                                   nvl2(eg.id_cancel_reason, pk_alert_constant.g_cancelled, NULL) flg_stag_status,
                                   eg.id_cancel_reason,
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, eg.id_cancel_reason) desc_cancel_reason,
                                   eg.cancel_notes,
                                   nvl2(eg.id_epis_diagnosis, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_has_staging
                              FROM epis_diagnosis ed
                              JOIN episode e
                                ON e.id_episode = ed.id_episode
                              LEFT JOIN epis_diag_stag eg
                                ON eg.id_epis_diagnosis = ed.id_epis_diagnosis
                             WHERE e.id_patient = l_id_patient
                               AND ed.id_diagnosis = l_id_diagnosis
                               AND ed.flg_type = l_flg_type
                               AND (eg.id_staging_basis IS NOT NULL OR i_flg_call = pk_edis_hist.g_call_hist)
                            
                            UNION ALL
                            
                            SELECT eh.id_epis_diagnosis,
                                   eh.id_epis_diagnosis_hist,
                                   egh.num_staging_basis,
                                   egh.id_staging_basis,
                                   eh.flg_mult_tumors,
                                   eh.num_primary_tumors,
                                   id_tnm_t,
                                   code_tnm_t,
                                   id_tnm_n,
                                   code_tnm_n,
                                   id_tnm_m,
                                   code_tnm_m,
                                   id_metastatic_sites,
                                   id_residual_tumor,
                                   id_surgical_margins,
                                   id_lymph_vasc_inv,
                                   id_other_staging_sys,
                                   id_staging_group,
                                   eh.dt_creation_tstz dt_epis_diagnosis_stag,
                                   id_prof_create,
                                   eh.flg_status,
                                   -- if the staging is not cancelled the status is retrieved by the epis_diagnosis record
                                   nvl2(egh.id_cancel_reason, pk_alert_constant.g_cancelled, NULL) flg_stag_status,
                                   egh.id_cancel_reason,
                                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, egh.id_cancel_reason) desc_cancel_reason,
                                   egh.cancel_notes,
                                   nvl2(egh.id_epis_diagnosis, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_has_staging
                              FROM epis_diagnosis_hist eh
                              JOIN epis_diagnosis ed
                                ON ed.id_epis_diagnosis = eh.id_epis_diagnosis
                              JOIN episode e
                                ON e.id_episode = ed.id_episode
                              LEFT JOIN epis_diag_stag_hist egh
                                ON egh.id_epis_diagnosis_hist = eh.id_epis_diagnosis_hist
                             WHERE e.id_patient = l_id_patient
                               AND ed.id_diagnosis = l_id_diagnosis
                               AND ed.flg_type = l_flg_type
                               AND (egh.id_staging_basis IS NOT NULL OR i_flg_call = pk_edis_hist.g_call_hist)) staging) t
              LEFT JOIN diagnosis_ea de
                ON de.id_concept_term = t.id_staging_basis
               AND de.flg_msi_concept_term = pk_diagnosis.g_diag_pesq
               AND de.id_institution = i_prof.institution
               AND de.id_software = i_prof.software
             WHERE ((i_flg_call = pk_edis_hist.g_call_detail AND
                   (t.id_epis_diagnosis_hist = i_epis_diag_hist OR
                   (i_epis_diag_hist IS NULL AND t.id_epis_diagnosis_hist IS NULL))) OR
                   (i_flg_call != pk_edis_hist.g_call_detail AND (i_flg_call = pk_edis_hist.g_call_hist OR (rn = 1))))
             ORDER BY de.rank DESC NULLS LAST, t.num_staging_basis DESC, t.dt_epis_diagnosis_stag DESC;
    
        TYPE t_tab_all_stagings IS TABLE OF c_all_stagings%ROWTYPE;
    
        l_tab_stagings t_tab_all_stagings;
    
        FUNCTION get_concept_code(i_concept_term IN alert_diagnosis.id_alert_diagnosis%TYPE) RETURN diagnosis.code_icd%TYPE IS
            l_concept_code diagnosis.code_icd%TYPE;
        BEGIN
            SELECT d.code_icd
              INTO l_concept_code
              FROM diagnosis d
              JOIN alert_diagnosis ad
                ON ad.id_diagnosis = d.id_diagnosis
             WHERE ad.id_alert_diagnosis = i_concept_term;
        
            RETURN l_concept_code;
        EXCEPTION
            WHEN OTHERS THEN
                RETURN NULL;
        END get_concept_code;
    BEGIN
    
        l_table := pk_edis_types.tab_epis_diag_staging();
    
        l_id_patient := pk_episode.get_id_patient(i_episode);
    
        SELECT d.id_diagnosis, check_diag_cancer(i_lang, i_prof, d.concept_type_int_name), ed.flg_type
          INTO l_id_diagnosis, l_is_cancer_diag, l_flg_type
          FROM epis_diagnosis ed
          JOIN diagnosis d
            ON d.id_diagnosis = ed.id_diagnosis
         WHERE ed.id_epis_diagnosis = i_epis_diag;
    
        IF l_is_cancer_diag = pk_alert_constant.g_yes
        THEN
        
            l_desc_tnm_considered_crit := pk_message.get_message(i_lang, i_prof, l_code_tnm_considered_crit);
            l_desc_group_na            := pk_message.get_message(i_lang, i_prof, g_code_stag_group_not_avail);
        
            OPEN c_all_stagings;
            FETCH c_all_stagings BULK COLLECT
                INTO l_tab_stagings;
            CLOSE c_all_stagings;
        
            FOR i IN 1 .. l_tab_stagings.count
            LOOP
                IF (l_tab_stagings(i)
                   .flg_stag_status IS NULL AND l_tab_stagings(i)
                   .flg_status NOT IN (pk_diagnosis.g_ed_flg_status_r, pk_diagnosis.g_ed_flg_status_ca))
                   OR i_flg_call = pk_edis_hist.g_call_hist
                THEN
                    l_table.extend;
                    l_table(l_table.count).num_staging_basis := l_tab_stagings(i).num_staging_basis;
                    l_table(l_table.count).id_epis_diagnosis := l_tab_stagings(i).id_epis_diagnosis;
                    l_table(l_table.count).id_epis_diagnosis_hist := l_tab_stagings(i).id_epis_diagnosis_hist;
                    l_table(l_table.count).id_staging_basis := l_tab_stagings(i).id_staging_basis;
                    l_table(l_table.count).rank := l_tab_stagings(i).rank;
                    l_table(l_table.count).flg_status := l_tab_stagings(i).flg_stag_status;
                    l_table(l_table.count).desc_status := pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status,
                                                                                  l_tab_stagings(i).flg_stag_status,
                                                                                  i_lang);
                    l_table(l_table.count).id_cancel_reason := l_tab_stagings(i).id_cancel_reason;
                    l_table(l_table.count).desc_cancel_reason := l_tab_stagings(i).desc_cancel_reason;
                    l_table(l_table.count).cancel_notes := l_tab_stagings(i).cancel_notes;
                
                    -- staging ID was fetched. proceed to the next iteration
                    -- also if we are fetching the history records and no staging basis was found we dont need to fetch the rest of the info
                    IF i_flg_ret_type = g_stage_ret_only_ids
                       OR l_tab_stagings(i).flg_has_staging = pk_alert_constant.g_no
                    THEN
                        CONTINUE;
                    END IF;
                
                    l_diag_staging_basis := pk_diagnosis_core.get_term_diagnosis_id(l_tab_stagings(i).id_staging_basis,
                                                                                    i_prof.institution,
                                                                                    i_prof.software);
                
                    l_tnm.code_stage_t := l_tab_stagings(i).code_tnm_t ||
                                           pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_tnm_t,
                                                                                                      i_prof.institution,
                                                                                                      i_prof.software);
                    l_tnm.code_stage_n := l_tab_stagings(i).code_tnm_n ||
                                           pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_tnm_n,
                                                                                                      i_prof.institution,
                                                                                                      i_prof.software);
                    l_tnm.code_stage_m := l_tab_stagings(i).code_tnm_m ||
                                           pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_tnm_m,
                                                                                                      i_prof.institution,
                                                                                                      i_prof.software);
                
                    l_table(l_table.count).desc_staging_basis := pk_diagnosis.std_staging_basis_desc(i_lang               => i_lang,
                                                                                                     i_prof               => i_prof,
                                                                                                     i_id_diagnosis       => l_diag_staging_basis,
                                                                                                     i_id_alert_diagnosis => l_tab_stagings(i).id_staging_basis,
                                                                                                     i_code               => pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_staging_basis,
                                                                                                                                                                       i_prof.institution,
                                                                                                                                                                       i_prof.software),
                                                                                                     i_flg_other          => pk_alert_constant.g_no,
                                                                                                     i_flg_std_diag       => pk_alert_constant.g_yes,
                                                                                                     i_staging_basis_type => l_tab_stagings(i).staging_basis_type,
                                                                                                     i_num_staging_basis  => l_tab_stagings(i).num_staging_basis);
                    l_table(l_table.count).id_tnm_t := l_tab_stagings(i).id_tnm_t;
                    l_table(l_table.count).desc_tnm_t := pk_diagnosis.std_tnm_desc(i_lang               => i_lang,
                                                                                   i_prof               => i_prof,
                                                                                   i_id_alert_diagnosis => l_tab_stagings(i).id_tnm_t,
                                                                                   i_code               => l_tnm.code_stage_t,
                                                                                   i_flg_other          => pk_alert_constant.g_no,
                                                                                   i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).code_tnm_t := l_tab_stagings(i).code_tnm_t;
                    l_table(l_table.count).concept_code_t := get_concept_code(i_concept_term => l_tab_stagings(i).id_tnm_t);
                    l_table(l_table.count).id_tnm_n := l_tab_stagings(i).id_tnm_n;
                    l_table(l_table.count).desc_tnm_n := pk_diagnosis.std_tnm_desc(i_lang               => i_lang,
                                                                                   i_prof               => i_prof,
                                                                                   i_id_alert_diagnosis => l_tab_stagings(i).id_tnm_n,
                                                                                   i_code               => l_tnm.code_stage_n,
                                                                                   i_flg_other          => pk_alert_constant.g_no,
                                                                                   i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).code_tnm_n := l_tab_stagings(i).code_tnm_n;
                    l_table(l_table.count).concept_code_n := get_concept_code(i_concept_term => l_tab_stagings(i).id_tnm_n);
                    l_table(l_table.count).id_tnm_m := l_tab_stagings(i).id_tnm_m;
                    l_table(l_table.count).desc_tnm_m := pk_diagnosis.std_tnm_desc(i_lang               => i_lang,
                                                                                   i_prof               => i_prof,
                                                                                   i_id_alert_diagnosis => l_tab_stagings(i).id_tnm_m,
                                                                                   i_code               => l_tnm.code_stage_m,
                                                                                   i_flg_other          => pk_alert_constant.g_no,
                                                                                   i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).code_tnm_m := l_tab_stagings(i).code_tnm_m;
                    l_table(l_table.count).concept_code_m := get_concept_code(i_concept_term => l_tab_stagings(i).id_tnm_m);
                
                    l_table(l_table.count).desc_tnm := pk_diagnosis_core.get_desc_tnm(i_lang            => i_lang,
                                                                                      i_prof            => i_prof,
                                                                                      i_tnm             => l_tnm,
                                                                                      i_flg_mult_tumors => l_tab_stagings(i).flg_mult_tumors,
                                                                                      i_num_prim_tumors => l_tab_stagings(i).num_primary_tumors);
                
                    l_table(l_table.count).id_metastatic_sites := l_tab_stagings(i).id_metastatic_sites;
                    l_table(l_table.count).desc_metastatic_sites := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                               i_prof               => i_prof,
                                                                                               i_id_alert_diagnosis => l_tab_stagings(i).id_metastatic_sites,
                                                                                               i_code               => pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_metastatic_sites,
                                                                                                                                                                 i_prof.institution,
                                                                                                                                                                 i_prof.software),
                                                                                               i_flg_other          => pk_alert_constant.g_no,
                                                                                               i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).desc_group_title := l_table(l_table.count).desc_tnm || ' ' ||
                                                                pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                                 i_prof               => i_prof,
                                                                                                                 i_id_alert_diagnosis => l_tab_stagings(i).id_staging_group,
                                                                                                                 i_code               => NULL,
                                                                                                                 i_flg_other          => pk_alert_constant.g_no,
                                                                                                                 i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).desc_stage_title := pk_diagnosis.std_staging_basis_desc(i_lang               => i_lang,
                                                                                                   i_prof               => i_prof,
                                                                                                   i_id_diagnosis       => l_diag_staging_basis,
                                                                                                   i_code               => NULL,
                                                                                                   i_flg_other          => pk_alert_constant.g_no,
                                                                                                   i_flg_std_diag       => pk_alert_constant.g_yes,
                                                                                                   i_staging_basis_type => l_tab_stagings(i).staging_basis_type,
                                                                                                   i_num_staging_basis  => l_tab_stagings(i).num_staging_basis,
                                                                                                   i_show_full_desc     => pk_alert_constant.g_yes);
                    l_table(l_table.count).id_staging_group := l_tab_stagings(i).id_staging_group;
                    l_table(l_table.count).desc_group := nvl(pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_staging_group,
                                                                                                       i_prof.institution,
                                                                                                       i_prof.software),
                                                             l_desc_group_na) || ' - ' || l_desc_tnm_considered_crit;
                    l_table(l_table.count).desc_staging := l_table(l_table.count).desc_stage_title || ' ' || l_table(l_table.count).desc_group_title;
                    l_table(l_table.count).id_residual_tumor := l_tab_stagings(i).id_residual_tumor;
                    l_table(l_table.count).desc_residual_tumor := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                             i_prof               => i_prof,
                                                                                             i_id_alert_diagnosis => l_tab_stagings(i).id_residual_tumor,
                                                                                             i_code               => pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_residual_tumor,
                                                                                                                                                               i_prof.institution,
                                                                                                                                                               i_prof.software),
                                                                                             i_flg_other          => pk_alert_constant.g_no,
                                                                                             i_flg_std_diag       => pk_alert_constant.g_yes,
                                                                                             i_flg_search_mode    => pk_alert_constant.g_yes);
                    l_table(l_table.count).id_surgical_margins := l_tab_stagings(i).id_surgical_margins;
                    l_table(l_table.count).desc_surgical_margins := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                               i_prof               => i_prof,
                                                                                               i_id_alert_diagnosis => l_tab_stagings(i).id_surgical_margins,
                                                                                               i_code               => NULL,
                                                                                               i_flg_other          => pk_alert_constant.g_no,
                                                                                               i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).id_lymph_vasc_inv := l_tab_stagings(i).id_lymph_vasc_inv;
                    l_table(l_table.count).desc_lymph_vasc_inv := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                             i_prof               => i_prof,
                                                                                             i_id_alert_diagnosis => l_tab_stagings(i).id_lymph_vasc_inv,
                                                                                             i_code               => NULL,
                                                                                             i_flg_other          => pk_alert_constant.g_no,
                                                                                             i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).id_other_staging_sys := l_tab_stagings(i).id_other_staging_sys;
                    l_table(l_table.count).desc_other_staging_sys := pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                                                                i_prof               => i_prof,
                                                                                                i_id_alert_diagnosis => l_tab_stagings(i).id_other_staging_sys,
                                                                                                i_code               => pk_diagnosis_core.get_term_diagnosis_code(l_tab_stagings(i).id_other_staging_sys,
                                                                                                                                                                  i_prof.institution,
                                                                                                                                                                  i_prof.software),
                                                                                                i_flg_other          => pk_alert_constant.g_no,
                                                                                                i_flg_std_diag       => pk_alert_constant.g_yes);
                    l_table(l_table.count).dt_epis_diagnosis_stag := l_tab_stagings(i).dt_epis_diagnosis_stag;
                    l_table(l_table.count).dt_epis_diag_stag_chr := pk_date_utils.date_char_tsz(i_lang,
                                                                                                l_tab_stagings(i).dt_epis_diagnosis_stag,
                                                                                                i_prof.institution,
                                                                                                i_prof.software);
                    l_table(l_table.count).id_prof_create := l_tab_stagings(i).id_prof_create;
                    l_table(l_table.count).name_prof_create := pk_prof_utils.get_name_signature(i_lang,
                                                                                                i_prof,
                                                                                                l_tab_stagings(i).id_prof_create);
                    l_table(l_table.count).desc_spec_create := pk_prof_utils.get_spec_signature(i_lang,
                                                                                                i_prof,
                                                                                                l_tab_stagings(i).id_prof_create,
                                                                                                l_tab_stagings(i).dt_epis_diagnosis_stag,
                                                                                                i_episode);
                
                    l_table(l_table.count).prog_factors := get_epis_diag_factors(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_episode           => i_episode,
                                                                                 i_epis_diag         => l_tab_stagings(i).id_epis_diagnosis,
                                                                                 i_epis_diag_hist    => l_tab_stagings(i).id_epis_diagnosis_hist,
                                                                                 i_staging_basis     => l_tab_stagings(i).id_staging_basis,
                                                                                 i_num_staging_basis => l_tab_stagings(i).num_staging_basis);
                END IF;
            END LOOP;
        END IF;
    
        RETURN l_table;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_STAGINGS',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_epis_diag_stagings;

    /********************************************************************************************
    * Function that gives all the information registered in a diagnosis record
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    * @param i_rec_epis_stag          staging record (calculated earlier before fetching the rest of the diagnosis info)
    * @param o_rec_epis_stag          staging record
    * @param o_tab_epis_tumors        tumors data
    * @param o_rec_epis_diag          diagnosis general info
    * @param o_error                  Error message
    *
    * @return                         true or false
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/27
    **********************************************************************************************/
    FUNCTION get_epis_diag_rec
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_epis_diag           IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist      IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        i_rec_epis_stag       IN pk_edis_types.rec_epis_diag_staging,
        i_flg_edit_mode       IN VARCHAR2 DEFAULT NULL,
        o_rec_epis_stag       OUT pk_edis_types.rec_epis_diag_staging,
        o_tab_epis_tumors     OUT pk_edis_types.tab_epis_diag_tumors,
        o_rec_epis_diag       OUT pk_edis_types.rec_epis_diagnosis,
        o_tab_epis_diag_compl OUT pk_edis_types.table_out_complications,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_rec_epis_diag   pk_edis_types.rec_epis_diagnosis;
        l_tab_epis_stag   pk_edis_types.tab_epis_diag_staging;
        l_rec_epis_stag   pk_edis_types.rec_epis_diag_staging;
        l_tab_epis_tumors pk_edis_types.tab_epis_diag_tumors;
    
        l_tab_epis_diag_compl pk_edis_types.table_out_complications := pk_edis_types.table_out_complications();
    
    BEGIN
    
        IF i_rec_epis_stag.num_staging_basis IS NOT NULL
        THEN
            l_rec_epis_stag := i_rec_epis_stag;
        ELSE
            l_tab_epis_stag := get_epis_diag_stagings(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_episode        => i_episode,
                                                      i_flg_call       => pk_edis_hist.g_call_detail,
                                                      i_epis_diag      => i_epis_diag,
                                                      i_epis_diag_hist => i_epis_diag_hist);
        
            IF l_tab_epis_stag.exists(1)
            THEN
                l_rec_epis_stag := l_tab_epis_stag(1);
            END IF;
        END IF;
    
        l_tab_epis_tumors := get_epis_diag_tumors(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_episode        => i_episode,
                                                  i_epis_diag      => i_epis_diag,
                                                  i_epis_diag_hist => i_epis_diag_hist);
    
        l_rec_epis_diag := get_epis_diag(i_lang           => i_lang,
                                         i_prof           => i_prof,
                                         i_episode        => i_episode,
                                         i_epis_diag      => i_epis_diag,
                                         i_epis_diag_hist => i_epis_diag_hist);
    
        -- at this moment we don't want to import complication in epis diagnosis creation
        -- this situation can occur when creating a discharge diagnosis based on a differencial diagnosis and the complications are imported
        IF i_flg_edit_mode != pk_diagnosis_core.g_diag_create_mode
           OR i_flg_edit_mode IS NULL
        THEN
            l_tab_epis_diag_compl := pk_complication.get_epis_diag_complications(i_lang                => i_lang,
                                                                                 i_prof                => i_prof,
                                                                                 i_id_epis_diagnosis   => i_epis_diag,
                                                                                 i_id_epis_diagnosis_h => i_epis_diag_hist);
        END IF;
    
        o_rec_epis_stag       := l_rec_epis_stag;
        o_tab_epis_tumors     := l_tab_epis_tumors;
        o_rec_epis_diag       := l_rec_epis_diag;
        o_tab_epis_diag_compl := l_tab_epis_diag_compl;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_REC',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_diag_rec;

    /********************************************************************************************
    * Function that gives all the information registered in a diagnosis record
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    *
    * @return                         Epis diagnosis record used as input parameter in save functions
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_epis_diag_rec
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_epis_diag_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE DEFAULT NULL
    ) RETURN pk_edis_types.rec_in_epis_diagnosis IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAG_REC';
        --
        CURSOR c_epis_diag(i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE) IS
            SELECT ed.id_patient,
                   ed.id_episode,
                   ed.flg_type,
                   ed.id_cdr_call,
                   ed.id_epis_diagnosis,
                   ed.id_diagnosis,
                   ed.id_alert_diagnosis,
                   ed.desc_epis_diagnosis,
                   ed.flg_final_type,
                   ed.flg_status,
                   ed.flg_add_problem,
                   ed.notes,
                   ed.dt_initial_diag,
                   ed.id_diag_basis,
                   ed.diag_basis_spec,
                   ed.flg_recurrence,
                   ed.flg_mult_tumors,
                   ed.num_primary_tumors,
                   ed.id_diagnosis_condition,
                   ed.id_sub_analysis,
                   ed.id_anatomical_area,
                   ed.id_anatomical_side,
                   ed.id_lesion_location,
                   ed.id_lesion_type,
                   ed.rank
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis = i_epis_diagnosis;
    
        r_epis_diag c_epis_diag%ROWTYPE;
    
        CURSOR c_tumors(i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE) IS
            SELECT edt.tumor_num,
                   edt.id_topography,
                   edt.id_laterality,
                   edt.id_morphology,
                   edt.id_behavior,
                   edt.id_histological_grade,
                   edt.id_other_grading_sys,
                   edt.flg_unknown_dimension,
                   edt.num_dimension,
                   edt.desc_dimension,
                   edt.additional_pathol_info
              FROM epis_diag_tumors edt
             WHERE edt.id_epis_diagnosis = i_epis_diagnosis;
    
        r_tumor c_tumors%ROWTYPE;
    
        CURSOR c_diag_staging(i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE) IS
            SELECT eds.num_staging_basis,
                   eds.id_staging_basis,
                   eds.id_tnm_t,
                   eds.code_tnm_t,
                   eds.id_tnm_n,
                   eds.code_tnm_n,
                   eds.id_tnm_m,
                   eds.code_tnm_m,
                   eds.id_metastatic_sites,
                   eds.id_staging_group,
                   eds.id_residual_tumor,
                   eds.id_surgical_margins,
                   eds.id_lymph_vasc_inv,
                   eds.id_other_staging_sys
              FROM epis_diag_stag eds
             WHERE eds.id_epis_diagnosis = i_epis_diagnosis;
    
        r_diag_staging c_diag_staging%ROWTYPE;
    
        CURSOR c_prog_factors
        (
            i_epis_diagnosis    IN epis_diagnosis.id_epis_diagnosis%TYPE,
            i_staging_basis     IN epis_diag_stag.id_staging_basis%TYPE,
            i_num_staging_basis IN epis_diag_stag.num_staging_basis%TYPE
        ) IS
            SELECT edsp.num_staging_basis, edsp.id_field, edsp.field_rank, edsp.id_value, edsp.desc_value
              FROM epis_diag_stag_pfact edsp
             WHERE edsp.id_epis_diagnosis = i_epis_diagnosis
               AND edsp.id_staging_basis = i_staging_basis
               AND edsp.num_staging_basis = i_num_staging_basis;
    
        r_prog_factor c_prog_factors%ROWTYPE;
        --
        CURSOR c_epis_diag_hist(i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE) IS
            SELECT ed.id_epis_diagnosis,
                   ed.id_patient,
                   ed.id_episode,
                   edh.flg_type,
                   edh.id_cdr_call,
                   ed.id_diagnosis,
                   ed.id_alert_diagnosis,
                   ed.desc_epis_diagnosis,
                   edh.flg_final_type,
                   edh.flg_status,
                   edh.flg_add_problem,
                   edh.notes,
                   edh.dt_initial_diag,
                   edh.id_diag_basis,
                   edh.diag_basis_spec,
                   edh.flg_recurrence,
                   edh.flg_mult_tumors,
                   edh.num_primary_tumors,
                   edh.id_diagnosis_condition,
                   edh.id_sub_analysis,
                   edh.id_anatomical_area,
                   edh.id_anatomical_side,
                   edh.id_lesion_location,
                   edh.id_lesion_type,
                   edh.rank
              FROM epis_diagnosis ed
              JOIN epis_diagnosis_hist edh
                ON edh.id_epis_diagnosis = ed.id_epis_diagnosis
             WHERE edh.id_epis_diagnosis_hist = i_epis_diagnosis_hist;
    
        r_epis_diag_hist c_epis_diag_hist%ROWTYPE;
    
        CURSOR c_tumors_hist
        (
            i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
            i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE
        ) IS
            SELECT edth.tumor_num,
                   edth.id_topography,
                   edth.id_laterality,
                   edth.id_morphology,
                   edth.id_behavior,
                   edth.id_histological_grade,
                   edth.id_other_grading_sys,
                   edth.flg_unknown_dimension,
                   edth.num_dimension,
                   edth.desc_dimension,
                   edth.additional_pathol_info
              FROM epis_diag_tumors_hist edth
             WHERE edth.id_epis_diagnosis_hist = i_epis_diagnosis_hist
               AND edth.id_epis_diagnosis = i_epis_diagnosis;
    
        r_tumor_hist c_tumors_hist%ROWTYPE;
    
        CURSOR c_diag_staging_hist
        (
            i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
            i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE
        ) IS
            SELECT edsh.num_staging_basis,
                   edsh.id_staging_basis,
                   edsh.id_tnm_t,
                   edsh.code_tnm_t,
                   edsh.id_tnm_n,
                   edsh.code_tnm_n,
                   edsh.id_tnm_m,
                   edsh.code_tnm_m,
                   edsh.id_metastatic_sites,
                   edsh.id_staging_group,
                   edsh.id_residual_tumor,
                   edsh.id_surgical_margins,
                   edsh.id_lymph_vasc_inv,
                   edsh.id_other_staging_sys
              FROM epis_diag_stag_hist edsh
             WHERE edsh.id_epis_diagnosis_hist = i_epis_diagnosis_hist
               AND edsh.id_epis_diagnosis = i_epis_diagnosis;
    
        r_diag_staging_hist c_diag_staging_hist%ROWTYPE;
    
        CURSOR c_prog_factors_hist
        (
            i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
            i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE,
            i_staging_basis       IN epis_diag_stag.id_staging_basis%TYPE,
            i_num_staging_basis   IN epis_diag_stag.num_staging_basis%TYPE
        ) IS
            SELECT edsph.num_staging_basis, edsph.id_field, edsph.field_rank, edsph.id_value, edsph.desc_value
              FROM epis_dstag_pfact_hist edsph
             WHERE edsph.id_epis_diagnosis_hist = i_epis_diagnosis_hist
               AND edsph.id_epis_diagnosis = i_epis_diagnosis
               AND edsph.id_staging_basis = i_staging_basis
               AND edsph.num_staging_basis = i_num_staging_basis;
    
        r_prog_factor_hist c_prog_factors_hist%ROWTYPE;
        --
        l_rec_epis_diag    pk_edis_types.rec_in_epis_diagnosis;
        l_rec_diag         pk_edis_types.rec_in_diagnosis;
        l_tbl_tumors       pk_edis_types.table_in_tumors;
        l_tumor            pk_edis_types.rec_in_tumor;
        l_tbl_diag_staging pk_edis_types.table_in_diag_staging;
        l_diag_staging     pk_edis_types.rec_in_diag_staging;
        l_tbl_prog_factors pk_edis_types.table_in_prog_factor;
        l_prog_factor      pk_edis_types.rec_in_prog_factor;
    BEGIN
        IF i_epis_diag_hist IS NOT NULL
        THEN
            g_error := 'OPEN C_EPIS_DIAG_HIST - ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            OPEN c_epis_diag_hist(i_epis_diagnosis_hist => i_epis_diag_hist);
            FETCH c_epis_diag_hist
                INTO r_epis_diag_hist;
            CLOSE c_epis_diag_hist;
        
            l_rec_epis_diag.id_epis_diagnosis        := r_epis_diag_hist.id_epis_diagnosis;
            l_rec_epis_diag.id_epis_diagnosis_hist   := i_epis_diag_hist;
            l_rec_epis_diag.id_patient               := r_epis_diag_hist.id_patient;
            l_rec_epis_diag.id_episode               := r_epis_diag_hist.id_episode;
            l_rec_epis_diag.prof_cat_type            := NULL; --only used when creating a new diagnosis
            l_rec_epis_diag.flg_type                 := r_epis_diag_hist.flg_type;
            l_rec_epis_diag.flg_edit_mode            := pk_diagnosis_core.g_diag_edit_mode_edit;
            l_rec_epis_diag.flg_transf_final         := NULL; --only used when creating a new diagnosis
            l_rec_epis_diag.id_cdr_call              := r_epis_diag_hist.id_cdr_call;
            l_rec_epis_diag.flg_val_single_prim_diag := nvl(pk_sysconfig.get_config(i_code_cf => pk_diagnosis_core.g_cfg_single_prim_diag,
                                                                                    i_prof    => i_prof),
                                                            pk_alert_constant.g_yes);
        
            l_rec_diag.id_diagnosis           := r_epis_diag_hist.id_diagnosis;
            l_rec_diag.id_alert_diagnosis     := r_epis_diag_hist.id_alert_diagnosis;
            l_rec_diag.desc_diagnosis         := r_epis_diag_hist.desc_epis_diagnosis;
            l_rec_diag.flg_final_type         := r_epis_diag_hist.flg_final_type;
            l_rec_diag.flg_status             := r_epis_diag_hist.flg_status;
            l_rec_diag.flg_add_problem        := r_epis_diag_hist.flg_add_problem;
            l_rec_diag.notes                  := r_epis_diag_hist.notes;
            l_rec_diag.dt_initial_diag        := r_epis_diag_hist.dt_initial_diag;
            l_rec_diag.id_diag_basis          := r_epis_diag_hist.id_diag_basis;
            l_rec_diag.diag_basis_spec        := r_epis_diag_hist.diag_basis_spec;
            l_rec_diag.flg_recurrence         := r_epis_diag_hist.flg_recurrence;
            l_rec_diag.flg_mult_tumors        := r_epis_diag_hist.flg_mult_tumors;
            l_rec_diag.num_primary_tumors     := r_epis_diag_hist.num_primary_tumors;
            l_rec_diag.id_diagnosis_condition := r_epis_diag_hist.id_diagnosis_condition;
            l_rec_diag.id_sub_analysis        := r_epis_diag_hist.id_sub_analysis;
            l_rec_diag.id_anatomical_area     := r_epis_diag_hist.id_anatomical_area;
            l_rec_diag.id_anatomical_side     := r_epis_diag_hist.id_anatomical_side;
            l_rec_diag.id_lesion_location     := r_epis_diag_hist.id_lesion_location;
            l_rec_diag.id_lesion_type         := r_epis_diag_hist.id_lesion_type;
            l_rec_diag.rank                   := r_epis_diag_hist.rank;
            l_tbl_tumors                      := pk_edis_types.table_in_tumors();
        
            g_error := 'LOOP THROUGH TUMORS_HIST - ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR r_tumor_hist IN c_tumors_hist(i_epis_diagnosis_hist => i_epis_diag_hist,
                                              i_epis_diagnosis      => r_epis_diag_hist.id_epis_diagnosis)
            LOOP
                l_tumor.tumor_num              := r_tumor_hist.tumor_num;
                l_tumor.id_topography          := r_tumor_hist.id_topography;
                l_tumor.id_laterality          := r_tumor_hist.id_laterality;
                l_tumor.morphology.morphology  := r_tumor_hist.id_morphology;
                l_tumor.morphology.behavior    := r_tumor_hist.id_behavior;
                l_tumor.morphology.grade       := r_tumor_hist.id_histological_grade;
                l_tumor.id_other_grading_sys   := r_tumor_hist.id_other_grading_sys;
                l_tumor.flg_unknown_dimension  := r_tumor_hist.flg_unknown_dimension;
                l_tumor.num_dimension          := r_tumor_hist.num_dimension;
                l_tumor.desc_dimension         := r_tumor_hist.desc_dimension;
                l_tumor.additional_pathol_info := r_tumor_hist.additional_pathol_info;
            
                l_tbl_tumors.extend;
                l_tbl_tumors(l_tbl_tumors.count) := l_tumor;
            END LOOP;
        
            l_rec_diag.tbl_tumors := l_tbl_tumors;
        
            l_tbl_diag_staging := pk_edis_types.table_in_diag_staging();
        
            g_error := 'LOOP THROUGH STAGING_HIST - ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR r_diag_staging_hist IN c_diag_staging_hist(i_epis_diagnosis_hist => i_epis_diag_hist,
                                                           i_epis_diagnosis      => r_epis_diag_hist.id_epis_diagnosis)
            LOOP
                l_diag_staging.num_staging_basis    := r_diag_staging_hist.num_staging_basis;
                l_diag_staging.id_staging_basis     := r_diag_staging_hist.id_staging_basis;
                l_diag_staging.tnm.t                := r_diag_staging_hist.id_tnm_t;
                l_diag_staging.tnm.code_stage_t     := r_diag_staging_hist.code_tnm_t;
                l_diag_staging.tnm.n                := r_diag_staging_hist.id_tnm_n;
                l_diag_staging.tnm.code_stage_n     := r_diag_staging_hist.code_tnm_n;
                l_diag_staging.tnm.m                := r_diag_staging_hist.id_tnm_m;
                l_diag_staging.tnm.code_stage_m     := r_diag_staging_hist.code_tnm_m;
                l_diag_staging.id_metastatic_sites  := r_diag_staging_hist.id_metastatic_sites;
                l_diag_staging.id_staging_group     := r_diag_staging_hist.id_staging_group;
                l_diag_staging.id_residual_tumor    := r_diag_staging_hist.id_residual_tumor;
                l_diag_staging.id_surgical_margins  := r_diag_staging_hist.id_surgical_margins;
                l_diag_staging.id_lymph_vasc_inv    := r_diag_staging_hist.id_lymph_vasc_inv;
                l_diag_staging.id_other_staging_sys := r_diag_staging_hist.id_other_staging_sys;
            
                l_tbl_prog_factors := pk_edis_types.table_in_prog_factor();
            
                g_error := 'LOOP THROUGH PROG_FACTORS_HIST - ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist ||
                           '; NUM_STAGING_BASIS: ' || l_diag_staging.num_staging_basis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FOR r_prog_factor_hist IN c_prog_factors_hist(i_epis_diagnosis_hist => i_epis_diag_hist,
                                                              i_epis_diagnosis      => r_epis_diag_hist.id_epis_diagnosis,
                                                              i_staging_basis       => l_diag_staging.id_staging_basis,
                                                              i_num_staging_basis   => l_diag_staging.num_staging_basis)
                LOOP
                    l_prog_factor.id_field   := r_prog_factor_hist.id_field;
                    l_prog_factor.field_rank := r_prog_factor_hist.field_rank;
                    l_prog_factor.id_value   := r_prog_factor_hist.id_value;
                    l_prog_factor.desc_value := r_prog_factor_hist.desc_value;
                
                    l_tbl_prog_factors.extend;
                    l_tbl_prog_factors(l_tbl_prog_factors.count) := l_prog_factor;
                END LOOP;
            
                l_diag_staging.tbl_prog_factors := l_tbl_prog_factors;
            
                l_tbl_diag_staging.extend;
                l_tbl_diag_staging(l_tbl_diag_staging.count) := l_diag_staging;
            END LOOP;
        
            l_rec_diag.tbl_diag_staging := l_tbl_diag_staging;
        
            l_rec_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_diag);
        
            l_rec_epis_diag.dt_record := g_sysdate_tstz;
        ELSIF i_epis_diag IS NOT NULL
        THEN
            g_error := 'OPEN C_EPIS_DIAG - ID_EPIS_DIAG: ' || i_epis_diag;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            OPEN c_epis_diag(i_epis_diagnosis => i_epis_diag);
            FETCH c_epis_diag
                INTO r_epis_diag;
            CLOSE c_epis_diag;
        
            l_rec_epis_diag.id_epis_diagnosis        := r_epis_diag.id_epis_diagnosis;
            l_rec_epis_diag.id_epis_diagnosis_hist   := NULL;
            l_rec_epis_diag.id_patient               := r_epis_diag.id_patient;
            l_rec_epis_diag.id_episode               := r_epis_diag.id_episode;
            l_rec_epis_diag.prof_cat_type            := NULL; --only used when creating a new diagnosis
            l_rec_epis_diag.flg_type                 := r_epis_diag.flg_type;
            l_rec_epis_diag.flg_edit_mode            := pk_diagnosis_core.g_diag_edit_mode_edit;
            l_rec_epis_diag.flg_transf_final         := NULL; --only used when creating a new diagnosis
            l_rec_epis_diag.id_cdr_call              := r_epis_diag.id_cdr_call;
            l_rec_epis_diag.flg_val_single_prim_diag := nvl(pk_sysconfig.get_config(i_code_cf => pk_diagnosis_core.g_cfg_single_prim_diag,
                                                                                    i_prof    => i_prof),
                                                            pk_alert_constant.g_yes);
        
            l_rec_diag.id_diagnosis           := r_epis_diag.id_diagnosis;
            l_rec_diag.id_alert_diagnosis     := r_epis_diag.id_alert_diagnosis;
            l_rec_diag.desc_diagnosis         := r_epis_diag.desc_epis_diagnosis;
            l_rec_diag.flg_final_type         := r_epis_diag.flg_final_type;
            l_rec_diag.flg_status             := r_epis_diag.flg_status;
            l_rec_diag.flg_add_problem        := r_epis_diag.flg_add_problem;
            l_rec_diag.notes                  := r_epis_diag.notes;
            l_rec_diag.dt_initial_diag        := r_epis_diag.dt_initial_diag;
            l_rec_diag.id_diag_basis          := r_epis_diag.id_diag_basis;
            l_rec_diag.diag_basis_spec        := r_epis_diag.diag_basis_spec;
            l_rec_diag.flg_recurrence         := r_epis_diag.flg_recurrence;
            l_rec_diag.flg_mult_tumors        := r_epis_diag.flg_mult_tumors;
            l_rec_diag.num_primary_tumors     := r_epis_diag.num_primary_tumors;
            l_rec_diag.id_diagnosis_condition := r_epis_diag.id_diagnosis_condition;
            l_rec_diag.id_sub_analysis        := r_epis_diag.id_sub_analysis;
            l_rec_diag.id_anatomical_area     := r_epis_diag.id_anatomical_area;
            l_rec_diag.id_anatomical_side     := r_epis_diag.id_anatomical_side;
            l_rec_diag.id_lesion_location     := r_epis_diag.id_lesion_location;
            l_rec_diag.id_lesion_type         := r_epis_diag.id_lesion_type;
            l_rec_diag.rank                   := r_epis_diag.rank;
        
            l_tbl_tumors := pk_edis_types.table_in_tumors();
        
            g_error := 'LOOP THROUGH TUMORS - ID_EPIS_DIAG: ' || i_epis_diag;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR r_tumor IN c_tumors(i_epis_diagnosis => i_epis_diag)
            LOOP
                l_tumor.tumor_num              := r_tumor.tumor_num;
                l_tumor.id_topography          := r_tumor.id_topography;
                l_tumor.id_laterality          := r_tumor.id_laterality;
                l_tumor.morphology.morphology  := r_tumor.id_morphology;
                l_tumor.morphology.behavior    := r_tumor.id_behavior;
                l_tumor.morphology.grade       := r_tumor.id_histological_grade;
                l_tumor.id_other_grading_sys   := r_tumor.id_other_grading_sys;
                l_tumor.flg_unknown_dimension  := r_tumor.flg_unknown_dimension;
                l_tumor.num_dimension          := r_tumor.num_dimension;
                l_tumor.desc_dimension         := r_tumor.desc_dimension;
                l_tumor.additional_pathol_info := r_tumor.additional_pathol_info;
            
                l_tbl_tumors.extend;
                l_tbl_tumors(l_tbl_tumors.count) := l_tumor;
            END LOOP;
        
            l_rec_diag.tbl_tumors := l_tbl_tumors;
        
            l_tbl_diag_staging := pk_edis_types.table_in_diag_staging();
        
            g_error := 'LOOP THROUGH STAGING - ID_EPIS_DIAG: ' || i_epis_diag;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR r_diag_staging IN c_diag_staging(i_epis_diagnosis => i_epis_diag)
            LOOP
                l_diag_staging.num_staging_basis    := r_diag_staging.num_staging_basis;
                l_diag_staging.id_staging_basis     := r_diag_staging.id_staging_basis;
                l_diag_staging.tnm.t                := r_diag_staging.id_tnm_t;
                l_diag_staging.tnm.code_stage_t     := r_diag_staging.code_tnm_t;
                l_diag_staging.tnm.n                := r_diag_staging.id_tnm_n;
                l_diag_staging.tnm.code_stage_n     := r_diag_staging.code_tnm_n;
                l_diag_staging.tnm.m                := r_diag_staging.id_tnm_m;
                l_diag_staging.tnm.code_stage_m     := r_diag_staging.code_tnm_m;
                l_diag_staging.id_metastatic_sites  := r_diag_staging.id_metastatic_sites;
                l_diag_staging.id_staging_group     := r_diag_staging.id_staging_group;
                l_diag_staging.id_residual_tumor    := r_diag_staging.id_residual_tumor;
                l_diag_staging.id_surgical_margins  := r_diag_staging.id_surgical_margins;
                l_diag_staging.id_lymph_vasc_inv    := r_diag_staging.id_lymph_vasc_inv;
                l_diag_staging.id_other_staging_sys := r_diag_staging.id_other_staging_sys;
            
                l_tbl_prog_factors := pk_edis_types.table_in_prog_factor();
            
                g_error := 'LOOP THROUGH PROG_FACTORS - ID_EPIS_DIAG: ' || i_epis_diag || '; NUM_STAGING_BASIS: ' ||
                           l_diag_staging.num_staging_basis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FOR r_prog_factor IN c_prog_factors(i_epis_diagnosis    => i_epis_diag,
                                                    i_staging_basis     => l_diag_staging.id_staging_basis,
                                                    i_num_staging_basis => l_diag_staging.num_staging_basis)
                LOOP
                    l_prog_factor.id_field   := r_prog_factor.id_field;
                    l_prog_factor.field_rank := r_prog_factor.field_rank;
                    l_prog_factor.id_value   := r_prog_factor.id_value;
                    l_prog_factor.desc_value := r_prog_factor.desc_value;
                
                    l_tbl_prog_factors.extend;
                    l_tbl_prog_factors(l_tbl_prog_factors.count) := l_prog_factor;
                END LOOP;
            
                l_diag_staging.tbl_prog_factors := l_tbl_prog_factors;
            
                l_tbl_diag_staging.extend;
                l_tbl_diag_staging(l_tbl_diag_staging.count) := l_diag_staging;
            END LOOP;
        
            l_rec_diag.tbl_diag_staging := l_tbl_diag_staging;
        
            l_rec_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_diag);
        
            l_rec_epis_diag.dt_record := g_sysdate_tstz;
        END IF;
    
        RETURN l_rec_epis_diag;
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  l_error);
            END;
            RETURN NULL;
    END get_epis_diag_rec;

    /********************************************************************************************
    * Returns the epis diagnosis record used as input parameter in save functions with the default values
    * for the given diagnosis
    * ATTENTION: This function shouldn't be used by default, please consult EDIS team before using it
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_params                 Table of XML with all input parameters
    *
    * @return                         Epis diagnosis record used as input parameter in save functions
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_diag_rec
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_params IN table_clob
    ) RETURN pk_edis_types.table_in_epis_diagnosis IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_REC';
        --
        l_table_epis_diag pk_edis_types.table_in_epis_diagnosis;
        l_rec_epis_diag   pk_edis_types.rec_in_epis_diagnoses;
        --
        l_exception EXCEPTION;
        l_error t_error_out;
    BEGIN
        l_table_epis_diag := pk_edis_types.table_in_epis_diagnosis();
    
        IF i_params IS NOT NULL
           AND i_params.count > 0
        THEN
            FOR i IN i_params.first .. i_params.last
            LOOP
                IF i_params(i) IS NOT NULL
                THEN
                    IF NOT pk_diagnosis_form.get_save_parameters(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_params                => i_params(i),
                                                                 o_rec_in_epis_diagnoses => l_rec_epis_diag,
                                                                 o_error                 => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    l_table_epis_diag.extend;
                    l_table_epis_diag(l_table_epis_diag.count) := l_rec_epis_diag.epis_diagnosis;
                ELSE
                    l_table_epis_diag.extend;
                END IF;
            END LOOP;
        END IF;
    
        RETURN l_table_epis_diag;
    EXCEPTION
        WHEN l_exception THEN
            RETURN NULL;
    END get_diag_rec;

    /********************************************************************************************
    * Returns the epis diagnosis record used as input parameter in save functions with the default values
    * for the given diagnosis
    * ATTENTION: This function shouldn't be used by default, please consult EDIS team before using it
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_patient                patient ID
    * @param i_episode                episode ID
    * @param i_diagnosis              Table with diagnosis ID
    * @param i_task_type              task type ID
    * @param i_cdr_call               cdr call ID
    *
    * @return                         Epis diagnosis record used as input parameter in save functions
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_diag_rec
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_patient         IN patient.id_patient%TYPE,
        i_episode         IN episode.id_episode%TYPE,
        i_diagnosis       IN table_table_number,
        i_alert_diagnosis IN table_table_number DEFAULT NULL,
        i_desc_diag       IN table_table_varchar DEFAULT NULL,
        i_task_type       IN NUMBER DEFAULT pk_alert_constant.g_task_diagnosis,
        i_cdr_call        IN cdr_call.id_cdr_call%TYPE DEFAULT NULL
    ) RETURN pk_edis_types.table_in_epis_diagnosis IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_REC';
        --
        l_table_epis_diag pk_edis_types.table_in_epis_diagnosis;
        l_alert_diag      table_number;
        l_desc_diag       table_varchar;
    BEGIN
        l_table_epis_diag := pk_edis_types.table_in_epis_diagnosis();
    
        IF i_diagnosis IS NOT NULL
           AND i_diagnosis.count > 0
        THEN
            FOR i IN i_diagnosis.first .. i_diagnosis.last
            LOOP
                l_alert_diag := NULL;
                IF i_alert_diagnosis IS NOT NULL
                   AND i_alert_diagnosis.exists(i)
                THEN
                    l_alert_diag := i_alert_diagnosis(i);
                END IF;
            
                l_desc_diag := NULL;
                IF i_desc_diag IS NOT NULL
                   AND i_desc_diag.exists(i)
                THEN
                    l_desc_diag := i_desc_diag(i);
                END IF;
            
                l_table_epis_diag.extend;
                l_table_epis_diag(l_table_epis_diag.count) := pk_diagnosis_core.get_diag_rec(i_lang            => i_lang,
                                                                                             i_prof            => i_prof,
                                                                                             i_patient         => i_patient,
                                                                                             i_episode         => i_episode,
                                                                                             i_diagnosis       => i_diagnosis(i),
                                                                                             i_alert_diagnosis => l_alert_diag,
                                                                                             i_desc_diag       => l_desc_diag,
                                                                                             i_task_type       => i_task_type,
                                                                                             i_cdr_call        => i_cdr_call);
            END LOOP;
        END IF;
    
        RETURN l_table_epis_diag;
    END get_diag_rec;

    /********************************************************************************************
    * Returns the epis diagnosis record used as input parameter in save functions with the default values
    * for the given diagnosis
    * ATTENTION: This function shouldn't be used by default, please consult EDIS team before using it
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_patient                patient ID
    * @param i_episode                episode ID
    * @param i_diagnosis              Table with diagnosis ID
    * @param i_task_type              task type ID
    * @param i_cdr_call               cdr call ID
    * @param i_id_epis_diagnosis      epis_diagnosis ID
    * @param i_flg_status             Table with diagnosis status
    * @param i_spec_notes             Table with diagnosis notes
    *
    * @return                         Epis diagnosis record used as input parameter in save functions
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_diag_rec
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_patient           IN patient.id_patient%TYPE,
        i_episode           IN episode.id_episode%TYPE,
        i_diagnosis         IN table_number,
        i_alert_diagnosis   IN table_number DEFAULT NULL,
        i_desc_diag         IN table_varchar DEFAULT NULL,
        i_task_type         IN NUMBER DEFAULT pk_alert_constant.g_task_diagnosis,
        i_cdr_call          IN cdr_call.id_cdr_call%TYPE DEFAULT NULL,
        i_id_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_flg_status        IN table_varchar DEFAULT NULL,
        i_spec_notes        IN table_varchar DEFAULT NULL,
        i_dt_diag           IN table_varchar DEFAULT NULL
    ) RETURN pk_edis_types.rec_in_epis_diagnosis IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_REC';
        --
        l_rec_epis_diag pk_edis_types.rec_in_epis_diagnosis;
        l_rec_diag      pk_edis_types.rec_in_diagnosis;
    BEGIN
        l_rec_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis();
    
        IF i_diagnosis IS NOT NULL
           AND i_diagnosis.count > 0
        THEN
            FOR i IN i_diagnosis.first .. i_diagnosis.last
            LOOP
                l_rec_diag.id_diagnosis := i_diagnosis(i);
            
                l_rec_diag.id_alert_diagnosis := NULL;
                IF i_alert_diagnosis IS NOT NULL
                   AND i_alert_diagnosis.exists(i)
                   AND i_alert_diagnosis(i) IS NOT NULL
                THEN
                    l_rec_diag.id_alert_diagnosis := i_alert_diagnosis(i);
                END IF;
            
                l_rec_diag.desc_diagnosis := NULL;
                IF i_desc_diag IS NOT NULL
                   AND i_desc_diag.exists(i)
                   AND i_desc_diag(i) IS NOT NULL
                THEN
                    l_rec_diag.desc_diagnosis := i_desc_diag(i);
                END IF;
            
                l_rec_diag.flg_status := pk_diagnosis.g_ed_flg_status_d;
                IF i_flg_status IS NOT NULL
                   AND i_flg_status.exists(i)
                   AND i_flg_status(i) IS NOT NULL
                THEN
                    l_rec_diag.flg_status := i_flg_status(i);
                END IF;
            
                l_rec_diag.notes := NULL;
                IF i_spec_notes IS NOT NULL
                   AND i_spec_notes.exists(i)
                   AND i_spec_notes(i) IS NOT NULL
                THEN
                    l_rec_diag.notes := i_spec_notes(i);
                END IF;
            
                l_rec_diag.dt_initial_diag := NULL;
                IF i_dt_diag IS NOT NULL
                   AND i_dt_diag.exists(i)
                   AND i_dt_diag(i) IS NOT NULL
                THEN
                    l_rec_diag.dt_initial_diag := pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_diag(i), NULL);
                END IF;
            
                l_rec_diag.flg_add_problem := pk_alert_constant.g_no;
            
                l_rec_epis_diag.tbl_diagnosis.extend;
                l_rec_epis_diag.tbl_diagnosis(l_rec_epis_diag.tbl_diagnosis.count) := l_rec_diag;
            END LOOP;
        END IF;
    
        l_rec_epis_diag.id_patient        := i_patient;
        l_rec_epis_diag.id_episode        := i_episode;
        l_rec_epis_diag.id_cdr_call       := i_cdr_call;
        l_rec_epis_diag.id_epis_diagnosis := i_id_epis_diagnosis;
    
        l_rec_epis_diag.flg_type := pk_diagnosis.g_diag_type_p;
    
        RETURN l_rec_epis_diag;
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  l_error);
            END;
            RETURN NULL;
    END get_diag_rec;

    /********************************************************************************************
    * Returns the epis diagnosis record used as input parameter in save functions with the default values
    * for the given diagnosis
    * ATTENTION: This function shouldn't be used by default, please consult EDIS team before using it
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_patient                patient ID
    * @param i_episode                episode ID
    * @param i_diagnosis              diagnosis ID
    * @param i_task_type              task type ID
    * @param i_cdr_call               cdr call ID
    * @param i_id_epis_diagnosis      epis_diagnosis ID
    * @param i_flg_status             Diagnosis status
    * @param i_spec_notes             Diagnosis notes
    *
    * @return                         Epis diagnosis record used as input parameter in save functions
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_diag_rec
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_patient           IN patient.id_patient%TYPE,
        i_episode           IN episode.id_episode%TYPE,
        i_diagnosis         IN diagnosis.id_diagnosis%TYPE,
        i_alert_diagnosis   IN alert_diagnosis.id_alert_diagnosis%TYPE DEFAULT NULL,
        i_desc_diag         IN epis_diagnosis.desc_epis_diagnosis%TYPE DEFAULT NULL,
        i_task_type         IN NUMBER DEFAULT pk_alert_constant.g_task_diagnosis,
        i_cdr_call          IN cdr_call.id_cdr_call%TYPE DEFAULT NULL,
        i_id_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_flg_status        IN epis_diagnosis.flg_status%TYPE DEFAULT NULL,
        i_spec_notes        IN epis_diagnosis.notes%TYPE DEFAULT NULL
    ) RETURN pk_edis_types.rec_in_epis_diagnosis IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_REC';
    BEGIN
        g_error := 'CALL PK_DIANGOSIS_CORE.GET_DIAG_REC - TABLE_NUMBER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        RETURN pk_diagnosis_core.get_diag_rec(i_lang              => i_lang,
                                              i_prof              => i_prof,
                                              i_patient           => i_patient,
                                              i_episode           => i_episode,
                                              i_diagnosis         => table_number(i_diagnosis),
                                              i_alert_diagnosis   => table_number(i_alert_diagnosis),
                                              i_desc_diag         => table_varchar(i_desc_diag),
                                              i_task_type         => i_task_type,
                                              i_cdr_call          => i_cdr_call,
                                              i_id_epis_diagnosis => i_id_epis_diagnosis,
                                              i_flg_status        => table_varchar(i_flg_status),
                                              i_spec_notes        => table_varchar(i_spec_notes));
    END get_diag_rec;

    /********************************************************************************************
    * Function that gives the staging general info of a specific diagnosis
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_flg_call               screen which called this method: V - viewer, D - detail
    * @param o_epis_diagnosis         diagnosis data
    * @param o_error                  error message
    *
    * @return                         true or false
    *
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          2012/02/27
    **********************************************************************************************/
    FUNCTION get_epis_diagnosis_det
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_flg_call       IN VARCHAR2,
        o_epis_diagnosis OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAGNOSIS_DET';
        l_count NUMBER;
    
        l_flg_call VARCHAR2(1 CHAR);
        l_space_format CONSTANT VARCHAR2(10 CHAR) := '   ';
        l_label_edition    sys_message.desc_message%TYPE;
        l_label_creation   sys_message.desc_message%TYPE;
        l_label_cancel     sys_message.desc_message%TYPE;
        l_label_main_tumor sys_message.desc_message%TYPE;
        l_label_diag_spec  sys_message.desc_message%TYPE;
        l_label_na         sys_message.desc_message%TYPE;
    
        -- staging records
        l_tab_epis_diag_staging pk_edis_types.tab_epis_diag_staging;
        l_rec_epis_diag_staging pk_edis_types.rec_epis_diag_staging;
    
        --Divide data into tabs
        l_rec_eds_tab_info    pk_edis_types.rec_epis_diag_staging;
        l_first_eph_with_stag epis_diag_stag_hist.id_epis_diagnosis_hist%TYPE; --fisrt epis_diagnosis_hist with staging data
        l_is_to_add_tabs      BOOLEAN := FALSE;
    
        -- diagnosis info
        l_current_tumor_idx   PLS_INTEGER;
        l_next_tumor_idx      PLS_INTEGER;
        l_prv_tumor_idx       PLS_INTEGER;
        l_tab_epis_tumors     pk_edis_types.tab_epis_diag_tumors;
        l_diag_factors        pk_edis_types.tab_diag_factors;
        l_rec_epis_diag       pk_edis_types.rec_epis_diagnosis;
        l_tab_epis_diag_compl pk_edis_types.table_out_complications := pk_edis_types.table_out_complications();
        l_tab_epis_diag_hist  table_number;
        l_diag_type           VARCHAR2(1 CHAR);
    
        -- previous record
        l_prev_rec_ed_staging      pk_edis_types.rec_epis_diag_staging;
        l_prev_tab_epis_tumors     pk_edis_types.tab_epis_diag_tumors;
        l_prev_rec_epis_tumor      pk_edis_types.rec_epis_diag_tumors;
        l_prev_rec_epis_diag       pk_edis_types.rec_epis_diagnosis;
        l_prev_diag_factors        pk_edis_types.tab_diag_factors;
        l_prev_tab_epis_diag_compl pk_edis_types.table_out_complications := pk_edis_types.table_out_complications();
    
        --section labels
        l_general_caract_title  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.65';
        l_tumor_title           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.76';
        l_staging_title         CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.77';
        l_aditional_info_title  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.78';
        l_prognostic_fact_title CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.95';
        l_diagnosis_basis_title CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.81';
    
        l_code_sub_analysis         CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.116';
        l_code_anatomical_area      CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.117';
        l_code_anatomical_side      CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.118';
        l_code_init_diag_date       CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.67';
        l_code_init_diag_age        CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.68';
        l_code_diag_basis_spec      CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M004';
        l_code_mult_tumors          CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.82';
        l_code_recurrence           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.83';
        l_code_main_diag            CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.102';
        l_code_diag_status          CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.103';
        l_code_diag_notes           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.104';
        l_code_add_problems         CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.105';
        l_code_lesion_type          CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.310';
        l_code_lesion_location      CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.311';
        l_code_cancel_reason        CONSTANT sys_message.code_message%TYPE := 'COMMON_M072';
        l_code_cancel_notes         CONSTANT sys_message.code_message%TYPE := 'COMMON_M073';
        l_code_original_description CONSTANT sys_message.code_message%TYPE := 'COMMON_T037';
        l_code_classification_inf   CONSTANT sys_message.code_message%TYPE := 'COMMON_T038';
        l_code_classification_name  CONSTANT sys_message.code_message%TYPE := 'COMMON_T039';
        l_code_abbreviation         CONSTANT sys_message.code_message%TYPE := 'COMMON_T040';
        l_code_version              CONSTANT sys_message.code_message%TYPE := 'COMMON_T041';
        l_code_copyright            CONSTANT sys_message.code_message%TYPE := 'COMMON_T042';
    
        --Dynamic screen sub_form fields labels
        l_code_multiple_primary_tumors CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.202';
        l_code_numb_of_prim_tumors     CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.203';
        k_code_complications           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.800';
    
        l_title_mult_tumors  VARCHAR2(4000 CHAR);
        l_desc_mult_tumors   VARCHAR2(4000 CHAR);
        l_title_num_prim_tum VARCHAR2(4000 CHAR);
        l_desc_num_prim_tum  VARCHAR2(4000 CHAR);
    
        -- diagnosis basis and specification
        l_diag_basis_title VARCHAR2(4000 CHAR);
        l_diag_basis_desc  VARCHAR2(4000 CHAR);
        l_diag_spec_title  VARCHAR2(4000 CHAR);
        l_diag_spec_desc   VARCHAR2(4000 CHAR);
    
        l_cfg_classification_inf      sys_config.id_sys_config%TYPE := 'DIAGNOSIS_DETAIL_SHOW_CLASSIFICATION';
        l_cfg_show_classification_inf sys_config.value%TYPE;
    
        l_classification_information pk_api_termin_server_func.g_rec_terminology_info;
    
        -- complications
        PROCEDURE process_complications IS
            tbl_curr     pk_edis_types.table_out_complications := pk_edis_types.table_out_complications();
            tbl_prev     pk_edis_types.table_out_complications := pk_edis_types.table_out_complications();
            l_idx        NUMBER;
            l_flg_found  BOOLEAN;
            l_count      NUMBER;
            l_max        NUMBER;
            l_prev_max   NUMBER := 0;
            l_curr_max   NUMBER := 0;
            l_prev_value VARCHAR2(4000);
            l_curr_value VARCHAR2(4000);
            l_code       VARCHAR2(0100 CHAR);
            l_rank       NUMBER := 0;
            k_mark CONSTANT VARCHAR2(0010 CHAR) := '###';
            t_rank           VARCHAR(0020 CHAR) := '[' || k_mark || ']';
            tt_rank          VARCHAR(0020 CHAR);
            sp               VARCHAR(0020 CHAR) := chr(32);
            l_free_text_desc epis_diag_complications.desc_complication%TYPE;
        
            --l_desc        varchar2(4000);
        
            FUNCTION get_max_records
            (
                i_val1 IN NUMBER,
                i_val2 IN NUMBER
            ) RETURN NUMBER IS
                l_max NUMBER;
            BEGIN
            
                SELECT MAX(xvalue)
                  INTO l_max
                  FROM (SELECT i_val1 xvalue
                          FROM dual
                        UNION ALL
                        SELECT i_val2 xvalue
                          FROM dual);
            
                RETURN l_max;
            END get_max_records;
        
        BEGIN
        
            l_prev_max := 0;
            l_curr_max := l_tab_epis_diag_compl.count;
        
            tbl_curr := l_tab_epis_diag_compl;
            tbl_prev := l_prev_tab_epis_diag_compl;
        
            IF l_prev_tab_epis_diag_compl.exists(1)
            THEN
                l_prev_max := l_prev_tab_epis_diag_compl.count;
            END IF;
        
            l_max := get_max_records(i_val1 => l_curr_max, i_val2 => l_prev_max);
        
            <<lup_thru_max>>
            FOR i IN 1 .. l_max
            LOOP
                l_rank := l_rank + 1;
                -- cur
                IF tbl_curr.exists(i)
                THEN
                
                    l_flg_found := FALSE;
                
                    <<lup_thru_prev>>
                    FOR j IN 1 .. l_prev_max
                    LOOP
                    
                        l_idx       := j;
                        l_flg_found := tbl_prev(j).id_complication = tbl_curr(i).id_complication;
                        IF l_flg_found
                        THEN
                            EXIT lup_thru_prev;
                        END IF;
                    
                    END LOOP lup_thru_prev;
                
                    -- flg_found
                    IF NOT l_flg_found
                    THEN
                        l_rank := l_rank + 1;
                    
                        --tt_rank      := REPLACE(t_rank, k_mark, to_char(l_rank));
                        --l_curr_value := tt_rank || sp || tbl_curr(i).complication_description;
                        --l_code       := pk_ts1_api.get_term_code(i_id_concept_term => tbl_curr(i).id_alert_complication);
                        --l_curr_value := l_curr_value || sp || '(' || l_code || ')';
                        BEGIN
                            SELECT edc.desc_complication
                              INTO l_free_text_desc
                              FROM epis_diag_complications edc
                             WHERE edc.id_epis_diagnosis = i_epis_diag
                               AND edc.id_complication = tbl_curr(i).id_complication
                               AND edc.id_alert_complication = tbl_curr(i).id_alert_complication
                               AND edc.rank = tbl_curr(i).rank;
                        EXCEPTION
                            WHEN OTHERS THEN
                                l_free_text_desc := NULL;
                        END;
                    
                        IF l_free_text_desc IS NULL
                        THEN
                            l_curr_value := pk_ts1_api.get_term_desc_n_code(i_lang            => i_lang,
                                                                            i_id_concept_term => tbl_curr(i).id_alert_complication,
                                                                            i_rank            => tbl_curr(i).rank);
                        ELSE
                            l_curr_value := pk_complication.get_complications_desc_serial(i_lang,
                                                                                          i_prof,
                                                                                          i_id_epis_diagnosis => i_epis_diag);
                        END IF;
                    
                        l_curr_value := rtrim(l_curr_value, '; ');
                    
                        l_prev_value := NULL;
                    
                    END IF; -- flg_found
                
                ELSE
                
                    -- prev
                    IF tbl_prev.exists(i)
                    THEN
                    
                        l_curr_value := NULL;
                    
                        --tt_rank      := REPLACE(t_rank, k_mark, to_char(l_rank));
                        --l_prev_value := tt_rank || sp || tbl_prev(i).complication_description;
                        --l_code       := pk_ts1_api.get_term_code(i_id_concept_term => tbl_prev(i).id_alert_complication);
                        --l_prev_value := l_prev_value || sp || '(' || l_code || ')';
                        l_prev_value := pk_ts1_api.get_term_desc_n_code(i_lang            => i_lang,
                                                                        i_id_concept_term => tbl_prev(i).id_alert_complication,
                                                                        i_rank            => tbl_prev(i).rank);
                        l_prev_value := rtrim(l_prev_value, '; ');
                    END IF; -- prev
                
                END IF; -- cur
            
                pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                                   i_flg_call   => l_flg_call,
                                                   i_label      => pk_translation.get_translation(i_lang,
                                                                                                  k_code_complications),
                                                   i_value      => l_curr_value,
                                                   i_type       => pk_edis_hist.g_type_content,
                                                   i_code       => k_code_complications,
                                                   i_title_code => l_aditional_info_title,
                                                   i_old_value  => l_prev_value);
            
            END LOOP lup_thru_max;
        
        END process_complications;
    
        -- build the diagnosis history IDs
        PROCEDURE get_diagnosis_hist_det IS
        BEGIN
            l_tab_epis_diag_hist := get_epis_diag_hist(i_lang => i_lang, i_prof => i_prof, i_epis_diag => i_epis_diag);
        
            l_tab_epis_diag_staging.extend;
            l_tab_epis_diag_staging(1).id_epis_diagnosis := i_epis_diag;
        
            FOR i IN 1 .. l_tab_epis_diag_hist.count
            LOOP
                l_tab_epis_diag_staging.extend;
                l_tab_epis_diag_staging(i + 1).id_epis_diagnosis := i_epis_diag;
                l_tab_epis_diag_staging(i + 1).id_epis_diagnosis_hist := l_tab_epis_diag_hist(i);
            END LOOP;
        
        END get_diagnosis_hist_det;
    
        -- staging title
        PROCEDURE add_staging_title IS
        BEGIN
        
            IF l_rec_epis_diag_staging.desc_stage_title IS NOT NULL
               AND i_flg_call = g_diag_call_viewer
            THEN
                g_error := 'ADD STAGE TITLE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                pk_edis_hist.add_value(i_label => l_rec_epis_diag_staging.desc_stage_title,
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title,
                                       i_code  => 'STAGE_TITLE_01');
            
                pk_edis_hist.add_value(i_label => NULL,
                                       i_value => l_rec_epis_diag_staging.desc_group_title,
                                       i_type  => pk_edis_hist.g_type_content,
                                       i_code  => 'STAGE_TITLE_02');
            
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M008'),
                                       i_value => l_rec_epis_diag_staging.name_prof_create ||
                                                  pk_utils.append_str_if_not_null(l_rec_epis_diag_staging.desc_spec_create,
                                                                                  ')',
                                                                                  '(') || '; ' ||
                                                  l_rec_epis_diag_staging.dt_epis_diag_stag_chr,
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'STAGE_TITLE_03');
            
            ELSIF i_flg_call = pk_edis_hist.g_call_detail
            THEN
            
                g_error := 'ADD DIAGNOSIS TITLE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                pk_edis_hist.add_value(i_label => l_rec_epis_diag.desc_diagnosis,
                                       i_value => '(' || l_rec_epis_diag.desc_status || ')',
                                       i_type  => pk_edis_hist.g_type_title,
                                       i_code  => 'TITLE_01');
            
                IF l_cfg_show_classification_inf = pk_alert_constant.g_yes
                   AND l_rec_epis_diag.desc_diagnosis_original IS NOT NULL
                THEN
                    -- original description
                    pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang,
                                                                             i_prof,
                                                                             l_code_original_description),
                                           i_value => l_rec_epis_diag.desc_diagnosis_original,
                                           i_type  => pk_edis_hist.g_type_content_italic,
                                           i_code  => l_code_original_description);
                
                    pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
                END IF;
            
            ELSIF i_flg_call = pk_edis_hist.g_call_hist
            THEN
                IF nvl(l_rec_epis_diag_staging.flg_status, l_rec_epis_diag.flg_status) = pk_alert_constant.g_cancelled
                THEN
                    g_error := 'ADD CANCEL TITLE';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    pk_edis_hist.add_value(i_label => l_label_cancel,
                                           i_value => NULL,
                                           i_type  => pk_edis_hist.g_type_title,
                                           i_code  => 'EDITION_TITLE_01');
                ELSIF l_prev_rec_epis_diag.id_epis_diagnosis IS NULL
                THEN
                    g_error := 'ADD CREATION TITLE';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    pk_edis_hist.add_value(i_label => l_label_creation,
                                           i_value => NULL,
                                           i_type  => pk_edis_hist.g_type_title,
                                           i_code  => 'EDITION_TITLE_02');
                ELSE
                    g_error := 'ADD EDITION TITLE';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    pk_edis_hist.add_value(i_label => l_label_edition,
                                           i_value => NULL,
                                           i_type  => pk_edis_hist.g_type_title,
                                           i_code  => 'EDITION_TITLE_03');
                END IF;
            END IF;
        END add_staging_title;
    
        -- tumor info
        PROCEDURE add_tumor_section(i_tumor_idx IN NUMBER) IS
            l_desc_title     VARCHAR2(4000 CHAR);
            l_desc_value     VARCHAR2(4000 CHAR);
            l_desc_old_value VARCHAR2(4000 CHAR);
        
            l_code_title_tumor pk_translation.t_code;
            l_code_title_icdo  pk_translation.t_code;
        
            -- label codes
            l_code_topography  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.84';
            l_code_laterality  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.85';
            l_code_morphology  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.86';
            l_code_behaviour   CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.87';
            l_code_hist_grade  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.88';
            l_code_other_grade CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.89';
            l_code_dimension   CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.90';
            l_code_adit_path   CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.91';
            l_code_unknown     CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.204';
            l_code_numeric     CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.205';
            l_code_descriptive CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.206';
        
            l_code_msg_creation CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M46';
        
            l_title_unknown     VARCHAR2(4000 CHAR);
            l_desc_unknown      VARCHAR2(4000 CHAR);
            l_title_numeric     VARCHAR2(4000 CHAR);
            l_desc_numeric      VARCHAR2(4000 CHAR);
            l_desc_numeric_um   VARCHAR2(4000 CHAR);
            l_title_descriptive VARCHAR2(4000 CHAR);
            l_desc_descriptive  VARCHAR2(4000 CHAR);
        
            l_prev_tumor_idx   PLS_INTEGER;
            l_prev_tumor_found BOOLEAN := FALSE;
            l_tumor_flg_call   VARCHAR2(1 CHAR);
        
            PROCEDURE reset_tumor_num_rec IS
                l_rec_reset pk_edis_types.rec_epis_diag_tumors;
            BEGIN
                l_prev_rec_epis_tumor := l_rec_reset;
            END reset_tumor_num_rec;
        BEGIN
        
            g_error := 'ADD TUMOR INFO ' || i_tumor_idx;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            IF l_tab_epis_tumors(i_tumor_idx).code_icdo IS NOT NULL
            THEN
                l_code_title_icdo := 'CODE_ICDO';
            END IF;
        
            IF l_prev_tab_epis_tumors.exists(1)
            THEN
                reset_tumor_num_rec;
                l_prev_tumor_found := FALSE;
            
                l_prev_tumor_idx := l_prev_tab_epis_tumors.first;
                WHILE l_prev_tumor_idx IS NOT NULL
                LOOP
                    IF l_prev_tab_epis_tumors(l_prev_tumor_idx).tumor_num = l_tab_epis_tumors(i_tumor_idx).tumor_num
                    THEN
                        l_prev_rec_epis_tumor := l_prev_tab_epis_tumors(l_prev_tumor_idx);
                        l_prev_tumor_found    := TRUE;
                        EXIT;
                    END IF;
                
                    l_prev_tumor_idx := l_prev_tab_epis_tumors.next(l_prev_tumor_idx);
                END LOOP;
            ELSE
                reset_tumor_num_rec;
            END IF;
        
            l_code_title_tumor := l_tumor_title || '_' || i_tumor_idx;
            l_tumor_flg_call   := l_flg_call;
            l_desc_title       := '';
        
            IF NOT l_prev_tumor_found
               AND l_flg_call = pk_edis_hist.g_call_hist
            THEN
                l_tumor_flg_call := pk_edis_hist.g_call_detail;
                l_desc_title     := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_msg_creation) || ' ';
            END IF;
        
            IF l_tab_epis_tumors(i_tumor_idx).tumor_num = 1
            THEN
                l_desc_title := l_desc_title || CASE
                                    WHEN l_desc_title IS NULL THEN
                                     l_label_main_tumor
                                    ELSE
                                     lower(l_label_main_tumor)
                                END;
            ELSE
                l_desc_title := l_desc_title || CASE
                                    WHEN l_desc_title IS NULL THEN
                                     pk_translation.get_translation(i_lang, l_tumor_title)
                                    ELSE
                                     lower(pk_translation.get_translation(i_lang, l_tumor_title))
                                END;
            END IF;
        
            --topography
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_topography),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).desc_topography,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_topography,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_topography);
        
            --laterality
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_laterality),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).desc_laterality,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_laterality,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_laterality);
        
            --morphology
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_morphology),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).desc_morphology,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_morphology,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_morphology);
        
            --behaviour
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_behaviour),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).desc_behaviour,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_behaviour,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_behaviour);
        
            --histological grade
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_hist_grade),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).desc_histological_grade,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_hist_grade,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_histological_grade);
        
            --other grading system
            l_desc_value := pk_utils.append_str_if_not_null(l_tab_epis_tumors(i_tumor_idx).desc_grading_system,
                                                            ': ' || l_tab_epis_tumors(i_tumor_idx).desc_other_grading_sys);
        
            l_desc_value := nvl(l_desc_value, l_tab_epis_tumors(i_tumor_idx).desc_other_grading_sys);
        
            l_desc_old_value := pk_utils.append_str_if_not_null(l_prev_rec_epis_tumor.desc_grading_system,
                                                                ': ' || l_prev_rec_epis_tumor.desc_other_grading_sys);
        
            l_desc_old_value := nvl(l_desc_old_value, l_prev_rec_epis_tumor.desc_other_grading_sys);
        
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_other_grade),
                                               i_value       => l_desc_value,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_other_grade,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_desc_old_value);
        
            --dimension
            l_desc_numeric_um := pk_utils.append_str_if_not_null(i_prefix_str => ' (',
                                                                 i_src_string => pk_unit_measure.get_uom_abbreviation(i_lang         => i_lang,
                                                                                                                      i_prof         => i_prof,
                                                                                                                      i_unit_measure => to_number(pk_sysconfig.get_config(i_code_cf => pk_diagnosis_form.g_cfg_prim_tum_unit_meas,
                                                                                                                                                                          i_prof    => i_prof))),
                                                                 i_suffix_str => ')');
        
            IF l_tumor_flg_call = pk_edis_hist.g_call_hist
            THEN
                l_title_unknown     := l_space_format || pk_translation.get_translation(i_lang, l_code_unknown);
                l_desc_unknown      := l_tab_epis_tumors(i_tumor_idx).desc_unknown_dimension;
                l_title_numeric     := l_space_format || pk_translation.get_translation(i_lang, l_code_numeric);
                l_desc_numeric      := pk_utils.append_str_if_not_null(l_tab_epis_tumors(i_tumor_idx).num_dimension,
                                                                       l_desc_numeric_um);
                l_title_descriptive := l_space_format || pk_translation.get_translation(i_lang, l_code_descriptive);
                l_desc_descriptive  := l_tab_epis_tumors(i_tumor_idx).desc_dimension;
            ELSE
                l_title_unknown     := '';
                l_desc_unknown      := pk_utils.append_str_if_not_null(l_tab_epis_tumors(i_tumor_idx).desc_unknown_dimension,
                                                                       '',
                                                                       l_space_format ||
                                                                       pk_translation.get_translation(i_lang,
                                                                                                      l_code_unknown) || ': ');
                l_title_numeric     := '';
                l_desc_numeric      := pk_utils.append_str_if_not_null(pk_utils.append_str_if_not_null(l_tab_epis_tumors(i_tumor_idx).num_dimension,
                                                                                                       l_desc_numeric_um),
                                                                       '',
                                                                       l_space_format ||
                                                                       pk_translation.get_translation(i_lang,
                                                                                                      l_code_numeric) || ': ');
                l_title_descriptive := '';
                l_desc_descriptive  := pk_utils.append_str_if_not_null(l_tab_epis_tumors(i_tumor_idx).desc_dimension,
                                                                       '',
                                                                       l_space_format ||
                                                                       pk_translation.get_translation(i_lang,
                                                                                                      l_code_descriptive) || ': ');
            END IF;
        
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => l_title_unknown,
                                               i_value       => l_desc_unknown,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_dimension,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_dimension),
                                               i_title_desc  => table_varchar('', ''),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_content),
                                               i_old_value   => l_prev_rec_epis_tumor.desc_unknown_dimension);
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_tumor_flg_call,
                                               i_label      => l_title_numeric,
                                               i_value      => l_desc_numeric,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_numeric,
                                               i_title_code => l_code_dimension,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => pk_utils.append_str_if_not_null(l_prev_rec_epis_tumor.num_dimension,
                                                                                               l_desc_numeric_um));
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_tumor_flg_call,
                                               i_label      => l_title_descriptive,
                                               i_value      => l_desc_descriptive,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_descriptive,
                                               i_title_code => l_code_dimension,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => l_prev_rec_epis_tumor.desc_dimension);
        
            --aditional pathology information
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_tumor_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_adit_path),
                                               i_value       => l_tab_epis_tumors(i_tumor_idx).additional_pathol_info,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_adit_path,
                                               i_title_code  => table_varchar(l_code_title_tumor, l_code_title_icdo),
                                               i_title_desc  => table_varchar(l_desc_title,
                                                                              l_tab_epis_tumors(i_tumor_idx).code_icdo),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_epis_tumor.additional_pathol_info);
        
        END add_tumor_section;
    
        PROCEDURE add_cancelled_tumor_section(i_tumor_idx IN NUMBER) IS
            l_code_msg_state        CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M43';
            l_code_msg_cancellation CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M44';
            l_code_msg_cancel       CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M45';
            --
            l_desc_title VARCHAR2(4000 CHAR);
        BEGIN
            l_desc_title := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_msg_cancellation) || ' ';
        
            IF l_prev_tab_epis_tumors(i_tumor_idx).tumor_num = 1
            THEN
                l_desc_title := l_desc_title || lower(l_label_main_tumor);
            ELSE
                l_desc_title := l_desc_title || lower(pk_translation.get_translation(i_lang, l_tumor_title));
            END IF;
        
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_message.get_message(i_lang      => i_lang,
                                                                                       i_code_mess => l_code_msg_state),
                                               i_value       => pk_message.get_message(i_lang      => i_lang,
                                                                                       i_code_mess => l_code_msg_cancel),
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_msg_state,
                                               i_title_code  => l_code_msg_cancellation,
                                               i_title_desc  => l_desc_title,
                                               i_title_value => '',
                                               i_title_type  => pk_edis_hist.g_type_subtitle,
                                               i_old_value   => NULL);
        END add_cancelled_tumor_section;
    
        -- staging info
        PROCEDURE add_staging_info IS
            l_title_progn_factors sys_message.desc_message%TYPE;
            l_title_stage_factors sys_message.desc_message%TYPE;
            l_title_clin_factors  sys_message.desc_message%TYPE;
            l_code_progn_factors  sys_message.code_message%TYPE;
            l_code_stage_factors CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M011';
            l_code_clin_factors  CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M012';
        
            l_prog_fact_idx    NUMBER := 1;
            l_curr_prog_factor pk_edis_types.rec_diag_factors;
            l_prev_prog_factor pk_edis_types.rec_diag_factors;
        
            --Prognostic factors required for staging that must be shown as Considered criteria
            l_curr_considered_crit VARCHAR2(4000 CHAR);
            l_prev_considered_crit VARCHAR2(4000 CHAR);
        
            l_val_yes CONSTANT NUMBER := 1;
            l_val_no  CONSTANT NUMBER := 0;
        
            l_code_title_staging pk_translation.t_code;
        
            l_prog_fact_label     VARCHAR2(4000 CHAR);
            l_prog_fact_value     VARCHAR2(4000 CHAR);
            l_prog_fact_old_value VARCHAR2(4000 CHAR);
        
            l_title_t VARCHAR2(4000 CHAR);
            l_desc_t  VARCHAR2(4000 CHAR);
            l_title_n VARCHAR2(4000 CHAR);
            l_desc_n  VARCHAR2(4000 CHAR);
            l_title_m VARCHAR2(4000 CHAR);
            l_desc_m  VARCHAR2(4000 CHAR);
        
            -- label codes
            l_code_stage_basis CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.92';
            l_code_tnm         CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.93';
            l_code_metastic_st CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.94';
            l_code_group       CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.96';
            l_code_staging     CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.97';
            l_code_resid_tumor CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.98';
            l_code_surg_margin CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.99';
            l_code_vasc_invas  CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.100';
            l_code_other_stage CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.101';
            l_code_t           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.208';
            l_code_n           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.209';
            l_code_m           CONSTANT pk_translation.t_code := 'DS_COMPONENT.CODE_DS_COMPONENT.210';
            --
            FUNCTION get_prev_prog_factor(i_curr_prog_factor IN pk_edis_types.rec_diag_factors)
                RETURN pk_edis_types.rec_diag_factors IS
                l_ret pk_edis_types.rec_diag_factors;
                l_aux pk_edis_types.rec_diag_factors;
            BEGIN
                IF l_prev_diag_factors.exists(1)
                THEN
                    FOR i IN l_prev_diag_factors.first .. l_prev_diag_factors.last
                    LOOP
                        l_aux := l_prev_diag_factors(i);
                    
                        IF l_aux.id_staging_basis = i_curr_prog_factor.id_staging_basis
                           AND l_aux.num_staging_basis = i_curr_prog_factor.num_staging_basis
                           AND l_aux.id_field = i_curr_prog_factor.id_field
                        THEN
                            l_ret := l_aux;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                RETURN l_ret;
            END get_prev_prog_factor;
        BEGIN
            g_error := 'ADD STAGING INFO';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            IF l_rec_epis_diag_staging.desc_staging IS NOT NULL
            THEN
                l_code_title_staging := 'CODE_STAGING';
            END IF;
        
            l_title_stage_factors := pk_message.get_message(i_lang, i_prof, l_code_stage_factors) || ':';
            l_title_clin_factors  := pk_message.get_message(i_lang, i_prof, l_code_clin_factors) || ':';
        
            --staging basis
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_stage_basis),
                                               i_value       => l_rec_epis_diag_staging.desc_staging_basis,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_stage_basis,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_staging_basis);
        
            --TNM
            IF l_flg_call = pk_edis_hist.g_call_hist
            THEN
                l_title_t := l_space_format || pk_translation.get_translation(i_lang, l_code_t);
                l_desc_t  := l_rec_epis_diag_staging.desc_tnm_t;
                l_title_n := l_space_format || pk_translation.get_translation(i_lang, l_code_n);
                l_desc_n  := l_rec_epis_diag_staging.desc_tnm_n;
                l_title_m := l_space_format || pk_translation.get_translation(i_lang, l_code_m);
                l_desc_m  := l_rec_epis_diag_staging.desc_tnm_m;
            ELSE
                l_title_t := '';
                l_desc_t  := pk_utils.append_str_if_not_null(l_rec_epis_diag_staging.desc_tnm_t,
                                                             '',
                                                             l_space_format ||
                                                             pk_translation.get_translation(i_lang, l_code_t) || ': ');
                l_title_n := '';
                l_desc_n  := pk_utils.append_str_if_not_null(l_rec_epis_diag_staging.desc_tnm_n,
                                                             '',
                                                             l_space_format ||
                                                             pk_translation.get_translation(i_lang, l_code_n) || ': ');
                l_title_m := '';
                l_desc_m  := pk_utils.append_str_if_not_null(l_rec_epis_diag_staging.desc_tnm_m,
                                                             '',
                                                             l_space_format ||
                                                             pk_translation.get_translation(i_lang, l_code_m) || ': ');
            END IF;
        
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => l_title_t,
                                               i_value       => l_desc_t,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_t,
                                               i_title_code  => table_varchar(l_staging_title, l_code_tnm),
                                               i_title_desc  => table_varchar('', ''),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_content),
                                               i_old_value   => l_prev_rec_ed_staging.desc_tnm_t);
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => l_title_n,
                                               i_value      => l_desc_n,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_n,
                                               i_title_code => l_code_tnm,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => l_prev_rec_ed_staging.desc_tnm_n);
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => l_title_m,
                                               i_value      => l_desc_m,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_m,
                                               i_title_code => l_code_tnm,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => l_prev_rec_ed_staging.desc_tnm_m);
        
            --metastatic sites
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_metastic_st),
                                               i_value       => l_rec_epis_diag_staging.desc_metastatic_sites,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_metastic_st,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_metastatic_sites);
        
            -- prognostic factors
            IF l_diag_factors IS NOT NULL
               AND l_diag_factors.count > 0
            THEN
                l_curr_considered_crit := NULL;
                l_prev_considered_crit := NULL;
            
                LOOP
                    EXIT WHEN NOT l_diag_factors.exists(l_prog_fact_idx);
                
                    l_curr_prog_factor := l_diag_factors(l_prog_fact_idx);
                    l_prev_prog_factor := get_prev_prog_factor(i_curr_prog_factor => l_curr_prog_factor);
                
                    -- add section titles
                    IF l_curr_prog_factor.is_stage_factor = l_val_yes
                    THEN
                        l_title_progn_factors := l_title_stage_factors;
                        l_code_progn_factors  := l_code_stage_factors;
                    
                    ELSIF l_curr_prog_factor.is_stage_factor = l_val_no
                    THEN
                        l_title_progn_factors := l_title_clin_factors;
                        l_code_progn_factors  := l_code_clin_factors;
                    END IF;
                
                    -- set the value format
                    IF l_flg_call = pk_edis_hist.g_call_hist
                    THEN
                        l_prog_fact_label     := l_space_format ||
                                                 nvl(l_curr_prog_factor.desc_field, l_prev_prog_factor.desc_field);
                        l_prog_fact_value     := nvl(l_curr_prog_factor.desc_value_field, l_curr_prog_factor.desc_value);
                        l_prog_fact_old_value := nvl(l_prev_prog_factor.desc_value_field, l_prev_prog_factor.desc_value);
                    ELSE
                        l_prog_fact_label     := '';
                        l_prog_fact_value     := l_space_format || l_curr_prog_factor.desc_field || ': ' ||
                                                 nvl(l_curr_prog_factor.desc_value_field, l_curr_prog_factor.desc_value);
                        l_prog_fact_old_value := '';
                    END IF;
                
                    IF l_prog_fact_value IS NOT NULL
                    THEN
                        l_curr_considered_crit := l_curr_considered_crit || '; ' || l_curr_prog_factor.desc_field;
                    END IF;
                
                    IF l_prog_fact_old_value IS NOT NULL
                    THEN
                        l_prev_considered_crit := l_prev_considered_crit || '; ' || l_prev_prog_factor.desc_field;
                    END IF;
                
                    pk_edis_hist.add_value(i_lang        => i_lang,
                                           i_flg_call    => l_flg_call,
                                           i_label       => l_prog_fact_label,
                                           i_value       => l_prog_fact_value,
                                           i_type        => pk_edis_hist.g_type_content,
                                           i_code        => l_code_progn_factors,
                                           i_title_code  => table_varchar(l_staging_title,
                                                                          l_code_title_staging,
                                                                          l_prognostic_fact_title,
                                                                          l_code_progn_factors),
                                           i_title_desc  => table_varchar('',
                                                                          l_rec_epis_diag_staging.desc_staging,
                                                                          '',
                                                                          ''),
                                           i_title_value => table_varchar('', '', '', l_title_progn_factors),
                                           i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                          pk_edis_hist.g_type_subtitle,
                                                                          pk_edis_hist.g_type_content,
                                                                          pk_edis_hist.g_type_content),
                                           i_old_value   => l_prog_fact_old_value);
                
                    l_prog_fact_idx := l_prog_fact_idx + 1;
                END LOOP;
            END IF;
        
            --group
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_group),
                                               i_value       => l_rec_epis_diag_staging.desc_group ||
                                                                l_curr_considered_crit,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_group,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_group ||
                                                                l_prev_considered_crit);
        
            --staging                                   
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_staging),
                                               i_value       => l_rec_epis_diag_staging.desc_staging,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_staging,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_staging);
        
            --residual tumor                                   
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_resid_tumor),
                                               i_value       => l_rec_epis_diag_staging.desc_residual_tumor,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_resid_tumor,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_residual_tumor);
        
            --surgical margins                             
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_surg_margin),
                                               i_value       => l_rec_epis_diag_staging.desc_surgical_margins,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_surg_margin,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_surgical_margins);
        
            --vascular invasion                             
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang, l_code_vasc_invas),
                                               i_value       => l_rec_epis_diag_staging.desc_lymph_vasc_inv,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_vasc_invas,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_lymph_vasc_inv);
        
            --other staging system                         
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => pk_translation.get_translation(i_lang,
                                                                                               l_code_other_stage),
                                               i_value       => l_rec_epis_diag_staging.desc_other_staging_sys,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_other_stage,
                                               i_title_code  => table_varchar(l_staging_title, l_code_title_staging),
                                               i_title_desc  => table_varchar('', l_rec_epis_diag_staging.desc_staging),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_subtitle),
                                               i_old_value   => l_prev_rec_ed_staging.desc_other_staging_sys);
        
        END add_staging_info;
    
        -- clear all previous record variables
        PROCEDURE clear_previous_record IS
            l_reset_rec_ed_staging      pk_edis_types.rec_epis_diag_staging;
            l_reset_tab_epis_tumors     pk_edis_types.tab_epis_diag_tumors;
            l_reset_rec_epis_tumor      pk_edis_types.rec_epis_diag_tumors;
            l_reset_rec_epis_diag       pk_edis_types.rec_epis_diagnosis;
            l_reset_diag_factors        pk_edis_types.tab_diag_factors;
            l_reset_tab_epis_diag_compl pk_edis_types.table_out_complications;
        BEGIN
            l_prev_rec_ed_staging      := l_reset_rec_ed_staging;
            l_prev_tab_epis_tumors     := l_reset_tab_epis_tumors;
            l_prev_rec_epis_tumor      := l_reset_rec_epis_tumor;
            l_prev_rec_epis_diag       := l_reset_rec_epis_diag;
            l_prev_diag_factors        := l_reset_diag_factors;
            l_prev_tab_epis_diag_compl := l_reset_tab_epis_diag_compl;
        END clear_previous_record;
    
    BEGIN
    
        g_error := 'INIT';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        -- Initialize history table
        pk_edis_hist.init_vars;
    
        l_label_edition    := pk_message.get_message(i_lang, i_prof, 'COMMON_T029');
        l_label_creation   := pk_message.get_message(i_lang, i_prof, 'COMMON_T030');
        l_label_cancel     := pk_message.get_message(i_lang, i_prof, 'COMMON_T032');
        l_label_main_tumor := pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M010');
        l_label_diag_spec  := pk_message.get_message(i_lang, i_prof, l_code_diag_basis_spec);
        l_label_na         := pk_message.get_message(i_lang, i_prof, 'COMMON_M036');
    
        g_error := 'GET CONFIG DIAGNOSIS_DETAIL_SHOW_CLASSIFICATION';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_cfg_show_classification_inf := pk_sysconfig.get_config(l_cfg_classification_inf, i_prof);
    
        g_error := 'CALL PK_DIAGNOSIS_CORE.GET_DIAG_TYPE';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT pk_diagnosis_core.get_diag_type(i_lang         => i_lang,
                                               i_prof         => i_prof,
                                               i_concept_type => NULL,
                                               i_diagnosis    => ed.id_diagnosis)
          INTO l_diag_type
          FROM epis_diagnosis ed
         WHERE ed.id_epis_diagnosis = i_epis_diag;
    
        g_error := 'GET ACTIVE STAGINGS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        -- Get the associated staging(s)
        l_tab_epis_diag_staging := get_epis_diag_stagings(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_episode        => i_episode,
                                                          i_flg_call       => g_diag_active_detail,
                                                          i_epis_diag      => i_epis_diag,
                                                          i_epis_diag_hist => NULL);
    
        -- regular diagnoses dont have stagings
        IF l_tab_epis_diag_staging.count = 0
        THEN
            IF i_flg_call = pk_edis_hist.g_call_hist
            THEN
                -- fetch the diagnosis history
                get_diagnosis_hist_det;
            ELSE
                l_tab_epis_diag_staging.extend;
            END IF;
        END IF;
    
        g_error := 'LOOP RECORDS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        -- Loop through all history records
        l_count := l_tab_epis_diag_staging.count;
        FOR i IN 1 .. l_tab_epis_diag_staging.count
        LOOP
            l_rec_epis_diag_staging := l_tab_epis_diag_staging(i);
            pk_edis_hist.reset_vars;
        
            -- fetch the previous record if it exists
            IF l_tab_epis_diag_staging.exists(i + 1)
            THEN
                g_error := 'GET PREVIOUS DIAGNOSIS INFO';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT get_epis_diag_rec(i_lang                => i_lang,
                                         i_prof                => i_prof,
                                         i_episode             => i_episode,
                                         i_epis_diag           => i_epis_diag,
                                         i_epis_diag_hist      => l_tab_epis_diag_staging(i + 1).id_epis_diagnosis_hist,
                                         i_rec_epis_stag       => l_tab_epis_diag_staging(i + 1),
                                         o_rec_epis_stag       => l_prev_rec_ed_staging,
                                         o_tab_epis_tumors     => l_prev_tab_epis_tumors,
                                         o_rec_epis_diag       => l_prev_rec_epis_diag,
                                         o_tab_epis_diag_compl => l_prev_tab_epis_diag_compl,
                                         o_error               => o_error)
                THEN
                    RAISE g_exception;
                END IF;
            
                l_prev_diag_factors := l_prev_rec_ed_staging.prog_factors;
            ELSE
                clear_previous_record;
            END IF;
        
            -- clear previous record if it refers to another staging basis
            IF nvl(l_prev_rec_ed_staging.id_staging_basis, -1) <> nvl(l_rec_epis_diag_staging.id_staging_basis, -1)
               OR
               nvl(l_prev_rec_ed_staging.num_staging_basis, -1) <> nvl(l_rec_epis_diag_staging.num_staging_basis, -1)
            THEN
                clear_previous_record;
            END IF;
        
            IF i_flg_call = pk_edis_hist.g_call_hist
               AND l_prev_rec_epis_diag.id_epis_diagnosis IS NOT NULL
            THEN
                l_flg_call := pk_edis_hist.g_call_hist;
            ELSE
                l_flg_call := pk_edis_hist.g_call_detail;
            END IF;
        
            -- When returning the viewer info there must be at least one active staging
            IF i_flg_call = g_diag_call_viewer
               AND l_rec_epis_diag_staging.num_staging_basis IS NULL
            THEN
                EXIT;
            END IF;
        
            g_error := 'GET DIAGNOSIS INFO';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT get_epis_diag_rec(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_episode             => i_episode,
                                     i_epis_diag           => i_epis_diag,
                                     i_epis_diag_hist      => l_rec_epis_diag_staging.id_epis_diagnosis_hist,
                                     i_rec_epis_stag       => l_rec_epis_diag_staging,
                                     o_rec_epis_stag       => l_rec_epis_diag_staging,
                                     o_tab_epis_tumors     => l_tab_epis_tumors,
                                     o_rec_epis_diag       => l_rec_epis_diag,
                                     o_tab_epis_diag_compl => l_tab_epis_diag_compl,
                                     o_error               => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            l_diag_factors := l_rec_epis_diag_staging.prog_factors;
        
            g_error := 'ADD NEW HIST LINE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            -- Create a new line in history table with current history record 
            pk_edis_hist.add_line(i_history         => nvl(l_rec_epis_diag.id_epis_diagnosis_hist, -1),
                                  i_dt_hist         => l_rec_epis_diag.dt_epis_diagnosis,
                                  i_record_state    => nvl(l_rec_epis_diag_staging.flg_status,
                                                           l_rec_epis_diag.flg_status),
                                  i_desc_rec_state  => nvl(l_rec_epis_diag_staging.desc_status,
                                                           l_rec_epis_diag.desc_status),
                                  i_desc_cat_viewer => l_rec_epis_diag_staging.desc_stage_title,
                                  i_professional    => l_rec_epis_diag_staging.id_prof_create,
                                  i_episode         => i_episode);
        
            --If previous record is in cancel state reset previous data
            IF nvl(l_prev_rec_ed_staging.flg_status, l_prev_rec_epis_diag.flg_status) = pk_alert_constant.g_cancelled
            THEN
                clear_previous_record;
            
                l_flg_call := pk_edis_hist.g_call_detail;
            END IF;
        
            g_error := 'VERIFY IF IT''S TO ADD STAGING INFO_VALUES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --This is used by flash to divide data in tabs
            IF l_rec_epis_diag_staging.id_staging_basis IS NOT NULL
            THEN
                l_rec_eds_tab_info := l_rec_epis_diag_staging;
                l_is_to_add_tabs   := TRUE;
            ELSIF l_diag_type = pk_diagnosis_core.g_diag_type_cancer
            THEN
                BEGIN
                    SELECT b.id_epis_diagnosis_hist
                      INTO l_first_eph_with_stag
                      FROM (SELECT a.id_epis_diagnosis_hist,
                                   a.dt_epis_diagnosis_stag,
                                   row_number() over(ORDER BY a.dt_epis_diagnosis_stag ASC) line_number
                              FROM (SELECT -1 id_epis_diagnosis_hist, eds.dt_epis_diagnosis_stag
                                      FROM epis_diag_stag eds
                                     WHERE eds.id_epis_diagnosis = i_epis_diag
                                    UNION ALL
                                    SELECT edsh.id_epis_diagnosis_hist, edsh.dt_epis_diagnosis_stag
                                      FROM epis_diag_stag_hist edsh
                                     WHERE edsh.id_epis_diagnosis = i_epis_diag) a
                             WHERE dt_epis_diagnosis_stag > l_rec_epis_diag.dt_epis_diagnosis) b
                     WHERE line_number = 1;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_first_eph_with_stag := NULL;
                END;
            
                IF l_first_eph_with_stag IS NOT NULL
                THEN
                    IF nvl(l_rec_eds_tab_info.id_epis_diagnosis, -1) != i_epis_diag
                       AND nvl(l_rec_eds_tab_info.id_epis_diagnosis_hist, -1) != l_first_eph_with_stag
                    THEN
                        DECLARE
                            l_dummy_epis_tumors     pk_edis_types.tab_epis_diag_tumors;
                            l_dummy_epis_diag       pk_edis_types.rec_epis_diagnosis;
                            l_dummy_epis_diag_compl pk_edis_types.table_out_complications;
                        BEGIN
                            g_error := 'GET NEXT STAGING RECORD';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            IF NOT get_epis_diag_rec(i_lang                => i_lang,
                                                     i_prof                => i_prof,
                                                     i_episode             => i_episode,
                                                     i_epis_diag           => i_epis_diag,
                                                     i_epis_diag_hist      => CASE l_first_eph_with_stag
                                                                                  WHEN -1 THEN
                                                                                   NULL
                                                                                  ELSE
                                                                                   l_first_eph_with_stag
                                                                              END,
                                                     i_rec_epis_stag       => NULL,
                                                     o_rec_epis_stag       => l_rec_eds_tab_info,
                                                     o_tab_epis_tumors     => l_dummy_epis_tumors,
                                                     o_rec_epis_diag       => l_dummy_epis_diag,
                                                     o_tab_epis_diag_compl => l_dummy_epis_diag_compl,
                                                     o_error               => o_error)
                            THEN
                                RAISE g_exception;
                            END IF;
                        END;
                    END IF;
                
                    l_is_to_add_tabs := TRUE;
                ELSE
                    l_is_to_add_tabs := FALSE;
                END IF;
            
            ELSE
                l_is_to_add_tabs := FALSE;
            END IF;
        
            IF l_is_to_add_tabs
               AND l_rec_eds_tab_info.id_staging_basis IS NOT NULL --double check
            THEN
                g_error := 'ADD STAGING INFO_VALUES';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                pk_edis_hist.add_info_value(i_label => 'STAGING_UK',
                                            i_value => l_rec_eds_tab_info.id_staging_basis || '_' ||
                                                       l_rec_eds_tab_info.num_staging_basis);
                pk_edis_hist.add_info_value(i_label => 'STAGING_TITLE',
                                            i_value => l_rec_eds_tab_info.desc_stage_title ||
                                                       CASE l_rec_eds_tab_info.flg_status
                                                           WHEN pk_alert_constant.g_cancelled THEN
                                                            ' (' || l_rec_eds_tab_info.desc_status || ')'
                                                           ELSE
                                                            NULL
                                                       END);
            END IF;
        
            -- add staging title
            add_staging_title;
        
            g_error := 'ADD FIRST SECTION INFO';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --sub-analysis
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_sub_analysis),
                                               i_value      => l_rec_epis_diag.desc_sub_analysis,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_sub_analysis,
                                               i_title_code => l_general_caract_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_sub_analysis);
        
            --anatomical area
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_anatomical_area),
                                               i_value      => l_rec_epis_diag.desc_anatomical_area,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_anatomical_area,
                                               i_title_code => l_general_caract_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_anatomical_area);
        
            --anatomical side
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_anatomical_side),
                                               i_value      => l_rec_epis_diag.desc_anatomical_side,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_anatomical_side,
                                               i_title_code => l_general_caract_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_anatomical_side);
        
            --initial diagnosis date
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_init_diag_date),
                                               i_value      => l_rec_epis_diag.dt_initial_diag_chr,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_init_diag_date,
                                               i_title_code => l_general_caract_title,
                                               i_old_value  => l_prev_rec_epis_diag.dt_initial_diag_chr);
        
            --age when diagnosis was detected
            pk_edis_hist.add_value_if_not_null(i_lang      => i_lang,
                                               i_flg_call  => l_flg_call,
                                               i_label     => pk_translation.get_translation(i_lang,
                                                                                             l_code_init_diag_age),
                                               i_value     => l_rec_epis_diag.age_diag,
                                               i_type      => pk_edis_hist.g_type_content,
                                               i_code      => l_code_init_diag_age,
                                               i_old_value => l_prev_rec_epis_diag.age_diag);
        
            -- set the diagnosis basis value format
            IF l_flg_call = pk_edis_hist.g_call_hist
            THEN
                l_diag_basis_title := l_space_format || pk_translation.get_translation(i_lang, l_diagnosis_basis_title);
                l_diag_basis_desc  := l_rec_epis_diag.desc_diag_basis;
                l_diag_spec_title  := l_space_format || l_label_diag_spec;
                l_diag_spec_desc   := l_rec_epis_diag.diag_basis_spec;
            ELSE
                l_diag_basis_title := '';
                l_diag_basis_desc  := pk_utils.append_str_if_not_null(l_rec_epis_diag.desc_diag_basis,
                                                                      '',
                                                                      l_space_format ||
                                                                      pk_translation.get_translation(i_lang,
                                                                                                     l_diagnosis_basis_title) || ': ');
                l_diag_spec_title  := '';
                l_diag_spec_desc   := pk_utils.append_str_if_not_null(l_rec_epis_diag.diag_basis_spec,
                                                                      '',
                                                                      l_space_format || l_label_diag_spec || ': ');
            END IF;
        
            --diagnosis basis
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => l_diag_basis_title,
                                               i_value       => l_diag_basis_desc,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_diagnosis_basis_title,
                                               i_title_code  => table_varchar(l_general_caract_title,
                                                                              l_diagnosis_basis_title),
                                               i_title_desc  => table_varchar('', ''),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_content),
                                               i_old_value   => l_prev_rec_epis_diag.desc_diag_basis);
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => l_diag_spec_title,
                                               i_value      => l_diag_spec_desc,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_diag_basis_spec,
                                               i_title_code => l_diagnosis_basis_title,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => l_prev_rec_epis_diag.diag_basis_spec);
        
            --multiple tumors
            IF l_flg_call = pk_edis_hist.g_call_hist
            THEN
                l_title_mult_tumors  := l_space_format ||
                                        pk_translation.get_translation(i_lang, l_code_multiple_primary_tumors);
                l_desc_mult_tumors   := l_rec_epis_diag.desc_mult_tumors;
                l_title_num_prim_tum := l_space_format ||
                                        pk_translation.get_translation(i_lang, l_code_numb_of_prim_tumors);
                l_desc_num_prim_tum  := l_rec_epis_diag.num_primary_tumors;
            ELSE
                l_title_mult_tumors  := '';
                l_desc_mult_tumors   := pk_utils.append_str_if_not_null(l_rec_epis_diag.desc_mult_tumors,
                                                                        '',
                                                                        l_space_format ||
                                                                        pk_translation.get_translation(i_lang,
                                                                                                       l_code_multiple_primary_tumors) || ': ');
                l_title_num_prim_tum := '';
                l_desc_num_prim_tum  := pk_utils.append_str_if_not_null(l_rec_epis_diag.num_primary_tumors,
                                                                        '',
                                                                        l_space_format ||
                                                                        pk_translation.get_translation(i_lang,
                                                                                                       l_code_numb_of_prim_tumors) || ': ');
            END IF;
        
            pk_edis_hist.add_value_if_not_null(i_lang        => i_lang,
                                               i_flg_call    => l_flg_call,
                                               i_label       => l_title_mult_tumors,
                                               i_value       => l_desc_mult_tumors,
                                               i_type        => pk_edis_hist.g_type_content,
                                               i_code        => l_code_mult_tumors,
                                               i_title_code  => table_varchar(l_general_caract_title, l_code_mult_tumors),
                                               i_title_desc  => table_varchar('', ''),
                                               i_title_value => table_varchar('', ''),
                                               i_title_type  => table_varchar(pk_edis_hist.g_type_subtitle,
                                                                              pk_edis_hist.g_type_content),
                                               i_old_value   => l_prev_rec_epis_diag.desc_mult_tumors);
        
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => l_title_num_prim_tum,
                                               i_value      => to_clob(l_desc_num_prim_tum),
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_numb_of_prim_tumors,
                                               i_title_code => l_code_mult_tumors,
                                               i_title_type => pk_edis_hist.g_type_content,
                                               i_old_value  => to_clob(l_prev_rec_epis_diag.num_primary_tumors));
            --recurrence
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang, l_code_recurrence),
                                               i_value      => l_rec_epis_diag.desc_recurrence,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_recurrence,
                                               i_title_code => l_general_caract_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_recurrence);
        
            IF l_tab_epis_tumors.count > 0
            THEN
                l_current_tumor_idx := l_tab_epis_tumors.first;
                WHILE l_current_tumor_idx IS NOT NULL
                LOOP
                    -- add tumor section
                    add_tumor_section(l_current_tumor_idx);
                
                    IF l_prev_tab_epis_tumors.count > 0
                       AND l_flg_call = pk_edis_hist.g_call_hist
                    THEN
                        l_next_tumor_idx := l_tab_epis_tumors.next(l_current_tumor_idx);
                        l_prv_tumor_idx  := l_prev_tab_epis_tumors.first;
                        WHILE l_prv_tumor_idx IS NOT NULL
                        LOOP
                            IF l_prv_tumor_idx > l_current_tumor_idx
                               AND (l_prv_tumor_idx < l_next_tumor_idx OR l_next_tumor_idx IS NULL)
                            THEN
                                add_cancelled_tumor_section(i_tumor_idx => l_prv_tumor_idx);
                            END IF;
                        
                            l_prv_tumor_idx := l_prev_tab_epis_tumors.next(l_prv_tumor_idx);
                        END LOOP;
                    END IF;
                
                    l_current_tumor_idx := l_tab_epis_tumors.next(l_current_tumor_idx);
                END LOOP;
            END IF;
        
            g_error := 'ADD STAGING INFO';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF l_rec_epis_diag_staging.num_staging_basis IS NOT NULL
            THEN
                -- add staging info
                add_staging_info;
            END IF;
        
            g_error := 'ADDITIONAL INFO';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            --main diagnosis
            pk_edis_hist.add_value(i_lang       => i_lang,
                                   i_flg_call   => l_flg_call,
                                   i_label      => pk_translation.get_translation(i_lang, l_code_main_diag),
                                   i_value      => nvl(l_rec_epis_diag.desc_final_type, l_label_na),
                                   i_type       => pk_edis_hist.g_type_content,
                                   i_code       => l_code_main_diag,
                                   i_title_code => l_aditional_info_title,
                                   i_old_value  => nvl(l_prev_rec_epis_diag.desc_final_type, l_label_na));
        
            --status
            IF l_rec_epis_diag.flg_status <> pk_alert_constant.g_cancelled
            THEN
                pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                                   i_flg_call   => l_flg_call,
                                                   i_label      => pk_translation.get_translation(i_lang,
                                                                                                  l_code_diag_status),
                                                   i_value      => l_rec_epis_diag.desc_status,
                                                   i_type       => pk_edis_hist.g_type_content,
                                                   i_code       => l_code_diag_status,
                                                   i_title_code => l_aditional_info_title,
                                                   i_old_value  => l_prev_rec_epis_diag.desc_status);
                -- when showing the current info of a cancelled record, the screen must show the previous state
            ELSIF l_flg_call = pk_edis_hist.g_call_detail
            THEN
                l_prev_rec_epis_diag := get_epis_diag(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_episode        => i_episode,
                                                      i_epis_diag      => i_epis_diag,
                                                      i_epis_diag_hist => get_last_epis_diag_hist(i_lang,
                                                                                                  i_prof,
                                                                                                  i_epis_diag));
            
                pk_edis_hist.add_value_if_not_null(i_lang  => i_lang,
                                                   i_label => pk_translation.get_translation(i_lang, l_code_diag_status),
                                                   i_value => l_prev_rec_epis_diag.desc_status,
                                                   i_type  => pk_edis_hist.g_type_content,
                                                   i_code  => l_code_diag_status);
            END IF;
        
            -- complications
            process_complications();
        
            --notes
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang, l_code_diag_notes),
                                               i_value      => l_rec_epis_diag.diag_notes,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_diag_notes,
                                               i_title_code => l_aditional_info_title,
                                               i_old_value  => l_prev_rec_epis_diag.diag_notes);
        
            --add to problems
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_add_problems),
                                               i_value      => l_rec_epis_diag.desc_add_problem,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_add_problems,
                                               i_title_code => l_aditional_info_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_add_problem);
        
            -- lesion type                    
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang, l_code_lesion_type),
                                               i_value      => l_rec_epis_diag.desc_lesion_type,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_lesion_type,
                                               i_title_code => l_aditional_info_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_lesion_type);
        
            -- lesion location                    
            pk_edis_hist.add_value_if_not_null(i_lang       => i_lang,
                                               i_flg_call   => l_flg_call,
                                               i_label      => pk_translation.get_translation(i_lang,
                                                                                              l_code_lesion_location),
                                               i_value      => l_rec_epis_diag.desc_lesion_location,
                                               i_type       => pk_edis_hist.g_type_content,
                                               i_code       => l_code_lesion_location,
                                               i_title_code => l_aditional_info_title,
                                               i_old_value  => l_prev_rec_epis_diag.desc_lesion_location);
        
            --cancel reason
            pk_edis_hist.add_value_if_not_null(i_lang  => i_lang,
                                               i_label => pk_message.get_message(i_lang, i_prof, l_code_cancel_reason),
                                               i_value => nvl(l_rec_epis_diag_staging.desc_cancel_reason,
                                                              l_rec_epis_diag.desc_cancel_reason),
                                               i_type  => pk_edis_hist.g_type_content,
                                               i_code  => l_code_cancel_reason);
        
            --cancel notes
            pk_edis_hist.add_value_if_not_null(i_lang  => i_lang,
                                               i_label => pk_message.get_message(i_lang, i_prof, l_code_cancel_notes),
                                               i_value => nvl(l_rec_epis_diag_staging.cancel_notes,
                                                              l_rec_epis_diag.notes_cancel),
                                               i_type  => pk_edis_hist.g_type_content,
                                               i_code  => l_code_cancel_notes);
        
            --signature
            pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M013'),
                                   i_value => l_rec_epis_diag.name_prof_diag || chr(32) ||
                                              pk_utils.append_str_if_not_null(l_rec_epis_diag.spec_prof_diag, ')', '(') || '; ' ||
                                              l_rec_epis_diag.dt_epis_diagnosis_chr,
                                   i_type  => pk_edis_hist.g_type_signature,
                                   i_code  => 'SIGNATURE');
        
            --The requirement is to show the classification info only in detail data, it's not necessary in history records
            IF l_cfg_show_classification_inf = pk_alert_constant.g_yes
               AND i_flg_call = pk_edis_hist.g_call_detail
            THEN
                l_classification_information := pk_api_pfh_diagnosis_in.get_terminology_information(i_concept_version => l_rec_epis_diag.id_diagnosis);
            
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
            
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, l_code_classification_inf),
                                       i_value => NULL,
                                       i_type  => pk_edis_hist.g_type_title_italic,
                                       i_code  => l_code_classification_inf);
            
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, l_code_classification_name),
                                       i_value => pk_translation.get_translation(i_lang,
                                                                                 l_classification_information.code_terminology) || ' (' ||
                                                  pk_translation.get_translation(i_lang,
                                                                                 l_classification_information.code_abbreviation) || ')',
                                       i_type  => pk_edis_hist.g_type_content_italic,
                                       i_code  => l_code_classification_name);
            
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, l_code_version),
                                       i_value => pk_translation.get_translation(i_lang,
                                                                                 l_classification_information.code_version),
                                       i_type  => pk_edis_hist.g_type_content_italic,
                                       i_code  => l_code_version);
            
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, l_code_copyright),
                                       i_value => pk_translation.get_translation(i_lang,
                                                                                 l_classification_information.code_copyright),
                                       i_type  => pk_edis_hist.g_type_content_italic,
                                       i_code  => l_code_copyright);
            END IF;
        END LOOP;
    
        g_error := 'OPEN O_EPIS_DIAGNOSIS CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_epis_diagnosis FOR
            SELECT *
              FROM (SELECT t.id_history,
                           -- viewer fields
                           t.id_history viewer_category,
                           t.desc_cat_viewer viewer_category_desc,
                           t.id_professional viewer_id_prof,
                           t.id_episode viewer_id_epis,
                           pk_date_utils.date_send_tsz(i_lang, t.dt_history, i_prof) viewer_date,
                           --
                           t.dt_history,
                           t.tbl_labels,
                           t.tbl_values,
                           t.tbl_types,
                           t.tbl_info_labels,
                           t.tbl_info_values,
                           t.tbl_codes,
                           (SELECT COUNT(*)
                              FROM TABLE(t.tbl_types)) count_elems
                      FROM TABLE(pk_edis_hist.tf_hist) t)
            -- remove history entries that have no difference from the previous record
            -- this is necessary due to diagnosis replications in the same visit
             WHERE count_elems > 2;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_epis_diagnosis);
            RETURN FALSE;
    END get_epis_diagnosis_det;
    --
    /**********************************************************************************************
    * Get the diagnosis info to be placed in the viewer grid
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_patient                patient id
    * @param i_episode                episode id
    * @param i_epis_diag              diagnosis episode id
    * @param o_diag_staging           diangosis staging info
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          29-Mar-2012
    **********************************************************************************************/
    FUNCTION get_diag_viewer_info
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_patient      IN patient.id_patient%TYPE,
        i_episode      IN episode.id_episode%TYPE,
        i_epis_diag    IN epis_diagnosis.id_epis_diagnosis%TYPE,
        o_diag_staging OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_VIEWER_INFO';
        --
        l_diag_info table_varchar;
        -- staging records
        l_tab_epis_diag_staging pk_edis_types.tab_epis_diag_staging;
        l_rec_epis_diag_staging pk_edis_types.rec_epis_diag_staging;
    BEGIN
    
        l_diag_info := table_varchar();
    
        g_error := 'GET ACTIVE STAGINGS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        -- Get the associated staging(s)
        l_tab_epis_diag_staging := get_epis_diag_stagings(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_episode        => i_episode,
                                                          i_flg_call       => g_diag_call_viewer,
                                                          i_epis_diag      => i_epis_diag,
                                                          i_epis_diag_hist => NULL);
    
        g_error := 'LOOP STAGINGS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR i IN 1 .. l_tab_epis_diag_staging.count
        LOOP
            l_rec_epis_diag_staging := l_tab_epis_diag_staging(i);
        
            l_diag_info.extend;
            l_diag_info(l_diag_info.count) := pk_utils.to_bold(l_rec_epis_diag_staging.desc_stage_title) || chr(10) ||
                                              l_rec_epis_diag_staging.desc_group_title || chr(10) ||
                                              l_rec_epis_diag_staging.dt_epis_diag_stag_chr;
        END LOOP;
    
        g_error := 'OPEN CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_diag_staging FOR
            SELECT column_value desc_staging
              FROM TABLE(l_diag_info);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_types.open_cursor_if_closed(o_diag_staging);
            RETURN FALSE;
    END get_diag_viewer_info;
    --
    /**********************************************************************************************
    * Get staging basis type based on the given id
    *
    * @param i_staging_basis          Staging basis id
    *
    * @return                         Staging basis type
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION get_staging_basis_type
    (
        i_prof          IN profissional,
        i_staging_basis IN epis_diag_stag.id_staging_basis%TYPE
    ) RETURN flag_type IS
        l_concept_retreatment CONSTANT diagnosis_ea.concept_code%TYPE := 'r';
        l_stag_basis_type diagnosis_ea.concept_code%TYPE;
    BEGIN
        SELECT CASE d.concept_code
                   WHEN l_concept_retreatment THEN
                    pk_diagnosis_core.g_staging_retreatment_type
                   ELSE
                    pk_diagnosis_core.g_staging_other_type
               END
          INTO l_stag_basis_type
          FROM diagnosis_ea d
         WHERE d.id_concept_term = i_staging_basis
           AND d.id_institution = i_prof.institution
           AND d.id_software = i_prof.software
           AND rownum = 1;
    
        RETURN l_stag_basis_type;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_staging_basis_type;
    --
    /**********************************************************************************************
    * Get staging basis number, if it's a retreatment it will increment the current saved value 
    * otherwise it will return the saved value or if there is no saved value the default one
    *
    * @param i_epis_diagnosis         Epis diagnosis id
    * @param i_epis_diagnosis_hist    Epis diagnosis hist id
    * @param i_staging_basis          Staging basis id
    * @param i_flg_edit_mode          Edit mode
    *
    * @return                         Staging basis number that will be saved in DB
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION get_staging_basis_num
    (
        i_prof                IN profissional,
        i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        i_staging_basis       IN epis_diag_stag.id_staging_basis%TYPE,
        i_flg_edit_mode       IN flag_type
    ) RETURN epis_diag_stag.num_staging_basis%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_STAGING_BASIS_NUM';
        --
        l_num_staging_basis epis_diag_stag.num_staging_basis%TYPE;
        --
        FUNCTION get_saved_stag_basis_num RETURN epis_diag_stag.num_staging_basis%TYPE IS
            l_saved_num epis_diag_stag.num_staging_basis%TYPE;
        BEGIN
            SELECT num_staging_basis
              INTO l_saved_num
              FROM (SELECT eds.num_staging_basis
                      FROM epis_diag_stag eds
                     WHERE eds.id_epis_diagnosis = i_epis_diagnosis
                       AND eds.id_staging_basis = i_staging_basis
                       AND i_epis_diagnosis_hist IS NULL
                    UNION ALL
                    SELECT edsh.num_staging_basis
                      FROM epis_diag_stag_hist edsh
                     WHERE edsh.id_epis_diagnosis_hist = i_epis_diagnosis_hist
                       AND edsh.id_staging_basis = i_staging_basis);
        
            RETURN l_saved_num;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN g_default_stag_basis_num;
        END get_saved_stag_basis_num;
    BEGIN
        IF i_epis_diagnosis IS NULL
           AND i_epis_diagnosis_hist IS NULL
        THEN
            l_num_staging_basis := g_default_stag_basis_num;
        ELSIF i_flg_edit_mode != pk_diagnosis_core.g_diag_edit_mode_retreatment
        THEN
            l_num_staging_basis := get_saved_stag_basis_num();
        ELSE
            -- i_flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_reassess
        
            IF i_epis_diagnosis_hist IS NULL
            THEN
                SELECT nvl(MAX(a.num_staging_basis) + 1, g_default_stag_basis_num)
                  INTO l_num_staging_basis
                  FROM (SELECT eds.num_staging_basis
                          FROM epis_diag_stag eds
                         WHERE eds.id_epis_diagnosis = i_epis_diagnosis
                           AND eds.id_staging_basis = i_staging_basis
                        UNION ALL
                        SELECT edsh.num_staging_basis
                          FROM epis_diag_stag_hist edsh
                         WHERE edsh.id_epis_diagnosis = i_epis_diagnosis
                           AND edsh.id_staging_basis = i_staging_basis) a;
            ELSE
                l_num_staging_basis := get_saved_stag_basis_num();
            END IF;
        END IF;
    
        RETURN l_num_staging_basis;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_staging_basis_num;
    --
    /**********************************************************************************************
    * Get staging basis rank
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_staging_basis          Staging basis id
    *
    * @return                         Staging basis rank
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION get_staging_basis_rank
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_staging_basis IN epis_diag_stag.id_staging_basis%TYPE
    ) RETURN diagnosis_ea.rank%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_STAGING_BASIS_RANK';
        --
        l_staging_basis_rank diagnosis_ea.rank%TYPE := NULL;
    BEGIN
        g_error := 'FIND RANK OF ID_STAGING_BASIS: ' || i_staging_basis;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR r_staging_basis IN pk_diagnosis_form.c_staging_basis(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_flg_edit_mode => g_diag_create_mode,
                                                                 i_staging_basis => NULL)
        LOOP
            IF r_staging_basis.id_staging_basis = i_staging_basis
            THEN
                l_staging_basis_rank := r_staging_basis.rank;
                EXIT;
            END IF;
        END LOOP;
    
        RETURN l_staging_basis_rank;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_staging_basis_rank;
    --
    /**********************************************************************************************
    * Compares the given staging bases with the most advanced saved stage
    * This function is used to know if it's to save in history tables or set the new data as the most recent one
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_episode                Episode id
    * @param i_staging_basis          Staging basis id
    *
    * @return                         -1: if the given staging basis is prior to the saved one
    *                                  0: if it's equal to the saved one
    *                                  1: if it's forward stage 
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION compare_with_svd_stag_basis
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_diagnosis     IN epis_diagnosis.id_diagnosis%TYPE,
        i_staging_basis IN epis_diag_stag.id_staging_basis%TYPE
    ) RETURN PLS_INTEGER IS
        l_func_name CONSTANT VARCHAR2(30) := 'COMPARE_WITH_SVD_STAG_BASIS';
        --
        l_rank_svd_stage   diagnosis_ea.rank%TYPE;
        l_rank_given_stage diagnosis_ea.rank%TYPE;
        l_compare          PLS_INTEGER;
        --
        FUNCTION get_svd_stag_basis_rank RETURN epis_diag_stag.id_staging_basis%TYPE IS
            l_svd_stag_rank diagnosis_ea.rank%TYPE;
        BEGIN
            SELECT MAX(pk_diagnosis_core.get_staging_basis_rank(i_lang          => i_lang,
                                                                i_prof          => i_prof,
                                                                i_staging_basis => id_staging_basis))
              INTO l_svd_stag_rank
              FROM (WITH tbl_recent_cancel_stag AS (SELECT a.id_epis_diagnosis,
                                                           a.id_staging_basis,
                                                           MAX(a.dt_epis_diagnosis_stag) dt_epis_diagnosis_stag
                                                      FROM (SELECT eds2.id_epis_diagnosis,
                                                                   eds2.id_staging_basis,
                                                                   eds2.dt_epis_diagnosis_stag
                                                              FROM epis_diag_stag eds2
                                                             WHERE eds2.id_cancel_reason IS NOT NULL
                                                            UNION ALL
                                                            SELECT edsh2.id_epis_diagnosis,
                                                                   edsh2.id_staging_basis,
                                                                   edsh2.dt_epis_diagnosis_stag
                                                              FROM epis_diag_stag_hist edsh2
                                                             WHERE edsh2.id_cancel_reason IS NOT NULL) a
                                                     GROUP BY a.id_epis_diagnosis, a.id_staging_basis)
                       SELECT eds.id_staging_basis
                         FROM epis_diagnosis ed
                         JOIN epis_diag_stag eds
                           ON eds.id_epis_diagnosis = ed.id_epis_diagnosis
                         LEFT JOIN tbl_recent_cancel_stag t
                           ON t.id_epis_diagnosis = eds.id_epis_diagnosis
                          AND t.id_staging_basis = eds.id_staging_basis
                        WHERE ed.id_episode = i_episode
                          AND ed.id_diagnosis = i_diagnosis
                          AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca
                          AND eds.id_cancel_reason IS NULL
                          AND eds.dt_epis_diagnosis_stag > nvl(t.dt_epis_diagnosis_stag, eds.dt_epis_diagnosis_stag - 1)
                       UNION
                       SELECT edsh.id_staging_basis
                         FROM epis_diagnosis_hist edh
                         JOIN epis_diag_stag_hist edsh
                           ON edsh.id_epis_diagnosis = edh.id_epis_diagnosis
                         LEFT JOIN tbl_recent_cancel_stag t
                           ON t.id_epis_diagnosis = edsh.id_epis_diagnosis
                          AND t.id_staging_basis = edsh.id_staging_basis
                        WHERE edh.id_epis_diagnosis IN
                              (SELECT ed.id_epis_diagnosis
                                 FROM epis_diagnosis ed
                                WHERE ed.id_episode = i_episode
                                  AND ed.id_diagnosis = i_diagnosis
                                  AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca)
                          AND edh.flg_status != pk_diagnosis.g_ed_flg_status_ca
                          AND edsh.id_cancel_reason IS NULL
                          AND edsh.dt_epis_diagnosis_stag >
                              nvl(t.dt_epis_diagnosis_stag, edsh.dt_epis_diagnosis_stag - 1));
        
        
            RETURN l_svd_stag_rank;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END get_svd_stag_basis_rank;
    BEGIN
        g_error := 'GET SAVED STAGING BASIS RANK';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_rank_svd_stage := get_svd_stag_basis_rank();
    
        IF l_rank_svd_stage IS NOT NULL
        THEN
            g_error := 'GET GIVEN STAGING BASIS RANK';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_rank_given_stage := pk_diagnosis_core.get_staging_basis_rank(i_lang          => i_lang,
                                                                           i_prof          => i_prof,
                                                                           i_staging_basis => i_staging_basis);
        
            IF l_rank_given_stage IS NOT NULL
            THEN
                g_error := 'BASED ON RANK RETURN PRIORITY';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF l_rank_given_stage < l_rank_svd_stage
                THEN
                    l_compare := g_staging_basis_prior_stage;
                ELSIF l_rank_given_stage = l_rank_svd_stage
                THEN
                    --For instance in retreatments the stage will be the same
                    l_compare := g_staging_basis_same_stage;
                ELSE
                    l_compare := g_staging_basis_forward_stage;
                END IF;
            END IF;
        ELSE
            l_compare := g_staging_basis_forward_stage;
        END IF;
    
        RETURN l_compare;
    EXCEPTION
        WHEN OTHERS THEN
            g_error := g_error || ' (' || SQLCODE || ' - ' || SQLERRM || ')';
            pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            RETURN g_staging_basis_forward_stage;
    END compare_with_svd_stag_basis;
    --
    /**********************************************************************************************
    * Checks if a given staging basis is available for registration
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_staging_basis          Staging basis id
    * @param i_epis_st_basis          List of staging basis registered in the episode
    * @param i_flg_edit_mode          type of edition (values available as constants in the package SPEC)
    *
    * @return                         Staging basis is available: (Y)es or (N)o
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/Apr/02
    **********************************************************************************************/
    FUNCTION check_staging_basis_avail
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_staging_basis IN epis_diag_stag.id_staging_basis%TYPE,
        i_epis_st_basis IN pk_edis_types.tab_epis_diag_staging,
        i_flg_edit_mode IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_STAGING_BASIS_AVAIL';
        --
        l_rank_given_stage diagnosis_ea.rank%TYPE;
        l_staging_type     flag_type;
        l_ret              VARCHAR2(1 CHAR);
    BEGIN
    
        l_staging_type := get_staging_basis_type(i_prof => i_prof, i_staging_basis => i_staging_basis);
    
        IF i_epis_st_basis IS NULL
           OR i_epis_st_basis.count = 0
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSIF nvl(i_flg_edit_mode, g_diag_create_mode) = g_diag_create_mode
        THEN
            g_error := 'CREATION MODE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_rank_given_stage := pk_diagnosis_core.get_staging_basis_rank(i_lang          => i_lang,
                                                                           i_prof          => i_prof,
                                                                           i_staging_basis => i_staging_basis);
        
            g_error := 'CHECK RANK PRIORITY';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF l_rank_given_stage > i_epis_st_basis(i_epis_st_basis.count).rank
               OR (l_rank_given_stage = i_epis_st_basis(i_epis_st_basis.count).rank AND
               l_staging_type = g_staging_retreatment_type)
            
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_no;
            END IF;
        ELSIF i_flg_edit_mode = g_diag_edit_mode_retreatment
        THEN
            IF l_staging_type = g_staging_retreatment_type
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_yes;
            
                g_error := 'CHECK IF STAGING BASIS EXISTS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FOR i IN 1 .. i_epis_st_basis.count
                LOOP
                    IF i_epis_st_basis(i).id_staging_basis = i_staging_basis
                    THEN
                        l_ret := pk_alert_constant.g_no;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        ELSE
            l_ret := pk_alert_constant.g_yes;
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END check_staging_basis_avail;
    --
    /**********************************************************************************************
    * Get the previous active staging
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_current_staging_basis  Current staging basis id
    * @param i_episode                Episode id
    * @param i_diagnosis              Diagnosis id             
    * @param i_epis_diagnosis         Epis diagnosis id
    * @param i_flg_type               Type of diagnosis
    * @param i_dt_record              Current time
    *
    * @return                         Epis diagnosis hist id, if available
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/Jun/18
    **********************************************************************************************/
    FUNCTION get_last_active_staging
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_current_staging_basis IN epis_diag_stag.id_staging_basis%TYPE,
        i_episode               IN episode.id_episode%TYPE,
        i_diagnosis             IN diagnosis.id_diagnosis%TYPE,
        i_epis_diagnosis        IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_flg_type              IN epis_diagnosis.flg_type%TYPE,
        i_dt_record             IN epis_diagnosis_hist.dt_creation_tstz%TYPE
    ) RETURN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_LAST_ACTIVE_STAGING';
        --
        l_epis_diagnosis_hist     epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
        l_current_stag_basis_rank PLS_INTEGER;
    BEGIN
        g_error := 'GET CURRENT STAGING BASIS RANK';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_current_stag_basis_rank := pk_diagnosis_core.get_staging_basis_rank(i_lang          => i_lang,
                                                                              i_prof          => i_prof,
                                                                              i_staging_basis => i_current_staging_basis);
    
        g_error := 'GET PREVIOUS STAGING BASIS ID_EPIS_DIAGNOSIS_HIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT a.id_epis_diagnosis_hist
          INTO l_epis_diagnosis_hist
          FROM (SELECT edh.id_epis_diagnosis_hist,
                        row_number() over(ORDER BY edsh.stag_basis_rank DESC, edh.dt_creation_tstz DESC) line_number
                   FROM epis_diagnosis_hist edh
                   JOIN epis_diagnosis ed
                     ON ed.id_epis_diagnosis = edh.id_epis_diagnosis
                   JOIN (SELECT a.id_epis_diagnosis_hist,
                               pk_diagnosis_core.get_staging_basis_rank(i_lang          => i_lang,
                                                                        i_prof          => i_prof,
                                                                        i_staging_basis => a.id_staging_basis) stag_basis_rank
                          FROM epis_diag_stag_hist a
                          JOIN epis_diagnosis_hist b
                            ON b.id_epis_diagnosis_hist = a.id_epis_diagnosis_hist
                         WHERE b.id_epis_diagnosis = i_epis_diagnosis
                           AND b.flg_type = i_flg_type
                           AND b.flg_status != pk_diagnosis.g_ed_flg_status_ca
                              --We don't want history records inserted during the current transaction
                          AND b.dt_creation_tstz < i_dt_record
                          AND b.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                               pk_diagnosis.g_ed_flg_status_r,
                                               pk_diagnosis.g_ed_flg_status_d)
                          AND a.id_cancel_reason IS NULL) edsh
                    ON edsh.id_epis_diagnosis_hist = edh.id_epis_diagnosis_hist
                 WHERE ed.id_episode = i_episode
                   AND ed.id_diagnosis = i_diagnosis
                   AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca
                   AND (edsh.stag_basis_rank < l_current_stag_basis_rank OR l_current_stag_basis_rank IS NULL)) a
         WHERE a.line_number = 1;
    
        RETURN l_epis_diagnosis_hist;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_last_active_staging;
    --
    /**********************************************************************************************
    * Add created record PK to the output parameters table
    *
    * @param i_epis_diagnosis         Epis diagnosis id
    * @param i_epis_diagnosis_hist    Epis diagnosis hist id           
    * @param i_tumor_num              Tumor number
    * @param i_tumor_num_hist         Tumor number added directly to history table
    * @param i_diag_stag              Staging basis number
    * @param i_diag_stag_hist         Staging basis number added directly to history table
    * @param i_stag_pfactor           Prognostic factor field
    * @param i_stag_pfactor_hist      Prognostic factor fieldadded directly to history table
    * @param i_dt_record              Record date
    * @param i_problem_msg            Problem message
    * @param i_problem_msg_title      Problem title
    * @param i_problem_flg_show       Problem flg_show
    * @param i_problem_button         Problem button
    * @param io_params                Output parameters table         
    *
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    PROCEDURE add_output_param
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_episode             IN episode.id_episode%TYPE,
        i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        i_tumor_num           IN epis_diag_tumors.tumor_num%TYPE DEFAULT NULL,
        i_tumor_num_hist      IN epis_diag_tumors.tumor_num%TYPE DEFAULT NULL,
        i_diag_stag           IN epis_diag_stag.num_staging_basis%TYPE DEFAULT NULL,
        i_diag_stag_hist      IN epis_diag_stag.num_staging_basis%TYPE DEFAULT NULL,
        i_stag_pfactor        IN epis_diag_stag_pfact.id_field%TYPE DEFAULT NULL,
        i_stag_pfactor_hist   IN epis_diag_stag_pfact.id_field%TYPE DEFAULT NULL,
        i_dt_record           IN epis_diagnosis_hist.dt_creation_tstz%TYPE,
        i_id_complication     epis_diag_complications.id_complication%TYPE DEFAULT NULL,
        i_comp_description    VARCHAR2 DEFAULT NULL,
        i_comp_code           VARCHAR2 DEFAULT NULL,
        i_comp_rank           epis_diag_complications.rank%TYPE DEFAULT NULL,
        i_problem_msg         IN VARCHAR2 DEFAULT NULL,
        i_problem_msg_title   IN VARCHAR2 DEFAULT NULL,
        i_problem_flg_show    IN VARCHAR2 DEFAULT NULL,
        i_problem_button      IN VARCHAR2 DEFAULT NULL,
        io_params             IN OUT NOCOPY pk_edis_types.table_out_epis_diags
    ) IS
        l_proc_name CONSTANT VARCHAR2(30) := 'ADD_OUTPUT_PARAM';
        --
        l_epis_diag_index  PLS_INTEGER;
        l_rec_epis_diag    pk_edis_types.rec_out_epis_diag;
        l_rec_tumor        pk_edis_types.rec_out_tumor;
        l_rec_complication pk_edis_types.rec_out_complication;
        l_tbl_stagings     pk_edis_types.table_out_stagings;
        l_rec_staging      pk_edis_types.rec_out_staging;
        l_staging_index    PLS_INTEGER;
        l_rec_pfactor      pk_edis_types.rec_out_pfactor;
        --
        l_episode episode.id_episode%TYPE;
    BEGIN
        IF io_params IS NULL
        THEN
            g_error := 'INITIALIZE OUTPUT TABLE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
            io_params := pk_edis_types.table_out_epis_diags();
        END IF;
    
        g_error := 'GET ID_EPISODE';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
        IF i_episode IS NOT NULL
        THEN
            l_episode := i_episode;
        ELSIF i_epis_diagnosis IS NOT NULL
              OR i_epis_diagnosis_hist IS NOT NULL
        THEN
            SELECT ed.id_episode
              INTO l_episode
              FROM epis_diagnosis ed
             WHERE ((i_epis_diagnosis IS NOT NULL AND ed.id_epis_diagnosis = i_epis_diagnosis) OR
                   (i_epis_diagnosis IS NULL AND
                   ed.id_epis_diagnosis =
                   (SELECT edh.id_epis_diagnosis
                        FROM epis_diagnosis_hist edh
                       WHERE edh.id_epis_diagnosis_hist = i_epis_diagnosis_hist)));
        ELSE
            l_episode := NULL;
        END IF;
    
        l_epis_diag_index := NULL;
    
        IF i_problem_msg IS NOT NULL
           OR i_problem_msg_title IS NOT NULL
           OR i_problem_flg_show IS NOT NULL
           OR i_problem_button IS NOT NULL
        THEN
            g_error := 'INSERT PROBLEM OUTPUT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
            l_rec_epis_diag.dt_record         := i_dt_record;
            l_rec_epis_diag.id_professional   := i_prof.id;
            l_rec_epis_diag.prof_name         := pk_prof_utils.get_name_signature(i_lang, i_prof, i_prof.id);
            l_rec_epis_diag.prof_spec         := pk_prof_utils.get_spec_signature(i_lang,
                                                                                  i_prof,
                                                                                  i_prof.id,
                                                                                  i_dt_record,
                                                                                  l_episode);
            l_rec_epis_diag.problem_msg       := i_problem_msg;
            l_rec_epis_diag.problem_msg_title := i_problem_msg_title;
            l_rec_epis_diag.problem_flg_show  := i_problem_flg_show;
            l_rec_epis_diag.problem_button    := i_problem_button;
        ELSE
            g_error := 'INSERT DIAGNOSIS OUTPUT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
            IF io_params.count > 0
            THEN
                FOR i IN io_params.first .. io_params.last
                LOOP
                    l_rec_epis_diag := io_params(i);
                
                    IF (l_rec_epis_diag.id_epis_diagnosis = i_epis_diagnosis AND
                       l_rec_epis_diag.id_epis_diagnosis_hist = i_epis_diagnosis_hist)
                       OR (l_rec_epis_diag.id_epis_diagnosis = i_epis_diagnosis AND
                       l_rec_epis_diag.id_epis_diagnosis_hist IS NULL)
                       OR (l_rec_epis_diag.id_epis_diagnosis IS NULL AND
                       l_rec_epis_diag.id_epis_diagnosis_hist = i_epis_diagnosis_hist)
                    THEN
                        l_epis_diag_index := i;
                    
                        IF l_rec_epis_diag.id_epis_diagnosis IS NULL
                           AND i_epis_diagnosis IS NOT NULL
                        THEN
                            l_rec_epis_diag.id_epis_diagnosis := i_epis_diagnosis;
                        END IF;
                    
                        IF l_rec_epis_diag.id_epis_diagnosis_hist IS NULL
                           AND i_epis_diagnosis_hist IS NOT NULL
                        THEN
                            l_rec_epis_diag.id_epis_diagnosis_hist := i_epis_diagnosis_hist;
                        END IF;
                    
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        
            IF l_epis_diag_index IS NULL
            THEN
                g_error := 'EPIS_DIAG NOT FOUND ON OUTPUT TABLE SO SET INPUT VARS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_epis_diag.id_epis_diagnosis      := i_epis_diagnosis;
                l_rec_epis_diag.id_epis_diagnosis_hist := i_epis_diagnosis_hist;
                l_rec_epis_diag.dt_record              := i_dt_record;
                l_rec_epis_diag.id_professional        := i_prof.id;
                l_rec_epis_diag.prof_name              := pk_prof_utils.get_name_signature(i_lang, i_prof, i_prof.id);
                l_rec_epis_diag.prof_spec              := pk_prof_utils.get_spec_signature(i_lang,
                                                                                           i_prof,
                                                                                           i_prof.id,
                                                                                           i_dt_record,
                                                                                           l_episode);
            END IF;
        
            --------------------------------------------------
            IF l_rec_epis_diag.tbl_tumors IS NULL
            THEN
                g_error := 'INITIALIZE TUMORS TABLE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_epis_diag.tbl_tumors := pk_edis_types.table_out_tumors();
            END IF;
        
            IF i_tumor_num IS NOT NULL
               OR i_tumor_num_hist IS NOT NULL
            THEN
                g_error := 'ADD TUMOR DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_tumor.tumor_num               := i_tumor_num;
                l_rec_tumor.tumor_num_directly_hist := i_tumor_num_hist;
            
                l_rec_epis_diag.tbl_tumors.extend;
                l_rec_epis_diag.tbl_tumors(l_rec_epis_diag.tbl_tumors.count) := l_rec_tumor;
            END IF;
        
            --------------------------------------------------
            IF l_rec_epis_diag.tbl_complications IS NULL
            THEN
                g_error := 'INITIALIZE COMPLICATION TABLE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_epis_diag.tbl_complications := pk_edis_types.table_out_complications();
            END IF;
        
            IF i_id_complication IS NOT NULL
            THEN
                g_error := 'ADD COMPLICATION DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_complication.id_complication          := i_id_complication;
                l_rec_complication.complication_description := i_comp_description;
                l_rec_complication.complication_code        := i_comp_code;
                l_rec_complication.rank                     := i_comp_rank;
            
                l_rec_epis_diag.tbl_complications.extend;
                l_rec_epis_diag.tbl_complications(l_rec_epis_diag.tbl_complications.count) := l_rec_complication;
            END IF;
        
            --------------------------------------------------        
            IF l_rec_epis_diag.tbl_stagings IS NULL
            THEN
                g_error := 'INITIALIZE STAGING TABLE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_epis_diag.tbl_stagings := pk_edis_types.table_out_stagings();
            END IF;
        
            --------------------------------------------------
            IF (i_diag_stag IS NOT NULL OR i_diag_stag_hist IS NOT NULL)
               AND i_stag_pfactor IS NULL
               AND i_stag_pfactor_hist IS NULL
            THEN
                g_error := 'ADD STAGING DATA (1)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_rec_staging.diag_staging               := i_diag_stag;
                l_rec_staging.diag_staging_directly_hist := i_diag_stag_hist;
            
                l_rec_epis_diag.tbl_stagings.extend;
                l_rec_epis_diag.tbl_stagings(l_rec_epis_diag.tbl_stagings.count) := l_rec_staging;
            ELSIF (i_diag_stag IS NOT NULL OR i_diag_stag_hist IS NOT NULL)
                  AND (i_stag_pfactor IS NOT NULL OR i_stag_pfactor_hist IS NOT NULL)
            THEN
                g_error := 'ADD STAGING DATA (2)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                l_tbl_stagings  := l_rec_epis_diag.tbl_stagings;
                l_staging_index := NULL;
            
                IF l_tbl_stagings.count > 0
                THEN
                    FOR i IN l_tbl_stagings.first .. l_tbl_stagings.last
                    LOOP
                        l_rec_staging := l_tbl_stagings(i);
                    
                        IF (l_rec_staging.diag_staging = i_diag_stag AND
                           l_rec_staging.diag_staging_directly_hist IS NULL)
                           OR (l_rec_staging.diag_staging IS NULL AND
                           l_rec_staging.diag_staging_directly_hist = i_diag_stag_hist)
                        THEN
                            l_staging_index := i;
                        
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                IF l_rec_staging.tbl_prog_factors IS NULL
                THEN
                    l_rec_staging.tbl_prog_factors := pk_edis_types.table_out_pfactors();
                END IF;
            
                l_rec_pfactor.prog_factor               := i_stag_pfactor;
                l_rec_pfactor.prog_factor_directly_hist := i_stag_pfactor_hist;
            
                l_rec_staging.tbl_prog_factors.extend;
                l_rec_staging.tbl_prog_factors(l_rec_staging.tbl_prog_factors.count) := l_rec_pfactor;
            
                IF l_staging_index IS NULL
                THEN
                    l_rec_staging.diag_staging               := i_diag_stag;
                    l_rec_staging.diag_staging_directly_hist := i_diag_stag_hist;
                
                    l_tbl_stagings.extend;
                    l_tbl_stagings(l_tbl_stagings.count) := l_rec_staging;
                ELSE
                    l_tbl_stagings(l_staging_index) := l_rec_staging;
                END IF;
            
                l_rec_epis_diag.tbl_stagings := l_tbl_stagings;
            END IF;
        END IF;
    
        g_error := 'UPDATE IN OUT PARAM';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
        IF l_epis_diag_index IS NOT NULL
        THEN
            io_params(l_epis_diag_index) := l_rec_epis_diag;
        ELSE
            io_params.extend;
            io_params(io_params.count) := l_rec_epis_diag;
        END IF;
    END add_output_param;
    --
    /**********************************************************************************************
    * Save epis diagnosis tumors
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis         Epis diagnosis id
    * @param i_epis_diagnosis_hist    Epis diagnosis hist id
    * @param i_tbl_tumors             Tumors table     
    * @param i_dt_record              Record creation date    
    * @param o_params                 Output parameters record
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION set_epis_diag_tumors_internal
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE DEFAULT NULL,
        i_tbl_tumors          IN pk_edis_types.table_in_tumors,
        i_dt_record           IN epis_diag_tumors.dt_epis_diagnosis_tumors%TYPE,
        io_params             IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_TUMORS_INTERNAL';
        --
        r_tumor     pk_edis_types.rec_in_tumor;
        l_epis_diag epis_diagnosis.id_epis_diagnosis%TYPE;
        --
        l_exception EXCEPTION;
        --
        PROCEDURE check_input_vars IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'CHECK_INPUT_VARS';
        BEGIN
            IF i_epis_diagnosis IS NULL
               AND i_epis_diagnosis_hist IS NULL
            THEN
                g_error := 'BOTH FK ARE EMPTY (ID_EPIS_DIAG AND ID_EPIS_DIAG_HIST).';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                RAISE l_exception;
            END IF;
        END check_input_vars;
        --
        --This method is used when we are changing current data. So we want to send it to history.
        PROCEDURE add_current_tumors_to_hist
        (
            i_epis_diag      IN epis_diag_tumors.id_epis_diagnosis%TYPE,
            i_epis_diag_hist IN epis_diag_tumors_hist.id_epis_diagnosis_hist%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_CURRENT_TUMORS_TO_HIST';
            --
            tbl_epis_tumors ts_epis_diag_tumors_hist.epis_diag_tumors_hist_tc;
        BEGIN
            --IF i_epis_diag_hist IS NULL --> means that it's creating a new diagnosis so we don't need to save data to hist
            IF i_epis_diag_hist IS NOT NULL
            THEN
                g_error := 'GET CURRENT TUMORS ID_EPIS_DIAG: ' || i_epis_diag;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                SELECT i_epis_diag_hist             id_epis_diagnosis_hist,
                       edt.id_epis_diagnosis,
                       edt.tumor_num,
                       edt.id_topography,
                       edt.id_topog_inst_owner,
                       edt.id_laterality,
                       edt.id_lat_inst_owner,
                       edt.id_morphology,
                       edt.id_morph_inst_owner,
                       edt.id_behavior,
                       edt.id_behav_inst_owner,
                       edt.id_histological_grade,
                       edt.id_hgrade_inst_owner,
                       edt.id_other_grading_sys,
                       edt.id_ogradsys_inst_owner,
                       edt.flg_unknown_dimension,
                       edt.num_dimension,
                       edt.desc_dimension,
                       edt.additional_pathol_info,
                       edt.dt_epis_diagnosis_tumors,
                       NULL                         create_user,
                       NULL                         create_time,
                       NULL                         create_institution,
                       NULL                         update_user,
                       NULL                         update_time,
                       NULL                         update_institution
                  BULK COLLECT
                  INTO tbl_epis_tumors
                  FROM epis_diag_tumors edt
                 WHERE edt.id_epis_diagnosis = i_epis_diag;
            
                g_error := 'SAVE CURRENT TUMORS IN HIST. ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_diag_tumors_hist.ins(rows_in => tbl_epis_tumors);
            
                g_error := 'DELETE CURRENT TUMORS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_diag_tumors.del_id_epis_diagnosis(id_epis_diagnosis_in => i_epis_diag);
            END IF;
        END add_current_tumors_to_hist;
    BEGIN
        g_error := 'CALL CHECK_INPUT_VARS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        check_input_vars;
    
        IF i_tbl_tumors IS NOT NULL
           AND i_tbl_tumors.count > 0
        THEN
            --i_epis_diagnosis is not null     -> means that we are adding new tumor data
            --i_epis_diagnosis is null     and i_epis_diagnosis_hist is not null -> means that we are inserting directly into history
        
            IF i_epis_diagnosis IS NOT NULL
            THEN
                g_error := 'ADD CURRENT TUMORS TO HISTORY';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_current_tumors_to_hist(i_epis_diag => i_epis_diagnosis, i_epis_diag_hist => i_epis_diagnosis_hist);
            
                FOR i IN i_tbl_tumors.first .. i_tbl_tumors.last
                LOOP
                    r_tumor := i_tbl_tumors(i);
                
                    g_error := 'ADD NEW TUMOR RECORD';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_diag_tumors.ins(id_epis_diagnosis_in        => i_epis_diagnosis,
                                            tumor_num_in                => r_tumor.tumor_num,
                                            id_topography_in            => r_tumor.id_topography,
                                            id_topog_inst_owner_in      => CASE
                                                                               WHEN r_tumor.id_topography IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            id_laterality_in            => r_tumor.id_laterality,
                                            id_lat_inst_owner_in        => CASE
                                                                               WHEN r_tumor.id_laterality IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            id_morphology_in            => r_tumor.morphology.morphology,
                                            id_morph_inst_owner_in      => CASE
                                                                               WHEN r_tumor.morphology.morphology IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            id_behavior_in              => r_tumor.morphology.behavior,
                                            id_behav_inst_owner_in      => CASE
                                                                               WHEN r_tumor.morphology.behavior IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            id_histological_grade_in    => r_tumor.morphology.grade,
                                            id_hgrade_inst_owner_in     => CASE
                                                                               WHEN r_tumor.morphology.grade IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            id_other_grading_sys_in     => r_tumor.id_other_grading_sys,
                                            id_ogradsys_inst_owner_in   => CASE
                                                                               WHEN r_tumor.id_other_grading_sys IS NOT NULL THEN
                                                                                pk_alert_constant.g_inst_all
                                                                               ELSE
                                                                                NULL
                                                                           END,
                                            flg_unknown_dimension_in    => r_tumor.flg_unknown_dimension,
                                            num_dimension_in            => r_tumor.num_dimension,
                                            desc_dimension_in           => r_tumor.desc_dimension,
                                            additional_pathol_info_in   => r_tumor.additional_pathol_info,
                                            dt_epis_diagnosis_tumors_in => i_dt_record);
                
                    g_error := 'ADD OUTPUT PARAMETER';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    add_output_param(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_episode             => NULL,
                                     i_epis_diagnosis      => i_epis_diagnosis,
                                     i_epis_diagnosis_hist => NULL,
                                     i_tumor_num           => r_tumor.tumor_num,
                                     i_tumor_num_hist      => NULL,
                                     i_dt_record           => i_dt_record,
                                     io_params             => io_params);
                END LOOP;
            ELSIF i_epis_diagnosis IS NULL
                  AND i_epis_diagnosis_hist IS NOT NULL
            THEN
                --i_epis_diagnosis IS NULL - We are inserting directly into history
            
                g_error := 'GET ID_EPIS_DIAG BY USING ID_EPIS_DIAG_HIST: ' || i_epis_diagnosis_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT edh.id_epis_diagnosis
                  INTO l_epis_diag
                  FROM epis_diagnosis_hist edh
                 WHERE edh.id_epis_diagnosis_hist = i_epis_diagnosis_hist;
            
                FOR i IN i_tbl_tumors.first .. i_tbl_tumors.last
                LOOP
                    r_tumor := i_tbl_tumors(i);
                
                    g_error := 'ADD NEW TUMOR RECORD DIRECTLY INTO HISTORY DATA';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_diag_tumors_hist.ins(id_epis_diagnosis_hist_in   => i_epis_diagnosis_hist,
                                                 id_epis_diagnosis_in        => l_epis_diag,
                                                 tumor_num_in                => r_tumor.tumor_num,
                                                 id_topography_in            => r_tumor.id_topography,
                                                 id_topog_inst_owner_in      => CASE
                                                                                    WHEN r_tumor.id_topography IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 id_laterality_in            => r_tumor.id_laterality,
                                                 id_lat_inst_owner_in        => CASE
                                                                                    WHEN r_tumor.id_laterality IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 id_morphology_in            => r_tumor.morphology.morphology,
                                                 id_morph_inst_owner_in      => CASE
                                                                                    WHEN r_tumor.morphology.morphology IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 id_behavior_in              => r_tumor.morphology.behavior,
                                                 id_behav_inst_owner_in      => CASE
                                                                                    WHEN r_tumor.morphology.behavior IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 id_histological_grade_in    => r_tumor.morphology.grade,
                                                 id_hgrade_inst_owner_in     => CASE
                                                                                    WHEN r_tumor.morphology.grade IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 id_other_grading_sys_in     => r_tumor.id_other_grading_sys,
                                                 id_ogradsys_inst_owner_in   => CASE
                                                                                    WHEN r_tumor.id_other_grading_sys IS NOT NULL THEN
                                                                                     pk_alert_constant.g_inst_all
                                                                                    ELSE
                                                                                     NULL
                                                                                END,
                                                 flg_unknown_dimension_in    => r_tumor.flg_unknown_dimension,
                                                 num_dimension_in            => r_tumor.num_dimension,
                                                 desc_dimension_in           => r_tumor.desc_dimension,
                                                 additional_pathol_info_in   => r_tumor.additional_pathol_info,
                                                 dt_epis_diagnosis_tumors_in => i_dt_record);
                
                    g_error := 'ADD OUTPUT PARAMETER';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    add_output_param(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_episode             => NULL,
                                     i_epis_diagnosis      => l_epis_diag,
                                     i_epis_diagnosis_hist => i_epis_diagnosis_hist,
                                     i_tumor_num           => NULL,
                                     i_tumor_num_hist      => r_tumor.tumor_num,
                                     i_dt_record           => i_dt_record,
                                     io_params             => io_params);
                END LOOP;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diag_tumors_internal;
    --
    /**********************************************************************************************
    * Save epis diagnosis staging
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis         Epis diagnosis id
    * @param i_epis_diagnosis_hist    Epis diagnosis hist id
    * @param i_tbl_diag_stag          Staging table     
    * @param i_dt_record              Record creation date    
    * @param o_params                 Output parameters record
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/09
    **********************************************************************************************/
    FUNCTION set_epis_diag_stag_internal
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_epis_diagnosis_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE DEFAULT NULL,
        i_tbl_diag_stag       IN pk_edis_types.table_in_diag_staging,
        i_dt_record           IN epis_diag_stag.dt_epis_diagnosis_stag%TYPE,
        io_params             IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_STAG_INTERNAL';
        --
        r_staging      pk_edis_types.rec_in_diag_staging;
        r_prog_factors pk_edis_types.rec_in_prog_factor;
        l_epis_diag    epis_diagnosis.id_epis_diagnosis%TYPE;
        --
        l_exception EXCEPTION;
        --
        PROCEDURE check_input_vars IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'CHECK_INPUT_VARS';
        BEGIN
            IF i_epis_diagnosis IS NULL
               AND i_epis_diagnosis_hist IS NULL
            THEN
                g_error := 'BOTH FK ARE EMPTY (ID_EPIS_DIAG AND ID_EPIS_DIAG_HIST).';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                RAISE l_exception;
            END IF;
        END check_input_vars;
        --
        --This method is used when we are changing current data. So we want to send it to history.
        PROCEDURE add_current_stags_to_hist
        (
            i_epis_diag      IN epis_diag_stag.id_epis_diagnosis%TYPE,
            i_epis_diag_hist IN epis_diag_stag_hist.id_epis_diagnosis_hist%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_CURRENT_STAGS_TO_HIST';
            --
            tbl_stagings     ts_epis_diag_stag_hist.epis_diag_stag_hist_tc;
            tbl_prog_factors ts_epis_dstag_pfact_hist.epis_dstag_pfact_hist_tc;
        BEGIN
            IF i_epis_diag_hist IS NOT NULL
            THEN
                g_error := 'GET CURRENT STAGINGS ID_EPIS_DIAG: ' || i_epis_diag;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                SELECT i_epis_diag_hist           id_epis_diagnosis_hist,
                       eds.id_epis_diagnosis,
                       eds.num_staging_basis,
                       eds.id_staging_basis,
                       eds.id_sbasis_inst_owner,
                       eds.id_tnm_t,
                       eds.id_tnm_t_inst_owner,
                       eds.code_tnm_t,
                       eds.id_tnm_n,
                       eds.id_tnm_n_inst_owner,
                       eds.code_tnm_n,
                       eds.id_tnm_m,
                       eds.id_tnm_m_inst_owner,
                       eds.code_tnm_m,
                       eds.id_metastatic_sites,
                       eds.id_msites_inst_owner,
                       eds.id_staging_group,
                       eds.id_sgroup_inst_owner,
                       eds.id_residual_tumor,
                       eds.id_rtumor_inst_owner,
                       eds.id_surgical_margins,
                       eds.id_smargins_inst_owner,
                       eds.id_lymph_vasc_inv,
                       eds.id_lvinv_inst_owner,
                       eds.id_other_staging_sys,
                       eds.id_ostgsys_inst_owner,
                       eds.id_cancel_reason,
                       eds.cancel_notes,
                       eds.id_prof_create,
                       eds.dt_epis_diagnosis_stag,
                       NULL                       create_user,
                       NULL                       create_time,
                       NULL                       create_institution,
                       NULL                       update_user,
                       NULL                       update_time,
                       NULL                       update_institution
                  BULK COLLECT
                  INTO tbl_stagings
                  FROM epis_diag_stag eds
                 WHERE eds.id_epis_diagnosis = i_epis_diag;
            
                g_error := 'SAVE CURRENT STAGINGS IN HIST. ID_EPIS_DIAG_HIST: ' || i_epis_diag_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_diag_stag_hist.ins(rows_in => tbl_stagings);
            
                g_error := 'GET CURRENT PROG FACTORS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                SELECT i_epis_diag_hist        id_epis_diagnosis_hist,
                       pf.id_epis_diagnosis,
                       pf.num_staging_basis,
                       pf.id_field,
                       pf.id_field_inst_owner,
                       pf.field_rank,
                       pf.id_value,
                       pf.id_value_inst_owner,
                       pf.desc_value,
                       NULL                    create_user,
                       NULL                    create_time,
                       NULL                    create_institution,
                       NULL                    update_user,
                       NULL                    update_time,
                       NULL                    update_institution,
                       pf.id_staging_basis,
                       pf.id_sbasis_inst_owner
                  BULK COLLECT
                  INTO tbl_prog_factors
                  FROM epis_diag_stag_pfact pf
                 WHERE pf.id_epis_diagnosis = i_epis_diag;
            
                g_error := 'SAVE PROG FACTORS IN HIST';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_dstag_pfact_hist.ins(rows_in => tbl_prog_factors);
            
                g_error := 'DELETE CURRENT PROG FACTORS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_diag_stag_pfact.del_id_epis_diagnosis(id_epis_diagnosis_in => i_epis_diag);
            
                g_error := 'DELETE CURRENT STAGINGS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                ts_epis_diag_stag.del_id_epis_diagnosis(id_epis_diagnosis_in => i_epis_diag);
            END IF;
        END add_current_stags_to_hist;
    BEGIN
        g_error := 'CALL CHECK_INPUT_VARS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        check_input_vars;
    
        IF i_tbl_diag_stag IS NOT NULL
           AND i_tbl_diag_stag.count > 0
        THEN
            --i_epis_diagnosis is not null     -> means that we are adding new staging data
            --i_epis_diagnosis is null     and i_epis_diagnosis_hist is not null -> means that we are inserting directly into history
        
            IF i_epis_diagnosis IS NOT NULL
            THEN
                g_error := 'ADD CURRENT STAGINGS TO HISTORY';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_current_stags_to_hist(i_epis_diag => i_epis_diagnosis, i_epis_diag_hist => i_epis_diagnosis_hist);
            
                FOR i IN i_tbl_diag_stag.first .. i_tbl_diag_stag.last
                LOOP
                    r_staging := i_tbl_diag_stag(i);
                
                    g_error := 'ADD NEW STAGING RECORD';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_diag_stag.ins(id_epis_diagnosis_in      => i_epis_diagnosis,
                                          num_staging_basis_in      => r_staging.num_staging_basis,
                                          id_staging_basis_in       => r_staging.id_staging_basis,
                                          id_sbasis_inst_owner_in   => CASE
                                                                           WHEN r_staging.id_staging_basis IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_tnm_t_in               => r_staging.tnm.t,
                                          id_tnm_t_inst_owner_in    => CASE
                                                                           WHEN r_staging.tnm.t IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          code_tnm_t_in             => r_staging.tnm.code_stage_t,
                                          id_tnm_n_in               => r_staging.tnm.n,
                                          id_tnm_n_inst_owner_in    => CASE
                                                                           WHEN r_staging.tnm.n IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          code_tnm_n_in             => r_staging.tnm.code_stage_n,
                                          id_tnm_m_in               => r_staging.tnm.m,
                                          id_tnm_m_inst_owner_in    => CASE
                                                                           WHEN r_staging.tnm.m IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          code_tnm_m_in             => r_staging.tnm.code_stage_m,
                                          id_metastatic_sites_in    => r_staging.id_metastatic_sites,
                                          id_msites_inst_owner_in   => CASE
                                                                           WHEN r_staging.id_metastatic_sites IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_staging_group_in       => r_staging.id_staging_group,
                                          id_sgroup_inst_owner_in   => CASE
                                                                           WHEN r_staging.id_staging_group IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_residual_tumor_in      => r_staging.id_residual_tumor,
                                          id_rtumor_inst_owner_in   => CASE
                                                                           WHEN r_staging.id_residual_tumor IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_surgical_margins_in    => r_staging.id_surgical_margins,
                                          id_smargins_inst_owner_in => CASE
                                                                           WHEN r_staging.id_surgical_margins IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_lymph_vasc_inv_in      => r_staging.id_lymph_vasc_inv,
                                          id_lvinv_inst_owner_in    => CASE
                                                                           WHEN r_staging.id_lymph_vasc_inv IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_other_staging_sys_in   => r_staging.id_other_staging_sys,
                                          id_ostgsys_inst_owner_in  => CASE
                                                                           WHEN r_staging.id_other_staging_sys IS NOT NULL THEN
                                                                            pk_alert_constant.g_inst_all
                                                                           ELSE
                                                                            NULL
                                                                       END,
                                          id_cancel_reason_in       => r_staging.id_cancel_reason,
                                          cancel_notes_in           => r_staging.cancel_notes,
                                          id_prof_create_in         => i_prof.id,
                                          dt_epis_diagnosis_stag_in => i_dt_record);
                
                    g_error := 'ADD OUTPUT PARAMETER';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    add_output_param(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_episode             => NULL,
                                     i_epis_diagnosis      => i_epis_diagnosis,
                                     i_epis_diagnosis_hist => NULL,
                                     i_diag_stag           => r_staging.num_staging_basis,
                                     i_diag_stag_hist      => NULL,
                                     i_dt_record           => i_dt_record,
                                     io_params             => io_params);
                
                    IF r_staging.tbl_prog_factors IS NOT NULL
                       AND r_staging.tbl_prog_factors.count > 0
                    THEN
                        FOR j IN r_staging.tbl_prog_factors.first .. r_staging.tbl_prog_factors.last
                        LOOP
                            r_prog_factors := r_staging.tbl_prog_factors(j);
                        
                            g_error := 'ADD NEW PROG_FACTOR RECORD';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            ts_epis_diag_stag_pfact.ins(id_epis_diagnosis_in    => i_epis_diagnosis,
                                                        id_staging_basis_in     => r_staging.id_staging_basis,
                                                        id_sbasis_inst_owner_in => CASE
                                                                                       WHEN r_staging.id_staging_basis IS NOT NULL THEN
                                                                                        pk_alert_constant.g_inst_all
                                                                                       ELSE
                                                                                        NULL
                                                                                   END,
                                                        num_staging_basis_in    => r_staging.num_staging_basis,
                                                        id_field_in             => r_prog_factors.id_field,
                                                        id_field_inst_owner_in  => CASE
                                                                                       WHEN r_prog_factors.id_field IS NOT NULL THEN
                                                                                        pk_alert_constant.g_inst_all
                                                                                       ELSE
                                                                                        NULL
                                                                                   END,
                                                        field_rank_in           => r_prog_factors.field_rank,
                                                        id_value_in             => r_prog_factors.id_value,
                                                        id_value_inst_owner_in  => CASE
                                                                                       WHEN r_prog_factors.id_value IS NOT NULL THEN
                                                                                        pk_alert_constant.g_inst_all
                                                                                       ELSE
                                                                                        NULL
                                                                                   END,
                                                        desc_value_in           => r_prog_factors.desc_value);
                        
                            g_error := 'ADD OUTPUT PARAMETER';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            add_output_param(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_episode             => NULL,
                                             i_epis_diagnosis      => i_epis_diagnosis,
                                             i_epis_diagnosis_hist => NULL,
                                             i_stag_pfactor        => r_prog_factors.id_field,
                                             i_stag_pfactor_hist   => NULL,
                                             i_dt_record           => i_dt_record,
                                             io_params             => io_params);
                        END LOOP;
                    END IF;
                END LOOP;
            ELSIF i_epis_diagnosis IS NULL
                  AND i_epis_diagnosis_hist IS NOT NULL
            THEN
                --i_epis_diagnosis IS NULL - We are inserting directly into history
            
                g_error := 'GET ID_EPIS_DIAG BY USING ID_EPIS_DIAG_HIST: ' || i_epis_diagnosis_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT edh.id_epis_diagnosis
                  INTO l_epis_diag
                  FROM epis_diagnosis_hist edh
                 WHERE edh.id_epis_diagnosis_hist = i_epis_diagnosis_hist;
            
                FOR i IN i_tbl_diag_stag.first .. i_tbl_diag_stag.last
                LOOP
                    r_staging := i_tbl_diag_stag(i);
                
                    g_error := 'ADD NEW STAGING RECORD DIRECTLY INTO HISTORY DATA';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    ts_epis_diag_stag_hist.ins(id_epis_diagnosis_hist_in => i_epis_diagnosis_hist,
                                               id_epis_diagnosis_in      => l_epis_diag,
                                               num_staging_basis_in      => r_staging.num_staging_basis,
                                               id_staging_basis_in       => r_staging.id_staging_basis,
                                               id_sbasis_inst_owner_in   => CASE
                                                                                WHEN r_staging.id_staging_basis IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_tnm_t_in               => r_staging.tnm.t,
                                               id_tnm_t_inst_owner_in    => CASE
                                                                                WHEN r_staging.tnm.t IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               code_tnm_t_in             => r_staging.tnm.code_stage_t,
                                               id_tnm_n_in               => r_staging.tnm.n,
                                               id_tnm_n_inst_owner_in    => CASE
                                                                                WHEN r_staging.tnm.n IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               code_tnm_n_in             => r_staging.tnm.code_stage_n,
                                               id_tnm_m_in               => r_staging.tnm.m,
                                               id_tnm_m_inst_owner_in    => CASE
                                                                                WHEN r_staging.tnm.m IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               code_tnm_m_in             => r_staging.tnm.code_stage_m,
                                               id_metastatic_sites_in    => r_staging.id_metastatic_sites,
                                               id_msites_inst_owner_in   => CASE
                                                                                WHEN r_staging.id_metastatic_sites IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_staging_group_in       => r_staging.id_staging_group,
                                               id_sgroup_inst_owner_in   => CASE
                                                                                WHEN r_staging.id_staging_group IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_residual_tumor_in      => r_staging.id_residual_tumor,
                                               id_rtumor_inst_owner_in   => CASE
                                                                                WHEN r_staging.id_residual_tumor IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_surgical_margins_in    => r_staging.id_surgical_margins,
                                               id_smargins_inst_owner_in => CASE
                                                                                WHEN r_staging.id_surgical_margins IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_lymph_vasc_inv_in      => r_staging.id_lymph_vasc_inv,
                                               id_lvinv_inst_owner_in    => CASE
                                                                                WHEN r_staging.id_lymph_vasc_inv IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_other_staging_sys_in   => r_staging.id_other_staging_sys,
                                               id_ostgsys_inst_owner_in  => CASE
                                                                                WHEN r_staging.id_other_staging_sys IS NOT NULL THEN
                                                                                 pk_alert_constant.g_inst_all
                                                                                ELSE
                                                                                 NULL
                                                                            END,
                                               id_cancel_reason_in       => r_staging.id_cancel_reason,
                                               cancel_notes_in           => r_staging.cancel_notes,
                                               id_prof_create_in         => i_prof.id,
                                               dt_epis_diagnosis_stag_in => i_dt_record);
                
                    g_error := 'ADD OUTPUT PARAMETER';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    add_output_param(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_episode             => NULL,
                                     i_epis_diagnosis      => l_epis_diag,
                                     i_epis_diagnosis_hist => i_epis_diagnosis_hist,
                                     i_diag_stag           => NULL,
                                     i_diag_stag_hist      => r_staging.num_staging_basis,
                                     i_dt_record           => i_dt_record,
                                     io_params             => io_params);
                
                    IF r_staging.tbl_prog_factors IS NOT NULL
                       AND r_staging.tbl_prog_factors.count > 0
                    THEN
                        FOR j IN r_staging.tbl_prog_factors.first .. r_staging.tbl_prog_factors.last
                        LOOP
                            r_prog_factors := r_staging.tbl_prog_factors(j);
                        
                            g_error := 'ADD NEW PROG_FACTOR RECORD DIRECTLY INTO HISTORY DATA';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            ts_epis_dstag_pfact_hist.ins(id_epis_diagnosis_hist_in => i_epis_diagnosis_hist,
                                                         id_epis_diagnosis_in      => l_epis_diag,
                                                         id_staging_basis_in       => r_staging.id_staging_basis,
                                                         id_sbasis_inst_owner_in   => CASE
                                                                                          WHEN r_staging.id_staging_basis IS NOT NULL THEN
                                                                                           pk_alert_constant.g_inst_all
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                         num_staging_basis_in      => r_staging.num_staging_basis,
                                                         id_field_in               => r_prog_factors.id_field,
                                                         id_field_inst_owner_in    => CASE
                                                                                          WHEN r_prog_factors.id_field IS NOT NULL THEN
                                                                                           pk_alert_constant.g_inst_all
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                         field_rank_in             => r_prog_factors.field_rank,
                                                         id_value_in               => r_prog_factors.id_value,
                                                         id_value_inst_owner_in    => CASE
                                                                                          WHEN r_prog_factors.id_value IS NOT NULL THEN
                                                                                           pk_alert_constant.g_inst_all
                                                                                          ELSE
                                                                                           NULL
                                                                                      END,
                                                         desc_value_in             => r_prog_factors.desc_value);
                        
                            g_error := 'ADD OUTPUT PARAMETER';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            add_output_param(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_episode             => NULL,
                                             i_epis_diagnosis      => l_epis_diag,
                                             i_epis_diagnosis_hist => i_epis_diagnosis_hist,
                                             i_stag_pfactor        => NULL,
                                             i_stag_pfactor_hist   => r_prog_factors.id_field,
                                             i_dt_record           => i_dt_record,
                                             io_params             => io_params);
                        END LOOP;
                    END IF;
                END LOOP;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diag_stag_internal;
    --
    /********************************************************************************************
    * Cria / elimina um problema associado a um diagnostico
      O problema e criado para diagnoticos definitivos e no estado confirmado; o problema e eliminado
      para os restantes estados
      Esta funcao e chamada em todos os locais onde se cria um diagnostico e em todos os locais onde
      se altera o estado do diagnostico para se as regras de negrito se alterarem ser mais facil
      actualizar o codigo
    *
    * @param i_lang                   ID da lingua
    * @param i_prof                   Objecto (id do profissional, id da instituicao, id do software)
    * @param i_epis_diagnosis         Epis diagnosis record
    * @param o_params                 Output parameters record
    * @param o_error                  Error message
    *
    * @return                         true or false para sucesso ou erro
    *
    * @author                         Luis Oliveira
    * @version                        1.0   
    * @since                          2007/06/26
    **********************************************************************************************/
    FUNCTION create_del_prob_assoc_diag_int
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
        io_params        IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_DEL_PROB_ASSOC_DIAG_INT';
        --
        l_rec_diagnosis pk_edis_types.rec_in_diagnosis;
        --
        l_flg_status table_varchar := table_varchar();
        --
        l_flg_show  VARCHAR2(1);
        l_msg_title VARCHAR2(2000);
        l_msg_text  VARCHAR2(2000);
        l_button    VARCHAR2(6);
    
        l_dt_init_diag VARCHAR2(200);
        l_format_short_dt CONSTANT VARCHAR2(10 CHAR) := 'YYYY-MM-DD';
        --
        r_existing_diag         c_existing_diag%ROWTYPE;
        l_diff_diag_flg_add_prb epis_diagnosis.flg_add_problem%TYPE;
        l_diff_id_epis_diag     epis_diagnosis.id_epis_diagnosis%TYPE;
    
        l_diff_diagnoses_same_icd    sys_config.value%TYPE := pk_sysconfig.get_config('ALLOW_DIFF_DIAGNOSIS_SAME_ICD',
                                                                                      i_prof);
        l_disch_diagnoses_same_icd   sys_config.value%TYPE := pk_sysconfig.get_config('ALLOW_DISCH_DIAGNOSIS_SAME_ICD',
                                                                                      i_prof);
        l_allow_diagnoses_same_icd   sys_config.value%TYPE := pk_alert_constant.g_no;
        l_terminology_allow_same_icd VARCHAR2(1) := NULL;
    BEGIN
        l_rec_diagnosis := i_epis_diagnosis.tbl_diagnosis(1);
    
        IF (l_diff_diagnoses_same_icd = pk_alert_constant.g_yes AND
           i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_p)
           OR (l_disch_diagnoses_same_icd = pk_alert_constant.g_yes AND
           i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_d)
        THEN
            l_allow_diagnoses_same_icd := pk_alert_constant.g_yes;
        END IF;
    
        l_terminology_allow_same_icd := pk_ts1_api.get_allow_duplicate(i_lang               => i_lang,
                                                                       i_id_concept_term    => l_rec_diagnosis.id_alert_diagnosis,
                                                                       i_id_concept_version => l_rec_diagnosis.id_diagnosis,
                                                                       i_id_task_type       => pk_alert_constant.g_task_diagnosis,
                                                                       i_id_institution     => i_prof.institution,
                                                                       i_id_software        => i_prof.software);
    
        --ALERT-250280 - Don't remove problem when differencial diagnosis is not cancelled
        IF i_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_diag
           AND i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_d
           AND nvl(i_epis_diagnosis.flg_cancel_diff_diag, pk_alert_constant.g_no) = pk_alert_constant.g_no
        THEN
            g_error := 'GET WORKING DIAGNOSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            OPEN c_existing_diag(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => i_epis_diagnosis.id_episode,
                                 i_diagnosis           => l_rec_diagnosis.id_diagnosis,
                                 i_alert_diagnosis     => CASE
                                                              WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                   AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                   pk_alert_constant.g_yes THEN
                                                               l_rec_diagnosis.id_alert_diagnosis
                                                              ELSE
                                                               NULL
                                                          END,
                                 i_flg_type            => pk_diagnosis.g_diag_type_p,
                                 i_desc_diag           => l_rec_diagnosis.desc_diagnosis,
                                 i_flg_cancer_diag     => pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                                              i_prof         => i_prof,
                                                                                              i_concept_type => NULL,
                                                                                              i_diagnosis    => l_rec_diagnosis.id_diagnosis),
                                 i_diagnosis_condition => l_rec_diagnosis.id_diagnosis_condition,
                                 i_sub_analysis        => l_rec_diagnosis.id_sub_analysis,
                                 i_anatomical_area     => l_rec_diagnosis.id_anatomical_area,
                                 i_anatomical_side     => l_rec_diagnosis.id_anatomical_side);
            FETCH c_existing_diag
                INTO r_existing_diag;
            CLOSE c_existing_diag;
        
            IF r_existing_diag.id_epis_diagnosis IS NOT NULL
               AND r_existing_diag.flg_status NOT IN
               (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r, pk_diagnosis.g_ed_flg_status_b)
            THEN
                l_diff_diag_flg_add_prb := r_existing_diag.flg_add_problem;
                l_diff_id_epis_diag     := r_existing_diag.id_epis_diagnosis;
            ELSE
                l_diff_diag_flg_add_prb := NULL;
            END IF;
        ELSE
            l_diff_diag_flg_add_prb := NULL;
        END IF;
    
        g_error := 'SET PROBLEM STATUS BASED ON DIAG STATUS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF (i_epis_diagnosis.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_p) AND
           l_rec_diagnosis.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca) AND
           l_rec_diagnosis.flg_add_problem = pk_alert_constant.g_yes)
           OR nvl(l_diff_diag_flg_add_prb, pk_alert_constant.g_no) = pk_alert_constant.g_yes --ALERT-250280
        THEN
            l_flg_status := table_varchar(pk_diagnosis.g_pat_prob_active);
        ELSIF l_rec_diagnosis.flg_status = pk_diagnosis.g_ed_flg_status_ca
        THEN
            l_flg_status := table_varchar(pk_diagnosis.g_pat_prob_canceled);
            --    l_flg_status := table_varchar(pk_diagnosis.g_pat_prob_excluded);
        END IF;
    
        IF l_rec_diagnosis.dt_initial_diag IS NOT NULL
        THEN
            l_dt_init_diag := pk_date_utils.to_char_insttimezone(i_lang,
                                                                 i_prof,
                                                                 l_rec_diagnosis.dt_initial_diag,
                                                                 l_format_short_dt);
        END IF;
        IF l_flg_status.count > 0
        THEN
            g_error := 'CALL PK_PROBLEMS.CREATE_PAT_PROBLEM_EPIS_DIAG';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_problems.create_pat_problem_epis_diag(i_lang            => i_lang,
                                                            i_epis            => i_epis_diagnosis.id_episode,
                                                            i_pat             => i_epis_diagnosis.id_patient,
                                                            i_prof            => i_prof,
                                                            i_desc_problem    => table_varchar(NULL),
                                                            i_flg_status      => l_flg_status,
                                                            i_notes           => table_varchar(l_rec_diagnosis.notes),
                                                            i_dt_symptoms     => table_varchar(l_dt_init_diag),
                                                            i_diagnosis       => table_number(l_rec_diagnosis.id_diagnosis),
                                                            i_alert_diagnosis => table_number(l_rec_diagnosis.id_alert_diagnosis),
                                                            i_epis_anamnesis  => table_number(NULL),
                                                            i_prof_cat_type   => NULL,
                                                            i_epis_diagnosis  => table_number(coalesce(l_diff_id_epis_diag,
                                                                                                       i_epis_diagnosis.id_epis_diagnosis)),
                                                            i_flg_nature      => table_varchar(NULL),
                                                            o_msg             => l_msg_text,
                                                            o_msg_title       => l_msg_title,
                                                            o_flg_show        => l_flg_show,
                                                            o_button          => l_button,
                                                            o_error           => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        
            IF nvl(l_flg_show, pk_alert_constant.g_no) = pk_alert_constant.g_yes
            THEN
                g_error := 'ADD OUTPUT PARAMETER';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_output_param(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => i_epis_diagnosis.id_episode,
                                 i_epis_diagnosis      => NULL,
                                 i_epis_diagnosis_hist => NULL,
                                 i_dt_record           => i_epis_diagnosis.dt_record,
                                 i_problem_msg         => l_msg_text,
                                 i_problem_msg_title   => l_msg_title,
                                 i_problem_flg_show    => l_flg_show,
                                 i_problem_button      => l_button,
                                 io_params             => io_params);
            END IF;
        
            g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_epis_diagnosis.id_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => NULL,
                                          i_dt_last_interaction => i_epis_diagnosis.dt_record,
                                          i_dt_first_obs        => i_epis_diagnosis.dt_record,
                                          o_error               => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_del_prob_assoc_diag_int;
    --
    /**********************************************************************************************
    * Change the status of a diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids      
    * @param i_epis_diagnosis         Epis diagnosis record       
    * @param i_is_updt_notes          If notes are null is to mantain previous notes? (Doesn't apply to cancel status)
    * @param io_params                Output parameters record
    * @param o_epis_diag_hist         Epis diagnosis history id
    * @param o_error                  Error message
    *
    * @value   i_is_updt_notes        {*} 'Y' Default value. If notes are null them previous notes are mantained.
    *                                 {*} 'N' The input notes are saved even if notes are null.
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/06
    **********************************************************************************************/
    FUNCTION set_epis_diag_status_internal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
        i_is_updt_notes  IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        io_params        IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_epis_diag_hist OUT epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_STATUS_INTERNAL';
        --
        l_epis_diagnosis pk_edis_types.rec_in_epis_diagnosis;
        l_rec_diagnosis  pk_edis_types.rec_in_diagnosis;
        --
        l_flg_status epis_diagnosis.flg_status%TYPE;
        l_flg_type   epis_diagnosis.flg_type%TYPE;
        l_epis_diag  epis_diagnosis.id_epis_diagnosis%TYPE;
        l_id_prof    professional.id_professional%TYPE;
        --
        l_rowids         table_varchar;
        l_rowdiags       table_varchar := table_varchar();
        l_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    
        CURSOR c_epis_diag IS
            SELECT id_epis_diagnosis
              FROM epis_diagnosis
             WHERE id_episode = i_epis_diagnosis.id_episode
               AND flg_status = pk_diagnosis.g_ed_flg_status_b;
    
        CURSOR c_epis_diag_h(l_id_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE) IS
            SELECT flg_status, flg_type, id_professional
              FROM epis_diagnosis_hist
             WHERE id_epis_diagnosis = l_id_epis_diag
               AND id_epis_diagnosis_hist = (SELECT MAX(edh1.id_epis_diagnosis_hist)
                                               FROM epis_diagnosis_hist edh1
                                              WHERE edh1.id_epis_diagnosis = l_id_epis_diag);
        --    
    BEGIN
        l_epis_diagnosis := i_epis_diagnosis;
        l_rec_diagnosis  := l_epis_diagnosis.tbl_diagnosis(1);
    
        IF l_epis_diagnosis.dt_record IS NULL
        THEN
            l_epis_diagnosis.dt_record := current_timestamp;
        END IF;
        --
        IF l_rec_diagnosis.flg_status != pk_diagnosis.g_ed_flg_status_b
        THEN
            -- Actualizar o historico
            g_error := 'CALL TO PK_DIAGNOSIS.SET_EPIS_DIAG_HIST(1)';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT set_epis_diag_hist_internal(i_lang           => i_lang,
                                               i_prof           => i_prof,
                                               i_episode        => l_epis_diagnosis.id_episode,
                                               i_epis_diag      => l_epis_diagnosis.id_epis_diagnosis,
                                               i_sysdate        => l_epis_diagnosis.dt_record,
                                               o_epis_diag_hist => l_epis_diag_hist,
                                               o_error          => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        
            g_error := 'ADD OUTPUT PARAMETER';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            add_output_param(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_episode             => l_epis_diagnosis.id_episode,
                             i_epis_diagnosis      => l_epis_diagnosis.id_epis_diagnosis,
                             i_epis_diagnosis_hist => l_epis_diag_hist,
                             i_dt_record           => l_epis_diagnosis.dt_record,
                             io_params             => io_params);
        END IF;
    
        pk_alertlog.log_info('i_flg_status: ' || l_rec_diagnosis.flg_status);
        IF l_rec_diagnosis.flg_status = pk_diagnosis.g_ed_flg_status_ca
        THEN
            g_error := 'CANCEL EPIS_DIAGNOSIS(1): ' || l_rec_diagnosis.flg_status;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            -- Josrito 04/11/2009 ALERT-53754  When cancelling, do not change the specific notes.
            --
            --when cancelling, don't update the following fields:
            --flg_add_problem         = l_rec_diagnosis.flg_add_problem    
            --dt_initial_diag_in      = l_rec_diagnosis.dt_initial_diag,
            --id_diag_basis_in        = l_rec_diagnosis.id_diag_basis,
            --id_dbasis_inst_owner_in = CASE
            --                              WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
            --                               pk_alert_constant.g_inst_all
            --                              ELSE
            --                               NULL
            --                          END,
            --diag_basis_spec_in      = l_rec_diagnosis.diag_basis_spec,
            --flg_recurrence_in       = l_rec_diagnosis.flg_recurrence,
            --flg_mult_tumors_in      = l_rec_diagnosis.flg_mult_tumors,
            --num_primary_tumors_in   = l_rec_diagnosis.num_primary_tumors,         
            ts_epis_diagnosis.upd(id_epis_diagnosis_in       => l_epis_diagnosis.id_epis_diagnosis,
                                  id_professional_diag_in    => NULL,
                                  id_professional_diag_nin   => FALSE,
                                  dt_epis_diagnosis_tstz_in  => NULL,
                                  dt_epis_diagnosis_tstz_nin => FALSE,
                                  id_prof_confirmed_in       => NULL,
                                  id_prof_confirmed_nin      => FALSE,
                                  dt_confirmed_tstz_in       => NULL,
                                  dt_confirmed_tstz_nin      => FALSE,
                                  id_prof_rulled_out_in      => NULL,
                                  id_prof_rulled_out_nin     => FALSE,
                                  dt_rulled_out_tstz_in      => NULL,
                                  dt_rulled_out_tstz_nin     => FALSE,
                                  id_prof_base_in            => NULL,
                                  id_prof_base_nin           => FALSE,
                                  dt_base_tstz_in            => NULL,
                                  dt_base_tstz_nin           => FALSE,
                                  id_professional_cancel_in  => i_prof.id,
                                  id_professional_cancel_nin => FALSE,
                                  dt_cancel_tstz_in          => l_epis_diagnosis.dt_record,
                                  dt_cancel_tstz_nin         => FALSE,
                                  notes_cancel_in            => l_epis_diagnosis.cancel_notes,
                                  notes_cancel_nin           => FALSE,
                                  id_cancel_reason_in        => l_epis_diagnosis.id_cancel_reason,
                                  id_cancel_reason_nin       => FALSE,
                                  flg_status_in              => l_rec_diagnosis.flg_status,
                                  flg_final_type_in          => l_rec_diagnosis.flg_final_type,
                                  rows_out                   => l_rowdiags);
        ELSIF l_rec_diagnosis.flg_status IN (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_p)
        THEN
            g_error := 'UPDATE EPIS_DIAGNOSIS(7): ' || l_rec_diagnosis.flg_status || ' - UNDER INVESTIGATION/SUSPECTED';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diagnosis.id_epis_diagnosis,
                                  id_professional_diag_in        => i_prof.id,
                                  id_professional_diag_nin       => FALSE,
                                  dt_epis_diagnosis_tstz_in      => l_epis_diagnosis.dt_record,
                                  dt_epis_diagnosis_tstz_nin     => FALSE,
                                  notes_in                       => l_rec_diagnosis.notes,
                                  notes_nin                      => CASE i_is_updt_notes
                                                                        WHEN pk_alert_constant.g_yes THEN
                                                                         FALSE
                                                                        ELSE
                                                                         TRUE
                                                                    END,
                                  id_prof_confirmed_in           => NULL,
                                  id_prof_confirmed_nin          => FALSE,
                                  dt_confirmed_tstz_in           => NULL,
                                  dt_confirmed_tstz_nin          => FALSE,
                                  id_prof_rulled_out_in          => NULL,
                                  id_prof_rulled_out_nin         => FALSE,
                                  dt_rulled_out_tstz_in          => NULL,
                                  dt_rulled_out_tstz_nin         => FALSE,
                                  id_prof_base_in                => NULL,
                                  id_prof_base_nin               => FALSE,
                                  dt_base_tstz_in                => NULL,
                                  dt_base_tstz_nin               => FALSE,
                                  id_professional_cancel_in      => NULL,
                                  id_professional_cancel_nin     => FALSE,
                                  dt_cancel_tstz_in              => NULL,
                                  dt_cancel_tstz_nin             => FALSE,
                                  notes_cancel_in                => NULL,
                                  notes_cancel_nin               => FALSE,
                                  id_cancel_reason_in            => NULL,
                                  id_cancel_reason_nin           => FALSE,
                                  flg_status_in                  => l_rec_diagnosis.flg_status,
                                  flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                  flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                  dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                  dt_initial_diag_nin            => FALSE,
                                  id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                  id_diag_basis_nin              => FALSE,
                                  id_dbasis_inst_owner_in        => CASE
                                                                        WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_dbasis_inst_owner_nin       => FALSE,
                                  diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                  diag_basis_spec_nin            => FALSE,
                                  flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                  flg_recurrence_nin             => FALSE,
                                  flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                  flg_mult_tumors_nin            => FALSE,
                                  num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                  num_primary_tumors_nin         => FALSE,
                                  id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                  id_diagnosis_condition_nin     => FALSE,
                                  id_diagcond_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_diagcond_inst_owner_nin     => FALSE,
                                  id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                  id_sub_analysis_nin            => FALSE,
                                  id_subanaly_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_subanaly_inst_owner_nin     => FALSE,
                                  id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                  id_anatomical_area_nin         => FALSE,
                                  id_anatarea_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatarea_inst_owner_nin     => FALSE,
                                  id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                  id_anatomical_side_nin         => FALSE,
                                  id_anatside_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatside_inst_owner_nin     => FALSE,
                                  id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                  id_lesion_location_nin         => FALSE,
                                  id_lesion_locat_inst_owner_in  => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_locat_inst_owner_nin => FALSE,
                                  id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                  id_lesion_type_nin             => FALSE,
                                  id_lesion_type_inst_owner_in   => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_type_inst_owner_nin  => FALSE,
                                  rank_in                        => CASE
                                                                        WHEN l_epis_diagnosis.flg_type =
                                                                             pk_diagnosis.g_diag_type_d THEN
                                                                         l_rec_diagnosis.rank
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  rank_nin                       => FALSE,
                                  rows_out                       => l_rowdiags);
        ELSIF l_rec_diagnosis.flg_status = pk_diagnosis.g_ed_flg_status_r
        THEN
            g_error := 'UPDATE EPIS_DIAGNOSIS(2): ' || l_rec_diagnosis.flg_status || ' - RULED OUT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diagnosis.id_epis_diagnosis,
                                  id_professional_diag_in        => NULL,
                                  id_professional_diag_nin       => FALSE,
                                  dt_epis_diagnosis_tstz_in      => NULL,
                                  dt_epis_diagnosis_tstz_nin     => FALSE,
                                  notes_in                       => l_rec_diagnosis.notes,
                                  notes_nin                      => CASE i_is_updt_notes
                                                                        WHEN pk_alert_constant.g_yes THEN
                                                                         FALSE
                                                                        ELSE
                                                                         TRUE
                                                                    END,
                                  id_prof_confirmed_in           => NULL,
                                  id_prof_confirmed_nin          => FALSE,
                                  dt_confirmed_tstz_in           => NULL,
                                  dt_confirmed_tstz_nin          => FALSE,
                                  id_prof_rulled_out_in          => i_prof.id,
                                  id_prof_rulled_out_nin         => FALSE,
                                  dt_rulled_out_tstz_in          => l_epis_diagnosis.dt_record,
                                  dt_rulled_out_tstz_nin         => FALSE,
                                  id_prof_base_in                => NULL,
                                  id_prof_base_nin               => FALSE,
                                  dt_base_tstz_in                => NULL,
                                  dt_base_tstz_nin               => FALSE,
                                  id_professional_cancel_in      => NULL,
                                  id_professional_cancel_nin     => FALSE,
                                  dt_cancel_tstz_in              => NULL,
                                  dt_cancel_tstz_nin             => FALSE,
                                  notes_cancel_in                => NULL,
                                  notes_cancel_nin               => FALSE,
                                  id_cancel_reason_in            => NULL,
                                  id_cancel_reason_nin           => FALSE,
                                  flg_status_in                  => l_rec_diagnosis.flg_status,
                                  flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                  flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                  dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                  dt_initial_diag_nin            => FALSE,
                                  id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                  id_diag_basis_nin              => FALSE,
                                  id_dbasis_inst_owner_in        => CASE
                                                                        WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_dbasis_inst_owner_nin       => FALSE,
                                  diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                  diag_basis_spec_nin            => FALSE,
                                  flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                  flg_recurrence_nin             => FALSE,
                                  flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                  flg_mult_tumors_nin            => FALSE,
                                  num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                  num_primary_tumors_nin         => FALSE,
                                  id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                  id_diagnosis_condition_nin     => FALSE,
                                  id_diagcond_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_diagcond_inst_owner_nin     => FALSE,
                                  id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                  id_sub_analysis_nin            => FALSE,
                                  id_subanaly_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_subanaly_inst_owner_nin     => FALSE,
                                  id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                  id_anatomical_area_nin         => FALSE,
                                  id_anatarea_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatarea_inst_owner_nin     => FALSE,
                                  id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                  id_anatomical_side_nin         => FALSE,
                                  id_anatside_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatside_inst_owner_nin     => FALSE,
                                  id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                  id_lesion_location_nin         => FALSE,
                                  id_lesion_locat_inst_owner_in  => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_locat_inst_owner_nin => FALSE,
                                  id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                  id_lesion_type_nin             => FALSE,
                                  id_lesion_type_inst_owner_in   => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_type_inst_owner_nin  => FALSE,
                                  rank_in                        => CASE
                                                                        WHEN l_epis_diagnosis.flg_type =
                                                                             pk_diagnosis.g_diag_type_d THEN
                                                                         l_rec_diagnosis.rank
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  rank_nin                       => FALSE,
                                  rows_out                       => l_rowdiags);
        ELSIF l_rec_diagnosis.flg_status = pk_diagnosis.g_ed_flg_status_co
        THEN
            g_error := 'UPDATE EPIS_DIAGNOSIS(3): ' || l_rec_diagnosis.flg_status || ' - CONFIRMED';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diagnosis.id_epis_diagnosis,
                                  id_professional_diag_in        => NULL,
                                  id_professional_diag_nin       => FALSE,
                                  dt_epis_diagnosis_tstz_in      => NULL,
                                  dt_epis_diagnosis_tstz_nin     => FALSE,
                                  notes_in                       => l_rec_diagnosis.notes,
                                  notes_nin                      => CASE i_is_updt_notes
                                                                        WHEN pk_alert_constant.g_yes THEN
                                                                         FALSE
                                                                        ELSE
                                                                         TRUE
                                                                    END,
                                  id_prof_confirmed_in           => i_prof.id,
                                  id_prof_confirmed_nin          => FALSE,
                                  dt_confirmed_tstz_in           => l_epis_diagnosis.dt_record,
                                  dt_confirmed_tstz_nin          => FALSE,
                                  id_prof_rulled_out_in          => NULL,
                                  id_prof_rulled_out_nin         => FALSE,
                                  dt_rulled_out_tstz_in          => NULL,
                                  dt_rulled_out_tstz_nin         => FALSE,
                                  id_prof_base_in                => NULL,
                                  id_prof_base_nin               => FALSE,
                                  dt_base_tstz_in                => NULL,
                                  dt_base_tstz_nin               => FALSE,
                                  id_professional_cancel_in      => NULL,
                                  id_professional_cancel_nin     => FALSE,
                                  dt_cancel_tstz_in              => NULL,
                                  dt_cancel_tstz_nin             => FALSE,
                                  notes_cancel_in                => NULL,
                                  notes_cancel_nin               => FALSE,
                                  id_cancel_reason_in            => NULL,
                                  id_cancel_reason_nin           => FALSE,
                                  flg_status_in                  => l_rec_diagnosis.flg_status,
                                  flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                  flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                  dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                  dt_initial_diag_nin            => FALSE,
                                  id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                  id_diag_basis_nin              => FALSE,
                                  id_dbasis_inst_owner_in        => CASE
                                                                        WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_dbasis_inst_owner_nin       => FALSE,
                                  diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                  diag_basis_spec_nin            => FALSE,
                                  flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                  flg_recurrence_nin             => FALSE,
                                  flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                  flg_mult_tumors_nin            => FALSE,
                                  num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                  num_primary_tumors_nin         => FALSE,
                                  id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                  id_diagnosis_condition_nin     => FALSE,
                                  id_diagcond_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_diagcond_inst_owner_nin     => FALSE,
                                  id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                  id_sub_analysis_nin            => FALSE,
                                  id_subanaly_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_subanaly_inst_owner_nin     => FALSE,
                                  id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                  id_anatomical_area_nin         => FALSE,
                                  id_anatarea_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatarea_inst_owner_nin     => FALSE,
                                  id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                  id_anatomical_side_nin         => FALSE,
                                  id_anatside_inst_owner_in      => CASE
                                                                        WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_anatside_inst_owner_nin     => FALSE,
                                  id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                  id_lesion_location_nin         => FALSE,
                                  id_lesion_locat_inst_owner_in  => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_locat_inst_owner_nin => FALSE,
                                  id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                  id_lesion_type_nin             => FALSE,
                                  id_lesion_type_inst_owner_in   => CASE
                                                                        WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                         pk_alert_constant.g_inst_all
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  id_lesion_type_inst_owner_nin  => FALSE,
                                  rank_in                        => CASE
                                                                        WHEN l_epis_diagnosis.flg_type =
                                                                             pk_diagnosis.g_diag_type_d THEN
                                                                         l_rec_diagnosis.rank
                                                                        ELSE
                                                                         NULL
                                                                    END,
                                  rank_nin                       => FALSE,
                                  rows_out                       => l_rowdiags);
        ELSIF l_rec_diagnosis.flg_status = pk_diagnosis.g_ed_flg_status_b
        THEN
            g_error := 'UPDATE - PRIMARY DIAGNOSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        
            -- Verify if already exists primary diagnosis in the current episode
            g_error := 'GET CURSOR C_EPIS_DIAG';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            OPEN c_epis_diag;
            FETCH c_epis_diag
                INTO l_epis_diag;
            g_found := c_epis_diag%FOUND;
            CLOSE c_epis_diag;
            --
            IF g_found
            THEN
                g_error := 'THIS EPISODE ALREADY HAS A PRIMARY DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            
                g_error := 'GET CURSOR C_EPIS_DIAG_H';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN c_epis_diag_h(l_epis_diag);
                FETCH c_epis_diag_h
                    INTO l_flg_status, l_flg_type, l_id_prof;
                g_found := c_epis_diag_h%FOUND;
                CLOSE c_epis_diag_h;
            
                --Add to history the existing primary diagnosis
                g_error := 'CALL TO SET_EPIS_DIAG_HIST_INTERNAL(4)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT set_epis_diag_hist_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_episode        => l_epis_diagnosis.id_episode,
                                                   i_epis_diag      => l_epis_diag,
                                                   i_sysdate        => l_epis_diagnosis.dt_record,
                                                   o_epis_diag_hist => l_epis_diag_hist,
                                                   o_error          => o_error)
                THEN
                    RAISE pk_diagnosis.e_call_exception;
                END IF;
                --
                g_error := 'ADD OUTPUT PARAMETER';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_output_param(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => l_epis_diagnosis.id_episode,
                                 i_epis_diagnosis      => l_epis_diag,
                                 i_epis_diagnosis_hist => l_epis_diag_hist,
                                 i_dt_record           => l_epis_diagnosis.dt_record,
                                 io_params             => io_params);
                --
                g_error := 'UPDATE EPIS_DIAGNOSIS(4): ' || l_flg_status || ' - EXISTING PRIMARY DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diag,
                                      id_professional_diag_in        => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_d THEN
                                                                             l_id_prof
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_professional_diag_nin       => FALSE,
                                      dt_epis_diagnosis_tstz_in      => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_d THEN
                                                                             l_epis_diagnosis.dt_record
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      dt_epis_diagnosis_tstz_nin     => FALSE,
                                      notes_in                       => l_rec_diagnosis.notes,
                                      notes_nin                      => CASE i_is_updt_notes
                                                                            WHEN pk_alert_constant.g_yes THEN
                                                                             FALSE
                                                                            ELSE
                                                                             TRUE
                                                                        END,
                                      id_prof_confirmed_in           => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_co THEN
                                                                             l_id_prof
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_prof_confirmed_nin          => FALSE,
                                      dt_confirmed_tstz_in           => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_co THEN
                                                                             l_epis_diagnosis.dt_record
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      dt_confirmed_tstz_nin          => FALSE,
                                      id_prof_rulled_out_in          => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_r THEN
                                                                             l_id_prof
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_prof_rulled_out_nin         => FALSE,
                                      dt_rulled_out_tstz_in          => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_r THEN
                                                                             l_epis_diagnosis.dt_record
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      dt_rulled_out_tstz_nin         => FALSE,
                                      id_prof_base_in                => NULL,
                                      id_prof_base_nin               => FALSE,
                                      dt_base_tstz_in                => NULL,
                                      dt_base_tstz_nin               => FALSE,
                                      id_professional_cancel_in      => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_ca THEN
                                                                             l_id_prof
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_professional_cancel_nin     => FALSE,
                                      dt_cancel_tstz_in              => CASE l_flg_status
                                                                            WHEN pk_diagnosis.g_ed_flg_status_ca THEN
                                                                             l_epis_diagnosis.dt_record
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      dt_cancel_tstz_nin             => FALSE,
                                      flg_type_in                    => l_flg_type,
                                      flg_status_in                  => l_flg_status,
                                      flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                      flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                      dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                      dt_initial_diag_nin            => FALSE,
                                      id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                      id_diag_basis_nin              => FALSE,
                                      id_dbasis_inst_owner_in        => CASE
                                                                            WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_dbasis_inst_owner_nin       => FALSE,
                                      diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                      diag_basis_spec_nin            => FALSE,
                                      flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                      flg_recurrence_nin             => FALSE,
                                      flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                      flg_mult_tumors_nin            => FALSE,
                                      num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                      num_primary_tumors_nin         => FALSE,
                                      id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                      id_diagnosis_condition_nin     => FALSE,
                                      id_diagcond_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_diagcond_inst_owner_nin     => FALSE,
                                      id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                      id_sub_analysis_nin            => FALSE,
                                      id_subanaly_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_subanaly_inst_owner_nin     => FALSE,
                                      id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                      id_anatomical_area_nin         => FALSE,
                                      id_anatarea_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatarea_inst_owner_nin     => FALSE,
                                      id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                      id_anatomical_side_nin         => FALSE,
                                      id_anatside_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatside_inst_owner_nin     => FALSE,
                                      id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                      id_lesion_location_nin         => FALSE,
                                      id_lesion_locat_inst_owner_in  => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_locat_inst_owner_nin => FALSE,
                                      id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                      id_lesion_type_nin             => FALSE,
                                      id_lesion_type_inst_owner_in   => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_type_inst_owner_nin  => FALSE,
                                      rank_in                        => CASE
                                                                            WHEN l_epis_diagnosis.flg_type =
                                                                                 pk_diagnosis.g_diag_type_d THEN
                                                                             l_rec_diagnosis.rank
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      rank_nin                       => FALSE,
                                      rows_out                       => l_rowdiags);
                --
                -- Add to history the new primary diagnosis
                g_error := 'CALL TO SET_EPIS_DIAG_HIST_INTERNAL(5)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT set_epis_diag_hist_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_episode        => l_epis_diagnosis.id_episode,
                                                   i_epis_diag      => l_epis_diagnosis.id_epis_diagnosis,
                                                   i_sysdate        => l_epis_diagnosis.dt_record,
                                                   o_epis_diag_hist => l_epis_diag_hist,
                                                   o_error          => o_error)
                THEN
                    RAISE pk_diagnosis.e_call_exception;
                END IF;
            
                g_error := 'ADD OUTPUT PARAMETER';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_output_param(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => l_epis_diagnosis.id_episode,
                                 i_epis_diagnosis      => l_epis_diagnosis.id_epis_diagnosis,
                                 i_epis_diagnosis_hist => l_epis_diag_hist,
                                 i_dt_record           => l_epis_diagnosis.dt_record,
                                 io_params             => io_params);
                --
                g_error := 'UPDATE EPIS_DIAGNOSIS(5): ' || l_rec_diagnosis.flg_status || ' - PRIMARY DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diagnosis.id_epis_diagnosis,
                                      id_professional_diag_in        => NULL,
                                      id_professional_diag_nin       => FALSE,
                                      dt_epis_diagnosis_tstz_in      => NULL,
                                      dt_epis_diagnosis_tstz_nin     => FALSE,
                                      id_prof_confirmed_in           => NULL,
                                      id_prof_confirmed_nin          => FALSE,
                                      dt_confirmed_tstz_in           => NULL,
                                      dt_confirmed_tstz_nin          => FALSE,
                                      id_prof_rulled_out_in          => NULL,
                                      id_prof_rulled_out_nin         => FALSE,
                                      dt_rulled_out_tstz_in          => NULL,
                                      dt_rulled_out_tstz_nin         => FALSE,
                                      id_prof_base_in                => i_prof.id,
                                      id_prof_base_nin               => FALSE,
                                      dt_base_tstz_in                => l_epis_diagnosis.dt_record,
                                      dt_base_tstz_nin               => FALSE,
                                      id_professional_cancel_in      => NULL,
                                      id_professional_cancel_nin     => FALSE,
                                      dt_cancel_tstz_in              => NULL,
                                      dt_cancel_tstz_nin             => FALSE,
                                      notes_cancel_in                => NULL,
                                      notes_cancel_nin               => FALSE,
                                      id_cancel_reason_in            => NULL,
                                      id_cancel_reason_nin           => FALSE,
                                      flg_type_in                    => pk_diagnosis.g_diag_type_b,
                                      flg_status_in                  => l_rec_diagnosis.flg_status,
                                      flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                      flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                      dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                      dt_initial_diag_nin            => FALSE,
                                      id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                      id_diag_basis_nin              => FALSE,
                                      id_dbasis_inst_owner_in        => CASE
                                                                            WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_dbasis_inst_owner_nin       => FALSE,
                                      diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                      diag_basis_spec_nin            => FALSE,
                                      flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                      flg_recurrence_nin             => FALSE,
                                      flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                      flg_mult_tumors_nin            => FALSE,
                                      num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                      num_primary_tumors_nin         => FALSE,
                                      id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                      id_diagnosis_condition_nin     => FALSE,
                                      id_diagcond_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_diagcond_inst_owner_nin     => FALSE,
                                      id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                      id_sub_analysis_nin            => FALSE,
                                      id_subanaly_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_subanaly_inst_owner_nin     => FALSE,
                                      id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                      id_anatomical_area_nin         => FALSE,
                                      id_anatarea_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatarea_inst_owner_nin     => FALSE,
                                      id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                      id_anatomical_side_nin         => FALSE,
                                      id_anatside_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatside_inst_owner_nin     => FALSE,
                                      id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                      id_lesion_location_nin         => FALSE,
                                      id_lesion_locat_inst_owner_in  => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_locat_inst_owner_nin => FALSE,
                                      id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                      id_lesion_type_nin             => FALSE,
                                      id_lesion_type_inst_owner_in   => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_type_inst_owner_nin  => FALSE,
                                      rank_in                        => CASE
                                                                            WHEN l_epis_diagnosis.flg_type =
                                                                                 pk_diagnosis.g_diag_type_d THEN
                                                                             l_rec_diagnosis.rank
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      rank_nin                       => FALSE,
                                      rows_out                       => l_rowdiags);
            ELSE
                g_error := 'THIS EPISODE DOESN''T HAVE A PRIMARY DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            
                g_error := 'CALL TO SET_EPIS_DIAG_HIST_INTERNAL(6)';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT set_epis_diag_hist_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_episode        => l_epis_diagnosis.id_episode,
                                                   i_epis_diag      => l_epis_diagnosis.id_epis_diagnosis,
                                                   i_sysdate        => l_epis_diagnosis.dt_record,
                                                   o_epis_diag_hist => l_epis_diag_hist,
                                                   o_error          => o_error)
                THEN
                    RAISE pk_diagnosis.e_call_exception;
                END IF;
            
                g_error := 'ADD OUTPUT PARAMETER';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                add_output_param(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => l_epis_diagnosis.id_episode,
                                 i_epis_diagnosis      => l_epis_diagnosis.id_epis_diagnosis,
                                 i_epis_diagnosis_hist => l_epis_diag_hist,
                                 i_dt_record           => l_epis_diagnosis.dt_record,
                                 io_params             => io_params);
            
                g_error := 'UPDATE EPIS_DIAGNOSIS(6): ' || l_rec_diagnosis.flg_status || ' - PRIMARY DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                ts_epis_diagnosis.upd(id_epis_diagnosis_in           => l_epis_diagnosis.id_epis_diagnosis,
                                      id_professional_diag_in        => NULL,
                                      id_professional_diag_nin       => FALSE,
                                      dt_epis_diagnosis_tstz_in      => NULL,
                                      dt_epis_diagnosis_tstz_nin     => FALSE,
                                      id_prof_confirmed_in           => NULL,
                                      id_prof_confirmed_nin          => FALSE,
                                      dt_confirmed_tstz_in           => NULL,
                                      dt_confirmed_tstz_nin          => FALSE,
                                      id_prof_rulled_out_in          => NULL,
                                      id_prof_rulled_out_nin         => FALSE,
                                      dt_rulled_out_tstz_in          => NULL,
                                      dt_rulled_out_tstz_nin         => FALSE,
                                      id_prof_base_in                => i_prof.id,
                                      id_prof_base_nin               => FALSE,
                                      dt_base_tstz_in                => l_epis_diagnosis.dt_record,
                                      dt_base_tstz_nin               => FALSE,
                                      id_professional_cancel_in      => NULL,
                                      id_professional_cancel_nin     => FALSE,
                                      dt_cancel_tstz_in              => NULL,
                                      dt_cancel_tstz_nin             => FALSE,
                                      notes_cancel_in                => NULL,
                                      notes_cancel_nin               => FALSE,
                                      id_cancel_reason_in            => NULL,
                                      id_cancel_reason_nin           => FALSE,
                                      flg_type_in                    => pk_diagnosis.g_diag_type_b,
                                      flg_status_in                  => l_rec_diagnosis.flg_status,
                                      flg_final_type_in              => l_rec_diagnosis.flg_final_type,
                                      flg_add_problem_in             => l_rec_diagnosis.flg_add_problem,
                                      dt_initial_diag_in             => l_rec_diagnosis.dt_initial_diag,
                                      dt_initial_diag_nin            => FALSE,
                                      id_diag_basis_in               => l_rec_diagnosis.id_diag_basis,
                                      id_diag_basis_nin              => FALSE,
                                      id_dbasis_inst_owner_in        => CASE
                                                                            WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_dbasis_inst_owner_nin       => FALSE,
                                      diag_basis_spec_in             => l_rec_diagnosis.diag_basis_spec,
                                      diag_basis_spec_nin            => FALSE,
                                      flg_recurrence_in              => l_rec_diagnosis.flg_recurrence,
                                      flg_recurrence_nin             => FALSE,
                                      flg_mult_tumors_in             => l_rec_diagnosis.flg_mult_tumors,
                                      flg_mult_tumors_nin            => FALSE,
                                      num_primary_tumors_in          => l_rec_diagnosis.num_primary_tumors,
                                      num_primary_tumors_nin         => FALSE,
                                      id_diagnosis_condition_in      => l_rec_diagnosis.id_diagnosis_condition,
                                      id_diagnosis_condition_nin     => FALSE,
                                      id_diagcond_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_diagcond_inst_owner_nin     => FALSE,
                                      id_sub_analysis_in             => l_rec_diagnosis.id_sub_analysis,
                                      id_sub_analysis_nin            => FALSE,
                                      id_subanaly_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_subanaly_inst_owner_nin     => FALSE,
                                      id_anatomical_area_in          => l_rec_diagnosis.id_anatomical_area,
                                      id_anatomical_area_nin         => FALSE,
                                      id_anatarea_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatarea_inst_owner_nin     => FALSE,
                                      id_anatomical_side_in          => l_rec_diagnosis.id_anatomical_side,
                                      id_anatomical_side_nin         => FALSE,
                                      id_anatside_inst_owner_in      => CASE
                                                                            WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_anatside_inst_owner_nin     => FALSE,
                                      id_lesion_location_in          => l_rec_diagnosis.id_lesion_location,
                                      id_lesion_location_nin         => FALSE,
                                      id_lesion_locat_inst_owner_in  => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_locat_inst_owner_nin => FALSE,
                                      id_lesion_type_in              => l_rec_diagnosis.id_lesion_type,
                                      id_lesion_type_nin             => FALSE,
                                      id_lesion_type_inst_owner_in   => CASE
                                                                            WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                             pk_alert_constant.g_inst_all
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      id_lesion_type_inst_owner_nin  => FALSE,
                                      rank_in                        => CASE
                                                                            WHEN l_epis_diagnosis.flg_type =
                                                                                 pk_diagnosis.g_diag_type_d THEN
                                                                             l_rec_diagnosis.rank
                                                                            ELSE
                                                                             NULL
                                                                        END,
                                      rank_nin                       => FALSE,
                                      rows_out                       => l_rowdiags);
            END IF;
            --
            -- Caso o epis seja um epis de bloco operat, existe um registo na tabela SCHEDULE_SR
            -- O diagnco base deve ser actualizado nessa tabela.
            g_error := 'UPDATE SCHEDULE_SR';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_rowids := table_varchar();
            ts_schedule_sr.upd(id_diagnosis_in  => l_rec_diagnosis.id_diagnosis,
                               id_diagnosis_nin => FALSE,
                               where_in         => 'id_episode = ' || l_epis_diagnosis.id_episode,
                               rows_out         => l_rowids);
        
            t_data_gov_mnt.process_update(i_lang         => i_lang,
                                          i_prof         => i_prof,
                                          i_table_name   => 'SCHEDULE_SR',
                                          i_rowids       => l_rowids,
                                          o_error        => o_error,
                                          i_list_columns => table_varchar('ID_DIAGNOSIS'));
        
        END IF;
    
        ----------------------------------------------------
        -- process the diagnosis rank (internaly it verifies if it has something to do)
        manage_epis_diagnosis_rank(i_lang              => i_lang,
                                   i_prof              => i_prof,
                                   i_id_epis_diagnosis => l_epis_diagnosis.id_epis_diagnosis,
                                   i_id_episode        => l_epis_diagnosis.id_episode,
                                   i_dt_record         => l_epis_diagnosis.dt_record);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_DIAGNOSIS',
                                      i_rowids     => l_rowdiags,
                                      o_error      => o_error);
    
        --            
        g_error := 'CALL TO SET_FIRST_OBS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                      i_id_episode          => l_epis_diagnosis.id_episode,
                                      i_pat                 => NULL,
                                      i_prof                => i_prof,
                                      i_prof_cat_type       => NULL,
                                      i_dt_last_interaction => l_epis_diagnosis.dt_record,
                                      i_dt_first_obs        => l_epis_diagnosis.dt_record,
                                      o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        o_epis_diag_hist := l_epis_diag_hist;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diag_status_internal;
    --
    /**********************************************************************************************
    * Set all existing episode diagnosis to secundary because the current one was set has primary
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_current_epis_diag      Epis diag that was set has primary
    * @param i_epis_diagnosis         Epis diagnosis record    
    * @param io_params                Output parameters record
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/06
    **********************************************************************************************/
    PROCEDURE set_prim_diag_to_secundary
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_current_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diagnosis    IN pk_edis_types.rec_in_epis_diagnosis,
        io_params           IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error             OUT t_error_out
    ) IS
        l_proc_name CONSTANT VARCHAR2(30) := 'SET_PRIM_DIAG_TO_SECUNDARY';
        --
        CURSOR c_epis_diag_d
        (
            i_episode   IN episode.id_episode%TYPE,
            i_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE
        ) IS
            SELECT ed.id_epis_diagnosis,
                   ed.flg_status,
                   ed.flg_type,
                   ed.flg_add_problem,
                   ed.notes,
                   ed.id_diagnosis_condition,
                   ed.id_sub_analysis,
                   ed.id_anatomical_area,
                   ed.id_anatomical_side,
                   ed.id_lesion_location,
                   ed.id_lesion_type
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis <> i_epis_diag
               AND ed.id_episode = i_episode
               AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
               AND ed.flg_final_type = pk_diagnosis.g_flg_final_type_p;
    
        r_epis_diag_d    c_epis_diag_d%ROWTYPE;
        l_epis_diagnosis pk_edis_types.rec_in_epis_diagnosis;
        l_rec_diagnosis  pk_edis_types.rec_in_diagnosis;
        l_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    BEGIN
        IF i_epis_diagnosis.flg_val_single_prim_diag = pk_alert_constant.g_yes
           AND i_epis_diagnosis.tbl_diagnosis(1).flg_final_type = pk_diagnosis.g_flg_final_type_p
        THEN
            l_epis_diagnosis                  := i_epis_diagnosis;
            l_epis_diagnosis.id_cancel_reason := NULL;
        
            --We only update one diagnosis at a time so the diagnosis table has only one diagnosis
            l_rec_diagnosis                := i_epis_diagnosis.tbl_diagnosis(1);
            l_rec_diagnosis.flg_final_type := pk_diagnosis.g_flg_final_type_s;
            l_rec_diagnosis.notes          := NULL;
        
            g_error := 'LOOP THROUGH ALL EPISODE DIAGNOSIS WHICH ARE PRIMARY DIAGNOSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
            FOR r_epis_diag_d IN c_epis_diag_d(i_episode   => i_epis_diagnosis.id_episode,
                                               i_epis_diag => i_current_epis_diag)
            LOOP
                l_rec_diagnosis.flg_status      := r_epis_diag_d.flg_status;
                l_rec_diagnosis.flg_add_problem := r_epis_diag_d.flg_add_problem;
                l_rec_diagnosis.notes           := r_epis_diag_d.notes;
            
                l_rec_diagnosis.id_diagnosis_condition := r_epis_diag_d.id_diagnosis_condition;
                l_rec_diagnosis.id_sub_analysis        := r_epis_diag_d.id_sub_analysis;
                l_rec_diagnosis.id_anatomical_area     := r_epis_diag_d.id_anatomical_area;
                l_rec_diagnosis.id_anatomical_side     := r_epis_diag_d.id_anatomical_side;
                l_rec_diagnosis.id_lesion_location     := r_epis_diag_d.id_lesion_location;
                l_rec_diagnosis.id_lesion_type         := r_epis_diag_d.id_lesion_type;
            
                l_epis_diagnosis.id_epis_diagnosis := r_epis_diag_d.id_epis_diagnosis;
                l_epis_diagnosis.flg_type          := r_epis_diag_d.flg_type;
                l_epis_diagnosis.tbl_diagnosis     := pk_edis_types.table_in_diagnosis(l_rec_diagnosis);
            
                g_error := 'CALL SET_EPIS_DIAG_STATUS_INTERNAL - ID_EPIS_DIAG: ' || l_epis_diagnosis.id_epis_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_proc_name);
                IF NOT set_epis_diag_status_internal(i_lang           => i_lang,
                                                     i_prof           => i_prof,
                                                     i_epis_diagnosis => l_epis_diagnosis,
                                                     io_params        => io_params,
                                                     o_epis_diag_hist => l_epis_diag_hist,
                                                     o_error          => o_error)
                THEN
                    RAISE pk_diagnosis.e_call_exception;
                END IF;
            END LOOP;
        END IF;
    END set_prim_diag_to_secundary;
    --
    FUNCTION update_diagnosis
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_epis_diag            IN pk_edis_types.rec_in_epis_diagnosis,
        i_tbl_tumors           IN pk_edis_types.table_in_tumors,
        i_tbl_staging          IN pk_edis_types.table_in_diag_staging,
        i_is_updt_notes        IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        io_params              IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        i_process_complication IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_inner_func_name CONSTANT VARCHAR2(30) := 'UPDATE_DIAGNOSIS';
        --
        l_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
        l_tbl_staging    pk_edis_types.table_in_diag_staging := i_tbl_staging;
    
        l_enable_complication VARCHAR2(100 CHAR) := nvl(pk_sysconfig.get_config('DIAGNOSIS_ENABLE_COMPLICATION', i_prof),
                                                        pk_alert_constant.g_no);
    
    BEGIN
        g_error := 'CALL TO PK_DIAGNOSIS.SET_EPIS_DIAG_STATUS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
        IF NOT set_epis_diag_status_internal(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_epis_diagnosis => i_epis_diag,
                                             i_is_updt_notes  => i_is_updt_notes,
                                             io_params        => io_params,
                                             o_epis_diag_hist => l_epis_diag_hist,
                                             o_error          => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        g_error := 'CALL SET_EPIS_DIAG_TUMORS_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
        IF NOT set_epis_diag_tumors_internal(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_epis_diagnosis      => i_epis_diag.id_epis_diagnosis,
                                             i_epis_diagnosis_hist => l_epis_diag_hist,
                                             i_tbl_tumors          => i_tbl_tumors,
                                             i_dt_record           => i_epis_diag.dt_record,
                                             io_params             => io_params,
                                             o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        IF i_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_diag
           AND l_tbl_staging IS NOT NULL
           AND l_tbl_staging.count = 1
        THEN
            --When canceling diagnosis also cancel current staging
            l_tbl_staging(1).id_cancel_reason := i_epis_diag.id_cancel_reason;
            l_tbl_staging(1).cancel_notes := i_epis_diag.cancel_notes;
        END IF;
    
        g_error := 'CALL SET_EPIS_DIAG_STAG_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
        IF NOT set_epis_diag_stag_internal(i_lang                => i_lang,
                                           i_prof                => i_prof,
                                           i_epis_diagnosis      => i_epis_diag.id_epis_diagnosis,
                                           i_epis_diagnosis_hist => l_epis_diag_hist,
                                           i_tbl_diag_stag       => l_tbl_staging,
                                           i_dt_record           => i_epis_diag.dt_record,
                                           io_params             => io_params,
                                           o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        IF i_process_complication = pk_alert_constant.g_yes
           AND l_enable_complication = pk_alert_constant.g_yes
        THEN
            g_error := 'CALL PK_COMPLICATION.SET_EPIS_DIAG_COMPLICATIONS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
            IF NOT pk_complication.set_epis_diag_complications(i_lang                   => i_lang,
                                                               i_prof                   => i_prof,
                                                               i_epis_diagnosis         => i_epis_diag,
                                                               i_id_epis_diagnosis      => i_epis_diag.id_epis_diagnosis,
                                                               i_id_epis_diagnosis_hist => l_epis_diag_hist,
                                                               i_dt_record              => i_epis_diag.dt_record,
                                                               io_params                => io_params,
                                                               o_error                  => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN pk_diagnosis.e_call_exception THEN
            RETURN FALSE;
    END update_diagnosis;
    --
    /**********************************************************************************************
    * Edit a episode diagnosis
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis         Epis diagnosis record
    * @param i_is_updt_notes          If notes are null is to mantain previous notes? (Doesn't apply to cancel status)     
    * @param i_is_sync_diags          Is to syncronize diagnoses?
    * @param o_params                 Output parameters record
    * @param o_error                  Error message
    *
    * @value   i_is_updt_notes        {*} 'Y' Default value. If notes are null them previous notes are mantained.
    *                                 {*} 'N' The input notes are saved even if notes are null.
    *
    * @value   i_is_sync_diags        {*} 'Y' Call set_visit_diagnosis to syncronize all diagnoses between visit episodes
    *                                 {*} 'N' Don't syncronize diags.
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/06
    **********************************************************************************************/
    FUNCTION set_epis_diagnosis_internal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
        i_is_updt_notes  IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        i_is_sync_diags  IN VARCHAR2 DEFAULT pk_alert_constant.g_yes,
        io_params        IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAGNOSIS_INTERNAL';
        --
        l_rec_in_epis_diag pk_edis_types.rec_in_epis_diagnosis;
        l_rec_in_diag      pk_edis_types.rec_in_diagnosis;
        --
        l_epis_ges_msg          epis_ges_msg.id_epis_ges_msg%TYPE;
        l_current_staging_basis epis_diag_stag.id_staging_basis%TYPE;
        l_epis_diagnosis_hist   epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
        --
        l_allow_diagnoses_same_icd   sys_config.value%TYPE;
        l_terminology_allow_same_icd VARCHAR2(1) := NULL;
        --
        PROCEDURE reset_values IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'RESET_VALUES';
        BEGIN
            g_error := 'RESET INPUT VAR';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            l_rec_in_epis_diag := i_epis_diagnosis;
        END reset_values;
    
        PROCEDURE handle_default_update(i_rec_epis_diag IN pk_edis_types.rec_in_epis_diagnosis) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'HANDLE_DEFAULT_UPDATE';
            --
            l_rec_epis_diag   pk_edis_types.rec_in_epis_diagnosis;
            l_rec_diagnosis   pk_edis_types.rec_in_diagnosis;
            r_existing_diag   c_existing_diag%ROWTYPE;
            l_flg_cancer_diag VARCHAR2(1);
        BEGIN
            l_rec_epis_diag := i_rec_epis_diag;
            l_rec_diagnosis := l_rec_epis_diag.tbl_diagnosis(1);
        
            l_flg_cancer_diag := pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_concept_type => NULL,
                                                                     i_diagnosis    => l_rec_diagnosis.id_diagnosis);
        
            IF l_rec_epis_diag.flg_type = pk_diagnosis.g_diag_type_p
            THEN
                l_allow_diagnoses_same_icd := pk_sysconfig.get_config('ALLOW_DIFF_DIAGNOSIS_SAME_ICD', i_prof);
                <<update_working_diagnosis>>
                BEGIN
                    l_rec_epis_diag.tbl_diagnosis(1).flg_final_type := NULL;
                    l_rec_diagnosis.flg_final_type := NULL;
                
                    g_error := 'UPDATE WORKING DIAGNOSIS (' || l_rec_epis_diag.flg_type || ')';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                    IF NOT update_diagnosis(i_lang          => i_lang,
                                            i_prof          => i_prof,
                                            i_epis_diag     => l_rec_epis_diag,
                                            i_tbl_tumors    => l_rec_diagnosis.tbl_tumors,
                                            i_tbl_staging   => l_rec_diagnosis.tbl_diag_staging,
                                            i_is_updt_notes => i_is_updt_notes,
                                            io_params       => io_params,
                                            o_error         => o_error)
                    THEN
                        RAISE pk_diagnosis.e_call_exception;
                    END IF;
                
                    g_error := 'GET FINAL DIAGNOSIS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                
                    l_terminology_allow_same_icd := pk_ts1_api.get_allow_duplicate(i_lang               => i_lang,
                                                                                   i_id_concept_term    => l_rec_in_diag.id_alert_diagnosis,
                                                                                   i_id_concept_version => l_rec_diagnosis.id_diagnosis,
                                                                                   i_id_task_type       => pk_alert_constant.g_task_diagnosis,
                                                                                   i_id_institution     => i_prof.institution,
                                                                                   i_id_software        => i_prof.software);
                
                    OPEN c_existing_diag(i_lang                => i_lang,
                                         i_prof                => i_prof,
                                         i_episode             => l_rec_epis_diag.id_episode,
                                         i_diagnosis           => l_rec_diagnosis.id_diagnosis,
                                         i_alert_diagnosis     => CASE
                                                                      WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                           AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                           pk_alert_constant.g_yes THEN
                                                                       l_rec_in_diag.id_alert_diagnosis
                                                                      ELSE
                                                                       NULL
                                                                  END,
                                         i_flg_type            => pk_diagnosis.g_diag_type_d,
                                         i_desc_diag           => l_rec_diagnosis.desc_diagnosis,
                                         i_flg_cancer_diag     => l_flg_cancer_diag,
                                         i_diagnosis_condition => l_rec_diagnosis.id_diagnosis_condition,
                                         i_sub_analysis        => l_rec_diagnosis.id_sub_analysis,
                                         i_anatomical_area     => l_rec_diagnosis.id_anatomical_area,
                                         i_anatomical_side     => l_rec_diagnosis.id_anatomical_side);
                    FETCH c_existing_diag
                        INTO r_existing_diag;
                    CLOSE c_existing_diag;
                
                    --If final diagnosis exists and is in a valide state update it
                    IF r_existing_diag.id_epis_diagnosis IS NOT NULL
                       AND
                       r_existing_diag.flg_status NOT IN
                       (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r, pk_diagnosis.g_ed_flg_status_b)
                    THEN
                    
                        l_rec_epis_diag.id_epis_diagnosis := r_existing_diag.id_epis_diagnosis;
                        l_rec_epis_diag.flg_type := pk_diagnosis.g_diag_type_d;
                        l_rec_epis_diag.tbl_diagnosis(1).flg_final_type := r_existing_diag.flg_final_type;
                        l_rec_diagnosis.flg_final_type := r_existing_diag.flg_final_type;
                    
                        g_error := 'UPDATE FINAL DIAGNOSIS (' || l_rec_epis_diag.flg_type || ')';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_inner_proc_name);
                        IF NOT update_diagnosis(i_lang          => i_lang,
                                                i_prof          => i_prof,
                                                i_epis_diag     => l_rec_epis_diag,
                                                i_tbl_tumors    => l_rec_diagnosis.tbl_tumors,
                                                i_tbl_staging   => l_rec_diagnosis.tbl_diag_staging,
                                                i_is_updt_notes => i_is_updt_notes,
                                                io_params       => io_params,
                                                -- if updating diag of a different type, no need to update complications
                                                i_process_complication => pk_alert_constant.g_no,
                                                o_error                => o_error)
                        THEN
                            RAISE pk_diagnosis.e_call_exception;
                        END IF;
                    END IF;
                END update_working_diagnosis;
            ELSIF l_rec_epis_diag.flg_type = pk_diagnosis.g_diag_type_d
            THEN
                l_allow_diagnoses_same_icd := pk_sysconfig.get_config('ALLOW_DISCH_DIAGNOSIS_SAME_ICD', i_prof);
                <<update_final_diagnosis>>
                BEGIN
                    g_error := 'UPDATE FINAL DIAGNOSIS (' || l_rec_epis_diag.flg_type || ')';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                    IF NOT update_diagnosis(i_lang          => i_lang,
                                            i_prof          => i_prof,
                                            i_epis_diag     => l_rec_epis_diag,
                                            i_tbl_tumors    => l_rec_diagnosis.tbl_tumors,
                                            i_tbl_staging   => l_rec_diagnosis.tbl_diag_staging,
                                            i_is_updt_notes => i_is_updt_notes,
                                            io_params       => io_params,
                                            o_error         => o_error)
                    THEN
                        RAISE pk_diagnosis.e_call_exception;
                    END IF;
                
                    l_terminology_allow_same_icd := pk_ts1_api.get_allow_duplicate(i_lang               => i_lang,
                                                                                   i_id_concept_term    => l_rec_in_diag.id_alert_diagnosis,
                                                                                   i_id_concept_version => l_rec_diagnosis.id_diagnosis,
                                                                                   i_id_task_type       => pk_alert_constant.g_task_diagnosis,
                                                                                   i_id_institution     => i_prof.institution,
                                                                                   i_id_software        => i_prof.software);
                
                    IF l_rec_diagnosis.flg_status NOT IN
                       (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_b)
                    THEN
                        g_error := 'GET WORKING DIAGNOSIS';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_inner_proc_name);
                        OPEN c_existing_diag(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_episode             => l_rec_epis_diag.id_episode,
                                             i_diagnosis           => l_rec_diagnosis.id_diagnosis,
                                             i_alert_diagnosis     => CASE
                                                                          WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                               AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                               pk_alert_constant.g_yes THEN
                                                                           l_rec_in_diag.id_alert_diagnosis
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                             i_flg_type            => pk_diagnosis.g_diag_type_p,
                                             i_desc_diag           => l_rec_diagnosis.desc_diagnosis,
                                             i_flg_cancer_diag     => l_flg_cancer_diag,
                                             i_diagnosis_condition => l_rec_diagnosis.id_diagnosis_condition,
                                             i_sub_analysis        => l_rec_diagnosis.id_sub_analysis,
                                             i_anatomical_area     => l_rec_diagnosis.id_anatomical_area,
                                             i_anatomical_side     => l_rec_diagnosis.id_anatomical_side);
                        FETCH c_existing_diag
                            INTO r_existing_diag;
                        CLOSE c_existing_diag;
                    
                        --If WORKING diagnosis exists update it
                        IF r_existing_diag.id_epis_diagnosis IS NOT NULL
                           AND r_existing_diag.flg_status NOT IN
                           (pk_diagnosis.g_ed_flg_status_ca,
                                pk_diagnosis.g_ed_flg_status_r,
                                pk_diagnosis.g_ed_flg_status_b)
                        THEN
                            l_rec_epis_diag.id_epis_diagnosis := r_existing_diag.id_epis_diagnosis;
                            l_rec_epis_diag.flg_type := pk_diagnosis.g_diag_type_p;
                            l_rec_epis_diag.tbl_diagnosis(1).flg_final_type := NULL;
                            l_rec_diagnosis.flg_final_type := NULL;
                        
                            g_error := 'UPDATE WORKING DIAGNOSIS (' || l_rec_epis_diag.flg_type || ')';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_inner_proc_name);
                            IF NOT update_diagnosis(i_lang          => i_lang,
                                                    i_prof          => i_prof,
                                                    i_epis_diag     => l_rec_epis_diag,
                                                    i_tbl_tumors    => l_rec_diagnosis.tbl_tumors,
                                                    i_tbl_staging   => l_rec_diagnosis.tbl_diag_staging,
                                                    i_is_updt_notes => i_is_updt_notes,
                                                    io_params       => io_params,
                                                    -- if updating diag of a different type, no need to update complications
                                                    i_process_complication => pk_alert_constant.g_no,
                                                    o_error                => o_error)
                            THEN
                                RAISE pk_diagnosis.e_call_exception;
                            END IF;
                        END IF;
                    END IF;
                
                    --RESET TO INPUT VALUES
                    l_rec_epis_diag := i_rec_epis_diag;
                    l_rec_diagnosis := l_rec_epis_diag.tbl_diagnosis(1);
                
                    -- only one diagnosis should be primary
                    g_error := 'CALL SET_PRIM_DIAG_TO_SECUNDARY';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                    set_prim_diag_to_secundary(i_lang              => i_lang,
                                               i_prof              => i_prof,
                                               i_current_epis_diag => l_rec_epis_diag.id_epis_diagnosis,
                                               i_epis_diagnosis    => l_rec_epis_diag,
                                               io_params           => io_params,
                                               o_error             => o_error);
                END update_final_diagnosis;
            END IF;
        
            g_error := 'CALL TO CREATE_DEL_PROB_ASSOC_DIAG_INT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            IF NOT create_del_prob_assoc_diag_int(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_epis_diagnosis => l_rec_epis_diag,
                                                  io_params        => io_params,
                                                  o_error          => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END handle_default_update;
    BEGIN
        l_rec_in_epis_diag := i_epis_diagnosis;
        l_rec_in_diag      := l_rec_in_epis_diag.tbl_diagnosis(1);
        --
        IF l_rec_in_epis_diag.flg_edit_mode IN
           (pk_diagnosis_core.g_diag_edit_mode_retreatment,
            pk_diagnosis_core.g_diag_edit_mode_edit,
            pk_diagnosis_core.g_diag_edit_mode_status,
            pk_diagnosis_core.g_diag_edit_mode_type,
            pk_diagnosis_core.g_diag_cancel_diag)
        THEN
            IF l_rec_in_epis_diag.flg_edit_mode != pk_diagnosis_core.g_diag_edit_mode_retreatment
               OR (l_rec_in_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_retreatment AND
               compare_with_svd_stag_basis(i_lang          => i_lang,
                                               i_prof          => i_prof,
                                               i_episode       => l_rec_in_epis_diag.id_episode,
                                               i_diagnosis     => l_rec_in_diag.id_diagnosis,
                                               i_staging_basis => l_rec_in_diag.tbl_diag_staging(1).id_staging_basis) IN
               (g_staging_basis_same_stage, g_staging_basis_forward_stage))
            THEN
                g_error := 'CALL DEFAULT UPDATE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                handle_default_update(i_rec_epis_diag => l_rec_in_epis_diag);
            
                --ASantos 21-11-2011
                --ALERT-195554 - Chile | Ability to interface information regarding management of GES
                g_error := 'CALL PK_EPIS_ER_LAW_API.CREATE_EPIS_GES_MSG';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT pk_epis_er_law_api.create_epis_ges_msg(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_episode               => l_rec_in_epis_diag.id_episode,
                                                              i_pat_history_diagnosis => NULL,
                                                              i_epis_diagnosis        => l_rec_in_epis_diag.id_epis_diagnosis,
                                                              i_flg_origin            => CASE l_rec_in_epis_diag.flg_type
                                                                                             WHEN pk_diagnosis.g_diag_type_p THEN
                                                                                              pk_epis_er_law_core.g_ges_flg_orig_d
                                                                                             WHEN pk_diagnosis.g_diag_type_d THEN
                                                                                              pk_epis_er_law_core.g_ges_flg_orig_f
                                                                                             ELSE
                                                                                              NULL
                                                                                         END,
                                                              o_epis_ges_msg          => l_epis_ges_msg,
                                                              o_error                 => o_error)
                THEN
                    RAISE pk_epis_er_law_core.g_ges_exception;
                END IF;
            ELSE
                --Staging base is prior to the current saved stage so we are adding it directly into history
            
                g_error := 'INSERT DIAGNOSIS STAGING DIRECTLY IN HISTORY';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                insert_diagnosis_hist(i_lang          => i_lang,
                                      i_prof          => i_prof,
                                      i_rec_epis_diag => l_rec_in_epis_diag,
                                      io_params       => io_params,
                                      o_error         => o_error); --(i_rec_epis_diag => l_rec_in_epis_diag);
            END IF;
        ELSIF l_rec_in_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_staging
        THEN
            --Staging base (PAST EDITION) - We are adding the staging basis directly into history
        
            g_error := 'INSERT DIAGNOSIS STAGING DIRECTLY IN HISTORY';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            insert_diagnosis_hist(i_lang          => i_lang,
                                  i_prof          => i_prof,
                                  i_rec_epis_diag => l_rec_in_epis_diag,
                                  io_params       => io_params,
                                  o_error         => o_error);
            --insert_diagnosis_hist(i_rec_epis_diag => l_rec_in_epis_diag);
        ELSIF l_rec_in_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
              AND l_rec_in_epis_diag.id_epis_diagnosis_hist IS NULL
        THEN
            --Cancel current staging - So we must cancel it and set the last cronological staging as the current one
        
            IF l_rec_in_diag.tbl_diag_staging IS NOT NULL
               AND l_rec_in_diag.tbl_diag_staging.count = 1
            THEN
                l_current_staging_basis := l_rec_in_diag.tbl_diag_staging(1).id_staging_basis;
            ELSE
                l_current_staging_basis := NULL;
            END IF;
        
            IF l_current_staging_basis IS NOT NULL
            THEN
                g_error := '1 - GET THE LAST ACTIVE CRONOLOGICAL STAGING IN HISTORY';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                l_epis_diagnosis_hist := get_last_active_staging(i_lang                  => i_lang,
                                                                 i_prof                  => i_prof,
                                                                 i_current_staging_basis => l_current_staging_basis,
                                                                 i_episode               => l_rec_in_epis_diag.id_episode,
                                                                 i_diagnosis             => l_rec_in_diag.id_diagnosis,
                                                                 i_epis_diagnosis        => l_rec_in_epis_diag.id_epis_diagnosis,
                                                                 i_flg_type              => l_rec_in_epis_diag.flg_type,
                                                                 i_dt_record             => l_rec_in_epis_diag.dt_record);
            
                IF l_epis_diagnosis_hist IS NOT NULL --this is a double check, the first check was on set_epis_diagnosis function - fill_missing_data_edt inner function
                THEN
                    g_error := '2 - CANCEL CURRENT STAGING BY CALLING THE DEFAULT UPDATE';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    handle_default_update(i_rec_epis_diag => l_rec_in_epis_diag);
                
                    g_error := '3 - GET SAVED HISTORY DATA OF THE LAST ACTIVE CRONOLOGICAL STAGING';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    l_rec_in_epis_diag := get_epis_diag_rec(i_lang           => i_lang,
                                                            i_prof           => i_prof,
                                                            i_epis_diag_hist => l_epis_diagnosis_hist);
                
                    l_rec_in_epis_diag.id_epis_diagnosis_hist := NULL;
                    l_rec_in_epis_diag.flg_edit_mode          := pk_diagnosis_core.g_diag_cancel_staging;
                
                    g_error := '4 - SET THE PREVIOUS STAGING AS THE CURRENT STAGING';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    handle_default_update(i_rec_epis_diag => l_rec_in_epis_diag);
                END IF;
            
                --RESET TO INPUT VALUES
                reset_values();
            END IF;
        ELSIF l_rec_in_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
              AND l_rec_in_epis_diag.id_epis_diagnosis_hist IS NOT NULL
        THEN
            --Cancel staging in history tables
        
            g_error := 'CANCEL STAGING DIRECTLY IN HISTORY';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            insert_diagnosis_hist(i_lang          => i_lang,
                                  i_prof          => i_prof,
                                  i_rec_epis_diag => l_rec_in_epis_diag,
                                  io_params       => io_params,
                                  o_error         => o_error);
            --insert_diagnosis_hist(i_rec_epis_diag => l_rec_in_epis_diag);
        END IF;
    
        IF i_is_sync_diags = pk_alert_constant.g_yes
        THEN
            g_error := 'CALL PK_DIAGNOSIS_CORE.SET_VISIT_DIAGNOSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_diagnosis_core.set_visit_diagnosis(i_lang               => i_lang,
                                                         i_prof               => i_prof,
                                                         i_episode            => l_rec_in_epis_diag.id_episode,
                                                         i_tbl_epis_diagnosis => io_params,
                                                         o_error              => o_error)
            THEN
                g_error := 'SET_VISIT_DIAGNOSIS ERROR';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN pk_epis_er_law_core.g_ges_exception THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_epis_diagnosis_internal;
    --
    /**********************************************************************************************
    * Register a new set of diagnoses
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis         Epis diagnosis record
    * @param o_params                 Output parameters record
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.2.1 
    * @since                          2012/03/06
    **********************************************************************************************/
    FUNCTION create_diagnosis_internal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
        io_params        IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CREATE_DIAGNOSIS_INTERNAL';
        --
        l_rec_in_epis_diag      pk_edis_types.rec_in_epis_diagnosis;
        l_rec_in_diag           pk_edis_types.rec_in_diagnosis;
        l_tbl_id_epis_diagnosis table_number;
        l_new_epis_diag_rows    table_varchar := table_varchar();
        --
        l_flg_cancer_diag VARCHAR2(1);
        --
        l_ex_create_past_staging EXCEPTION;
        --        
        l_allow_diagnoses_same_icd sys_config.value%TYPE;
        --Configs to control if a final diagnosis can be transfered to working diagnosis
        l_allow_diff_diag_same_icd   sys_config.value%TYPE := pk_sysconfig.get_config('ALLOW_DIFF_DIAGNOSIS_SAME_ICD',
                                                                                      i_prof);
        l_terminology_allow_same_icd VARCHAR2(1) := NULL;
        --
        CURSOR c_mdm_coding IS
            SELECT d.mdm_coding
              FROM epis_diagnosis ed, diagnosis d
             WHERE ed.id_episode = i_epis_diagnosis.id_episode
               AND ed.id_diagnosis = d.id_diagnosis;
    
        r_mdm_coding c_mdm_coding%ROWTYPE;
    
        r_existing_diag c_existing_diag%ROWTYPE;
    
        r_existing_working_diag c_existing_diag%ROWTYPE;
    
        r_existing_final_diag c_existing_diag%ROWTYPE;
    
        r_existing_diff_diag c_existing_diag%ROWTYPE;
    
        l_epis_ges_msg epis_ges_msg.id_epis_ges_msg%TYPE;
    
        --
        PROCEDURE reset_values(i_index IN PLS_INTEGER) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'RESET_VALUES';
            --
            l_r_existing_diag         c_existing_diag%ROWTYPE;
            l_r_existing_working_diag c_existing_diag%ROWTYPE;
            l_r_existing_final_diag   c_existing_diag%ROWTYPE;
            l_r_existing_diff_diag    c_existing_diag%ROWTYPE;
        BEGIN
            g_error := 'RESET INPUT VARS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            l_rec_in_diag := i_epis_diagnosis.tbl_diagnosis(i_index);
        
            l_rec_in_epis_diag.id_epis_diagnosis := i_epis_diagnosis.id_epis_diagnosis;
            l_rec_in_epis_diag.flg_type          := i_epis_diagnosis.flg_type;
            l_rec_in_epis_diag.tbl_diagnosis     := pk_edis_types.table_in_diagnosis(l_rec_in_diag);
        
            r_existing_diag         := l_r_existing_diag;
            r_existing_working_diag := l_r_existing_working_diag;
            r_existing_diff_diag    := l_r_existing_diff_diag;
        END reset_values;
    BEGIN
        g_error := 'INITIALIZE VAR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_rec_in_epis_diag := i_epis_diagnosis;
        --
        g_error := 'OPEN C_MDM_CODING';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_mdm_coding;
        FETCH c_mdm_coding
            INTO r_mdm_coding;
        CLOSE c_mdm_coding;
        --   
        FOR i IN i_epis_diagnosis.tbl_diagnosis.first .. i_epis_diagnosis.tbl_diagnosis.last
        LOOP
            --RESET TO INPUT VALUES
            reset_values(i_index => i);
        
            g_error := 'CALL PK_DIAGNOSIS_CORE.CHECK_DIAG_CANCER';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_flg_cancer_diag := pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_concept_type => NULL,
                                                                     i_diagnosis    => l_rec_in_diag.id_diagnosis);
        
            --Verify if the current diag already exists, and if so retrives it's ID
            g_error := 'OPEN C_EXISTING_DIAG - L_REC_DIAG.DESC_DIAGNOSIS: ' || l_rec_in_diag.desc_diagnosis;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --
            IF i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_p
            THEN
                l_allow_diagnoses_same_icd := pk_sysconfig.get_config('ALLOW_DIFF_DIAGNOSIS_SAME_ICD', i_prof);
            ELSIF i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_d
            THEN
                l_allow_diagnoses_same_icd := pk_sysconfig.get_config('ALLOW_DISCH_DIAGNOSIS_SAME_ICD', i_prof);
            ELSE
                l_allow_diagnoses_same_icd := pk_alert_constant.g_no;
            END IF;
        
            l_terminology_allow_same_icd := pk_ts1_api.get_allow_duplicate(i_lang               => i_lang,
                                                                           i_id_concept_term    => l_rec_in_diag.id_alert_diagnosis,
                                                                           i_id_concept_version => l_rec_in_diag.id_diagnosis,
                                                                           i_id_task_type       => pk_alert_constant.g_task_diagnosis,
                                                                           i_id_institution     => i_prof.institution,
                                                                           i_id_software        => i_prof.software);
            --
            OPEN c_existing_diag(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => l_rec_in_epis_diag.id_episode,
                                 i_diagnosis           => l_rec_in_diag.id_diagnosis,
                                 i_alert_diagnosis     => CASE
                                                              WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                   AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                   pk_alert_constant.g_yes THEN
                                                               l_rec_in_diag.id_alert_diagnosis
                                                              ELSE
                                                               NULL
                                                          END,
                                 i_flg_type            => i_epis_diagnosis.flg_type,
                                 i_desc_diag           => l_rec_in_diag.desc_diagnosis,
                                 i_flg_cancer_diag     => l_flg_cancer_diag,
                                 i_diagnosis_condition => l_rec_in_diag.id_diagnosis_condition,
                                 i_sub_analysis        => l_rec_in_diag.id_sub_analysis,
                                 i_anatomical_area     => l_rec_in_diag.id_anatomical_area,
                                 i_anatomical_side     => l_rec_in_diag.id_anatomical_side);
            FETCH c_existing_diag
                INTO r_existing_diag;
            CLOSE c_existing_diag;
        
            OPEN c_existing_diag(i_lang                => i_lang,
                                 i_prof                => i_prof,
                                 i_episode             => l_rec_in_epis_diag.id_episode,
                                 i_diagnosis           => l_rec_in_diag.id_diagnosis,
                                 i_alert_diagnosis     => CASE
                                                              WHEN l_allow_diff_diag_same_icd = pk_alert_constant.g_yes
                                                                   AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                   pk_alert_constant.g_yes THEN
                                                               l_rec_in_diag.id_alert_diagnosis
                                                              ELSE
                                                               NULL
                                                          END,
                                 i_flg_type            => pk_diagnosis.g_diag_type_p,
                                 i_desc_diag           => l_rec_in_diag.desc_diagnosis,
                                 i_flg_cancer_diag     => l_flg_cancer_diag,
                                 i_diagnosis_condition => l_rec_in_diag.id_diagnosis_condition,
                                 i_sub_analysis        => l_rec_in_diag.id_sub_analysis,
                                 i_anatomical_area     => l_rec_in_diag.id_anatomical_area,
                                 i_anatomical_side     => l_rec_in_diag.id_anatomical_side);
            FETCH c_existing_diag
                INTO r_existing_diff_diag;
            CLOSE c_existing_diag;
        
            IF l_rec_in_diag.tbl_diag_staging IS NULL
               OR l_rec_in_diag.tbl_diag_staging.count = 0
               OR compare_with_svd_stag_basis(i_lang          => i_lang,
                                              i_prof          => i_prof,
                                              i_episode       => l_rec_in_epis_diag.id_episode,
                                              i_diagnosis     => l_rec_in_diag.id_diagnosis,
                                              i_staging_basis => l_rec_in_diag.tbl_diag_staging(1).id_staging_basis) IN
               (g_staging_basis_same_stage, g_staging_basis_forward_stage)
            THEN
                IF r_existing_diag.id_epis_diagnosis IS NULL
                THEN
                    g_error := 'CALL INSERT_DIAGNOSIS (1)';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    insert_diagnosis(i_lang                => i_lang,
                                     i_prof                => i_prof,
                                     i_rec_epis_diag       => l_rec_in_epis_diag,
                                     io_new_epis_diag_rows => l_new_epis_diag_rows,
                                     o_epis_diagnosis      => l_rec_in_epis_diag.id_epis_diagnosis,
                                     io_params             => io_params,
                                     o_error               => o_error);
                
                    /*i_rec_epis_diag       => l_rec_in_epis_diag,
                    o_epis_diagnosis      => l_rec_in_epis_diag.id_epis_diagnosis,
                    io_new_epis_diag_rows => l_new_epis_diag_rows);*/
                
                    g_error := 'CALL TO CREATE_DEL_PROB_ASSOC_DIAG_INT';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT create_del_prob_assoc_diag_int(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_epis_diagnosis => l_rec_in_epis_diag,
                                                          io_params        => io_params,
                                                          o_error          => o_error)
                    THEN
                        RAISE pk_diagnosis.e_call_exception;
                    END IF;
                    --
                    IF i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_d
                    THEN
                        -- only one diagnosis should be primary
                        g_error := 'CALL SET_PRIM_DIAG_TO_SECUNDARY';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        set_prim_diag_to_secundary(i_lang              => i_lang,
                                                   i_prof              => i_prof,
                                                   i_current_epis_diag => l_rec_in_epis_diag.id_epis_diagnosis,
                                                   i_epis_diagnosis    => l_rec_in_epis_diag,
                                                   io_params           => io_params,
                                                   o_error             => o_error);
                        -- 
                        OPEN c_existing_diag(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_episode             => l_rec_in_epis_diag.id_episode,
                                             i_diagnosis           => l_rec_in_diag.id_diagnosis,
                                             i_alert_diagnosis     => CASE
                                                                          WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                               AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                               pk_alert_constant.g_yes THEN
                                                                           l_rec_in_diag.id_alert_diagnosis
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                             i_flg_type            => pk_diagnosis.g_diag_type_p,
                                             i_desc_diag           => l_rec_in_diag.desc_diagnosis,
                                             i_flg_cancer_diag     => l_flg_cancer_diag,
                                             i_diagnosis_condition => l_rec_in_diag.id_diagnosis_condition,
                                             i_sub_analysis        => l_rec_in_diag.id_sub_analysis,
                                             i_anatomical_area     => l_rec_in_diag.id_anatomical_area,
                                             i_anatomical_side     => l_rec_in_diag.id_anatomical_side);
                        FETCH c_existing_diag
                            INTO r_existing_working_diag;
                        CLOSE c_existing_diag;
                        --
                        IF r_existing_working_diag.id_epis_diagnosis IS NULL
                           AND i_epis_diagnosis.flg_transf_final = pk_alert_constant.g_yes
                           AND (r_existing_diff_diag.id_epis_diagnosis IS NULL OR
                           (r_existing_diff_diag.id_epis_diagnosis IS NOT NULL AND
                           l_allow_diff_diag_same_icd = pk_alert_constant.g_yes AND
                           nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) = pk_alert_constant.g_yes))
                        THEN
                            l_rec_in_epis_diag.id_epis_diagnosis := NULL;
                            l_rec_in_epis_diag.flg_type := pk_diagnosis.g_diag_type_p;
                            l_rec_in_epis_diag.tbl_diagnosis(1).flg_final_type := NULL;
                            l_rec_in_diag.flg_final_type := NULL;
                        
                            --Working diagnosis doesn't exist so insert it
                            g_error := 'INSERT NEW WORKING DIAGNOSIS';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                        
                            insert_diagnosis(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_rec_epis_diag       => l_rec_in_epis_diag,
                                             io_new_epis_diag_rows => l_new_epis_diag_rows,
                                             o_epis_diagnosis      => l_rec_in_epis_diag.id_epis_diagnosis,
                                             io_params             => io_params,
                                             o_error               => o_error);
                        
                            /*i_rec_epis_diag       => l_rec_in_epis_diag,
                            o_epis_diagnosis      => l_rec_in_epis_diag.id_epis_diagnosis,
                            io_new_epis_diag_rows => l_new_epis_diag_rows);*/
                        
                        ELSIF r_existing_working_diag.id_epis_diagnosis IS NOT NULL
                              AND r_existing_working_diag.flg_status NOT IN
                              (pk_diagnosis.g_ed_flg_status_ca,
                                   pk_diagnosis.g_ed_flg_status_r,
                                   pk_diagnosis.g_ed_flg_status_b)
                        THEN
                            l_rec_in_epis_diag.id_epis_diagnosis := r_existing_working_diag.id_epis_diagnosis;
                            l_rec_in_epis_diag.flg_type := pk_diagnosis.g_diag_type_p;
                            l_rec_in_epis_diag.tbl_diagnosis(1).flg_final_type := NULL;
                            l_rec_in_diag.flg_final_type := NULL;
                        
                            g_error := 'UPDATE THE STATUS OF WORKING DIAGNOSIS - CALL SET_EPIS_DIAG_STATUS_INTERNAL';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            IF NOT update_diagnosis(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_epis_diag   => l_rec_in_epis_diag,
                                                    i_tbl_tumors  => l_rec_in_diag.tbl_tumors,
                                                    i_tbl_staging => l_rec_in_diag.tbl_diag_staging,
                                                    io_params     => io_params,
                                                    -- if updating diag of a different type, no need to update complications
                                                    i_process_complication => pk_alert_constant.g_no,
                                                    o_error                => o_error)
                            THEN
                                RAISE pk_diagnosis.e_call_exception;
                            END IF;
                        END IF;
                    ELSIF i_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_p
                    THEN
                        g_error := 'GET CURSOR C_EPIS_DIAG';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        OPEN c_existing_diag(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_episode             => l_rec_in_epis_diag.id_episode,
                                             i_diagnosis           => l_rec_in_diag.id_diagnosis,
                                             i_alert_diagnosis     => CASE
                                                                          WHEN l_allow_diagnoses_same_icd = pk_alert_constant.g_yes
                                                                               AND nvl(l_terminology_allow_same_icd, pk_alert_constant.g_yes) =
                                                                               pk_alert_constant.g_yes THEN
                                                                           l_rec_in_diag.id_alert_diagnosis
                                                                          ELSE
                                                                           NULL
                                                                      END,
                                             i_flg_type            => pk_diagnosis.g_diag_type_d,
                                             i_desc_diag           => l_rec_in_diag.desc_diagnosis,
                                             i_flg_cancer_diag     => l_flg_cancer_diag,
                                             i_diagnosis_condition => l_rec_in_diag.id_diagnosis_condition,
                                             i_sub_analysis        => l_rec_in_diag.id_sub_analysis,
                                             i_anatomical_area     => l_rec_in_diag.id_anatomical_area,
                                             i_anatomical_side     => l_rec_in_diag.id_anatomical_side);
                        FETCH c_existing_diag
                            INTO r_existing_final_diag;
                        CLOSE c_existing_diag;
                        --
                        IF r_existing_final_diag.id_epis_diagnosis IS NOT NULL
                           AND r_existing_final_diag.flg_status NOT IN
                           (pk_diagnosis.g_ed_flg_status_ca,
                                pk_diagnosis.g_ed_flg_status_r,
                                pk_diagnosis.g_ed_flg_status_b)
                        THEN
                            l_rec_in_epis_diag.id_epis_diagnosis := r_existing_final_diag.id_epis_diagnosis;
                            l_rec_in_epis_diag.flg_type          := pk_diagnosis.g_diag_type_d;
                        
                            l_rec_in_diag.flg_final_type := r_existing_final_diag.flg_final_type;
                        
                            l_rec_in_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_in_diag);
                        
                            -- Actualizao do diagnco final
                            g_error := 'CALL TO PK_DIAGNOSIS.SET_EPIS_DIAG_STATUS';
                            pk_alertlog.log_debug(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            IF NOT update_diagnosis(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_epis_diag   => l_rec_in_epis_diag,
                                                    i_tbl_tumors  => l_rec_in_diag.tbl_tumors,
                                                    i_tbl_staging => l_rec_in_diag.tbl_diag_staging,
                                                    io_params     => io_params,
                                                    -- if updating diag of a different type, no need to update complications
                                                    i_process_complication => pk_alert_constant.g_no,
                                                    o_error                => o_error)
                            THEN
                                RAISE pk_diagnosis.e_call_exception;
                            END IF;
                        END IF;
                    END IF;
                    --
                    g_error := 'CALL SET_COD_ELEM_MDM_NO_COMMIT';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    IF NOT pk_medical_decision.set_cod_elem_mdm_no_commit(i_lang              => i_lang,
                                                                          i_prof              => i_prof,
                                                                          i_epis              => i_epis_diagnosis.id_episode,
                                                                          i_id_mdm_evaluation => r_mdm_coding.mdm_coding,
                                                                          o_error             => o_error)
                    THEN
                        RAISE pk_diagnosis.e_call_exception;
                    END IF;
                
                ELSE
                    --Existing epis_diagnosis so we must do one of two things:
                    --  1 - if it's a past date then insert directly into history
                    --  2 - This call was wrongly made. What was really intended to do, was calling set_epis_diagnosis
                
                    IF l_rec_in_epis_diag.dt_record < r_existing_diag.dt_diagnosis
                    THEN
                        --Add a new data to history
                    
                        l_rec_in_epis_diag.id_epis_diagnosis := r_existing_diag.id_epis_diagnosis;
                    
                        g_error := 'INSERT DIAGNOSIS IN HISTORY (1)';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        insert_diagnosis_hist(i_lang          => i_lang,
                                              i_prof          => i_prof,
                                              i_rec_epis_diag => l_rec_in_epis_diag,
                                              io_params       => io_params,
                                              o_error         => o_error);
                        --insert_diagnosis_hist(i_rec_epis_diag => l_rec_in_epis_diag);
                    ELSE
                        --Call SET_EPIS_DIAGNOSIS_INTERNAL to update the existing record
                    
                        l_rec_in_epis_diag.id_epis_diagnosis := r_existing_diag.id_epis_diagnosis;
                        l_rec_in_epis_diag.flg_edit_mode     := pk_diagnosis_core.g_diag_edit_mode_edit;
                    
                        g_error := 'CALL TO SET_EPIS_DIAGNOSIS_INTERNAL';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_epis_diagnosis => l_rec_in_epis_diag,
                                                           i_is_updt_notes  => pk_alert_constant.g_yes,
                                                           i_is_sync_diags  => pk_alert_constant.g_no,
                                                           io_params        => io_params,
                                                           o_error          => o_error)
                        THEN
                            RAISE pk_diagnosis.e_call_exception;
                        END IF;
                    END IF;
                END IF;
            ELSE
                -- If code arrives here it means that we are inserting a prior staging basis, so we must save data in history
            
                IF r_existing_diag.id_epis_diagnosis IS NOT NULL
                THEN
                    l_rec_in_epis_diag.id_epis_diagnosis := r_existing_diag.id_epis_diagnosis;
                
                    g_error := 'INSERT DIAGNOSIS IN HISTORY (2)';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    insert_diagnosis_hist(i_lang          => i_lang,
                                          i_prof          => i_prof,
                                          i_rec_epis_diag => l_rec_in_epis_diag,
                                          io_params       => io_params,
                                          o_error         => o_error);
                    --insert_diagnosis_hist(i_rec_epis_diag => l_rec_in_epis_diag);
                ELSE
                    --this means that current staging is a prior staging but the most current staging is saved in another episode
                    --so the code shouldn't reach here, if it does we must correct the creation form logic
                    g_error := 'TRYING TO INSERT PRIOR STAGING WHEN THE MOST RECENT STAGING IS IN ANOTHER EPISODE';
                    pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    RAISE l_ex_create_past_staging;
                END IF;
            END IF;
        END LOOP;
    
        t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_DIAGNOSIS',
                                      i_rowids     => l_new_epis_diag_rows,
                                      o_error      => o_error);
        --
    
        IF l_new_epis_diag_rows IS NOT NULL
           AND l_new_epis_diag_rows.count > 0
        THEN
            SELECT ed.id_epis_diagnosis
              BULK COLLECT
              INTO l_tbl_id_epis_diagnosis
              FROM epis_diagnosis ed
             WHERE ROWID IN (SELECT column_value
                               FROM TABLE(l_new_epis_diag_rows));
        END IF;
    
        --The following code is only meant to run if there was made any insertion
        IF l_tbl_id_epis_diagnosis IS NOT NULL
           AND l_tbl_id_epis_diagnosis.count > 0
        THEN
            --ASantos 21-11-20011
            --ALERT-195554 - Chile | Ability to interface information regarding management of GES
            g_error := 'CALL PK_EPIS_ER_LAW_API.CREATE_EPIS_GES_MSG';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR i IN l_tbl_id_epis_diagnosis.first .. l_tbl_id_epis_diagnosis.last
            LOOP
                IF NOT pk_epis_er_law_api.create_epis_ges_msg(i_lang                  => i_lang,
                                                              i_prof                  => i_prof,
                                                              i_episode               => i_epis_diagnosis.id_episode,
                                                              i_pat_history_diagnosis => NULL,
                                                              i_epis_diagnosis        => l_tbl_id_epis_diagnosis(i),
                                                              i_flg_origin            => CASE i_epis_diagnosis.flg_type
                                                                                             WHEN pk_diagnosis.g_diag_type_p THEN
                                                                                              pk_epis_er_law_core.g_ges_flg_orig_d
                                                                                             WHEN pk_diagnosis.g_diag_type_d THEN
                                                                                              pk_epis_er_law_core.g_ges_flg_orig_f
                                                                                             ELSE
                                                                                              NULL
                                                                                         END,
                                                              o_epis_ges_msg          => l_epis_ges_msg,
                                                              o_error                 => o_error)
                THEN
                    RAISE pk_epis_er_law_core.g_ges_exception;
                END IF;
            END LOOP;
            --END ALERT-195554
        END IF;
    
        IF l_rec_in_epis_diag.dt_record >= nvl(r_existing_diag.dt_diagnosis, l_rec_in_epis_diag.dt_record)
        THEN
            g_error := 'CALL PK_VISIT.SET_FIRST_OBS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_epis_diagnosis.id_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => i_epis_diagnosis.prof_cat_type,
                                          i_dt_last_interaction => l_rec_in_epis_diag.dt_record,
                                          i_dt_first_obs        => l_rec_in_epis_diag.dt_record,
                                          o_error               => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        
            g_error := 'CALL PK_DIAGNOSIS_CORE.SET_VISIT_DIAGNOSIS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF NOT pk_diagnosis_core.set_visit_diagnosis(i_lang               => i_lang,
                                                         i_prof               => i_prof,
                                                         i_episode            => i_epis_diagnosis.id_episode,
                                                         i_tbl_epis_diagnosis => io_params,
                                                         o_error              => o_error)
            THEN
                g_error := 'SET_VISIT_DIAGNOSIS ERROR';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN pk_epis_er_law_core.g_ges_exception THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_diagnosis_internal;
    --
    FUNCTION cancel_epis_diagnosis
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnosis IN pk_edis_types.rec_in_epis_diagnosis,
        io_params        IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_EPIS_DIAGNOSIS';
        --
        l_rec_epis_diag pk_edis_types.rec_in_epis_diagnosis;
        l_rec_diagnosis pk_edis_types.rec_in_diagnosis;
        --
        l_exception EXCEPTION;
        --
        PROCEDURE reset_vars IS
        BEGIN
            l_rec_epis_diag := i_epis_diagnosis;
            l_rec_diagnosis := l_rec_epis_diag.tbl_diagnosis(1);
        END reset_vars;
        --
        FUNCTION get_tbl_active_stagings
        (
            i_episode       IN episode.id_episode%TYPE,
            i_epis_diag     IN epis_diagnosis.id_epis_diagnosis%TYPE,
            i_curr_staging  IN epis_diag_stag.id_staging_basis%TYPE,
            i_curr_num_stag IN epis_diag_stag.num_staging_basis%TYPE
        ) RETURN table_number IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_TBL_ACTIVE_STAGINGS';
            --
            l_diag_stagings pk_edis_types.tab_epis_diag_staging;
            l_ret           table_number := table_number();
        BEGIN
            g_error := 'CALL GET_EPIS_DIAG_REC';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
            l_diag_stagings := get_epis_diag_stagings(i_lang           => i_lang,
                                                      i_prof           => i_prof,
                                                      i_episode        => i_episode,
                                                      i_flg_call       => pk_diagnosis_core.g_diag_call_viewer,
                                                      i_epis_diag      => i_epis_diag,
                                                      i_epis_diag_hist => NULL,
                                                      i_flg_ret_type   => 'I');
        
            IF l_diag_stagings IS NOT NULL
               AND l_diag_stagings.count > 0
            THEN
                g_error := 'LOOP THROUGH EPIC DIAG STAGINGS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
                FOR i IN l_diag_stagings.first .. l_diag_stagings.last
                LOOP
                    IF i_curr_staging != l_diag_stagings(i).id_staging_basis
                       OR (i_curr_staging = l_diag_stagings(i).id_staging_basis AND
                       i_curr_num_stag != l_diag_stagings(i).num_staging_basis)
                    THEN
                        l_ret.extend;
                        l_ret(l_ret.count) := l_diag_stagings(i).id_epis_diagnosis_hist;
                    END IF;
                END LOOP;
            END IF;
        
            RETURN l_ret;
        END get_tbl_active_stagings;
    
        PROCEDURE cancel_active_stagings
        (
            i_episode       IN episode.id_episode%TYPE,
            i_epis_diag     IN epis_diagnosis.id_epis_diagnosis%TYPE,
            i_curr_staging  IN epis_diag_stag.id_staging_basis%TYPE,
            i_curr_num_stag IN epis_diag_stag.num_staging_basis%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'CANCEL_ACTIVE_STAGINGS';
            --
            l_rec_ed              pk_edis_types.rec_in_epis_diagnosis;
            l_tbl_active_stagings table_number;
        BEGIN
            g_error := 'CALL GET_TBL_ACTIVE_STAGINGS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            l_tbl_active_stagings := get_tbl_active_stagings(i_episode       => i_episode,
                                                             i_epis_diag     => i_epis_diag,
                                                             i_curr_staging  => i_curr_staging,
                                                             i_curr_num_stag => i_curr_num_stag);
        
            FOR r_act_stag IN (SELECT column_value id_epis_diagnosis_hist
                                 FROM TABLE(l_tbl_active_stagings))
            LOOP
                g_error := 'CALL GET_EPIS_DIAG_REC';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                l_rec_ed := get_epis_diag_rec(i_lang           => i_lang,
                                              i_prof           => i_prof,
                                              i_epis_diag      => i_epis_diag,
                                              i_epis_diag_hist => r_act_stag.id_epis_diagnosis_hist);
            
                l_rec_ed.flg_edit_mode := pk_diagnosis_core.g_diag_cancel_staging;
                l_rec_ed.tbl_diagnosis(1).tbl_diag_staging(1).id_cancel_reason := i_epis_diagnosis.id_cancel_reason;
                l_rec_ed.tbl_diagnosis(1).tbl_diag_staging(1).cancel_notes := i_epis_diagnosis.cancel_notes;
            
                g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL - CANCEL ACTIVE STAGING';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_epis_diagnosis => l_rec_ed,
                                                   io_params        => io_params,
                                                   o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        END cancel_active_stagings;
    BEGIN
        reset_vars;
    
        g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_epis_diagnosis => l_rec_epis_diag,
                                           io_params        => io_params,
                                           o_error          => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        IF l_rec_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_diag
           AND l_rec_epis_diag.id_epis_diagnosis_hist IS NULL
           AND l_rec_diagnosis.tbl_diag_staging IS NOT NULL
           AND l_rec_diagnosis.tbl_diag_staging.count = 1
        THEN
            g_error := 'CALL CANCEL_ACTIVE_STAGINGS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            cancel_active_stagings(i_episode       => l_rec_epis_diag.id_episode,
                                   i_epis_diag     => l_rec_epis_diag.id_epis_diagnosis,
                                   i_curr_staging  => l_rec_diagnosis.tbl_diag_staging(1).id_staging_basis,
                                   i_curr_num_stag => l_rec_diagnosis.tbl_diag_staging(1).num_staging_basis);
        END IF;
    
        reset_vars;
    
        --Verify if diferential diagnosis is also to be cancelled
        IF l_rec_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_diag
           AND l_rec_epis_diag.flg_type = pk_diagnosis.g_diag_type_d
           AND nvl(l_rec_epis_diag.flg_cancel_diff_diag, pk_alert_constant.g_no) = pk_alert_constant.g_yes
        THEN
            BEGIN
                g_error := 'GET ID_EPIS_DIAG OF DIFERENCIAL DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error);
                SELECT ed.id_epis_diagnosis, ed.flg_add_problem
                  INTO l_rec_epis_diag.id_epis_diagnosis, l_rec_diagnosis.flg_add_problem
                  FROM epis_diagnosis ed
                 WHERE ed.id_episode = l_rec_epis_diag.id_episode
                   AND ed.id_diagnosis = l_rec_diagnosis.id_diagnosis
                   AND ed.id_epis_diagnosis != i_epis_diagnosis.id_epis_diagnosis
                   AND ed.flg_type = pk_diagnosis.g_diag_type_p
                   AND ed.id_alert_diagnosis = l_rec_diagnosis.id_alert_diagnosis
                   AND ed.flg_status IN
                       (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_b);
            
                l_rec_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_diagnosis);
            
                g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_epis_diagnosis => l_rec_epis_diag,
                                                   io_params        => io_params,
                                                   o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                IF l_rec_epis_diag.id_epis_diagnosis_hist IS NULL
                   AND l_rec_diagnosis.tbl_diag_staging IS NOT NULL
                   AND l_rec_diagnosis.tbl_diag_staging.count = 1
                THEN
                    g_error := 'CALL CANCEL_ACTIVE_STAGINGS';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    cancel_active_stagings(i_episode       => l_rec_epis_diag.id_episode,
                                           i_epis_diag     => l_rec_epis_diag.id_epis_diagnosis,
                                           i_curr_staging  => l_rec_diagnosis.tbl_diag_staging(1).id_staging_basis,
                                           i_curr_num_stag => l_rec_diagnosis.tbl_diag_staging(1).num_staging_basis);
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        ELSIF l_rec_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
              AND l_rec_epis_diag.flg_type = pk_diagnosis.g_diag_type_d
              AND nvl(l_rec_epis_diag.flg_cancel_diff_diag, pk_alert_constant.g_no) = pk_alert_constant.g_yes
        THEN
            BEGIN
                g_error := 'GET ID_EPIS_DIAG_HIST OF DIFERENCIAL DIAGNOSIS';
                pk_alertlog.log_debug(text => g_error);
                SELECT edh.id_epis_diagnosis, edh.id_epis_diagnosis_hist, ed.flg_add_problem
                  INTO l_rec_epis_diag.id_epis_diagnosis,
                       l_rec_epis_diag.id_epis_diagnosis_hist,
                       l_rec_diagnosis.flg_add_problem
                  FROM epis_diagnosis_hist edh
                  JOIN epis_diagnosis ed
                    ON ed.id_epis_diagnosis = edh.id_epis_diagnosis
                  JOIN epis_diag_stag_hist edsh
                    ON edsh.id_epis_diagnosis_hist = edh.id_epis_diagnosis_hist
                  JOIN (SELECT ed1.id_episode, ed1.id_diagnosis, edsh1.id_staging_basis, edsh1.num_staging_basis
                          FROM epis_diagnosis_hist edh1
                          JOIN epis_diagnosis ed1
                            ON ed1.id_epis_diagnosis = edh1.id_epis_diagnosis
                          JOIN epis_diag_stag_hist edsh1
                            ON edsh1.id_epis_diagnosis_hist = edh1.id_epis_diagnosis_hist
                         WHERE edh1.id_epis_diagnosis_hist = i_epis_diagnosis.id_epis_diagnosis_hist) t
                    ON t.id_episode = ed.id_episode
                   AND t.id_diagnosis = ed.id_diagnosis
                   AND t.id_staging_basis = edsh.id_staging_basis
                   AND t.num_staging_basis = edsh.num_staging_basis
                 WHERE edh.flg_type = pk_diagnosis.g_diag_type_p
                   AND edh.flg_status IN
                       (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_b);
            
                l_rec_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_diagnosis);
            
                g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_epis_diagnosis => l_rec_epis_diag,
                                                   io_params        => io_params,
                                                   o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END cancel_epis_diagnosis;
    --
    /********************************************************************************************
    * Verifies if there are diagnoses registered on episodes of the same visit/previsous episode and adds them to the new episode
    * This function will be call whenever is created a new episode and whenever it's added or edited a diagnosis
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                Episode ID
    * @param i_tbl_epis_diagnosis     Epis diagnosis ID's created or changed; 
    *                                 If this column is null or the table_number has 0 elements means that's a new episode 
    *                                 and it will import the diagnoses of the the same visit/previous episode
    * @param o_error                  Error message
    *
    * @return                         true or false para sucesso ou erro
    *
    * @author                         Alexandre Santos
    * @version                        1.0   
    * @since                          2010/01/25
    **********************************************************************************************/
    FUNCTION set_visit_diagnosis
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_episode            IN episode.id_episode%TYPE,
        i_tbl_epis_diagnosis IN pk_edis_types.table_out_epis_diags,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'SET_VISIT_DIAGNOSIS';
        --
        l_epis_to_search table_number;
    
        l_tbl_epis_diag_to_process table_number;
    
        l_epis_diagnosis table_number;
        l_episodes       table_number;
    
        l_tbl_valid_epis_type table_number;
    
        l_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    
        CURSOR c_active_visit_episodes(i_tbl_valid_epis_type IN table_number) IS
            SELECT a.id_episode
              FROM (SELECT epis.id_prev_episode id_episode
                       FROM episode epis
                      WHERE epis.id_episode = i_episode
                           --It's only to be considered the UBU episode when getting the diagnoses of previous episodes
                       AND epis.id_prev_epis_type = pk_alert_constant.g_epis_type_urgent_care
                    UNION
                    SELECT epis.id_episode
                      FROM episode epis
                     WHERE epis.id_visit IN (SELECT e.id_visit
                                               FROM episode e
                                              WHERE e.id_episode = i_episode)
                       AND epis.id_epis_type IN (SELECT column_value
                                                   FROM TABLE(i_tbl_valid_epis_type))
                       AND epis.flg_status != pk_alert_constant.g_epis_status_inactive) a;
    
        CURSOR c_replicate_to_active_epis(i_tbl_valid_epis_type IN table_number) IS
            SELECT epis.id_episode
              FROM episode epis
             WHERE epis.id_episode NOT IN (SELECT column_value id_episode
                                             FROM TABLE(g_processed_episodes))
               AND epis.flg_status != pk_alert_constant.g_epis_status_inactive
               AND NOT EXISTS (SELECT 'X'
                      FROM discharge d
                     WHERE d.id_episode = epis.id_episode
                       AND d.flg_status = pk_discharge.g_disch_flg_active)
               AND epis.id_visit IN (SELECT e.id_visit
                                       FROM episode e
                                      WHERE e.id_episode = i_episode)
               AND epis.id_epis_type IN (SELECT column_value
                                           FROM TABLE(i_tbl_valid_epis_type));
    
        r_replicate_to_active_epis c_replicate_to_active_epis%ROWTYPE;
    
        CURSOR c_epis_diagnoses_to_sync(i_epis_to_search IN table_number) IS
        --    Exclude all cancelled diagnoses
        --    All previous diagnoses with flg_type = 'P'
        --    All previous diagnoses with flg_type = 'D' whose id_diagnosis doesn't have a corresponding record with flg_type = 'P'
            SELECT a.id_epis_diagnosis, a.id_episode
              FROM (
                    --Get all diferencial diagnoses
                    SELECT ed.id_epis_diagnosis, ed.id_episode
                      FROM epis_diagnosis ed
                     WHERE ed.id_episode IN (SELECT column_value
                                               FROM TABLE(CAST(i_epis_to_search AS table_number)))
                       AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
                       AND ed.flg_type = pk_diagnosis.g_diag_type_p
                    UNION ALL
                    --Get all final diagnoses
                    SELECT ed.id_epis_diagnosis, ed.id_episode
                      FROM epis_diagnosis ed
                     WHERE ed.id_episode IN (SELECT column_value
                                               FROM TABLE(CAST(i_epis_to_search AS table_number)))
                       AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
                       AND ed.flg_type = pk_diagnosis.g_diag_type_d
                          --remove diferencial diagnoses
                       AND (ed.id_diagnosis, ed.id_diagnosis_condition, ed.id_sub_analysis, ed.id_anatomical_area,
                            ed.id_anatomical_side) NOT IN
                           (SELECT ed1.id_diagnosis,
                                   ed1.id_diagnosis_condition,
                                   ed1.id_sub_analysis,
                                   ed1.id_anatomical_area,
                                   ed1.id_anatomical_side
                              FROM epis_diagnosis ed1
                             WHERE ed1.id_episode IN
                                   (SELECT column_value
                                      FROM TABLE(CAST(i_epis_to_search AS table_number)))
                               AND ed1.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
                               AND ed1.flg_type = pk_diagnosis.g_diag_type_p)) a;
    
        CURSOR c_diags_dont_exist_on_epis
        (
            i_epis                     IN episode.id_episode%TYPE,
            i_tbl_epis_diag_to_process IN table_number
        ) IS
        --02.A - Get all diagnoses that doesn't exist on current episode
            SELECT ed.id_epis_diagnosis, ed.id_episode
              FROM epis_diagnosis ed
             WHERE ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
               AND ed.flg_type IN (pk_diagnosis.g_diag_type_p, pk_diagnosis.g_diag_type_d)
               AND ed.id_epis_diagnosis IN
                   (SELECT column_value
                      FROM TABLE(CAST(i_tbl_epis_diag_to_process AS table_number)))
                  --remove diagnoses that already exist on the current episode
               AND (ed.id_diagnosis, ed.id_diagnosis_condition, ed.id_sub_analysis, ed.id_anatomical_area,
                    ed.id_anatomical_side) NOT IN
                   (SELECT ed1.id_diagnosis,
                           ed1.id_diagnosis_condition,
                           ed1.id_sub_analysis,
                           ed1.id_anatomical_area,
                           ed1.id_anatomical_side
                      FROM epis_diagnosis ed1
                     WHERE ed1.id_episode = i_epis
                       AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca);
    
        PROCEDURE insert_processed_episode(i_epis IN episode.id_episode%TYPE) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'INSERT_PROCESSED_EPISODE';
            --
            l_count PLS_INTEGER;
        BEGIN
            g_error := 'Init';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
            SELECT COUNT(*)
              INTO l_count
              FROM TABLE(g_processed_episodes) t
             WHERE t.column_value = i_epis;
        
            g_error := 'Number of episodes found: ' || to_char(l_count) || ' with id: ' || to_char(i_epis);
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
            IF l_count = 0
            THEN
                g_processed_episodes.extend();
                g_processed_episodes(g_processed_episodes.count) := i_epis;
            END IF;
        END insert_processed_episode;
    
        FUNCTION epis_was_processed(i_epis IN episode.id_episode%TYPE) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'EPIS_WAS_PROCESSED';
        BEGIN
            g_error := 'Init';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => l_func_name || ' - ' || l_inner_func_name);
        
            FOR l_curr IN (SELECT column_value id_episode
                             FROM TABLE(g_processed_episodes))
            LOOP
                IF l_curr.id_episode = i_epis
                THEN
                    RETURN TRUE;
                END IF;
            END LOOP;
        
            RETURN FALSE;
        END epis_was_processed;
    
        FUNCTION is_epis_origin_null(i_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'IS_EPIS_ORIGIN_NULL';
            --
            l_value VARCHAR2(1) := pk_alert_constant.g_yes;
        BEGIN
            g_error := 'Init';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => l_func_name || ' - ' || l_inner_func_name);
            SELECT decode(ed.id_episode_origin, NULL, pk_alert_constant.g_yes, pk_alert_constant.g_no)
              INTO l_value
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis = i_epis_diag;
        
            IF l_value = pk_alert_constant.g_yes
            THEN
                RETURN TRUE;
            ELSE
                RETURN FALSE;
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN TRUE;
        END is_epis_origin_null;
    
        --If current episode doesn't belong to the transfer list then there is nothing to do
        --Validate if current episode is part of the episodes to be processed
        FUNCTION validate_get_epis_types
        (
            i_epis           IN episode.id_episode%TYPE,
            o_tbl_epis_types OUT table_number
        ) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'VALIDATE_GET_EPIS_TYPES';
            --
            l_cfg_transfer_epis_typ sys_config.id_sys_config%TYPE := 'DIAG_TRANSFER_EPIS_TYPE';
            --
            l_cur_epis_type_validation PLS_INTEGER;
        BEGIN
            g_error := 'GET TRANSFER EPIS_TYPES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
            SELECT to_number(column_value)
              BULK COLLECT
              INTO o_tbl_epis_types
              FROM TABLE(pk_utils.str_split_l(pk_sysconfig.get_config(l_cfg_transfer_epis_typ, i_prof), ','));
        
            g_error := 'VALIDATE EPISODE TYPE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
            SELECT COUNT(*)
              INTO l_cur_epis_type_validation
              FROM episode epis
             WHERE epis.id_episode = i_epis
               AND epis.id_epis_type IN (SELECT column_value
                                           FROM TABLE(o_tbl_epis_types));
        
            RETURN(l_cur_epis_type_validation = 1);
        END validate_get_epis_types;
    
        FUNCTION is_to_process_episode
        (
            i_epis           IN episode.id_episode%TYPE,
            o_tbl_epis_types OUT table_number
        ) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'IS_TO_PROCESS_EPISODE';
            --
            l_cfg_transfer_epis       sys_config.id_sys_config%TYPE := 'TRANSFER_EPIS_DIAGNOSIS';
            l_cfg_transfer_epis_value sys_config.value%TYPE;
        BEGIN
            g_error := 'GET CFG TRANSFER';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
            l_cfg_transfer_epis_value := pk_sysconfig.get_config(i_code_cf => l_cfg_transfer_epis, i_prof => i_prof);
        
            IF l_cfg_transfer_epis_value = pk_alert_constant.g_yes
               AND NOT epis_was_processed(i_epis => i_epis)
               AND validate_get_epis_types(i_epis => i_epis, o_tbl_epis_types => o_tbl_epis_types)
            THEN
                g_error := 'INSERT_PROCESSED_EPISODE: ' || i_epis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_func_name);
                insert_processed_episode(i_epis => i_epis);
            
                RETURN TRUE;
            ELSE
                RETURN FALSE;
            END IF;
        END is_to_process_episode;
    
        PROCEDURE get_epis_diag_to_process
        (
            i_tbl_epis_diags           IN pk_edis_types.table_out_epis_diags,
            o_tbl_epis_diag_to_process OUT table_number
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAG_TO_PROCESS';
        BEGIN
            o_tbl_epis_diag_to_process := table_number();
        
            g_error := 'LOOP THROUGH OUTPUT TABLE RECORD';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            FOR i IN i_tbl_epis_diags.first .. i_tbl_epis_diags.last
            LOOP
                IF i_tbl_epis_diags(i).id_epis_diagnosis IS NOT NULL
                THEN
                    o_tbl_epis_diag_to_process.extend;
                    o_tbl_epis_diag_to_process(o_tbl_epis_diag_to_process.count) := i_tbl_epis_diags(i).id_epis_diagnosis;
                END IF;
            END LOOP;
        END get_epis_diag_to_process;
    
        PROCEDURE replicate_epis_diag
        (
            i_episode_destiny IN episode.id_episode%TYPE,
            i_epis_diagnosis  IN table_number,
            i_episodes        IN table_number
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'REPLICATE_EPIS_DIAG';
            --
            l_new_epis_diag      epis_diagnosis.id_epis_diagnosis%TYPE;
            l_tbl_processed_diag table_number := table_number();
            --
            FUNCTION is_to_process_diagnosis
            (
                i_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE,
                i_epis_dest IN episode.id_episode%TYPE
            ) RETURN BOOLEAN IS
                l_iinner_func_name CONSTANT VARCHAR(30) := 'IS_TO_PROCESS_DIAGNOSIS';
                --
                l_diagnosis       epis_diagnosis.id_diagnosis%TYPE;
                l_total_proc_diag PLS_INTEGER;
                l_total_epis_diag PLS_INTEGER;
            BEGIN
                --BEFORE INSERT VERIFY IF DIAG WAS ALREADY PROCESSED
                g_error := 'GET ID_DIAG OF ID_EPIS_DIAG:' || i_epis_diag || ';';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_func_name);
                SELECT ed.id_diagnosis
                  INTO l_diagnosis
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = i_epis_diag
                   AND ((pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                             i_prof         => i_prof,
                                                             i_concept_type => NULL,
                                                             i_diagnosis    => ed.id_diagnosis) =
                       pk_alert_constant.g_yes AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca) OR
                       pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_concept_type => NULL,
                                                            i_diagnosis    => ed.id_diagnosis) =
                       pk_alert_constant.g_no);
            
                g_error := 'VERIFY IF IT''s ON PROCESSED LIST. ID_DIAG: ' || l_diagnosis;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_func_name);
                SELECT COUNT(*)
                  INTO l_total_proc_diag
                  FROM TABLE(l_tbl_processed_diag) t
                 WHERE t.column_value = l_diagnosis;
            
                g_error := 'VERIFY IF DIAG ALREADY EXISTS ON CURRENT EPISODE. ID_EPIS: ' || i_epis_dest ||
                           '; ID_DIAG: ' || l_diagnosis;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_func_name);
                SELECT COUNT(*)
                  INTO l_total_epis_diag
                  FROM epis_diagnosis ed
                 WHERE ed.id_episode = i_epis_dest
                   AND ed.id_diagnosis = l_diagnosis
                   AND ed.flg_type = pk_diagnosis.g_diag_type_p;
            
                IF l_total_proc_diag = 0
                   AND l_total_epis_diag = 0
                THEN
                    l_tbl_processed_diag.extend;
                    l_tbl_processed_diag(l_tbl_processed_diag.count) := l_diagnosis;
                
                    RETURN TRUE;
                ELSE
                    RETURN FALSE;
                END IF;
            END is_to_process_diagnosis;
        
            PROCEDURE insert_new_epis_diag
            (
                i_epis_origin      IN episode.id_episode%TYPE,
                i_epis_dest        IN episode.id_episode%TYPE,
                i_epis_diag_origin IN epis_diagnosis.id_epis_diagnosis%TYPE,
                o_new_epis_diag    OUT epis_diagnosis.id_epis_diagnosis%TYPE
            ) IS
                l_iinner_proc_name CONSTANT VARCHAR(30) := 'INSERT_NEW_EPIS_DIAG';
                --
                l_epis_diag   epis_diagnosis%ROWTYPE;
                l_tumors      ts_epis_diag_tumors.epis_diag_tumors_tc;
                l_staging     ts_epis_diag_stag.epis_diag_stag_tc;
                l_prog_factor ts_epis_diag_stag_pfact.epis_diag_stag_pfact_tc;
            
                l_rows table_varchar := table_varchar();
            BEGIN
                o_new_epis_diag := ts_epis_diagnosis.next_key;
            
                g_error := 'GET EPIS_DIAGNOSIS DATA ID_EPIS_DIAG: ' || to_char(i_epis_diag_origin) ||
                           '; NEW_ID_EPIS_DIAG: ' || to_char(o_new_epis_diag);
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                SELECT o_new_epis_diag id_epis_diagnosis,
                       i_epis_dest id_episode,
                       ed.id_diagnosis,
                       ed.id_professional_diag,
                       ed.id_professional_cancel,
                       pk_diagnosis.g_diag_type_p flg_type,
                       ed.flg_status,
                       ed.notes,
                       ed.notes_cancel,
                       ed.desc_epis_diagnosis,
                       ed.id_prof_confirmed,
                       ed.id_prof_rulled_out,
                       ed.id_prof_base,
                       ed.flg_final_type,
                       ed.dt_epis_diagnosis_tstz,
                       ed.dt_cancel_tstz,
                       ed.dt_rulled_out_tstz,
                       ed.dt_confirmed_tstz,
                       ed.dt_base_tstz,
                       ed.id_patient,
                       ed.id_cancel_reason,
                       ed.id_alert_diagnosis,
                       nvl(ed.id_episode_origin, i_epis_origin) id_episode_origin,
                       ed.flg_add_problem,
                       ed.id_cdr_call,
                       ed.id_diag_inst_owner,
                       ed.id_adiag_inst_owner,
                       ed.dt_initial_diag,
                       ed.id_diag_basis,
                       ed.id_dbasis_inst_owner,
                       ed.diag_basis_spec,
                       ed.flg_recurrence,
                       ed.flg_mult_tumors,
                       ed.num_primary_tumors,
                       ed.id_diagnosis_condition,
                       ed.id_diagcond_inst_owner,
                       ed.id_sub_analysis,
                       ed.id_subanaly_inst_owner,
                       ed.id_anatomical_area,
                       ed.id_anatarea_inst_owner,
                       ed.id_anatomical_side,
                       ed.id_anatside_inst_owner
                  INTO l_epis_diag.id_epis_diagnosis,
                       l_epis_diag.id_episode,
                       l_epis_diag.id_diagnosis,
                       l_epis_diag.id_professional_diag,
                       l_epis_diag.id_professional_cancel,
                       l_epis_diag.flg_type,
                       l_epis_diag.flg_status,
                       l_epis_diag.notes,
                       l_epis_diag.notes_cancel,
                       l_epis_diag.desc_epis_diagnosis,
                       l_epis_diag.id_prof_confirmed,
                       l_epis_diag.id_prof_rulled_out,
                       l_epis_diag.id_prof_base,
                       l_epis_diag.flg_final_type,
                       l_epis_diag.dt_epis_diagnosis_tstz,
                       l_epis_diag.dt_cancel_tstz,
                       l_epis_diag.dt_rulled_out_tstz,
                       l_epis_diag.dt_confirmed_tstz,
                       l_epis_diag.dt_base_tstz,
                       l_epis_diag.id_patient,
                       l_epis_diag.id_cancel_reason,
                       l_epis_diag.id_alert_diagnosis,
                       l_epis_diag.id_episode_origin,
                       l_epis_diag.flg_add_problem,
                       l_epis_diag.id_cdr_call,
                       l_epis_diag.id_diag_inst_owner,
                       l_epis_diag.id_adiag_inst_owner,
                       l_epis_diag.dt_initial_diag,
                       l_epis_diag.id_diag_basis,
                       l_epis_diag.id_dbasis_inst_owner,
                       l_epis_diag.diag_basis_spec,
                       l_epis_diag.flg_recurrence,
                       l_epis_diag.flg_mult_tumors,
                       l_epis_diag.num_primary_tumors,
                       l_epis_diag.id_diagnosis_condition,
                       l_epis_diag.id_diagcond_inst_owner,
                       l_epis_diag.id_sub_analysis,
                       l_epis_diag.id_subanaly_inst_owner,
                       l_epis_diag.id_anatomical_area,
                       l_epis_diag.id_anatarea_inst_owner,
                       l_epis_diag.id_anatomical_side,
                       l_epis_diag.id_anatside_inst_owner
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = i_epis_diag_origin;
            
                g_error := 'CALL TS_EPIS_DIAGNOSIS.INS';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                ts_epis_diagnosis.ins(rec_in => l_epis_diag, rows_out => l_rows);
            
                t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_DIAGNOSIS',
                                              i_rowids     => l_rows,
                                              o_error      => o_error);
            
                g_error := 'GET TUMORS DATA';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                SELECT o_new_epis_diag              id_epis_diagnosis,
                       edt.tumor_num,
                       edt.id_topography,
                       edt.id_topog_inst_owner,
                       edt.id_laterality,
                       edt.id_lat_inst_owner,
                       edt.id_morphology,
                       edt.id_morph_inst_owner,
                       edt.id_behavior,
                       edt.id_behav_inst_owner,
                       edt.id_histological_grade,
                       edt.id_hgrade_inst_owner,
                       edt.id_other_grading_sys,
                       edt.id_ogradsys_inst_owner,
                       edt.flg_unknown_dimension,
                       edt.num_dimension,
                       edt.desc_dimension,
                       edt.additional_pathol_info,
                       edt.dt_epis_diagnosis_tumors,
                       NULL                         create_user,
                       NULL                         create_time,
                       NULL                         create_institution,
                       NULL                         update_user,
                       NULL                         update_time,
                       NULL                         update_institution
                  BULK COLLECT
                  INTO l_tumors
                  FROM epis_diag_tumors edt
                 WHERE edt.id_epis_diagnosis = i_epis_diag_origin;
            
                g_error := 'CALL TS_EPIS_DIAG_TUMORS.INS';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                ts_epis_diag_tumors.ins(rows_in => l_tumors);
            
                g_error := 'GET STAGING DATA';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                SELECT o_new_epis_diag            id_epis_diagnosis,
                       eds.num_staging_basis,
                       eds.id_staging_basis,
                       eds.id_sbasis_inst_owner,
                       eds.id_tnm_t,
                       eds.id_tnm_t_inst_owner,
                       eds.code_tnm_t,
                       eds.id_tnm_n,
                       eds.id_tnm_n_inst_owner,
                       eds.code_tnm_n,
                       eds.id_tnm_m,
                       eds.id_tnm_m_inst_owner,
                       eds.code_tnm_m,
                       eds.id_metastatic_sites,
                       eds.id_msites_inst_owner,
                       eds.id_staging_group,
                       eds.id_sgroup_inst_owner,
                       eds.id_residual_tumor,
                       eds.id_rtumor_inst_owner,
                       eds.id_surgical_margins,
                       eds.id_smargins_inst_owner,
                       eds.id_lymph_vasc_inv,
                       eds.id_lvinv_inst_owner,
                       eds.id_other_staging_sys,
                       eds.id_ostgsys_inst_owner,
                       eds.id_cancel_reason,
                       eds.cancel_notes,
                       eds.id_prof_create,
                       eds.dt_epis_diagnosis_stag,
                       NULL                       create_user,
                       NULL                       create_time,
                       NULL                       create_institution,
                       NULL                       update_user,
                       NULL                       update_time,
                       NULL                       update_institution
                  BULK COLLECT
                  INTO l_staging
                  FROM epis_diag_stag eds
                 WHERE eds.id_epis_diagnosis = i_epis_diag_origin;
            
                g_error := 'CALL TS_EPIS_DIAG_STAG.INS';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                ts_epis_diag_stag.ins(rows_in => l_staging);
            
                g_error := 'GET PROG_FACTORS DATA';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                SELECT o_new_epis_diag           id_epis_diagnosis,
                       edsp.num_staging_basis,
                       edsp.id_field,
                       edsp.id_field_inst_owner,
                       edsp.field_rank,
                       edsp.id_value,
                       edsp.id_value_inst_owner,
                       edsp.desc_value,
                       NULL                      create_user,
                       NULL                      create_time,
                       NULL                      create_institution,
                       NULL                      update_user,
                       NULL                      update_time,
                       NULL                      update_institution,
                       edsp.id_staging_basis,
                       edsp.id_sbasis_inst_owner
                  BULK COLLECT
                  INTO l_prog_factor
                  FROM epis_diag_stag_pfact edsp
                 WHERE edsp.id_epis_diagnosis = i_epis_diag_origin;
            
                g_error := 'CALL TS_EPIS_DIAG_STAG_PFACT.INS';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package,
                                      sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                         l_iinner_proc_name);
                ts_epis_diag_stag_pfact.ins(rows_in => l_prog_factor);
            END insert_new_epis_diag;
        
            PROCEDURE insert_new_epis_diag_hist
            (
                i_epis_origin      IN episode.id_episode%TYPE,
                i_epis_diag_origin IN epis_diagnosis.id_epis_diagnosis%TYPE,
                i_new_epis_diag    IN epis_diagnosis.id_epis_diagnosis%TYPE
            ) IS
                l_iinner_proc_name CONSTANT VARCHAR(30) := 'INSERT_NEW_EPIS_DIAG_HIST';
                --
                l_new_epis_diag_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
                l_epis_diag_hist     epis_diagnosis_hist%ROWTYPE;
                l_tumors_hist        ts_epis_diag_tumors_hist.epis_diag_tumors_hist_tc;
                l_staging_hist       ts_epis_diag_stag_hist.epis_diag_stag_hist_tc;
                l_prog_factor_hist   ts_epis_dstag_pfact_hist.epis_dstag_pfact_hist_tc;
                --
                CURSOR c_epis_hist_rows(i_epis_diag IN epis_diagnosis.id_epis_diagnosis%TYPE) IS
                    SELECT edh.id_epis_diagnosis_hist, edh.id_epis_diagnosis_notes
                      FROM epis_diagnosis_hist edh
                     WHERE edh.id_epis_diagnosis = i_epis_diag
                     ORDER BY edh.id_epis_diagnosis_hist;
            
                r_epis_hist c_epis_hist_rows%ROWTYPE;
            BEGIN
                FOR r_epis_hist IN c_epis_hist_rows(i_epis_diag => i_epis_diag_origin)
                LOOP
                    --CREATE EPIS_DIAG_HIST
                    g_error := 'GET SEQ_EPIS_DIAGNOSIS_HIST.NEXTVAL';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
                    l_new_epis_diag_hist := ts_epis_diagnosis_hist.next_key;
                
                    g_error := 'GET EPIS_DIAGNOSIS_HIST';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
                    SELECT l_new_epis_diag_hist id_epis_diagnosis_hist,
                           i_new_epis_diag id_epis_diagnosis,
                           edh.id_professional,
                           edh.flg_status,
                           edh.flg_type,
                           edh.notes,
                           edh.flg_final_type,
                           edh.dt_creation_tstz,
                           edh.adw_last_update,
                           edh.id_cancel_reason,
                           nvl(edh.id_episode_origin, i_epis_origin) id_episode_origin,
                           edh.flg_add_problem,
                           edh.dt_initial_diag,
                           edh.id_diag_basis,
                           edh.id_dbasis_inst_owner,
                           edh.diag_basis_spec,
                           edh.flg_recurrence,
                           edh.flg_mult_tumors,
                           edh.num_primary_tumors,
                           edh.id_diagnosis_condition,
                           edh.id_diagcond_inst_owner,
                           edh.id_sub_analysis,
                           edh.id_subanaly_inst_owner,
                           edh.id_anatomical_area,
                           edh.id_anatarea_inst_owner,
                           edh.id_anatomical_side,
                           edh.id_anatside_inst_owner
                      INTO l_epis_diag_hist.id_epis_diagnosis_hist,
                           l_epis_diag_hist.id_epis_diagnosis,
                           l_epis_diag_hist.id_professional,
                           l_epis_diag_hist.flg_status,
                           l_epis_diag_hist.flg_type,
                           l_epis_diag_hist.notes,
                           l_epis_diag_hist.flg_final_type,
                           l_epis_diag_hist.dt_creation_tstz,
                           l_epis_diag_hist.adw_last_update,
                           l_epis_diag_hist.id_cancel_reason,
                           l_epis_diag_hist.id_episode_origin,
                           l_epis_diag_hist.flg_add_problem,
                           l_epis_diag_hist.dt_initial_diag,
                           l_epis_diag_hist.id_diag_basis,
                           l_epis_diag_hist.id_dbasis_inst_owner,
                           l_epis_diag_hist.diag_basis_spec,
                           l_epis_diag_hist.flg_recurrence,
                           l_epis_diag_hist.flg_mult_tumors,
                           l_epis_diag_hist.num_primary_tumors,
                           l_epis_diag_hist.id_diagnosis_condition,
                           l_epis_diag_hist.id_diagcond_inst_owner,
                           l_epis_diag_hist.id_sub_analysis,
                           l_epis_diag_hist.id_subanaly_inst_owner,
                           l_epis_diag_hist.id_anatomical_area,
                           l_epis_diag_hist.id_anatarea_inst_owner,
                           l_epis_diag_hist.id_anatomical_side,
                           l_epis_diag_hist.id_anatside_inst_owner
                      FROM epis_diagnosis_hist edh
                     WHERE edh.id_epis_diagnosis_hist = r_epis_hist.id_epis_diagnosis_hist;
                
                    g_error := 'INSERT EPIS_DIAGNOSIS_HIST';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                    ts_epis_diagnosis_hist.ins(rec_in => l_epis_diag_hist);
                
                    g_error := 'GET TUMORS DATA';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    SELECT l_new_epis_diag_hist          id_epis_diagnosis_hist,
                           i_new_epis_diag               id_epis_diagnosis,
                           edth.tumor_num,
                           edth.id_topography,
                           edth.id_topog_inst_owner,
                           edth.id_laterality,
                           edth.id_lat_inst_owner,
                           edth.id_morphology,
                           edth.id_morph_inst_owner,
                           edth.id_behavior,
                           edth.id_behav_inst_owner,
                           edth.id_histological_grade,
                           edth.id_hgrade_inst_owner,
                           edth.id_other_grading_sys,
                           edth.id_ogradsys_inst_owner,
                           edth.flg_unknown_dimension,
                           edth.num_dimension,
                           edth.desc_dimension,
                           edth.additional_pathol_info,
                           edth.dt_epis_diagnosis_tumors,
                           NULL                          create_user,
                           NULL                          create_time,
                           NULL                          create_institution,
                           NULL                          update_user,
                           NULL                          update_time,
                           NULL                          update_institution
                      BULK COLLECT
                      INTO l_tumors_hist
                      FROM epis_diag_tumors_hist edth
                     WHERE edth.id_epis_diagnosis_hist = r_epis_hist.id_epis_diagnosis_hist;
                
                    g_error := 'CALL TS_EPIS_DIAG_TUMORS.INS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    ts_epis_diag_tumors_hist.ins(rows_in => l_tumors_hist);
                
                    g_error := 'GET STAGING DATA';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    SELECT l_new_epis_diag_hist        id_epis_diagnosis_hist,
                           i_new_epis_diag             id_epis_diagnosis,
                           edsh.num_staging_basis,
                           edsh.id_staging_basis,
                           edsh.id_sbasis_inst_owner,
                           edsh.id_tnm_t,
                           edsh.id_tnm_t_inst_owner,
                           edsh.code_tnm_t,
                           edsh.id_tnm_n,
                           edsh.id_tnm_n_inst_owner,
                           edsh.code_tnm_n,
                           edsh.id_tnm_m,
                           edsh.id_tnm_m_inst_owner,
                           edsh.code_tnm_m,
                           edsh.id_metastatic_sites,
                           edsh.id_msites_inst_owner,
                           edsh.id_staging_group,
                           edsh.id_sgroup_inst_owner,
                           edsh.id_residual_tumor,
                           edsh.id_rtumor_inst_owner,
                           edsh.id_surgical_margins,
                           edsh.id_smargins_inst_owner,
                           edsh.id_lymph_vasc_inv,
                           edsh.id_lvinv_inst_owner,
                           edsh.id_other_staging_sys,
                           edsh.id_ostgsys_inst_owner,
                           edsh.id_cancel_reason,
                           edsh.cancel_notes,
                           edsh.id_prof_create,
                           edsh.dt_epis_diagnosis_stag,
                           NULL                        create_user,
                           NULL                        create_time,
                           NULL                        create_institution,
                           NULL                        update_user,
                           NULL                        update_time,
                           NULL                        update_institution
                      BULK COLLECT
                      INTO l_staging_hist
                      FROM epis_diag_stag_hist edsh
                     WHERE edsh.id_epis_diagnosis_hist = r_epis_hist.id_epis_diagnosis_hist;
                
                    g_error := 'CALL TS_EPIS_DIAG_STAG.INS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    ts_epis_diag_stag_hist.ins(rows_in => l_staging_hist);
                
                    g_error := 'GET PROG_FACTORS DATA';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    SELECT l_new_epis_diag_hist       id_epis_diagnosis_hist,
                           i_new_epis_diag            id_epis_diagnosis,
                           edsph.num_staging_basis,
                           edsph.id_field,
                           edsph.id_field_inst_owner,
                           edsph.field_rank,
                           edsph.id_value,
                           edsph.id_value_inst_owner,
                           edsph.desc_value,
                           NULL                       create_user,
                           NULL                       create_time,
                           NULL                       create_institution,
                           NULL                       update_user,
                           NULL                       update_time,
                           NULL                       update_institution,
                           edsph.id_staging_basis,
                           edsph.id_sbasis_inst_owner
                      BULK COLLECT
                      INTO l_prog_factor_hist
                      FROM epis_dstag_pfact_hist edsph
                     WHERE edsph.id_epis_diagnosis_hist = r_epis_hist.id_epis_diagnosis_hist;
                
                    g_error := 'CALL TS_EPIS_DIAG_STAG_PFACT.INS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name || ' - ' ||
                                                             l_iinner_proc_name);
                    ts_epis_dstag_pfact_hist.ins(rows_in => l_prog_factor_hist);
                END LOOP;
            END insert_new_epis_diag_hist;
        BEGIN
            g_error := 'Create new diagnoses for the current episode. l_epis_diagnosis: ' ||
                       pk_utils.concat_table(i_epis_diagnosis) || ';';
            pk_alertlog.log_debug(text            => g_error,
                                  object_name     => g_package,
                                  sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
            FOR i IN i_epis_diagnosis.first .. i_epis_diagnosis.last
            LOOP
                IF is_to_process_diagnosis(i_epis_diag => i_epis_diagnosis(i), i_epis_dest => i_episode_destiny)
                THEN
                    g_error := 'INSERT NEW EPIS_DIAG: ' || i_epis_diagnosis(i) || ' IN ID_EPISODE: ' ||
                               i_episode_destiny;
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
                    insert_new_epis_diag(i_epis_origin      => i_episodes(i),
                                         i_epis_dest        => i_episode_destiny,
                                         i_epis_diag_origin => i_epis_diagnosis(i),
                                         o_new_epis_diag    => l_new_epis_diag);
                
                    g_error := 'INSERT NEW EPIS_DIAG_HIST''s FOR THE NEW ID_EPIS_DIAG: ' || l_new_epis_diag;
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_func_name || ' - ' || l_inner_proc_name);
                    insert_new_epis_diag_hist(i_epis_origin      => i_episodes(i),
                                              i_epis_diag_origin => i_epis_diagnosis(i),
                                              i_new_epis_diag    => l_new_epis_diag);
                END IF;
            END LOOP;
        END replicate_epis_diag;
    
        PROCEDURE update_existing_diags
        (
            i_tbl_epis_diag_already_ins IN table_number,
            i_tbl_epis_diag_to_process  IN table_number
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'UPDATE_EXISTING_DIAGS';
            --
            CURSOR c_epis_diags_to_updt
            (
                i_tbl_ed_already_ins IN table_number,
                i_tbl_ed_to_process  IN table_number
            ) IS
            --02.A - Get all diferencial and final diagnoses
                SELECT ed3.id_epis_diagnosis id_epis_diag_orig,
                       ed.id_epis_diagnosis,
                       ed.id_episode,
                       ed.flg_type,
                       ed.flg_final_type
                  FROM epis_diagnosis ed
                --join with the updated epis_diagnosis to get the most recent data
                  JOIN (SELECT ed1.id_epis_diagnosis, ed1.id_diagnosis
                          FROM epis_diagnosis ed1
                         WHERE ed1.flg_type IN (pk_diagnosis.g_diag_type_p, pk_diagnosis.g_diag_type_d)
                           AND ed1.flg_status != pk_diagnosis.g_ed_flg_status_b
                           AND ed1.id_epis_diagnosis IN
                               (SELECT column_value
                                  FROM TABLE(CAST(i_tbl_ed_to_process AS table_number)))) ed3
                    ON ed3.id_diagnosis = ed.id_diagnosis
                 WHERE ed.flg_type IN (pk_diagnosis.g_diag_type_p, pk_diagnosis.g_diag_type_d)
                   AND ed.flg_status != pk_diagnosis.g_ed_flg_status_b
                      --get only the diagnoses that already exist on the current episode
                   AND ed.id_episode = r_replicate_to_active_epis.id_episode
                   AND ((pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                             i_prof         => i_prof,
                                                             i_concept_type => NULL,
                                                             i_diagnosis    => ed.id_diagnosis) =
                       pk_alert_constant.g_yes AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca) OR
                       pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_concept_type => NULL,
                                                            i_diagnosis    => ed.id_diagnosis) =
                       pk_alert_constant.g_no)
                      --remove diagnoses inserted previously
                   AND ed.id_diagnosis NOT IN
                       (SELECT ed2.id_diagnosis
                          FROM epis_diagnosis ed2
                         WHERE ed2.id_epis_diagnosis IN (SELECT column_value id_epis_diagnosis
                                                           FROM TABLE(i_tbl_ed_already_ins))
                           AND ((pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_concept_type => NULL,
                                                                     i_diagnosis    => ed2.id_diagnosis) =
                               pk_alert_constant.g_yes AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca) OR
                               pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_concept_type => NULL,
                                                                    i_diagnosis    => ed2.id_diagnosis) =
                               pk_alert_constant.g_no))
                 ORDER BY id_epis_diag_orig;
        
            r_epis_diags_to_updt c_epis_diags_to_updt%ROWTYPE;
            --
            l_rec_epis_diagnosis     pk_edis_types.rec_in_epis_diagnosis;
            l_tbl_out_epis_diags     pk_edis_types.table_out_epis_diags;
            l_current_epis_diag_orig epis_diagnosis.id_epis_diagnosis%TYPE := NULL;
        BEGIN
            g_error := 'LOOP THROUGH EPIS_DIAGS THAT MUST BE UPDATED';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            FOR r_epis_diags_to_updt IN c_epis_diags_to_updt(i_tbl_ed_already_ins => i_tbl_epis_diag_already_ins,
                                                             i_tbl_ed_to_process  => i_tbl_epis_diag_to_process)
            LOOP
                IF l_current_epis_diag_orig IS NULL
                   OR l_current_epis_diag_orig != r_epis_diags_to_updt.id_epis_diag_orig
                THEN
                    --It's only needed to get new data if the current epis_diag being synced is diferent from the last one
                    --To have the minimum calls to the get_epis_diag_rec the cursor c_epis_diags_to_updt must be order by id_epis_diag_orig
                    l_current_epis_diag_orig := r_epis_diags_to_updt.id_epis_diag_orig;
                
                    g_error := 'GET EPIS_DIAG ORIGIN DATA';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package,
                                          sub_object_name => l_inner_proc_name);
                    l_rec_epis_diagnosis := get_epis_diag_rec(i_lang           => i_lang,
                                                              i_prof           => i_prof,
                                                              i_epis_diag      => l_current_epis_diag_orig,
                                                              i_epis_diag_hist => NULL);
                END IF;
            
                l_rec_epis_diagnosis.id_epis_diagnosis := r_epis_diags_to_updt.id_epis_diagnosis;
                l_rec_epis_diagnosis.id_episode        := r_epis_diags_to_updt.id_episode;
                l_rec_epis_diagnosis.flg_type          := r_epis_diags_to_updt.flg_type;
                l_rec_epis_diagnosis.flg_edit_mode     := pk_diagnosis_core.g_diag_edit_mode_edit;
            
                IF r_epis_diags_to_updt.flg_type = pk_diagnosis.g_diag_type_p
                THEN
                    l_rec_epis_diagnosis.tbl_diagnosis(1).flg_final_type := NULL;
                END IF;
            
                g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
                IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_epis_diagnosis => l_rec_epis_diagnosis,
                                                   i_is_updt_notes  => pk_alert_constant.g_yes,
                                                   i_is_sync_diags  => pk_alert_constant.g_no,
                                                   io_params        => l_tbl_out_epis_diags,
                                                   o_error          => o_error)
                THEN
                    RAISE pk_diagnosis.e_call_exception;
                END IF;
            END LOOP;
        END update_existing_diags;
    BEGIN
        IF is_to_process_episode(i_epis => i_episode, o_tbl_epis_types => l_tbl_valid_epis_type)
        THEN
            IF i_tbl_epis_diagnosis IS NULL
               OR i_tbl_epis_diagnosis.count = 0
            THEN
                --If code enters here it means that we are creating a new episode and we want to replicate diagnoses
                --to the new episode
            
                g_error := 'ORIGIN NEW EPISODE - 01 - Get list of episodes for further search of diagnoses';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN c_active_visit_episodes(i_tbl_valid_epis_type => l_tbl_valid_epis_type);
                FETCH c_active_visit_episodes BULK COLLECT
                    INTO l_epis_to_search;
                CLOSE c_active_visit_episodes;
            
                g_error := 'ORIGIN NEW EPISODE - 02 - Get the diagnoses to transfer to the new episode';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                OPEN c_epis_diagnoses_to_sync(i_epis_to_search => l_epis_to_search);
                FETCH c_epis_diagnoses_to_sync BULK COLLECT
                    INTO l_epis_diagnosis, l_episodes;
                CLOSE c_epis_diagnoses_to_sync;
            
                g_error := 'ORIGIN NEW EPISODE - 03 - Replicate episode diagnoses';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF l_epis_diagnosis IS NOT NULL
                   AND l_epis_diagnosis.count > 0
                THEN
                    replicate_epis_diag(i_episode_destiny => i_episode,
                                        i_epis_diagnosis  => l_epis_diagnosis,
                                        i_episodes        => l_episodes);
                END IF;
            ELSE
                g_error := 'GET EPIS_DIAGS THAT WERE CREATED OR UPDATED';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                get_epis_diag_to_process(i_tbl_epis_diags           => i_tbl_epis_diagnosis,
                                         o_tbl_epis_diag_to_process => l_tbl_epis_diag_to_process);
            
                g_error := 'ORIGIN INSRT/UPDT EPIS_DIAGN - 01 - Get list of active episodes of the same visit to replicate the diagnoses';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                FOR r_replicate_to_active_epis IN c_replicate_to_active_epis(i_tbl_valid_epis_type => l_tbl_valid_epis_type)
                LOOP
                    IF NOT epis_was_processed(i_epis => r_replicate_to_active_epis.id_episode)
                    THEN
                        insert_processed_episode(r_replicate_to_active_epis.id_episode);
                    
                        g_error := 'ORIGIN INSRT/UPDT EPIS_DIAGN - 02 - Get diagnoses that doesn''t exist on current episode';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        OPEN c_diags_dont_exist_on_epis(i_epis                     => r_replicate_to_active_epis.id_episode,
                                                        i_tbl_epis_diag_to_process => l_tbl_epis_diag_to_process);
                        FETCH c_diags_dont_exist_on_epis BULK COLLECT
                            INTO l_epis_diagnosis, l_episodes;
                        CLOSE c_diags_dont_exist_on_epis;
                    
                        g_error := 'ORIGIN INSRT/UPDT EPIS_DIAGN - 02.01 Replicate episode diagnoses';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF l_epis_diagnosis IS NOT NULL
                           AND l_epis_diagnosis.count > 0
                        THEN
                            replicate_epis_diag(i_episode_destiny => r_replicate_to_active_epis.id_episode,
                                                i_epis_diagnosis  => l_epis_diagnosis,
                                                i_episodes        => l_episodes);
                        END IF;
                    
                        g_error := 'ORIGIN INSRT/UPDT EPIS_DIAGN - 03 - Update diagnoses that exist on current episode';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        update_existing_diags(i_tbl_epis_diag_already_ins => l_epis_diagnosis,
                                              i_tbl_epis_diag_to_process  => l_tbl_epis_diag_to_process);
                    END IF;
                END LOOP;
            END IF;
        
            ----------------------------------------------------
            -- process the diagnosis rank (internaly it verifies if it has something to do)
            manage_epis_diagnosis_rank(i_lang             => i_lang,
                                       i_prof             => i_prof,
                                       i_id_episode       => i_episode,
                                       i_flg_process_hist => FALSE);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN pk_diagnosis.e_call_exception THEN
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_visit_diagnosis;
    --
    /**
    * Encapsulates the logic of saving (create/update/cancel) a diagnosis
    * (CALLED BY: PL/SQL)
    *
    * @param   i_lang                  Professional preferred language
    * @param   i_prof                  Professional identification and its context (institution and software)
    * @param   i_epis_diagnoses        Epis diagnoses record
    * @param   o_params                Output parameters record
    * @param   o_error                 Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    *
    * @author  Alexandre Santos
    * @version 2.6.2.1
    * @since   27-02-2012
    */
    FUNCTION set_epis_diagnosis
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_epis_diagnoses IN pk_edis_types.rec_in_epis_diagnoses,
        o_params         OUT pk_edis_types.table_out_epis_diags,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAGNOSIS';
        --
        l_epis_diagnosis pk_edis_types.rec_in_epis_diagnosis;
        l_general_notes  pk_edis_types.rec_in_general_notes;
    
        l_arr_diag_id  table_number;
        l_flg_type     VARCHAR2(2 CHAR);
        l_code_message sys_message.code_message%TYPE;
    
        --
        l_ae_exception  EXCEPTION;
        l_exception     EXCEPTION;
        l_nmx_exception EXCEPTION;
        l_diag_abort_deliv VARCHAR2(100 CHAR) := pk_sysconfig.get_config('DIAGNOSIS_ABORT_DELIV_VALIDATION', i_prof);
    
        --
        --Check if any AE_DIAG was already registered        
        FUNCTION check_ae_diag_already_reg
        (
            i_epis_diagnosis      IN epis_diagnosis.id_epis_diagnosis%TYPE,
            i_episode             IN episode.id_episode%TYPE,
            i_flg_type            IN epis_diagnosis.flg_type%TYPE,
            i_diagnosis           IN diagnosis.id_diagnosis%TYPE,
            i_diagnosis_condition IN epis_diagnosis.id_diagnosis_condition%TYPE,
            i_sub_analysis        IN epis_diagnosis.id_sub_analysis%TYPE,
            i_anatomical_area     IN epis_diagnosis.id_anatomical_area%TYPE,
            i_anatomical_side     IN epis_diagnosis.id_anatomical_side%TYPE
        ) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'CHECK_AE_DIAG_ALREADY_REG';
            --
            l_total_registered_diags PLS_INTEGER;
        BEGIN
            g_error := 'GET TOTAL REGISTERED DIAGS';
            pk_alertlog.log_debug(object_name => g_package, sub_object_name => l_inner_func_name, text => g_error);
            SELECT COUNT(1)
              INTO l_total_registered_diags
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis != nvl(i_epis_diagnosis, g_null_replace_value)
               AND ed.id_episode = i_episode
               AND ed.flg_type = i_flg_type
               AND ed.id_diagnosis = i_diagnosis
               AND nvl(ed.id_diagnosis_condition, g_null_replace_value) =
                   nvl(i_diagnosis_condition, g_null_replace_value)
               AND nvl(ed.id_sub_analysis, g_null_replace_value) = nvl(i_sub_analysis, g_null_replace_value)
               AND nvl(ed.id_anatomical_area, g_null_replace_value) = nvl(i_anatomical_area, g_null_replace_value)
               AND nvl(ed.id_anatomical_side, g_null_replace_value) = nvl(i_anatomical_side, g_null_replace_value)
               AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca;
        
            RETURN(l_total_registered_diags > 0);
        END check_ae_diag_already_reg;
        --
        --Check and fill missing creation data
        PROCEDURE fill_missing_data_crt(io_epis_diag IN OUT pk_edis_types.rec_in_epis_diagnosis) IS
            l_count            NUMBER := 0;
            l_count_exist_diag NUMBER;
            l_flg_other_diag   diagnosis.flg_other%TYPE;
        BEGIN
            IF io_epis_diag.tbl_diagnosis IS NULL
               AND io_epis_diag.tbl_diagnosis.count = 0
            THEN
                g_error := 'AT LEAST ONE DIAGNOSIS IS NEEDED TO PERFORM THIS OPERATION';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                raise_application_error(-20101, g_error);
            END IF;
        
            FOR i IN io_epis_diag.tbl_diagnosis.first .. io_epis_diag.tbl_diagnosis.last
            LOOP
                IF io_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_retreatment
                THEN
                    IF io_epis_diag.id_epis_diagnosis_hist IS NOT NULL
                    THEN
                        g_error := 'IT''S ONLY POSSIBLE TO ADD RETREATMENTS TO THE MOST RECENT EPIS_DIAG';
                        pk_alertlog.log_error(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        raise_application_error(-20102, g_error);
                    END IF;
                
                    IF io_epis_diag.id_epis_diagnosis IS NULL
                    THEN
                        g_error := 'TO ADD A RETREATMENT ID_EPIS_DIAGNOSIS IS NEEDED';
                        pk_alertlog.log_error(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        raise_application_error(-20103, g_error);
                    END IF;
                
                    IF io_epis_diag.tbl_diagnosis(i).id_diagnosis IS NULL
                    THEN
                        SELECT ed.id_diagnosis
                          INTO io_epis_diag.tbl_diagnosis(i).id_diagnosis
                          FROM epis_diagnosis ed
                         WHERE ed.id_epis_diagnosis = io_epis_diag.id_epis_diagnosis;
                    END IF;
                
                    IF io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis IS NULL
                    THEN
                        SELECT ed.id_alert_diagnosis
                          INTO io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis
                          FROM epis_diagnosis ed
                         WHERE ed.id_epis_diagnosis = io_epis_diag.id_epis_diagnosis;
                    END IF;
                ELSIF io_epis_diag.tbl_diagnosis(i).id_diagnosis IS NULL
                       AND io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis IS NULL
                THEN
                    g_error := 'ID_DIAGNOSIS AND ID_ALERT_DIAGNOSIS ARE BOTH EMPTY';
                    pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    raise_application_error(-20104, g_error);
                ELSIF io_epis_diag.tbl_diagnosis(i).id_diagnosis IS NULL
                       AND io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis IS NOT NULL
                THEN
                    g_error := 'GET ID_DIAGNOSIS OF ID_ALERT_DIAG: ' || io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis;
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    SELECT ad.id_diagnosis
                      INTO io_epis_diag.tbl_diagnosis(i).id_diagnosis
                      FROM alert_diagnosis ad
                     WHERE ad.id_alert_diagnosis = io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis;
                END IF;
            
                g_error := 'VALIDATE FLG_FINAL_TYPE';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF io_epis_diag.flg_val_single_prim_diag = pk_alert_constant.g_yes
                   AND io_epis_diag.tbl_diagnosis(i).flg_final_type = pk_diagnosis.g_flg_final_type_p
                THEN
                    IF l_count = 1
                    THEN
                        RAISE pk_diagnosis.e_final_type_exception;
                    ELSE
                        l_count := 1;
                    END IF;
                END IF;
            
                g_error := 'GET FLG_OTHER';
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT nvl(d.flg_other, pk_alert_constant.g_no)
                  INTO l_flg_other_diag
                  FROM diagnosis d
                 WHERE d.id_diagnosis = io_epis_diag.tbl_diagnosis(i).id_diagnosis;
            
                IF l_flg_other_diag = pk_alert_constant.g_no
                   AND io_epis_diag.tbl_diagnosis(i).id_alert_diagnosis IS NULL
                THEN
                    g_error := 'GET EXISTING DIAG';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    SELECT COUNT(*)
                      INTO l_count_exist_diag
                      FROM epis_diagnosis ed
                     WHERE ed.id_episode = io_epis_diag.id_episode
                       AND ed.id_diagnosis = io_epis_diag.tbl_diagnosis(i).id_diagnosis;
                
                    IF l_count_exist_diag = 0
                    THEN
                        g_error := 'ID_ALERT_DIAGNOSIS IS A MANDATORY FIELD';
                        pk_alertlog.log_error(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        raise_application_error(-20109, g_error);
                    END IF;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(i).flg_status IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(i).flg_status := pk_diagnosis.g_ed_flg_status_d;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(i).flg_add_problem IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(i).flg_add_problem := pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                                                         i_prof         => i_prof,
                                                                                                         i_concept_type => NULL,
                                                                                                         i_diagnosis    => io_epis_diag.tbl_diagnosis(i).id_diagnosis);
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(i).tbl_diag_staging IS NOT NULL
                    AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging.count > 0
                THEN
                    IF io_epis_diag.tbl_diagnosis(i).tbl_diag_staging.count > 1
                    THEN
                        g_error := 'THIS OPERATION IS ONLY AVAILABLE FOR ONE STAGING';
                        pk_alertlog.log_error(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        raise_application_error(-20105, g_error);
                    END IF;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(i).id_diagnosis_condition IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(i).id_diagnosis_condition := pk_diagnosis_core.get_id_diag_condition(i_prof      => i_prof,
                                                                                                                    i_diagnosis => io_epis_diag.tbl_diagnosis(i).id_diagnosis);
                END IF;
            END LOOP;
        END fill_missing_data_crt;
        --
        PROCEDURE fill_missing_data_edt(io_epis_diag IN OUT pk_edis_types.rec_in_epis_diagnosis) IS
            l_aux_epis_diag pk_edis_types.rec_in_epis_diagnosis;
        BEGIN
            IF io_epis_diag.tbl_diagnosis IS NULL
               OR (io_epis_diag.tbl_diagnosis IS NOT NULL AND io_epis_diag.tbl_diagnosis.count != 1)
            THEN
                g_error := 'THIS OPERATION IS ONLY AVAILABLE FOR ONE DIAGNOSIS';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                raise_application_error(-20106, g_error);
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).tbl_diag_staging IS NOT NULL
                AND io_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count > 1
            THEN
                g_error := 'THIS OPERATION IS ONLY AVAILABLE FOR ONE STAGING';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                raise_application_error(-20107, g_error);
            END IF;
        
            IF io_epis_diag.id_epis_diagnosis IS NULL
               AND io_epis_diag.id_epis_diagnosis_hist IS NOT NULL
            THEN
                SELECT edh.id_epis_diagnosis
                  INTO io_epis_diag.id_epis_diagnosis
                  FROM epis_diagnosis_hist edh
                 WHERE edh.id_epis_diagnosis_hist = io_epis_diag.id_epis_diagnosis_hist;
            ELSIF io_epis_diag.id_epis_diagnosis IS NULL
                  AND io_epis_diag.id_epis_diagnosis_hist IS NULL
            THEN
                g_error := 'THIS OPERATION IS ONLY VALID WHEN AT LEAST ONE OF THIS FIELDS ARE FILLED: (ID_EPIS_DIAGNOSIS OR ID_EPIS_DIAGNOSIS_HIST)';
                pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                raise_application_error(-20108, g_error);
            END IF;
        
            --It's only possible to edit one diagnosis at a time, so I can assume that the index of tbl_diagnosis is 1
        
            g_error := 'GET ALL SAVED DATA';
            pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_aux_epis_diag := get_epis_diag_rec(i_lang           => i_lang,
                                                 i_prof           => i_prof,
                                                 i_epis_diag      => io_epis_diag.id_epis_diagnosis,
                                                 i_epis_diag_hist => io_epis_diag.id_epis_diagnosis_hist);
        
            IF io_epis_diag.tbl_diagnosis(1).id_diagnosis IS NULL
            THEN
                io_epis_diag.tbl_diagnosis(1).id_diagnosis := l_aux_epis_diag.tbl_diagnosis(1).id_diagnosis;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).id_alert_diagnosis IS NULL
            THEN
                io_epis_diag.tbl_diagnosis(1).id_alert_diagnosis := l_aux_epis_diag.tbl_diagnosis(1).id_alert_diagnosis;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).flg_add_problem IS NULL
            THEN
                io_epis_diag.tbl_diagnosis(1).flg_add_problem := CASE
                                                                     WHEN l_aux_epis_diag.tbl_diagnosis(1).flg_add_problem IS NULL THEN
                                                                      pk_alert_constant.g_no
                                                                     ELSE
                                                                      l_aux_epis_diag.tbl_diagnosis(1).flg_add_problem
                                                                 END;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).flg_status IS NULL
            THEN
                io_epis_diag.tbl_diagnosis(1).flg_status := l_aux_epis_diag.tbl_diagnosis(1).flg_status;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).flg_final_type IS NULL
                AND io_epis_diag.flg_type != pk_diagnosis.g_diag_type_d
            THEN
                io_epis_diag.tbl_diagnosis(1).flg_final_type := l_aux_epis_diag.tbl_diagnosis(1).flg_final_type;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).tbl_diag_staging IS NOT NULL
                AND io_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count > 0
            THEN
                IF io_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count > 1
                THEN
                    g_error := 'THIS OPERATION IS ONLY AVAILABLE FOR ONE STAGING';
                    pk_alertlog.log_error(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    raise_application_error(-20105, g_error);
                END IF;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis(1).id_diagnosis_condition IS NULL
            THEN
                io_epis_diag.tbl_diagnosis(1).id_diagnosis_condition := nvl(l_aux_epis_diag.tbl_diagnosis(1).id_diagnosis_condition,
                                                                            pk_diagnosis_core.get_id_diag_condition(i_prof      => i_prof,
                                                                                                                    i_diagnosis => io_epis_diag.tbl_diagnosis(1).id_diagnosis));
            END IF;
        
            IF io_epis_diag.flg_edit_mode IN (pk_diagnosis_core.g_diag_edit_mode_status,
                                              pk_diagnosis_core.g_diag_edit_mode_type,
                                              pk_diagnosis_core.g_diag_cancel_staging,
                                              pk_diagnosis_core.g_diag_cancel_diag)
            THEN
                IF io_epis_diag.tbl_diagnosis(1).desc_diagnosis IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).desc_diagnosis := l_aux_epis_diag.tbl_diagnosis(1).desc_diagnosis;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).notes IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).notes := l_aux_epis_diag.tbl_diagnosis(1).notes;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).dt_initial_diag IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).dt_initial_diag := l_aux_epis_diag.tbl_diagnosis(1).dt_initial_diag;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).id_diag_basis IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).id_diag_basis := l_aux_epis_diag.tbl_diagnosis(1).id_diag_basis;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).diag_basis_spec IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).diag_basis_spec := l_aux_epis_diag.tbl_diagnosis(1).diag_basis_spec;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).flg_recurrence IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).flg_recurrence := l_aux_epis_diag.tbl_diagnosis(1).flg_recurrence;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).flg_mult_tumors IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).flg_mult_tumors := l_aux_epis_diag.tbl_diagnosis(1).flg_mult_tumors;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).num_primary_tumors IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).num_primary_tumors := l_aux_epis_diag.tbl_diagnosis(1).num_primary_tumors;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).id_sub_analysis IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).id_sub_analysis := l_aux_epis_diag.tbl_diagnosis(1).id_sub_analysis;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).id_anatomical_area IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).id_anatomical_area := l_aux_epis_diag.tbl_diagnosis(1).id_anatomical_area;
                END IF;
            
                IF io_epis_diag.tbl_diagnosis(1).id_anatomical_side IS NULL
                THEN
                    io_epis_diag.tbl_diagnosis(1).id_anatomical_side := l_aux_epis_diag.tbl_diagnosis(1).id_anatomical_side;
                END IF;
            
                IF (io_epis_diag.tbl_diagnosis(1).tbl_tumors IS NULL OR io_epis_diag.tbl_diagnosis(1).tbl_tumors.count = 0)
                   AND
                   (l_aux_epis_diag.tbl_diagnosis(1).tbl_tumors IS NOT NULL AND l_aux_epis_diag.tbl_diagnosis(1).tbl_tumors.count > 0)
                THEN
                    io_epis_diag.tbl_diagnosis(1).tbl_tumors := l_aux_epis_diag.tbl_diagnosis(1).tbl_tumors;
                END IF;
            
                IF (io_epis_diag.tbl_diagnosis(1).tbl_diag_staging IS NULL OR io_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count = 0)
                   AND
                   (l_aux_epis_diag.tbl_diagnosis(1).tbl_diag_staging IS NOT NULL AND l_aux_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count > 0)
                THEN
                    io_epis_diag.tbl_diagnosis(1).tbl_diag_staging := l_aux_epis_diag.tbl_diagnosis(1).tbl_diag_staging;
                
                    IF io_epis_diag.tbl_diagnosis(1)
                     .tbl_diag_staging IS NOT NULL
                        AND io_epis_diag.tbl_diagnosis(1).tbl_diag_staging.count = 1
                        AND io_epis_diag.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
                    THEN
                        IF io_epis_diag.id_epis_diagnosis_hist IS NULL --means that we are canceling the current staging
                        THEN
                            IF get_last_active_staging(i_lang                  => i_lang,
                                                       i_prof                  => i_prof,
                                                       i_current_staging_basis => io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).id_staging_basis,
                                                       i_episode               => io_epis_diag.id_episode,
                                                       i_diagnosis             => io_epis_diag.tbl_diagnosis(1).id_diagnosis,
                                                       i_epis_diagnosis        => io_epis_diag.id_epis_diagnosis,
                                                       i_flg_type              => io_epis_diag.flg_type,
                                                       i_dt_record             => io_epis_diag.dt_record) IS NULL
                            THEN
                                --There is no previous staging so cancel current diagnosis
                                io_epis_diag.tbl_diagnosis(1).flg_status := pk_diagnosis_core.g_diag_cancel_diag;
                                io_epis_diag.flg_edit_mode := pk_diagnosis_core.g_diag_cancel_diag;
                            ELSE
                                --Cancel current stating and set the previous one as current
                                io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).id_cancel_reason := io_epis_diag.id_cancel_reason;
                                io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).cancel_notes := io_epis_diag.cancel_notes;
                            
                                io_epis_diag.id_cancel_reason := NULL;
                                io_epis_diag.cancel_notes     := NULL;
                            END IF;
                        ELSE
                            --Cancel history stating
                            io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).id_cancel_reason := io_epis_diag.id_cancel_reason;
                            io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).cancel_notes := io_epis_diag.cancel_notes;
                        
                            io_epis_diag.id_cancel_reason := NULL;
                            io_epis_diag.cancel_notes     := NULL;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END fill_missing_data_edt;
        --
        --Check if there is missing data, and if so, fill it
        PROCEDURE check_fill_missing_data
        (
            i_flg_create IN BOOLEAN,
            io_epis_diag IN OUT pk_edis_types.rec_in_epis_diagnosis
        ) IS
            l_rec_diag pk_edis_types.rec_in_diagnosis;
            --
            l_curr_diag pk_edis_types.rec_in_diagnosis;
            l_aux_diag  pk_edis_types.rec_in_diagnosis;
        BEGIN
            IF io_epis_diag.flg_val_single_prim_diag IS NULL
            THEN
                g_error := 'GET DEFAULT VALUE SYS_CFG: ' || pk_diagnosis_core.g_cfg_single_prim_diag;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                io_epis_diag.flg_val_single_prim_diag := nvl(pk_sysconfig.get_config(i_code_cf => pk_diagnosis_core.g_cfg_single_prim_diag,
                                                                                     i_prof    => i_prof),
                                                             pk_alert_constant.g_yes);
            END IF;
        
            IF io_epis_diag.id_patient IS NULL
               AND io_epis_diag.id_episode IS NOT NULL
            THEN
                g_error := 'GET ID_PATIENT BASED ON I_EPISODE: ' || io_epis_diag.id_episode;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT epis.id_patient
                  INTO io_epis_diag.id_patient
                  FROM episode epis
                 WHERE epis.id_episode = io_epis_diag.id_episode;
            ELSIF io_epis_diag.id_episode IS NULL
                  AND io_epis_diag.id_epis_diagnosis IS NOT NULL
            THEN
                g_error := 'GET ID_PATIENT AND ID_EPISODE BASED ON I_EPIS_DIAG: ' || io_epis_diag.id_epis_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT ed.id_patient, ed.id_episode
                  INTO io_epis_diag.id_patient, io_epis_diag.id_episode
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = io_epis_diag.id_epis_diagnosis;
            ELSIF io_epis_diag.id_episode IS NULL
                  AND io_epis_diag.id_epis_diagnosis_hist IS NOT NULL
            THEN
                g_error := 'GET ID_PATIENT AND ID_EPISODE BASED ON I_EPIS_DIAG_HIST: ' ||
                           io_epis_diag.id_epis_diagnosis_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT ed.id_patient, ed.id_episode
                  INTO io_epis_diag.id_patient, io_epis_diag.id_episode
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis =
                       (SELECT edh.id_epis_diagnosis
                          FROM epis_diagnosis_hist edh
                         WHERE edh.id_epis_diagnosis_hist = io_epis_diag.id_epis_diagnosis_hist);
            END IF;
        
            IF io_epis_diag.flg_transf_final IS NULL
            THEN
                io_epis_diag.flg_transf_final := pk_alert_constant.g_no;
            END IF;
        
            IF io_epis_diag.dt_record IS NULL
            THEN
                g_sysdate      := SYSDATE;
                g_sysdate_tstz := current_timestamp;
            
                io_epis_diag.dt_record := g_sysdate_tstz;
            ELSE
                g_sysdate      := io_epis_diag.dt_record;
                g_sysdate_tstz := io_epis_diag.dt_record;
            END IF;
        
            IF io_epis_diag.flg_type IS NULL
            THEN
                io_epis_diag.flg_type := pk_diagnosis.g_diag_type_p;
            END IF;
        
            IF io_epis_diag.tbl_diagnosis.exists(1)
            THEN
                FOR i IN io_epis_diag.tbl_diagnosis.first .. io_epis_diag.tbl_diagnosis.last
                LOOP
                    IF io_epis_diag.tbl_diagnosis(i).desc_diagnosis IS NOT NULL
                        AND io_epis_diag.tbl_diagnosis(i).id_diagnosis IS NOT NULL
                    THEN
                        g_error := 'GET DESC_DIAG';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        SELECT decode(nvl(d.flg_other, pk_alert_constant.g_no),
                                      pk_alert_constant.g_yes,
                                      io_epis_diag.tbl_diagnosis(i).desc_diagnosis,
                                      '')
                          INTO io_epis_diag.tbl_diagnosis(i).desc_diagnosis
                          FROM diagnosis d
                         WHERE d.id_diagnosis = io_epis_diag.tbl_diagnosis(i).id_diagnosis;
                    END IF;
                
                    IF io_epis_diag.flg_type != pk_diagnosis.g_diag_type_d
                    THEN
                        io_epis_diag.tbl_diagnosis(i).flg_final_type := NULL;
                    END IF;
                
                    IF io_epis_diag.tbl_diagnosis(i).tbl_diag_staging IS NOT NULL
                        AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging.count = 1
                    THEN
                        IF (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.t IS NOT NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_t IS NULL)
                           OR (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.t IS NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_t IS NOT NULL)
                        THEN
                            g_error := 'WHEN TNM_T OR CODE_STAGE_T IS NOT NULL THE OTHER FIELD MUST ALSO BE SENT.';
                            pk_alertlog.log_error(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            raise_application_error(-20050, g_error);
                        END IF;
                    
                        IF (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.n IS NOT NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_n IS NULL)
                           OR (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.n IS NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_n IS NOT NULL)
                        THEN
                            g_error := 'WHEN TNM_N OR CODE_STAGE_N IS NOT NULL THE OTHER FIELD MUST ALSO BE SENT.';
                            pk_alertlog.log_error(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            raise_application_error(-20051, g_error);
                        END IF;
                    
                        IF (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.m IS NOT NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_m IS NULL)
                           OR (io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.m IS NULL --
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).tnm.code_stage_m IS NOT NULL)
                        THEN
                            g_error := 'WHEN TNM_M OR CODE_STAGE_M IS NOT NULL THE OTHER FIELD MUST ALSO BE SENT.';
                            pk_alertlog.log_error(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            raise_application_error(-20052, g_error);
                        END IF;
                    
                        IF io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).id_staging_basis IS NULL
                        THEN
                            g_error := 'STAGING BASIS IS A MANDATORY FIELD';
                            pk_alertlog.log_error(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            raise_application_error(-20053, g_error);
                        END IF;
                    
                        io_epis_diag.tbl_diagnosis(i).tbl_diag_staging(1).num_staging_basis := get_staging_basis_num(i_prof                => i_prof,
                                                                                                                     i_epis_diagnosis      => io_epis_diag.id_epis_diagnosis,
                                                                                                                     i_epis_diagnosis_hist => io_epis_diag.id_epis_diagnosis_hist,
                                                                                                                     i_staging_basis       => io_epis_diag.tbl_diagnosis(1).tbl_diag_staging(1).id_staging_basis,
                                                                                                                     i_flg_edit_mode       => io_epis_diag.flg_edit_mode);
                    ELSIF io_epis_diag.tbl_diagnosis(i).tbl_diag_staging IS NOT NULL
                           AND io_epis_diag.tbl_diagnosis(i).tbl_diag_staging.count > 1
                    THEN
                        g_error := 'IS ONLY POSSIBLE TO ADD ONE STAGING SECTION BY CANCER DIAGNOSIS';
                        pk_alertlog.log_error(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        raise_application_error(-20054, g_error);
                    END IF;
                
                    IF io_epis_diag.tbl_diagnosis(i).flg_diag_type = pk_diagnosis_core.g_diag_type_acc_emerg
                    THEN
                        l_curr_diag := io_epis_diag.tbl_diagnosis(i);
                    
                        IF l_curr_diag.id_diagnosis_condition IS NULL
                        THEN
                            l_curr_diag.id_diagnosis_condition := pk_diagnosis_core.get_id_diag_condition(i_prof      => i_prof,
                                                                                                          i_diagnosis => l_curr_diag.id_diagnosis);
                        END IF;
                    
                        --We need to verify if there is a existing AE_DIAG with the same axes
                        --If we have then raise an error
                        --This validation must be made in two different datasets:
                        --   * In the input parameters
                        --   * In the transactional data for the current episode
                    
                        g_error := 'VALIDATING AE_DIAG - SEARCH IN INPUT PARAMETERS FOR DUPLICATED DIAGS';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF io_epis_diag.tbl_diagnosis.count > 1
                        THEN
                            --We only need to validate if we have more then one diagnosis
                            FOR j IN io_epis_diag.tbl_diagnosis.first .. io_epis_diag.tbl_diagnosis.last
                            LOOP
                                IF i != j
                                THEN
                                    l_aux_diag := io_epis_diag.tbl_diagnosis(j);
                                
                                    IF l_aux_diag.id_diagnosis_condition IS NULL
                                    THEN
                                        l_aux_diag.id_diagnosis_condition := pk_diagnosis_core.get_id_diag_condition(i_prof      => i_prof,
                                                                                                                     i_diagnosis => l_aux_diag.id_diagnosis);
                                    END IF;
                                
                                    IF l_curr_diag.flg_diag_type = l_aux_diag.flg_diag_type
                                       AND l_curr_diag.id_diagnosis = l_aux_diag.id_diagnosis
                                       AND nvl(l_curr_diag.id_diagnosis_condition, g_null_replace_value) =
                                       nvl(l_aux_diag.id_diagnosis_condition, g_null_replace_value)
                                       AND nvl(l_curr_diag.id_sub_analysis, g_null_replace_value) =
                                       nvl(l_aux_diag.id_sub_analysis, g_null_replace_value)
                                       AND nvl(l_curr_diag.id_anatomical_area, g_null_replace_value) =
                                       nvl(l_aux_diag.id_anatomical_area, g_null_replace_value)
                                       AND nvl(l_curr_diag.id_anatomical_side, g_null_replace_value) =
                                       nvl(l_aux_diag.id_anatomical_side, g_null_replace_value)
                                    THEN
                                        g_error := 'DUPLICATED AE DIAGNOSES ON INPUT PARAMETERS - '; --TODO: add description
                                        pk_alertlog.log_error(text            => g_error,
                                                              object_name     => g_package,
                                                              sub_object_name => l_func_name);
                                        RAISE l_ae_exception;
                                    END IF;
                                END IF;
                            END LOOP;
                        END IF;
                    
                        g_error := 'VALIDATING AE_DIAG - SEARCH IN SAVED DATA FOR DUPLICATED DIAGS';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF check_ae_diag_already_reg(i_epis_diagnosis      => io_epis_diag.id_epis_diagnosis,
                                                     i_episode             => io_epis_diag.id_episode,
                                                     i_flg_type            => io_epis_diag.flg_type,
                                                     i_diagnosis           => l_curr_diag.id_diagnosis,
                                                     i_diagnosis_condition => l_curr_diag.id_diagnosis_condition,
                                                     i_sub_analysis        => l_curr_diag.id_sub_analysis,
                                                     i_anatomical_area     => l_curr_diag.id_anatomical_area,
                                                     i_anatomical_side     => l_curr_diag.id_anatomical_side)
                        THEN
                            g_error := 'AE DIAGNOSES WAS ALREADY REGISTERED IN THE CURRENT EPISODE';
                            pk_alertlog.log_error(text            => g_error,
                                                  object_name     => g_package,
                                                  sub_object_name => l_func_name);
                            RAISE l_ae_exception;
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        
            IF i_flg_create
            THEN
                fill_missing_data_crt(io_epis_diag => io_epis_diag);
            ELSE
                IF io_epis_diag.flg_edit_mode IN
                   (pk_diagnosis_core.g_diag_cancel_diag, pk_diagnosis_core.g_diag_cancel_staging)
                THEN
                    SELECT t.id_diagnosis,
                           t.id_alert_diagnosis,
                           t.flg_type,
                           t.notes,
                           t.flg_final_type,
                           t.flg_add_problem,
                           decode(io_epis_diag.flg_edit_mode,
                                  pk_diagnosis_core.g_diag_cancel_diag,
                                  pk_diagnosis.g_ed_flg_status_ca,
                                  t.flg_status)
                      INTO l_rec_diag.id_diagnosis,
                           l_rec_diag.id_alert_diagnosis,
                           io_epis_diag.flg_type,
                           l_rec_diag.notes,
                           l_rec_diag.flg_final_type,
                           l_rec_diag.flg_add_problem,
                           l_rec_diag.flg_status
                      FROM (SELECT ed.id_diagnosis,
                                   ed.id_alert_diagnosis,
                                   ed.flg_type,
                                   ed.notes,
                                   ed.flg_final_type,
                                   ed.flg_add_problem,
                                   ed.flg_status
                              FROM epis_diagnosis ed
                             WHERE ed.id_epis_diagnosis = io_epis_diag.id_epis_diagnosis
                               AND io_epis_diag.id_epis_diagnosis_hist IS NULL
                            UNION ALL
                            SELECT ed.id_diagnosis,
                                   ed.id_alert_diagnosis,
                                   ed.flg_type,
                                   edh.notes,
                                   ed.flg_final_type,
                                   ed.flg_add_problem,
                                   edh.flg_status
                              FROM epis_diagnosis_hist edh
                              JOIN epis_diagnosis ed
                                ON ed.id_epis_diagnosis = edh.id_epis_diagnosis
                             WHERE edh.id_epis_diagnosis_hist = io_epis_diag.id_epis_diagnosis_hist) t;
                
                    io_epis_diag.tbl_diagnosis := pk_edis_types.table_in_diagnosis(l_rec_diag);
                END IF;
            
                fill_missing_data_edt(io_epis_diag => io_epis_diag);
            END IF;
        END check_fill_missing_data;
    BEGIN
        l_epis_diagnosis := i_epis_diagnoses.epis_diagnosis;
        l_general_notes  := i_epis_diagnoses.general_notes;
    
        IF l_epis_diagnosis.tbl_diagnosis IS NOT NULL
           AND l_epis_diagnosis.flg_type = pk_diagnosis.g_diag_type_p
           AND l_diag_abort_deliv = pk_alert_constant.g_yes
        THEN
        
            l_arr_diag_id := table_number();
        
            FOR i IN 1 .. l_epis_diagnosis.tbl_diagnosis.count
            LOOP
                l_arr_diag_id.extend;
                l_arr_diag_id(l_arr_diag_id.count) := l_epis_diagnosis.tbl_diagnosis(i).id_diagnosis;
            END LOOP;
        
            IF NOT pk_diagnosis_core.check_diag_abort_or_deliv(i_lang      => i_lang,
                                                               i_prof      => i_prof,
                                                               i_diagnosis => l_arr_diag_id,
                                                               o_flg_type  => l_flg_type,
                                                               o_error     => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF l_flg_type IS NOT NULL
            THEN
            
                IF l_flg_type = pk_diagnosis_core.g_preg_out_type_a
                THEN
                    l_code_message := 'DIAGNOSIS_FINAL_M017';
                ELSE
                    l_code_message := 'DIAGNOSIS_FINAL_M018';
                END IF;
            
                RAISE l_nmx_exception;
            END IF;
        
        END IF;
    
        IF l_epis_diagnosis.flg_edit_mode IS NULL
        THEN
            IF l_epis_diagnosis.id_cancel_reason IS NOT NULL
            THEN
                l_epis_diagnosis.flg_edit_mode := pk_diagnosis_core.g_diag_cancel_diag;
            ELSIF l_epis_diagnosis.id_epis_diagnosis IS NOT NULL
                  OR l_epis_diagnosis.id_epis_diagnosis_hist IS NOT NULL
            THEN
                l_epis_diagnosis.flg_edit_mode := pk_diagnosis_core.g_diag_edit_mode_edit;
            ELSE
                l_epis_diagnosis.flg_edit_mode := pk_diagnosis_core.g_diag_create_mode;
            END IF;
        END IF;
    
        IF l_epis_diagnosis.id_cancel_reason IS NOT NULL
           AND l_epis_diagnosis.flg_edit_mode IN
           (pk_diagnosis_core.g_diag_cancel_diag, pk_diagnosis_core.g_diag_cancel_staging)
        THEN
            g_error := 'CALL CHECK_FILL_MISSING_DATA - CANCEL';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            check_fill_missing_data(i_flg_create => FALSE, io_epis_diag => l_epis_diagnosis);
        
            IF l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_diag
               AND l_epis_diagnosis.id_epis_diagnosis IS NOT NULL
            THEN
                g_error := 'CANCEL ID_EPIS_DIAGNOSIS: ' || l_epis_diagnosis.id_epis_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT cancel_epis_diagnosis(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_epis_diagnosis => l_epis_diagnosis,
                                             io_params        => o_params,
                                             o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            ELSIF l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
                  AND l_epis_diagnosis.id_epis_diagnosis_hist IS NULL
            THEN
                --It's the most recent staging, so we must cancel the current staging and set the last cronological staging as the current one
                g_error := 'CANCEL CURRENT STAGING ID_EPIS_DIAGNOSIS: ' || l_epis_diagnosis.id_epis_diagnosis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT cancel_epis_diagnosis(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_epis_diagnosis => l_epis_diagnosis,
                                             io_params        => o_params,
                                             o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            ELSIF l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_cancel_staging
                  AND l_epis_diagnosis.id_epis_diagnosis_hist IS NOT NULL
            THEN
                --Cancel staging in history tables
                g_error := 'CANCEL PAST STAGING ID_EPIS_DIAGNOSIS_HIST: ' || l_epis_diagnosis.id_epis_diagnosis_hist;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                IF NOT cancel_epis_diagnosis(i_lang           => i_lang,
                                             i_prof           => i_prof,
                                             i_epis_diagnosis => l_epis_diagnosis,
                                             io_params        => o_params,
                                             o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        ELSE
            IF l_epis_diagnosis.tbl_diagnosis IS NOT NULL
               AND l_epis_diagnosis.tbl_diagnosis.count > 0
            THEN
                IF l_epis_diagnosis.flg_edit_mode IN
                   (pk_diagnosis_core.g_diag_edit_mode_edit,
                    pk_diagnosis_core.g_diag_edit_mode_status,
                    pk_diagnosis_core.g_diag_edit_mode_type,
                    pk_diagnosis_core.g_diag_edit_mode_staging)
                THEN
                    g_error := 'CALL CHECK_FILL_MISSING_DATA - EDIT';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    check_fill_missing_data(i_flg_create => FALSE, io_epis_diag => l_epis_diagnosis);
                
                    IF l_epis_diagnosis.flg_edit_mode IN
                       (pk_diagnosis_core.g_diag_edit_mode_edit,
                        pk_diagnosis_core.g_diag_edit_mode_status,
                        pk_diagnosis_core.g_diag_edit_mode_type)
                       AND l_epis_diagnosis.id_epis_diagnosis IS NOT NULL
                    THEN
                        g_error := 'EDIT CURRENT EPIS_DIAGNOSIS OR CURRENT STAGING';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_epis_diagnosis => l_epis_diagnosis,
                                                           io_params        => o_params,
                                                           o_error          => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    ELSIF l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_staging
                          AND l_epis_diagnosis.id_epis_diagnosis_hist IS NOT NULL
                    THEN
                        g_error := 'EDIT PAST STAGING';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_epis_diagnosis => l_epis_diagnosis,
                                                           io_params        => o_params,
                                                           o_error          => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                ELSIF l_epis_diagnosis.flg_edit_mode IN
                      (pk_diagnosis_core.g_diag_create_mode, pk_diagnosis_core.g_diag_edit_mode_retreatment)
                THEN
                    g_error := 'CALL CHECK_FILL_MISSING_DATA - CREATE';
                    pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    check_fill_missing_data(i_flg_create => TRUE, io_epis_diag => l_epis_diagnosis);
                
                    IF l_epis_diagnosis.id_epis_diagnosis IS NULL
                       AND l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_create_mode
                    THEN
                        g_error := 'CALL CREATE_DIAGNOSIS_INTERNAL';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        IF NOT create_diagnosis_internal(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_epis_diagnosis => l_epis_diagnosis,
                                                         io_params        => o_params,
                                                         o_error          => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    ELSIF l_epis_diagnosis.id_epis_diagnosis IS NOT NULL
                          AND l_epis_diagnosis.flg_edit_mode = pk_diagnosis_core.g_diag_edit_mode_retreatment
                    THEN
                        g_error := 'CALL SET_EPIS_DIAGNOSIS_INTERNAL - RETREATMENT';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package,
                                              sub_object_name => l_func_name);
                        --This call is here because of the type of validations, it must be validated has a creation
                        IF NOT set_epis_diagnosis_internal(i_lang           => i_lang,
                                                           i_prof           => i_prof,
                                                           i_epis_diagnosis => l_epis_diagnosis,
                                                           io_params        => o_params,
                                                           o_error          => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        IF l_general_notes.id_epis_diagnosis_notes IS NOT NULL
           OR l_general_notes.notes IS NOT NULL
        THEN
            NULL;
            --TODO: Chamar a func. handle_notes
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN l_ae_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'DIAGNOSIS_ERROR_55',
                                              g_error,
                                              '',
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              'U',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN pk_diagnosis.e_final_type_exception THEN
            DECLARE
                l_only_one_prim_disch_diag CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_FINAL_T031';
                l_error_msg sys_message.desc_message%TYPE;
            BEGIN
                l_error_msg := pk_message.get_message(i_lang      => i_lang,
                                                      i_prof      => i_prof,
                                                      i_code_mess => l_only_one_prim_disch_diag);
            
                pk_alert_exceptions.process_error(i_lang,
                                                  l_only_one_prim_disch_diag,
                                                  l_error_msg,
                                                  '',
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  'D',
                                                  o_error);
            END;
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN l_nmx_exception THEN
            DECLARE
                l_error_msg sys_message.desc_message%TYPE;
            BEGIN
                l_error_msg := pk_message.get_message(i_lang => i_lang, i_prof => i_prof, i_code_mess => l_code_message);
            
                pk_alert_exceptions.process_error(i_lang,
                                                  l_code_message,
                                                  l_error_msg,
                                                  '',
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  'D',
                                                  o_error);
            END;
            pk_utils.undo_changes;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END set_epis_diagnosis;

    /**********************************************************************************************
    * Get the options for the actions button in the diagnosis grid 
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diagnosis         episode diagnosis ID
    * @param o_diag_actions           actions list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          27-02-2012
    **********************************************************************************************/
    FUNCTION get_diag_actions
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE,
        o_diag_actions   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_ACTIONS';
        --
        l_subject_diagnosis CONSTANT action.subject%TYPE := 'DIAGNOSIS_EDIT';
        l_subj_actions          t_coll_action;
        l_diag_actions          t_coll_action;
        l_staging_actions       t_coll_action;
        l_tab_epis_diag_staging pk_edis_types.tab_epis_diag_staging;
    
        l_epis_diagnosis      table_number;
        l_epis_diagnosis_hist table_number;
    
        l_curr_status epis_diagnosis.flg_status%TYPE;
    
        l_prof_diag        epis_diagnosis.id_professional_diag%TYPE;
        l_prof_id_cat      prof_cat.id_category%TYPE;
        l_prof_diag_id_cat prof_cat.id_category%TYPE;
    
        PROCEDURE fill_staging_actions
        (
            i_par_from_state action.from_state%TYPE,
            i_action         action.internal_name%TYPE
        ) IS
            l_code_msg_edit   CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M030';
            l_code_msg_cancel CONSTANT sys_message.code_message%TYPE := 'DIAGNOSIS_M031';
            l_code_msg_action sys_message.code_message%TYPE;
            l_id_action       action.id_action%TYPE;
        
            l_first_level    CONSTANT NUMBER := 1;
            l_level_stagings CONSTANT NUMBER := 2;
            --
            l_to_state VARCHAR2(1);
        BEGIN
            g_error := 'INIT ACTION VARS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            --
            IF i_par_from_state = g_action_edit
            THEN
                l_to_state        := pk_diagnosis_core.g_diag_edit_mode_edit;
                l_code_msg_action := l_code_msg_edit;
                l_id_action       := -998;
            ELSIF i_par_from_state = g_action_cancel
            THEN
                l_to_state        := pk_diagnosis_core.g_diag_cancel_diag;
                l_code_msg_action := l_code_msg_cancel;
                l_id_action       := -999;
            END IF;
            --
            l_diag_actions.extend;
            l_diag_actions(l_diag_actions.count) := t_rec_action(id_action   => l_id_action,
                                                                 id_parent   => NULL,
                                                                 level_nr    => l_first_level,
                                                                 from_state  => pk_alert_constant.g_active,
                                                                 to_state    => l_to_state,
                                                                 desc_action => pk_message.get_message(i_lang,
                                                                                                       i_prof,
                                                                                                       l_code_msg_action),
                                                                 icon        => NULL,
                                                                 flg_default => pk_alert_constant.g_no,
                                                                 action      => i_action,
                                                                 flg_active  => pk_alert_constant.g_active);
        
            g_error := 'LOOP STAGINGS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            FOR i IN 1 .. l_tab_epis_diag_staging.count
            LOOP
                g_error := 'FETCH STAGING ' || l_tab_epis_diag_staging(i).id_staging_basis;
                pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            
                l_epis_diagnosis.extend;
                l_epis_diagnosis_hist.extend;
                l_epis_diagnosis(l_epis_diagnosis.count) := l_tab_epis_diag_staging(i).id_epis_diagnosis;
                l_epis_diagnosis_hist(l_epis_diagnosis_hist.count) := l_tab_epis_diag_staging(i).id_epis_diagnosis_hist;
            
                l_to_state := CASE
                                  WHEN i_par_from_state = g_action_edit
                                       AND l_tab_epis_diag_staging(i).id_epis_diagnosis_hist IS NULL THEN
                                  --It's the most recent staging, equal to edit the diagnosis
                                   pk_diagnosis_core.g_diag_edit_mode_edit
                                  WHEN i_par_from_state = g_action_edit
                                       AND l_tab_epis_diag_staging(i).id_epis_diagnosis_hist IS NOT NULL THEN
                                  --Edit staging in history tables
                                   pk_diagnosis_core.g_diag_edit_mode_staging
                                  WHEN i_par_from_state = g_action_cancel
                                       AND l_tab_epis_diag_staging(i).id_epis_diagnosis_hist IS NULL THEN
                                  --It's the most recent staging, so we must cancel the current staging and set the last cronological staging as the current one
                                   pk_diagnosis_core.g_diag_cancel_staging
                                  WHEN i_par_from_state = g_action_cancel
                                       AND l_tab_epis_diag_staging(i).id_epis_diagnosis_hist IS NOT NULL THEN
                                  --Cancel staging in history tables
                                   pk_diagnosis_core.g_diag_cancel_staging
                                  ELSE
                                   NULL
                              END;
            
                l_staging_actions.extend;
                l_staging_actions(l_staging_actions.count) := t_rec_action(id_action   => l_tab_epis_diag_staging(i).id_staging_basis,
                                                                           id_parent   => l_id_action,
                                                                           level_nr    => l_level_stagings,
                                                                           from_state  => pk_alert_constant.g_active,
                                                                           to_state    => l_to_state,
                                                                           desc_action => l_tab_epis_diag_staging(i).desc_stage_title,
                                                                           icon        => NULL,
                                                                           flg_default => pk_alert_constant.g_no,
                                                                           action      => l_to_state || '_STAGING_ACTION',
                                                                           flg_active  => pk_alert_constant.g_active);
            
            END LOOP;
        END fill_staging_actions;
    
    BEGIN
    
        l_staging_actions     := t_coll_action();
        l_diag_actions        := t_coll_action();
        l_epis_diagnosis      := table_number();
        l_epis_diagnosis_hist := table_number();
    
        g_error := 'GET ACTIONS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_subj_actions := pk_action.tf_get_actions(i_lang, i_prof, l_subject_diagnosis, NULL);
    
        g_error := 'GET STAGINGS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_tab_epis_diag_staging := get_epis_diag_stagings(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          i_episode        => i_episode,
                                                          i_flg_call       => g_diag_call_viewer,
                                                          i_epis_diag      => i_epis_diagnosis,
                                                          i_epis_diag_hist => NULL);
    
        IF i_epis_diagnosis IS NOT NULL
        THEN
            SELECT ed.flg_status,
                   decode(ed.flg_status,
                          pk_diagnosis.g_ed_flg_status_co,
                          ed.id_prof_confirmed,
                          pk_diagnosis.g_ed_flg_status_r,
                          ed.id_prof_rulled_out,
                          pk_diagnosis.g_ed_flg_status_ca,
                          ed.id_professional_cancel,
                          pk_diagnosis.g_ed_flg_status_p,
                          ed.id_prof_base,
                          ed.id_professional_diag)
              INTO l_curr_status, l_prof_diag
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis = i_epis_diagnosis;
        ELSE
            l_curr_status := NULL;
            l_prof_diag   := NULL;
        END IF;
    
        l_prof_id_cat      := pk_prof_utils.get_id_category(i_lang => i_lang, i_prof => i_prof);
        l_prof_diag_id_cat := pk_prof_utils.get_id_category(i_lang => i_lang,
                                                            i_prof => profissional(l_prof_diag,
                                                                                   i_prof.institution,
                                                                                   i_prof.software));
    
        g_error := 'LOOP ACTIONS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        FOR i IN 1 .. l_subj_actions.count
        LOOP
            g_error := 'FETCH ACTION ' || l_subj_actions(i).id_action;
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            IF l_subj_actions(i).from_state IN (g_action_edit, g_action_cancel)
               -- reassess option only available when the diagnosis has at least one staging
                OR l_tab_epis_diag_staging.count > 0
            THEN
                IF l_curr_status = g_action_cancel
                   OR l_prof_id_cat != l_prof_diag_id_cat
                THEN
                    l_subj_actions(i).flg_active := pk_alert_constant.g_inactive;
                END IF;
            
                IF l_curr_status = g_action_edit
                   AND l_prof_id_cat != l_prof_diag_id_cat
                THEN
                    l_subj_actions(i).flg_active := pk_alert_constant.g_inactive;
                END IF;
            
                l_diag_actions.extend;
                l_diag_actions(l_diag_actions.count) := l_subj_actions(i);
            END IF;
        
            IF l_tab_epis_diag_staging.count > 0
               AND l_subj_actions(i).from_state IN (g_action_edit, g_action_cancel)
            THEN
                -- add staging actions
                fill_staging_actions(l_subj_actions(i).from_state, l_subj_actions(i).action);
            END IF;
        
        END LOOP;
    
        g_error := 'OPEN CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_diag_actions FOR
            SELECT i_epis_diagnosis id_epis_diagnosis,
                   NULL             id_epis_diagnosis_hist,
                   act.id_action,
                   act.id_parent,
                   act.level_nr     AS "LEVEL",
                   act.from_state,
                   act.to_state,
                   act.desc_action,
                   act.icon,
                   act.flg_default,
                   act.action,
                   act.flg_active
              FROM TABLE(l_diag_actions) act
            
            UNION ALL
            
            SELECT ed.column_value  id_epis_diagnosis,
                   edh.column_value id_epis_diagnosis_hist,
                   act.id_action,
                   act.id_parent,
                   act.level_nr     AS "LEVEL",
                   act.from_state,
                   act.to_state,
                   act.desc_action,
                   act.icon,
                   act.flg_default,
                   act.action,
                   act.flg_active
              FROM (SELECT rownum rn, a.*
                      FROM TABLE(l_staging_actions) a) act
              JOIN (SELECT b.column_value, rownum rn
                      FROM TABLE(l_epis_diagnosis) b) ed
                ON ed.rn = act.rn
              JOIN (SELECT c.column_value, rownum rn
                      FROM TABLE(l_epis_diagnosis_hist) c) edh
                ON edh.rn = ed.rn;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_diag_actions);
            RETURN FALSE;
    END get_diag_actions;

    /**********************************************************************************************
    * Get the most recent note registered in the episode 
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_episode                episode ID
    * @param i_epis_diag              episode diagnosis ID
    * @param i_epis_diag_hist         episode diagnosis ID (history record)
    *
    * @return                         diagnosis note
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          29-02-2012
    **********************************************************************************************/
    FUNCTION get_epis_diag_note
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_epis_diag      IN epis_diagnosis.id_epis_diagnosis%TYPE,
        i_epis_diag_hist IN epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE
    ) RETURN epis_diagnosis.notes%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAG_NOTE';
        --
        l_notes epis_diagnosis.notes%TYPE;
        l_error t_error_out;
    
        l_dt_diagnosis epis_diagnosis.dt_epis_diagnosis_tstz%TYPE;
    
        CURSOR c_diag_notes IS
            SELECT notes
              FROM epis_diagnosis_notes en
             WHERE en.id_episode = i_episode
               AND en.id_cancel_reason IS NULL
               AND en.dt_create >= nvl(l_dt_diagnosis, en.dt_create)
             ORDER BY dt_epis_diagnosis_notes DESC;
    
    BEGIN
    
        IF i_epis_diag_hist IS NOT NULL
        THEN
            SELECT ed.dt_creation_tstz
              INTO l_dt_diagnosis
              FROM epis_diagnosis_hist ed
             WHERE ed.id_epis_diagnosis_hist = i_epis_diag_hist;
        ELSIF i_epis_diag IS NOT NULL
        THEN
            SELECT pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                      i_prof,
                                                      ed.flg_status,
                                                      ed.dt_epis_diagnosis_tstz,
                                                      ed.dt_confirmed_tstz,
                                                      ed.dt_cancel_tstz,
                                                      ed.dt_base_tstz,
                                                      ed.dt_rulled_out_tstz) dt_creation_tstz
              INTO l_dt_diagnosis
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis = i_epis_diag;
        END IF;
    
        g_error := 'FETCH NOTES';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_diag_notes;
        FETCH c_diag_notes
            INTO l_notes;
        CLOSE c_diag_notes;
    
        RETURN l_notes;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_epis_diag_note;

    /**********************************************************************************************
    * Get the notes registered in the diagnosis area 
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_episode                episode ID
    * @param o_diag_notes             diagnosis notes list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          28-02-2012
    **********************************************************************************************/
    FUNCTION get_epis_diag_notes
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        i_flg_type   IN epis_diagnosis.flg_type%TYPE DEFAULT NULL,
        o_diag_notes OUT pk_edis_types.t_cur_diag_notes,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAG_NOTES';
        --
    
    BEGIN
    
        g_error := 'OPEN CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_diag_notes FOR
            SELECT id_epis_diagnosis_notes,
                   pk_date_utils.date_send_tsz(i_lang, dt_epis_diagnosis_notes, i_prof) dt_register,
                   pk_date_utils.date_char_tsz(i_lang, dt_epis_diagnosis_notes, i_prof.institution, i_prof.software) dt_register_chr,
                   id_prof_create,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_create) name_prof_create,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_create, dt_epis_diagnosis_notes, id_episode) desc_spec_create,
                   flg_status,
                   decode(flg_status,
                          pk_alert_constant.g_active,
                          NULL,
                          upper(pk_sysdomain.get_domain('EPIS_DIAGNOSIS_NOTES.FLG_STATUS', flg_status, i_lang))) desc_status,
                   notes,
                   id_prof_cancel,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_cancel) name_prof_cancel,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, id_prof_cancel, dt_cancel, id_episode) desc_spec_cancel,
                   pk_date_utils.date_char_tsz(i_lang, dt_cancel, i_prof.institution, i_prof.software) dt_cancel_chr,
                   pk_cancel_reason.get_cancel_reason_desc(i_lang, i_prof, id_cancel_reason) desc_cancel_reason,
                   notes_cancel,
                   NULL signature
            --ALERT-295408 Gisela Couto - The association between the impression and the list of active diagnoses registered was removed.
              FROM (SELECT en.id_epis_diagnosis_notes,
                           en.dt_epis_diagnosis_notes,
                           en.id_episode,
                           en.notes,
                           en.id_prof_create,
                           en.dt_create,
                           nvl2(id_cancel_reason, pk_alert_constant.g_cancelled, pk_alert_constant.g_active) flg_status,
                           en.id_cancel_reason,
                           en.notes_cancel,
                           en.id_prof_cancel,
                           en.dt_cancel
                      FROM epis_diagnosis_notes en
                     WHERE en.id_episode = i_episode
                    UNION ALL
                    SELECT enh.id_epis_diagnosis_notes,
                           enh.dt_epis_diagnosis_notes,
                           enh.id_episode,
                           enh.notes,
                           enh.id_prof_create,
                           enh.dt_create,
                           pk_alert_constant.g_outdated flg_status,
                           NULL                         id_cancel_reason,
                           NULL                         notes_cancel,
                           NULL                         id_prof_cancel,
                           NULL                         dt_cancel
                      FROM epis_diag_notes_hist enh
                     WHERE enh.id_episode = i_episode) epis_notes
             ORDER BY flg_status, dt_epis_diagnosis_notes DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_diag_notes);
            RETURN FALSE;
    END get_epis_diag_notes;

    /**********************************************************************************************
    * Sets the diagnosis notes  
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_episode                episode ID
    * @param i_epis_diag_notes        previous diagnosis notes ID (if it is an edition)
    * @param i_notes                  registered notes
    * @param o_epis_diag_notes        diagnosis notes ID that was saved
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          28-02-2012
    **********************************************************************************************/
    FUNCTION set_epis_diag_notes
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_epis_diag_notes IN epis_diagnosis_notes.id_epis_diagnosis_notes%TYPE,
        i_notes           IN epis_diagnosis_notes.notes%TYPE,
        o_epis_diag_notes OUT epis_diagnosis_notes.id_epis_diagnosis_notes%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_EPIS_DIAG_NOTES';
        --
        l_curr_diag_notes epis_diagnosis_notes%ROWTYPE;
        l_id_diag_notes   epis_diagnosis_notes.id_epis_diagnosis_notes%TYPE;
        l_rows            table_varchar := table_varchar();
    
    BEGIN
    
        IF i_epis_diag_notes IS NOT NULL
        THEN
            g_error := 'GET CURRENT NOTES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT *
              INTO l_curr_diag_notes
              FROM epis_diagnosis_notes ed
             WHERE ed.id_epis_diagnosis_notes = i_epis_diag_notes;
        END IF;
    
        IF l_curr_diag_notes.id_epis_diagnosis_notes IS NOT NULL
        THEN
            g_error := 'SET HISTORY';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_diag_notes_hist.ins(id_epis_diagnosis_notes_in => l_curr_diag_notes.id_epis_diagnosis_notes,
                                        dt_epis_diagnosis_notes_in => l_curr_diag_notes.dt_epis_diagnosis_notes,
                                        id_episode_in              => l_curr_diag_notes.id_episode,
                                        notes_in                   => l_curr_diag_notes.notes,
                                        id_prof_create_in          => l_curr_diag_notes.id_prof_create,
                                        dt_create_in               => l_curr_diag_notes.dt_create,
                                        rows_out                   => l_rows);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_DIAG_NOTES_HIST',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            l_rows := table_varchar();
        
            g_error := 'UPDATE NOTES RECORD';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            ts_epis_diagnosis_notes.upd(id_epis_diagnosis_notes_in => i_epis_diag_notes,
                                        dt_epis_diagnosis_notes_in => current_timestamp,
                                        id_episode_in              => i_episode,
                                        notes_in                   => i_notes,
                                        id_prof_create_in          => i_prof.id,
                                        rows_out                   => l_rows);
        
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_DIAGNOSIS_NOTES',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            o_epis_diag_notes := i_epis_diag_notes;
        
        ELSE
            g_error := 'INSERT NEW NOTES RECORD';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_id_diag_notes := ts_epis_diagnosis_notes.next_key;
        
            ts_epis_diagnosis_notes.ins(id_epis_diagnosis_notes_in => l_id_diag_notes,
                                        dt_epis_diagnosis_notes_in => current_timestamp,
                                        id_episode_in              => i_episode,
                                        notes_in                   => i_notes,
                                        id_prof_create_in          => i_prof.id,
                                        dt_create_in               => current_timestamp,
                                        rows_out                   => l_rows);
        
            t_data_gov_mnt.process_insert(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_DIAGNOSIS_NOTES',
                                          i_rowids     => l_rows,
                                          o_error      => o_error);
        
            o_epis_diag_notes := l_id_diag_notes;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_epis_diag_notes;

    /**********************************************************************************************
    * Cancel the diagnosis notes  
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis_diag_notes        diagnosis notes ID to be cancelled
    * @param i_cancel_reason          cancel reason
    * @param i_notes                  cancel notes
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          28-02-2012
    **********************************************************************************************/
    FUNCTION cancel_diag_notes
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_epis_diag_notes IN epis_diagnosis_notes.id_epis_diagnosis_notes%TYPE,
        i_cancel_reason   IN cancel_reason.id_cancel_reason%TYPE,
        i_notes           IN epis_diagnosis_notes.notes%TYPE,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CANCEL_DIAG_NOTES';
        --
        l_rows table_varchar;
    
    BEGIN
    
        g_error := 'CANCEL NOTES RECORD';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        ts_epis_diagnosis_notes.upd(id_epis_diagnosis_notes_in => i_epis_diag_notes,
                                    id_cancel_reason_in        => i_cancel_reason,
                                    notes_cancel_in            => i_notes,
                                    id_prof_cancel_in          => i_prof.id,
                                    dt_cancel_in               => current_timestamp,
                                    rows_out                   => l_rows);
    
        t_data_gov_mnt.process_update(i_lang       => i_lang,
                                      i_prof       => i_prof,
                                      i_table_name => 'EPIS_DIAGNOSIS_NOTES',
                                      i_rowids     => l_rows,
                                      o_error      => o_error);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_diag_notes;

    /**********************************************************************************************
    * Get all the cancer diagnoses registered previously in a patient
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_episode                Episode id
    * @param i_patient                Patient id
    * @param o_diags                  Diagnoses description list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/Apr/12
    **********************************************************************************************/
    FUNCTION get_pat_prev_cancer_diag
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE,
        i_patient IN patient.id_patient%TYPE,
        o_diags   OUT table_varchar,
        o_error   OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PAT_PREV_CANCER_DIAG';
    
    BEGIN
    
        g_error := 'OPEN O_CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                          i_prof                => i_prof,
                                          i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                          i_id_diagnosis        => d.id_diagnosis,
                                          i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                          i_code                => d.code_icd,
                                          i_flg_other           => d.flg_other,
                                          i_flg_std_diag        => ad.flg_icd9,
                                          i_epis_diag           => ed.id_epis_diagnosis,
                                          i_show_aditional_info => pk_alert_constant.g_no) diag_desc
          BULK COLLECT
          INTO o_diags
          FROM (SELECT ed.id_epis_diagnosis,
                       ed.id_diagnosis,
                       ed.id_alert_diagnosis,
                       ed.desc_epis_diagnosis,
                       pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                          i_prof,
                                                          ed.flg_status,
                                                          ed.dt_epis_diagnosis_tstz,
                                                          ed.dt_confirmed_tstz,
                                                          ed.dt_cancel_tstz,
                                                          ed.dt_base_tstz,
                                                          ed.dt_rulled_out_tstz) dt_diagnosis,
                       check_diag_cancer(i_lang, i_prof, NULL, ed.id_diagnosis) is_cancer_diag
                  FROM epis_diagnosis ed
                  JOIN episode e
                    ON e.id_episode = ed.id_episode
                 WHERE ed.id_episode <> i_episode
                   AND ed.id_patient = i_patient
                   AND ed.flg_status NOT IN (pk_diagnosis.g_epis_status_c, pk_diagnosis.g_ed_flg_status_r)) ed
          JOIN diagnosis d
            ON (d.id_diagnosis = ed.id_diagnosis)
          LEFT OUTER JOIN alert_diagnosis ad
            ON (ad.id_alert_diagnosis = ed.id_alert_diagnosis)
          JOIN pat_problem pp
            ON pp.id_epis_diagnosis = ed.id_epis_diagnosis
         WHERE is_cancer_diag = pk_alert_constant.g_yes
           AND pp.flg_status = pk_problems.g_active
         ORDER BY dt_diagnosis DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_pat_prev_cancer_diag;

    /**********************************************************************************************
    * List all diagnosis registered in a patient
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_id_patient             Patient id
    * @param i_show_only_cancer       Show only cancer diagnoses: (Y)es or (N)o
    * @param i_order_by_final_type    Order the grid by 
    * @param o_cursor                 Diagnoses list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/Mar/29
    **********************************************************************************************/
    FUNCTION get_pat_diagnosis_list
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_patient          IN patient.id_patient%TYPE,
        i_show_only_cancer    IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_order_by_final_type IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_order_by_status     IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_cursor              OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_PAT_DIAGNOSIS_LIST';
    
        l_msg_with_notes sys_message.desc_message%TYPE;
    
        l_allow_diff_diag_same_icd sys_config.value%TYPE := pk_sysconfig.get_config('ALLOW_DIFF_DIAGNOSIS_SAME_ICD',
                                                                                    i_prof);
    
        l_allow_disch_diag_same_icd sys_config.value%TYPE := pk_sysconfig.get_config('ALLOW_DISCH_DIAGNOSIS_SAME_ICD',
                                                                                     i_prof);
    
    BEGIN
    
        l_msg_with_notes := pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_DIFF_T016');
    
        g_error := 'OPEN O_CURSOR';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_cursor FOR
            SELECT id_epis_diagnosis,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => id_alert_diagnosis,
                                              i_id_diagnosis        => id_diagnosis,
                                              i_desc_epis_diagnosis => desc_epis_diagnosis,
                                              i_code                => code_icd,
                                              i_flg_other           => flg_other,
                                              i_flg_std_diag        => flg_icd9,
                                              i_epis_diag           => id_epis_diagnosis) desc_diagnosis,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, id_prof_diagnosis) prof_name_diag,
                   pk_date_utils.dt_chr_tsz(i_lang, dt_diagnosis, i_prof) date_target_diag,
                   pk_date_utils.date_char_hour_tsz(i_lang, dt_diagnosis, i_prof.institution, i_prof.software) hour_target_diag,
                   pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', flg_status, i_lang) desc_status,
                   pk_date_utils.date_send_tsz(i_lang, dt_diagnosis, i_prof) date_order,
                   notes,
                   pk_diagnosis_core.get_epis_diag_note(i_lang           => i_lang,
                                                        i_prof           => i_prof,
                                                        i_episode        => id_episode,
                                                        i_epis_diag      => id_epis_diagnosis,
                                                        i_epis_diag_hist => NULL) general_notes,
                   notes_cancel,
                   nvl2(nvl(notes_cancel, notes), l_msg_with_notes, '') see_notes,
                   decode(i_order_by_final_type, pk_alert_constant.g_yes, flg_final_type) rank1,
                   decode(i_order_by_status,
                          pk_alert_constant.g_yes,
                          pk_sysdomain.get_rank(i_lang, pk_diagnosis.g_epis_diag_status, flg_status)) rank2
              FROM (SELECT ed.id_episode,
                           ed.id_epis_diagnosis,
                           ad.id_alert_diagnosis,
                           d.id_diagnosis,
                           ed.desc_epis_diagnosis,
                           d.code_icd,
                           d.flg_other,
                           ad.flg_icd9,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                flg_status,
                                                                id_professional_diag,
                                                                id_prof_confirmed,
                                                                id_professional_cancel,
                                                                id_prof_base,
                                                                id_prof_rulled_out) id_prof_diagnosis,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              flg_status,
                                                              dt_epis_diagnosis_tstz,
                                                              dt_confirmed_tstz,
                                                              dt_cancel_tstz,
                                                              dt_base_tstz,
                                                              dt_rulled_out_tstz) dt_diagnosis,
                           ed.flg_status,
                           ed.notes,
                           ed.notes_cancel,
                           ed.flg_final_type,
                           check_diag_cancer(i_lang, i_prof, d.concept_type_int_name) flg_is_cancer
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_patient = i_id_patient
                       AND d.flg_other = pk_alert_constant.g_no
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                             pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_b)
                       AND (ed.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b) OR
                           (ed.flg_type = pk_diagnosis.g_diag_type_p AND
                           ed.id_diagnosis NOT IN
                           (SELECT id_diagnosis
                                FROM epis_diagnosis ed1
                               WHERE ed1.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b)
                                 AND ed1.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                                        pk_diagnosis.g_ed_flg_status_d,
                                                        pk_diagnosis.g_ed_flg_status_b)
                                 AND ed1.id_episode = ed.id_episode)))
                       AND ed.id_epis_diagnosis IN
                           (SELECT aux.id_epis_diagnosis
                              FROM (SELECT ed2.id_epis_diagnosis,
                                           row_number() over(PARTITION BY ed2.id_diagnosis, decode(ed2.flg_type, pk_diagnosis.g_ed_flg_status_d,(decode(l_allow_disch_diag_same_icd, pk_alert_constant.g_yes, ed2.id_alert_diagnosis, NULL)), pk_diagnosis.g_ed_flg_status_p,(decode(l_allow_diff_diag_same_icd, pk_alert_constant.g_yes, ed2.id_alert_diagnosis, NULL)), NULL) ORDER BY nvl(ed2.dt_confirmed_tstz, ed2.dt_epis_diagnosis_tstz) DESC) line_number
                                      FROM epis_diagnosis ed2
                                     WHERE ed2.id_patient = i_id_patient
                                       AND ed2.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                                              pk_diagnosis.g_ed_flg_status_co,
                                                              pk_diagnosis.g_ed_flg_status_b)
                                       AND (ed2.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b) OR
                                           (ed2.flg_type = pk_diagnosis.g_diag_type_p AND
                                           ed2.id_diagnosis NOT IN
                                           (SELECT id_diagnosis
                                                FROM epis_diagnosis ed3
                                               WHERE ed3.flg_type IN
                                                     (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b)
                                                 AND ed3.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                                                        pk_diagnosis.g_ed_flg_status_d,
                                                                        pk_diagnosis.g_ed_flg_status_b)
                                                 AND ed3.id_episode = ed2.id_episode)))) aux
                             WHERE aux.line_number = 1)
                    
                    UNION ALL
                    
                    SELECT ed.id_episode,
                           ed.id_epis_diagnosis,
                           ad.id_alert_diagnosis,
                           d.id_diagnosis,
                           ed.desc_epis_diagnosis,
                           d.code_icd,
                           d.flg_other,
                           ad.flg_icd9,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                flg_status,
                                                                id_professional_diag,
                                                                id_prof_confirmed,
                                                                id_professional_cancel,
                                                                id_prof_base,
                                                                id_prof_rulled_out) id_prof_diagnosis,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              flg_status,
                                                              dt_epis_diagnosis_tstz,
                                                              dt_confirmed_tstz,
                                                              dt_cancel_tstz,
                                                              dt_base_tstz,
                                                              dt_rulled_out_tstz) dt_diagnosis,
                           ed.flg_status,
                           ed.notes,
                           ed.notes_cancel,
                           ed.flg_final_type,
                           check_diag_cancer(i_lang, i_prof, d.concept_type_int_name) flg_is_cancer
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_patient = i_id_patient
                       AND d.flg_other = pk_alert_constant.g_yes
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                             pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_b)
                       AND (ed.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b) OR
                           (ed.flg_type = pk_diagnosis.g_diag_type_p AND
                           ed.desc_epis_diagnosis NOT IN
                           (SELECT desc_epis_diagnosis
                                FROM epis_diagnosis ed1
                               WHERE ed1.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b)
                                 AND ed1.id_diagnosis = ed.id_diagnosis
                                 AND ed1.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                                        pk_diagnosis.g_ed_flg_status_d,
                                                        pk_diagnosis.g_ed_flg_status_b)
                                 AND ed1.id_episode = ed.id_episode)))
                       AND ed.id_epis_diagnosis IN
                           (SELECT aux.id_epis_diagnosis
                              FROM (SELECT ed2.id_epis_diagnosis,
                                           row_number() over(PARTITION BY ed2.desc_epis_diagnosis ORDER BY nvl(ed2.dt_confirmed_tstz, ed2.dt_epis_diagnosis_tstz) DESC) line_number
                                      FROM epis_diagnosis ed2
                                     WHERE ed2.id_patient = i_id_patient
                                       AND ed2.desc_epis_diagnosis IS NOT NULL
                                       AND ed2.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                                              pk_diagnosis.g_ed_flg_status_co,
                                                              pk_diagnosis.g_ed_flg_status_b)
                                       AND (ed2.flg_type IN (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b) OR
                                           (ed2.flg_type = pk_diagnosis.g_diag_type_p AND
                                           ed2.desc_epis_diagnosis NOT IN
                                           (SELECT desc_epis_diagnosis
                                                FROM epis_diagnosis ed3
                                               WHERE ed3.flg_type IN
                                                     (pk_diagnosis.g_diag_type_d, pk_diagnosis.g_diag_type_b)
                                                 AND ed3.desc_epis_diagnosis IS NOT NULL
                                                 AND ed3.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                                                        pk_diagnosis.g_ed_flg_status_d,
                                                                        pk_diagnosis.g_ed_flg_status_b)
                                                 AND ed3.id_episode = ed2.id_episode)))) aux
                             WHERE aux.line_number = 1))
             WHERE i_show_only_cancer = pk_alert_constant.g_no
                OR flg_is_cancer = pk_alert_constant.g_yes
             ORDER BY rank1, rank2, dt_diagnosis DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_pat_diagnosis_list;

    /**********************************************************************************************
    * List all diagnosis registered in an episode
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_episode                Episode id
    * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param o_list                   Diagnoses list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/02/29
    **********************************************************************************************/
    FUNCTION get_epis_diagnosis_list
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_episode  IN episode.id_episode%TYPE,
        i_flg_type IN epis_diagnosis.flg_type%TYPE,
        o_list     OUT NOCOPY pk_edis_types.diagnosis_cur,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAGNOSIS_LIST';
    
        l_cfg_show_all_diag_states sys_config.id_sys_config%TYPE := 'FINAL_DIAGNOSIS_SHOW_ALL_STATES';
        l_show_all_diag_states     sys_config.value%TYPE;
    
    BEGIN
        --
        g_error := 'GET CFG - ' || l_cfg_show_all_diag_states;
        pk_alertlog.log_debug(g_error);
        IF i_flg_type = pk_diagnosis.g_diag_type_d
        THEN
            l_show_all_diag_states := nvl(pk_sysconfig.get_config(i_code_cf => l_cfg_show_all_diag_states,
                                                                  i_prof    => i_prof),
                                          pk_alert_constant.g_no);
        ELSE
            l_show_all_diag_states := pk_alert_constant.g_yes;
        END IF;
        --
        g_error := 'OPEN O_LIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_list FOR
            SELECT ed.id_epis_diagnosis,
                   pk_prof_utils.get_category(i_lang => i_lang,
                                              i_prof => profissional(ed.id_professional_diag,
                                                                     i_prof.institution,
                                                                     i_prof.software)) prof_category,
                   pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                   d.id_diagnosis,
                   ad.id_alert_diagnosis,
                   pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                              i_prof                => i_prof,
                                              i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                              i_id_diagnosis        => d.id_diagnosis,
                                              i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9,
                                              i_epis_diag           => ed.id_epis_diagnosis,
                                              i_show_aditional_info => pk_alert_constant.g_no) ||
                   pk_diagnosis.get_origin_diagnosis(i_lang, i_prof, ed.id_episode, ed.id_episode_origin) desc_diagnosis,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_initial_diag, i_prof) date_target_initial,
                   nvl2(nvl(ed.notes_cancel, ed.notes), pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_with_notes,
                   ed.flg_status status_diagnosis,
                   ed.id_professional_diag, --in investigation
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_professional_diag) prof_name_diag,
                   pk_date_utils.date_send_tsz(i_lang, ed.dt_epis_diagnosis_tstz, i_prof) date_diag,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_epis_diagnosis_tstz, i_prof) date_target_diag,
                   pk_date_utils.date_char_hour_tsz(i_lang,
                                                    ed.dt_epis_diagnosis_tstz,
                                                    i_prof.institution,
                                                    i_prof.software) hour_target_diag,
                   ed.id_prof_confirmed, --confirmed
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_prof_confirmed) prof_name_conf,
                   pk_date_utils.date_send_tsz(i_lang, ed.dt_confirmed_tstz, i_prof) date_conf,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_confirmed_tstz, i_prof) date_target_conf,
                   pk_date_utils.date_char_hour_tsz(i_lang, ed.dt_confirmed_tstz, i_prof.institution, i_prof.software) hour_target_conf,
                   ed.id_professional_cancel, --cancelled
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_professional_cancel) prof_name_cancel,
                   pk_date_utils.date_send_tsz(i_lang, ed.dt_cancel_tstz, i_prof) date_cancel,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_cancel_tstz, i_prof) date_target_cancel,
                   pk_date_utils.date_char_hour_tsz(i_lang, ed.dt_cancel_tstz, i_prof.institution, i_prof.software) hour_target_cancel,
                   ed.id_prof_rulled_out, -- declined
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_prof_rulled_out) prof_name_rulled_out,
                   pk_date_utils.date_send_tsz(i_lang, ed.dt_rulled_out_tstz, i_prof) date_rulled_out,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_rulled_out_tstz, i_prof) date_target_rulled,
                   pk_date_utils.date_char_hour_tsz(i_lang, ed.dt_rulled_out_tstz, i_prof.institution, i_prof.software) hour_target_rulled,
                   ed.id_prof_base, -- base
                   pk_prof_utils.get_name_signature(i_lang, i_prof, ed.id_prof_base) prof_name_base,
                   pk_date_utils.date_send_tsz(i_lang, ed.dt_base_tstz, i_prof) date_base,
                   pk_date_utils.dt_chr_tsz(i_lang, ed.dt_base_tstz, i_prof) date_target_base,
                   pk_date_utils.date_char_hour_tsz(i_lang, ed.dt_base_tstz, i_prof.institution, i_prof.software) hour_target_base,
                   pk_sysdomain.get_img(i_lang, pk_diagnosis.g_epis_diag_status, ed.flg_status) icon_status,
                   pk_sysdomain.get_domain_cached(i_lang, ed.flg_status, pk_diagnosis.g_epis_diag_status) desc_status,
                   pk_sysdomain.get_img(i_lang, pk_diagnosis.g_epis_diag_type_d, ed.flg_final_type) icon_final_type,
                   pk_sysdomain.get_domain_cached(i_lang, ed.flg_final_type, pk_diagnosis.g_epis_diag_type_d) desc_final_type,
                   ed.flg_final_type final_type,
                   pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                      i_prof,
                                                      flg_status,
                                                      dt_epis_diagnosis_tstz,
                                                      dt_confirmed_tstz,
                                                      dt_cancel_tstz,
                                                      dt_base_tstz,
                                                      dt_rulled_out_tstz) date_order,
                   ed.notes,
                   ed.notes_cancel,
                   ed.id_cancel_reason,
                   get_epis_diag_note(i_lang, i_prof, ed.id_episode, ed.id_epis_diagnosis, NULL) general_notes,
                   decode(ed.flg_status,
                          pk_diagnosis.g_ed_flg_status_ca,
                          pk_alert_constant.g_no,
                          pk_alert_constant.g_yes) avail_butt_cancel,
                   pk_sysdomain.get_rank(i_lang, pk_diagnosis.g_epis_diag_status, ed.flg_status) rank,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    ed.id_professional_diag,
                                                    ed.dt_epis_diagnosis_tstz,
                                                    ed.id_episode) prof_spec_diag,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    ed.id_prof_confirmed,
                                                    ed.dt_confirmed_tstz,
                                                    ed.id_episode) prof_spec_conf,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    ed.id_professional_cancel,
                                                    ed.dt_cancel_tstz,
                                                    ed.id_episode) prof_spec_canc,
                   pk_prof_utils.get_spec_signature(i_lang,
                                                    i_prof,
                                                    ed.id_prof_rulled_out,
                                                    ed.dt_rulled_out_tstz,
                                                    ed.id_episode) prof_spec_rull,
                   pk_prof_utils.get_spec_signature(i_lang, i_prof, ed.id_prof_base, ed.dt_base_tstz, ed.id_episode) prof_spec_base,
                   (decode((SELECT COUNT(*)
                             FROM epis_diagnosis ed_diff
                            WHERE ed_diff.id_episode = ed.id_episode
                              AND ed_diff.id_diagnosis = ed.id_diagnosis
                              AND ed_diff.flg_type = pk_diagnosis.g_diag_type_p
                              AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                                    pk_diagnosis.g_ed_flg_status_co,
                                                    pk_diagnosis.g_ed_flg_status_b)),
                           0,
                           pk_alert_constant.g_no,
                           pk_alert_constant.g_yes)) has_diff_diag,
                   check_diag_cancer(i_lang, i_prof, d.concept_type_int_name) flg_is_cancer,
                   pk_diagnosis_core.get_ds_leaf_path(i_lang => i_lang, i_prof => i_prof, i_diagnosis => d.id_diagnosis) ds_leafs_path
              FROM epis_diagnosis ed
              JOIN diagnosis d
                ON d.id_diagnosis = ed.id_diagnosis
              LEFT JOIN alert_diagnosis ad
                ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
             WHERE ed.id_episode = i_episode
               AND (ed.flg_type = i_flg_type OR (ed.flg_type = pk_diagnosis.g_diag_type_b AND NOT EXISTS
                    (SELECT 1
                                                    FROM epis_diagnosis ed2
                                                   WHERE ed2.id_episode = ed.id_episode
                                                     AND ed2.id_diagnosis = ed.id_diagnosis
                                                     AND ed2.flg_type = i_flg_type)))
               AND ((l_show_all_diag_states = pk_alert_constant.g_no AND
                   ed.flg_status IN
                   (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_b)) OR
                   l_show_all_diag_states = pk_alert_constant.g_yes)
             ORDER BY ed.flg_final_type, rank, date_order DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_edis_types.open_my_cursor(o_list);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_diagnosis_list;

    FUNCTION get_count_epis_diagnosis_list
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_episode  IN episode.id_episode%TYPE,
        i_flg_type IN epis_diagnosis.flg_type%TYPE,
        o_count    OUT NUMBER,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_DIAGNOSIS_LIST';
    
        l_cfg_show_all_diag_states sys_config.id_sys_config%TYPE := 'FINAL_DIAGNOSIS_SHOW_ALL_STATES';
        l_show_all_diag_states     sys_config.value%TYPE;
    
    BEGIN
        --
        g_error := 'GET CFG - ' || l_cfg_show_all_diag_states;
        pk_alertlog.log_debug(g_error);
        IF i_flg_type = pk_diagnosis.g_diag_type_d
        THEN
            l_show_all_diag_states := nvl(pk_sysconfig.get_config(i_code_cf => l_cfg_show_all_diag_states,
                                                                  i_prof    => i_prof),
                                          pk_alert_constant.g_no);
        ELSE
            l_show_all_diag_states := pk_alert_constant.g_yes;
        END IF;
        --
        g_error := 'OPEN O_LIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        SELECT COUNT(*)
          INTO o_count
          FROM epis_diagnosis ed
          JOIN diagnosis d
            ON d.id_diagnosis = ed.id_diagnosis
          LEFT JOIN alert_diagnosis ad
            ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
         WHERE ed.id_episode = i_episode
           AND (ed.flg_type = i_flg_type OR (ed.flg_type = pk_diagnosis.g_diag_type_b AND NOT EXISTS
                (SELECT 1
                                                FROM epis_diagnosis ed2
                                               WHERE ed2.id_episode = ed.id_episode
                                                 AND ed2.id_diagnosis = ed.id_diagnosis
                                                 AND ed2.flg_type = i_flg_type)))
           AND ((l_show_all_diag_states = pk_alert_constant.g_no AND
               ed.flg_status IN
               (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_b)) OR
               l_show_all_diag_states = pk_alert_constant.g_yes);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_count_epis_diagnosis_list;

    /**********************************************************************************************
    * Get all the diagnosis contained in a list of episode diagnosis IDs
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_episode                Episode ID
    * @param i_epis_diagnosis         Episode diagnosis ID
    * @param o_diagnosis              List of diagnosis IDs
    * @param o_alert_diagnosis        List of alert diagnosis IDs
    * @param o_desc_detail            List of diagnosis detail information to be placed in the grid
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/03/21
    **********************************************************************************************/
    FUNCTION get_diag_from_epis_diag
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_epis_diagnosis  IN table_number,
        o_diagnosis       OUT table_number,
        o_alert_diagnosis OUT table_number,
        o_desc_detail     OUT table_varchar,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DIAG_FROM_EPIS_DIAG';
    
        l_prev_records_label sys_message.desc_message%TYPE;
        l_dt_initial_label   sys_message.desc_message%TYPE;
    
    BEGIN
    
        l_prev_records_label := pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M033');
        l_dt_initial_label   := pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M034');
    
        g_error := 'GET ACTIVE DIAGNOSIS_PROBLEMS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT id_diagnosis, id_alert_diagnosis, desc_detail
          BULK COLLECT
          INTO o_diagnosis, o_alert_diagnosis, o_desc_detail
          FROM (SELECT /*+opt_estimate (table epis_d rows=5)*/
                 row_number() over(PARTITION BY id_diagnosis ORDER BY e.dt_begin_tstz DESC, ed.flg_type) rn,
                 ed.id_diagnosis,
                 ed.id_alert_diagnosis,
                 nvl2(ed.dt_initial_diag,
                      l_prev_records_label || ' (' || l_dt_initial_label || ': ' ||
                      pk_date_utils.dt_chr_tsz(i_lang, ed.dt_initial_diag, i_prof.institution, i_prof.software) || ')',
                      l_prev_records_label) desc_detail
                  FROM epis_diagnosis ed
                  JOIN episode e
                    ON e.id_episode = ed.id_episode
                  JOIN TABLE(i_epis_diagnosis) epis_d
                    ON epis_d.column_value = ed.id_epis_diagnosis
                 WHERE ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)) t
         WHERE rn = 1
           AND NOT EXISTS (SELECT 0
                  FROM epis_diagnosis
                 WHERE id_episode = i_episode
                   AND id_diagnosis = t.id_diagnosis);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_diag_from_epis_diag;

    /********************************************************************************************
    * Gets all configurations related with diagnosis
    * NOTE: This function makes DML operations so don't use it directly in a query
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_flg_type               Filter type: 
    *                                                      M - most frequent 
    *                                                      C - complaint diagnosis
    * @param i_patient                Patient ID
    * @param i_episode                Episode ID
    *                        
    * @return                         diagnosis list
    * 
    * @author                         José Silva
    * @version                        2.6.2
    * @since                          02-Mar-2012
    **********************************************************************************************/
    FUNCTION tf_get_diag_configurations
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_flg_type  IN diagnosis_dep_clin_serv.flg_type%TYPE,
        i_patient   IN patient.id_patient%TYPE,
        i_episode   IN episode.id_episode%TYPE,
        i_diag_type IN epis_diagnosis.flg_type%TYPE,
        i_complaint IN table_number DEFAULT NULL
    ) RETURN t_coll_diagnosis_config IS
        l_func_name VARCHAR2(30) := 'GET_DIAG_CONFIGURATIONS';
        --
        l_ret   t_coll_diagnosis_config;
        l_error t_error_out;
        --
        l_synonym_list_enable sys_config.value%TYPE;
    
        l_epis_diagnosis  table_number;
        l_diagnosis       table_number;
        l_alert_diagnosis table_number;
        l_desc_detail     table_varchar;
    
        l_tbl_terminologies    table_varchar;
        l_tbl_complaint_diags  table_number;
        l_tbl_complaint_adiags table_number;
        l_tbl_diagnoses        t_coll_diagnosis_config;
    
        l_rows_limit PLS_INTEGER;
    BEGIN
    
        -- enable/disable synonyms in search and reply result sets
        g_error := 'INIT CONFIG PARAMS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_synonym_list_enable := nvl(pk_sysconfig.get_config(g_cfg_synonym_list_enable, i_prof), pk_alert_constant.g_no);
        l_rows_limit          := to_number(nvl(pk_sysconfig.get_config(g_cfg_rows_limit, i_prof), g_def_rows_limit));
    
        g_error := 'GET PREVIOUS PROBLEMS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT pk_problems.get_pat_prob_active_diag(i_lang           => i_lang,
                                                    i_prof           => i_prof,
                                                    i_patient        => i_patient,
                                                    i_episode        => i_episode,
                                                    o_epis_diagnosis => l_epis_diagnosis,
                                                    o_error          => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL GET_DIAG_FROM_EPIS_DIAG';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF NOT get_diag_from_epis_diag(i_lang            => i_lang,
                                       i_prof            => i_prof,
                                       i_episode         => i_episode,
                                       i_epis_diagnosis  => l_epis_diagnosis,
                                       o_diagnosis       => l_diagnosis,
                                       o_alert_diagnosis => l_alert_diagnosis,
                                       o_desc_detail     => l_desc_detail,
                                       o_error           => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        g_error := 'CALL GET_DIAG_TERMINOLOGIES';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_tbl_terminologies := pk_diagnosis_core.get_diag_terminologies(i_lang      => i_lang,
                                                                        i_prof      => i_prof,
                                                                        i_task_type => pk_alert_constant.g_task_diagnosis);
    
        IF i_flg_type = g_filter_complaint
        THEN
        
            IF i_complaint IS NOT NULL
               AND i_complaint.count > 0
            THEN
                g_error := 'GET COMPLAINT DIAGS';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT t.id_diagnosis,
                       pk_api_pfh_diagnosis_in.get_diag_preferred_term_id(i_concept_version => t.id_diagnosis) id_alert_diagnosis
                  BULK COLLECT
                  INTO l_tbl_complaint_diags, l_tbl_complaint_adiags
                  FROM (SELECT DISTINCT cd.id_diagnosis
                          FROM doc_template_diagnosis cd
                         WHERE cd.id_complaint IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                    *
                                                     FROM TABLE(i_complaint) t)
                           AND cd.id_diagnosis NOT IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                        column_value
                                                         FROM TABLE(l_diagnosis) t)
                           AND EXISTS (SELECT 1
                                  FROM diagnosis_ea e
                                  JOIN diagnosis_conf_ea c
                                    ON c.flg_terminology = e.flg_terminology
                                   AND c.id_institution = e.id_institution
                                   AND c.id_software = e.id_software
                                   AND c.id_task_type = pk_alert_constant.g_task_diagnosis
                                 WHERE e.id_institution = i_prof.institution
                                   AND e.id_software = i_prof.software
                                   AND e.flg_msi_concept_term = 'P' --searchable_diags
                                   AND e.flg_diag_type = 'M' --medical_diags
                                   AND e.id_concept_version = cd.id_diagnosis)
                           AND cd.flg_available = pk_alert_constant.g_available) t;
            
                IF l_tbl_complaint_diags.count > 0
                   OR l_tbl_complaint_adiags.count > 0
                THEN
                    g_error := 'GET DIAGNOSES LIST FILTERED BY COMPLAINT DIAGS';
                    pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                    l_tbl_diagnoses := pk_terminology_search.tf_diagnoses_list(i_lang                     => i_lang,
                                                                               i_prof                     => i_prof,
                                                                               i_patient                  => i_patient,
                                                                               i_terminologies_task_types => table_number(pk_alert_constant.g_task_diagnosis),
                                                                               i_term_task_type           => pk_alert_constant.g_task_diagnosis,
                                                                               i_list_type                => pk_diagnosis_core.g_diag_list_searchable,
                                                                               i_synonym_list_enable      => l_synonym_list_enable,
                                                                               i_tbl_diagnosis            => l_tbl_complaint_diags,
                                                                               i_tbl_alert_diagnosis      => l_tbl_complaint_adiags,
                                                                               i_row_limit                => l_rows_limit);
                ELSE
                    l_tbl_diagnoses := t_coll_diagnosis_config();
                END IF;
            
                g_error := 'GET CONFIGURATIONS BY COMPLAINT';
                pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
                SELECT t_rec_diagnosis_config(id_diagnosis            => id_diagnosis,
                                              id_diagnosis_parent     => id_diagnosis_parent,
                                              id_epis_diagnosis       => id_epis_diagnosis,
                                              desc_diagnosis          => desc_diagnosis,
                                              code_icd                => code_icd,
                                              status_diagnosis        => status_diagnosis,
                                              icon_status             => pk_sysdomain.get_img(i_lang,
                                                                                              pk_diagnosis.g_epis_diag_status,
                                                                                              status_diagnosis),
                                              avail_for_select        => decode(di_flg_status,
                                                                                pk_diagnosis.g_ed_flg_status_r,
                                                                                pk_alert_constant.g_yes,
                                                                                pk_diagnosis.g_ed_flg_status_ca,
                                                                                pk_alert_constant.g_yes,
                                                                                NULL,
                                                                                pk_alert_constant.g_yes,
                                                                                pk_alert_constant.g_no),
                                              default_new_status      => nvl(status_diagnosis,
                                                                             pk_diagnosis.g_ed_flg_status_d),
                                              default_new_status_desc => decode(status_diagnosis,
                                                                                NULL,
                                                                                pk_sysdomain.get_domain_cached(i_lang,
                                                                                                               pk_diagnosis.g_ed_flg_status_d,
                                                                                                               pk_diagnosis.g_epis_diag_status),
                                                                                pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status,
                                                                                                        status_diagnosis,
                                                                                                        i_lang)),
                                              flg_other               => flg_other,
                                              id_alert_diagnosis      => id_alert_diagnosis,
                                              desc_epis_diagnosis     => desc_epis_diagnosis,
                                              flg_terminology         => flg_terminology)
                  BULK COLLECT
                  INTO l_ret
                  FROM (SELECT id_diagnosis,
                               id_diagnosis_parent,
                               NULL id_epis_diagnosis,
                               desc_diagnosis,
                               code_icd,
                               nvl2(i_diag_type, pk_diagnosis.get_status_diag(i_episode, id_diagnosis), NULL) status_diagnosis,
                               nvl2(i_diag_type,
                                    pk_diagnosis.get_status_diag(i_episode, id_diagnosis, i_diag_type),
                                    NULL) di_flg_status,
                               id_alert_diagnosis,
                               flg_other,
                               rank,
                               NULL desc_epis_diagnosis,
                               flg_terminology
                          FROM (SELECT DISTINCT dc.id_diagnosis,
                                                dc.id_diagnosis_parent,
                                                dc.desc_diagnosis,
                                                dc.code_icd,
                                                dc.id_alert_diagnosis,
                                                dc.flg_other,
                                                NULL rank,
                                                dc.flg_terminology
                                  FROM TABLE(l_tbl_diagnoses) dc
                                 WHERE rownum > 0) -- dummy condition in order to prevent performance issues
                         WHERE desc_diagnosis IS NOT NULL
                        
                        -- previous diagnosis extracted from the problem list
                        UNION ALL
                        SELECT /*+ use_nl(diag adiag dd d)*/
                         d.id_diagnosis,
                         d.id_diagnosis_parent,
                         NULL id_epis_diagnosis,
                         pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                    i_prof               => i_prof,
                                                    i_id_alert_diagnosis => d.id_alert_diagnosis,
                                                    i_id_diagnosis       => d.id_diagnosis,
                                                    i_code               => d.code_icd,
                                                    i_flg_other          => d.flg_other,
                                                    i_flg_std_diag       => d.flg_icd9,
                                                    i_flg_search_mode    => pk_alert_constant.get_yes) desc_diagnosis,
                         d.code_icd,
                         NULL status_diagnosis,
                         NULL di_flg_status,
                         d.id_alert_diagnosis,
                         d.flg_other,
                         -999 rank,
                         dd.column_value desc_epis_diagnosis,
                         d.flg_type flg_terminology
                          FROM diagnosis_content d
                          JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value, rownum rn
                                 FROM TABLE(l_diagnosis) t) diag
                            ON diag.column_value = d.id_diagnosis
                          JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value, rownum rn
                                 FROM TABLE(l_alert_diagnosis) t) adiag
                            ON adiag.rn = diag.rn
                          JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                column_value, rownum rn
                                 FROM TABLE(l_desc_detail) t) dd
                            ON dd.rn = diag.rn
                         WHERE d.flg_type_dep_clin = pk_diagnosis.g_diag_pesq
                           AND d.id_institution = i_prof.institution
                           AND d.id_software = i_prof.software
                           AND (d.id_alert_diagnosis = adiag.column_value OR
                               (d.flg_icd9 = pk_alert_constant.g_yes AND adiag.column_value IS NULL))
                           AND d.flg_type IN (SELECT /*+opt_estimate(table,tdgc,scale_rows=1))*/
                                               column_value flg_terminology
                                                FROM TABLE(l_tbl_terminologies) tdgc)
                           AND rownum > 0)
                 ORDER BY rank, desc_diagnosis;
            ELSE
                l_ret := t_coll_diagnosis_config();
            END IF;
        ELSIF i_flg_type = g_filter_freq
        THEN
        
            g_error := 'GET MOST FREQ DIAGNOSES LIST';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            l_tbl_diagnoses := pk_terminology_search.tf_diagnoses_list(i_lang                     => i_lang,
                                                                       i_prof                     => i_prof,
                                                                       i_patient                  => i_patient,
                                                                       i_terminologies_task_types => table_number(pk_alert_constant.g_task_diagnosis),
                                                                       i_term_task_type           => pk_alert_constant.g_task_diagnosis,
                                                                       i_list_type                => pk_diagnosis_core.g_diag_list_most_freq,
                                                                       i_synonym_list_enable      => l_synonym_list_enable,
                                                                       i_row_limit                => l_rows_limit);
        
            g_error := 'GET CONFIGURATIONS BY MOST FREQUENT';
            pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
            SELECT t_rec_diagnosis_config(id_diagnosis            => id_diagnosis,
                                          id_diagnosis_parent     => id_diagnosis_parent,
                                          id_epis_diagnosis       => NULL,
                                          desc_diagnosis          => desc_diagnosis,
                                          code_icd                => code_icd,
                                          status_diagnosis        => status_diagnosis,
                                          icon_status             => pk_sysdomain.get_img(i_lang,
                                                                                          pk_diagnosis.g_epis_diag_status,
                                                                                          status_diagnosis),
                                          avail_for_select        => decode(di_flg_status,
                                                                            pk_diagnosis.g_ed_flg_status_r,
                                                                            pk_alert_constant.g_yes,
                                                                            pk_diagnosis.g_ed_flg_status_ca,
                                                                            pk_alert_constant.g_yes,
                                                                            NULL,
                                                                            pk_alert_constant.g_yes,
                                                                            pk_alert_constant.g_no),
                                          default_new_status      => nvl(status_diagnosis, pk_diagnosis.g_ed_flg_status_d),
                                          default_new_status_desc => decode(status_diagnosis,
                                                                            NULL,
                                                                            pk_sysdomain.get_domain_cached(i_lang,
                                                                                                           pk_diagnosis.g_ed_flg_status_d,
                                                                                                           pk_diagnosis.g_epis_diag_status),
                                                                            pk_sysdomain.get_domain(pk_diagnosis.g_epis_diag_status,
                                                                                                    status_diagnosis,
                                                                                                    i_lang)),
                                          flg_other               => flg_other,
                                          id_alert_diagnosis      => id_alert_diagnosis,
                                          desc_epis_diagnosis     => desc_epis_diagnosis,
                                          flg_terminology         => flg_terminology)
              BULK COLLECT
              INTO l_ret
              FROM (SELECT id_diagnosis,
                           id_diagnosis_parent,
                           code_icd,
                           desc_diagnosis,
                           pk_diagnosis.get_status_diag(i_episode, id_diagnosis) status_diagnosis,
                           pk_diagnosis.get_status_diag(i_episode, id_diagnosis, i_diag_type) di_flg_status,
                           id_alert_diagnosis,
                           rank,
                           flg_other,
                           NULL desc_epis_diagnosis,
                           flg_terminology
                      FROM (SELECT a.id_diagnosis,
                                   a.id_diagnosis_parent,
                                   a.desc_diagnosis,
                                   a.code_icd,
                                   a.id_alert_diagnosis,
                                   0 rank,
                                   a.flg_other,
                                   a.flg_terminology
                              FROM (SELECT DISTINCT dc.id_diagnosis,
                                                    dc.id_diagnosis_parent,
                                                    dc.desc_diagnosis,
                                                    dc.code_icd,
                                                    dc.id_alert_diagnosis,
                                                    dc.flg_other,
                                                    dc.flg_terminology
                                      FROM TABLE(l_tbl_diagnoses) dc
                                     WHERE dc.id_diagnosis NOT IN (SELECT /*+ opt_estimate(table t rows=1)*/
                                                                    column_value
                                                                     FROM TABLE(l_diagnosis) t)) a
                            -- previous diagnosis extracted from the problem list
                            UNION ALL
                            
                            SELECT /*+ use_nl(diag adiag dd d)*/
                             d.id_diagnosis,
                             d.id_diagnosis_parent,
                             pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                                        i_prof               => i_prof,
                                                        i_id_alert_diagnosis => d.id_alert_diagnosis,
                                                        i_id_diagnosis       => d.id_diagnosis,
                                                        i_code_diagnosis     => NULL,
                                                        i_diagnosis_language => d.id_language,
                                                        i_code               => d.code_icd,
                                                        i_flg_other          => d.flg_other,
                                                        i_flg_std_diag       => d.flg_icd9,
                                                        i_flg_search_mode    => pk_alert_constant.get_yes) desc_diagnosis,
                             d.code_icd,
                             d.id_alert_diagnosis,
                             -999 rank,
                             d.flg_other,
                             d.flg_type flg_terminology
                              FROM diagnosis_content d
                              JOIN (SELECT diag.id_diagnosis, adiag.id_alert_diagnosis, dd.desc_epis_diagnosis
                                     FROM (SELECT /*+opt_estimate(table t rows=1)*/
                                            column_value id_diagnosis, rownum rn
                                             FROM TABLE(l_diagnosis) t) diag
                                     JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                           column_value id_alert_diagnosis, rownum rn
                                            FROM TABLE(l_alert_diagnosis) t) adiag
                                       ON adiag.rn = diag.rn
                                     JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                                           column_value desc_epis_diagnosis, rownum rn
                                            FROM TABLE(l_desc_detail) t) dd
                                       ON dd.rn = diag.rn) a
                                ON a.id_diagnosis = d.id_diagnosis
                               AND (a.id_alert_diagnosis = d.id_alert_diagnosis OR
                                   (a.id_alert_diagnosis IS NULL AND d.flg_icd9 = pk_alert_constant.g_yes))
                             WHERE d.flg_type_dep_clin = pk_diagnosis.g_diag_pesq
                               AND d.id_institution = i_prof.institution
                               AND d.id_software = i_prof.software
                               AND d.flg_type IN (SELECT /*+opt_estimate(table,tdgc,scale_rows=1))*/
                                                   column_value flg_terminology
                                                    FROM TABLE(l_tbl_terminologies) tdgc))
                     WHERE rownum > 0)
             WHERE desc_diagnosis IS NOT NULL
             ORDER BY rank, desc_diagnosis;
        
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END tf_get_diag_configurations;

    /**********************************************************************************************
    * List the most frequent diagnosis of a specific category
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_patient                Patient id
    * @param i_episode                Episode id
    * @param o_diagnosis              Diagnoses list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/02
    **********************************************************************************************/
    FUNCTION get_freq_diag_cat
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_patient   IN patient.id_patient%TYPE,
        i_episode   IN episode.id_episode%TYPE,
        o_diagnosis OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_FREQ_DIAG_CAT';
        l_prof_cat  category.id_category%TYPE;
        l_tbl_diags t_coll_diagnosis_config;
    BEGIN
        --
        g_error := 'GET CATEGORY';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_prof_cat := pk_prof_utils.get_id_category(i_lang, i_prof);
    
        g_error := 'CALL TF_GET_DIAG_CONFIGURATIONS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_tbl_diags := tf_get_diag_configurations(i_lang      => i_lang,
                                                  i_prof      => i_prof,
                                                  i_flg_type  => g_filter_freq,
                                                  i_patient   => i_patient,
                                                  i_episode   => i_episode,
                                                  i_diag_type => pk_diagnosis.g_diag_type_p);
    
        g_error := 'OPEN O_DIAGNOSIS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN o_diagnosis FOR
            SELECT /*+opt_estimate(table dc rows=30)*/
             *
              FROM TABLE(l_tbl_diags) dc
              JOIN diagnosis_cat dcat
                ON dcat.id_diagnosis = dc.id_diagnosis
             WHERE dcat.id_category = l_prof_cat;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_diagnosis);
            RETURN FALSE;
    END get_freq_diag_cat;

    /**********************************************************************************************
    * Get the diagnosis code 
    *
    * @param i_diagnosis              term/alert_diagnosis ID
    * @param i_institution            institution ID
    * @param i_software               software ID
    *
    * @return                         diagnosis code
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/03/28
    **********************************************************************************************/
    FUNCTION get_term_diagnosis_code
    (
        i_alert_diagnosis IN diagnosis.id_diagnosis%TYPE,
        i_institution     IN institution.id_institution%TYPE,
        i_software        IN software.id_software%TYPE
    ) RETURN diagnosis_ea.concept_code%TYPE IS
    
        l_diagnosis      diagnosis.id_diagnosis%TYPE;
        l_diagnosis_code diagnosis_ea.concept_code%TYPE;
    
    BEGIN
        --
        l_diagnosis      := pk_diagnosis_core.get_term_diagnosis_id(i_alert_diagnosis, i_institution, i_software);
        l_diagnosis_code := pk_diagnosis_core.get_diagnosis_code(l_diagnosis, i_institution, i_software);
    
        RETURN l_diagnosis_code;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_term_diagnosis_code;

    /**********************************************************************************************
    * Get the diagnosis code 
    *
    * @param i_diagnosis              diagnosis ID (corresponding to ID_CONCEPT_VERSION in the new model)
    * @param i_institution            institution ID
    * @param i_software               software ID
    *
    * @return                         diagnosis code
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/03/18
    **********************************************************************************************/
    FUNCTION get_diagnosis_code
    (
        i_diagnosis   IN diagnosis.id_diagnosis%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_software    IN software.id_software%TYPE
    ) RETURN diagnosis_ea.concept_code%TYPE IS
    
        l_diagnosis_code diagnosis_ea.concept_code%TYPE;
    
    BEGIN
        --
        BEGIN
            SELECT DISTINCT concept_code
              INTO l_diagnosis_code
              FROM diagnosis_ea d
             WHERE d.id_concept_version = i_diagnosis
               AND d.id_institution = i_institution
               AND d.id_software = i_software;
        EXCEPTION
            -- record not found on easy access table. Search in all content
            WHEN no_data_found THEN
                SELECT code_icd
                  INTO l_diagnosis_code
                  FROM diagnosis d
                 WHERE d.id_diagnosis = i_diagnosis;
        END;
    
        RETURN l_diagnosis_code;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_diagnosis_code;

    /**********************************************************************************************
    * Get the parent diagnosis (to be used in the views that simultate the old column DIAGNOSIS.ID_DIAGNOSIS_PARENT)
    *
    * @param i_diagnosis              diagnosis ID (corresponding to ID_CONCEPT_VERSION in the new model)
    * @param i_institution            institution ID
    * @param i_software               software ID
    *
    * @return                         diagnosis parent ID
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/07
    **********************************************************************************************/
    FUNCTION get_diagnosis_parent
    (
        i_diagnosis   IN diagnosis.id_diagnosis%TYPE,
        i_institution IN institution.id_institution%TYPE,
        i_software    IN software.id_software%TYPE
    ) RETURN diagnosis.id_diagnosis%TYPE IS
    
        l_diagnosis_parent diagnosis.id_diagnosis%TYPE;
    
    BEGIN
        --
        SELECT id_concept_version_2
          INTO l_diagnosis_parent
          FROM diagnosis_relations_ea dr
         WHERE dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
           AND dr.concept_type_int_name1 = dr.concept_type_int_name2
           AND dr.id_concept_version_1 = i_diagnosis
           AND dr.id_institution = i_institution
           AND dr.id_software = i_software;
    
        RETURN l_diagnosis_parent;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_diagnosis_parent;

    /**********************************************************************************************
    * Get the staging group based on the different staging parameteres
    *
    * @param i_lang                      Language ID
    * @param i_prof                      Object (professional ID, institution ID, software ID)
    * @param i_pfactors                  Prognostic factors
    * @param i_tnm                       Registered TNM
    * @param i_show_sgroup_not_avail_msg Show staging group message not available
    *
    * @return                         staging group description/code/ID
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/19
    **********************************************************************************************/
    FUNCTION get_desc_staging_group
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_pfactors                  IN pk_edis_types.table_in_prog_factor,
        i_tnm                       IN pk_edis_types.rec_in_tnm,
        i_show_sgroup_not_avail_msg IN BOOLEAN DEFAULT FALSE
    ) RETURN pk_edis_types.rec_diag_staging_group IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DESC_STAGING_GROUP';
        l_staging_group pk_edis_types.rec_diag_staging_group;
    
        l_concept_code diagnosis.code_icd%TYPE;
    
        l_flg_type_desc CONSTANT VARCHAR2(1 CHAR) := 'D';
        l_flg_type_code CONSTANT VARCHAR2(1 CHAR) := 'C';
    
        l_id_req_prog_fact_01_value diagnosis.id_diagnosis%TYPE;
        l_id_req_prog_fact_02_value diagnosis.id_diagnosis%TYPE;
        l_id_req_prog_fact_03_value diagnosis.id_diagnosis%TYPE;
        --
        l_id_any_req_prog_fact_01 diagnosis.id_diagnosis%TYPE;
        l_id_any_req_prog_fact_02 diagnosis.id_diagnosis%TYPE;
        l_id_any_req_prog_fact_03 diagnosis.id_diagnosis%TYPE;
        --
        l_id_any_tnm_t diagnosis.id_diagnosis%TYPE;
        l_id_any_tnm_n diagnosis.id_diagnosis%TYPE;
        l_id_any_tnm_m diagnosis.id_diagnosis%TYPE;
        --
        l_pfactor pk_edis_types.rec_in_prog_factor;
    
        l_error t_error_out;
    BEGIN
        --
    
        g_error := 'FETCH REGISTERED REQ_PROG_FACT_01 AND REQ_PROG_FACT_02 AND REQ_PROG_FACT_03';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF i_pfactors IS NOT NULL
           AND i_pfactors.count > 0
        THEN
            FOR i IN 1 .. i_pfactors.count
            LOOP
                l_pfactor := i_pfactors(i);
            
                BEGIN
                    SELECT d.code_icd
                      INTO l_concept_code
                      FROM diagnosis d
                     WHERE d.id_diagnosis = l_pfactor.id_field;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_concept_code := NULL;
                END;
            
                IF l_concept_code = pk_diagnosis_form.g_val_req_prog_fact_01_type
                THEN
                    l_id_req_prog_fact_01_value := l_pfactor.id_value;
                ELSIF l_concept_code = pk_diagnosis_form.g_val_req_prog_fact_02_type
                THEN
                    l_id_req_prog_fact_02_value := l_pfactor.id_value;
                ELSIF l_concept_code = pk_diagnosis_form.g_val_req_prog_fact_03_type
                THEN
                    l_id_req_prog_fact_03_value := l_pfactor.id_value;
                END IF;
            
                IF l_id_req_prog_fact_01_value IS NOT NULL
                   AND l_id_req_prog_fact_02_value IS NOT NULL
                   AND l_id_req_prog_fact_03_value IS NOT NULL
                THEN
                    EXIT;
                END IF;
            END LOOP;
        END IF;
    
        g_error := 'FETCH VALIDATION ANY IDS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_id_any_req_prog_fact_01 := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_req_prog_fact_01_any_type);
        l_id_any_req_prog_fact_02 := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_req_prog_fact_02_any_type);
        l_id_any_req_prog_fact_03 := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_req_prog_fact_03_any_type);
        l_id_any_tnm_t            := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_tnm_t_type);
        l_id_any_tnm_n            := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_tnm_n_type);
        l_id_any_tnm_m            := pk_api_pfh_diagnosis_in.get_concept_validation_any(pk_diagnosis_form.g_tnm_m_type);
    
        g_error := 'GET STAGING GROUP';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        BEGIN
            SELECT id_concept_term,
                   pk_diagnosis.std_diag_desc(i_lang               => i_lang,
                                              i_prof               => i_prof,
                                              i_id_alert_diagnosis => id_concept_term,
                                              i_id_diagnosis       => id_concept_version,
                                              i_code_diagnosis     => code_diagnosis,
                                              i_diagnosis_language => id_language,
                                              i_code               => NULL,
                                              i_flg_other          => flg_other,
                                              i_flg_std_diag       => flg_icd9,
                                              i_flg_search_mode    => pk_alert_constant.g_yes) desc_staging,
                   concept_code
              INTO l_staging_group.id_staging_group,
                   l_staging_group.desc_staging_group,
                   l_staging_group.code_staging_group
              FROM (SELECT DISTINCT d.id_concept_version,
                                    d.id_concept_term,
                                    d.code_diagnosis,
                                    d.id_language,
                                    d.concept_code,
                                    d.flg_other,
                                    d.flg_icd9
                      FROM diagnosis_relations_ea dr
                      JOIN diagnosis_ea d
                        ON d.id_concept_version = dr.id_concept_version_1
                     WHERE dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                       AND dr.concept_type_int_name1 = pk_diagnosis_form.g_stage_group_type
                       AND dr.concept_type_int_name2 = pk_diagnosis_form.g_validation_any_type
                       AND dr.id_institution = i_prof.institution
                       AND dr.id_software = i_prof.software
                       AND d.id_institution = i_prof.institution
                       AND d.id_software = i_prof.software
                          -- tnm_t
                       AND EXISTS (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_tnm_t_type
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (i_tnm.t, l_id_any_tnm_t)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software)
                          -- tnm_n
                       AND EXISTS (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_tnm_n_type
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (i_tnm.n, l_id_any_tnm_n)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software)
                          -- tnm_m
                       AND EXISTS (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_tnm_m_type
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (i_tnm.m, l_id_any_tnm_m)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software)
                          -- REQ_PROG_FACT_01
                       AND EXISTS
                     (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_pfactors_staging
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (l_id_req_prog_fact_01_value, l_id_any_req_prog_fact_01)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software)
                          -- REQ_PROG_FACT_02
                       AND EXISTS
                     (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_pfactors_staging
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (l_id_req_prog_fact_02_value, l_id_any_req_prog_fact_02)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software)
                          -- REQ_PROG_FACT_03
                       AND EXISTS
                     (SELECT 0
                              FROM diagnosis_relations_ea dr2
                             WHERE dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_depends_on
                               AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_validation_any_type
                               AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_pfactors_staging
                               AND dr2.id_concept_version_1 = dr.id_concept_version_2
                               AND dr2.id_concept_version_2 IN (l_id_req_prog_fact_03_value, l_id_any_req_prog_fact_03)
                               AND dr2.id_institution = i_prof.institution
                               AND dr2.id_software = i_prof.software));
        EXCEPTION
            WHEN no_data_found THEN
                IF i_show_sgroup_not_avail_msg
                THEN
                    l_staging_group.desc_staging_group := pk_message.get_message(i_lang      => i_lang,
                                                                                 i_code_mess => g_code_stag_group_not_avail);
                END IF;
        END;
    
        RETURN l_staging_group;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_desc_staging_group;

    /**********************************************************************************************
    * Get the staging group based on the different staging parameteres
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_tnm                    Registered TNM
    *
    * @return                         tnm description
    *
    * @author                         José Silva
    * @version                        1.0
    * @since                          2012/03/19
    **********************************************************************************************/
    FUNCTION get_desc_tnm
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_tnm             IN pk_edis_types.rec_in_tnm,
        i_flg_mult_tumors IN epis_diagnosis.flg_mult_tumors%TYPE,
        i_num_prim_tumors IN epis_diagnosis.num_primary_tumors%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DESC_TNM';
        l_desc_tnm pk_translation.t_desc_translation;
    
        l_code_t diagnosis.code_icd%TYPE;
        l_code_n diagnosis.code_icd%TYPE;
        l_code_m diagnosis.code_icd%TYPE;
    
        l_code_mult_tumors VARCHAR(10 CHAR);
        l_code_unk_tumors CONSTANT VARCHAR2(1 CHAR) := 'm';
    
    BEGIN
        --
        g_error := 'GET TNM CODES';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF i_tnm.t IS NOT NULL
        THEN
            l_code_t := get_diagnosis_code(i_tnm.t, i_prof.institution, i_prof.software);
            l_code_n := get_diagnosis_code(i_tnm.n, i_prof.institution, i_prof.software);
            l_code_m := get_diagnosis_code(i_tnm.m, i_prof.institution, i_prof.software);
        END IF;
    
        g_error := 'GET CODE MULT TUMORS';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        IF i_flg_mult_tumors = pk_alert_constant.g_yes
        THEN
            IF i_num_prim_tumors IS NOT NULL
            THEN
                l_code_mult_tumors := '(' || i_num_prim_tumors || ')';
            ELSE
                l_code_mult_tumors := '(' || l_code_unk_tumors || ')';
            END IF;
        END IF;
    
        g_error := 'GET FORMATTED TNM DESCRIPTION';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_desc_tnm := pk_utils.append_str_if_not_null(CASE
                                                          WHEN i_tnm.code_stage_t IS NOT NULL
                                                               OR l_code_t IS NOT NULL THEN
                                                           i_tnm.code_stage_t || l_code_t || l_code_mult_tumors
                                                          ELSE
                                                           NULL
                                                      END,
                                                      ' ') ||
                      pk_utils.append_str_if_not_null(i_tnm.code_stage_n || l_code_n, ' ') || i_tnm.code_stage_m ||
                      l_code_m;
    
        RETURN l_desc_tnm;
    
    END get_desc_tnm;

    /**********************************************************************************************
    * Get the staging info based on the different staging parameteres
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_staging_basis          Staging basis ID
    * @param i_desc_tnm               TNM description
    * @param i_desc_staging_group     Staging group description
    *
    * @return                         tnm description
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/03/19
    **********************************************************************************************/
    FUNCTION get_desc_staging_info
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_staging_basis      IN diagnosis.id_diagnosis%TYPE,
        i_desc_tnm           IN VARCHAR2,
        i_desc_staging_group IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DESC_STAGING_INFO';
        l_desc_staging pk_translation.t_desc_translation;
    
    BEGIN
        --
        g_error := 'GET FORMATTED STAGING INFO';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        BEGIN
            SELECT pk_diagnosis.std_staging_basis_desc(i_lang               => i_lang,
                                                       i_prof               => i_prof,
                                                       i_id_diagnosis       => ad.id_diagnosis,
                                                       i_diagnosis_language => ad.id_language,
                                                       i_code               => NULL,
                                                       i_flg_other          => pk_alert_constant.g_no,
                                                       i_flg_std_diag       => ad.flg_icd9,
                                                       i_flg_search_mode    => pk_alert_constant.g_yes,
                                                       i_show_full_desc     => pk_alert_constant.g_yes)
              INTO l_desc_staging
              FROM alert_diagnosis ad
             WHERE ad.id_diagnosis = i_staging_basis
               AND rownum < 2;
        EXCEPTION
            WHEN no_data_found THEN
                l_desc_staging := NULL;
        END;
    
        l_desc_staging := l_desc_staging || ' ' || i_desc_tnm || ' ' || i_desc_staging_group;
    
        RETURN l_desc_staging;
    
    END get_desc_staging_info;

    /********************************************************************************************
    * Gets the options available in the diagnosis filter
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_patient                Patient ID
    * @param i_episode                Episode ID
    * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param o_options                Filter options
    * @param o_error                  Error message
    *                        
    * @return                         true or false on success or error
    * 
    * @author                         José Silva
    * @version                        1.0   
    * @since                          2011/01/26
    **********************************************************************************************/
    FUNCTION get_diag_filter_options
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_patient  IN patient.id_patient%TYPE,
        i_episode  IN episode.id_episode%TYPE,
        i_flg_type IN VARCHAR2,
        o_options  OUT pk_types.cursor_type,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_subj_diag_filter        CONSTANT action.subject%TYPE := 'DIAGNOSIS_FILTER';
        l_subj_final_diag_filter  CONSTANT action.subject%TYPE := 'FINAL_DIAGNOSIS_FILTER';
        l_subj_mcdt_diag_filter   CONSTANT action.subject%TYPE := 'MCDT_DIAGNOSIS_FILTER';
        l_subj_interv_diag_filter CONSTANT action.subject%TYPE := 'INTERVENTION_DIAGNOSIS_FILTER';
        l_problems_label sys_message.desc_message%TYPE;
    
        l_flg_type_f CONSTANT VARCHAR2(1 CHAR) := 'F'; -- mcdt filter
        l_flg_type_i CONSTANT VARCHAR2(1 CHAR) := 'I'; -- interventions filter 
    
        l_subj_diagnosis action.subject%TYPE;
    
        l_epis_diagnosis  table_number;
        l_diagnosis       table_number;
        l_alert_diagnosis table_number;
        l_desc_detail     table_varchar;
        l_count_diagnosis NUMBER := 0;
    
    BEGIN
    
        g_error := 'GET SUBJECT';
        IF i_flg_type = pk_diagnosis.g_diag_type_p
        THEN
            l_subj_diagnosis := l_subj_diag_filter;
        ELSIF i_flg_type = pk_diagnosis.g_diag_type_d
        THEN
            l_subj_diagnosis := l_subj_final_diag_filter;
        ELSIF i_flg_type = l_flg_type_f
        THEN
            l_subj_diagnosis := l_subj_mcdt_diag_filter;
        ELSIF i_flg_type = l_flg_type_i
        THEN
            l_subj_diagnosis := l_subj_interv_diag_filter;
        END IF;
    
        g_error := 'GET PREVIOUS PROBLEMS';
        IF i_patient IS NOT NULL
        THEN
            IF NOT pk_problems.get_pat_prob_active_diag(i_lang           => i_lang,
                                                        i_prof           => i_prof,
                                                        i_patient        => i_patient,
                                                        i_episode        => i_episode,
                                                        o_epis_diagnosis => l_epis_diagnosis,
                                                        o_error          => o_error)
            THEN
                RAISE g_exception;
            END IF;
        
            IF NOT get_diag_from_epis_diag(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_episode         => i_episode,
                                           i_epis_diagnosis  => l_epis_diagnosis,
                                           o_diagnosis       => l_diagnosis,
                                           o_alert_diagnosis => l_alert_diagnosis,
                                           o_desc_detail     => l_desc_detail,
                                           o_error           => o_error)
            THEN
                RAISE g_exception;
            END IF;
        END IF;
    
        IF l_diagnosis IS NOT NULL
        THEN
            l_count_diagnosis := l_diagnosis.count;
            l_problems_label  := pk_message.get_message(i_lang, i_prof, 'DIAGNOSIS_M035');
        END IF;
    
        g_error := 'GET ACTIONS';
        OPEN o_options FOR
            SELECT act.id_action,
                   act.id_parent,
                   act.level_nr AS "LEVEL",
                   act.from_state,
                   act.to_state,
                   decode(l_count_diagnosis,
                          0,
                          act.desc_action,
                          decode(act.from_state,
                                 g_filter_complaint,
                                 l_problems_label || ' / ' || act.desc_action,
                                 g_filter_freq,
                                 l_problems_label || ' / ' || act.desc_action,
                                 act.desc_action)) desc_action,
                   act.icon,
                   act.flg_default,
                   act.action,
                   act.flg_active
              FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, l_subj_diagnosis, NULL)) act;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_DIAG_FILTER_OPTIONS',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_options);
            RETURN FALSE;
    END get_diag_filter_options;

    /********************************************************************************************
    * Gets the related diagnosis associated with the diagnosis note
    *
    * @param i_lang                   Language ID
    * @param i_prof                   Object (professional ID, institution ID, software ID)
    * @param i_episode                Episode ID
    * @param i_dt_diag_notes          Diagnoses notes ID
    *                        
    * @return                         true or false on success or error
    * 
    * @author                         José Silva
    * @version                        2.6.2.1  
    * @since                          2012-Mar-23
    **********************************************************************************************/
    FUNCTION get_note_associated_diags
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_flg_type      IN epis_diagnosis.flg_type%TYPE,
        i_dt_diag_notes IN epis_diagnosis_notes.dt_create%TYPE
    ) RETURN VARCHAR2 IS
    
        l_diagnosis_list pk_translation.t_desc_translation;
        l_error          t_error_out;
    
        CURSOR c_diags IS
            WITH aux_query AS
             (SELECT DISTINCT ed.id_diagnosis, ed.id_alert_diagnosis, ed.desc_epis_diagnosis
                FROM epis_diagnosis ed
               WHERE ed.id_episode = i_episode
                 AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
                 AND pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                        i_prof,
                                                        flg_status,
                                                        dt_epis_diagnosis_tstz,
                                                        dt_confirmed_tstz,
                                                        dt_cancel_tstz,
                                                        dt_base_tstz,
                                                        dt_rulled_out_tstz) < i_dt_diag_notes)
            SELECT pk_diagnosis.std_diag_desc(i_lang,
                                              i_prof,
                                              i_id_alert_diagnosis  => aux_query.id_alert_diagnosis,
                                              i_id_diagnosis        => aux_query.id_diagnosis,
                                              i_desc_epis_diagnosis => aux_query.desc_epis_diagnosis,
                                              i_code                => d.code_icd,
                                              i_flg_other           => d.flg_other,
                                              i_flg_std_diag        => ad.flg_icd9) diag_desc
              FROM aux_query
              JOIN diagnosis d
                ON d.id_diagnosis = aux_query.id_diagnosis
              LEFT JOIN alert_diagnosis ad
                ON ad.id_alert_diagnosis = aux_query.id_alert_diagnosis;
    
    BEGIN
    
        g_error := 'GET_NOTE_ASSOCIATED_DIAGS';
        FOR r_diag IN c_diags
        LOOP
            l_diagnosis_list := pk_utils.append_str_if_not_null(l_diagnosis_list, '; ') || r_diag.diag_desc;
        END LOOP;
    
        l_diagnosis_list := pk_utils.append_str_if_not_null(l_diagnosis_list, '; ');
    
        RETURN l_diagnosis_list;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_NOTE_ASSOCIATED_DIAGS',
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_note_associated_diags;

    /**********************************************************************************************
    * Get the diagnosis ID of a specific term
    *
    * @param i_alert_diagnosis        alert_diagnosis/term ID
    * @param i_institution            institution ID
    * @param i_software               software ID
    *
    * @return                         diagnosis ID
    *
    * @author                         José Silva
    * @version                        2.6.2.1
    * @since                          2012/03/26
    **********************************************************************************************/
    FUNCTION get_term_diagnosis_id
    (
        i_alert_diagnosis IN alert_diagnosis.id_alert_diagnosis%TYPE,
        i_institution     IN institution.id_institution%TYPE,
        i_software        IN software.id_software%TYPE
    ) RETURN diagnosis.id_diagnosis%TYPE IS
    
        l_diagnosis diagnosis.id_diagnosis%TYPE;
    
    BEGIN
        --
        BEGIN
            SELECT id_concept_version
              INTO l_diagnosis
              FROM diagnosis_ea d
             WHERE d.id_concept_term = i_alert_diagnosis
               AND d.id_institution = i_institution
               AND d.id_software = i_software
               AND d.flg_msi_concept_term = pk_diagnosis.g_diag_pesq;
        EXCEPTION
            -- record not found on easy access table. Search in all content
            WHEN no_data_found THEN
                SELECT ad.id_diagnosis
                  INTO l_diagnosis
                  FROM alert_diagnosis ad
                 WHERE ad.id_alert_diagnosis = i_alert_diagnosis;
        END;
    
        RETURN l_diagnosis;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_term_diagnosis_id;

    /**********************************************************************************************
    * get actions of the diagnosis general notes
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_task_request           task request id (monitorization id)
    * @param       o_actions                actions cursor info 
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Sofia Mendes
    * @version                              2.6.2
    * @since                                26-Mar-2012
    **********************************************************************************************/
    FUNCTION get_actions
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_request IN epis_diagnosis_notes.id_epis_diagnosis_notes%TYPE,
        o_actions      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        g_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
        pk_alertlog.log_debug(g_error);
        OPEN o_actions FOR
            SELECT id_action,
                   id_parent,
                   level_nr,
                   from_state,
                   to_state,
                   desc_action,
                   icon,
                   flg_default,
                   flg_active,
                   action
              FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, 'DIAGNOSIS', NULL)) act;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_ACTIONS',
                                              o_error);
            RETURN FALSE;
    END get_actions;

    /**********************************************************************************************
    * get actions of the final diagnosis 
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_task_request           task request id (epis_diagnosis)
    * @param       o_actions                actions cursor info 
    * @param       o_error                  error message
    *
    * @return      boolean                  true on success, otherwise false
    *
    * @author                               Sofia Mendes
    * @version                              2.6.3
    * @since                                29-Nov-2012
    **********************************************************************************************/
    FUNCTION get_actions_final_diags
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_request IN epis_diagnosis.id_epis_diagnosis%TYPE,
        o_actions      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_flg_status epis_diagnosis.flg_status%TYPE;
    BEGIN
    
        g_error := 'get flg_status i_id_epis_diagnosis: ' || i_task_request;
        pk_alertlog.log_debug(g_error);
        BEGIN
            SELECT ed.flg_status
              INTO l_flg_status
              FROM epis_diagnosis ed
             WHERE ed.id_epis_diagnosis = i_task_request
               AND ed.flg_status = pk_diagnosis.g_ed_flg_status_ca;
        EXCEPTION
            WHEN no_data_found THEN
                l_flg_status := pk_alert_constant.g_active;
        END;
    
        g_error := 'CALL PK_ACTION.TF_GET_ACTIONS';
        pk_alertlog.log_debug(g_error);
        OPEN o_actions FOR
            SELECT id_action,
                   id_parent,
                   level_nr,
                   from_state,
                   to_state,
                   desc_action,
                   icon,
                   flg_default,
                   flg_active,
                   action
              FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, 'DIAGNOSIS_FINAL', l_flg_status)) act;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_ACTIONS_FINAL_DIAGS',
                                              o_error);
            RETURN FALSE;
    END get_actions_final_diags;

    /**********************************************************************************************
    * Return record diagnosis
    *
    * @param       i_rec_epis_diag          Epis diagnosis record
    *
    * @return      t_table_diagnosis        Diagnosis table
    *
    * @author                               Alexandre Santos
    * @version                              2.6.2.1
    * @since                                03-04-2012
    **********************************************************************************************/
    FUNCTION tf_diagnosis(i_rec_epis_diag IN pk_edis_types.rec_in_epis_diagnosis) RETURN t_table_diagnoses IS
        l_func_name CONSTANT VARCHAR2(30) := 'TF_DIAGNOSIS';
        --
        l_tbl_diag t_table_diagnoses := t_table_diagnoses();
    BEGIN
        IF i_rec_epis_diag.tbl_diagnosis IS NOT NULL
           AND i_rec_epis_diag.tbl_diagnosis.count > 0
        THEN
            FOR i IN i_rec_epis_diag.tbl_diagnosis.first .. i_rec_epis_diag.tbl_diagnosis.last
            LOOP
                l_tbl_diag.extend;
                l_tbl_diag(l_tbl_diag.count) := t_rec_diagnosis(id_diagnosis        => i_rec_epis_diag.tbl_diagnosis(i).id_diagnosis,
                                                                id_alert_diagnosis  => i_rec_epis_diag.tbl_diagnosis(i).id_alert_diagnosis,
                                                                desc_epis_diagnosis => i_rec_epis_diag.tbl_diagnosis(i).desc_diagnosis);
            END LOOP;
        END IF;
    
        RETURN l_tbl_diag;
    END tf_diagnosis;

    /**********************************************************************************************
    * get a existing id_epis_diagnosis according to the input parameters
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                Episode id
    * @param       i_diagnosis              Diagnosis id
    * @param       i_desc_diag              Diagnosis description
    * @param       i_flg_type               Diagnosis type
    *
    * @return      boolean                  id_epis_diagnosis if exists; otherwise NULL
    *
    * @author                               Alexandre Santos
    * @version                              2.6.2
    * @since                                27-06-2012
    **********************************************************************************************/
    FUNCTION get_existing_epis_diag
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        i_diagnosis IN epis_diagnosis.id_diagnosis%TYPE,
        i_desc_diag IN epis_diagnosis.desc_epis_diagnosis%TYPE,
        i_flg_type  IN epis_diagnosis.flg_type%TYPE
    ) RETURN epis_diagnosis.id_epis_diagnosis%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EXISTING_EPIS_DIAG';
        --
        l_flg_cancer_diag VARCHAR2(1);
        r_existing_diag   c_existing_diag%ROWTYPE;
    BEGIN
        g_error := 'CALL PK_DIAGNOSIS_CORE.CHECK_DIAG_CANCER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        l_flg_cancer_diag := pk_diagnosis_core.check_diag_cancer(i_lang         => i_lang,
                                                                 i_prof         => i_prof,
                                                                 i_concept_type => NULL,
                                                                 i_diagnosis    => i_diagnosis);
    
        g_error := 'GET FINAL DIAGNOSIS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_existing_diag(i_lang                => i_lang,
                             i_prof                => i_prof,
                             i_episode             => i_episode,
                             i_diagnosis           => i_diagnosis,
                             i_flg_type            => i_flg_type,
                             i_desc_diag           => i_desc_diag,
                             i_flg_cancer_diag     => l_flg_cancer_diag,
                             i_diagnosis_condition => NULL,
                             i_sub_analysis        => NULL,
                             i_anatomical_area     => NULL,
                             i_anatomical_side     => NULL);
        FETCH c_existing_diag
            INTO r_existing_diag;
        CLOSE c_existing_diag;
    
        RETURN r_existing_diag.id_epis_diagnosis;
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  l_error);
            END;
        
            RETURN NULL;
    END get_existing_epis_diag;

    /**********************************************************************************************
    * Gets an existing id_epis_diagnosis according to the given description and flg_type
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_episode                Episode id
    * @param       i_desc_diag              Diagnosis description
    * @param       i_flg_type               Diagnosis type
    *
    * @return      boolean                  id_epis_diagnosis if exists; otherwise NULL
    *
    **********************************************************************************************/
    FUNCTION get_existing_epis_diag
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        i_desc_diag IN epis_diagnosis.desc_epis_diagnosis%TYPE,
        i_flg_type  IN epis_diagnosis.flg_type%TYPE
    ) RETURN epis_diagnosis.id_epis_diagnosis%TYPE IS
    
        CURSOR c_epis_diag
        (
            i_lang                IN language.id_language%TYPE,
            i_prof                IN profissional,
            i_episode             IN episode.id_episode%TYPE,
            i_alert_diagnosis     IN epis_diagnosis.id_alert_diagnosis%TYPE DEFAULT NULL,
            i_flg_type            IN epis_diagnosis.flg_type%TYPE,
            i_desc_diag           IN epis_diagnosis.desc_epis_diagnosis%TYPE,
            i_flg_cancer_diag     IN VARCHAR2,
            i_diagnosis_condition IN epis_diagnosis.id_diagnosis_condition%TYPE,
            i_sub_analysis        IN epis_diagnosis.id_sub_analysis%TYPE,
            i_anatomical_area     IN epis_diagnosis.id_anatomical_area%TYPE,
            i_anatomical_side     IN epis_diagnosis.id_anatomical_side%TYPE
        ) IS
            SELECT ed.id_epis_diagnosis,
                   pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                      i_prof,
                                                      ed.flg_status,
                                                      ed.dt_epis_diagnosis_tstz,
                                                      ed.dt_confirmed_tstz,
                                                      ed.dt_cancel_tstz,
                                                      ed.dt_base_tstz,
                                                      ed.dt_rulled_out_tstz) dt_diagnosis,
                   ed.flg_status,
                   ed.flg_final_type,
                   ed.flg_add_problem
              FROM epis_diagnosis ed
              JOIN diagnosis d
                ON d.id_diagnosis = ed.id_diagnosis
             WHERE ed.id_episode = i_episode
               AND ((ed.flg_type = i_flg_type AND ed.flg_status != pk_diagnosis.g_diag_type_b) OR
                   ed.flg_status = pk_diagnosis.g_diag_type_b)
               AND ((upper(get_alert_diag_desc(i_lang               => i_lang,
                                               i_prof               => i_prof,
                                               i_id_alert_diagnosis => ed.id_alert_diagnosis,
                                               i_code_diagnosis     => NULL,
                                               i_diagnosis_language => i_lang,
                                               i_id_task_type       => NULL)) LIKE ('%' || upper(i_desc_diag) || '%') AND
                   nvl(d.flg_other, pk_alert_constant.g_no) = pk_alert_constant.g_no) OR
                   (upper(ed.desc_epis_diagnosis) LIKE upper('%' || i_desc_diag || '%') AND
                   nvl(d.flg_other, pk_alert_constant.g_no) = pk_alert_constant.g_yes))
               AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca
               AND nvl(ed.id_diagnosis_condition, g_null_replace_value) =
                   nvl(i_diagnosis_condition, g_null_replace_value)
               AND nvl(ed.id_sub_analysis, g_null_replace_value) = nvl(i_sub_analysis, g_null_replace_value)
               AND nvl(ed.id_anatomical_area, g_null_replace_value) = nvl(i_anatomical_area, g_null_replace_value)
               AND nvl(ed.id_anatomical_side, g_null_replace_value) = nvl(i_anatomical_side, g_null_replace_value);
    
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EXISTING_EPIS_DIAG';
        --
        l_flg_cancer_diag VARCHAR2(1);
        r_epis_diag       c_epis_diag%ROWTYPE;
    
    BEGIN
        g_error := 'CALL PK_DIAGNOSIS_CORE.CHECK_DIAG_CANCER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        g_error := 'GET FINAL DIAGNOSIS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        OPEN c_epis_diag(i_lang                => i_lang,
                         i_prof                => i_prof,
                         i_episode             => i_episode,
                         i_flg_type            => i_flg_type,
                         i_desc_diag           => i_desc_diag,
                         i_flg_cancer_diag     => pk_alert_constant.g_no,
                         i_diagnosis_condition => NULL,
                         i_sub_analysis        => NULL,
                         i_anatomical_area     => NULL,
                         i_anatomical_side     => NULL);
        FETCH c_epis_diag
            INTO r_epis_diag;
        CLOSE c_epis_diag;
    
        RETURN r_epis_diag.id_epis_diagnosis;
    EXCEPTION
        WHEN OTHERS THEN
            DECLARE
                l_error t_error_out;
            BEGIN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_owner,
                                                  g_package,
                                                  l_func_name,
                                                  l_error);
            END;
        
            RETURN NULL;
    END get_existing_epis_diag;

    /**********************************************************************************************
    * get the professional that created the diagnosis
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_id_epis_diagnosis      diagnosis
    *
    * @return      profissional             professional that created diagnosis
    *
    * @author                               Elisabete Bugalho
    * @version                              2.6.3
    * @since                                21-01-2013
    **********************************************************************************************/

    FUNCTION get_prof_create_diagnosis
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE
    ) RETURN epis_diagnosis.id_professional_diag%TYPE IS
    
        l_id_professional     epis_diagnosis.id_professional_diag%TYPE;
        l_epis_diagnosis_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    BEGIN
        BEGIN
            SELECT a.id_professional
              INTO l_id_professional
              FROM (SELECT edh.id_professional, row_number() over(ORDER BY edh.dt_creation_tstz) line_number
                      FROM epis_diagnosis_hist edh
                     WHERE edh.id_epis_diagnosis = i_id_epis_diagnosis) a
             WHERE a.line_number = 1;
        
        EXCEPTION
            WHEN no_data_found THEN
                SELECT pk_diagnosis_core.get_prof_diagnosis(i_lang                => NULL,
                                                            i_prof                => NULL,
                                                            i_flg_status          => ed.flg_status,
                                                            i_professional_diag   => ed.id_professional_diag,
                                                            i_prof_confirmed      => ed.id_prof_confirmed,
                                                            i_professional_cancel => ed.id_professional_cancel,
                                                            i_prof_base           => ed.id_prof_base,
                                                            i_prof_rulled_out     => ed.id_prof_rulled_out)
                  INTO l_id_professional
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = i_id_epis_diagnosis;
            
        END;
        RETURN l_id_professional;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_prof_create_diagnosis;

    /**********************************************************************************************
    * get the creaded diagnosis date
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_id_epis_diagnosis      diagnosis
    *
    * @return      profissional             professional that created diagnosis
    *
    * @author                               Elisabete Bugalho
    * @version                              2.6.3
    * @since                                21-01-2013
    **********************************************************************************************/

    FUNCTION get_dt_create_diagnosis
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE
    ) RETURN epis_diagnosis.dt_epis_diagnosis_tstz%TYPE IS
    
        l_dt_create           epis_diagnosis.dt_epis_diagnosis_tstz%TYPE;
        l_epis_diagnosis_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    BEGIN
        BEGIN
            SELECT a.dt_creation_tstz
              INTO l_dt_create
              FROM (SELECT edh.dt_creation_tstz, row_number() over(ORDER BY edh.dt_creation_tstz) line_number
                      FROM epis_diagnosis_hist edh
                     WHERE edh.id_epis_diagnosis = i_id_epis_diagnosis) a
             WHERE a.line_number = 1;
        
        EXCEPTION
            WHEN no_data_found THEN
                SELECT pk_diagnosis_core.get_dt_diagnosis(i_lang              => NULL,
                                                          i_prof              => NULL,
                                                          i_flg_status        => ed.flg_status,
                                                          i_dt_epis_diagnosis => ed.dt_epis_diagnosis_tstz,
                                                          i_dt_confirmed      => ed.dt_confirmed_tstz,
                                                          i_dt_cancel         => ed.dt_cancel_tstz,
                                                          i_dt_base           => ed.dt_base_tstz,
                                                          i_dt_rulled_out     => ed.dt_rulled_out_tstz)
                  INTO l_dt_create
                  FROM epis_diagnosis ed
                 WHERE ed.id_epis_diagnosis = i_id_epis_diagnosis;
            
        END;
        RETURN l_dt_create;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_dt_create_diagnosis;

    /**********************************************************************************************
    * checks if a given diagnosis was registered in previous episodes
    *
    * @param       i_lang                   preferred language id for this professional
    * @param       i_prof                   professional type
    * @param       i_patient                patient id
    * @param       i_episode                episode id   
    * @param       i_id_diagnosis           diagnosis id
    * @param       i_id_alert_diagnosis     id alert diagnosis
    *
    * @return      profissional            Y/N
    *
    * @author                               Elisabete Bugalho
    * @version                              2.6.3
    * @since                                25-01-2013
    **********************************************************************************************/

    FUNCTION check_previous_diagnosis
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_patient            IN epis_diagnosis.id_patient%TYPE,
        i_episode            IN episode.id_episode%TYPE,
        i_id_diagnosis       IN diagnosis.id_diagnosis%TYPE,
        i_id_alert_diagnosis IN epis_diagnosis.id_alert_diagnosis%TYPE
    ) RETURN VARCHAR2 IS
        l_count NUMBER;
    BEGIN
    
        SELECT COUNT(1)
          INTO l_count
          FROM epis_diagnosis ed
        
          JOIN episode e
            ON ed.id_episode = e.id_episode
         WHERE ed.id_patient = i_patient
           AND e.id_institution = i_prof.institution
           AND ed.id_diagnosis = i_id_diagnosis
              --        AND ed.id_alert_diagnosis = i_id_alert_diagnosis
           AND e.dt_begin_tstz < (SELECT dt_begin_tstz
                                    FROM episode
                                   WHERE id_episode = i_episode)
           AND ed.flg_status IN
               (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_co, pk_diagnosis.g_ed_flg_status_b);
    
        IF l_count > 0
        THEN
            RETURN pk_alert_constant.g_yes;
        ELSE
        
            RETURN pk_alert_constant.g_no;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_constant.g_no;
    END check_previous_diagnosis;

    /**********************************************************************************************
    * List all diagnosis registered in an episode
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_episode                Episode id
    * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param i_criteria               search criteria
    * @param i_format_text            
    *
    * @return                         Diagnoses list
    *
    * @author                               Elisabete Bugalho
    * @version                              2.6.3
    * @since                                21-01-2013
    **********************************************************************************************/
    FUNCTION tb_get_epis_diagnosis_list
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_patient               IN patient.id_patient%TYPE DEFAULT NULL,
        i_id_scope              IN episode.id_episode%TYPE,
        i_flg_scope             IN VARCHAR2,
        i_flg_type              IN epis_diagnosis.flg_type%TYPE,
        i_criteria              IN VARCHAR2,
        i_format_text           IN VARCHAR2,
        i_translation_desc_only IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_tbl_status            IN table_varchar DEFAULT NULL
    ) RETURN t_coll_episode_diagnosis IS
    
        l_diagnosis   t_coll_episode_diagnosis;
        l_error       t_error_out;
        l_tbl_episode table_number := table_number();
        l_tbl_status  table_varchar;
        l_tbl_type    table_varchar;
    
    BEGIN
        IF i_tbl_status.exists(1)
        THEN
            l_tbl_status := i_tbl_status;
        ELSE
        
            SELECT sd.val
              BULK COLLECT
              INTO l_tbl_status
              FROM sys_domain sd
             WHERE sd.code_domain = 'EPIS_DIAGNOSIS.FLG_STATUS'
               AND sd.domain_owner = pk_sysdomain.k_default_schema
               AND sd.flg_available = pk_alert_constant.g_yes
               AND sd.id_language = i_lang;
        END IF;
    
        IF i_flg_type IS NULL
        THEN
            l_tbl_type := table_varchar(pk_diagnosis.g_diag_type_p, pk_diagnosis.g_diag_type_d);
        ELSE
            l_tbl_type := table_varchar(i_flg_type);
        END IF;
    
        IF i_flg_scope = pk_diagnosis_core.g_scope_visit
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_patient,
                                                         i_id_episode        => NULL,
                                                         i_id_visit          => i_id_scope,
                                                         i_flg_visit_or_epis => i_flg_scope);
        ELSIF i_flg_scope = pk_diagnosis_core.g_scope_episode
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_patient,
                                                         i_id_episode        => i_id_scope,
                                                         i_id_visit          => NULL,
                                                         i_flg_visit_or_epis => i_flg_scope);
        ELSIF i_flg_scope = pk_diagnosis_core.g_scope_patient
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_id_scope,
                                                         i_id_episode        => NULL,
                                                         i_id_visit          => NULL,
                                                         i_flg_visit_or_epis => i_flg_scope);
        END IF;
    
        IF i_criteria IS NOT NULL -- search criteria
        THEN
        
            SELECT t_rec_episode_diagnosis(ed2.id_epis_diagnosis,
                                           id_diagnosis,
                                           id_alert_diagnosis,
                                           desc_diagnosis,
                                           dt_initial,
                                           pk_date_utils.dt_chr_tsz(i_lang, dt_initial, i_prof),
                                           flg_status,
                                           pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', flg_status, i_lang),
                                           dt_diagnosis,
                                           pk_date_utils.date_char_tsz(i_lang,
                                                                       dt_diagnosis,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                                           id_professional,
                                           pk_prof_utils.get_name_signature(i_lang, i_prof, id_professional),
                                           pk_prof_utils.get_spec_signature(i_lang,
                                                                            i_prof,
                                                                            id_professional,
                                                                            dt_diagnosis,
                                                                            ed2.id_episode),
                                           flg_type,
                                           has_previous,
                                           notes,
                                           flg_other,
                                           id_content,
                                           rank,
                                           ed2.id_episode)
              BULK COLLECT
              INTO l_diagnosis
              FROM (SELECT /*+ opt_estimate(table tf rows=1) */ ed.id_epis_diagnosis,
                           pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                           d.id_diagnosis,
                           ed.id_alert_diagnosis,
                           decode(i_translation_desc_only,
                                  pk_alert_constant.g_yes,
                                  get_alert_diag_desc(i_lang               => i_lang,
                                                      i_prof               => i_prof,
                                                      i_id_alert_diagnosis => ad.id_alert_diagnosis,
                                                      i_code_diagnosis     => ad.code_alert_diagnosis,
                                                      i_diagnosis_language => pk_ts1_api.get_id_language(i_lang,
                                                                                                         d.id_terminology_version),
                                                      i_id_task_type       => pk_alert_constant.g_task_diagnosis),
                                  pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                             i_prof                => i_prof,
                                                             i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                             i_id_diagnosis        => d.id_diagnosis,
                                                             i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                             i_code                => d.code_icd,
                                                             i_flg_other           => d.flg_other,
                                                             i_flg_std_diag        => ad.flg_icd9,
                                                             i_epis_diag           => ed.id_epis_diagnosis,
                                                             i_show_aditional_info => 'N',
                                                             i_diagnosis_language  => pk_ts1_api.get_id_language(i_lang,
                                                                                                                 d.id_terminology_version),
                                                             i_code_diagnosis      => ad.code_alert_diagnosis)) desc_diagnosis,
                           ed.dt_initial_diag dt_initial,
                           -- pk_diagnosis_core.get_first_dt_diagnosis(i_lang               => i_lang,
                           --                                          i_prof               => i_prof,
                           --                                          i_patient            => ed.id_patient,
                           --                                          i_id_diagnosis       => ed.id_diagnosis,
                           --                                         i_id_alert_diagnosis => ed.id_alert_diagnosis) dt_initial,
                           ed.flg_status,
                           d.flg_type,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              ed.flg_status,
                                                              ed.dt_epis_diagnosis_tstz,
                                                              ed.dt_confirmed_tstz,
                                                              ed.dt_cancel_tstz,
                                                              ed.dt_base_tstz,
                                                              ed.dt_rulled_out_tstz) dt_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                ed.flg_status,
                                                                ed.id_professional_diag,
                                                                ed.id_prof_confirmed,
                                                                ed.id_professional_cancel,
                                                                ed.id_prof_base,
                                                                ed.id_prof_rulled_out) id_professional,
                           pk_diagnosis_core.check_previous_diagnosis(i_lang               => i_lang,
                                                                      i_prof               => i_prof,
                                                                      i_patient            => ed.id_patient,
                                                                      i_episode            => ed.id_episode,
                                                                      i_id_diagnosis       => ed.id_diagnosis,
                                                                      i_id_alert_diagnosis => ed.id_alert_diagnosis) has_previous,
                           ed.notes,
                           d.flg_other,
                           d.id_content,
                           ed.id_episode,
                           tf.position rank
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                      JOIN TABLE(pk_translation.get_search_translation(i_lang => i_lang, i_search => i_criteria, i_column_name => pk_diagnosis.g_code_column_name, i_highlight => i_format_text)) tf
                        ON ((ad.code_alert_diagnosis IS NOT NULL AND ad.code_alert_diagnosis = tf.code_translation) OR
                           (ad.code_alert_diagnosis IS NULL AND d.code_diagnosis = tf.code_translation))
                     WHERE ed.id_episode IN (SELECT /*+ opt_estimate(table d rows=1) */
                                              d.column_value
                                               FROM TABLE(l_tbl_episode) d)
                       AND ed.flg_type IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                             FROM TABLE(l_tbl_type) d )
                       AND ed.flg_status IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                               FROM TABLE(l_tbl_status) d)
                    
                    UNION ALL
                    
                    --Getting free texts registered related with i_criteria param
                    SELECT ed.id_epis_diagnosis,
                           pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                           d.id_diagnosis,
                           ed.id_alert_diagnosis,
                           ed.desc_epis_diagnosis desc_diagnosis,
                           ed.dt_initial_diag dt_initial,
                           ed.flg_status,
                           d.flg_type,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              ed.flg_status,
                                                              ed.dt_epis_diagnosis_tstz,
                                                              ed.dt_confirmed_tstz,
                                                              ed.dt_cancel_tstz,
                                                              ed.dt_base_tstz,
                                                              ed.dt_rulled_out_tstz) dt_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                ed.flg_status,
                                                                ed.id_professional_diag,
                                                                ed.id_prof_confirmed,
                                                                ed.id_professional_cancel,
                                                                ed.id_prof_base,
                                                                ed.id_prof_rulled_out) id_professional,
                           pk_diagnosis_core.check_previous_diagnosis(i_lang               => i_lang,
                                                                      i_prof               => i_prof,
                                                                      i_patient            => ed.id_patient,
                                                                      i_episode            => ed.id_episode,
                                                                      i_id_diagnosis       => ed.id_diagnosis,
                                                                      i_id_alert_diagnosis => ed.id_alert_diagnosis) has_previous,
                           ed.notes,
                           d.flg_other,
                           d.id_content,
                           ed.id_episode,
                           NULL rank
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_episode IN (SELECT /*+ opt_estimate(table d rows=1) */
                                              d.column_value
                                               FROM TABLE(l_tbl_episode) d)
                       AND ed.flg_type IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                             FROM TABLE(l_tbl_type)d )
                       AND ed.flg_status IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                               FROM TABLE(l_tbl_status) d)
                       AND (d.flg_other = pk_alert_constant.g_yes AND ed.desc_epis_diagnosis LIKE i_criteria || '%')) ed2;
        ELSE
            -- with no search criteria (all episode diagnosis)
        
            SELECT t_rec_episode_diagnosis(ed2.id_epis_diagnosis,
                                           id_diagnosis,
                                           id_alert_diagnosis,
                                           desc_diagnosis,
                                           dt_initial,
                                           pk_date_utils.dt_chr_tsz(i_lang, dt_initial, i_prof),
                                           flg_status,
                                           pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', flg_status, i_lang),
                                           dt_diagnosis,
                                           pk_date_utils.date_char_tsz(i_lang,
                                                                       dt_diagnosis,
                                                                       i_prof.institution,
                                                                       i_prof.software),
                                           id_professional,
                                           pk_prof_utils.get_name_signature(i_lang, i_prof, id_professional),
                                           pk_prof_utils.get_spec_signature(i_lang,
                                                                            i_prof,
                                                                            id_professional,
                                                                            dt_diagnosis,
                                                                            ed2.id_episode),
                                           flg_type,
                                           has_previous,
                                           notes,
                                           flg_other,
                                           id_content,
                                           rank,
                                           ed2.id_episode)
              BULK COLLECT
              INTO l_diagnosis
              FROM (SELECT ed.id_epis_diagnosis,
                           pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                           d.id_diagnosis,
                           ed.id_alert_diagnosis,
                           decode(i_translation_desc_only,
                                  pk_alert_constant.g_yes,
                                  get_alert_diag_desc(i_lang               => i_lang,
                                                      i_prof               => i_prof,
                                                      i_id_alert_diagnosis => ad.id_alert_diagnosis,
                                                      i_code_diagnosis     => ad.code_alert_diagnosis,
                                                      i_diagnosis_language => pk_ts1_api.get_id_language(i_lang,
                                                                                                         d.id_terminology_version),
                                                      i_id_task_type       => pk_alert_constant.g_task_diagnosis),
                                  pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                             i_prof                => i_prof,
                                                             i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                             i_id_diagnosis        => d.id_diagnosis,
                                                             i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                             i_code                => d.code_icd,
                                                             i_flg_other           => d.flg_other,
                                                             i_flg_std_diag        => ad.flg_icd9,
                                                             i_epis_diag           => ed.id_epis_diagnosis,
                                                             i_show_aditional_info => 'N',
                                                             i_diagnosis_language  => pk_ts1_api.get_id_language(i_lang,
                                                                                                                 d.id_terminology_version),
                                                             i_code_diagnosis      => ad.code_alert_diagnosis)) desc_diagnosis,
                           --   pk_diagnosis_core.get_first_dt_diagnosis(i_lang               => i_lang,
                           --                                            i_prof               => i_prof,
                           --                                            i_patient            => ed.id_patient,
                           --                                            i_id_diagnosis       => ed.id_diagnosis,
                           ----                                            i_id_alert_diagnosis => ed.id_alert_diagnosis) dt_initial,
                           ed.dt_initial_diag dt_initial,
                           ed.flg_status,
                           d.flg_type,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              ed.flg_status,
                                                              ed.dt_epis_diagnosis_tstz,
                                                              ed.dt_confirmed_tstz,
                                                              ed.dt_cancel_tstz,
                                                              ed.dt_base_tstz,
                                                              ed.dt_rulled_out_tstz) dt_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                ed.flg_status,
                                                                ed.id_professional_diag,
                                                                ed.id_prof_confirmed,
                                                                ed.id_professional_cancel,
                                                                ed.id_prof_base,
                                                                ed.id_prof_rulled_out) id_professional,
                           
                           pk_diagnosis_core.check_previous_diagnosis(i_lang               => i_lang,
                                                                      i_prof               => i_prof,
                                                                      i_patient            => ed.id_patient,
                                                                      i_episode            => ed.id_episode,
                                                                      i_id_diagnosis       => ed.id_diagnosis,
                                                                      i_id_alert_diagnosis => ed.id_alert_diagnosis) has_previous,
                           ed.notes,
                           d.flg_other,
                           d.id_content,
                           ed.id_episode,
                           NULL rank
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_episode IN (SELECT /*+ opt_estimate(table d rows=1) */
                                              d.column_value
                                               FROM TABLE(l_tbl_episode) d)
                       AND ed.flg_type IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                             FROM TABLE(l_tbl_type) d)
                       AND ed.flg_status IN (SELECT /*+ opt_estimate(table d rows=1) */ column_value
                                               FROM TABLE(l_tbl_status) d)) ed2;
        END IF;
    
        RETURN l_diagnosis;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'TB_GET_EPIS_DIAGNOSIS_LIST',
                                              l_error);
            RETURN l_diagnosis;
    END tb_get_epis_diagnosis_list;

    /**********************************************************************************************
    * List all diagnosis registered for a patient
    * (this function does not perform a text search, it returns all records of a patient according to the scope)
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_id_scope               Scope (V-Visit/E-Episode/P-Patient)
    * @param i_id_scope               Scope id
    * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param i_tbl_status            
    *
    * @return                         Diagnoses list
    *
    * @version                        2.8.1.0
    **********************************************************************************************/
    FUNCTION tb_get_epis_diagnosis_list
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_patient    IN patient.id_patient%TYPE DEFAULT NULL,
        i_id_scope   IN episode.id_episode%TYPE,
        i_flg_scope  IN VARCHAR2,
        i_flg_type   IN epis_diagnosis.flg_type%TYPE,
        i_tbl_status IN table_varchar DEFAULT NULL
    ) RETURN t_coll_episode_diagnosis IS
    
        l_diagnosis   t_coll_episode_diagnosis;
        l_error       t_error_out;
        l_tbl_episode table_number := table_number();
        l_tbl_status  table_varchar;
        l_tbl_type    table_varchar;
    
    BEGIN
        IF i_tbl_status.exists(1)
        THEN
            l_tbl_status := i_tbl_status;
        ELSE
        
            SELECT sd.val
              BULK COLLECT
              INTO l_tbl_status
              FROM sys_domain sd
             WHERE sd.code_domain = 'EPIS_DIAGNOSIS.FLG_STATUS'
               AND sd.domain_owner = pk_sysdomain.k_default_schema
               AND sd.flg_available = pk_alert_constant.g_yes
               AND sd.id_language = i_lang;
        END IF;
    
        IF i_flg_type IS NULL
        THEN
            l_tbl_type := table_varchar(pk_diagnosis.g_diag_type_p, pk_diagnosis.g_diag_type_d);
        ELSE
            l_tbl_type := table_varchar(i_flg_type);
        END IF;
    
        IF i_flg_scope = pk_diagnosis_core.g_scope_visit
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_patient,
                                                         i_id_episode        => NULL,
                                                         i_id_visit          => i_id_scope,
                                                         i_flg_visit_or_epis => i_flg_scope);
        ELSIF i_flg_scope = pk_diagnosis_core.g_scope_episode
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_patient,
                                                         i_id_episode        => i_id_scope,
                                                         i_id_visit          => NULL,
                                                         i_flg_visit_or_epis => i_flg_scope);
        ELSIF i_flg_scope = pk_diagnosis_core.g_scope_patient
        THEN
            l_tbl_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                         i_prof              => i_prof,
                                                         i_id_patient        => i_id_scope,
                                                         i_id_episode        => NULL,
                                                         i_id_visit          => NULL,
                                                         i_flg_visit_or_epis => i_flg_scope);
        END IF;
    
        SELECT t_rec_episode_diagnosis(ed2.id_epis_diagnosis,
                                       id_diagnosis,
                                       id_alert_diagnosis,
                                       NULL,
                                       dt_initial,
                                       NULL,
                                       NULL,
                                       NULL,
                                       dt_diagnosis,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL,
                                       NULL)
          BULK COLLECT
          INTO l_diagnosis
          FROM (SELECT ed.id_epis_diagnosis,
                       ed.id_diagnosis,
                       ed.id_alert_diagnosis,
                       ed.dt_initial_diag dt_initial,
                       pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                          i_prof,
                                                          ed.flg_status,
                                                          ed.dt_epis_diagnosis_tstz,
                                                          ed.dt_confirmed_tstz,
                                                          ed.dt_cancel_tstz,
                                                          ed.dt_base_tstz,
                                                          ed.dt_rulled_out_tstz) dt_diagnosis
                  FROM epis_diagnosis ed
                 WHERE ed.id_episode IN (SELECT  /*+ opt_estimate(table d rows=1) */
                                          d.column_value
                                           FROM TABLE(l_tbl_episode) d)
                   AND ed.flg_type IN (SELECT  /*+ opt_estimate(table d rows=1) */ column_value
                                         FROM TABLE(l_tbl_type) d )
                   AND ed.flg_status IN (SELECT  /*+ opt_estimate(table d rows=1) */ column_value
                                           FROM TABLE(l_tbl_status) d)) ed2;
    
        RETURN l_diagnosis;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'TB_GET_EPIS_DIAGNOSIS_LIST',
                                              l_error);
            RETURN l_diagnosis;
    END tb_get_epis_diagnosis_list;

    /**********************************************************************************************
    * List active diagnosis registered in an episode
    *
    * @param i_lang                   Id language
    * @param i_prof                   Professional, software and institution ids
    * @param i_episode                Episode id
    * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param i_criteria               search criteria
    * @param i_format_text            
    *
    * @return                         Active Diagnoses list
    *
    * @author                               Joel Lopes
    * @version                              2.6.3
    * @since                                12-02-2014
    **********************************************************************************************/
    FUNCTION tb_get_epis_diagnosis_cda
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_pat               IN patient.id_patient%TYPE DEFAULT NULL,
        i_episode           IN episode.id_episode%TYPE,
        i_flg_type          IN epis_diagnosis.flg_type%TYPE,
        i_criteria          IN VARCHAR2,
        i_format_text       IN VARCHAR2,
        i_flg_visit_or_epis IN VARCHAR2 DEFAULT 'E'
    ) RETURN t_coll_episode_diagnosis_cda IS
    
        l_diagnosis t_coll_episode_diagnosis_cda;
        l_error     t_error_out;
        l_episode   table_number := table_number();
    BEGIN
    
        --find list of episodes
        IF i_flg_visit_or_epis = g_scope_visit
        THEN
            l_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                     i_prof              => i_prof,
                                                     i_id_patient        => i_pat,
                                                     i_id_episode        => NULL,
                                                     i_id_visit          => i_episode,
                                                     i_flg_visit_or_epis => i_flg_visit_or_epis);
        ELSE
            l_episode := pk_patient.get_episode_list(i_lang              => i_lang,
                                                     i_prof              => i_prof,
                                                     i_id_patient        => i_pat,
                                                     i_id_episode        => i_episode,
                                                     i_id_visit          => NULL,
                                                     i_flg_visit_or_epis => i_flg_visit_or_epis);
        END IF;
    
        IF i_criteria IS NOT NULL -- search criteria
        THEN
        
            SELECT t_rec_episode_diagnosis_cda(ed2.id_epis_diagnosis,
                                               id_diagnosis,
                                               id_alert_diagnosis,
                                               desc_diagnosis,
                                               dt_initial,
                                               pk_date_utils.dt_chr_tsz(i_lang, dt_initial, i_prof),
                                               flg_status,
                                               pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', flg_status, i_lang),
                                               dt_diagnosis,
                                               pk_date_utils.date_char_tsz(i_lang,
                                                                           dt_diagnosis,
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                               id_professional,
                                               pk_prof_utils.get_name_signature(i_lang, i_prof, id_professional),
                                               pk_prof_utils.get_spec_signature(i_lang,
                                                                                i_prof,
                                                                                id_professional,
                                                                                dt_diagnosis,
                                                                                ed2.id_episode),
                                               flg_type,
                                               has_previous,
                                               notes,
                                               flg_other,
                                               id_content,
                                               code_icd,
                                               id_terminology_version)
              BULK COLLECT
              INTO l_diagnosis
              FROM (SELECT /*+ opt_estimate(table tf rows=1) */ ed.id_epis_diagnosis,
                           pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                           d.id_diagnosis,
                           ed.id_alert_diagnosis,
                           pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                      i_prof                => i_prof,
                                                      i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                      i_id_diagnosis        => d.id_diagnosis,
                                                      i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                      i_code                => d.code_icd,
                                                      i_flg_other           => d.flg_other,
                                                      i_flg_std_diag        => ad.flg_icd9,
                                                      i_epis_diag           => ed.id_epis_diagnosis,
                                                      i_show_aditional_info => 'N') desc_diagnosis,
                           /*pk_date_utils.date_send_tsz(i_lang, ed.dt_epis_diagnosis_tstz, i_prof) dt_initial,--*/
                           --ed.dt_epis_diagnosis_tstz dt_initial,
                           ed.dt_initial_diag dt_initial,
                           -- pk_diagnosis_core.get_first_dt_diagnosis(i_lang               => i_lang,
                           --                                          i_prof               => i_prof,
                           --                                          i_patient            => ed.id_patient,
                           --                                          i_id_diagnosis       => ed.id_diagnosis,
                           --                                         i_id_alert_diagnosis => ed.id_alert_diagnosis) dt_initial,
                           ed.flg_status,
                           d.flg_type,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              ed.flg_status,
                                                              ed.dt_epis_diagnosis_tstz,
                                                              ed.dt_confirmed_tstz,
                                                              ed.dt_cancel_tstz,
                                                              ed.dt_base_tstz,
                                                              ed.dt_rulled_out_tstz) dt_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                ed.flg_status,
                                                                ed.id_professional_diag,
                                                                ed.id_prof_confirmed,
                                                                ed.id_professional_cancel,
                                                                ed.id_prof_base,
                                                                ed.id_prof_rulled_out) id_professional,
                           pk_diagnosis_core.check_previous_diagnosis(i_lang               => i_lang,
                                                                      i_prof               => i_prof,
                                                                      i_patient            => ed.id_patient,
                                                                      i_episode            => ed.id_episode,
                                                                      i_id_diagnosis       => ed.id_diagnosis,
                                                                      i_id_alert_diagnosis => ed.id_alert_diagnosis) has_previous,
                           ed.notes,
                           d.flg_other,
                           d.id_content,
                           ed.id_episode,
                           d.code_icd,
                           d.id_terminology_version
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                      JOIN TABLE(pk_translation.get_search_translation(i_lang => i_lang, i_search => i_criteria, i_column_name => pk_diagnosis.g_code_column_name, i_highlight => i_format_text)) tf
                        ON (d.code_diagnosis = tf.code_translation OR ad.code_alert_diagnosis = tf.code_translation)
                     WHERE ed.id_episode IN (SELECT  /*+ opt_estimate(table d rows=1) */
                                              d.column_value
                                               FROM TABLE(l_episode) d)
                       AND ed.flg_type = i_flg_type
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_p,
                                             pk_diagnosis.g_ed_flg_status_d)) ed2;
        
        ELSE
            -- with no search criteria (all episode diagnosis)
        
            SELECT t_rec_episode_diagnosis_cda(ed2.id_epis_diagnosis,
                                               id_diagnosis,
                                               id_alert_diagnosis,
                                               desc_diagnosis,
                                               dt_initial,
                                               pk_date_utils.dt_chr_tsz(i_lang, dt_initial, i_prof),
                                               flg_status,
                                               pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', flg_status, i_lang),
                                               dt_diagnosis,
                                               pk_date_utils.date_char_tsz(i_lang,
                                                                           dt_diagnosis,
                                                                           i_prof.institution,
                                                                           i_prof.software),
                                               id_professional,
                                               pk_prof_utils.get_name_signature(i_lang, i_prof, id_professional),
                                               pk_prof_utils.get_spec_signature(i_lang,
                                                                                i_prof,
                                                                                id_professional,
                                                                                dt_diagnosis,
                                                                                ed2.id_episode),
                                               flg_type,
                                               has_previous,
                                               notes,
                                               flg_other,
                                               id_content,
                                               code_icd,
                                               id_terminology_version)
              BULK COLLECT
              INTO l_diagnosis
              FROM (SELECT ed.id_epis_diagnosis,
                           pk_diagnosis_core.get_last_epis_diag_hist(i_lang, i_prof, ed.id_epis_diagnosis) id_epis_diagnosis_hist,
                           d.id_diagnosis,
                           ed.id_alert_diagnosis,
                           pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                      i_prof                => i_prof,
                                                      i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                      i_id_diagnosis        => d.id_diagnosis,
                                                      i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                      i_code                => d.code_icd,
                                                      i_flg_other           => d.flg_other,
                                                      i_flg_std_diag        => ad.flg_icd9,
                                                      i_epis_diag           => ed.id_epis_diagnosis,
                                                      i_show_aditional_info => 'N') desc_diagnosis,
                           --   pk_diagnosis_core.get_first_dt_diagnosis(i_lang               => i_lang,
                           --                                            i_prof               => i_prof,
                           --                                            i_patient            => ed.id_patient,
                           --                                            i_id_diagnosis       => ed.id_diagnosis,
                           ----                                            i_id_alert_diagnosis => ed.id_alert_diagnosis) dt_initial,
                           /*pk_date_utils.date_send_tsz(i_lang, ed.dt_epis_diagnosis_tstz, i_prof) dt_initial,--*/
                           --ed.dt_epis_diagnosis_tstz dt_initial,
                           ed.dt_initial_diag dt_initial,
                           ed.flg_status,
                           d.flg_type,
                           pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                              i_prof,
                                                              ed.flg_status,
                                                              ed.dt_epis_diagnosis_tstz,
                                                              ed.dt_confirmed_tstz,
                                                              ed.dt_cancel_tstz,
                                                              ed.dt_base_tstz,
                                                              ed.dt_rulled_out_tstz) dt_diagnosis,
                           pk_diagnosis_core.get_prof_diagnosis(i_lang,
                                                                i_prof,
                                                                ed.flg_status,
                                                                ed.id_professional_diag,
                                                                ed.id_prof_confirmed,
                                                                ed.id_professional_cancel,
                                                                ed.id_prof_base,
                                                                ed.id_prof_rulled_out) id_professional,
                           
                           pk_diagnosis_core.check_previous_diagnosis(i_lang               => i_lang,
                                                                      i_prof               => i_prof,
                                                                      i_patient            => ed.id_patient,
                                                                      i_episode            => ed.id_episode,
                                                                      i_id_diagnosis       => ed.id_diagnosis,
                                                                      i_id_alert_diagnosis => ed.id_alert_diagnosis) has_previous,
                           ed.notes,
                           d.flg_other,
                           d.id_content,
                           ed.id_episode,
                           d.code_icd,
                           d.id_terminology_version
                      FROM epis_diagnosis ed
                      JOIN diagnosis d
                        ON d.id_diagnosis = ed.id_diagnosis
                      LEFT JOIN alert_diagnosis ad
                        ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
                     WHERE ed.id_episode IN (SELECT /*+ opt_estimate(table d rows=1) */
                                              d.column_value
                                               FROM TABLE(l_episode) d)
                       AND ed.flg_type = i_flg_type
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_p,
                                             pk_diagnosis.g_ed_flg_status_d)) ed2;
        
        END IF;
        RETURN l_diagnosis;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'TB_GET_EPIS_DIAGNOSIS_LIST',
                                              l_error);
            RETURN l_diagnosis;
        
    END tb_get_epis_diagnosis_cda;
    -------

    --
    /********************************************************************************************
    * Function that returns the terminology abbreviation for a diagnosis
    *
    * @param i_lang                   language ID
    * @param id_diagnosis             Diagnosis ID
    *
    * @return                         Translation
    *
    * @author                         Sergio Dias
    * @version                        2.6.3.8.4
    * @since                          Nov/11/2013
    **********************************************************************************************/
    FUNCTION get_terminology_abbreviation
    (
        i_lang       IN language.id_language%TYPE,
        id_diagnosis IN diagnosis.id_diagnosis%TYPE
    ) RETURN VARCHAR2 IS
        l_terminology_information pk_api_termin_server_func.g_rec_terminology_info;
    BEGIN
        l_terminology_information := pk_api_diagnosis_func.get_terminology_information(i_concept_version => id_diagnosis);
    
        RETURN pk_translation.get_translation(i_lang      => i_lang,
                                              i_code_mess => l_terminology_information.code_abbreviation);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_terminology_abbreviation;

    FUNCTION get_id_diag_condition
    (
        i_prof      IN profissional,
        i_diagnosis IN diagnosis.id_diagnosis%TYPE
    ) RETURN concept_version.id_concept_version%TYPE IS
        l_ret concept_version.id_concept_version%TYPE;
    BEGIN
        SELECT decode(t.concept_type_int_name,
                      --DIAG IS DIAGNOSIS_CONDITION 
                      pk_diagnosis_form.g_diag_condition_type,
                      i_diagnosis,
                      pk_diagnosis_form.g_ae_diagnosis_type,
                      --DIAG IS AE_DIAGNOSIS IS_A DIAG_CONDITION
                      nvl((SELECT dr.id_concept_version_2
                            FROM diagnosis_relations_ea dr
                           WHERE dr.id_concept_version_1 = i_diagnosis
                             AND dr.concept_type_int_name1 = pk_diagnosis_form.g_ae_diagnosis_type
                             AND dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
                             AND dr.concept_type_int_name2 = pk_diagnosis_form.g_diag_condition_type
                             AND dr.id_institution = i_prof.institution
                             AND dr.id_software = i_prof.software),
                          --AE_DIAGNOSIS IS_A SUB_ANALYSIS
                          (SELECT dr.id_concept_version_2
                             FROM diagnosis_relations_ea dr
                            WHERE dr.id_concept_version_1 =
                                  (SELECT dr2.id_concept_version_2
                                     FROM diagnosis_relations_ea dr2
                                    WHERE dr2.id_concept_version_1 = i_diagnosis
                                      AND dr2.concept_type_int_name1 = pk_diagnosis_form.g_ae_diagnosis_type
                                      AND dr2.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
                                      AND dr2.concept_type_int_name2 = pk_diagnosis_form.g_sub_analysis_type
                                      AND dr2.id_institution = dr.id_institution
                                      AND dr2.id_software = dr.id_software)
                              AND dr.concept_type_int_name1 = pk_diagnosis_form.g_sub_analysis_type
                              AND dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
                              AND dr.concept_type_int_name2 = pk_diagnosis_form.g_diag_condition_type
                              AND dr.id_institution = i_prof.institution
                              AND dr.id_software = i_prof.software)),
                      --DIAG IS SUB_ANALYSIS
                      pk_diagnosis_form.g_sub_analysis_type,
                      (SELECT dr.id_concept_version_2
                         FROM diagnosis_relations_ea dr
                        WHERE dr.id_concept_version_1 = i_diagnosis
                          AND dr.concept_type_int_name1 = pk_diagnosis_form.g_sub_analysis_type
                          AND dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
                          AND dr.concept_type_int_name2 = pk_diagnosis_form.g_diag_condition_type
                          AND dr.id_institution = i_prof.institution
                          AND dr.id_software = i_prof.software),
                      NULL)
          INTO l_ret
          FROM (SELECT DISTINCT d.concept_type_int_name
                  FROM diagnosis_ea d
                 WHERE d.id_institution = i_prof.institution
                   AND d.id_software = i_prof.software
                   AND d.id_concept_version = i_diagnosis) t;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_id_diag_condition;

    FUNCTION get_id_sub_analysis
    (
        i_prof      IN profissional,
        i_diagnosis IN diagnosis.id_diagnosis%TYPE
    ) RETURN concept_version.id_concept_version%TYPE IS
        l_ret concept_version.id_concept_version%TYPE;
    BEGIN
        SELECT decode(t.concept_type_int_name,
                      --DIAG IS SUB_ANALYSIS 
                      pk_diagnosis_form.g_sub_analysis_type,
                      i_diagnosis,
                      --DIAG IS_A AE_DIAG
                      pk_diagnosis_form.g_ae_diagnosis_type,
                      (SELECT dr.id_concept_version_2
                         FROM diagnosis_relations_ea dr
                        WHERE dr.id_concept_version_1 = i_diagnosis
                          AND dr.concept_type_int_name1 = pk_diagnosis_form.g_ae_diagnosis_type
                          AND dr.cncpt_rel_type_int_name = pk_diagnosis_form.g_rel_is_a
                          AND dr.concept_type_int_name2 = pk_diagnosis_form.g_sub_analysis_type
                          AND dr.id_institution = i_prof.institution
                          AND dr.id_software = i_prof.software),
                      NULL)
          INTO l_ret
          FROM (SELECT DISTINCT d.concept_type_int_name
                  FROM diagnosis_ea d
                 WHERE d.id_institution = i_prof.institution
                   AND d.id_software = i_prof.software
                   AND d.id_concept_version = i_diagnosis) t;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_id_sub_analysis;

    /********************************************************************************************
    * Get FLG_ICD9 of the given concept_term
    *
    * @param i_alert_diagnosis        Concept term
    * 
    * @return                         FLG_ICD9
    * 
    * @author                         Alexandre Santos
    * @version                        2.6.3   
    * @since                          2014/03/13
    **********************************************************************************************/
    FUNCTION get_flg_std_diag(i_alert_diagnosis IN alert_diagnosis.id_alert_diagnosis%TYPE) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_FLG_STD_DIAG';
        l_ret alert_diagnosis.flg_icd9%TYPE;
    BEGIN
        g_error := 'GET FLG_ICD9 OF ID_ALERT_DIAGNOSIS: ' || i_alert_diagnosis;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_func_name);
        SELECT ad.flg_icd9
          INTO l_ret
          FROM alert_diagnosis ad
         WHERE ad.id_alert_diagnosis = i_alert_diagnosis;
    
        RETURN l_ret;
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_flg_std_diag;

    /********************************************************************************************
    * Function that returns the last episode identifier that contains the last diagnosis documented
    * by software 
    *
    * @param i_lang                   language identifier
    * @param i_prof                   Professional identifier
    * @param i_patient                Patient identifier
    * @param i_software               Software identifier
    * @param i_diag_type              Diagnosis Type: D-Final, P-Diferential
    *
    * @return                         Last episode identifier
    *
    * @author                         Gisela Couto
    * @version                        2.6.4.2.2
    * @since                          Oct/29/2014
    **********************************************************************************************/
    FUNCTION get_lst_epis_doc_diag_by_soft
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_patient   IN patient.id_patient%TYPE,
        i_software  IN software.id_software%TYPE,
        i_diag_type IN VARCHAR2
    ) RETURN episode.id_episode%TYPE IS
        l_id_episode episode.id_episode%TYPE;
        --
        l_func_name CONSTANT VARCHAR2(100 CHAR) := 'GET_LAST_EPIS_DOC_BY_SOFT';
    BEGIN
    
        BEGIN
            SELECT t.id_episode
              INTO l_id_episode
              FROM (SELECT epis.id_episode,
                           row_number() over(ORDER BY epis.dt_end_tstz DESC NULLS FIRST, epis.dt_begin_tstz DESC) line_number
                      FROM episode epis
                      JOIN epis_info ei
                        ON ei.id_episode = epis.id_episode
                      JOIN epis_diagnosis ed
                        ON ed.id_episode = epis.id_episode
                       AND ed.flg_type = i_diag_type
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_p,
                                             pk_diagnosis.g_ed_flg_status_d)
                     WHERE ei.id_software = i_software
                       AND epis.id_patient = i_patient) t
             WHERE line_number = 1;
        
        EXCEPTION
            WHEN no_data_found THEN
                l_id_episode := NULL;
        END;
    
        RETURN l_id_episode;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_lst_epis_doc_diag_by_soft;

    /********************************************************************************************
    * Function that returns the informtaion of diagnosis by id_epis_diagnosis
    *
    * @param i_lang                   language ID
    * @param i_prof                   Object (professional, Institution and Software)
    * @param i_episode                episode ID
     * @param i_flg_type               Diagnosis type: P - differential, D - final
    * @param i_epis_diag              episode diagnosis ID
     *
    * @return                         diagnosis general info
    *
    *
    * @author                         Elisabete Bugalho
    * @version                        2.7.0
    * @since                          16/11/2016
    **********************************************************************************************/
    FUNCTION get_epis_diag_list
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        i_flg_type  IN epis_diagnosis.flg_type%TYPE,
        i_epis_diag IN table_number,
        o_epis_diag OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'OPEN o_epis_diag';
        pk_alertlog.log_debug(g_error);
        IF i_epis_diag IS NOT NULL
        THEN
            OPEN o_epis_diag FOR
                SELECT ed.id_epis_diagnosis,
                       ed.id_diagnosis,
                       ed.id_alert_diagnosis,
                       pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                  i_prof                => i_prof,
                                                  i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                  i_id_diagnosis        => d.id_diagnosis,
                                                  i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                  i_code                => d.code_icd,
                                                  i_flg_other           => d.flg_other,
                                                  i_flg_std_diag        => ad.flg_icd9) diag_desc,
                       ed.flg_type,
                       ed.flg_final_type,
                       decode(ed.flg_type,
                              pk_diagnosis.g_diag_type_d,
                              decode(ed.flg_final_type,
                                     pk_diagnosis.g_flg_final_type_p,
                                     pk_message.get_message(i_lang, 'DIAGNOSIS_T003'),
                                     pk_diagnosis.g_flg_final_type_s,
                                     pk_message.get_message(i_lang, 'DIAGNOSIS_T004'))) desc_final_type,
                       pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_TYPE', ed.flg_type, i_lang) type_desc,
                       ed.flg_status,
                       d.code_icd,
                       pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', ed.flg_status, i_lang) status_desc,
                       date_order,
                       pk_date_utils.date_send_tsz(i_lang, date_order, i_prof) dt_order
                  FROM (SELECT ed.id_diagnosis,
                               ed.flg_type,
                               ed.flg_status,
                               ed.id_alert_diagnosis,
                               ed.desc_epis_diagnosis,
                               ed.flg_add_problem,
                               ed.id_epis_diagnosis,
                               
                               NULL id_epis_diagnosis_hist,
                               pk_alert_constant.g_no flg_has_recent_data,
                               ed.flg_final_type,
                               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                                  i_prof,
                                                                  flg_status,
                                                                  dt_epis_diagnosis_tstz,
                                                                  dt_confirmed_tstz,
                                                                  dt_cancel_tstz,
                                                                  dt_base_tstz,
                                                                  dt_rulled_out_tstz) date_order
                          FROM epis_diagnosis ed
                          JOIN (SELECT /*+opt_estimate(table t2 rows=1)*/
                                column_value
                                 FROM TABLE((CAST(i_epis_diag AS table_number))) t2) tab_ed
                            ON tab_ed.column_value = ed.id_epis_diagnosis) ed
                  JOIN diagnosis d
                    ON (d.id_diagnosis = ed.id_diagnosis)
                  LEFT OUTER JOIN alert_diagnosis ad
                    ON (ad.id_alert_diagnosis = ed.id_alert_diagnosis)
                 ORDER BY ed.flg_final_type NULLS LAST, diag_desc;
        ELSE
        
            OPEN o_epis_diag FOR
                SELECT ed.id_epis_diagnosis,
                       ed.id_diagnosis,
                       ed.id_alert_diagnosis,
                       pk_diagnosis.std_diag_desc(i_lang                => i_lang,
                                                  i_prof                => i_prof,
                                                  i_id_alert_diagnosis  => ad.id_alert_diagnosis,
                                                  i_id_diagnosis        => d.id_diagnosis,
                                                  i_desc_epis_diagnosis => ed.desc_epis_diagnosis,
                                                  i_code                => d.code_icd,
                                                  i_flg_other           => d.flg_other,
                                                  i_flg_std_diag        => ad.flg_icd9) diag_desc,
                       ed.flg_type,
                       ed.flg_final_type,
                       decode(ed.flg_type,
                              pk_diagnosis.g_diag_type_d,
                              decode(ed.flg_final_type,
                                     pk_diagnosis.g_flg_final_type_p,
                                     pk_message.get_message(i_lang, 'DIAGNOSIS_T003'),
                                     pk_diagnosis.g_flg_final_type_s,
                                     pk_message.get_message(i_lang, 'DIAGNOSIS_T004'))) desc_final_type,
                       pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_TYPE', ed.flg_type, i_lang) type_desc,
                       ed.flg_status,
                       d.code_icd,
                       pk_sysdomain.get_domain('EPIS_DIAGNOSIS.FLG_STATUS', ed.flg_status, i_lang) status_desc,
                       date_order,
                       pk_date_utils.date_send_tsz(i_lang, date_order, i_prof) dt_order
                  FROM (SELECT ed.id_diagnosis,
                               ed.flg_type,
                               ed.flg_status,
                               ed.id_alert_diagnosis,
                               ed.desc_epis_diagnosis,
                               ed.flg_add_problem,
                               ed.id_epis_diagnosis,
                               
                               NULL id_epis_diagnosis_hist,
                               pk_alert_constant.g_no flg_has_recent_data,
                               ed.flg_final_type,
                               pk_diagnosis_core.get_dt_diagnosis(i_lang,
                                                                  i_prof,
                                                                  flg_status,
                                                                  dt_epis_diagnosis_tstz,
                                                                  dt_confirmed_tstz,
                                                                  dt_cancel_tstz,
                                                                  dt_base_tstz,
                                                                  dt_rulled_out_tstz) date_order
                          FROM epis_diagnosis ed
                         WHERE ed.id_episode = i_episode
                           AND (ed.flg_type = i_flg_type OR i_flg_type IS NULL)
                           AND ed.flg_status != 'C') ed
                  JOIN diagnosis d
                    ON (d.id_diagnosis = ed.id_diagnosis)
                  LEFT OUTER JOIN alert_diagnosis ad
                    ON (ad.id_alert_diagnosis = ed.id_alert_diagnosis)
                 ORDER BY ed.flg_final_type NULLS LAST, diag_desc;
        
        END IF;
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              'GET_EPIS_DIAG_LIST',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            pk_types.open_my_cursor(o_epis_diag);
            RETURN FALSE;
    END get_epis_diag_list;

    /**********************************************************************************************
    * Listar os diagnósticos definitivos do episódio
    *
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids             
    * @param i_epis                   episode id
    * @param i_preg_out_type          type Abortion (A) or Delivery(D)
    * @param o_exists                 IF exists, return 'Y', otherwise, return 'N'
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Pedro Henriques
    * @version                        1.0 
    * @since                          2017/07/27
    **********************************************************************************************/
    FUNCTION get_final_diag_abort_deliv
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_epis          IN episode.id_episode%TYPE,
        i_preg_out_type IN pat_pregnancy.flg_preg_out_type%TYPE,
        i_diagnosis     IN table_number,
        o_exists        OUT VARCHAR2,
        o_count         OUT NUMBER,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exists                   NUMBER := 0;
        l_cfg_show_all_diag_states sys_config.id_sys_config%TYPE := 'FINAL_DIAGNOSIS_SHOW_ALL_STATES';
        l_show_all_diag_states     sys_config.value%TYPE;
        l_tbl_clave                table_varchar;
    
        l_icd10_abort_init CONSTANT VARCHAR2(3 CHAR) := 'O00';
        l_icd10_abort_end  CONSTANT VARCHAR2(3 CHAR) := 'O08';
    
        l_icd10_deliv_init CONSTANT VARCHAR2(3 CHAR) := 'O80';
        l_icd10_deliv_end  CONSTANT VARCHAR2(3 CHAR) := 'O85';
    
    BEGIN
    
        l_show_all_diag_states := nvl(pk_sysconfig.get_config(i_code_cf => l_cfg_show_all_diag_states, i_prof => i_prof),
                                      pk_alert_constant.g_no);
    
        IF i_preg_out_type = g_preg_out_type_a
        THEN
            SELECT a.catalog_key
              BULK COLLECT
              INTO l_tbl_clave
              FROM cat_diagnosis a
             WHERE (a.catalog_key BETWEEN l_icd10_abort_init AND l_icd10_abort_end OR
                   a.catalog_key = l_icd10_abort_init)
               AND a.catalog_key <> l_icd10_abort_end
             ORDER BY catalog_key;
        
            SELECT COUNT(*)
              INTO o_count
              FROM diagnosis d
              LEFT JOIN alert_diagnosis ad
                ON ad.id_diagnosis = d.id_diagnosis
              JOIN cat_diagnosis a
                ON a.id_concept_term = ad.id_alert_diagnosis
             WHERE ((a.catalog_key BETWEEN l_icd10_abort_init AND l_icd10_abort_end OR
                   a.catalog_key = l_icd10_abort_init) AND a.catalog_key <> l_icd10_abort_end)
               AND d.id_diagnosis IN (SELECT *
                                        FROM TABLE(i_diagnosis));
        
        ELSE
            SELECT a.catalog_key
              BULK COLLECT
              INTO l_tbl_clave
              FROM cat_diagnosis a
             WHERE (a.catalog_key BETWEEN l_icd10_deliv_init AND l_icd10_deliv_end OR
                   a.catalog_key = l_icd10_deliv_init)
               AND a.catalog_key <> l_icd10_deliv_end
             ORDER BY catalog_key;
        
            SELECT COUNT(*)
              INTO o_count
              FROM diagnosis d
              LEFT JOIN alert_diagnosis ad
                ON ad.id_diagnosis = d.id_diagnosis
              JOIN cat_diagnosis a
                ON a.id_concept_term = ad.id_alert_diagnosis
             WHERE ((a.catalog_key BETWEEN l_icd10_deliv_init AND l_icd10_deliv_end OR
                   a.catalog_key = l_icd10_deliv_init) AND a.catalog_key <> l_icd10_deliv_end)
               AND d.id_diagnosis IN (SELECT *
                                        FROM TABLE(i_diagnosis));
        END IF;
    
        SELECT COUNT(*)
          INTO l_exists
          FROM epis_diagnosis ed
          JOIN diagnosis d
            ON d.id_diagnosis = ed.id_diagnosis
          LEFT JOIN alert_diagnosis ad
            ON ad.id_alert_diagnosis = ed.id_alert_diagnosis
          JOIN cat_diagnosis cd
            ON cd.id_concept_term = ad.id_alert_diagnosis
         WHERE ed.id_episode = i_epis
           AND ed.flg_type = pk_diagnosis.g_diag_type_d
           AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
           AND cd.catalog_key IN (SELECT *
                                    FROM TABLE(l_tbl_clave));
    
        IF l_exists > 0
        THEN
            o_exists := pk_alert_constant.g_yes;
        ELSE
            o_exists := pk_alert_constant.g_no;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_DIAGNOSIS_CORE',
                                              'GET_FINAL_DIAG_ABORT_DELIV',
                                              o_error);
            RETURN FALSE;
    END get_final_diag_abort_deliv;

    FUNCTION check_diag_abort_or_deliv
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_diagnosis IN table_number,
        o_flg_type  OUT VARCHAR2,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tbl_abortion table_varchar;
        l_tbl_delivery table_varchar;
    
        l_exist_abort NUMBER;
        l_exist_deliv NUMBER;
    
        l_icd10_abort_init CONSTANT VARCHAR2(3 CHAR) := 'O00';
        l_icd10_abort_end  CONSTANT VARCHAR2(3 CHAR) := 'O08';
    
        l_icd10_deliv_init CONSTANT VARCHAR2(3 CHAR) := 'O80';
        l_icd10_deliv_end  CONSTANT VARCHAR2(3 CHAR) := 'O85';
    
    BEGIN
    
        SELECT a.catalog_key
          BULK COLLECT
          INTO l_tbl_abortion
          FROM cat_diagnosis a
         WHERE (a.catalog_key BETWEEN l_icd10_abort_init AND l_icd10_abort_end OR a.catalog_key = l_icd10_abort_init)
           AND a.catalog_key <> l_icd10_abort_end
         ORDER BY catalog_key;
    
        SELECT a.catalog_key
          BULK COLLECT
          INTO l_tbl_delivery
          FROM cat_diagnosis a
         WHERE (a.catalog_key BETWEEN l_icd10_deliv_init AND l_icd10_deliv_end OR a.catalog_key = l_icd10_deliv_init)
           AND a.catalog_key <> l_icd10_deliv_end
         ORDER BY catalog_key;
    
        -- verify if exist abortion diagnosis
        SELECT COUNT(*)
          INTO l_exist_abort
          FROM diagnosis d
         INNER JOIN alert_diagnosis ad
            ON d.id_diagnosis = ad.id_diagnosis
         INNER JOIN cat_diagnosis cd
            ON cd.id_concept_term = ad.id_alert_diagnosis
         WHERE d.id_diagnosis IN (SELECT *
                                    FROM TABLE(i_diagnosis))
           AND cd.catalog_key IN (SELECT *
                                    FROM TABLE(l_tbl_abortion));
    
        -- verify if exist delivery diagnosis    
        SELECT COUNT(*)
          INTO l_exist_deliv
          FROM diagnosis d
         INNER JOIN alert_diagnosis ad
            ON d.id_diagnosis = ad.id_diagnosis
         INNER JOIN cat_diagnosis cd
            ON cd.id_concept_term = ad.id_alert_diagnosis
         WHERE d.id_diagnosis IN (SELECT *
                                    FROM TABLE(i_diagnosis))
           AND cd.catalog_key IN (SELECT *
                                    FROM TABLE(l_tbl_delivery));
    
        IF l_exist_deliv > 0
           AND l_exist_abort > 0
        THEN
            o_flg_type := pk_diagnosis_core.g_preg_out_type_b;
        ELSIF l_exist_deliv > 0
        THEN
            o_flg_type := pk_diagnosis_core.g_preg_out_type_d;
        ELSIF l_exist_abort > 0
        THEN
            o_flg_type := pk_diagnosis_core.g_preg_out_type_a;
        ELSE
            o_flg_type := NULL;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              'PK_DIAGNOSIS_CORE',
                                              'CHECK_DIAG_ABORT_OR_DELIV',
                                              o_error);
            RETURN FALSE;
    END check_diag_abort_or_deliv;

    FUNCTION tf_diagnosis_notes_cda
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_scope      IN NUMBER,
        i_scope_type IN VARCHAR2
    ) RETURN t_coll_diagnosis_notes_cda
        PIPELINED IS
        l_func_name CONSTANT VARCHAR2(30 CHAR) := 'TF_DIAGNOSIS_NOTES_CDA';
    
        l_id_patient patient.id_patient%TYPE;
        l_id_episode episode.id_episode%TYPE;
        l_id_visit   visit.id_visit%TYPE;
    
        l_rec_diagnosis_notes_cda t_rec_diagnosis_notes_cda;
        l_error                   t_error_out;
    BEGIN
        IF i_scope IS NULL
           OR i_scope_type IS NULL
        THEN
            g_error := 'SCOPE ID OR TYPE IS NULL';
            RAISE g_exception;
        END IF;
    
        g_error := 'ANALYSING SCOPE TYPE';
        IF NOT pk_touch_option.get_scope_vars(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_scope      => i_scope,
                                              i_scope_type => i_scope_type,
                                              o_patient    => l_id_patient,
                                              o_visit      => l_id_visit,
                                              o_episode    => l_id_episode,
                                              o_error      => l_error)
        THEN
            RAISE g_exception;
        END IF;
    
        FOR l_rec_diagnosis_notes_cda IN (SELECT ed.id_epis_diagnosis_notes,
                                                 ed.notes,
                                                 pk_date_utils.date_send_tsz(i_lang, ed.dt_create, i_prof),
                                                 ed.dt_create,
                                                 pk_date_utils.date_char_tsz(i_lang,
                                                                             ed.dt_create,
                                                                             i_prof.institution,
                                                                             i_prof.software)
                                            FROM epis_diagnosis_notes ed
                                           INNER JOIN (SELECT e.id_episode
                                                        FROM episode e
                                                       WHERE e.id_episode = l_id_episode
                                                         AND e.id_patient = l_id_patient
                                                         AND i_scope_type = pk_alert_constant.g_scope_type_episode
                                                      UNION ALL
                                                      SELECT e.id_episode
                                                        FROM episode e
                                                       WHERE e.id_patient = l_id_patient
                                                         AND i_scope_type = pk_alert_constant.g_scope_type_patient
                                                      UNION ALL
                                                      SELECT e.id_episode
                                                        FROM episode e
                                                       WHERE e.id_visit = l_id_visit
                                                         AND e.id_patient = l_id_patient
                                                         AND i_scope_type = pk_alert_constant.g_scope_type_visit) epi
                                              ON ed.id_episode = epi.id_episode)
        LOOP
            PIPE ROW(l_rec_diagnosis_notes_cda);
        END LOOP;
    
        RETURN;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package,
                                              i_function => l_func_name,
                                              o_error    => l_error);
            RETURN;
    END tf_diagnosis_notes_cda;

    /***************************************************************************************
    ***************************************************************************************/
    PROCEDURE insert_diagnosis
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_rec_epis_diag       IN pk_edis_types.rec_in_epis_diagnosis,
        io_new_epis_diag_rows IN OUT table_varchar,
        o_epis_diagnosis      OUT epis_diagnosis.id_epis_diagnosis%TYPE,
        io_params             IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error               OUT t_error_out
    ) IS
        l_inner_proc_name CONSTANT VARCHAR2(30) := 'INSERT_DIAGNOSIS';
        --
        l_rec_diagnosis pk_edis_types.rec_in_diagnosis;
    
        l_id_professional_diag   epis_diagnosis.id_professional_diag%TYPE;
        l_dt_epis_diagnosis_tstz epis_diagnosis.dt_epis_diagnosis_tstz%TYPE;
        l_id_prof_confirmed      epis_diagnosis.id_prof_confirmed%TYPE;
        l_dt_confirmed_tstz      epis_diagnosis.dt_confirmed_tstz%TYPE;
        l_id_prof_rulled_out     epis_diagnosis.id_prof_rulled_out%TYPE;
        l_dt_rulled_out_tstz     epis_diagnosis.dt_rulled_out_tstz%TYPE;
        l_id_prof_base           epis_diagnosis.id_prof_base%TYPE;
        l_dt_base_tstz           epis_diagnosis.dt_base_tstz%TYPE;
    
        l_rowids table_varchar := table_varchar();
    
        l_enable_complication VARCHAR2(100 CHAR) := nvl(pk_sysconfig.get_config('DIAGNOSIS_ENABLE_COMPLICATION', i_prof),
                                                        pk_alert_constant.g_no);
    BEGIN
        l_rec_diagnosis := i_rec_epis_diag.tbl_diagnosis(1);
    
        g_error := 'GET NEXT EPIS_DIAGNOSIS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        o_epis_diagnosis := ts_epis_diagnosis.next_key();
    
        g_error := 'ADD OUTPUT PARAMETER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        add_output_param(i_lang                => i_lang,
                         i_prof                => i_prof,
                         i_episode             => i_rec_epis_diag.id_episode,
                         i_epis_diagnosis      => o_epis_diagnosis,
                         i_epis_diagnosis_hist => NULL,
                         i_dt_record           => i_rec_epis_diag.dt_record,
                         io_params             => io_params);
    
        g_error := 'PROC DECODE EPIS_DIAGNOSIS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
    
        l_id_professional_diag := CASE
                                      WHEN l_rec_diagnosis.flg_status IN
                                           (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_p) THEN
                                       i_prof.id
                                      ELSE
                                       NULL
                                  END;
        l_dt_epis_diagnosis_tstz := CASE
                                        WHEN l_rec_diagnosis.flg_status IN
                                             (pk_diagnosis.g_ed_flg_status_d, pk_diagnosis.g_ed_flg_status_p) THEN
                                         g_sysdate_tstz
                                        ELSE
                                         NULL
                                    END;
        l_id_prof_confirmed      := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_co THEN
                                         i_prof.id
                                        ELSE
                                         NULL
                                    END;
        l_dt_confirmed_tstz      := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_co THEN
                                         i_rec_epis_diag.dt_record
                                        ELSE
                                         NULL
                                    END;
        l_id_prof_rulled_out     := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_r THEN
                                         i_prof.id
                                        ELSE
                                         NULL
                                    END;
        l_dt_rulled_out_tstz     := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_r THEN
                                         i_rec_epis_diag.dt_record
                                        ELSE
                                         NULL
                                    END;
        l_id_prof_base           := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_b THEN
                                         i_prof.id
                                        ELSE
                                         NULL
                                    END;
        l_dt_base_tstz           := CASE l_rec_diagnosis.flg_status
                                        WHEN pk_diagnosis.g_ed_flg_status_b THEN
                                         i_rec_epis_diag.dt_record
                                        ELSE
                                         NULL
                                    END;
    
        g_error := 'INSERT EPIS_DIAGNOSIS: ' || i_rec_epis_diag.flg_type;
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        ts_epis_diagnosis.ins(id_epis_diagnosis_in          => o_epis_diagnosis,
                              id_episode_in                 => i_rec_epis_diag.id_episode,
                              id_patient_in                 => i_rec_epis_diag.id_patient,
                              id_diagnosis_in               => l_rec_diagnosis.id_diagnosis,
                              id_diag_inst_owner_in         => CASE
                                                                   WHEN l_rec_diagnosis.id_diagnosis IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              flg_status_in                 => l_rec_diagnosis.flg_status,
                              id_professional_diag_in       => l_id_professional_diag,
                              dt_epis_diagnosis_tstz_in     => l_dt_epis_diagnosis_tstz,
                              id_prof_confirmed_in          => l_id_prof_confirmed,
                              dt_confirmed_tstz_in          => l_dt_confirmed_tstz,
                              id_prof_rulled_out_in         => l_id_prof_rulled_out,
                              dt_rulled_out_tstz_in         => l_dt_rulled_out_tstz,
                              id_prof_base_in               => l_id_prof_base,
                              dt_base_tstz_in               => l_dt_base_tstz,
                              flg_type_in                   => i_rec_epis_diag.flg_type,
                              desc_epis_diagnosis_in        => l_rec_diagnosis.desc_diagnosis,
                              notes_in                      => l_rec_diagnosis.notes,
                              flg_final_type_in             => l_rec_diagnosis.flg_final_type,
                              id_alert_diagnosis_in         => l_rec_diagnosis.id_alert_diagnosis,
                              id_adiag_inst_owner_in        => CASE
                                                                   WHEN l_rec_diagnosis.id_alert_diagnosis IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              flg_add_problem_in            => l_rec_diagnosis.flg_add_problem,
                              id_cdr_call_in                => i_rec_epis_diag.id_cdr_call,
                              dt_initial_diag_in            => l_rec_diagnosis.dt_initial_diag,
                              id_diag_basis_in              => l_rec_diagnosis.id_diag_basis,
                              id_dbasis_inst_owner_in       => CASE
                                                                   WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              diag_basis_spec_in            => l_rec_diagnosis.diag_basis_spec,
                              flg_recurrence_in             => l_rec_diagnosis.flg_recurrence,
                              flg_mult_tumors_in            => l_rec_diagnosis.flg_mult_tumors,
                              num_primary_tumors_in         => l_rec_diagnosis.num_primary_tumors,
                              id_diagnosis_condition_in     => l_rec_diagnosis.id_diagnosis_condition,
                              id_diagcond_inst_owner_in     => CASE
                                                                   WHEN l_rec_diagnosis.id_diagnosis_condition IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              id_sub_analysis_in            => l_rec_diagnosis.id_sub_analysis,
                              id_subanaly_inst_owner_in     => CASE
                                                                   WHEN l_rec_diagnosis.id_sub_analysis IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              id_anatomical_area_in         => l_rec_diagnosis.id_anatomical_area,
                              id_anatarea_inst_owner_in     => CASE
                                                                   WHEN l_rec_diagnosis.id_anatomical_area IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              id_anatomical_side_in         => l_rec_diagnosis.id_anatomical_side,
                              id_anatside_inst_owner_in     => CASE
                                                                   WHEN l_rec_diagnosis.id_anatomical_side IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              id_lesion_location_in         => l_rec_diagnosis.id_lesion_location,
                              id_lesion_locat_inst_owner_in => CASE
                                                                   WHEN l_rec_diagnosis.id_lesion_location IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              id_lesion_type_in             => l_rec_diagnosis.id_lesion_type,
                              id_lesion_type_inst_owner_in  => CASE
                                                                   WHEN l_rec_diagnosis.id_lesion_type IS NOT NULL THEN
                                                                    pk_alert_constant.g_inst_all
                                                                   ELSE
                                                                    NULL
                                                               END,
                              rank_in                       => CASE
                                                                   WHEN i_rec_epis_diag.flg_type = pk_diagnosis.g_diag_type_d THEN
                                                                    l_rec_diagnosis.rank
                                                                   ELSE
                                                                    NULL
                                                               END,
                              rows_out                      => l_rowids);
    
        io_new_epis_diag_rows.extend;
        io_new_epis_diag_rows(io_new_epis_diag_rows.count) := l_rowids(1);
    
        ----------------------------------------------------
        -- process the diagnosis rank (internaly it verifies if it has something to do)
        manage_epis_diagnosis_rank(i_lang              => i_lang,
                                   i_prof              => i_prof,
                                   i_id_epis_diagnosis => o_epis_diagnosis,
                                   i_id_episode        => i_rec_epis_diag.id_episode,
                                   i_dt_record         => i_rec_epis_diag.dt_record);
    
        g_error := 'CALL SET_EPIS_DIAG_TUMORS_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        IF NOT set_epis_diag_tumors_internal(i_lang => i_lang,
                                             
                                             i_prof           => i_prof,
                                             i_epis_diagnosis => o_epis_diagnosis,
                                             i_tbl_tumors     => l_rec_diagnosis.tbl_tumors,
                                             i_dt_record      => i_rec_epis_diag.dt_record,
                                             io_params        => io_params,
                                             o_error          => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        g_error := 'CALL SET_EPIS_DIAG_STAG_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        IF NOT set_epis_diag_stag_internal(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_epis_diagnosis => o_epis_diagnosis,
                                           i_tbl_diag_stag  => l_rec_diagnosis.tbl_diag_staging,
                                           i_dt_record      => i_rec_epis_diag.dt_record,
                                           io_params        => io_params,
                                           o_error          => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        IF l_enable_complication = pk_alert_constant.g_yes
        THEN
            g_error := 'CALL PK_COMPLICATION.SET_EPIS_DIAG_COMPLICATIONS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            IF NOT pk_complication.set_epis_diag_complications(i_lang              => i_lang,
                                                               i_prof              => i_prof,
                                                               i_epis_diagnosis    => i_rec_epis_diag,
                                                               i_id_epis_diagnosis => o_epis_diagnosis,
                                                               i_dt_record         => i_rec_epis_diag.dt_record,
                                                               io_params           => io_params,
                                                               o_error             => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
    END insert_diagnosis;

    /***************************************************************************************
    ***************************************************************************************/
    PROCEDURE insert_diagnosis_hist
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_rec_epis_diag IN pk_edis_types.rec_in_epis_diagnosis,
        io_params       IN OUT NOCOPY pk_edis_types.table_out_epis_diags,
        o_error         OUT t_error_out
    ) IS
        l_inner_proc_name CONSTANT VARCHAR2(30) := 'INSERT_DIAGNOSIS_HIST';
        --
        l_rec_diagnosis       pk_edis_types.rec_in_diagnosis;
        l_epis_diagnosis_hist epis_diagnosis_hist%ROWTYPE;
        l_epis_diag_hist_pk   epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    
        l_enable_complication VARCHAR2(100 CHAR) := nvl(pk_sysconfig.get_config('DIAGNOSIS_ENABLE_COMPLICATION', i_prof),
                                                        pk_alert_constant.g_no);
    BEGIN
        l_rec_diagnosis := i_rec_epis_diag.tbl_diagnosis(1);
    
        l_epis_diagnosis_hist.id_epis_diagnosis      := i_rec_epis_diag.id_epis_diagnosis;
        l_epis_diagnosis_hist.id_professional        := i_prof.id;
        l_epis_diagnosis_hist.dt_creation_tstz       := i_rec_epis_diag.dt_record;
        l_epis_diagnosis_hist.flg_status             := l_rec_diagnosis.flg_status;
        l_epis_diagnosis_hist.flg_type               := i_rec_epis_diag.flg_type;
        l_epis_diagnosis_hist.notes                  := l_rec_diagnosis.notes;
        l_epis_diagnosis_hist.flg_final_type         := l_rec_diagnosis.flg_final_type;
        l_epis_diagnosis_hist.flg_add_problem        := l_rec_diagnosis.flg_add_problem;
        l_epis_diagnosis_hist.id_cdr_call            := i_rec_epis_diag.id_cdr_call;
        l_epis_diagnosis_hist.dt_initial_diag        := l_rec_diagnosis.dt_initial_diag;
        l_epis_diagnosis_hist.id_diag_basis          := l_rec_diagnosis.id_diag_basis;
        l_epis_diagnosis_hist.id_dbasis_inst_owner := CASE
                                                          WHEN l_rec_diagnosis.id_diag_basis IS NOT NULL THEN
                                                           pk_alert_constant.g_inst_all
                                                          ELSE
                                                           NULL
                                                      END;
        l_epis_diagnosis_hist.diag_basis_spec        := l_rec_diagnosis.diag_basis_spec;
        l_epis_diagnosis_hist.flg_recurrence         := l_rec_diagnosis.flg_recurrence;
        l_epis_diagnosis_hist.flg_mult_tumors        := l_rec_diagnosis.flg_mult_tumors;
        l_epis_diagnosis_hist.num_primary_tumors     := l_rec_diagnosis.num_primary_tumors;
        l_epis_diagnosis_hist.id_diagnosis_condition := l_rec_diagnosis.id_diagnosis_condition;
        l_epis_diagnosis_hist.id_sub_analysis        := l_rec_diagnosis.id_sub_analysis;
        l_epis_diagnosis_hist.id_anatomical_area     := l_rec_diagnosis.id_anatomical_area;
        l_epis_diagnosis_hist.id_anatomical_side     := l_rec_diagnosis.id_anatomical_side;
    
        l_epis_diagnosis_hist.id_lesion_location := l_rec_diagnosis.id_lesion_location;
        l_epis_diagnosis_hist.id_lesion_type     := l_rec_diagnosis.id_lesion_type;
        l_epis_diagnosis_hist.rank               := l_rec_diagnosis.rank;
    
        g_error := 'CALL TO SET_EPIS_DIAG_HIST_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        IF NOT set_epis_diag_hist_internal(i_lang                => i_lang,
                                           i_prof                => i_prof,
                                           i_epis_diagnosis_hist => l_epis_diagnosis_hist,
                                           o_epis_diag_hist      => l_epis_diag_hist_pk,
                                           o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        g_error := 'ADD OUTPUT PARAMETER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        add_output_param(i_lang                => i_lang,
                         i_prof                => i_prof,
                         i_episode             => i_rec_epis_diag.id_episode,
                         i_epis_diagnosis      => i_rec_epis_diag.id_epis_diagnosis,
                         i_epis_diagnosis_hist => l_epis_diag_hist_pk,
                         i_dt_record           => i_rec_epis_diag.dt_record,
                         io_params             => io_params);
    
        g_error := 'CALL SET_EPIS_DIAG_TUMORS_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        IF NOT set_epis_diag_tumors_internal(i_lang                => i_lang,
                                             i_prof                => i_prof,
                                             i_epis_diagnosis_hist => l_epis_diag_hist_pk,
                                             i_tbl_tumors          => l_rec_diagnosis.tbl_tumors,
                                             i_dt_record           => i_rec_epis_diag.dt_record,
                                             io_params             => io_params,
                                             o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        g_error := 'CALL SET_EPIS_DIAG_STAG_INTERNAL';
        pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
        IF NOT set_epis_diag_stag_internal(i_lang                => i_lang,
                                           i_prof                => i_prof,
                                           i_epis_diagnosis_hist => l_epis_diag_hist_pk,
                                           i_tbl_diag_stag       => l_rec_diagnosis.tbl_diag_staging,
                                           i_dt_record           => i_rec_epis_diag.dt_record,
                                           io_params             => io_params,
                                           o_error               => o_error)
        THEN
            RAISE pk_diagnosis.e_call_exception;
        END IF;
    
        IF l_enable_complication = pk_alert_constant.g_yes
        THEN
            g_error := 'CALL PK_COMPLICATION.SET_EPIS_DIAG_COMPLICATIONS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package, sub_object_name => l_inner_proc_name);
            IF NOT pk_complication.set_epis_diag_complications(i_lang              => i_lang,
                                                               i_prof              => i_prof,
                                                               i_epis_diagnosis    => i_rec_epis_diag,
                                                               i_id_epis_diagnosis => i_rec_epis_diag.id_epis_diagnosis,
                                                               i_dt_record         => i_rec_epis_diag.dt_record,
                                                               io_params           => io_params,
                                                               o_error             => o_error)
            THEN
                RAISE pk_diagnosis.e_call_exception;
            END IF;
        END IF;
    END insert_diagnosis_hist;

    /***************************************************************************************
    ***************************************************************************************/
    PROCEDURE manage_epis_diagnosis_rank
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_epis_diagnosis IN epis_diagnosis.id_epis_diagnosis%TYPE DEFAULT NULL,
        i_id_episode        IN epis_diagnosis.id_episode%TYPE,
        i_dt_record         IN TIMESTAMP WITH LOCAL TIME ZONE DEFAULT NULL,
        i_flg_process_hist  IN BOOLEAN DEFAULT TRUE
    ) IS
        l_func_name CONSTANT VARCHAR2(30) := 'MANAGE_EPIS_DIAGNOSIS_RANK';
        l_error t_error_out;
    
        g_manage_principal CONSTANT VARCHAR2(1 CHAR) := 'P';
        g_manage_rank      CONSTANT VARCHAR2(1 CHAR) := 'R';
        l_dis_diag_manage_type VARCHAR2(100 CHAR) := pk_sysconfig.get_config('DISCHARGE_DIAGNOSIS_MANAGE_BY_RANK_OR_PRINCIPAL',
                                                                             i_prof);
    
        l_dt_record              TIMESTAMP WITH LOCAL TIME ZONE := nvl(i_dt_record, current_timestamp);
        l_counter                NUMBER := 0;
        l_this_rank              epis_diagnosis.rank%TYPE;
        l_id_epis_diagnosis      epis_diagnosis.id_epis_diagnosis%TYPE;
        l_id_episode             epis_diagnosis.id_episode%TYPE;
        l_id_epis_diagnosis_hist epis_diagnosis_hist.id_epis_diagnosis_hist%TYPE;
    
        l_id_epis_diagnosis_list table_number := table_number();
        l_rank_list              table_number := table_number();
    BEGIN
        g_error := 'Call MANAGE_EPIS_DIADNOSIS_RANK';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        IF i_id_episode IS NOT NULL
           AND l_dis_diag_manage_type = g_manage_rank -- only process rank if the config indicates the discharhe is managed by rank
        THEN
            -- determine if passed epis_diagnosis is active and is a discharge diagnosis (only these have rank)
            IF i_id_epis_diagnosis IS NOT NULL
            THEN
                BEGIN
                    SELECT COUNT(1), ed.rank
                      INTO l_counter, l_this_rank
                      FROM epis_diagnosis ed
                     WHERE ed.id_epis_diagnosis = i_id_epis_diagnosis
                       AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                             pk_diagnosis.g_ed_flg_status_co,
                                             pk_diagnosis.g_ed_flg_status_b,
                                             pk_diagnosis.g_ed_flg_status_p)
                       AND ed.flg_type = pk_diagnosis.g_diag_type_d
                       AND (ed.id_episode = i_id_episode OR i_id_episode IS NULL)
                       AND (ed.flg_is_complication = pk_alert_constant.g_no OR ed.flg_is_complication IS NULL)
                     GROUP BY ed.rank;
                EXCEPTION
                    WHEN no_data_found THEN
                        RETURN;
                END;
                -- if no record found with this characteristics, then exit
                IF l_counter = 0
                THEN
                    RETURN;
                END IF;
            ELSE
                l_this_rank := NULL;
            END IF;
        
            -- obtain new epis_diag rank
            SELECT ed.id_epis_diagnosis,
                   rank() over(ORDER BY nvl(ed.rank, 0), --
                   nvl(ed.dt_epis_diagnosis_tstz, ed.dt_confirmed_tstz) DESC, --
                   ed.id_epis_diagnosis DESC) rn
              BULK COLLECT
              INTO l_id_epis_diagnosis_list, l_rank_list
              FROM epis_diagnosis ed
             WHERE ed.id_episode = i_id_episode
               AND ed.flg_status IN (pk_diagnosis.g_ed_flg_status_d,
                                     pk_diagnosis.g_ed_flg_status_co,
                                     pk_diagnosis.g_ed_flg_status_b,
                                     pk_diagnosis.g_ed_flg_status_p)
               AND ed.flg_type = pk_diagnosis.g_diag_type_d
               AND ((ed.id_epis_diagnosis != i_id_epis_diagnosis AND i_id_epis_diagnosis IS NOT NULL AND
                   l_this_rank IS NOT NULL) OR i_id_epis_diagnosis IS NULL OR l_this_rank IS NULL)
               AND (ed.flg_is_complication = pk_alert_constant.g_no OR ed.flg_is_complication IS NULL);
        
            -- if list is null then exit    
            IF nvl(cardinality(l_id_epis_diagnosis_list), 0) = 0
            THEN
                RETURN;
            END IF;
        
            -- rearrange rank_list to take in consideration "this_rank"
            IF l_this_rank IS NOT NULL
            THEN
                FOR i IN l_rank_list.first .. l_rank_list.last
                LOOP
                    IF l_rank_list(i) >= l_this_rank
                    THEN
                        l_rank_list(i) := l_rank_list(i) + 1;
                    END IF;
                END LOOP;
            END IF;
        
            -- update ranks
            FOR i IN l_id_epis_diagnosis_list.first .. l_id_epis_diagnosis_list.last
            LOOP
                l_id_epis_diagnosis := NULL;
                l_id_episode        := NULL;
            
                UPDATE epis_diagnosis ed
                   SET ed.rank = l_rank_list(i)
                 WHERE ed.id_epis_diagnosis = l_id_epis_diagnosis_list(i)
                   AND ((ed.rank != l_rank_list(i)) OR (ed.rank IS NULL AND l_rank_list(i) IS NOT NULL))
                RETURNING ed.id_epis_diagnosis, ed.id_episode INTO l_id_epis_diagnosis, l_id_episode;
            
                -- if the update was successful then update epis_diag_hist
                -- if epis_diag to update is different from current one, then update hist
                IF i_flg_process_hist
                   AND i_id_epis_diagnosis IS NOT NULL
                   AND i_id_epis_diagnosis != l_id_epis_diagnosis
                THEN
                    IF NOT set_epis_diag_hist_internal(i_lang           => i_lang,
                                                       i_prof           => i_prof,
                                                       i_episode        => l_id_episode,
                                                       i_epis_diag      => l_id_epis_diagnosis,
                                                       i_sysdate        => l_dt_record,
                                                       o_epis_diag_hist => l_id_epis_diagnosis_hist,
                                                       o_error          => l_error)
                    THEN
                        RAISE g_exception;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
    END manage_epis_diagnosis_rank;

    /***************************************************************************************
    ***************************************************************************************/
    PROCEDURE manage_epis_diagnosis_is_compl
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_episode     IN epis_diagnosis.id_episode%TYPE,
        i_flg_type       IN epis_diagnosis.flg_type%TYPE,
        i_removed_compl  IN table_number,
        i_inserted_compl IN table_number
    ) IS
        l_func_name CONSTANT VARCHAR2(30) := 'MANAGE_EPIS_DIAGNOSIS_IS_COMPL';
        l_error t_error_out;
    
        l_counter NUMBER;
    BEGIN
        IF i_id_episode IS NULL
           OR i_flg_type IS NULL
        THEN
            RETURN;
        END IF;
    
        g_error := 'Call MANAGE_EPIS_DIAGNOSIS_IS_COMPL';
        pk_alertlog.log_info(text => g_error, object_name => g_package, sub_object_name => l_func_name);
    
        -- remove flg_is_complication from epis_diagnosis
        IF i_removed_compl.exists(1)
        THEN
            FOR i IN i_removed_compl.first .. i_removed_compl.last
            LOOP
                -- determine if some complication with the same id_complication is still active
                SELECT COUNT(1)
                  INTO l_counter
                  FROM epis_diag_complications edc
                 WHERE edc.id_complication = i_removed_compl(i)
                   AND edc.flg_status = pk_complication.g_complication_active
                   AND edc.id_epis_diagnosis IN
                       (SELECT ed.id_epis_diagnosis
                          FROM epis_diagnosis ed
                         WHERE ed.id_episode = i_id_episode
                           AND ed.flg_type = i_flg_type
                           AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r))
                   AND ((edc.desc_complication IS NULL) OR
                       (edc.desc_complication IN
                       (SELECT ed.desc_epis_diagnosis
                            FROM epis_diagnosis ed
                            JOIN diagnosis d
                              ON d.id_diagnosis = ed.id_diagnosis
                           WHERE ed.id_episode = i_id_episode
                             AND ed.flg_type = i_flg_type
                             AND ed.flg_status NOT IN (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r)
                             AND d.flg_other = pk_alert_constant.g_yes)));
            
                -- in no more complication is active for this id we can set flg_is_complication = 'N'
                IF l_counter = 0
                THEN
                    UPDATE epis_diagnosis ed
                       SET ed.flg_is_complication = pk_alert_constant.g_no
                     WHERE ed.flg_type = i_flg_type
                       AND ed.id_episode = i_id_episode
                       AND ed.id_diagnosis = i_removed_compl(i)
                       AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca;
                END IF;
            END LOOP;
        END IF;
    
        -- set flg_is_complication = 'Y' to epis_diagnosis
        IF i_inserted_compl.exists(1)
        THEN
            FOR i IN i_inserted_compl.first .. i_inserted_compl.last
            LOOP
                UPDATE epis_diagnosis ed
                   SET ed.flg_is_complication = pk_alert_constant.g_yes
                 WHERE ed.flg_type = i_flg_type
                   AND ed.id_episode = i_id_episode
                   AND ed.id_diagnosis = i_inserted_compl(i)
                   AND ed.flg_status != pk_diagnosis.g_ed_flg_status_ca
                   AND ((ed.desc_epis_diagnosis IS NULL) OR
                       (ed.desc_epis_diagnosis IN
                       (SELECT edc.desc_complication
                            FROM epis_diag_complications edc
                            JOIN diagnosis d
                              ON d.id_diagnosis = edc.id_complication
                           WHERE edc.id_epis_diagnosis IN
                                 (SELECT ed1.id_epis_diagnosis
                                    FROM epis_diagnosis ed1
                                   WHERE ed1.id_episode = i_id_episode
                                     AND ed1.flg_type = i_flg_type
                                     AND ed1.flg_status NOT IN
                                         (pk_diagnosis.g_ed_flg_status_ca, pk_diagnosis.g_ed_flg_status_r))
                             AND edc.flg_status = pk_complication.g_complication_active
                             AND d.flg_other = pk_alert_constant.g_yes)));
            END LOOP;
        END IF;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package,
                                              l_func_name,
                                              l_error);
    END manage_epis_diagnosis_is_compl;

BEGIN
    -- Initialization

    /* CAN'T TOUCH THIS */
    /* Who am I */
    pk_alertlog.who_am_i(owner => g_owner, name => g_package);
    /* Log init */
    pk_alertlog.log_init(object_name => g_package);

    g_processed_episodes := table_number();
END pk_diagnosis_core;
/
