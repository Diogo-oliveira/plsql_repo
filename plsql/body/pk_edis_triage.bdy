/*-- Last Change Revision: $Rev: 2027092 $*/
/*-- Last Change by: $Author: mario.fernandes $*/
/*-- Date of last change: $Date: 2022-08-02 18:41:00 +0100 (ter, 02 ago 2022) $*/

CREATE OR REPLACE PACKAGE BODY pk_edis_triage AS

    g_flg_data_type_vs CONSTANT ds_component.flg_data_type%TYPE := 'VS';

    g_code_msg_not_applicable CONSTANT sys_message.code_message%TYPE := 'N/A';

    g_code_domain_yes_no CONSTANT sys_domain.code_domain%TYPE := 'YES_NO';

    g_ds_vs_node_pk CONSTANT ds_component.id_ds_component%TYPE := 1000004;

    g_est_min_vs_level  CONSTANT triage_esi_level.esi_level%TYPE := 4;
    g_ctas_min_vs_level CONSTANT triage_esi_level.esi_level%TYPE := 5;

    g_code_msg_level_3_and_4 CONSTANT sys_message.code_message%TYPE := 'TRIAGE_T050';

    g_cfg_decimal_symbol CONSTANT sys_config.id_sys_config%TYPE := 'DECIMAL_SYMBOL';

    g_package_name VARCHAR2(32);

    g_triage pk_edis_types.rec_triage;

    g_ds_def_crit_int_name    CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_DEFINING_CRITERIA';
    g_ds_other_crit_int_name  CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_OTHER_CRITERIA';
    g_ds_fast_track_reason    CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK_REASON';
    g_ds_critical_look        CONSTANT ds_component.internal_name%TYPE := 'CRITICAL_LOOK';
    g_ds_fast_track_signature CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK_SIGNATURE';

    g_ctas_warning_title CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M009';
    g_ctas_warning_msg   CONSTANT sys_message.code_message%TYPE := 'TRIAGE_CTAS_M004';
    TYPE table_child_vs IS TABLE OF pk_vital_sign.rec_sign_v;

    TYPE rec_vital_sign IS RECORD(
        id_ds_component ds_component.id_ds_component%TYPE,
        internal_name   ds_component.internal_name%TYPE,
        id_vital_sign   vital_sign.id_vital_sign%TYPE,
        vs              pk_vital_sign.rec_sign_v,
        child_vs        table_child_vs);

    TYPE table_vital_signs IS TABLE OF rec_vital_sign;
    --
    g_nls_num_char CONSTANT VARCHAR2(30) := 'NLS_NUMERIC_CHARACTERS';

    g_back_nls        VARCHAR2(2) := NULL;
    g_is_to_reset_nls BOOLEAN := FALSE;
    --
    PROCEDURE set_nls_numeric_characters(i_prof IN profissional) IS
    
        l_proc_name CONSTANT VARCHAR2(30) := 'SET_NLS_NUMERIC_CHARACTERS';
        --
        l_decimal_symbol  sys_config.value%TYPE;
        l_grouping_symbol VARCHAR2(1);
    BEGIN
        IF g_is_to_reset_nls
           AND g_back_nls IS NOT NULL
        THEN
            g_error := 'RESET NLS_NUMERIC_CHARACTERS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_proc_name, text => g_error);
            EXECUTE IMMEDIATE 'ALTER SESSION SET ' || g_nls_num_char || ' = ''' || g_back_nls || '''';
        
            g_is_to_reset_nls := FALSE;
        ELSIF NOT g_is_to_reset_nls
        THEN
            g_error := 'GET DECIMAL SYMBOL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_proc_name, text => g_error);
            -- Flash is going to send all numbers with the . as decimal separator,
            -- so I'm not going to use this call pk_sysconfig.get_config('DECIMAL_SYMBOL', i_prof);
            l_decimal_symbol := '.';
        
            g_error := 'SET GROUPING SYMBOL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_proc_name, text => g_error);
            IF l_decimal_symbol = ','
            THEN
                l_grouping_symbol := '.';
            ELSE
                l_grouping_symbol := ',';
            END IF;
        
            g_error := 'GET NLS_NUMERIC_CHARACTERS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_proc_name, text => g_error);
            SELECT VALUE
              INTO g_back_nls
              FROM nls_session_parameters
             WHERE parameter = g_nls_num_char;
        
            g_error := 'SET NLS_NUMERIC_CHARACTERS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_proc_name, text => g_error);
            EXECUTE IMMEDIATE 'ALTER SESSION SET ' || g_nls_num_char || ' = ''' || l_decimal_symbol ||
                              l_grouping_symbol || '''';
        
            g_is_to_reset_nls := TRUE;
        END IF;
    END set_nls_numeric_characters;

    PROCEDURE open_my_cursor(i_cursor IN OUT cursor_anamnesis) IS
    BEGIN
        IF i_cursor%ISOPEN
        THEN
            CLOSE i_cursor;
        END IF;
    
        OPEN i_cursor FOR
            SELECT NULL id_epis_anamnesis, NULL desc_epis_anamnesis
              FROM dual
             WHERE 1 = 0;
    END open_my_cursor;

    /**********************************************************************************************
    * Registar os sinais vitais da triagem
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_prof_cat_type          Professional category
    * @param i_id_epis                id do episódio clinico
    * @param i_dt_triage_begin        Triage begin date
    * @param i_vs_id                  Array de IDs de SVs lidos 
    * @param i_vs_val                 Array de leituras dos SVs de I_VS_ID ( (valor do sinal vital) 
    * @param i_unit_meas              ID's das unidades de medida dos sinais vitais a inserir
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/06/19 
    **********************************************************************************************/
    FUNCTION set_triage_vs
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_prof_cat_type     IN category.flg_type%TYPE,
        i_id_epis           IN episode.id_episode%TYPE,
        i_patient           IN patient.id_patient%TYPE,
        i_epis_triage       IN epis_triage.id_epis_triage%TYPE,
        i_dt_triage_begin   IN epis_triage.dt_begin_tstz%TYPE,
        i_vs_id             IN table_number,
        i_vs_val            IN table_number,
        i_unit_meas         IN table_number,
        i_scales_element_id IN table_number,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'SET_TRIAGE_VS';
    
        l_tbl_dt_vs_read table_varchar;
        l_rows_vsr_out   table_number;
        --
        l_exception EXCEPTION;
        l_dt_registry VARCHAR2(20 CHAR);
    BEGIN
        --This way the table l_tbl_dt_vs_read will have the same number of elements as i_vs_id table
        SELECT pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => i_dt_triage_begin, i_prof => i_prof)
          BULK COLLECT
          INTO l_tbl_dt_vs_read
          FROM TABLE(i_vs_id);
    
        IF NOT pk_vital_sign.set_epis_vital_sign(i_lang               => i_lang,
                                                 i_episode            => i_id_epis,
                                                 i_prof               => i_prof,
                                                 i_pat                => i_patient,
                                                 i_vs_id              => i_vs_id,
                                                 i_vs_val             => i_vs_val,
                                                 i_id_monit           => NULL,
                                                 i_unit_meas          => i_unit_meas,
                                                 i_vs_scales_elements => i_scales_element_id,
                                                 i_notes              => NULL,
                                                 i_prof_cat_type      => i_prof_cat_type,
                                                 i_dt_vs_read         => l_tbl_dt_vs_read,
                                                 i_epis_triage        => i_epis_triage,
                                                 i_unit_meas_convert  => i_unit_meas,
                                                 o_vital_sign_read    => l_rows_vsr_out,
                                                 o_dt_registry        => l_dt_registry,
                                                 o_error              => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_triage_vs;
    --
    /**********************************************************************************************
    * Determines if the patient age is within the limits defined to the flowchart or
    * flowchart group, while taking into account the configurations defined by the institution.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_pat_age                Patient age
    * @param i_age_limit              Limit to check (minimum or maximum)
    * @param i_limit_type             (MIN) Check minimum; (MAX) Check maximum;
    * @param i_flg_check_age_limits   Value of TRIAGE_CONFIGURATION.FLG_CHECK_AGE_LIMITS
    * @param i_override_config        Value of TRIAGE_BOARD.FLG_OVERRIDE_CONFIG, if available
    *
    * @return                         Y - Value within the limits; N - Value not within the limits.
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          2010/02/11 
    **********************************************************************************************/
    FUNCTION check_age_limits
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_pat_age              IN NUMBER,
        i_age_limit            IN NUMBER,
        i_limit_type           IN VARCHAR2,
        i_flg_check_age_limits IN triage_configuration.flg_check_age_limits%TYPE,
        i_override_config      IN triage_board.flg_override_config%TYPE DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_result               VARCHAR2(1) := pk_alert_constant.g_no;
        l_flg_check_age_limits triage_configuration.flg_check_age_limits%TYPE;
        l_override_config      triage_board.flg_override_config%TYPE;
    
        l_error t_error_out;
        l_param_error EXCEPTION;
    BEGIN
    
        IF i_limit_type NOT IN (g_age_min, g_age_max)
           OR i_limit_type IS NULL
        THEN
            RAISE l_param_error;
        END IF;
    
        IF i_flg_check_age_limits IS NULL
        THEN
            l_flg_check_age_limits := pk_alert_constant.g_yes;
        ELSE
            l_flg_check_age_limits := i_flg_check_age_limits;
        END IF;
    
        IF i_override_config IS NULL
        THEN
            l_override_config := pk_alert_constant.g_no;
        ELSE
            l_override_config := i_override_config;
        END IF;
    
        IF (i_pat_age >= i_age_limit AND i_limit_type = g_age_min OR
           i_pat_age <= i_age_limit AND i_limit_type = g_age_max)
           AND (l_flg_check_age_limits = pk_alert_constant.g_yes OR l_override_config = pk_alert_constant.g_yes)
           AND i_pat_age IS NOT NULL
           AND i_age_limit IS NOT NULL
        THEN
            l_result := pk_alert_constant.g_yes;
        
        ELSIF i_age_limit IS NULL
              OR i_pat_age IS NULL
              OR (l_flg_check_age_limits = pk_alert_constant.g_no AND l_override_config = pk_alert_constant.g_no)
        THEN
            l_result := pk_alert_constant.g_yes;
        
        END IF;
    
        RETURN l_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'CHECK_AGE_LIMITS',
                                              l_error);
            RETURN NULL;
    END check_age_limits;

    /**********************************************************************************************
    * Listar os grupos de fluxograma da triagem
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_episode                episode id
    * @param i_patient                patient id
    * @param i_urgency_level          Display flowcharts that support this urgency level (when applicable)
    * @param o_triage_board_g         Cursor with all group triage board
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/09/13 
    **********************************************************************************************/
    FUNCTION get_triage_board_group
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_patient        IN patient.id_patient%TYPE,
        i_urgency_level  IN NUMBER,
        o_triage_board_g OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_triage_type triage_type.id_triage_type%TYPE;
        l_pat_gender  patient.gender%TYPE;
        l_age         VARCHAR2(20);
    
        l_triage_check_age triage_configuration.flg_check_age_limits%TYPE;
        l_filter_flowchart triage_configuration.flg_filter_flowchart%TYPE;
    BEGIN
        g_error       := 'GET TRIAGE_TYPE';
        l_triage_type := get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        l_triage_check_age := get_triage_config_by_name(i_lang,
                                                        i_prof,
                                                        i_episode,
                                                        l_triage_type,
                                                        'FLG_CHECK_AGE_LIMITS');
    
        g_error := 'GET CONFIGURATIONS (3)';
        IF i_urgency_level IS NOT NULL
        THEN
            l_filter_flowchart := get_triage_config_by_name(i_lang,
                                                            i_prof,
                                                            i_episode,
                                                            l_triage_type,
                                                            'FLG_FILTER_FLOWCHART');
        ELSE
            l_filter_flowchart := g_no;
        END IF;
    
        -- Qual o sexo do paciente
        g_error := 'GET PATIENT GENDER';
        SELECT p.gender, nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age
          INTO l_pat_gender, l_age
          FROM episode e, patient p
         WHERE e.id_episode = i_episode
           AND e.id_patient = p.id_patient;
    
        g_error := 'GET CURSOR O_TRIAGE_BOARD_G';
        OPEN o_triage_board_g FOR
            SELECT tbg.id_triage_board_group,
                   pk_translation.get_translation(i_lang, tbg.code_triage_board_group) desc_triage_board
              FROM triage_board_group tbg
              LEFT JOIN triage_age_limit tal
                ON tal.id_triage_board_group = tbg.id_triage_board_group
               AND tal.flg_available = pk_alert_constant.g_yes
               AND (tal.id_institution = i_prof.institution OR tal.id_institution = 0 AND NOT EXISTS
                    (SELECT 0
                       FROM triage_age_limit tal1
                      WHERE tal1.id_triage_board_group = tbg.id_triage_board_group
                        AND tal1.id_institution = i_prof.institution
                        AND tal1.flg_available = pk_alert_constant.g_yes))
             WHERE tbg.flg_available = g_yes
               AND tbg.id_triage_type = l_triage_type
               AND (l_pat_gender = tbg.gender OR tbg.gender IS NULL OR l_pat_gender IS NULL OR
                   upper(l_pat_gender) IN ('N', 'I') OR upper(tbg.gender) IN ('N', 'I'))
                  -- José Brito 11/02/2009 ALERT-74105 Added configuration to indicate if age limits should be checked
               AND check_age_limits(i_lang, i_prof, l_age, tal.age_min, g_age_min, l_triage_check_age) =
                   pk_alert_constant.g_yes
               AND check_age_limits(i_lang, i_prof, l_age, tal.age_max, g_age_max, l_triage_check_age) =
                   pk_alert_constant.g_yes
               AND ((l_filter_flowchart = g_yes AND
                   tbg.id_triage_board_group IN
                   (SELECT tbgi.id_triage_board_group
                        FROM triage_board_acuity_lvl tbal
                        JOIN triage_esi_level tel
                          ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                        JOIN triage_board_grouping tbgi
                          ON tbgi.id_triage_board = tbal.id_triage_board
                       WHERE ((i_urgency_level != g_est_min_vs_level AND tel.esi_level <= i_urgency_level) OR
                             i_urgency_level = g_est_min_vs_level) --Requirement 1.4 of Analisys document
                         AND tbal.flg_available = g_yes
                         AND tel.flg_available = g_yes)) OR l_filter_flowchart = g_no)
             ORDER BY tbg.rank, desc_triage_board;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_TRIAGE_BOARD_GROUP',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END;

    /**********************************************************************************************
    * Listar as descrições e respectiva relação grupo / fluxograma da triagem.
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_episode                episode id
    * @param i_patient                patient id
    * @param i_t_board_group          ID do grupo do fluxograma 
    * @param i_flg_view               Tipo de visão: V1- Visão 1 de manchester
                                                     V2- Visão 2 de manchester
    * @param i_urgency_level          Display flowcharts that support this urgency level (when applicable)
    * @param o_triage_board           Cursor with all triage board
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/09/13 
    **********************************************************************************************/
    FUNCTION get_triage_board_grouping
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_episode       IN episode.id_episode%TYPE,
        i_patient       IN patient.id_patient%TYPE,
        i_t_board_group IN triage_board_group.id_triage_board_group%TYPE,
        i_flg_view      IN VARCHAR2,
        i_urgency_level IN NUMBER,
        o_triage_board  OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
        l_triage_type          triage_type.id_triage_type%TYPE;
        l_pat_gender           patient.gender%TYPE;
        l_age                  VARCHAR2(20);
        l_triage_show_id_board triage_configuration.flg_id_board%TYPE;
        l_triage_check_age     triage_configuration.flg_check_age_limits%TYPE;
        l_filter_flowchart     triage_configuration.flg_filter_flowchart%TYPE;
    
        l_empty_table    table_number := table_number();
        l_warn_flowchart VARCHAR2(1 CHAR);
    BEGIN
        g_error       := 'GET TRIAGE_TYPE';
        l_triage_type := pk_edis_triage.get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        g_error                := 'GET CONFIGURATIONS (1)';
        l_triage_show_id_board := get_triage_config_by_name(i_lang, i_prof, i_episode, l_triage_type, 'FLG_ID_BOARD');
        g_error                := 'GET CONFIGURATIONS (2)';
        l_triage_check_age     := get_triage_config_by_name(i_lang,
                                                            i_prof,
                                                            i_episode,
                                                            l_triage_type,
                                                            'FLG_CHECK_AGE_LIMITS');
    
        g_error := 'GET CONFIGURATIONS (3)';
        IF i_urgency_level IS NOT NULL
        THEN
            l_filter_flowchart := get_triage_config_by_name(i_lang,
                                                            i_prof,
                                                            i_episode,
                                                            l_triage_type,
                                                            'FLG_FILTER_FLOWCHART');
        ELSE
            l_filter_flowchart := g_no;
        END IF;
    
        IF l_triage_type IN (g_triage_id_ctas_p, g_triage_id_ctas_a)
        THEN
            l_warn_flowchart := pk_alert_constant.g_yes;
        END IF;
        -- Check patient gender
        g_error := 'GET PATIENT GENDER';
        SELECT p.gender, nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age
          INTO l_pat_gender, l_age
          FROM episode e, patient p
         WHERE e.id_episode = i_episode
           AND e.id_patient = p.id_patient;
    
        IF i_flg_view = g_flg_view_v1
        THEN
            g_error := 'GET CURSOR O_TRIAGE_BOARD: ' || i_flg_view;
            OPEN o_triage_board FOR
                SELECT tbgi.id_triage_board_grouping,
                       tbgi.id_triage_board,
                       tbgi.id_triage_board_group,
                       decode(l_triage_show_id_board, pk_alert_constant.g_yes, tb.board_number || ' - ') ||
                       pk_translation.get_translation(i_lang, tb.code_triage_board) desc_triage_board,
                       tb.sex,
                       pk_translation.get_translation(i_lang, tb.code_triage_board) desc_board,
                       tbgi.rank,
                       -- EST triage fields:
                       -- 1) Selecting this flowchart, triage advances to confirmation screen
                       tb.flg_direct_confirm,
                       -- 2) ID_TRIAGE_DISCRIMINATOR to be used when triage advances to confirmation screen
                       decode(tb.flg_direct_confirm,
                              g_no,
                              NULL,
                              (SELECT t.id_triage_discriminator
                                 FROM triage t
                                WHERE t.id_triage_board = tb.id_triage_board
                                  AND t.flg_available = g_yes)) id_triage_discriminator,
                       -- 3) Urgency levels supported by the flowchart
                       CASE
                            WHEN l_triage_type IN
                                 (g_triage_id_est, g_triage_id_sa, g_triage_id_ctas_p, g_triage_id_ctas_a) THEN
                             CAST(MULTISET (SELECT DISTINCT tel.esi_level
                                     FROM triage_board_acuity_lvl tbal
                                     JOIN triage_esi_level tel
                                       ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                                    WHERE tbal.id_triage_board = tb.id_triage_board
                                      AND tbal.flg_available = g_yes
                                      AND tel.flg_available = g_yes
                                    ORDER BY 1) AS table_number)
                            ELSE
                             l_empty_table
                        END urgency_level_list,
                       (SELECT COUNT(*)
                          FROM triage t
                         WHERE t.id_triage_board = tb.id_triage_board) total_discrims,
                       nvl2(pk_translation.get_translation(i_lang, tb.code_help_triage_board), 'Y', 'N') flg_context_help,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              check_board_level_msg(tb.id_triage_board, i_urgency_level),
                              tb.flg_show_warning) flg_show_warning,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              decode(check_board_level_msg(tb.id_triage_board, i_urgency_level),
                                     pk_alert_constant.g_yes,
                                     pk_message.get_message(i_lang, g_ctas_warning_title),
                                     decode(tb.flg_show_warning,
                                            pk_alert_constant.g_yes,
                                            pk_translation.get_translation(i_lang      => i_lang,
                                                                           i_code_mess => tb.code_warning_title),
                                            NULL))) desc_warning_title,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              decode(check_board_level_msg(tb.id_triage_board, i_urgency_level),
                                     pk_alert_constant.g_yes,
                                     pk_message.get_message(i_lang, g_ctas_warning_msg),
                                     decode(tb.flg_show_warning,
                                            pk_alert_constant.g_yes,
                                            pk_translation.get_translation(i_lang      => i_lang,
                                                                           i_code_mess => tb.code_warning_msg),
                                            NULL))) desc_warning_msg,
                       tb.flg_req_yes_discrim
                  FROM triage_board_grouping tbgi
                  JOIN triage_board tb
                    ON tb.id_triage_board = tbgi.id_triage_board
                  JOIN triage_board_group tbg
                    ON tbg.id_triage_board_group = tbgi.id_triage_board_group
                  LEFT JOIN triage_age_limit tal
                    ON tal.id_triage_board = tb.id_triage_board
                   AND tal.flg_available = pk_alert_constant.g_yes
                   AND (tal.id_institution = i_prof.institution OR tal.id_institution = 0 AND NOT EXISTS
                        (SELECT 0
                           FROM triage_age_limit tal1
                          WHERE tal1.id_triage_board = tb.id_triage_board
                            AND tal1.id_institution = i_prof.institution
                            AND tal1.flg_available = pk_alert_constant.g_yes))
                 WHERE tbgi.id_triage_board_group = i_t_board_group
                   AND tbg.id_triage_type = l_triage_type
                   AND tbgi.flg_available = g_yes
                   AND tb.flg_initial_screen_board = g_no -- Exclude "special" flowcharts of EST triage protocol
                      -- Filter by urgency level, if applicable
                   AND ((l_filter_flowchart = g_yes AND
                       tb.id_triage_board IN
                       (SELECT tbal.id_triage_board
                            FROM triage_board_acuity_lvl tbal
                            JOIN triage_esi_level tel
                              ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                           WHERE ((i_urgency_level != g_est_min_vs_level AND tel.esi_level <= i_urgency_level) OR
                                 i_urgency_level = g_est_min_vs_level) --Requirement 1.4 of Analisys document
                             AND tbal.flg_available = g_yes
                             AND tel.flg_available = g_yes)) OR l_filter_flowchart = g_no)
                      -- Filter by gender
                   AND (l_pat_gender = tb.sex OR tb.sex IS NULL OR l_pat_gender IS NULL OR
                       upper(l_pat_gender) IN ('N', 'I') OR upper(tb.sex) IN ('N', 'I'))
                      -- José Brito 11/02/2009 ALERT-74105 Added configuration to indicate if age limits should be checked
                   AND check_age_limits(i_lang,
                                        i_prof,
                                        l_age,
                                        tal.age_min,
                                        g_age_min,
                                        l_triage_check_age,
                                        tb.flg_override_config) = pk_alert_constant.g_yes
                   AND check_age_limits(i_lang,
                                        i_prof,
                                        l_age,
                                        tal.age_max,
                                        g_age_max,
                                        l_triage_check_age,
                                        tb.flg_override_config) = pk_alert_constant.g_yes
                -- IMPORTANT: All changes in the ORDER BY criteria, must also be changed in the Flash layer (TriageCreateView2.as)
                 ORDER BY tbgi.rank, desc_board;
        ELSE
            g_error := 'GET CURSOR O_TRIAGE_BOARD: ' || i_flg_view;
            OPEN o_triage_board FOR
                SELECT tbgi.id_triage_board_grouping,
                       tbgi.id_triage_board,
                       tbgi.id_triage_board_group,
                       decode(l_triage_show_id_board, pk_alert_constant.g_yes, tb.board_number || ' - ') ||
                       pk_translation.get_translation(i_lang, tb.code_triage_board) desc_triage_board,
                       tb.sex,
                       pk_translation.get_translation(i_lang, tb.code_triage_board) desc_board,
                       tbgi.rank,
                       -- EST triage fields:
                       -- 1) Selecting this flowchart, triage advances to confirmation screen
                       tb.flg_direct_confirm,
                       -- 2) ID_TRIAGE_DISCRIMINATOR to be used when triage advances to confirmation screen
                       decode(tb.flg_direct_confirm,
                              g_no,
                              NULL,
                              (SELECT t.id_triage_discriminator
                                 FROM triage t
                                WHERE t.id_triage_board = tb.id_triage_board
                                  AND t.flg_available = g_yes)) id_triage_discriminator,
                       -- 3) Urgency levels supported by the flowchart
                       CASE
                            WHEN l_triage_type IN
                                 (g_triage_id_est, g_triage_id_sa, g_triage_id_ctas_p, g_triage_id_ctas_a) THEN
                             CAST(MULTISET (SELECT DISTINCT tel.esi_level
                                     FROM triage_board_acuity_lvl tbal
                                     JOIN triage_esi_level tel
                                       ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                                    WHERE tbal.id_triage_board = tb.id_triage_board
                                      AND tbal.flg_available = g_yes
                                      AND tel.flg_available = g_yes
                                    ORDER BY 1) AS table_number)
                            ELSE
                             l_empty_table
                        END urgency_level_list,
                       nvl2(pk_translation.get_translation(i_lang, tb.code_help_triage_board), 'Y', 'N') flg_context_help,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              check_board_level_msg(tb.id_triage_board, i_urgency_level),
                              tb.flg_show_warning) flg_show_warning,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              decode(check_board_level_msg(tb.id_triage_board, i_urgency_level),
                                     pk_alert_constant.g_yes,
                                     pk_message.get_message(i_lang, g_ctas_warning_title),
                                     decode(tb.flg_show_warning,
                                            pk_alert_constant.g_yes,
                                            pk_translation.get_translation(i_lang      => i_lang,
                                                                           i_code_mess => tb.code_warning_title),
                                            NULL))) desc_warning_title,
                       decode(l_warn_flowchart,
                              pk_alert_constant.g_yes,
                              decode(check_board_level_msg(tb.id_triage_board, i_urgency_level),
                                     pk_alert_constant.g_yes,
                                     pk_message.get_message(i_lang, g_ctas_warning_msg),
                                     decode(tb.flg_show_warning,
                                            pk_alert_constant.g_yes,
                                            pk_translation.get_translation(i_lang      => i_lang,
                                                                           i_code_mess => tb.code_warning_msg),
                                            NULL))) desc_warning_msg,
                       tb.flg_req_yes_discrim
                  FROM (SELECT id_triage_board,
                               MIN(id_triage_board_group) id_triage_board_group,
                               MIN(rank) rank,
                               MIN(id_triage_board_grouping) id_triage_board_grouping
                          FROM triage_board_grouping
                         WHERE flg_available = g_yes
                         GROUP BY id_triage_board) tbgi
                  JOIN triage_board tb
                    ON tb.id_triage_board = tbgi.id_triage_board
                  JOIN triage_board_group tbg
                    ON tbg.id_triage_board_group = tbgi.id_triage_board_group
                  LEFT JOIN triage_age_limit tal
                    ON tal.id_triage_board = tb.id_triage_board
                   AND tal.flg_available = pk_alert_constant.g_yes
                   AND (tal.id_institution = i_prof.institution OR tal.id_institution = 0 AND NOT EXISTS
                        (SELECT 0
                           FROM triage_age_limit tal1
                          WHERE tal1.id_triage_board = tb.id_triage_board
                            AND tal1.id_institution = i_prof.institution
                            AND tal1.flg_available = pk_alert_constant.g_yes))
                 WHERE tbg.id_triage_type = l_triage_type
                   AND tb.flg_initial_screen_board = g_no -- Exclude "special" flowcharts of EST triage protocol
                      -- Filter by urgency level, if applicable
                   AND ((l_filter_flowchart = g_yes AND
                       tb.id_triage_board IN
                       (SELECT tbal.id_triage_board
                            FROM triage_board_acuity_lvl tbal
                            JOIN triage_esi_level tel
                              ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                           WHERE ((i_urgency_level != g_est_min_vs_level AND tel.esi_level <= i_urgency_level) OR
                                 i_urgency_level = g_est_min_vs_level) --Requirement 1.4 of Analisys document
                             AND tbal.flg_available = g_yes
                             AND tel.flg_available = g_yes)) OR l_filter_flowchart = g_no)
                      -- Filter by gender
                   AND (l_pat_gender = tb.sex OR tb.sex IS NULL OR l_pat_gender IS NULL OR
                       upper(l_pat_gender) IN ('N', 'I') OR upper(tb.sex) IN ('N', 'I'))
                      -- José Brito 11/02/2009 ALERT-74105 Added configuration to indicate if age limits should be checked
                   AND check_age_limits(i_lang,
                                        i_prof,
                                        l_age,
                                        tal.age_min,
                                        g_age_min,
                                        l_triage_check_age,
                                        tb.flg_override_config) = pk_alert_constant.g_yes
                   AND check_age_limits(i_lang,
                                        i_prof,
                                        l_age,
                                        tal.age_max,
                                        g_age_max,
                                        l_triage_check_age,
                                        tb.flg_override_config) = pk_alert_constant.g_yes
                -- IMPORTANT: All changes in the ORDER BY criteria, must also be changed in the Flash layer (TriageCreateView2.as)
                 ORDER BY tbgi.rank, desc_board;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_TRIAGE_BOARD_GROUPING',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END;
    --
    /*
        FUNCTION get_triage_board_grouping
        (
            i_lang          IN language.id_language%TYPE,
            i_prof          IN profissional,
            i_episode       IN episode.id_episode%TYPE,
            i_patient       IN patient.id_patient%TYPE,
            i_t_board_group IN triage_board_group.id_triage_board_group%TYPE,
            i_flg_view      IN VARCHAR2,
            o_triage_board  OUT pk_types.cursor_type,
            o_error         OUT t_error_out
        ) RETURN BOOLEAN IS
        BEGIN
            RETURN get_triage_board_grouping(i_lang,
                                             i_prof,
                                             i_episode,
                                             i_patient,
                                             i_t_board_group,
                                             i_flg_view,
                                             NULL,
                                             o_triage_board,
                                             o_error);
        END;
    */
    --
    /**********************************************************************************************
    * Listar os conteudos de: - Grupo do fluxograma da triagem - Fluxograma da triagem
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_t_board_group          ID do grupo do fluxograma
    * @param i_triage_board           ID do fluxograma    
    * @param i_discrimin              discriminator id
    * @param o_title_triage           Cursor with all title triage
    * @param o_help_triage            Cursor with all help triage   
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/09/14
    **********************************************************************************************/
    FUNCTION get_help_triage
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_t_board_group IN triage_board_group.id_triage_board_group%TYPE,
        i_triage_board  IN triage_board.id_triage_board%TYPE,
        i_discrimin     IN triage_discriminator.id_triage_discriminator%TYPE,
        o_title_triage  OUT pk_types.cursor_type,
        o_help_triage   OUT pk_types.cursor_type,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        --
        IF i_t_board_group IS NOT NULL
        THEN
            -- Conteudo do grupo do fluxograma de triagem  
            g_error := 'GET CURSOR O_TITLE_TRIAGE  - TBG';
            OPEN o_title_triage FOR
                SELECT pk_translation.get_translation(i_lang, code_triage_board_group) desc_title_triage
                  FROM triage_board_group
                 WHERE id_triage_board_group = i_t_board_group;
            --
            g_error := 'GET CURSOR O_HELP_TRIAGE  - TBG';
            OPEN o_help_triage FOR
                SELECT pk_translation.get_translation(i_lang, code_help_triage_board_group) desc_help_triage
                  FROM triage_board_group
                 WHERE id_triage_board_group = i_t_board_group;
        
        ELSIF i_triage_board IS NOT NULL
        THEN
            -- Conteudo do fluxograma de triagem  
            g_error := 'GET CURSOR O_TITLE_TRIAGE  - TB';
            OPEN o_title_triage FOR
                SELECT pk_translation.get_translation(i_lang, code_triage_board) desc_title_triage
                  FROM triage_board
                 WHERE id_triage_board = i_triage_board;
            --        
            g_error := 'GET CURSOR O_HELP_TRIAGE  - TB';
            OPEN o_help_triage FOR
                SELECT pk_translation.get_translation(i_lang, code_help_triage_board) desc_help_triage
                  FROM triage_board
                 WHERE id_triage_board = i_triage_board;
        
        ELSIF i_discrimin IS NOT NULL
        THEN
            -- Conteudo do discriminador  
            g_error := 'GET CURSOR O_TITLE_TRIAGE  - DH';
            OPEN o_title_triage FOR
                SELECT nvl(pk_translation.get_translation(i_lang, tdh.code_title_triage_disc_help),
                           pk_translation.get_translation(i_lang, td.code_triage_discriminator)) desc_title_triage
                  FROM triage_discriminator_help tdih, triage_disc_help tdh, triage_discriminator td
                 WHERE tdh.id_triage_disc_help = tdih.id_triage_disc_help
                   AND tdih.id_triage_discriminator = td.id_triage_discriminator
                   AND tdih.id_triage_discriminator = i_discrimin
                   AND tdih.flg_available = g_flg_available
                   AND rownum = 1;
        
            g_error := 'GET CURSOR O_HELP_TRIAGE  - DH';
            OPEN o_help_triage FOR
                SELECT pk_translation.get_translation(i_lang, tdh.code_triage_disc_help) desc_help_triage
                  FROM triage_discriminator_help tdih, triage_disc_help tdh
                 WHERE tdh.id_triage_disc_help = tdih.id_triage_disc_help
                   AND tdih.id_triage_discriminator = i_discrimin
                   AND tdih.flg_available = g_flg_available
                   AND rownum = 1;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_types.open_my_cursor(o_title_triage);
            pk_types.open_my_cursor(o_help_triage);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_HELP_TRIAGE',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END;
    --
    FUNCTION get_vs_relation_domain(i_tab_vital_sign IN table_number) RETURN vital_sign_relation.relation_domain%TYPE IS
        l_count PLS_INTEGER;
        l_ret   vital_sign_relation.relation_domain%TYPE := pk_alert_constant.g_vs_rel_group;
    BEGIN
        IF i_tab_vital_sign.exists(1)
        THEN
            BEGIN
                SELECT COUNT(*)
                  INTO l_count
                  FROM TABLE(i_tab_vital_sign) tbl_vs
                 WHERE tbl_vs.column_value =
                       (SELECT vs.id_vital_sign
                          FROM vital_sign vs
                         WHERE vs.intern_name_vital_sign = pk_edis_triage.g_vs_trts);
            EXCEPTION
                WHEN no_data_found THEN
                    l_count := 0;
            END;
        
            IF l_count > 0
            THEN
                l_ret := pk_alert_constant.g_vs_rel_man;
            END IF;
        END IF;
    
        RETURN l_ret;
    END get_vs_relation_domain;
    --
    /**************************************************************************
    * Returns the set of discriminators for the current box, in a given board (flowchart).
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_patient                Patient ID
    * @param i_episode                Episode ID
    * @param i_tbl_triage             Triage table id's
    * @param i_triage_board           Triage board id
    * @param i_triage_color           Triage color id
    * @param i_triage_check_age       Is to check the patient age?
    * @param i_pat_gender             Patient gender
    * @param i_age                    Patient age
    * @param i_age_str                Patient age
    *
    * @return                         Triage discriminators table
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          07/10/2013
    **************************************************************************/
    FUNCTION tf_triage_discrim
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_patient          IN patient.id_patient%TYPE,
        i_episode          IN episode.id_episode%TYPE,
        i_tbl_triage       IN table_number DEFAULT table_number(),
        i_triage_board     IN triage_board.id_triage_board%TYPE DEFAULT NULL,
        i_triage_color     IN triage_color.id_triage_color%TYPE DEFAULT NULL,
        i_triage_check_age IN triage_configuration.flg_check_age_limits%TYPE DEFAULT NULL,
        i_pat_gender       IN patient.gender%TYPE DEFAULT NULL,
        i_age              IN NUMBER DEFAULT NULL,
        i_age_str          IN VARCHAR2 DEFAULT NULL
    ) RETURN t_table_triage_discrim IS
        l_func_name VARCHAR2(200) := 'TF_TRIAGE_DISCRIM';
        --
        l_code_msg_trg_disc_cons CONSTANT sys_message.code_message%TYPE := 'TRIAGE_DISC_CONSENT_M001';
        l_desc_msg_trg_disc_cons sys_message.desc_message%TYPE;
        --
        l_triage_check_age triage_configuration.flg_check_age_limits%TYPE;
        --
        l_pat_gender patient.gender%TYPE;
        l_age        NUMBER(6);
        l_age_str    VARCHAR2(10 CHAR);
        --
        l_tbl_triage_discrim t_table_triage_discrim;
    BEGIN
        g_error := 'GET CONSENT FIELD LABEL';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_desc_msg_trg_disc_cons := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_msg_trg_disc_cons);
    
        IF i_pat_gender IS NULL
           AND i_age IS NULL
           AND i_age_str IS NULL
        THEN
            g_error := 'GET PATIENT GENDER';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            SELECT p.gender,
                   nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age,
                   pk_patient.get_pat_age(i_lang, p.dt_birth, p.age, i_prof.institution, i_prof.software)
              INTO l_pat_gender, l_age, l_age_str
              FROM patient p
             WHERE p.id_patient = i_patient;
        ELSE
            l_pat_gender := i_pat_gender;
            l_age        := i_age;
            l_age_str    := i_age_str;
        END IF;
    
        IF i_triage_check_age IS NULL
        THEN
            g_error := 'GET CONFIGURATION - CHECK AGE LIMITS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_triage_check_age := get_triage_config_by_name(i_lang, i_prof, i_episode, NULL, 'FLG_CHECK_AGE_LIMITS');
        ELSE
            l_triage_check_age := i_triage_check_age;
        END IF;
    
        SELECT t_rec_triage_discrim(id_triage                  => a.id_triage,
                                     id_triage_other            => a.id_triage_other,
                                     id_triage_color            => a.id_triage_color, -- Color assigned to the patient when the ACCEPTANCE OPTION is selected
                                     id_triage_color_other      => a.id_triage_color_other, -- Color assigned when the OPPOSITE of the acceptance option is selected
                                     color_text                 => a.color_text,
                                     color_text_other           => a.color_text_other,
                                     acuity                     => a.acuity,
                                     acuity_other               => a.acuity_other,
                                     id_triage_discriminator    => a.id_triage_discriminator,
                                     id_triage_discrim_other    => a.id_triage_discrim_other,
                                     id_triage_board            => a.id_triage_board,
                                     desc_triage_board          => decode(a.flg_critical_look,
                                                                          NULL,
                                                                          NULL,
                                                                          (SELECT pk_translation.get_translation(i_lang,
                                                                                                                 tb.code_triage_board)
                                                                             FROM triage_board tb
                                                                            WHERE tb.id_triage_board = a.id_triage_board)),
                                     desc_discriminator         => pk_translation.get_translation(i_lang,
                                                                                                  a.code_triage_discriminator),
                                     desc_discrim_other         => pk_translation.get_translation(i_lang,
                                                                                                  a.code_triage_disc_other),
                                     desc_discrim_question      => pk_translation.get_translation(i_lang,
                                                                                                  a.code_discrim_question),
                                     id_triage_disc_help        => a.id_triage_disc_help,
                                     age_min                    => a.age_min,
                                     age_max                    => a.age_max,
                                     patient_age                => l_age_str, -- Option that allows acceptance of the discriminator. Default option is 'YES'.
                                     flg_accepted_option        => nvl(a.flg_accepted_option, pk_alert_constant.g_yes), -- Type of assessment for the discriminator: vital signs or set of child discriminators
                                     flg_assessment_type        => a.flg_assessment_type, -- Lists with vital sign data, for each discriminator
                                     vsign_ids                  => get_vs_list_by_field(i_lang,
                                                                                        i_prof,
                                                                                        a.id_triage_discriminator,
                                                                                        'ID_VITAL_SIGN'),
                                     vsign_flg_mandatory        => get_vs_list_by_field(i_lang,
                                                                                        i_prof,
                                                                                        a.id_triage_discriminator,
                                                                                        'FLG_MANDATORY'),
                                     vsign_flg_type             => get_vs_list_by_field(i_lang,
                                                                                        i_prof,
                                                                                        a.id_triage_discriminator,
                                                                                        'FLG_VS_TYPE'), -- ESI Protocol data
                                     title_decision_point       => decode(a.id_triage_decision_point,
                                                                          NULL,
                                                                          NULL,
                                                                          (SELECT get_esi_decision_point_title(i_lang,
                                                                                                               i_prof,
                                                                                                               a.id_triage_decision_point,
                                                                                                               'L')
                                                                             FROM dual)),
                                     title_decision_point_short => decode(a.id_triage_decision_point,
                                                                          NULL,
                                                                          NULL,
                                                                          (SELECT get_esi_decision_point_title(i_lang,
                                                                                                               i_prof,
                                                                                                               a.id_triage_decision_point,
                                                                                                               'S')
                                                                             FROM dual)),
                                     esi_decision_point         => decode(a.id_triage_decision_point,
                                                                          NULL,
                                                                          NULL,
                                                                          (SELECT tdp.shortname
                                                                             FROM triage_decision_point tdp
                                                                            WHERE tdp.id_triage_decision_point =
                                                                                  a.id_triage_decision_point)),
                                     esi_level_header           => decode(a.id_triage_decision_point,
                                                                          NULL,
                                                                          NULL,
                                                                          (SELECT pk_translation.get_translation(i_lang,
                                                                                                                 a.code_triage_color)
                                                                             FROM dual)),
                                     -- José Brito 19/03/2010 ALERT-81593 READ-ONLY mode not implemented for now
                                     -- is_read_only(i_lang, i_prof, l_age, tal.age_min, tal.age_max, l_triage_check_age) flg_read_only
                                     -- ALERT-240677 (AS) - Indicats if it's need to request consent to read discriminator VS
                                    flg_need_consent    => decode((SELECT COUNT(*)
                                                                    FROM triage_disc_consent tdc
                                                                   WHERE tdc.id_triage_discriminator =
                                                                         a.id_triage_discriminator),
                                                                  0,
                                                                  pk_alert_constant.g_no,
                                                                  pk_alert_constant.g_yes),
                                    consent_field_group => (SELECT t.consent_group
                                                              FROM triage_disc_consent t
                                                             WHERE t.id_triage_discriminator = a.id_triage_discriminator
                                                               AND rownum = 1),
                                    box                 => a.box,
                                    urgency_level       => get_epis_esi_level(i_lang,
                                                                              i_prof,
                                                                              i_episode,
                                                                              a.id_triage_color),
                                    urgency_level_other => get_epis_esi_level(i_lang,
                                                                              i_prof,
                                                                              i_episode,
                                                                              a.id_triage_color_other),
                                    flg_context_help    => nvl2(pk_translation.get_translation(i_lang,
                                                                                               a.code_triage_disc_help),
                                                                'Y',
                                                                'N'),
                                    rank                => a.rank,
                                    flg_critical_look   => NULL)
          BULK COLLECT
          INTO l_tbl_triage_discrim
          FROM (SELECT t.id_triage,
                       hidden_discrim.id_triage                 id_triage_other,
                       t.id_triage_color,
                       t.id_triage_color_other,
                       tc.color_text,
                       hidden_discrim.color_text                color_text_other,
                       tc.color                                 acuity,
                       hidden_discrim.acuity                    acuity_other,
                       t.id_triage_discriminator,
                       hidden_discrim.id_triage_discriminator   id_triage_discrim_other,
                       t.id_triage_board,
                       td.code_triage_discriminator,
                       hidden_discrim.code_triage_discriminator code_triage_disc_other,
                       td.code_discrim_question,
                       tdh.id_triage_disc_help,
                       td.age_min,
                       td.age_max,
                       t.flg_accepted_option,
                       td.flg_assessment_type,
                       td.id_triage_decision_point,
                       tc.code_triage_color,
                       tdh.code_triage_disc_help,
                       t.box,
                       t.rank,
                       t.flg_critical_look
                  FROM triage t
                  JOIN triage_type tt
                    ON tt.id_triage_type = t.id_triage_type
                  JOIN triage_color tc
                    ON tc.id_triage_color = t.id_triage_color
                  JOIN triage_discriminator td
                    ON td.id_triage_discriminator = t.id_triage_discriminator
                  LEFT JOIN triage_discriminator_help tdih
                    ON tdih.id_triage_discriminator = t.id_triage_discriminator
                   AND tdih.flg_available = pk_alert_constant.g_yes
                  LEFT JOIN triage_disc_help tdh
                    ON tdh.id_triage_disc_help = tdih.id_triage_disc_help
                   AND tdh.flg_available = pk_alert_constant.g_yes
                  LEFT JOIN triage_age_limit tal
                    ON tal.id_triage_discriminator = td.id_triage_discriminator
                   AND tal.flg_available = pk_alert_constant.g_yes
                   AND (tal.id_institution = i_prof.institution OR tal.id_institution = 0 AND NOT EXISTS
                        (SELECT 0
                           FROM triage_age_limit tal1
                          WHERE tal1.id_triage_discriminator = td.id_triage_discriminator
                            AND tal1.id_institution = i_prof.institution
                            AND tal1.flg_available = pk_alert_constant.g_yes))
                  LEFT JOIN (SELECT t1.id_triage,
                                   t1.id_triage_color,
                                   t1.id_triage_type,
                                   t1.id_triage_board,
                                   tc1.color_text,
                                   tc1.code_accuity acuity,
                                   t1.id_triage_discriminator,
                                   td1.code_triage_discriminator
                              FROM triage t1
                              JOIN triage_discriminator td1
                                ON td1.id_triage_discriminator = t1.id_triage_discriminator
                              JOIN triage_color tc1
                                ON tc1.id_triage_color = t1.id_triage_color
                             WHERE t1.flg_available = pk_alert_constant.g_yes
                               AND t1.box = -1 -- Hidden box
                            ) hidden_discrim -- hidden discriminator info (used when all answers are No)
                    ON hidden_discrim.id_triage_color = t.id_triage_color_other
                   AND hidden_discrim.id_triage_board = t.id_triage_board
                   AND hidden_discrim.id_triage_type = t.id_triage_type
                 WHERE ((i_triage_board IS NULL AND i_triage_color IS NULL AND
                       t.id_triage IN (SELECT column_value
                                           FROM TABLE(i_tbl_triage))) OR
                       (i_triage_board IS NOT NULL AND i_triage_color IS NOT NULL AND
                       t.id_triage_board = i_triage_board AND t.id_triage_color = i_triage_color))
                   AND td.id_parent IS NULL -- DO NOT return the child discriminators. These will be obtained in GET_TRIAGE_DISCRIM_CHILD.
                   AND td.flg_available = pk_alert_constant.g_yes
                   AND tc.flg_available = pk_alert_constant.g_yes
                   AND (l_pat_gender = td.gender OR td.gender IS NULL OR l_pat_gender IS NULL OR
                       upper(l_pat_gender) = 'I' OR upper(td.gender) = 'I')
                   AND rownum > 0) a
        -- José Brito 19/03/2010 ALERT-81593 Configurable age limits
         WHERE pk_edis_triage.check_age_limits(i_lang, i_prof, l_age, a.age_min, g_age_min, l_triage_check_age) =
               pk_alert_constant.g_yes
           AND pk_edis_triage.check_age_limits(i_lang, i_prof, l_age, a.age_max, g_age_max, l_triage_check_age) =
               pk_alert_constant.g_yes;
    
        RETURN l_tbl_triage_discrim;
    
    END tf_triage_discrim;
    --
    /**************************************************************************
    * Returns the set of discriminators for the current box, in a given board (flowchart).
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode ID
    * @param i_patient                Patient ID
    * @param i_triage_board           Board (flowchart) ID
    * @param i_box                    Current box identifier
    * @param i_triage_type            Triage type ID
    * @param o_id_box                 Next box identifier
    * @param o_flg_last               Last box of the flowchart? (Y) Yes (N) No
    * @param o_vital_sign             Vital sign data
    * @param o_triage_discrim         Discriminator data
    * @param o_triage_disc_consent    When applicable has the multichoice consent values of each discriminator
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          23/11/2009
    **************************************************************************/
    FUNCTION get_triage_discrim
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_patient        IN patient.id_patient%TYPE,
        i_triage_board   IN triage_board.id_triage_board%TYPE,
        i_box            IN triage.box%TYPE,
        i_triage_type    IN triage_type.id_triage_type%TYPE,
        o_id_box         OUT triage.box%TYPE,
        o_flg_last       OUT VARCHAR2,
        o_vital_sign     OUT pk_types.cursor_type,
        o_triage_discrim OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200) := 'GET_TRIAGE_DISCRIM';
    
        l_triage_type        triage_type.id_triage_type%TYPE;
        l_triage_board       triage_board.id_triage_board%TYPE;
        l_box                triage.box%TYPE;
        l_max_box            triage.box%TYPE;
        l_triage_check_age   triage_configuration.flg_check_age_limits%TYPE;
        l_triage_color_other triage.id_triage_color_other%TYPE;
        l_triage_buttons     triage_configuration.flg_buttons%TYPE;
    
        l_pat_gender patient.gender%TYPE;
        l_age        NUMBER(6);
        l_age_str    VARCHAR2(10 CHAR);
    
        l_tab_discrim    table_number;
        l_tab_triage     table_number;
        l_tab_vital_sign table_number;
    
        l_param_error    EXCEPTION;
        l_internal_error EXCEPTION;
        l_consent_error  EXCEPTION;
        l_critital_look VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        CURSOR c_has_color_other IS
            SELECT t.id_triage_color_other
              FROM triage t
             WHERE t.box = l_box
               AND t.id_triage_type = l_triage_type
               AND t.id_triage_board = l_triage_board
               AND t.flg_available = pk_alert_constant.g_yes
             ORDER BY t.rank DESC;
    BEGIN
        IF i_triage_type IS NULL
        THEN
            g_error       := 'GET TRIAGE_TYPE';
            l_triage_type := pk_edis_triage.get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
        ELSE
            l_triage_type := i_triage_type;
        END IF;
    
        g_error            := 'GET CONFIGURATION - CHECK AGE LIMITS';
        l_triage_check_age := get_triage_config_by_name(i_lang,
                                                        i_prof,
                                                        i_episode,
                                                        l_triage_type,
                                                        'FLG_CHECK_AGE_LIMITS');
    
        IF i_triage_board IS NULL
           AND l_triage_type IN (pk_edis_triage.g_triage_id_esi,
                                 pk_edis_triage.g_triage_id_latour,
                                 pk_edis_triage.g_triage_id_ppau,
                                 pk_edis_triage.g_triage_id_sa,
                                 pk_edis_triage.g_triage_id_atas)
        
        THEN
            -- ESI/Latour protocols only have one flowchart.
            g_error := 'GET ESI BOARD';
            pk_alertlog.log_debug(g_error);
            SELECT tb.id_triage_board
              INTO l_triage_board
              FROM triage_board tb
             WHERE tb.id_triage_board IN (SELECT t.id_triage_board
                                            FROM triage t
                                           WHERE t.id_triage_type = l_triage_type)
               AND tb.flg_available = pk_alert_constant.g_yes
               AND rownum = 1;
        
        ELSIF i_triage_board IS NULL
              AND i_box <> 0
              AND l_triage_type <> pk_edis_triage.g_triage_id_sa
        THEN
            g_error := 'INVALID BOARD ID';
            RAISE l_param_error;
        
        ELSE
        
            l_triage_board := i_triage_board;
        END IF;
    
        g_error := 'GET PATIENT GENDER';
        SELECT p.gender,
               nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age,
               pk_patient.get_pat_age(i_lang, p.dt_birth, p.age, i_prof.institution, i_prof.software)
          INTO l_pat_gender, l_age, l_age_str
          FROM episode e
          JOIN patient p
            ON p.id_patient = e.id_patient
         WHERE e.id_episode = i_episode;
    
        l_box := nvl(i_box, 0) + 1; -- Initialize variable
    
        -- Get the maximum BOX value, for the current flowchart (board)
        g_error := 'OPEN C_MAX_BOX';
        SELECT MAX(box)
          INTO l_max_box
          FROM triage t
         WHERE t.id_triage_type = l_triage_type
           AND t.id_triage_board = l_triage_board
           AND t.flg_available = pk_alert_constant.g_yes;
    
        -- Check if this is the maximum BOX value
        IF l_box = l_max_box
        THEN
            o_flg_last := g_last_box_yes;
            o_id_box   := l_box;
        
            g_error := 'CHECK COLOR OTHER';
            OPEN c_has_color_other;
            FETCH c_has_color_other
                INTO l_triage_color_other;
            CLOSE c_has_color_other;
        
            g_error          := 'GET CONFIGURATION - CHECK AGE LIMITS';
            l_triage_buttons := get_triage_config_by_name(i_lang, i_prof, i_episode, l_triage_type, 'FLG_BUTTONS');
        
            IF l_triage_color_other IS NOT NULL
               AND l_triage_buttons = pk_alert_constant.g_yes
            THEN
                o_flg_last := g_last_box_other;
            END IF;
        ELSE
            o_flg_last := g_last_box_no;
            o_id_box   := l_box;
        END IF;
    
        -- if this is an EST triage, resets l_box so that all discriminators of all levels are returned on the cursor
        IF i_triage_type IN (g_triage_id_est, g_triage_id_sa, g_triage_id_ctas_a, g_triage_id_ctas_p)
        THEN
            -- CRITICAL LOOK
            l_box    := NULL;
            o_id_box := l_box;
            IF i_triage_board IS NULL
            THEN
                l_critital_look := pk_alert_constant.g_yes;
            END IF;
        END IF;
    
        -- Get the ID's of the triages and discriminators
        g_error := 'GET TRIAGE DISCRIMINATORS';
        pk_alertlog.log_debug(g_error);
        SELECT t.id_triage, td.id_triage_discriminator
          BULK COLLECT
          INTO l_tab_triage, l_tab_discrim
          FROM triage_discriminator td
          JOIN triage t
            ON t.id_triage_discriminator = td.id_triage_discriminator
          LEFT JOIN triage_age_limit tal
            ON tal.id_triage_discriminator = td.id_triage_discriminator
           AND tal.flg_available = pk_alert_constant.g_yes
           AND (tal.id_institution = i_prof.institution OR tal.id_institution = 0 AND NOT EXISTS
                (SELECT 0
                   FROM triage_age_limit tal1
                  WHERE tal1.id_triage_discriminator = td.id_triage_discriminator
                    AND tal1.id_institution = i_prof.institution
                    AND tal1.flg_available = pk_alert_constant.g_yes))
         WHERE td.flg_available = pk_alert_constant.g_yes
           AND (t.id_triage_board = l_triage_board OR l_triage_board IS NULL)
           AND t.box = nvl(l_box, t.box)
           AND nvl(t.flg_critical_look, pk_alert_constant.g_no) = l_critital_look
           AND t.id_triage_type = l_triage_type
           AND t.flg_available = pk_alert_constant.g_yes
           AND (l_pat_gender = td.gender OR td.gender IS NULL OR l_pat_gender IS NULL OR upper(l_pat_gender) = 'I' OR
               upper(td.gender) = 'I')
              -- José Brito 19/03/2010 ALERT-81593 Configurable age limits
           AND pk_edis_triage.check_age_limits(i_lang, i_prof, l_age, tal.age_min, g_age_min, l_triage_check_age) =
               pk_alert_constant.g_yes
           AND pk_edis_triage.check_age_limits(i_lang, i_prof, l_age, tal.age_max, g_age_max, l_triage_check_age) =
               pk_alert_constant.g_yes
         ORDER BY t.rank;
    
        g_error := 'CALL PK_EDIS_TRIAGE.TF_TRIAGE_VITAL_SIGNS';
        pk_alertlog.log_debug(g_error);
        l_tab_vital_sign := pk_edis_triage.tf_triage_vital_signs(i_lang           => i_lang,
                                                                 i_prof           => i_prof,
                                                                 i_id_episode     => i_episode,
                                                                 i_tbl_id_context => l_tab_discrim,
                                                                 i_flg_context    => pk_edis_triage.g_flg_context_id_triage_disc,
                                                                 i_id_triage_type => i_triage_type);
    
        IF l_tab_vital_sign IS NOT NULL
           AND l_tab_vital_sign.count > 0
        THEN
            -- Return the data of the required vital signs, for all discriminators
            g_error := 'GET VITAL SIGN DATA';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_vital_sign.get_vs_triage_header(i_lang            => i_lang,
                                                      i_prof            => i_prof,
                                                      i_tbl_vital_sign  => l_tab_vital_sign,
                                                      i_flg_view        => 'T',
                                                      i_relation_domain => get_vs_relation_domain(i_tab_vital_sign => l_tab_vital_sign),
                                                      i_patient         => i_patient,
                                                      o_sign_v          => o_vital_sign,
                                                      o_error           => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_vital_sign);
        END IF;
    
        g_error := 'GET CURSOR O_TRIAGE_DISCRIM';
        pk_alertlog.log_debug(g_error);
        OPEN o_triage_discrim FOR
            SELECT t.id_triage,
                   t.id_triage_other,
                   t.id_triage_color,
                   t.id_triage_color_other,
                   t.color_text,
                   t.color_text_other,
                   t.acuity,
                   t.acuity_other,
                   t.id_triage_discriminator,
                   t.id_triage_discrim_other,
                   t.id_triage_board,
                   t.desc_triage_board,
                   t.desc_discriminator,
                   t.desc_discrim_other,
                   t.desc_discrim_question,
                   t.id_triage_disc_help,
                   t.age_min,
                   t.age_max,
                   t.patient_age,
                   t.flg_accepted_option,
                   t.flg_assessment_type,
                   t.vsign_ids,
                   t.vsign_flg_mandatory,
                   t.vsign_flg_type,
                   t.title_decision_point,
                   t.title_decision_point_short,
                   t.esi_decision_point,
                   t.esi_level_header,
                   t.flg_need_consent,
                   t.consent_field_group,
                   t.box,
                   t.urgency_level,
                   t.urgency_level_other,
                   t.flg_context_help,
                   t.flg_critical_look
              FROM TABLE(pk_edis_triage.tf_triage_discrim(i_lang             => i_lang,
                                                          i_prof             => i_prof,
                                                          i_patient          => i_patient,
                                                          i_episode          => i_episode,
                                                          i_tbl_triage       => l_tab_triage,
                                                          i_triage_check_age => l_triage_check_age,
                                                          i_pat_gender       => l_pat_gender,
                                                          i_age              => l_age,
                                                          i_age_str          => l_age_str)) t
             ORDER BY t.box, t.rank;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_param_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'PARAM ERROR',
                                              'INVALID PARAMETER FOUND (' || g_error || ')',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_vital_sign);
            pk_types.open_my_cursor(o_triage_discrim);
            RETURN FALSE;
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.err_desc,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_vital_sign);
            pk_types.open_my_cursor(o_triage_discrim);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_vital_sign);
            pk_types.open_my_cursor(o_triage_discrim);
            RETURN FALSE;
    END get_triage_discrim;
    --
    /**
    * Return the correct labels for "Flowchart" and "Discriminator",
    * according to the triage protocol used in the institution.
    * IMPORTANT: DATABASE INTERNAL FUNCTION
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_episode             Episode Id    
    * @param i_triage_acronym      Acronym for triage type (M) Manchester, (T5) 5-Level Triage, etc...
    * @param o_flowchart           Label for "Flowchart"    
    * @param o_discriminator       Label for "Discriminator"        
    * @param o_reason_for_visit    Label for "Reason for visit"
    * @param o_fchart_selection    Label for "Flowchart selection"
    * @param o_protocol            Label for the protocol title, when applicable
    * @param o_confirmation        Label for the confirmation of triage (e.g. "Confirming Emergency Severity Index triage")
    * @param o_other_discrim       Label for "Other answers" (usually "No" answers)
    * @param o_error               Error message
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      José Brito
    * @since                       2009/03/26
    * @version                     1.0
    *
    */
    FUNCTION get_triage_labels
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_episode          IN episode.id_episode%TYPE,
        i_triage_acronym   IN triage_type.acronym%TYPE,
        o_flowchart        OUT VARCHAR2,
        o_discriminator    OUT VARCHAR2,
        o_reason_for_visit OUT VARCHAR2,
        o_fchart_selection OUT VARCHAR2,
        o_protocol         OUT VARCHAR2,
        o_confirmation     OUT VARCHAR2,
        o_current_prof     OUT VARCHAR2,
        o_other_discrim    OUT VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- Other variables
        l_triage_acronym sys_config.value%TYPE;
    
    BEGIN
        g_error := 'GET TRIAGE TYPE';
        pk_alertlog.log_debug(g_error);
        IF i_triage_acronym IS NULL
        THEN
            l_triage_acronym := pk_edis_triage.get_triage_acronym(i_lang    => i_lang,
                                                                  i_prof    => i_prof,
                                                                  i_episode => i_episode);
        ELSE
            l_triage_acronym := i_triage_acronym;
        END IF;
    
        g_error := 'GET LABELS FROM DOMAIN';
        pk_alertlog.log_debug(g_error);
    
        -- Label for "Flowchart"
        CASE l_triage_acronym
            WHEN g_t5 THEN
                o_flowchart := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART',
                                                       i_val      => l_triage_acronym,
                                                       i_lang     => i_lang);
            WHEN g_latour THEN
                o_flowchart := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART',
                                                       i_val      => l_triage_acronym,
                                                       i_lang     => i_lang);
            WHEN g_esi THEN
                -- In ESI protocol, show "Decision Point", instead of the flowchart.
                o_flowchart := pk_message.get_message(i_lang => i_lang, i_code_mess => 'TRIAGE_ESI_T001');
            WHEN g_est THEN
                o_flowchart := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART',
                                                       i_val      => l_triage_acronym,
                                                       i_lang     => i_lang);
            WHEN g_atas_mental THEN
                o_flowchart := '';
            ELSE
                -- For other types of triage, use the Manchester labels.
                o_flowchart := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART',
                                                       i_val      => g_manchester,
                                                       i_lang     => i_lang);
        END CASE;
    
        -- Label for "Flowchart selection"
        CASE l_triage_acronym
            WHEN g_t5 THEN
                o_fchart_selection := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART_SELECTION',
                                                              i_val      => g_t5,
                                                              i_lang     => i_lang);
            WHEN g_esi THEN
                -- ESI uses the same label as T5 protocol
                o_fchart_selection := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART_SELECTION',
                                                              i_val      => g_t5,
                                                              i_lang     => i_lang);
            WHEN g_est THEN
                -- ESI uses the same label as T5 protocol
                o_fchart_selection := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART_SELECTION',
                                                              i_val      => g_est,
                                                              i_lang     => i_lang);
            ELSE
                -- For other types of triage, use the Manchester labels.
                o_fchart_selection := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_FLOWCHART_SELECTION',
                                                              i_val      => g_manchester,
                                                              i_lang     => i_lang);
        END CASE;
    
        -- Label for "Discriminator"
        CASE l_triage_acronym
            WHEN g_t5 THEN
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_t5,
                                                           i_lang     => i_lang);
            WHEN g_esi THEN
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_esi,
                                                           i_lang     => i_lang);
            WHEN g_latour THEN
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_latour,
                                                           i_lang     => i_lang);
            WHEN g_est THEN
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_est,
                                                           i_lang     => i_lang);
            WHEN g_atas_mental THEN
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_atas_mental,
                                                           i_lang     => i_lang);
            ELSE
                -- For other types of triage, use the Manchester labels.
                o_discriminator := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_DISCRIMINATOR',
                                                           i_val      => g_manchester,
                                                           i_lang     => i_lang);
        END CASE;
    
        -- Label for "Discriminator"
        CASE l_triage_acronym
            WHEN g_t5 THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => g_t5,
                                                           i_lang     => i_lang);
            WHEN g_esi THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => g_esi,
                                                           i_lang     => i_lang);
            WHEN g_latour THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => g_latour,
                                                           i_lang     => i_lang);
            WHEN g_est THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => g_est,
                                                           i_lang     => i_lang);
            WHEN g_ctas_ped THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => 'CTAS',
                                                           i_lang     => i_lang);
            WHEN g_ctas_adult THEN
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => 'CTAS',
                                                           i_lang     => i_lang);
            ELSE
                -- For other types of triage, use the Manchester labels.
                o_other_discrim := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_OTHER_DISCRIMS',
                                                           i_val      => g_manchester,
                                                           i_lang     => i_lang);
        END CASE;
    
        -- Label for the protocol title, when applicable
        IF l_triage_acronym = g_esi
        THEN
            o_protocol := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_PROTOCOL',
                                                  i_val      => g_esi,
                                                  i_lang     => i_lang);
        ELSE
            -- For all other protocols, use the label "Triage"
            o_protocol := pk_message.get_message(i_lang => i_lang, i_code_mess => 'TRIAGE_T013');
        END IF;
    
        -- Label for the confirmation of triage (e.g. "Confirming Emergency Severity Index triage")
        IF l_triage_acronym IN (g_esi, g_latour, g_est)
        THEN
            o_confirmation := pk_sysdomain.get_domain(i_code_dom => 'TRIAGE_LABEL_CONFIRMATION',
                                                      i_val      => l_triage_acronym,
                                                      i_lang     => i_lang);
        ELSE
            -- For all other protocols, use the label "Confirm triage acuity"
            o_confirmation := pk_message.get_message(i_lang => i_lang, i_code_mess => 'TRIAGE_T005');
        END IF;
    
        -- Label for "Reason for visit"
        -- The same for all types of triage.
        o_reason_for_visit := lower(' / ' || pk_message.get_message(i_lang => i_lang, i_code_mess => 'TRIAGE_T017')); -- Reason for visit
    
        o_current_prof := pk_prof_utils.get_name_signature(i_lang, i_prof, i_prof.id);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     'GET_TRIAGE_LABELS',
                                                     o_error);
    END get_triage_labels;

    --
    /**********************************************************************************************
    * Listar todos os episódios de triagem 
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_id_epis                episode id
    * @param o_epis_triage            array com os todos os episódios de triagem deste episodio   
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/09/15
    **********************************************************************************************/
    FUNCTION get_epis_triage
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_id_epis     IN episode.id_episode%TYPE,
        o_epis_triage OUT pk_types.cursor_type,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_has_transfer              NUMBER(6);
        l_prof_cat                  category.flg_type%TYPE;
        l_ft_manual_activations_cfg sys_config.value%TYPE;
    BEGIN
        g_error        := 'CHECK TRANSFER';
        l_has_transfer := pk_transfer_institution.check_epis_transfer(i_id_epis);
    
        g_error    := 'CALL PK_PROF_UTILS.GET_CATEGORY';
        l_prof_cat := pk_prof_utils.get_category(i_lang => i_lang, i_prof => i_prof);
    
        g_error                     := 'GET SYS_CONFIG ''FAST_TRACKS_MANUAL_ACTIVATION''';
        l_ft_manual_activations_cfg := nvl(pk_sysconfig.get_config(i_code_cf => 'FAST_TRACKS_MANUAL_ACTIVATION',
                                                                   i_prof    => i_prof),
                                           g_no);
    
        g_error := 'GET CURSOR O_EPIS_TRIAGE';
        OPEN o_epis_triage FOR
            SELECT et.id_epis_triage,
                   tc.id_triage_type,
                   et.id_professional,
                   pk_prof_utils.get_name_signature(i_lang, i_prof, et.id_professional) name_prof,
                   pk_date_utils.dt_chr_tsz(i_lang, et.dt_end_tstz, i_prof) date_target,
                   pk_date_utils.date_char_hour_tsz(i_lang, et.dt_end_tstz, i_prof.institution, i_prof.software) hour_target,
                   tc.color acuity,
                   decode(et.flg_critical_look,
                          pk_alert_constant.g_yes,
                          pk_message.get_message(i_lang, 'TRIAGE_CTAS_T003'),
                          get_board_label(i_lang,
                                          i_prof,
                                          et.id_triage_board,
                                          td.id_triage_decision_point,
                                          t.id_triage_type)) desc_triage_board,
                   decode(et.flg_critical_look,
                          pk_alert_constant.g_yes,
                          get_critical_look_str(i_lang, et.id_epis_triage, et.flg_critical_look),
                          get_defining_criteria_str(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_epis_triage => et.id_epis_triage)) desc_triage_disc,
                   pk_translation.get_translation(i_lang, twr.code_triage_white_reason) desc_triage_w_reason,
                   et.notes,
                   t.id_triage_board,
                   t.id_triage_discriminator,
                   t.id_triage_color,
                   ef.id_fast_track id_fast_track,
                   -- José Brito 12/01/2010 ALERT-16615 Send ID_TRIAGE_COLOR to check for ESI protocol
                   
                   (SELECT pk_fast_track.get_fast_track_icon(i_lang,
                                                             i_prof,
                                                             et.id_episode,
                                                             nvl(ef.id_fast_track, -1),
                                                             et.id_triage_color,
                                                             decode(l_has_transfer,
                                                                    0,
                                                                    pk_edis_grid.g_icon_ft,
                                                                    pk_edis_grid.g_icon_ft_transfer),
                                                             l_has_transfer)
                      FROM dual) fast_track_icon,
                   pk_fast_track.get_fast_track_desc(i_lang, i_prof, ef.id_fast_track, pk_fast_track.g_desc_grid) fast_track_desc,
                   pk_fast_track.get_fast_track_permission(i_lang, i_prof, ef.id_fast_track) flg_ft_permission,
                   decode(tc.color, pk_edis_grid.g_ft_color, pk_edis_grid.g_ft_triage_white, pk_edis_grid.g_ft_color) fast_track_color,
                   -- José Brito 12/01/2010 ALERT-16615 Returns the ESI level, if patient was triaged with ESI protocol.
                   (SELECT get_epis_esi_level(i_lang, i_prof, et.id_episode, et.id_triage_color)
                      FROM dual) esi_level,
                   tc.color acuity,
                   tc.color_text color_text,
                   tc.rank rank_acuity,
                   pk_prof_utils.get_prof_speciality(i_lang => i_lang,
                                                     i_prof => profissional(et.id_professional,
                                                                            i_prof.institution,
                                                                            i_prof.software)) prof_speciality,
                   pk_date_utils.date_char_tsz(i_lang => i_lang,
                                               i_date => et.dt_end_tstz,
                                               i_inst => i_prof.institution,
                                               i_soft => i_prof.software) datetime
              FROM epis_triage et
              LEFT JOIN triage_board tb
                ON et.id_triage_board = tb.id_triage_board
              LEFT JOIN triage t
                ON et.id_triage = t.id_triage
              LEFT JOIN triage_discriminator td
                ON t.id_triage_discriminator = td.id_triage_discriminator
              LEFT JOIN triage_color tc
                ON et.id_triage_color = tc.id_triage_color
              LEFT JOIN professional p
                ON et.id_professional = p.id_professional
              LEFT JOIN triage_white_reason twr
                ON et.id_triage_white_reason = twr.id_triage_white_reason
              LEFT JOIN epis_fast_track ef
                ON et.id_epis_triage = ef.id_epis_triage
               AND ef.flg_status IN (pk_fast_track.g_fast_track_active, pk_fast_track.g_fast_track_confirm) --EMR-4797
             WHERE et.id_episode = i_id_epis
             ORDER BY dt_end_tstz DESC;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_types.open_my_cursor(o_epis_triage);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_EPIS_TRIAGE',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END;
    --
    /**********************************************************************************************
    * Returns the available reasons for non-triaged patients ("white" triage),
    * configured in the institution.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode ID
    * @param o_white_reason           Configured reasons for "white" triages 
    * @param o_error                  Error message
    *
    * @return                         TRUE/FALSE
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/09/15
    *
    * @alter                          José Brito
    * @version                        2.6
    * @since                          2009/12/17
    **********************************************************************************************/
    FUNCTION get_triage_white_reason
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_episode      IN episode.id_episode%TYPE,
        o_white_reason OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_triage_type sys_config.value%TYPE;
    BEGIN
        g_error       := 'GET TRIAGE_TYPE';
        l_triage_type := get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        g_error := 'GET CURSOR O_WHITE_REASON';
        OPEN o_white_reason FOR
            SELECT a.id_triage_white_reason, a.desc_triage_white_reason, a.color_white
              FROM (SELECT tw.id_triage_white_reason,
                           pk_translation.get_translation(i_lang, tw.code_triage_white_reason) desc_triage_white_reason,
                           (SELECT tco.id_triage_color
                              FROM triage_color tco
                              JOIN triage_color_group tcg
                                ON tcg.id_triage_color_group = tco.id_triage_color_group
                             WHERE tcg.flg_type = 'W'
                               AND tcg.flg_available = pk_alert_constant.g_yes
                               AND tco.flg_available = pk_alert_constant.g_yes
                               AND tco.id_triage_type = l_triage_type) color_white,
                           tw.rank
                      FROM triage_white_reas_inst twt
                      JOIN triage_white_reason tw
                        ON tw.id_triage_white_reason = twt.id_triage_white_reason
                     WHERE twt.flg_available = pk_alert_constant.g_yes
                       AND tw.flg_available = pk_alert_constant.g_yes
                       AND ((twt.id_institution = 0 AND NOT EXISTS
                            (SELECT 0
                                FROM triage_white_reas_inst twt1
                               WHERE twt1.id_institution = i_prof.institution
                                 AND twt1.flg_available = pk_alert_constant.g_yes)) OR
                           twt.id_institution = i_prof.institution)) a
             WHERE a.desc_triage_white_reason IS NOT NULL
             ORDER BY a.rank, a.desc_triage_white_reason;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_TRIAGE_WHITE_REASON',
                                              o_error);
            pk_types.open_my_cursor(o_white_reason);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_triage_white_reason;
    --
    /**********************************************************************************************
    * Listar todos os cuidados de enfermagem associadas ao Fluxograma/discriminador/cor   
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_triage_board           triage board id
    * @param i_discrim                discriminator id                   
    * @param i_triage_color           triage color id
    * @param o_n_consid               Listar todos os cuidados de enfermagem associadas ao Fluxograma/discriminador/cor 
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/10/06
    **********************************************************************************************/
    FUNCTION get_triage_n_consid
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_patient   IN patient.id_patient%TYPE,
        i_triage_board IN triage_board.id_triage_board%TYPE,
        i_discrim      IN triage_discriminator.id_triage_discriminator%TYPE,
        i_triage_color IN triage_color.id_triage_color%TYPE,
        i_flg_confirm  IN VARCHAR2 DEFAULT NULL,
        o_n_consid     OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name   VARCHAR2(30) := 'GET_TRIAGE_N_CONSID';
        l_patient_age patient.age%TYPE;
    BEGIN
    
        g_error := 'GET CURSOR O_N_CONSID';
        pk_alertlog.log_debug(g_error);
        l_patient_age := pk_patient.get_pat_age(i_lang        => i_lang,
                                                i_dt_birth    => NULL,
                                                i_dt_deceased => NULL,
                                                i_age         => NULL,
                                                i_age_format  => 'YEARS',
                                                i_patient     => i_id_patient);
    
        g_error := 'GET CURSOR O_N_CONSID';
        pk_alertlog.log_debug(g_error);
        IF i_flg_confirm = pk_alert_constant.g_no
        THEN
            OPEN o_n_consid FOR
                SELECT tnc.id_triage_n_consid,
                       tnc.id_triage_considerations,
                       pk_translation.get_translation(i_lang, tc.code_triage_considerations) desc_considerations
                  FROM triage_n_consid tnc, triage_considerations tc
                 WHERE tnc.id_triage_considerations = tc.id_triage_considerations
                   AND tnc.id_triage_board = i_triage_board
                   AND tnc.id_triage_color = i_triage_color
                   AND nvl(tnc.id_triage_discriminator, i_discrim) = i_discrim
                   AND tnc.flg_confirmation = i_flg_confirm
                   AND tnc.flg_available = g_yes
                   AND pk_edis_triage.check_age_limits(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_pat_age              => l_patient_age,
                                                       i_age_limit            => tc.age_min,
                                                       i_limit_type           => g_age_min,
                                                       i_flg_check_age_limits => pk_alert_constant.g_yes) =
                       pk_alert_constant.g_yes
                   AND pk_edis_triage.check_age_limits(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_pat_age              => l_patient_age,
                                                       i_age_limit            => tc.age_max,
                                                       i_limit_type           => g_age_max,
                                                       i_flg_check_age_limits => pk_alert_constant.g_yes) =
                       pk_alert_constant.g_yes
                   AND pk_patient.validate_pat_gender(i_pat_gender  => pk_patient.get_pat_gender(i_id_patient => i_id_patient),
                                                      i_item_gender => tc.gender) = 1
                 ORDER BY tnc.rank, desc_considerations;
        ELSE
            OPEN o_n_consid FOR
                SELECT tnc.id_triage_n_consid,
                       tnc.id_triage_considerations,
                       pk_translation.get_translation(i_lang, tc.code_triage_considerations) desc_considerations
                  FROM triage_n_consid tnc, triage_considerations tc
                 WHERE tnc.id_triage_considerations = tc.id_triage_considerations
                   AND tnc.id_triage_board = i_triage_board
                   AND tnc.id_triage_color = i_triage_color
                   AND tnc.id_triage_discriminator IS NULL
                   AND i_discrim IS NULL
                   AND tnc.flg_confirmation = i_flg_confirm
                   AND tnc.flg_available = g_yes
                   AND pk_edis_triage.check_age_limits(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_pat_age              => l_patient_age,
                                                       i_age_limit            => tc.age_min,
                                                       i_limit_type           => g_age_min,
                                                       i_flg_check_age_limits => pk_alert_constant.g_yes) =
                       pk_alert_constant.g_yes
                   AND pk_edis_triage.check_age_limits(i_lang                 => i_lang,
                                                       i_prof                 => i_prof,
                                                       i_pat_age              => l_patient_age,
                                                       i_age_limit            => tc.age_max,
                                                       i_limit_type           => g_age_max,
                                                       i_flg_check_age_limits => pk_alert_constant.g_yes) =
                       pk_alert_constant.g_yes
                   AND pk_patient.validate_pat_gender(i_pat_gender  => pk_patient.get_pat_gender(i_id_patient => i_id_patient),
                                                      i_item_gender => tc.gender) = 1
                 ORDER BY tnc.rank, desc_considerations;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_types.open_my_cursor(o_n_consid);
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_name,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END;
    --
    /**********************************************************************************************
    * Listar os fluxogramas associados à queixa activa, do episódio.   
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_epis                   episode id
    * @param o_comp_t                 Listar os fluxogramas associados à queixa, activa, do episódio 
    * @param o_anamnesis              Anamnesis list
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2006/10/06
    **********************************************************************************************/
    FUNCTION get_complaint_triage
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_epis      IN episode.id_episode%TYPE,
        o_comp_t    OUT pk_types.cursor_type,
        o_anamnesis OUT cursor_anamnesis,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_complaint      complaint.id_complaint%TYPE;
        l_epis_complaint epis_complaint.id_epis_complaint%TYPE;
        l_epis_triage    epis_triage.id_epis_triage%TYPE;
        l_triage_type    triage_type.id_triage_type%TYPE;
        --
        CURSOR c_complaint IS
            SELECT ec.id_epis_complaint, ec.id_complaint
              FROM epis_complaint ec
             WHERE ec.id_episode = i_epis
               AND ec.flg_status = g_complaint_act
             ORDER BY ec.adw_last_update_tstz DESC;
        --
        CURSOR c_epis_triage IS
            SELECT et.id_epis_triage
              FROM epis_triage et
             WHERE et.id_episode = i_epis
               AND et.dt_begin_tstz = (SELECT MAX(et1.dt_begin_tstz)
                                         FROM epis_triage et1
                                        WHERE et1.id_episode(+) = et.id_episode);
    BEGIN
        g_error       := 'GET TRIAGE_TYPE';
        l_triage_type := get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_epis);
        --
        g_error := 'GET EPIS_TRIAGE';
        OPEN c_epis_triage;
        FETCH c_epis_triage
            INTO l_epis_triage;
        CLOSE c_epis_triage;
    
        g_error := 'GET CURSOR C_COMPLAINT';
        OPEN c_complaint;
        FETCH c_complaint
            INTO l_epis_complaint, l_complaint;
        CLOSE c_complaint;
    
        IF l_epis_triage IS NOT NULL
        THEN
            -- Quando estamos perante uma re-triagem, estes dados serão devolvidos (ET 2007/03/27)
            g_error := 'GET CURSOR O_COMP_T (EPIS_TRIAGE)';
            OPEN o_comp_t FOR
                SELECT etr.id_epis_triage,
                       tbg.id_triage_board_group,
                       t.id_triage_board,
                       pk_translation.get_translation(i_lang, tbg.code_triage_board_group) desc_triage_board_group,
                       pk_translation.get_translation(i_lang, tb.code_triage_board) desc_triage_board
                  FROM epis_triage etr
                  JOIN triage t
                    ON t.id_triage = etr.id_triage
                  JOIN triage_board tb
                    ON tb.id_triage_board = t.id_triage_board
                  JOIN triage_board_grouping tbgr
                    ON tbgr.id_triage_board = tb.id_triage_board
                  JOIN triage_board_group tbg
                    ON tbg.id_triage_board_group = tbgr.id_triage_board_group
                 WHERE etr.id_epis_triage = l_epis_triage
                   AND tbg.id_triage_type = l_triage_type
                   AND t.flg_available = pk_alert_constant.g_yes
                   AND tb.flg_available = pk_alert_constant.g_yes
                   AND tbgr.flg_available = pk_alert_constant.g_yes
                   AND tbg.flg_available = pk_alert_constant.g_yes;
        ELSE
            IF l_complaint IS NOT NULL
            THEN
                g_error := 'GET CURSOR O_COMP_T (COMPLAINT_TRIAGE_BOARD)';
                OPEN o_comp_t FOR
                    SELECT ctb.id_complaint_triage_board,
                           tbg.id_triage_board_group,
                           ctb.id_triage_board,
                           pk_translation.get_translation(i_lang, tbg.code_triage_board_group) desc_triage_board_group,
                           pk_translation.get_translation(i_lang, tb.code_triage_board) desc_triage_board
                      FROM triage_board tb
                      JOIN complaint_triage_board ctb
                        ON ctb.id_triage_board = tb.id_triage_board
                      JOIN triage_board_grouping tbgr
                        ON tbgr.id_triage_board = tb.id_triage_board
                      JOIN triage_board_group tbg
                        ON tbg.id_triage_board_group = tbgr.id_triage_board_group
                     WHERE ctb.id_complaint = l_complaint
                       AND ctb.flg_available = g_yes
                       AND tbgr.flg_available = g_yes
                       AND tbg.flg_available = g_yes
                       AND tbg.id_triage_type = l_triage_type
                     ORDER BY 4;
            ELSE
                pk_types.open_my_cursor(o_comp_t);
            END IF;
        END IF;
    
        g_error := 'GET CURSOR O_ANAMNESIS';
        OPEN o_anamnesis FOR
            SELECT ea.id_epis_anamnesis,
                   pk_string_utils.clob_to_sqlvarchar2(ea.desc_epis_anamnesis) desc_epis_anamnesis
              FROM epis_anamnesis ea
              LEFT JOIN epis_complaint ec
                ON ec.id_episode = ea.id_episode
               AND ec.id_epis_complaint = l_epis_complaint
             WHERE ea.id_episode = i_epis
               AND ea.flg_type = pk_complaint.g_epis_anam_flg_type_c
               AND ea.dt_epis_anamnesis_tstz =
                   (SELECT MAX(ea1.dt_epis_anamnesis_tstz)
                      FROM epis_anamnesis ea1
                     WHERE ea1.id_episode = ea.id_episode
                       AND ea1.flg_type = pk_complaint.g_epis_anam_flg_type_c)
               AND (ea.dt_epis_anamnesis_tstz > ec.adw_last_update_tstz OR ec.adw_last_update_tstz IS NULL)
            UNION ALL
            SELECT NULL id_epis_anamnesis, ec.patient_complaint desc_epis_anamnesis
              FROM epis_complaint ec
              LEFT JOIN epis_anamnesis ea
                ON ea.id_episode = ec.id_episode
               AND ea.flg_type = pk_complaint.g_epis_anam_flg_type_c
             WHERE ec.id_epis_complaint = l_epis_complaint
               AND ec.patient_complaint IS NOT NULL
               AND (ea.dt_epis_anamnesis_tstz =
                   (SELECT MAX(ea1.dt_epis_anamnesis_tstz)
                       FROM epis_anamnesis ea1
                      WHERE ea1.id_episode = ec.id_episode
                        AND ea1.flg_type = pk_complaint.g_epis_anam_flg_type_c) OR ea.dt_epis_anamnesis_tstz IS NULL)
               AND (ec.adw_last_update_tstz > ea.dt_epis_anamnesis_tstz OR ea.dt_epis_anamnesis_tstz IS NULL);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_types.open_my_cursor(o_comp_t);
            open_my_cursor(o_anamnesis);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_COMPLAINT_TRIAGE',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END;
    --
    /**********************************************************************************************
    * Calcular o valor total do TRTS (Conjunto de sinais vitais)   
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_triage_discrim         discriminator id
    * @param i_vs_id                  Array de IDs de SVs lidos
    * @param i_vs_val                 Array de leituras dos SVs de I_VS_ID ( (valor do sinal vital) 
    * @param i_flg_view               Posição dos sinais vitais:S- Resumo; 
                                                                H- Saída de turno; 
                                                                V1- Grelha completa; 
                                                                V2- Grelha reduzida;
                                                                V3 - Biometria 
                                                                T- Triagem;
    * @param o_trts                   Resultado do conjunto dos sinais vitais   
    * @param o_vs                     ID do sinal vital a ser calculado
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Emilia Taborda
    * @version                        1.0 
    * @since                          2007/01/25
    **********************************************************************************************/
    FUNCTION get_triage_trts
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_triage_discrim IN triage.id_triage_discriminator%TYPE,
        i_vs_id          IN table_number,
        i_vs_val         IN table_number,
        i_flg_view       IN vs_soft_inst.flg_view%TYPE,
        o_trts           OUT NUMBER,
        o_vs             OUT NUMBER,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_vstrts_1 NUMBER := 0;
        l_vstrts_2 NUMBER := 0;
        l_vstrts_3 NUMBER := 0;
    
        l_vs_intern_name vital_sign.intern_name_vital_sign%TYPE;
    BEGIN
        g_error := 'GET o_vs';
    
        SELECT id_vital_sign
          INTO o_vs
          FROM triage_type_vs ttv
          JOIN triage_vs_area tva
            ON ttv.id_triage_type_vs = tva.id_triage_type_vs
         WHERE tva.id_context = i_triage_discrim
           AND ttv.flg_available = g_yes;
    
        g_error := 'GET o_trts sum values';
    
        FOR i IN 1 .. i_vs_id.count
        LOOP
            SELECT vs.intern_name_vital_sign
              INTO l_vs_intern_name
              FROM vital_sign vs
             WHERE vs.id_vital_sign = i_vs_id(i);
        
            CASE l_vs_intern_name
                WHEN 'RESPIRATORY_RATE' THEN
                
                    -- Inicialmente apenas estava a ser validado se o sinal vital não tinha parent, no entanto,
                    -- para calcular o TRTS são enviados dois sinais vitais sem parent: a frequência respiratória
                    -- e o glasgow total. De forma a diferenciar estes dois sinais foi introduzida mais uma validação:
                    -- o tipo de relação ser diferente de "S" (glasgow). Esta solução não é a mais correcta. Deveria
                    -- ser criado um mecanismo diferente que permitissse distinguir os vários sinais vitais (talvez
                    -- através de um internal name / vital sign code)
                    -- Frequencia respiratória
                    --Frequência respiratória
                    IF i_vs_val(i) = 0
                    THEN
                        l_vstrts_1 := 0;
                    ELSIF i_vs_val(i) BETWEEN 1 AND 5
                    THEN
                        l_vstrts_1 := 1;
                    ELSIF i_vs_val(i) BETWEEN 6 AND 9
                    THEN
                        l_vstrts_1 := 2;
                    ELSIF i_vs_val(i) BETWEEN 10 AND 29
                    THEN
                        l_vstrts_1 := 4;
                    ELSIF i_vs_val(i) > 29
                    THEN
                        l_vstrts_1 := 3;
                    END IF;
                WHEN 'BLOOD_PRESSURE_S' THEN
                    -- Blood Pressure
                    IF i_vs_val(i) = 0
                    THEN
                        l_vstrts_2 := 0;
                    ELSIF i_vs_val(i) BETWEEN 1 AND 49
                    THEN
                        l_vstrts_2 := 1;
                    ELSIF i_vs_val(i) BETWEEN 50 AND 75
                    THEN
                        l_vstrts_2 := 2;
                    ELSIF i_vs_val(i) BETWEEN 76 AND 89
                    THEN
                        l_vstrts_2 := 3;
                    ELSIF i_vs_val(i) >= 90
                    THEN
                        l_vstrts_2 := 4;
                    END IF;
                
                WHEN 'GLASGOW' THEN
                    IF i_vs_val(i) = 3
                    THEN
                        l_vstrts_3 := 0;
                    ELSIF i_vs_val(i) BETWEEN 4 AND 5
                    THEN
                        l_vstrts_3 := 1;
                    ELSIF i_vs_val(i) BETWEEN 6 AND 8
                    THEN
                        l_vstrts_3 := 2;
                    ELSIF i_vs_val(i) BETWEEN 9 AND 12
                    THEN
                        l_vstrts_3 := 3;
                    ELSIF i_vs_val(i) BETWEEN 13 AND 15
                    THEN
                        l_vstrts_3 := 4;
                    END IF;
                ELSE
                    NULL;
            END CASE;
        END LOOP;
        o_trts := l_vstrts_1 + l_vstrts_2 + l_vstrts_3;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
        
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_TRIAGE_TRTS',
                                              o_error);
        
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        
    END;
    --
    /********************************************************************************************
    * Devolver as cores associadas ao tipo de triagem, bem como a cor do episódio em análise
    *
    * @param i_lang                language id
    * @param i_prof                professional, software and institution ids
    * @param i_episode             episode id
    * @param o_color_triage        array with color triage and color episode
    * @param o_error               Error message
    *
    * @return                      true (sucess), false (error)
    *    
    * @author                      Emília Taborda
    * @version                     1.0    
    * @since                       2007/06/06
    **********************************************************************************************/
    FUNCTION get_epis_triage_color
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        o_epis_color OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_triage_type sys_config.value%TYPE;
        l_no_color_id triage_color.id_triage_color%TYPE;
        l_exception EXCEPTION;
    BEGIN
        g_error := 'GET TRIAGE_TYPE';
        pk_alertlog.log_debug(g_error);
        l_triage_type := pk_edis_triage.get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
    
        g_error := 'GET NO COLOR ID';
        pk_alertlog.log_debug(g_error);
        l_no_color_id := get_id_no_color(i_lang => i_lang, i_prof => i_prof, i_id_triage_type => l_triage_type);
    
        IF l_no_color_id IS NULL
        THEN
            g_error := 'NO COLOR ID - NOT FOUND';
            RAISE l_exception;
        END IF;
    
        g_error := 'OPEN O_EPIS_COLOR';
        pk_alertlog.log_debug(g_error);
        OPEN o_epis_color FOR
            SELECT pk_translation.get_translation(i_lang, tc.code_accuity) desc_accuity,
                   tc.color,
                   tc.id_triage_color,
                   tc.color_text,
                   nvl((SELECT *
                         FROM (SELECT et.id_triage_color
                                 FROM epis_triage et
                                WHERE et.id_episode = i_episode
                                ORDER BY et.dt_end_tstz DESC) et
                        WHERE rownum < 2),
                       l_no_color_id) color_episode
              FROM triage_color tc, triage_type tt
             WHERE tc.id_triage_type = tt.id_triage_type
               AND tc.flg_show = g_flg_show_tr_color
               AND tc.flg_available = g_yes
               AND EXISTS (SELECT 0
                      FROM triage t
                     WHERE t.id_triage_color = tc.id_triage_color)
               AND tt.id_triage_type = l_triage_type
             ORDER BY rank;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_types.open_my_cursor(o_epis_color);
            pk_alert_exceptions.process_error(i_lang,
                                              'PARAMETER ERROR',
                                              g_error,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_EPIS_TRIAGE_COLOR',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_types.open_my_cursor(o_epis_color);
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              'GET_EPIS_TRIAGE_COLOR',
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_triage_color;

    /********************************************************************************************
    * This function returns the id_movement of the movement made right after a triage
    *
    * @param i_lang                language id
    * @param i_epis_triage         triage id
    *
    * @return                      id_movement of the movement we wan't
    
    * @author                      João Eiras
    * @since                       2007/03/26
    **********************************************************************************************/
    FUNCTION get_epis_triage_dest_room(i_epis_triage IN epis_triage.id_epis_triage%TYPE) RETURN room.id_room%TYPE IS
        l_id_room            room.id_room%TYPE;
        l_id_prof_triage     epis_triage.id_epis_triage%TYPE;
        l_dt_end_tstz_triage epis_triage.dt_end_tstz%TYPE;
        l_id_episode         epis_triage.id_episode%TYPE;
    BEGIN
    
        SELECT etr.id_professional, etr.dt_end_tstz, etr.id_episode, etr.id_room
          INTO l_id_prof_triage, l_dt_end_tstz_triage, l_id_episode, l_id_room
          FROM epis_triage etr
         WHERE etr.id_epis_triage = i_epis_triage;
    
        IF l_id_room IS NULL
        THEN
            SELECT id_room_to
              INTO l_id_room
              FROM (SELECT m.id_prof_request, m.flg_status, m.id_room_to
                      FROM (SELECT m2.id_prof_request, m2.flg_status, m2.id_room_to
                              FROM movement m2
                             WHERE m2.dt_req_tstz BETWEEN l_dt_end_tstz_triage AND l_dt_end_tstz_triage + INTERVAL '10'
                             minute
                               AND m2.id_episode = l_id_episode
                             ORDER BY m2.dt_req_tstz DESC) m
                     WHERE rownum < 2) t
             WHERE t.id_prof_request = l_id_prof_triage
               AND t.flg_status = g_movement_finish;
        END IF;
    
        RETURN l_id_room;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_epis_triage_dest_room;

    /**
    *
    * Function to insert or delete triage alerts
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_id_episode          Episode ID
    * @param i_dt_req_det          Record date
    * @param i_alert_type          Alert type: D - doctor, N - nurse    
    * @param i_type                Operation type: A - add, R- remove        
    * @param o_error               Error message
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      José Silva
    * @since                       2008/05/22
    * @version                     1.0
    *
    */

    FUNCTION set_alert_triage
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_episode IN episode.id_episode%TYPE,
        i_dt_req_det IN sys_alert_event.dt_record%TYPE,
        i_alert_type IN VARCHAR2,
        i_type       IN VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_internal_error EXCEPTION;
    BEGIN
    
        IF NOT set_alert_triage(i_lang             => i_lang,
                                i_prof             => i_prof,
                                i_id_episode       => i_id_episode,
                                i_dt_req_det       => i_dt_req_det,
                                i_alert_type       => i_alert_type,
                                i_type             => i_type,
                                i_is_transfer_inst => pk_alert_constant.g_no,
                                o_error            => o_error)
        THEN
        
            RAISE l_internal_error;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     o_error.ora_sqlcode,
                                                     o_error.ora_sqlerrm,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     'SET_ALERT_TRIAGE',
                                                     o_error);
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     'SET_ALERT_TRIAGE',
                                                     o_error);
    END set_alert_triage;

    /**
    *
    * Function to insert or delete triage alerts
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_id_episode          Episode ID
    * @param i_dt_req_det          Record date
    * @param i_alert_type          Alert type: D - doctor, N - nurse    
    * @param i_type                Operation type: A - add, R- remove        
    * @param i_is_transfer_inst    Calling method from transfer institution: (Y) Yes (N) No       
    * @param o_error               Error message
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      José Silva
    * @since                       2008/05/22
    * @version                     1.0
    *
    */

    FUNCTION set_alert_triage
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_episode       IN episode.id_episode%TYPE,
        i_dt_req_det       IN sys_alert_event.dt_record%TYPE,
        i_alert_type       IN VARCHAR2,
        i_type             IN VARCHAR2,
        i_is_transfer_inst IN VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_sys_alert_event sys_alert_event%ROWTYPE;
    
        l_alert_triage_nurse CONSTANT sys_alert.id_sys_alert%TYPE := 46;
        l_alert_triage_doc   CONSTANT sys_alert.id_sys_alert%TYPE := 47;
        l_alert_waiting_x    CONSTANT sys_alert.id_sys_alert%TYPE := 99;
        l_alert_reassess     CONSTANT sys_alert.id_sys_alert%TYPE := 322;
        l_id_sys_alert       sys_alert.id_sys_alert%TYPE;
        l_id_sys_alert_event sys_alert_event.id_sys_alert_event%TYPE;
    
        l_type         VARCHAR2(1);
        l_dt_first_obs epis_info.dt_first_obs_tstz%TYPE;
        l_error        t_error_out;
    
        l_user_exception    EXCEPTION;
        l_user_exception_nr EXCEPTION;
    
        l_id_epis_triage  epis_triage.id_epis_triage%TYPE;
        l_id_triage       triage.id_triage%TYPE;
        l_id_triage_color triage_color.id_triage_color%TYPE;
        l_flg_letter      epis_triage.flg_letter%TYPE;
        l_rec_color       triage_color%ROWTYPE;
    
        l_rowids_ei table_varchar;
    
        CURSOR c_epis_triage IS
            SELECT et.id_epis_triage, et.id_triage, et.id_triage_color, et.flg_letter
              FROM epis_triage et
             WHERE et.id_episode = i_id_episode
             ORDER BY et.dt_end_tstz DESC;
    
        CURSOR c_alerts_triage(i_id_alert IN NUMBER) IS
            SELECT sa.id_sys_alert_event
              FROM sys_alert_event sa
             WHERE id_episode = l_sys_alert_event.id_episode
               AND id_sys_alert = i_id_alert
             ORDER BY sa.dt_record;
    
        CURSOR c_alerts_triage_nurse IS
            SELECT sa.id_sys_alert_event
              FROM sys_alert_event sa
             WHERE id_episode = l_sys_alert_event.id_episode
               AND id_sys_alert = l_alert_triage_nurse
             ORDER BY sa.dt_record;
    
        CURSOR c_alerts_waiting_x IS
            SELECT sa.id_sys_alert_event
              FROM sys_alert_event sa
             WHERE id_episode = l_sys_alert_event.id_episode
               AND id_sys_alert = l_alert_waiting_x
             ORDER BY sa.dt_record;
    BEGIN
    
        l_type := i_type;
    
        g_error := 'GET DT_FIRST_OBS';
        BEGIN
            SELECT ei.dt_first_obs_tstz
              INTO l_dt_first_obs
              FROM epis_info ei
             WHERE ei.id_episode = i_id_episode;
        EXCEPTION
            WHEN no_data_found THEN
                l_dt_first_obs := NULL;
        END;
    
        IF pk_sysconfig.get_config('ALERT_TRIAGE_PERMISSION', i_prof) = g_yes
        THEN
        
            IF i_alert_type = g_alert_doc
            THEN
                l_id_sys_alert := l_alert_triage_doc;
            
                IF l_dt_first_obs IS NOT NULL
                   AND i_is_transfer_inst = pk_alert_constant.g_no
                THEN
                    l_type := NULL;
                END IF;
            
            ELSIF i_alert_type = g_alert_nurse
            THEN
                l_id_sys_alert := l_alert_triage_nurse;
            ELSIF i_alert_type = g_alert_waiting
            THEN
                l_id_sys_alert := l_alert_waiting_x;
            ELSIF i_alert_type = g_alert_reassess
            THEN
                l_id_sys_alert := l_alert_reassess;
            END IF;
        
            l_sys_alert_event.id_sys_alert := l_id_sys_alert;
            l_sys_alert_event.id_episode   := i_id_episode;
            l_sys_alert_event.id_record    := i_id_episode;
        
            IF l_type = g_type_add
            THEN
                g_error := 'INSERT INTO SYS_ALERT_EVENT';
                IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_sys_alert           => l_id_sys_alert,
                                                        i_id_episode          => i_id_episode,
                                                        i_id_record           => i_id_episode,
                                                        i_dt_record           => i_dt_req_det,
                                                        i_id_professional     => NULL,
                                                        i_id_room             => NULL,
                                                        i_id_clinical_service => NULL,
                                                        i_flg_type_dest       => NULL,
                                                        i_replace1            => NULL,
                                                        o_error               => l_error)
                THEN
                    RAISE l_user_exception_nr;
                END IF;
            ELSIF l_type = g_type_rem
            THEN
                g_error := 'DELETE SYS_ALERT_EVENT';
                IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                        i_prof            => i_prof,
                                                        i_sys_alert_event => l_sys_alert_event,
                                                        o_error           => l_error)
                THEN
                    RAISE l_user_exception_nr;
                END IF;
            ELSIF l_type = g_type_match
            THEN
                g_error := 'CHECK SYS_ALERT DOC';
                OPEN c_alerts_triage(l_alert_triage_doc);
                FETCH c_alerts_triage
                    INTO l_id_sys_alert_event;
            
                IF l_id_sys_alert_event IS NOT NULL
                THEN
                    UPDATE sys_alert_event sa
                       SET sa.id_record = l_sys_alert_event.id_record
                     WHERE sa.id_sys_alert_event = l_id_sys_alert_event;
                END IF;
            
                g_error := 'LOOP SYS_ALERT DOC';
                LOOP
                    FETCH c_alerts_triage
                        INTO l_id_sys_alert_event;
                
                    EXIT WHEN c_alerts_triage%NOTFOUND;
                
                    DELETE FROM sys_alert_event
                     WHERE id_sys_alert_event = l_id_sys_alert_event;
                END LOOP;
                CLOSE c_alerts_triage;
                g_error := 'CHECK SYS_ALERT NURSE';
                OPEN c_alerts_triage(l_alert_triage_nurse);
                FETCH c_alerts_triage
                    INTO l_id_sys_alert_event;
            
                IF l_id_sys_alert_event IS NOT NULL
                THEN
                    UPDATE sys_alert_event sa
                       SET sa.id_record = l_sys_alert_event.id_record
                     WHERE sa.id_sys_alert_event = l_id_sys_alert_event;
                END IF;
            
                g_error := 'LOOP SYS_ALERT NURSE';
                LOOP
                    FETCH c_alerts_triage
                        INTO l_id_sys_alert_event;
                
                    EXIT WHEN c_alerts_triage%NOTFOUND;
                
                    DELETE FROM sys_alert_event
                     WHERE id_sys_alert_event = l_id_sys_alert_event;
                END LOOP;
                CLOSE c_alerts_triage;
                g_error := 'CHECK SYS_ALERT WAITING X';
                OPEN c_alerts_triage(l_alert_waiting_x);
                FETCH c_alerts_triage
                    INTO l_id_sys_alert_event;
            
                IF l_id_sys_alert_event IS NOT NULL
                THEN
                    UPDATE sys_alert_event sa
                       SET sa.id_record = l_sys_alert_event.id_record
                     WHERE sa.id_sys_alert_event = l_id_sys_alert_event;
                END IF;
            
                g_error := 'LOOP SYS_ALERT WAITING X';
                LOOP
                    FETCH c_alerts_triage
                        INTO l_id_sys_alert_event;
                
                    EXIT WHEN c_alerts_triage%NOTFOUND;
                
                    DELETE FROM sys_alert_event
                     WHERE id_sys_alert_event = l_id_sys_alert_event;
                END LOOP;
                CLOSE c_alerts_triage;
                g_error := 'OPEN c_epis_triage';
                OPEN c_epis_triage;
                FETCH c_epis_triage
                    INTO l_id_epis_triage, l_id_triage, l_id_triage_color, l_flg_letter;
                CLOSE c_epis_triage;
            
                g_error := 'GET TRIAGE COLOR';
                BEGIN
                    SELECT tc.*
                      INTO l_rec_color
                      FROM triage_color tc
                     WHERE tc.id_triage_color = l_id_triage_color;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            
                g_error := 'SET TRIAGE COLOR';
                ts_epis_info.upd(id_episode_in          => i_id_episode,
                                 triage_flg_letter_in   => l_flg_letter,
                                 triage_flg_letter_nin  => FALSE,
                                 triage_acuity_in       => nvl(l_rec_color.color, '0x787864'),
                                 triage_acuity_nin      => FALSE,
                                 triage_color_text_in   => nvl(l_rec_color.color_text, '0xFFFFFF'),
                                 triage_color_text_nin  => FALSE,
                                 triage_rank_acuity_in  => nvl(l_rec_color.rank, 999),
                                 triage_rank_acuity_nin => FALSE,
                                 id_triage_color_in     => l_id_triage_color,
                                 id_triage_color_nin    => FALSE,
                                 rows_out               => l_rowids_ei);
            
                t_data_gov_mnt.process_update(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_table_name => 'EPIS_INFO',
                                              i_rowids     => l_rowids_ei,
                                              o_error      => o_error);
            
                g_error := 'CALL TO SET_EPIS_FAST_TRACK';
                IF NOT pk_fast_track.set_epis_fast_track(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_id_episode     => i_id_episode,
                                                         i_id_triage      => l_id_triage,
                                                         i_id_epis_triage => l_id_epis_triage,
                                                         i_flg_epis_ft    => pk_alert_constant.g_no,
                                                         o_error          => o_error)
                THEN
                    RAISE l_user_exception_nr;
                END IF;
            
                g_error := 'DELETE SYS_ALERT_EVENT DOC';
                IF l_dt_first_obs IS NOT NULL
                THEN
                    l_sys_alert_event.id_sys_alert := l_alert_triage_doc;
                
                    IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            o_error           => l_error)
                    THEN
                        RAISE l_user_exception_nr;
                    END IF;
                END IF;
            
                g_error := 'DELETE SYS_ALERT_EVENT NURSE';
                IF l_id_epis_triage IS NOT NULL
                THEN
                    l_sys_alert_event.id_sys_alert := l_alert_triage_nurse;
                
                    IF NOT pk_alerts.delete_sys_alert_event(i_lang            => i_lang,
                                                            i_prof            => i_prof,
                                                            i_sys_alert_event => l_sys_alert_event,
                                                            o_error           => l_error)
                    THEN
                        RAISE l_user_exception_nr;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_user_exception_nr THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error || ' / ' || l_error.err_desc,
                                                     'ALERT',
                                                     g_package_name,
                                                     'SET_ALERT_TRIAGE',
                                                     o_error);
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     'SET_ALERT_TRIAGE',
                                                     o_error);
        
    END set_alert_triage;

    /**
    * Returns the triage type and acronym for the given professional institution and episode department.
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_episode             Episode Id    
    * @param o_triage_type         Triage type        
    * @param o_triage_acronym      Triage acronym
    * @param o_error               Error message
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      Alexandre Santos
    * @since                       2009/08/19
    * @version                     1.0
    *
    */
    FUNCTION get_triage_type_int
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_episode        IN episode.id_episode%TYPE,
        i_department     IN department.id_department%TYPE DEFAULT NULL,
        o_triage_type    OUT triage_type.id_triage_type%TYPE,
        o_triage_acronym OUT triage_type.acronym%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name  VARCHAR2(30) := 'GET_TRIAGE_TYPE_INT';
        l_department department.id_department%TYPE;
        l_no_triage_cfg EXCEPTION;
    BEGIN
        pk_alertlog.log_debug(l_func_name || ' - INPUT PARAM - i_lang: ' || to_char(i_lang));
        pk_alertlog.log_debug(l_func_name || ' - INPUT PARAM - i_prof: ' || to_char(i_prof.id) || ', ' ||
                              to_char(i_prof.institution) || ', ' || to_char(i_prof.software));
        pk_alertlog.log_debug(l_func_name || ' - INPUT PARAM - i_episode: ' || to_char(i_episode));
        pk_alertlog.log_debug(l_func_name || ' - INPUT PARAM - i_department: ' || to_char(i_department));
    
        IF (i_department IS NULL)
        THEN
            g_error := 'GET EPISODE DEPARTMENT';
            pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
            BEGIN
                SELECT nvl(dcs.id_department, -1)
                  INTO l_department
                  FROM epis_info ei
                  LEFT JOIN dep_clin_serv dcs
                    ON dcs.id_dep_clin_serv = ei.id_dep_clin_serv
                 WHERE ei.id_episode = i_episode;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        ELSE
            l_department := i_department;
        END IF;
    
        g_error := 'GET TRIAGE TYPE AND ACRONYM';
        pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
        BEGIN
            SELECT id_triage_type, acronym
              INTO o_triage_type, o_triage_acronym
              FROM (SELECT tt.id_triage_type, tt.acronym
                      FROM triage_department td
                      JOIN triage_type tt
                        ON tt.id_triage_type = td.id_triage_type
                     WHERE td.id_institution IN (0, i_prof.institution)
                       AND td.id_department IN (-1, l_department)
                       AND td.flg_available = pk_alert_constant.g_yes
                     ORDER BY td.id_institution DESC, td.id_department DESC)
             WHERE rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                g_error := l_func_name || ' - NO TRIAGE CONFIGURATION FOR ID_INST: ' || i_prof.institution ||
                           '; ID_DEPT: ' || l_department || ';';
                pk_alertlog.log_debug(g_error);
                RAISE l_no_triage_cfg;
        END;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     l_func_name,
                                                     o_error);
    END get_triage_type_int;

    /********************************************************************************************
    * Return the institution default triage type
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param o_triage_type         Triage type        
    * @param o_triage_acronym      Triage acronym
    * @param o_error               Error message
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      Alexandre Santos
    * @version                     1.0
    * @since                       21-08-2009
    **********************************************************************************************/
    FUNCTION get_default_triage_type
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_triage_type    OUT triage_type.id_triage_type%TYPE,
        o_triage_acronym OUT triage_type.acronym%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'GET_DEFAULT_TRIAGE_TYPE';
    BEGIN
        g_error := 'GET TRIAGE TYPE AND ACRONYM';
        pk_alertlog.log_debug(l_func_name || ' - ' || g_error);
        SELECT id_triage_type, acronym
          INTO o_triage_type, o_triage_acronym
          FROM (SELECT td.id_triage_type, tt.acronym
                  FROM triage_department td
                  JOIN triage_type tt
                    ON tt.id_triage_type = td.id_triage_type
                 WHERE td.id_institution IN (0, i_prof.institution)
                   AND td.flg_available = pk_alert_constant.g_yes
                   AND td.flg_default = pk_alert_constant.g_yes
                 ORDER BY td.id_institution DESC)
         WHERE rownum = 1;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN pk_alert_exceptions.process_error(i_lang,
                                                     SQLCODE,
                                                     SQLERRM,
                                                     g_error,
                                                     'ALERT',
                                                     g_package_name,
                                                     l_func_name,
                                                     o_error);
    END get_default_triage_type;

    /********************************************************************************************
    * Returns all available triage types for the given institution
    *
    * @param i_institution         institution id
    *    
    * @return                      list of all institution triage types
    *
    * @author                      Alexandre Santos
    * @version                     1.0
    * @since                       21-08-2009
    **********************************************************************************************/
    FUNCTION tf_get_inst_triag_types(i_institution IN institution_group.id_institution%TYPE) RETURN table_number IS
        l_tbl_trg_types table_number;
    BEGIN
        SELECT td.id_triage_type
          BULK COLLECT
          INTO l_tbl_trg_types
          FROM triage_department td
         WHERE td.id_institution = i_institution
           AND td.flg_available = pk_alert_constant.g_yes;
    
        IF (l_tbl_trg_types.count = 0)
        THEN
            SELECT td.id_triage_type
              BULK COLLECT
              INTO l_tbl_trg_types
              FROM triage_department td
             WHERE td.id_institution = 0
               AND td.flg_available = pk_alert_constant.g_yes;
        END IF;
    
        -- Clear repeated elements
        l_tbl_trg_types := l_tbl_trg_types MULTISET UNION DISTINCT l_tbl_trg_types;
    
        RETURN l_tbl_trg_types;
    END tf_get_inst_triag_types;

    /**
    * Returns the triage type for the given professional institution and department.
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_department          Department Id    
    *
    * @return                      TRUE if sucess, FALSE otherwise
    *
    * @author                      Alexandre Santos
    * @since                       2009/08/20
    * @version                     1.0
    *
    */
    FUNCTION get_triage_type_by_dep
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_department IN department.id_department%TYPE
    ) RETURN triage_type.id_triage_type%TYPE IS
        l_triage_type    triage_type.id_triage_type%TYPE;
        l_triage_acronym triage_type.acronym%TYPE;
        l_error          t_error_out;
    BEGIN
        IF (NOT get_triage_type_int(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_episode        => NULL,
                                    i_department     => i_department,
                                    o_triage_type    => l_triage_type,
                                    o_triage_acronym => l_triage_acronym,
                                    o_error          => l_error))
        THEN
            RETURN NULL;
        END IF;
    
        RETURN l_triage_type;
    END get_triage_type_by_dep;

    /**
    * Returns the triage type for the given professional institution and episode department.
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_episode             Episode Id    
    *
    * @return                      Triage type
    *
    * @author                      Alexandre Santos
    * @since                       2009/08/19
    * @version                     1.0
    *
    */
    FUNCTION get_triage_type
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE
    ) RETURN triage_type.id_triage_type%TYPE IS
        l_triage_type    triage_type.id_triage_type%TYPE;
        l_triage_acronym triage_type.acronym%TYPE;
        l_error          t_error_out;
    BEGIN
        IF (NOT get_triage_type_int(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_episode        => i_episode,
                                    o_triage_type    => l_triage_type,
                                    o_triage_acronym => l_triage_acronym,
                                    o_error          => l_error))
        THEN
            RETURN NULL;
        END IF;
    
        RETURN l_triage_type;
    END get_triage_type;

    /**
    * Returns the triage acronym for the given professional institution and episode department.
    *
    * @param i_lang                Language Id
    * @param i_prof                Professional, institution, software
    * @param i_episode             Episode Id    
    *
    * @return                      Triage acronym
    *
    * @author                      Alexandre Santos
    * @since                       2009/08/19
    * @version                     1.0
    *
    */
    FUNCTION get_triage_acronym
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE
    ) RETURN triage_type.acronym%TYPE IS
        l_triage_type    triage_type.id_triage_type%TYPE;
        l_triage_acronym triage_type.acronym%TYPE;
        l_error          t_error_out;
    BEGIN
        IF (NOT get_triage_type_int(i_lang           => i_lang,
                                    i_prof           => i_prof,
                                    i_episode        => i_episode,
                                    o_triage_type    => l_triage_type,
                                    o_triage_acronym => l_triage_acronym,
                                    o_error          => l_error))
        THEN
            RETURN NULL;
        END IF;
    
        RETURN l_triage_acronym;
    END get_triage_acronym;

    /**************************************************************************
    * Obtains the configurations for the triage in use.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode ID
    * @param i_triage_type            ID for the type of triage
    * @param o_config_row             Row with configurations
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          04/12/2009
    **************************************************************************/
    FUNCTION get_triage_config_row
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN episode.id_episode%TYPE,
        i_triage_type IN triage_type.id_triage_type%TYPE,
        o_config_row  OUT triage_configuration%ROWTYPE,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name      VARCHAR2(200) := 'GET_TRIAGE_CONFIG_ROW';
        l_triage_type    triage_type.id_triage_type%TYPE;
        l_triage_acronym triage_type.acronym%TYPE;
        l_count          NUMBER(6);
    
        l_internal_error EXCEPTION;
        l_config_error   EXCEPTION;
    BEGIN
    
        IF i_triage_type IS NULL
        THEN
            IF i_episode IS NOT NULL
            THEN
                g_error := 'GET TRIAGE_TYPE';
                pk_alertlog.log_debug(g_error);
                l_triage_type := get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
            ELSE
                -- If episode is not specified, obtain the institution's default triage type.
                g_error := 'GET DEFAULT TRIAGE_TYPE';
                pk_alertlog.log_debug(g_error);
                IF NOT get_default_triage_type(i_lang           => i_lang,
                                               i_prof           => i_prof,
                                               o_triage_type    => l_triage_type,
                                               o_triage_acronym => l_triage_acronym,
                                               o_error          => o_error)
                THEN
                    RAISE l_internal_error;
                END IF;
            END IF;
        
            IF l_triage_type IS NULL
            THEN
                g_error := 'TRIAGE TYPE NOT FOUND';
                pk_alertlog.log_debug(g_error);
                RAISE l_config_error;
            END IF;
        ELSE
            l_triage_type := i_triage_type;
        END IF;
    
        -- Check if exists configurations for the current triage type
        g_error := 'CHECK CONFIGURATIONS';
        pk_alertlog.log_debug(g_error);
        SELECT COUNT(*)
          INTO l_count
          FROM triage_configuration t
         WHERE t.id_triage_type = l_triage_type;
    
        IF l_count = 0
        THEN
            g_error := 'NO CONFIGURATIONS FOUND FOR CURRENT TRIAGE TYPE';
            RAISE l_config_error;
        END IF;
    
        BEGIN
            g_error := 'GET TRIAGE CONFIGURATIONS';
            pk_alertlog.log_debug(g_error);
            SELECT t.*
              INTO o_config_row
              FROM (SELECT tconf.*
                      FROM triage_configuration tconf
                     WHERE tconf.id_triage_type = l_triage_type
                       AND ((tconf.id_institution = 0 AND tconf.id_software = 0 AND NOT EXISTS
                            (SELECT 1
                                FROM triage_configuration tconf1
                               WHERE tconf1.id_institution = i_prof.institution
                                 AND tconf1.id_triage_type = l_triage_type
                                 AND tconf1.id_software IN (0, i_prof.software))) OR
                           (tconf.id_institution = i_prof.institution AND tconf.id_software IN (0, i_prof.software)))
                     ORDER BY tconf.id_institution DESC, tconf.id_software DESC) t
             WHERE rownum = 1;
        EXCEPTION
            WHEN no_data_found THEN
                g_error := 'NO CONFIGURATIONS FOUND FOR CURRENT INSTITUTION/SOFTWARE';
                RAISE l_config_error;
        END;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.err_desc,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN l_config_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'CONFIG ERROR',
                                              g_error,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_triage_config_row;

    /**************************************************************************
    * Load the configurations for the triage in use.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode id
    * @param o_config                 Cursor with configurations
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          23/11/2009
    **************************************************************************/
    FUNCTION get_triage_configurations
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_show_additional_info IN BOOLEAN DEFAULT TRUE,
        o_config               OUT cursor_triage_conf,
        o_row_triage_config    OUT triage_configuration%ROWTYPE,
        o_section              OUT t_table_ds_sections,
        o_def_events           OUT t_table_ds_def_events,
        o_tbl_detail_schema    OUT t_table_ds_sections,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(200) := 'GET_TRIAGE_CONFIGURATIONS';
        --
        l_internal_error EXCEPTION;
        --
        l_ds_component ds_component.internal_name%TYPE;
        l_ds_comp_type ds_component.flg_component_type%TYPE;
        --
        l_detail_schema CLOB;
    BEGIN
    
        -- Get configurations for current triage type
        g_error := 'GET CONFIGURATIONS';
        IF NOT get_triage_config_row(i_lang        => i_lang,
                                     i_prof        => i_prof,
                                     i_episode     => i_episode,
                                     i_triage_type => NULL,
                                     o_config_row  => o_row_triage_config,
                                     o_error       => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'GET COMPONENT NAME AND TYPE';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        SELECT dc.internal_name, dc.flg_component_type
          INTO l_ds_component, l_ds_comp_type
          FROM ds_component dc
          JOIN triage_ds_component tdc
            ON tdc.internal_name = dc.internal_name
           AND tdc.flg_component_type = dc.flg_component_type
         WHERE tdc.id_triage_ds_component = o_row_triage_config.id_triage_ds_component;
    
        g_error := 'CALL PK_DYNAMIC_SCREEN.GET_DS_SECTION_EVENTS_LIST';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_dynamic_screen.get_ds_section_events_list(i_lang           => i_lang,
                                                            i_prof           => i_prof,
                                                            i_component_name => l_ds_component,
                                                            i_component_type => l_ds_comp_type,
                                                            i_patient        => pk_episode.get_id_patient(i_episode => i_episode),
                                                            o_section        => o_section,
                                                            o_def_events     => o_def_events,
                                                            o_error          => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'CALL PK_EDIS_TRIAGE.TF_DETAIL_SCHEMA';
        pk_alertlog.log_debug(g_error);
        o_tbl_detail_schema := pk_edis_triage.tf_detail_schema(i_lang                 => i_lang,
                                                               i_prof                 => i_prof,
                                                               i_episode              => i_episode,
                                                               i_show_additional_info => i_show_additional_info,
                                                               i_triage_type          => o_row_triage_config.id_triage_type,
                                                               i_ds_component         => l_ds_component,
                                                               i_ds_comp_type         => l_ds_comp_type,
                                                               i_ds_tbl_nodes         => o_section);
    
        g_error := 'SET DETAIL SCHEMA';
        pk_alertlog.log_debug(g_error);
        SELECT xmlelement("DETAIL", xmlattributes(a.id_ds_component AS "ID", a.component_desc AS "TITLE"), --
                (SELECT xmlagg(xmlelement("BLOCK",
                                           xmlattributes(b.id_ds_component AS "ID",
                                                         b.component_desc AS "TITLE",
                                                         b.rank AS "RANK",
                                                         b.max_len AS "MAX_LEN",
                                                         b.id_ds_component_parent AS "PARENT_ID",
                                                         CASE
                                                             WHEN b.internal_name IN (g_ds_comp_triage_est, g_ds_comp_triage_sa, g_ds_comp_triage_ctas)
                                                                  AND o_row_triage_config.flg_considerations = pk_alert_constant.g_no THEN
                                                              pk_alert_constant.g_yes
                                                             ELSE
                                                              pk_alert_constant.g_no
                                                         END AS "FLG_SHOW_IN_VIEWER"), --
                                           (SELECT xmlagg(xmlelement("SECTION",
                                                                     xmlattributes(c.id_ds_component AS "ID",
                                                                                   c.component_desc AS "TITLE",
                                                                                   c.rank AS "RANK",
                                                                                   c.id_ds_component_parent AS "PARENT_ID"), --
                                                                     (SELECT xmlagg(xmlelement("ITEM",
                                                                                                xmlattributes(d.id_ds_component AS "ID",
                                                                                                              d.component_desc AS
                                                                                                              "TITLE",
                                                                                                              d.max_len AS
                                                                                                              "MAX_LEN",
                                                                                                              d.min_value AS
                                                                                                              "MIN_VALUE",
                                                                                                              d.max_value AS
                                                                                                              "MAX_VALUE",
                                                                                                              d.rank AS "RANK",
                                                                                                              d.id_ds_component_parent AS
                                                                                                              "PARENT_ID",
                                                                                                              CASE
                                                                                                                   WHEN c.internal_name IN
                                                                                                                        (pk_edis_triage.g_ds_comp_est_vsigns,
                                                                                                                         pk_edis_triage.g_ds_comp_vsigns) THEN
                                                                                                                    substr(d.id_ds_component,
                                                                                                                           length(d.id_ds_component_parent) + 1,
                                                                                                                           length(d.id_ds_component) -
                                                                                                                           length(d.id_ds_component_parent) + 1)
                                                                                                                   ELSE
                                                                                                                    NULL
                                                                                                               END
                                                                                                              /*     decode(c.internal_name,
                                                                                                              pk_edis_triage.g_ds_comp_est_vsigns,
                                                                                                              substr(d.id_ds_component,
                                                                                                                     length(d.id_ds_component_parent) + 1,
                                                                                                                     length(d.id_ds_component) -
                                                                                                                     length(d.id_ds_component_parent) + 1),
                                                                                                              NULL)*/ AS
                                                                                                               "ID_VITAL_SIGN")))
                                                                        FROM TABLE(o_tbl_detail_schema) d
                                                                       WHERE d.id_ds_component_parent = c.id_ds_component
                                                                         AND d.flg_component_type =
                                                                             pk_dynamic_screen.c_leaf_component)))
                                              FROM TABLE(o_tbl_detail_schema) c
                                             WHERE c.id_ds_component_parent = b.id_ds_component
                                               AND c.flg_component_type = pk_dynamic_screen.c_node_component)))
                   FROM TABLE(o_tbl_detail_schema) b
                  WHERE b.id_ds_component_parent = a.id_ds_component
                    AND b.flg_component_type = pk_dynamic_screen.c_root_component)).getclobval()
          INTO l_detail_schema
          FROM TABLE(o_tbl_detail_schema) a
         WHERE a.flg_component_type = pk_dynamic_screen.c_root_component
           AND a.id_ds_component_parent IS NULL;
    
        g_error := 'LOAD CONFIGURATIONS';
        pk_alertlog.log_debug(g_error);
        OPEN o_config FOR
            SELECT o_row_triage_config.id_institution id_institution,
                   o_row_triage_config.id_software    id_software,
                   o_row_triage_config.id_triage_type id_triage_type,
                   -- ASantos 05-01-2012: ALERT-188926 - Ability to perform triage based on EST (Échele Suisse de Tri)
                   o_row_triage_config.id_triage_ds_component id_triage_ds_component,
                   l_ds_component ds_comp_int_name,
                   l_ds_comp_type ds_comp_flg_comp,
                   o_row_triage_config.flg_buttons flg_buttons,
                   o_row_triage_config.flg_considerations flg_considerations,
                   o_row_triage_config.num_epis_triage_audit num_epis_triage_audit,
                   o_row_triage_config.id_reports id_reports,
                   o_row_triage_config.flg_auto_print_tag flg_auto_print_tag,
                   o_row_triage_config.flg_change_color flg_change_color,
                   o_row_triage_config.flg_complaint flg_complaint,
                   o_row_triage_config.flg_default_view flg_default_view,
                   o_row_triage_config.flg_check_vital_sign flg_check_vital_sign,
                   o_row_triage_config.flg_id_board flg_id_board,
                   o_row_triage_config.flg_check_age_limits flg_check_age_limits,
                   o_row_triage_config.flg_filter_flowchart flg_filter_flowchart,
                   o_row_triage_config.flg_triage_res_grids flg_triage_res_grids,
                   o_row_triage_config.flg_show_color_desc flg_show_color_desc,
                   CASE
                        WHEN o_row_triage_config.id_triage_type IN
                             (pk_edis_triage.g_triage_id_est,
                              pk_edis_triage.g_triage_id_sa,
                              pk_edis_triage.g_triage_id_ctas_p,
                              pk_edis_triage.g_triage_id_ctas_a)
                             AND o_row_triage_config.flg_considerations = pk_alert_constant.g_no THEN
                         pk_alert_constant.g_yes
                        ELSE
                         pk_alert_constant.g_no
                    END flg_show_detail_viewer,
                   l_detail_schema detail_schema
              FROM dual;
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_types.open_my_cursor(o_config);
            o_section    := t_table_ds_sections();
            o_def_events := t_table_ds_def_events();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_config);
            o_section    := t_table_ds_sections();
            o_def_events := t_table_ds_def_events();
            RETURN FALSE;
    END get_triage_configurations;

    FUNCTION get_triage_configurations
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_show_additional_info IN BOOLEAN DEFAULT TRUE,
        o_config               OUT cursor_triage_conf,
        o_section              OUT t_table_ds_sections,
        o_def_events           OUT t_table_ds_def_events,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_row_triage_config triage_configuration%ROWTYPE;
        l_tbl_detail_schema t_table_ds_sections;
    BEGIN
        RETURN get_triage_configurations(i_lang                 => i_lang,
                                         i_prof                 => i_prof,
                                         i_episode              => i_episode,
                                         i_show_additional_info => i_show_additional_info,
                                         o_config               => o_config,
                                         o_row_triage_config    => l_row_triage_config,
                                         o_section              => o_section,
                                         o_def_events           => o_def_events,
                                         o_tbl_detail_schema    => l_tbl_detail_schema,
                                         o_error                => o_error);
    END get_triage_configurations;

    /**************************************************************************
    * Used to return the data about a "hidden" discriminator.
    * These discriminators can be accepted by answering the opposite of the acceptance option
    * in the last discriminator of the last box, in some flowcharts.
    * Only supported by some protocols, such as Manchester 2 NL.
    *   
    * @param i_lang                    Language ID
    * @param i_prof                    Professional info
    * @param i_id_triage_type          Triage type ID
    * @param i_id_triage_color         Triage color ID
    * @param i_id_triage_board         Triage board ID
    * @param o_disc                    Discriminator data
    * @param o_error                   Error message
    *
    * @return                          TRUE / FALSE
    *                        
    * @author                          José Brito
    * @version                         2.6
    * @since                           20/01/2010
    **************************************************************************/
    FUNCTION get_hidden_discriminator
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_triage_type  IN triage_type.id_triage_type%TYPE,
        i_id_triage_color IN triage_color.id_triage_color%TYPE,
        i_id_triage_board IN triage_board.id_triage_board%TYPE,
        o_disc            OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200) := 'GET_HIDDEN_DISCRIMINATOR';
    BEGIN
    
        g_error := 'GET DISCRIMINATOR DATA';
        pk_alertlog.log_debug(g_error);
        OPEN o_disc FOR
            SELECT t.id_triage,
                   t.id_triage_color,
                   tc.color_text,
                   tc.code_accuity acuity,
                   t.id_triage_discriminator,
                   pk_translation.get_translation(i_lang, td.code_triage_discriminator) desc_discriminator
              FROM triage t
              JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
              JOIN triage_color tc
                ON tc.id_triage_color = t.id_triage_color
             WHERE t.id_triage_color = i_id_triage_color
               AND t.id_triage_board = i_id_triage_board
               AND t.id_triage_type = i_id_triage_type
               AND t.flg_available = pk_alert_constant.g_yes
               AND t.box = -1; -- Hidden box
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_disc);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_hidden_discriminator;

    /**************************************************************************
    * Converts a serialized date string to the appropriate date format.
    *   
    * @param i_lang                    Language ID
    * @param i_prof                    Professional info
    * @param i_date_str                Date to convert
    * @param o_date                    Converted date
    * @param o_error                   Error message
    *
    * @return                          TRUE / FALSE
    *                        
    * @author                          José Brito
    * @version                         2.6
    * @since                           20/05/2010
    **************************************************************************/
    FUNCTION convert_triage_date
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_date_str IN VARCHAR2,
        o_date     OUT VARCHAR2,
        o_error    OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200) := 'CONVERT_TRIAGE_DATE';
    BEGIN
    
        g_error := 'CONVERT DATE';
        o_date  := pk_date_utils.date_hour_chr_extend(i_lang => i_lang,
                                                      i_date => to_date(i_date_str, pk_date_utils.g_dateformat),
                                                      i_prof => i_prof);
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END convert_triage_date;

    /**************************************************************************
    * Get the institution's triage type for auditing reports.
    *   
    * @param i_lang                    Language ID
    * @param i_prof                    Professional info
    * @param o_audit_type              Audit type ID
    * @param o_id_triage_type          Triage type ID
    * @param o_triage_acronym          Triage acronym 
    * @param o_error                   Error message
    *
    * @return                          TRUE / FALSE
    *                        
    * @author                          José Brito
    * @version                         2.6
    * @since                           07/12/2010
    **************************************************************************/
    FUNCTION get_instit_audit_triage_type
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_audit_type     OUT audit_type.id_audit_type%TYPE,
        o_id_triage_type OUT triage_type.id_triage_type%TYPE,
        o_triage_acronym OUT triage_type.acronym%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(200 CHAR) := 'GET_INSTIT_AUDIT_TRIAGE_TYPE';
        l_internal_error EXCEPTION;
    
        l_triage_type    triage_type.id_triage_type%TYPE;
        l_triage_acronym triage_type.acronym%TYPE;
    BEGIN
    
        -- Obtain the institution's default triage type.
        g_error := 'GET DEFAULT TRIAGE_TYPE';
        pk_alertlog.log_debug(g_error);
        IF NOT get_default_triage_type(i_lang           => i_lang,
                                       i_prof           => i_prof,
                                       o_triage_type    => l_triage_type,
                                       o_triage_acronym => l_triage_acronym,
                                       o_error          => o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        -- Check if triage type has audit support 
        g_error := 'CHECK AUDIT SUPPORT';
        pk_alertlog.log_debug(g_error);
        SELECT att.id_audit_type, att.id_triage_type, tt.acronym
          INTO o_audit_type, o_id_triage_type, o_triage_acronym
          FROM audit_type_triage_type att
          JOIN triage_type tt
            ON tt.id_triage_type = att.id_triage_type
         WHERE att.id_triage_type = l_triage_type
           AND att.flg_available = pk_alert_constant.g_yes;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_instit_audit_triage_type;

    /**
    * Get dynamic screen sections and events list
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_episode                   Episode id
    * @param   o_section                   Section cursor
    * @param   o_def_events                Def events cursor
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6
    * @since   15-12-2011
    */
    FUNCTION get_section_events_list_int
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_show_additional_info IN BOOLEAN DEFAULT TRUE,
        o_section              OUT t_table_ds_sections,
        o_def_events           OUT t_table_ds_def_events,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_SECTION_EVENTS_LIST_INT';
        --
        c_config pk_types.cursor_type;
        --
        l_exception EXCEPTION;
    BEGIN
        g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_CONFIGURATIONS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT pk_edis_triage.get_triage_configurations(i_lang                 => i_lang,
                                                        i_prof                 => i_prof,
                                                        i_episode              => i_episode,
                                                        i_show_additional_info => i_show_additional_info,
                                                        o_config               => c_config,
                                                        o_section              => o_section,
                                                        o_def_events           => o_def_events,
                                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
        
            o_section    := t_table_ds_sections();
            o_def_events := t_table_ds_def_events();
            RETURN FALSE;
    END get_section_events_list_int;

    FUNCTION get_section_events_list
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_episode    IN episode.id_episode%TYPE,
        o_section    OUT pk_types.cursor_type,
        o_def_events OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_SECTION_EVENTS_LIST';
        --
        l_tbl_section    t_table_ds_sections;
        l_tbl_def_events t_table_ds_def_events;
        --
        l_ret BOOLEAN;
    BEGIN
        l_ret := get_section_events_list_int(i_lang       => i_lang,
                                             i_prof       => i_prof,
                                             i_episode    => i_episode,
                                             o_section    => l_tbl_section,
                                             o_def_events => l_tbl_def_events,
                                             o_error      => o_error);
    
        IF l_ret
        THEN
            g_error := 'OPEN O_SECTION';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN o_section FOR
                SELECT *
                  FROM TABLE(l_tbl_section);
        
            g_error := 'OPEN O_DEF_EVENTS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN o_def_events FOR
                SELECT *
                  FROM TABLE(l_tbl_def_events);
        ELSE
            pk_types.open_my_cursor(o_section);
            pk_types.open_my_cursor(o_def_events);
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
        
            pk_types.open_my_cursor(o_section);
            pk_types.open_my_cursor(o_def_events);
            RETURN FALSE;
    END get_section_events_list;

    /**************************************************************************
    * Returns the set of child discriminators for the discriminator.
    * This is used in the ESI triage protocol.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_disc                Parent discriminator ID
    * @param i_id_patient             Patient ID used to filter by age
    * @param o_discrim_child          Discriminator data
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.2.1.6
    * @since                          21-8-2012
    **************************************************************************/
    FUNCTION get_triage_discrim_child
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_disc              IN triage_discriminator.id_triage_discriminator%TYPE,
        i_id_patient           IN patient.id_patient%TYPE,
        i_ignore_flg_available IN VARCHAR2, --Ignore flg_available when getting saved data
        o_discrim_child        OUT pk_edis_types.cursor_discrim_child,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name             VARCHAR2(200) := 'GET_TRIAGE_DISCRIM_CHILD';
        l_config_next_dec_point sys_config.value%TYPE;
        l_config_activate_no    sys_config.value%TYPE;
        l_patient_age           NUMBER(7, 2);
        l_code_domain_yes_no CONSTANT sys_domain.code_domain%TYPE := 'YES_NO';
        l_desc_domain_yes pk_translation.t_desc_translation := pk_sysdomain.get_domain(i_code_dom => l_code_domain_yes_no,
                                                                                       i_val      => pk_alert_constant.g_yes,
                                                                                       i_lang     => i_lang);
        l_desc_domain_no  pk_translation.t_desc_translation := pk_sysdomain.get_domain(i_code_dom => l_code_domain_yes_no,
                                                                                       i_val      => pk_alert_constant.g_no,
                                                                                       i_lang     => i_lang);
    BEGIN
        -- ID_TRIAGE that should advance to the next ESI decision point, when selected. Others should proceed to 
        -- the confirmation screen, assigning the corresponding ID_TRIAGE_COLOR to the triage.
        g_error                 := 'GET CONFIGURATIONS';
        l_config_next_dec_point := pk_sysconfig.get_config('ESI_TRIAGE_NEXT_DECISION_POINT',
                                                           i_prof.institution,
                                                           i_prof.software);
        l_config_activate_no    := pk_sysconfig.get_config('ESI_TRIAGE_ACTIVATE_NO_IN_PARENT',
                                                           i_prof.institution,
                                                           i_prof.software);
    
        IF i_id_patient IS NOT NULL
        THEN
            SELECT nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12, 2)) age
              INTO l_patient_age
              FROM patient p
             WHERE p.id_patient = i_id_patient;
        END IF;
    
        g_error := 'GET O_DISCRIM_CHILD';
        pk_alertlog.log_debug(g_error);
        OPEN o_discrim_child FOR
            SELECT t.id_triage,
                   t.flg_reassess,
                   t.id_triage_color, -- Color assigned to the patient when the ACCEPTANCE OPTION is selected
                   t.id_triage_color_other, -- Color assigned when the OPPOSITE of the acceptance option is selected
                   tc.color_text,
                   tc.color acuity,
                   t.id_triage_discriminator,
                   pk_translation.get_translation(i_lang, td.code_triage_discriminator) desc_discriminator,
                   -- Option that allows acceptance of the discriminator. Default option is 'YES'.
                   nvl(t.flg_accepted_option, pk_alert_constant.g_yes) flg_accepted_option,
                   decode(nvl(t.flg_accepted_option, pk_alert_constant.g_yes),
                          pk_alert_constant.g_yes,
                          l_desc_domain_yes,
                          l_desc_domain_no) desc_accepted_option,
                   -- Check if after accepting option, it must proceed to the accuity confirmation screen or not.
                   decode(instr(l_config_next_dec_point, '|' || t.id_triage || '|'),
                          0,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_accuity_confirmation,
                   -- Option that each child discriminator should activate in the parent.
                   decode(instr(l_config_activate_no, '|' || t.id_triage_discriminator || '|'),
                          0,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_select_option,
                   decode(td.id_triage_decision_point,
                          NULL,
                          NULL,
                          (SELECT pk_translation.get_translation(i_lang, tc.code_triage_color)
                             FROM dual)) esi_level_header
              FROM triage_discriminator td
              JOIN triage t
                ON t.id_triage_discriminator = td.id_triage_discriminator
              JOIN triage_color tc
                ON tc.id_triage_color = t.id_triage_color
             WHERE td.id_parent = i_id_disc
               AND (td.flg_available = pk_alert_constant.g_yes OR
                   nvl(i_ignore_flg_available, pk_alert_constant.g_no) = pk_alert_constant.g_yes)
               AND (t.flg_available = pk_alert_constant.g_yes OR
                   nvl(i_ignore_flg_available, pk_alert_constant.g_no) = pk_alert_constant.g_yes)
               AND pk_edis_triage.check_age_limits(i_lang,
                                                   i_prof,
                                                   l_patient_age,
                                                   td.age_min,
                                                   g_age_min,
                                                   pk_alert_constant.g_yes,
                                                   NULL) = pk_alert_constant.g_yes
               AND pk_edis_triage.check_age_limits(i_lang,
                                                   i_prof,
                                                   l_patient_age,
                                                   td.age_max,
                                                   g_age_max,
                                                   pk_alert_constant.g_yes,
                                                   NULL) = pk_alert_constant.g_yes
             ORDER BY t.rank;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_edis_types.open_my_cursor(o_discrim_child);
            RETURN FALSE;
    END get_triage_discrim_child;

    /**************************************************************************
    * Returns the set of child discriminators for the discriminator.
    * This is used in the ESI triage protocol.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_disc                Parent discriminator ID
    * @param i_id_patient             Patient ID used to filter by age
    * @param o_discrim_child          Discriminator data
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.2.1.6
    * @since                          21-8-2012
    **************************************************************************/
    FUNCTION get_triage_discrim_child
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_disc       IN triage_discriminator.id_triage_discriminator%TYPE,
        i_id_patient    IN patient.id_patient%TYPE,
        o_discrim_child OUT pk_edis_types.cursor_discrim_child,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN get_triage_discrim_child(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_id_disc              => i_id_disc,
                                        i_id_patient           => i_id_patient,
                                        i_ignore_flg_available => pk_alert_constant.g_no,
                                        o_discrim_child        => o_discrim_child,
                                        o_error                => o_error);
    END get_triage_discrim_child;

    FUNCTION get_discrim_child_rec
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_disc              IN triage_discriminator.id_triage_discriminator%TYPE,
        i_id_patient           IN patient.id_patient%TYPE,
        i_ignore_flg_available IN VARCHAR2 DEFAULT pk_alert_constant.g_no
    ) RETURN pk_edis_types.rec_discrim_child IS
        l_func_name CONSTANT VARCHAR2(50 CHAR) := 'GET_DISCRIM_CHILD_REC';
        --
        l_id_disc_parent triage_discriminator.id_parent%TYPE;
        --
        c_discrim_child pk_edis_types.cursor_discrim_child;
        r_discrim_child pk_edis_types.rec_discrim_child;
        --
        l_found BOOLEAN := FALSE;
        --
        l_error t_error_out;
        l_exception EXCEPTION;
    BEGIN
        SELECT td.id_parent
          INTO l_id_disc_parent
          FROM triage_discriminator td
         WHERE td.id_triage_discriminator = i_id_disc;
    
        g_error := 'CALL GET_TRIAGE_DISCRIM_CHILD';
        pk_alertlog.log_debug(g_error);
        IF NOT get_triage_discrim_child(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_id_disc              => l_id_disc_parent,
                                        i_id_patient           => i_id_patient,
                                        i_ignore_flg_available => i_ignore_flg_available,
                                        o_discrim_child        => c_discrim_child,
                                        o_error                => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        LOOP
            FETCH c_discrim_child
                INTO r_discrim_child;
            EXIT WHEN c_discrim_child%NOTFOUND;
        
            IF r_discrim_child.id_triage_discriminator = i_id_disc
            THEN
                l_found := TRUE;
                EXIT;
            END IF;
        END LOOP;
    
        CLOSE c_discrim_child;
    
        IF l_found
        THEN
            RETURN r_discrim_child;
        ELSE
            RETURN NULL;
        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_discrim_child_rec;

    FUNCTION get_group_options
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_epis_triage         IN epis_triage.id_triage%TYPE,
        i_triage              IN triage.id_triage%TYPE DEFAULT NULL,
        i_triage_color        IN triage_color.id_triage_color%TYPE DEFAULT NULL,
        i_flg_selected_option IN epis_triage.flg_selected_option%TYPE DEFAULT NULL
    ) RETURN pk_edis_types.table_group_options IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_GROUP_OPTIONS';
        --
        l_triage              triage.id_triage%TYPE;
        l_triage_color        triage_color.id_triage_color%TYPE;
        l_flg_selected_option epis_triage.flg_selected_option%TYPE;
        --
        l_tbl_group_options pk_edis_types.table_group_options := pk_edis_types.table_group_options();
        l_tbl_options       pk_edis_types.table_options;
        --
        CURSOR c_options IS
            SELECT td.id_triage_discriminator,
                   pk_edis_triage.get_discriminator_desc(i_lang            => i_lang,
                                                         i_prof            => i_prof,
                                                         i_id_triage_type  => tt.id_triage_type,
                                                         i_acronym         => tt.acronym,
                                                         i_id_disc         => td.id_triage_discriminator,
                                                         i_id_disc_parent  => td.id_parent,
                                                         i_code_disc       => td.code_triage_discriminator,
                                                         i_selected_option => eto.flg_selected_option) desc_triage_discriminator,
                   eto.id_triage,
                   eto.id_triage_cons_value,
                   tcv.title_consent,
                   tcv.desc_consent,
                   tcv.flg_triage_cons_vs_mand,
                   tcv.flg_triage_cons_vs_enab,
                   eto.flg_selected_option,
                   t.id_triage_color,
                   (SELECT t1.id_triage_discriminator
                      FROM epis_triage_option eto1
                      JOIN triage t1
                        ON t1.id_triage = eto1.id_triage
                     WHERE eto1.id_epis_triage = eto.id_epis_triage
                       AND EXISTS (SELECT 1
                              FROM triage_discriminator td1
                             WHERE td1.id_parent = td.id_triage_discriminator
                               AND td1.id_triage_discriminator = t1.id_triage_discriminator)) id_triage_discrim_child,
                   (SELECT epis.id_patient
                      FROM epis_triage et
                      JOIN episode epis
                        ON epis.id_episode = et.id_episode
                     WHERE et.id_epis_triage = eto.id_epis_triage) id_patient,
                   t.flg_critical_look
              FROM epis_triage_option eto
              JOIN triage t
                ON t.id_triage = eto.id_triage
              JOIN triage_type tt
                ON tt.id_triage_type = t.id_triage_type
              JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
               AND td.id_parent IS NULL
              LEFT JOIN (SELECT a.line_number,
                                a.id_triage_cons_value,
                                pk_message.get_message(i_lang, tcv1.code_cons_detail_msg) title_consent,
                                pk_translation.get_translation(i_lang, tcv1.code_triage_cons_value) desc_consent,
                                tdc.flg_vs_mandatory flg_triage_cons_vs_mand,
                                tdc.flg_vs_enable flg_triage_cons_vs_enab
                           FROM (SELECT t1.id_triage_discriminator,
                                        eto1.id_triage_cons_value,
                                        row_number() over(ORDER BY t1.box DESC, t1.rank DESC) line_number
                                   FROM epis_triage_option eto1
                                   JOIN triage t1
                                     ON t1.id_triage = eto1.id_triage
                                  WHERE eto1.id_epis_triage = i_epis_triage) a
                           JOIN triage_cons_value tcv1
                             ON tcv1.id_triage_cons_value = a.id_triage_cons_value
                           JOIN triage_disc_consent tdc
                             ON tdc.id_triage_cons_value = tcv1.id_triage_cons_value
                          WHERE a.line_number = 1
                            AND a.id_triage_discriminator = tdc.id_triage_discriminator) tcv
                ON tcv.id_triage_cons_value = eto.id_triage_cons_value
             WHERE eto.id_epis_triage = i_epis_triage
             ORDER BY t.id_triage_color, t.box, t.rank, desc_triage_discriminator;
    
        r_option c_options%ROWTYPE;
    
        TYPE table_c_options IS TABLE OF c_options%ROWTYPE;
        l_tbl_c_options table_c_options;
    
        FUNCTION get_rec_option(i_option IN c_options%ROWTYPE) RETURN pk_edis_types.rec_option IS
            l_rec_option pk_edis_types.rec_option;
        BEGIN
            l_rec_option.id_triage_discriminator   := i_option.id_triage_discriminator;
            l_rec_option.desc_triage_discriminator := i_option.desc_triage_discriminator;
            l_rec_option.id_triage                 := i_option.id_triage;
            l_rec_option.id_triage_cons_value      := i_option.id_triage_cons_value;
            l_rec_option.title_consent             := i_option.title_consent;
            l_rec_option.desc_consent              := i_option.desc_consent;
            l_rec_option.flg_triage_cons_vs_mand   := i_option.flg_triage_cons_vs_mand;
            l_rec_option.flg_triage_cons_vs_enab   := i_option.flg_triage_cons_vs_enab;
            l_rec_option.flg_selected_option       := i_option.flg_selected_option;
            l_rec_option.flg_critical_look         := i_option.flg_critical_look;
        
            IF i_option.id_triage_discrim_child IS NOT NULL
            THEN
                l_rec_option.child_option := get_discrim_child_rec(i_lang                 => i_lang,
                                                                   i_prof                 => i_prof,
                                                                   i_id_disc              => i_option.id_triage_discrim_child,
                                                                   i_id_patient           => i_option.id_patient,
                                                                   i_ignore_flg_available => (CASE
                                                                                                 WHEN i_epis_triage IS NOT NULL THEN
                                                                                                  pk_alert_constant.g_yes
                                                                                                 ELSE
                                                                                                  pk_alert_constant.g_no
                                                                                             END));
            END IF;
        
            RETURN l_rec_option;
        END get_rec_option;
    BEGIN
        g_error := 'OPEN AND FETCH C_OPTIONS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN c_options;
        FETCH c_options BULK COLLECT
            INTO l_tbl_c_options;
        CLOSE c_options;
    
        IF i_triage IS NOT NULL
        THEN
            l_triage              := i_triage;
            l_triage_color        := i_triage_color;
            l_flg_selected_option := i_flg_selected_option;
        ELSE
            SELECT et.id_triage, et.id_triage_color, et.flg_selected_option
              INTO l_triage, l_triage_color, l_flg_selected_option
              FROM epis_triage et
             WHERE et.id_epis_triage = i_epis_triage;
        END IF;
    
        --l_tbl_c_options table will be always empty in triages other then ESI and EST because these are the only triages that
        --fill epis_triage_option table
        IF l_tbl_c_options.count > 0
        THEN
            g_error := 'FILL TABLE WITH ALL OPTIONS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            FOR i IN l_tbl_c_options.first .. l_tbl_c_options.last
            LOOP
                IF l_tbl_group_options.count = 0
                   OR l_tbl_group_options(l_tbl_group_options.count).id_triage_color != l_tbl_c_options(i).id_triage_color
                THEN
                    IF l_tbl_group_options.count != 0
                       AND l_tbl_group_options(l_tbl_group_options.count).id_triage_color != l_tbl_c_options(i).id_triage_color
                    THEN
                        l_tbl_group_options(l_tbl_group_options.count).options := l_tbl_options;
                    END IF;
                
                    l_tbl_group_options.extend;
                    l_tbl_group_options(l_tbl_group_options.count).id_triage_color := l_tbl_c_options(i).id_triage_color;
                
                    l_tbl_options := pk_edis_types.table_options();
                END IF;
            
                l_tbl_options.extend;
                l_tbl_options(l_tbl_options.count) := get_rec_option(i_option => l_tbl_c_options(i));
            END LOOP;
        
            IF l_tbl_group_options.count > 0
            THEN
                --Add last options to the last group
                l_tbl_group_options(l_tbl_group_options.count).options := l_tbl_options;
            END IF;
        END IF;
    
        --When l_tbl_group_options table is empty we must fill the values from epis_triage table
        IF l_tbl_group_options.count = 0
        THEN
            --If option wasn't found we need to get all data
            IF l_triage IS NOT NULL
            THEN
                g_error := 'FILL TRIAGE OPTION';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                SELECT td.id_triage_discriminator,
                       pk_edis_triage.get_discriminator_desc(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_id_triage_type  => tt.id_triage_type,
                                                             i_acronym         => tt.acronym,
                                                             i_id_disc         => td.id_triage_discriminator,
                                                             i_id_disc_parent  => td.id_parent,
                                                             i_code_disc       => td.code_triage_discriminator,
                                                             i_selected_option => l_flg_selected_option) desc_triage_discriminator,
                       t.id_triage,
                       NULL id_triage_cons_value,
                       NULL title_consent,
                       NULL desc_consent,
                       NULL flg_triage_cons_vs_mand,
                       NULL flg_triage_cons_vs_enab,
                       l_flg_selected_option flg_selected_option,
                       l_triage_color id_triage_color,
                       NULL id_triage_discrim_child,
                       (SELECT epis.id_patient
                          FROM epis_triage et
                          JOIN episode epis
                            ON epis.id_episode = et.id_episode
                         WHERE et.id_epis_triage = i_epis_triage) id_patient,
                       t.flg_critical_look
                  INTO r_option
                  FROM triage t
                  JOIN triage_type tt
                    ON tt.id_triage_type = t.id_triage_type
                  JOIN triage_discriminator td
                    ON td.id_triage_discriminator = t.id_triage_discriminator
                 WHERE t.id_triage = l_triage;
            ELSE
                r_option.id_triage_discriminator   := NULL;
                r_option.desc_triage_discriminator := NULL;
                r_option.id_triage                 := NULL;
                r_option.id_triage_cons_value      := NULL;
                r_option.title_consent             := NULL;
                r_option.desc_consent              := NULL;
                r_option.flg_triage_cons_vs_mand   := NULL;
                r_option.flg_triage_cons_vs_enab   := NULL;
                r_option.flg_selected_option       := l_flg_selected_option;
                r_option.id_triage_color           := l_triage_color;
                r_option.id_triage_discrim_child   := NULL;
                r_option.id_patient                := NULL;
            END IF;
        
            l_tbl_group_options.extend;
            l_tbl_group_options(l_tbl_group_options.count).id_triage_color := r_option.id_triage_color;
        
            l_tbl_options := pk_edis_types.table_options();
            l_tbl_options.extend;
            l_tbl_options(l_tbl_options.count) := get_rec_option(i_option => r_option);
        
            l_tbl_group_options(l_tbl_group_options.count).options := l_tbl_options;
        END IF;
    
        RETURN l_tbl_group_options;
    END get_group_options;

    FUNCTION get_vital_signs
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_epis_triage IN epis_triage.id_triage%TYPE
    ) RETURN pk_edis_types.table_vital_signs IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_VITAL_SIGNS';
        --
        g_decimal_symbol CONSTANT sys_config.id_sys_config%TYPE := 'DECIMAL_SYMBOL';
        --
        l_tbl_vital_signs pk_edis_types.table_vital_signs := pk_edis_types.table_vital_signs();
        l_rec_vital_sign  pk_edis_types.rec_vital_sign;
        --
        CURSOR c_vital_signs(i_decimal_symbol IN VARCHAR2) IS
            SELECT a.id_vital_sign,
                   (SELECT vs.intern_name_vital_sign
                      FROM vital_sign vs
                     WHERE vs.id_vital_sign = a.id_vital_sign) internal_name,
                   a.desc_vital_sign,
                   a.id_unit_measure,
                   a.desc_unit_measure,
                   a.value,
                   a.desc_value,
                   a.id_vs_scales_element,
                   etv.urgency_level,
                   etv.flg_ignore_result
              FROM (SELECT vs.id_vital_sign,
                           pk_translation.get_translation(i_lang, vs.code_vital_sign) desc_vital_sign,
                           nvl(vs_read.id_unit_measure, vsi.id_unit_measure) id_unit_measure,
                           (SELECT pk_translation.get_translation(i_lang, um.code_unit_measure)
                              FROM unit_measure um
                              LEFT JOIN unit_mea_soft_inst umsi
                                ON umsi.id_unit_measure = um.id_unit_measure
                               AND umsi.id_institution = i_prof.institution
                               AND umsi.id_software = i_prof.software
                               AND umsi.flg_available = pk_alert_constant.g_yes
                             WHERE um.id_unit_measure = nvl(vs_read.id_unit_measure, vsi.id_unit_measure)
                               AND um.flg_available = pk_alert_constant.g_yes) desc_unit_measure,
                           decode(vs_read.id_unit_measure,
                                  vsi.id_unit_measure,
                                  vs_read.value,
                                  pk_vital_sign.get_unit_mea_conversion(i_value      => vs_read.value,
                                                                        i_vital_sign => vs_read.id_vital_sign,
                                                                        i_um_origin  => vs_read.id_unit_measure,
                                                                        i_um_dest    => vsi.id_unit_measure)) VALUE,
                           nvl2(vs_read.id_vital_sign_desc,
                                pk_vital_sign.get_vsd_desc(i_lang            => i_lang,
                                                           i_vital_sign_desc => vs_read.id_vital_sign_desc,
                                                           i_patient         => vs_read.id_patient),
                                pk_vital_sign.get_full_value(i_lang        => i_lang,
                                                             i_prof        => i_prof,
                                                             i_vsr         => vs_read.id_vital_sign_read,
                                                             i_vital_sign  => vs_read.id_vital_sign,
                                                             i_value       => nvl(pk_utils.to_str(vs_read.value,
                                                                                                  i_decimal_symbol),
                                                                                  pk_vital_sign.get_vsd_desc(i_lang,
                                                                                                             vs_read.id_vital_sign_desc,
                                                                                                             NULL)),
                                                             i_dt_read     => vs_read.dt_vital_sign_read_tstz,
                                                             i_dt_registry => vs_read.dt_registry) || ' ' ||
                                pk_vital_sign_core.get_um_desc(i_lang, vs_read.id_unit_measure, NULL)) desc_value,
                           vsi.rank,
                           vs_read.id_vs_scales_element
                      FROM vital_sign_read vs_read
                      JOIN vital_sign vs
                        ON vs.id_vital_sign = vs_read.id_vital_sign
                      LEFT JOIN vital_sign_desc vsd
                        ON vsd.id_vital_sign_desc = vs_read.id_vital_sign_desc
                      LEFT JOIN vs_soft_inst vsi
                        ON vsi.id_vital_sign = vs.id_vital_sign
                       AND vsi.id_software = i_prof.software
                       AND vsi.id_institution = i_prof.institution
                       AND vsi.flg_view = pk_edis_triage.g_flg_view_t
                     WHERE vs_read.id_epis_triage = i_epis_triage
                       AND vs_read.id_vital_sign NOT IN
                           (SELECT vr.id_vital_sign_detail
                              FROM vital_sign_relation vr
                             WHERE vr.relation_domain IN (pk_edis_triage.g_vs_rel_conc, pk_edis_triage.g_vs_rel_sum))
                       AND pk_delivery.check_vs_read_from_fetus(vs_read.id_vital_sign_read) = 0
                    UNION ALL -- PRESSÃO ARTERIAL
                    SELECT DISTINCT vs.id_vital_sign,
                                    pk_translation.get_translation(i_lang, vs.code_vital_sign) desc_vital_sign,
                                    vs_read.id_unit_measure,
                                    (SELECT pk_translation.get_translation(i_lang, um.code_unit_measure)
                                       FROM unit_measure um
                                       LEFT JOIN unit_mea_soft_inst umsi
                                         ON umsi.id_unit_measure = um.id_unit_measure
                                        AND umsi.id_institution = i_prof.institution
                                        AND umsi.id_software = i_prof.software
                                      WHERE um.id_unit_measure = vs_read.id_unit_measure) desc_unit_measure,
                                    NULL VALUE,
                                    decode(pk_vital_sign.get_bloodpressure_value(vsre.id_vital_sign_parent,
                                                                                 vs_read.id_patient,
                                                                                 etr.id_episode,
                                                                                 vs_read.dt_vital_sign_read_tstz,
                                                                                 i_decimal_symbol),
                                           '/',
                                           NULL,
                                           pk_vital_sign.get_bloodpressure_value(vsre.id_vital_sign_parent,
                                                                                 vs_read.id_patient,
                                                                                 etr.id_episode,
                                                                                 vs_read.dt_vital_sign_read_tstz,
                                                                                 i_decimal_symbol)) || ' ' ||
                                    pk_vital_sign_core.get_um_desc(i_lang, vs_read.id_unit_measure, NULL) desc_value,
                                    vsi.rank,
                                    NULL id_vs_scales_element
                      FROM vital_sign_read vs_read
                      JOIN vital_sign_relation vsre
                        ON vsre.id_vital_sign_detail = vs_read.id_vital_sign
                       AND vsre.relation_domain = pk_edis_triage.g_vs_rel_conc
                      LEFT JOIN vital_sign vs
                        ON vs.id_vital_sign = vsre.id_vital_sign_parent
                      LEFT JOIN vs_soft_inst vsi
                        ON vsi.id_vital_sign = vsre.id_vital_sign_parent
                       AND vsi.id_software = i_prof.software
                       AND vsi.id_institution = i_prof.institution
                       AND vsi.flg_view = pk_edis_triage.g_flg_view_t
                      JOIN epis_triage etr
                        ON etr.id_epis_triage = vs_read.id_epis_triage
                     WHERE vs_read.id_epis_triage = i_epis_triage
                       AND pk_delivery.check_vs_read_from_fetus(vs_read.id_vital_sign_read) = 0
                    UNION ALL
                    --Grouped vital signs, including GLASGOW TOTAL
                    SELECT d.id_vital_sign,
                           (SELECT pk_translation.get_translation(i_lang, vs.code_vital_sign)
                              FROM vital_sign vs
                             WHERE vs.id_vital_sign = d.id_vital_sign) desc_vital_sign,
                           NULL id_unit_measure,
                           NULL desc_unit_measure,
                           NULL VALUE,
                           decode(d.total_glasgow, NULL, d.desc_value, d.total_glasgow || '; ' || d.desc_value) desc_value,
                           (SELECT vsi.rank
                              FROM vs_soft_inst vsi
                             WHERE vsi.id_vital_sign = d.id_vital_sign
                               AND vsi.id_software = i_prof.software
                               AND vsi.id_institution = i_prof.institution
                               AND vsi.flg_view = pk_edis_triage.g_flg_view_t) rank,
                           NULL id_vs_scales_element
                      FROM (SELECT c.id_vital_sign_parent id_vital_sign,
                                   SUM(c.glasgow_value) total_glasgow,
                                   listagg(c.desc_vital_sign || ': ' || c.desc_value, '; ') within GROUP(ORDER BY c.rank) desc_value
                              FROM (SELECT b.id_vital_sign_parent,
                                           b.id_vital_sign,
                                           (SELECT pk_translation.get_translation(i_lang, vs.code_vital_sign)
                                              FROM vital_sign vs
                                             WHERE vs.id_vital_sign = b.id_vital_sign) desc_vital_sign,
                                           b.rank,
                                           nvl2(b.id_vital_sign_desc,
                                                pk_vital_sign.get_vsd_desc(i_lang            => i_lang,
                                                                           i_vital_sign_desc => b.id_vital_sign_desc,
                                                                           i_patient         => b.id_patient),
                                                pk_vital_sign.get_full_value(i_lang        => i_lang,
                                                                             i_prof        => i_prof,
                                                                             i_vsr         => b.id_vital_sign_read,
                                                                             i_vital_sign  => b.id_vital_sign,
                                                                             i_value       => nvl(pk_utils.to_str(b.value,
                                                                                                                  i_decimal_symbol),
                                                                                                  pk_vital_sign.get_vsd_desc(i_lang,
                                                                                                                             b.id_vital_sign_desc,
                                                                                                                             NULL)),
                                                                             i_dt_read     => b.dt_vital_sign_read_tstz,
                                                                             i_dt_registry => b.dt_registry) || ' ' ||
                                                pk_vital_sign_core.get_um_desc(i_lang,
                                                                               nvl(b.vsr_unit_measure, b.vsi_unit_measure),
                                                                               NULL)) desc_value,
                                           decode(b.relation_domain, pk_alert_constant.g_vs_rel_sum, b.value, NULL) glasgow_value
                                      FROM (SELECT a.*,
                                                   pk_vital_sign.get_vs_relation_domain(i_vital_sign => a.id_vital_sign_parent) relation_domain
                                              FROM (SELECT vsr.id_vital_sign_read,
                                                           vsr.id_vital_sign,
                                                           vsr.id_patient,
                                                           vsr.id_vital_sign_desc,
                                                           nvl(vsr.value,
                                                               (SELECT vsd.value
                                                                  FROM vital_sign_desc vsd
                                                                 WHERE vsd.id_vital_sign_desc = vsr.id_vital_sign_desc)) VALUE,
                                                           vsr.dt_vital_sign_read_tstz,
                                                           vsr.dt_registry,
                                                           vsr.id_unit_measure vsr_unit_measure,
                                                           vsi.id_unit_measure vsi_unit_measure,
                                                           decode(pk_vital_sign.get_vital_sign_type(i_vital_sign => vsr.id_vital_sign),
                                                                  'C',
                                                                  pk_vital_sign.get_vs_parent_triage(i_vital_sign => vsr.id_vital_sign),
                                                                  NULL) id_vital_sign_parent,
                                                           vsi.rank rank
                                                      FROM vital_sign_read vsr
                                                      JOIN vs_soft_inst vsi
                                                        ON vsi.id_vital_sign = vsr.id_vital_sign
                                                       AND vsi.id_software = i_prof.software
                                                       AND vsi.id_institution = i_prof.institution
                                                       AND vsi.flg_view = pk_edis_triage.g_flg_view_t
                                                     WHERE vsr.id_epis_triage = i_epis_triage) a
                                             WHERE pk_vital_sign.get_vs_relation_domain(i_vital_sign => a.id_vital_sign_parent) IN
                                                   (pk_alert_constant.g_vs_rel_group, pk_alert_constant.g_vs_rel_sum)
                                               AND EXISTS (SELECT 1
                                                      FROM vs_soft_inst vsi
                                                     WHERE vsi.id_vital_sign = a.id_vital_sign_parent
                                                       AND vsi.id_software = i_prof.software
                                                       AND vsi.id_institution = i_prof.institution
                                                       AND vsi.flg_view = pk_edis_triage.g_flg_view_t)) b) c
                             GROUP BY c.id_vital_sign_parent) d) a
              LEFT JOIN epis_triage_vs etv
                ON etv.id_epis_triage = i_epis_triage
               AND etv.id_vital_sign = a.id_vital_sign
             ORDER BY a.rank, a.desc_vital_sign;
    
        r_vital_sign c_vital_signs%ROWTYPE;
    BEGIN
        g_error := 'FILL VITAL SIGNS TABLE';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        FOR r_vital_sign IN c_vital_signs(i_decimal_symbol => pk_sysconfig.get_config(i_code_cf => g_decimal_symbol,
                                                                                      i_prof    => i_prof))
        LOOP
            l_rec_vital_sign.id_vital_sign       := r_vital_sign.id_vital_sign;
            l_rec_vital_sign.internal_name       := r_vital_sign.internal_name;
            l_rec_vital_sign.desc_vital_sign     := r_vital_sign.desc_vital_sign;
            l_rec_vital_sign.id_unit_measure     := r_vital_sign.id_unit_measure;
            l_rec_vital_sign.desc_unit_measure   := r_vital_sign.desc_unit_measure;
            l_rec_vital_sign.value               := r_vital_sign.value;
            l_rec_vital_sign.desc_value          := r_vital_sign.desc_value;
            l_rec_vital_sign.id_scales_element   := r_vital_sign.id_vs_scales_element;
            l_rec_vital_sign.urgency_level       := r_vital_sign.urgency_level;
            l_rec_vital_sign.is_to_ignore_result := r_vital_sign.flg_ignore_result;
        
            l_tbl_vital_signs.extend;
            l_tbl_vital_signs(l_tbl_vital_signs.count) := l_rec_vital_sign;
        END LOOP;
    
        RETURN l_tbl_vital_signs;
    END get_vital_signs;

    PROCEDURE add_defining_crit_desc
    (
        i_lang                   IN language.id_language%TYPE,
        i_is_other_def_crit      IN BOOLEAN DEFAULT FALSE,
        io_tbl_defining_criteria IN OUT pk_edis_types.table_defining_criteria
    ) IS
        l_rec_def_crit_desc pk_edis_types.rec_defining_criteria;
        --
        l_code_msg_trg_disc_cons     CONSTANT sys_message.code_message%TYPE := 'TRIAGE_DISC_CONSENT_M001';
        l_triage_disc_without_answer CONSTANT sys_message.code_message%TYPE := 'TRIAGE_DISC_WITHOUT_ANS';
    
        l_desc_msg_trg_disc_cons  sys_message.desc_message%TYPE;
        l_desc_without_answer     sys_message.desc_message%TYPE;
        l_desc_consent_permission sys_message.desc_message%TYPE;
        l_desc_msg_consent        sys_message.desc_message%TYPE;
        l_desc_msg_separator      VARCHAR2(3) := '; (';
    
    BEGIN
        IF io_tbl_defining_criteria.count > 0
        THEN
            FOR i IN io_tbl_defining_criteria.first .. io_tbl_defining_criteria.last
            LOOP
                l_rec_def_crit_desc := io_tbl_defining_criteria(i);
            
                IF l_rec_def_crit_desc.id_triage_discriminator IS NULL
                THEN
                    l_rec_def_crit_desc.desc_criteria := pk_message.get_message(i_lang      => i_lang,
                                                                                i_code_mess => g_code_msg_not_applicable);
                ELSE
                    IF (l_rec_def_crit_desc.discrim_answer = pk_alert_constant.g_yes)
                       AND l_rec_def_crit_desc.child_criteria.id_triage_discriminator IS NULL
                    THEN
                        SELECT pk_translation.get_translation(i_lang      => i_lang,
                                                              i_code_mess => td.code_triage_discriminator)
                          INTO l_rec_def_crit_desc.desc_criteria
                          FROM triage_discriminator td
                         WHERE td.id_triage_discriminator = l_rec_def_crit_desc.id_triage_discriminator;
                    ELSE
                        SELECT pk_translation.get_translation(i_lang => i_lang, i_code_mess => td.code_discrim_question)
                          INTO l_rec_def_crit_desc.desc_criteria
                          FROM triage_discriminator td
                         WHERE td.id_triage_discriminator = l_rec_def_crit_desc.id_triage_discriminator;
                    END IF;
                
                    --START
                    --only get in this statement one turn
                    IF l_rec_def_crit_desc.id_triage_cons_value IS NOT NULL
                       AND l_desc_msg_trg_disc_cons IS NULL
                    THEN
                        l_desc_msg_trg_disc_cons := pk_message.get_message(i_lang      => i_lang,
                                                                           i_code_mess => l_code_msg_trg_disc_cons);
                    END IF;
                
                    IF l_rec_def_crit_desc.discrim_answer IS NULL
                       AND l_desc_without_answer IS NULL
                    THEN
                        l_desc_without_answer := pk_message.get_message(i_lang      => i_lang,
                                                                        i_code_mess => l_triage_disc_without_answer);
                    END IF;
                    IF l_rec_def_crit_desc.id_triage_cons_value IS NOT NULL
                    THEN
                        BEGIN
                            SELECT pk_translation.get_translation(i_lang, tcv.code_triage_cons_value) desc_triage_cons_value
                              INTO l_desc_consent_permission
                              FROM triage_cons_value tcv
                             WHERE tcv.id_triage_cons_value = l_rec_def_crit_desc.id_triage_cons_value;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_desc_consent_permission := NULL;
                        END;
                    END IF;
                    l_rec_def_crit_desc.desc_discrim_answer := NULL;
                    -- 
                    IF i_is_other_def_crit
                    THEN
                        l_rec_def_crit_desc.desc_discrim_answer := pk_sysdomain.get_domain(i_code_dom => g_code_domain_yes_no,
                                                                                           i_val      => l_rec_def_crit_desc.discrim_answer,
                                                                                           i_lang     => i_lang);
                    
                    ELSE
                        IF l_rec_def_crit_desc.discrim_answer = pk_alert_constant.g_no
                           OR (l_rec_def_crit_desc.discrim_answer = pk_alert_constant.g_yes AND
                           l_rec_def_crit_desc.child_criteria.id_triage_discriminator IS NOT NULL)
                        THEN
                            --get No/Yes
                            l_rec_def_crit_desc.desc_discrim_answer := pk_sysdomain.get_domain(i_code_dom => g_code_domain_yes_no,
                                                                                               i_val      => l_rec_def_crit_desc.discrim_answer,
                                                                                               i_lang     => i_lang);
                        END IF;
                    END IF;
                
                    --First IF condition only for Manchester Triage
                    IF l_rec_def_crit_desc.id_triage_cons_value IS NOT NULL
                    THEN
                        IF l_rec_def_crit_desc.desc_discrim_answer IS NULL
                           AND l_rec_def_crit_desc.discrim_answer IS NULL
                        THEN
                            l_desc_msg_consent := l_desc_without_answer || l_desc_msg_separator;
                        ELSIF l_rec_def_crit_desc.discrim_answer = pk_alert_constant.g_yes
                              AND l_rec_def_crit_desc.child_criteria.id_triage_discriminator IS NULL
                        THEN
                            l_desc_msg_consent := '(';
                        ELSE
                            l_desc_msg_consent := l_desc_msg_separator;
                        END IF;
                    
                        l_desc_msg_consent := l_desc_msg_consent || l_desc_msg_trg_disc_cons || ': ' ||
                                              l_desc_consent_permission || ')';
                    ELSE
                    
                        IF l_rec_def_crit_desc.child_criteria.flg_accepted_option = pk_alert_constant.g_yes
                           AND l_rec_def_crit_desc.child_criteria.id_triage_discriminator IS NOT NULL
                        THEN
                            l_rec_def_crit_desc.child_criteria.desc_accepted_option := NULL;
                        END IF;
                    
                        l_desc_msg_consent := NULL;
                    END IF;
                
                    l_rec_def_crit_desc.desc_discrim_answer := l_rec_def_crit_desc.desc_discrim_answer ||
                                                               l_desc_msg_consent;
                    --END
                END IF;
            
                io_tbl_defining_criteria(i) := l_rec_def_crit_desc;
            END LOOP;
        ELSIF NOT i_is_other_def_crit
        THEN
            l_rec_def_crit_desc.desc_criteria := pk_message.get_message(i_lang      => i_lang,
                                                                        i_code_mess => g_code_msg_not_applicable);
        
            io_tbl_defining_criteria.extend;
            io_tbl_defining_criteria(io_tbl_defining_criteria.count) := l_rec_def_crit_desc;
        END IF;
    END add_defining_crit_desc;

    FUNCTION get_defining_criteria
    (
        i_lang            IN language.id_language%TYPE,
        i_tbl_grp_options IN pk_edis_types.table_group_options,
        i_tbl_vital_signs IN pk_edis_types.table_vital_signs,
        i_triage_type     IN triage_type.id_triage_type%TYPE
    ) RETURN pk_edis_types.table_defining_criteria IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DEFINING_CRITERIA';
        --
        l_rec_grp_option   pk_edis_types.rec_group_option;
        l_rec_option       pk_edis_types.rec_option;
        l_rec_child_option pk_edis_types.rec_discrim_child;
        --
        l_has_a_yes_answer          BOOLEAN := FALSE;
        l_has_a_yes_answer_critical BOOLEAN := FALSE;
        l_all_answers_are_no        BOOLEAN := TRUE;
        --
        l_rec_defining_criteria pk_edis_types.rec_defining_criteria;
        l_tbl_defining_criteria pk_edis_types.table_defining_criteria := pk_edis_types.table_defining_criteria();
        --
        l_higher_vs_urgency_level triage_esi_level.esi_level%TYPE := g_est_min_vs_level;
        l_flg_critical_look       VARCHAR2(1 CHAR) := pk_alert_constant.g_yes;
        --
        --Remove from io_tbl_defining_criteria table all answers not equal to i_discrim_answer
        --This function only makes sure if we have only one answer that gives the triage emergency level
        PROCEDURE remove_defining_crit(io_tbl_defining_criteria IN OUT pk_edis_types.table_defining_criteria) IS
            l_tbl_final pk_edis_types.table_defining_criteria := pk_edis_types.table_defining_criteria();
        BEGIN
            --The last answer is the defining criteria, just return it
            l_tbl_final.extend;
            l_tbl_final(l_tbl_final.count) := io_tbl_defining_criteria(io_tbl_defining_criteria.count);
        
            io_tbl_defining_criteria := l_tbl_final;
        END remove_defining_crit;
    
    BEGIN
        IF i_tbl_grp_options.exists(1)
        THEN
            FOR i IN i_tbl_grp_options.first .. i_tbl_grp_options.last
            LOOP
                l_rec_grp_option := i_tbl_grp_options(i);
            
                IF l_rec_grp_option.options IS NOT NULL
                   AND l_rec_grp_option.options.count > 0
                THEN
                    FOR j IN l_rec_grp_option.options.first .. l_rec_grp_option.options.last
                    LOOP
                        l_rec_option       := l_rec_grp_option.options(j);
                        l_rec_child_option := l_rec_option.child_option;
                    
                        IF l_rec_option.flg_selected_option IS NOT NULL
                           OR l_rec_child_option.id_triage_discriminator IS NOT NULL
                        THEN
                            --This means that it's a triage defining criteria
                            l_rec_defining_criteria.id_triage               := l_rec_option.id_triage;
                            l_rec_defining_criteria.id_triage_cons_value    := l_rec_option.id_triage_cons_value;
                            l_rec_defining_criteria.flg_reassess            := l_rec_option.flg_reassess;
                            l_rec_defining_criteria.id_triage_discriminator := l_rec_option.id_triage_discriminator;
                            l_rec_defining_criteria.discrim_answer          := l_rec_option.flg_selected_option;
                            l_rec_defining_criteria.child_criteria          := NULL; --Reset variable
                            l_rec_defining_criteria.flg_critical_look       := l_rec_option.flg_critical_look;
                            IF l_rec_option.flg_critical_look = pk_alert_constant.g_yes
                            THEN
                                l_flg_critical_look := pk_alert_constant.g_yes;
                                BEGIN
                                    SELECT t.box
                                      INTO l_rec_defining_criteria.box
                                      FROM triage t
                                     WHERE id_triage = l_rec_option.id_triage;
                                EXCEPTION
                                    WHEN OTHERS THEN
                                        NULL;
                                END;
                            ELSE
                                l_rec_defining_criteria.box := NULL;
                            END IF;
                            IF l_rec_child_option.id_triage_discriminator IS NOT NULL
                            THEN
                                l_rec_defining_criteria.child_criteria := l_rec_child_option;
                            
                                --The field flg_select_option of the child discriminator is the correct answer to the parent discrim
                                l_rec_defining_criteria.discrim_answer := l_rec_child_option.flg_select_option;
                            END IF;
                            IF i_triage_type NOT IN (g_triage_id_ctas_p, g_triage_id_ctas_a)
                               OR (i_triage_type IN (g_triage_id_ctas_p, g_triage_id_ctas_a) AND
                               l_rec_defining_criteria.discrim_answer = pk_alert_constant.g_yes)
                            THEN
                                l_has_a_yes_answer_critical := TRUE;
                                l_tbl_defining_criteria.extend;
                                l_tbl_defining_criteria(l_tbl_defining_criteria.count) := l_rec_defining_criteria;
                            END IF;
                        END IF;
                    
                        IF l_all_answers_are_no
                           AND nvl(l_rec_option.flg_selected_option, pk_alert_constant.g_yes) != pk_alert_constant.g_no
                        THEN
                            l_all_answers_are_no := FALSE;
                        END IF;
                    
                        IF l_rec_option.flg_selected_option = pk_alert_constant.g_yes
                           AND nvl(l_rec_child_option.flg_accuity_confirmation, pk_alert_constant.g_yes) =
                           pk_alert_constant.g_yes
                           OR (l_rec_child_option.id_triage_discriminator IS NOT NULL AND
                           l_rec_child_option.flg_accuity_confirmation = pk_alert_constant.g_yes AND
                           l_rec_child_option.flg_select_option = pk_alert_constant.g_yes)
                        
                        THEN
                            --An YES answer to one discriminator sets the urgency level
                            --Only one YES is allowed
                        
                            IF nvl(l_rec_option.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                            THEN
                                l_has_a_yes_answer := TRUE;
                                EXIT;
                            END IF;
                        END IF;
                    END LOOP;
                END IF;
            
                IF l_has_a_yes_answer
                   AND nvl(l_rec_option.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                THEN
                    EXIT;
                END IF;
            END LOOP;
        END IF;
    
        IF l_has_a_yes_answer
           OR l_has_a_yes_answer_critical
        
        THEN
            IF i_triage_type NOT IN (g_triage_id_ctas_p, g_triage_id_ctas_a)
            THEN
                g_error := 'CALL REMOVE_DEFINING_CRIT - RETURN YES CRIT';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                remove_defining_crit(io_tbl_defining_criteria => l_tbl_defining_criteria);
            
            END IF;
        ELSIF l_all_answers_are_no
        THEN
            IF i_triage_type IS NULL
               OR i_triage_type != pk_edis_triage.g_triage_id_est
            THEN
                l_tbl_defining_criteria := pk_edis_types.table_defining_criteria();
            END IF;
        ELSE
            l_tbl_defining_criteria := pk_edis_types.table_defining_criteria();
        END IF;
    
        IF i_triage_type = pk_edis_triage.g_triage_id_est
           AND l_tbl_defining_criteria.count = 0
           AND i_tbl_vital_signs.exists(1)
        THEN
            g_error := 'GET HIGHER_VS_URGENCY_LEVEL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR i IN i_tbl_vital_signs.first .. i_tbl_vital_signs.last
            LOOP
                IF i_tbl_vital_signs(i).urgency_level < l_higher_vs_urgency_level
                THEN
                    l_higher_vs_urgency_level := i_tbl_vital_signs(i).urgency_level;
                END IF;
            END LOOP;
        
            g_error := 'ADD VS AS DEF_CRIT WHICH URGENCY_LEVEL = ' || l_higher_vs_urgency_level;
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR i IN i_tbl_vital_signs.first .. i_tbl_vital_signs.last
            LOOP
                IF i_tbl_vital_signs(i).urgency_level = l_higher_vs_urgency_level
                THEN
                    l_tbl_defining_criteria.extend;
                    l_tbl_defining_criteria(l_tbl_defining_criteria.count).desc_criteria := i_tbl_vital_signs(i).desc_vital_sign || ': ' || i_tbl_vital_signs(i).desc_value;
                END IF;
            END LOOP;
        ELSE
            g_error := 'CALL ADD_DEFINING_CRIT_DESC';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            add_defining_crit_desc(i_lang => i_lang, io_tbl_defining_criteria => l_tbl_defining_criteria);
        END IF;
    
        RETURN l_tbl_defining_criteria;
    END get_defining_criteria;

    FUNCTION get_defining_criteria_str
    (
        i_lang                  IN language.id_language%TYPE,
        i_tbl_defining_criteria IN pk_edis_types.table_defining_criteria,
        i_prefix                IN VARCHAR2 DEFAULT NULL,
        i_has_critical_look     IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        i_critical_look_str     IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DEFINING_CRITERIA_STR';
        --
        l_rec_defining_criteria pk_edis_types.rec_defining_criteria;
        --
        l_ret pk_translation.t_desc_translation;
    
        PROCEDURE concat_value
        (
            i_new_value IN VARCHAR2,
            i_count     IN NUMBER,
            i_max_count IN NUMBER
        ) IS
        BEGIN
            l_ret := l_ret || i_prefix || i_new_value;
        
            IF i_count < i_max_count
            THEN
                -- if it's not the last criteria, adds a line break
                l_ret := l_ret || chr(10);
            END IF;
        
        END concat_value;
    BEGIN
        g_error := 'CONCATENATE ALL DEFINING CRITERIAS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
    
        IF i_critical_look_str IS NOT NULL
        THEN
            concat_value(i_critical_look_str, 1, 2);
        END IF;
        IF i_tbl_defining_criteria.exists(1)
        THEN
            FOR i IN i_tbl_defining_criteria.first .. i_tbl_defining_criteria.last
            LOOP
                IF nvl(i_tbl_defining_criteria(i).flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                   AND i_has_critical_look = pk_alert_constant.g_no
                THEN
                    IF i_tbl_defining_criteria(i).discrim_answer = g_yes
                    THEN
                        -- If it receives a child, concatenates the child, if not, shows the parent
                        IF i_tbl_defining_criteria(i).child_criteria.id_triage IS NOT NULL
                        THEN
                            concat_value(i_tbl_defining_criteria(i).desc_criteria || chr(32) || i_tbl_defining_criteria(i).desc_discrim_answer || ': ' || i_tbl_defining_criteria(i).child_criteria.desc_discriminator,
                                         i,
                                         i_tbl_defining_criteria.count);
                        ELSE
                        
                            concat_value(i_tbl_defining_criteria(i).desc_criteria || chr(32) || i_tbl_defining_criteria(i).desc_discrim_answer,
                                         i,
                                         i_tbl_defining_criteria.count);
                        END IF;
                    ELSIF i_tbl_defining_criteria(i).discrim_answer = g_no
                    THEN
                        -- if it is a No answer and there is only 1
                        IF i_tbl_defining_criteria(i).child_criteria.id_triage IS NOT NULL
                        THEN
                            -- if it receives a child, shows the child and the parent
                            concat_value(i_tbl_defining_criteria(i).desc_criteria || chr(32) || i_tbl_defining_criteria(i).desc_discrim_answer || ': ' || i_tbl_defining_criteria(i).child_criteria.desc_discriminator,
                                         i,
                                         i_tbl_defining_criteria.count);
                        ELSE
                            concat_value(i_tbl_defining_criteria(i).desc_criteria || chr(32) || i_tbl_defining_criteria(i).desc_discrim_answer,
                                         i,
                                         i_tbl_defining_criteria.count);
                        END IF;
                    ELSE
                        -- the other possible situation is when there are several No answers, in this case these
                        concat_value(i_tbl_defining_criteria(i).desc_criteria || chr(32) || i_tbl_defining_criteria(i).desc_discrim_answer,
                                     i,
                                     i_tbl_defining_criteria.count);
                    END IF;
                END IF;
            END LOOP;
        ELSE
            l_ret := '';
        END IF;
    
        RETURN l_ret;
    END get_defining_criteria_str;

    FUNCTION get_defining_criteria_str
    (
        i_lang            IN language.id_language%TYPE,
        i_tbl_grp_options IN pk_edis_types.table_group_options,
        i_tbl_vital_signs IN pk_edis_types.table_vital_signs,
        i_triage_type     IN triage_type.id_triage_type%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DEFINING_CRITERIA_STR';
        --
        l_tbl_defining_criteria pk_edis_types.table_defining_criteria;
    BEGIN
        g_error := 'CALL GET_DEFINING_CRITERIA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_tbl_defining_criteria := get_defining_criteria(i_lang            => i_lang,
                                                         i_tbl_grp_options => i_tbl_grp_options,
                                                         i_tbl_vital_signs => i_tbl_vital_signs,
                                                         i_triage_type     => i_triage_type);
    
        g_error := 'CALL GET_DEFINING_CRITERIA_STR';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        RETURN get_defining_criteria_str(i_lang => i_lang, i_tbl_defining_criteria => l_tbl_defining_criteria);
    END get_defining_criteria_str;

    FUNCTION get_defining_criteria_str
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_epis_triage IN epis_triage.id_epis_triage%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_DEFINING_CRITERIA_STR';
        --
        l_tbl_grp_options pk_edis_types.table_group_options;
        l_tbl_vital_signs pk_edis_types.table_vital_signs;
        l_triage_type     triage_type.id_triage_type%TYPE;
    BEGIN
        g_error := 'CALL GET_GROUP_OPTIONS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_tbl_grp_options := get_group_options(i_lang => i_lang, i_prof => i_prof, i_epis_triage => i_epis_triage);
    
        g_error := 'CALL GET_VITAL_SIGNS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_tbl_vital_signs := get_vital_signs(i_lang => i_lang, i_prof => i_prof, i_epis_triage => i_epis_triage);
    
        g_error := 'GET TRIAGE_TYPE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        BEGIN
            SELECT tc.id_triage_type
              INTO l_triage_type
              FROM epis_triage et
              JOIN triage_color tc
                ON tc.id_triage_color = et.id_triage_color
             WHERE et.id_epis_triage = i_epis_triage;
        EXCEPTION
            WHEN no_data_found THEN
                l_triage_type := NULL;
        END;
    
        g_error := 'CALL GET_DEFINING_CRITERIA_STR';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        RETURN get_defining_criteria_str(i_lang            => i_lang,
                                         i_tbl_grp_options => l_tbl_grp_options,
                                         i_tbl_vital_signs => l_tbl_vital_signs,
                                         i_triage_type     => l_triage_type);
    END get_defining_criteria_str;

    FUNCTION get_other_def_criteria
    (
        i_lang                   IN language.id_language%TYPE,
        i_tbl_grp_options        IN pk_edis_types.table_group_options,
        i_tbl_defining_criterias IN pk_edis_types.table_defining_criteria
    ) RETURN pk_edis_types.table_defining_criteria IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_OTHER_DEF_CRITERIA';
        --
        l_rec_group_option pk_edis_types.rec_group_option;
        l_rec_option       pk_edis_types.rec_option;
        --
        l_rec_other_def_crit pk_edis_types.rec_defining_criteria;
        l_tbl_other_def_crit pk_edis_types.table_defining_criteria := pk_edis_types.table_defining_criteria();
        --
        FUNCTION is_def_criteria(i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE)
            RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'IS_DEF_CRITERIA';
            --
            l_rec_def_crit pk_edis_types.rec_defining_criteria;
            --
            l_ret BOOLEAN := FALSE;
        BEGIN
            IF i_tbl_defining_criterias IS NOT NULL
               AND i_tbl_defining_criterias.count > 0
            THEN
                g_error := 'LOOP THROUGH DEFINIG CRITERIAS';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name,
                                      text            => g_error);
                FOR i IN i_tbl_defining_criterias.first .. i_tbl_defining_criterias.last
                LOOP
                    l_rec_def_crit := i_tbl_defining_criterias(i);
                
                    IF l_rec_def_crit.id_triage_discriminator = i_triage_discriminator
                    THEN
                        l_ret := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        
            RETURN l_ret;
        END is_def_criteria;
    BEGIN
        IF i_tbl_grp_options IS NOT NULL
           AND i_tbl_grp_options.count > 0
        THEN
            g_error := 'LOOP THROUGH GROUP OPTIONS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR i IN i_tbl_grp_options.first .. i_tbl_grp_options.last
            LOOP
                l_rec_group_option := i_tbl_grp_options(i);
            
                IF l_rec_group_option.options IS NOT NULL
                   AND l_rec_group_option.options.count > 0
                THEN
                    g_error := 'LOOP THROUGH OPTIONS';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_func_name,
                                          text            => g_error);
                    FOR j IN l_rec_group_option.options.first .. l_rec_group_option.options.last
                    LOOP
                        l_rec_option := l_rec_group_option.options(j);
                    
                        IF (l_rec_option.flg_selected_option IS NOT NULL AND
                           NOT is_def_criteria(i_triage_discriminator => l_rec_option.id_triage_discriminator))
                           OR
                           (l_rec_option.flg_selected_option IS NULL AND l_rec_option.id_triage_cons_value IS NOT NULL)
                        THEN
                            g_error := 'ADD OTHER DEFINING CRITERIA';
                            pk_alertlog.log_debug(object_name     => g_package_name,
                                                  sub_object_name => l_func_name,
                                                  text            => g_error);
                            l_rec_other_def_crit.id_triage               := l_rec_option.id_triage;
                            l_rec_other_def_crit.id_triage_cons_value    := l_rec_option.id_triage_cons_value;
                            l_rec_other_def_crit.flg_reassess            := l_rec_option.flg_reassess;
                            l_rec_other_def_crit.id_triage_discriminator := l_rec_option.id_triage_discriminator;
                            l_rec_other_def_crit.discrim_answer          := l_rec_option.flg_selected_option;
                            l_rec_other_def_crit.child_criteria          := l_rec_option.child_option;
                            l_rec_other_def_crit.flg_critical_look       := l_rec_option.flg_critical_look;
                            IF l_rec_option.flg_critical_look = pk_alert_constant.g_yes
                            THEN
                                BEGIN
                                    SELECT t.box
                                      INTO l_rec_other_def_crit.box
                                      FROM triage t
                                     WHERE id_triage = l_rec_option.id_triage;
                                EXCEPTION
                                    WHEN OTHERS THEN
                                        NULL;
                                END;
                            END IF;
                            l_tbl_other_def_crit.extend;
                            l_tbl_other_def_crit(l_tbl_other_def_crit.count) := l_rec_other_def_crit;
                        END IF;
                    END LOOP;
                END IF;
            END LOOP;
        END IF;
    
        g_error := 'CALL ADD_DEFINING_CRIT_DESC - OTHER CRITERIAS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        add_defining_crit_desc(i_lang                   => i_lang,
                               i_is_other_def_crit      => TRUE,
                               io_tbl_defining_criteria => l_tbl_other_def_crit);
    
        RETURN l_tbl_other_def_crit;
    END get_other_def_criteria;

    FUNCTION get_triage_svd_data
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_epis_triage IN epis_triage.id_epis_triage%TYPE,
        i_flg_call    IN VARCHAR2 DEFAULT pk_edis_hist.g_call_detail,
        o_triage      OUT pk_edis_types.rec_triage,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_TRIAGE_SVD_DATA';
        --
        CURSOR c_epis_triage IS
            SELECT (SELECT epis.id_patient
                      FROM episode epis
                     WHERE epis.id_episode = et.id_episode) id_patient,
                   et.id_episode,
                   nvl(et.id_triage_board, t.id_triage_board) id_triage_board,
                   pk_edis_triage.get_board_label(i_lang,
                                                  i_prof,
                                                  nvl(et.id_triage_board, t.id_triage_board),
                                                  td.id_triage_decision_point,
                                                  t.id_triage_type) desc_triage_board,
                   decode(et.id_triage_white_reason, NULL, tc.id_triage_type) id_triage_type,
                   decode(et.id_triage_white_reason,
                          NULL,
                          (SELECT pk_translation.get_translation(i_lang, tt.code_triage_type)
                             FROM triage_type tt
                            WHERE tt.id_triage_type = t.id_triage_type)) desc_triage_type,
                   et.id_triage_color,
                   et.id_triage_white_reason,
                   (SELECT pk_translation.get_translation(i_lang, twr.code_triage_white_reason)
                      FROM triage_white_reason twr
                     WHERE twr.id_triage_white_reason = et.id_triage_white_reason) desc_white_reason,
                   et.id_transp_entity,
                   (SELECT pk_translation.get_translation(i_lang, te.code_transp_entity)
                      FROM transp_entity te
                     WHERE te.id_transp_entity = et.id_transp_entity) desc_transport,
                   decode(nvl(et.id_triage_color_orig, et.id_triage_color),
                          et.id_triage_color,
                          pk_alert_constant.g_no,
                          pk_alert_constant.g_yes) flg_changed_color,
                   (extract(DAY FROM(et.dt_end_tstz - et.dt_begin_tstz)) * 86400 +
                   extract(hour FROM(et.dt_end_tstz - et.dt_begin_tstz)) * 3600 +
                   extract(minute FROM(et.dt_end_tstz - et.dt_begin_tstz)) * 60 +
                   extract(SECOND FROM(et.dt_end_tstz - et.dt_begin_tstz)) * 1000) triage_duration,
                   et.flg_letter,
                   decode(et.flg_letter,
                          NULL,
                          NULL,
                          pk_sysdomain.get_domain(g_code_domain_yes_no, et.flg_letter, i_lang)) desc_letter,
                   et.notes,
                   (SELECT pk_string_utils.clob_to_sqlvarchar2(ea.desc_epis_anamnesis)
                      FROM epis_anamnesis ea
                     WHERE ea.id_epis_anamnesis = et.id_epis_anamnesis) chief_complaint,
                   et.emergency_contact,
                   et.treatment,
                   et.id_necessity,
                   et.id_triage,
                   et.flg_selected_option,
                   et.initial_notes,
                   et.accident_desc,
                   --origin
                   et.id_origin,
                   (SELECT pk_translation.get_translation(i_lang, ori.code_origin)
                      FROM origin ori
                     WHERE ori.id_origin = et.id_origin) desc_origin,
                   et.desc_origin desc_origin_ft,
                   --pregnant
                   et.flg_pregnant,
                   et.preg_weeks pregnancy_weeks,
                   et.flg_postpartum,
                   pk_translation.get_translation(i_lang, tc.code_triage_color) ||
                   decode(tcg.flg_type, g_no, NULL, ' - ' || pk_translation.get_translation(i_lang, tc.code_accuity)) ||
                   nvl2(et.id_triage_color_orig,
                        chr(10) || '(' || REPLACE(REPLACE(pk_message.get_message(i_lang, 'TRIAGE_T047'),
                                                          '@1',
                                                          pk_edis_triage.get_triage_color_orig(i_lang,
                                                                                               i_prof,
                                                                                               g_type_color_value,
                                                                                               tc.id_triage_type,
                                                                                               et.id_triage_color_orig,
                                                                                               'S')),
                                                  '@2',
                                                  pk_edis_triage.get_triage_color_orig(i_lang,
                                                                                       i_prof,
                                                                                       g_type_color_value,
                                                                                       tc.id_triage_type,
                                                                                       et.id_triage_color,
                                                                                       'S')) || ')',
                        NULL) desc_triage_color,
                   et.id_transportation,
                   et.flg_under_two_years,
                   et.flg_immobile,
                   et.flg_unexplained_injury,
                   et.flg_protection_plan,
                   et.flg_attendance_delay,
                   et.flg_domestic_abuse,
                   et.flg_possible_injury,
                   et.flg_has_social_work,
                   et.social_work_name,
                   et.social_work_address,
                   et.flg_social_services,
                   et.social_reason,
                   et.flg_consent_social,
                   et.flg_info_sharing,
                   et.dt_social_contact,
                   et.social_info_received,
                   et.flg_signs_abuse,
                   et.flg_critical_look,
                   decode(g_triage.id_triage_type,
                          g_triage_id_ctas_p,
                          pk_message.get_message(i_lang, 'TRIAGE_CTAS_T003'),
                          g_triage_id_ctas_a,
                          pk_message.get_message(i_lang, 'TRIAGE_CTAS_T0034'),
                          NULL) desc_critical,
                   pk_utils.concatenate_list(CURSOR
                                             (SELECT pk_translation.get_translation(i_lang, tb.code_triage_board) || ': ' || aux
                                                FROM triage_board tb
                                                JOIN (SELECT t.id_triage_board,
                                                            listagg(pk_translation.get_translation(i_lang,
                                                                                                   td.code_triage_discriminator),
                                                                    ',') within GROUP(ORDER BY t.rank) aux
                                                       FROM epis_triage_option eto
                                                       JOIN triage t
                                                         ON eto.id_triage = t.id_triage
                                                       JOIN triage_discriminator td
                                                         ON t.id_triage_discriminator = td.id_triage_discriminator
                                                      WHERE eto.id_epis_triage = i_epis_triage
                                                        AND eto.flg_selected_option = pk_alert_constant.g_yes
                                                        AND t.flg_critical_look = pk_alert_constant.g_yes
                                                      GROUP BY t.id_triage_board) t
                                                  ON tb.id_triage_board = t.id_triage_board),
                                             chr(10)) critical_look_description
              FROM epis_triage et
              LEFT JOIN triage t
                ON t.id_triage = et.id_triage
              LEFT JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
              LEFT JOIN triage_color tc
                ON tc.id_triage_color = et.id_triage_color
              LEFT JOIN triage_color_group tcg
                ON tcg.id_triage_color_group = tc.id_triage_color_group
             WHERE et.id_epis_triage = i_epis_triage;
    
        r_epis_triage c_epis_triage%ROWTYPE;
    
        FUNCTION get_needs(i_id_necessity IN necessity.id_necessity%TYPE) RETURN pk_edis_types.table_needs IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_NEEDS';
            --
            l_tbl_needs pk_edis_types.table_needs := pk_edis_types.table_needs();
            l_rec_need  pk_edis_types.rec_need;
        BEGIN
            IF i_id_necessity IS NOT NULL -- Support for old data, when the needs were registered in EPIS_TRIAGE
            THEN
                g_error := 'GET NECESSITY (OLD)';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name);
                SELECT n.id_necessity, pk_translation.get_translation(i_lang, n.code_necessity) desc_necessity
                  INTO l_rec_need.id_necessity, l_rec_need.desc_necessity
                  FROM necessity n
                 WHERE n.id_necessity = i_id_necessity;
            
                l_tbl_needs.extend;
                l_tbl_needs(l_tbl_needs.count) := l_rec_need;
            ELSE
                g_error := 'GET NECESSITY (NEW)';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name);
                FOR r_need IN (SELECT n.id_necessity,
                                      pk_translation.get_translation(i_lang, n.code_necessity) desc_necessity,
                                      pn.flg_status
                                 FROM epis_triage_pat_necessity etpn
                                 JOIN pat_necessity pn
                                   ON pn.id_pat_necessity = etpn.id_pat_necessity
                                 JOIN necessity n
                                   ON n.id_necessity = pn.id_necessity
                                WHERE etpn.id_epis_triage = i_epis_triage)
                LOOP
                    l_rec_need.id_necessity   := r_need.id_necessity;
                    l_rec_need.desc_necessity := r_need.desc_necessity;
                    l_rec_need.flg_status     := r_need.flg_status;
                
                    l_tbl_needs.extend;
                    l_tbl_needs(l_tbl_needs.count) := l_rec_need;
                END LOOP;
            END IF;
        
            RETURN l_tbl_needs;
        END get_needs;
    
        FUNCTION get_fast_track RETURN pk_edis_types.table_fast_track IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_FAST_TRACK';
            --
            l_rec_fast_track pk_edis_types.rec_fast_track;
            l_ret            pk_edis_types.table_fast_track := pk_edis_types.table_fast_track();
            CURSOR c_fast_track IS
                SELECT eft.id_fast_track,
                       pk_fast_track.get_fast_track_desc(i_lang            => i_lang,
                                                         i_fast_track_hist => eft.id_epis_fast_track_hist) desc_fast_track,
                       eft.flg_activation_type,
                       eft.flg_type,
                       pk_sysdomain.get_domain('EPIS_FAST_TRACK.FLG_TYPE', eft.flg_type, i_lang) desc_flg_type,
                       flg_status,
                       eft.id_epis_fast_track_hist,
                       decode(eft.flg_status,
                              pk_fast_track.g_fast_track_active,
                              eft.notes_enable,
                              pk_fast_track.g_fast_track_confirm, -- EMR-4797
                              eft.notes_enable,
                              eft.notes_disable) notes,
                       nvl(pk_fast_track.get_disable_desc(i_lang, i_prof, eft.id_fast_track_disable),
                           pk_fast_track.get_fast_track_reasons(i_lang,
                                                                i_prof,
                                                                eft.id_epis_fast_track_hist,
                                                                decode(eft.flg_status,
                                                                       pk_fast_track.g_fast_track_active,
                                                                       pk_fast_track.g_fast_track_reason_active,
                                                                       pk_fast_track.g_fast_track_confirm, -- EMR-4797
                                                                       pk_fast_track.g_fast_track_reason_active,
                                                                       pk_fast_track.g_fast_track_reason_cancel))) reason,
                       
                       decode(eft.flg_status,
                              pk_fast_track.g_fast_track_active,
                              eft.id_prof_enable,
                              pk_fast_track.g_fast_track_confirm, -- EMR-4797
                              eft.id_prof_enable,
                              eft.id_prof_disable) id_professional,
                       decode(eft.flg_status,
                              pk_fast_track.g_fast_track_active,
                              eft.dt_enable,
                              pk_fast_track.g_fast_track_confirm, -- EMR-4797
                              eft.dt_activation,
                              eft.dt_disable) fast_track_date,
                       eft.dt_activation dt_activation -- EMR-4797  
                  FROM epis_fast_track_hist eft
                 WHERE eft.id_epis_triage = i_epis_triage
                 ORDER BY eft.id_epis_fast_track_hist DESC, --eft.dt_enable DESC --
                          eft.dt_disable;
            -- EMR-4797
        
            r_fast_track c_fast_track%ROWTYPE;
        BEGIN
            g_error := 'FILL FAST TRACK RECORD';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_func_name);
        
            FOR r_fast_track IN c_fast_track
            LOOP
                l_rec_fast_track.id_fast_track           := r_fast_track.id_fast_track;
                l_rec_fast_track.desc_fast_track         := r_fast_track.desc_fast_track;
                l_rec_fast_track.flg_activation_type     := r_fast_track.flg_activation_type;
                l_rec_fast_track.flg_type                := r_fast_track.flg_type;
                l_rec_fast_track.desc_flg_type           := r_fast_track.desc_flg_type;
                l_rec_fast_track.flg_status              := r_fast_track.flg_status;
                l_rec_fast_track.id_epis_fast_track_hist := r_fast_track.id_epis_fast_track_hist;
                l_rec_fast_track.notes                   := r_fast_track.notes;
                l_rec_fast_track.id_professional         := r_fast_track.id_professional;
                l_rec_fast_track.fast_track_date         := r_fast_track.fast_track_date;
                l_rec_fast_track.reason                  := r_fast_track.reason;
            
                l_ret.extend;
                l_ret(l_ret.count) := l_rec_fast_track;
            END LOOP;
        
            RETURN l_ret;
        END get_fast_track;
    
        FUNCTION get_cause_comments(i_id_transportation IN transportation.id_transportation%TYPE)
            RETURN pk_edis_types.rec_cause_comments IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_CAUSE_COMMENTS';
            --
            l_ret pk_edis_types.rec_cause_comments;
        BEGIN
            g_error := 'FILL TRANSPORT RECORD';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_func_name);
            BEGIN
                SELECT t.id_external_cause, pk_translation.get_translation(i_lang, tr.code_translation), t.notes
                  INTO l_ret.id_external_cause, l_ret.desc_external_cause, l_ret.comments
                  FROM transportation t
                  JOIN external_cause ec
                    ON ec.id_external_cause = t.id_external_cause
                  JOIN translation tr
                    ON ec.code_external_cause = tr.code_translation
                 WHERE t.id_transportation = i_id_transportation;
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        
            RETURN l_ret;
        END get_cause_comments;
    BEGIN
        IF nvl(g_triage.id_epis_triage, -99) != i_epis_triage
        THEN
            g_error := 'OPEN AND FETCH C_EPIS_TRIAGE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN c_epis_triage;
            FETCH c_epis_triage
                INTO r_epis_triage;
            CLOSE c_epis_triage;
        
            g_error := 'FILL TRIAGE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        
            o_triage.id_patient      := r_epis_triage.id_patient;
            o_triage.id_episode      := r_epis_triage.id_episode;
            o_triage.id_triage_board := r_epis_triage.id_triage_board;
            o_triage.id_epis_triage  := i_epis_triage;
            o_triage.id_triage_type  := r_epis_triage.id_triage_type;
        
            IF nvl(i_flg_call, pk_edis_hist.g_call_detail) <> 'S'
            THEN
                o_triage.desc_triage_board         := r_epis_triage.desc_triage_board;
                o_triage.desc_triage_type          := r_epis_triage.desc_triage_type;
                o_triage.id_triage_color           := r_epis_triage.id_triage_color;
                o_triage.desc_triage_color         := r_epis_triage.desc_triage_color;
                o_triage.id_triage_white_reason    := r_epis_triage.id_triage_white_reason;
                o_triage.desc_white_reason         := r_epis_triage.desc_white_reason;
                o_triage.id_transp_entity          := r_epis_triage.id_transp_entity;
                o_triage.desc_transport            := r_epis_triage.desc_transport;
                o_triage.flg_changed_color         := r_epis_triage.flg_changed_color;
                o_triage.triage_duration           := r_epis_triage.triage_duration;
                o_triage.flg_letter                := r_epis_triage.flg_letter;
                o_triage.desc_letter               := r_epis_triage.desc_letter;
                o_triage.notes                     := r_epis_triage.notes;
                o_triage.chief_complaint           := r_epis_triage.chief_complaint;
                o_triage.emergency_contact         := r_epis_triage.emergency_contact;
                o_triage.treatment                 := r_epis_triage.treatment;
                o_triage.initial_notes             := r_epis_triage.initial_notes;
                o_triage.accident_desc             := r_epis_triage.accident_desc;
                o_triage.flg_critical_look         := r_epis_triage.flg_critical_look;
                o_triage.desc_critical             := r_epis_triage.desc_critical;
                o_triage.critical_look_description := r_epis_triage.critical_look_description;
                --Origin
                o_triage.origin.id_origin      := r_epis_triage.id_origin;
                o_triage.origin.desc_origin    := r_epis_triage.desc_origin;
                o_triage.origin.desc_origin_ft := r_epis_triage.desc_origin_ft;
                --Pregnant
                o_triage.pregnant.flg_pregnant    := r_epis_triage.flg_pregnant;
                o_triage.pregnant.desc_pregnant   := pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                                                         i_prof              => i_prof,
                                                                                         i_grp_internal_name => pk_edis_triage.g_ds_comp_lst_yes_no,
                                                                                         i_flg_context       => o_triage.pregnant.flg_pregnant);
                o_triage.pregnant.pregnancy_weeks := r_epis_triage.pregnancy_weeks;
                IF o_triage.pregnant.pregnancy_weeks IS NOT NULL
                THEN
                    o_triage.pregnant.desc_weeks := o_triage.pregnant.pregnancy_weeks || ' ' ||
                                                    pk_message.get_message(i_lang      => i_lang,
                                                                           i_code_mess => pk_pregnancy.g_code_msg_weeks);
                END IF;
                o_triage.pregnant.flg_postpartum  := r_epis_triage.flg_postpartum;
                o_triage.pregnant.desc_postpartum := pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                                                         i_prof              => i_prof,
                                                                                         i_grp_internal_name => pk_edis_triage.g_ds_comp_lst_yes_no,
                                                                                         i_flg_context       => o_triage.pregnant.flg_postpartum);
            
                --Needs
                g_error := 'FILL NEEDS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.needs := get_needs(i_id_necessity => r_epis_triage.id_necessity);
            
                --Options
                g_error := 'FILL GROUP OPTIONS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.group_options := get_group_options(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_epis_triage         => i_epis_triage,
                                                            i_triage              => r_epis_triage.id_triage,
                                                            i_triage_color        => r_epis_triage.id_triage_color,
                                                            i_flg_selected_option => r_epis_triage.flg_selected_option);
            
                --Vital Signs
                g_error := 'FILL VITAL_SIGNS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.vital_signs := get_vital_signs(i_lang        => i_lang,
                                                        i_prof        => i_prof,
                                                        i_epis_triage => i_epis_triage);
            
                --Defining Criterias
                g_error := 'FILL DEFINING CRITERIAS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.defining_criterias := get_defining_criteria(i_lang            => i_lang,
                                                                     i_tbl_grp_options => o_triage.group_options,
                                                                     i_tbl_vital_signs => o_triage.vital_signs,
                                                                     i_triage_type     => o_triage.id_triage_type);
            
                --Other Defining Criterias
                g_error := 'FILL OTHER DEFINING CRITERIAS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.other_criterias := get_other_def_criteria(i_lang                   => i_lang,
                                                                   i_tbl_grp_options        => o_triage.group_options,
                                                                   i_tbl_defining_criterias => o_triage.defining_criterias);
            
                --Fast track
                g_error := 'FILL FAST TRACK';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.fast_track := get_fast_track;
            
                g_error := 'FILL DISABLE FAST TRACK';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                --    o_triage.disable_fast_tracks := get_disable_fast_track(pk_fast_track.g_fast_track_active);
            
                -- Cause and Comments
                g_error := 'FILL CAUSE AND COMMENTS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                o_triage.cause_comments := get_cause_comments(i_id_transportation => r_epis_triage.id_transportation);
            END IF;
            -- Safeguarding
            g_error := 'FILL SAFEGUARDING';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            o_triage.safeguarding.flg_under_two_years  := r_epis_triage.flg_under_two_years;
            o_triage.safeguarding.flg_immobile         := r_epis_triage.flg_immobile;
            o_triage.safeguarding.flg_injury           := r_epis_triage.flg_unexplained_injury;
            o_triage.safeguarding.flg_protection_plan  := r_epis_triage.flg_protection_plan;
            o_triage.safeguarding.flg_attend_delay     := r_epis_triage.flg_attendance_delay;
            o_triage.safeguarding.flg_domestic_abuse   := r_epis_triage.flg_domestic_abuse;
            o_triage.safeguarding.flg_possible_injury  := r_epis_triage.flg_possible_injury;
            o_triage.safeguarding.flg_has_social       := r_epis_triage.flg_has_social_work;
            o_triage.safeguarding.social_work_name     := r_epis_triage.social_work_name;
            o_triage.safeguarding.social_work_address  := r_epis_triage.social_work_address;
            o_triage.safeguarding.flg_social_services  := r_epis_triage.flg_social_services;
            o_triage.safeguarding.social_reason        := r_epis_triage.social_reason;
            o_triage.safeguarding.flg_consent_social   := r_epis_triage.flg_consent_social;
            o_triage.safeguarding.flg_info_sharing     := r_epis_triage.flg_info_sharing;
            o_triage.safeguarding.dt_social_contact    := r_epis_triage.dt_social_contact;
            o_triage.safeguarding.social_info_received := r_epis_triage.social_info_received;
            o_triage.safeguarding.flg_signs_abuse      := r_epis_triage.flg_signs_abuse;
        
            g_triage := o_triage;
        ELSE
            o_triage := g_triage;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END get_triage_svd_data;

    /**
    * Get dynamic screen sections and events list
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_patient                   Patient id
    * @param   i_episode                   Episode id
    * @param   i_component_name            Component name
    * @param   i_component_type            Component type
    * @param   i_triage_board              Triage board id
    * @param   i_triage_discriminator      Triage discriminator id
    * @param   o_section                   Section cursor
    * @param   o_def_events                Default events cursor
    * @param   o_events                    Events cursor
    * @param   o_items_values              Item values for multichoices of single choice
    * @param   o_data_val                  Default data or previous saved data
    * @param   o_error                     Error information
    *
    * @return  TRUE if sucess, FALSE otherwise
    *
    * @author  Alexandre Santos
    * @version v2.6
    * @since   15-12-2011
    */
    FUNCTION get_section_data_int
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_epis_triage          IN epis_triage.id_epis_triage%TYPE DEFAULT NULL,
        i_component_name       IN ds_cmpt_mkt_rel.internal_name_parent%TYPE,
        i_component_type       IN ds_cmpt_mkt_rel.flg_component_type_parent%TYPE DEFAULT pk_dynamic_screen.c_node_component,
        i_triage_board         IN triage_board.id_triage_board%TYPE DEFAULT NULL,
        i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE DEFAULT NULL,
        i_is_detail_call       IN BOOLEAN DEFAULT FALSE,
        o_section              OUT t_table_ds_sections,
        o_def_events           OUT t_table_ds_def_events,
        o_events               OUT t_table_ds_events,
        o_items_values         OUT t_table_ds_items_values,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_SECTION_DATA_INT';
        --
        l_default_rank           CONSTANT PLS_INTEGER := 10;
        l_code_msg_ignore_result CONSTANT sys_message.code_message%TYPE := 'TRIAGE_M012';
        --
        l_tbl_sections             t_table_ds_sections;
        l_final_tbl_sections       t_table_ds_sections := t_table_ds_sections();
        r_section                  t_rec_ds_sections;
        l_tbl_items_values         t_table_ds_items_values;
        l_tbl_events               t_table_ds_events;
        l_tbl_def_events           t_table_ds_def_events;
        r_anamnesis                pk_edis_triage.rec_anamnesis;
        l_anamnesis_already_called BOOLEAN := FALSE;
        r_arrive                   pk_edis_proc.rec_arrive;
        l_arrive_already_called    BOOLEAN := FALSE;
        --
        l_pat_gender           patient.gender%TYPE;
        l_dt_preg_init         VARCHAR2(500);
        l_dt_preg_end          VARCHAR2(500);
        l_pregn_area_available VARCHAR2(2 CHAR);
        l_pregn_area_av_min_dt VARCHAR2(50 CHAR);
        --
        l_rec_preg pk_edis_types.rec_pregnant;
        --    
        l_exception   EXCEPTION;
        l_param_error EXCEPTION;
        l_needs_arrived_cfg sys_config.value%TYPE;
        --
        l_id_pat_pregnancy    pat_pregnancy.id_pat_pregnancy%TYPE;
        l_id_triage_type      triage_type.id_triage_type%TYPE;
        l_triage_ds_component triage_ds_component.id_triage_ds_component%TYPE;
        l_component_name_root triage_ds_component.internal_name%TYPE;
        l_component_type_root triage_ds_component.flg_component_type%TYPE;
        l_needs_complaint_cfg sys_config.value%TYPE;
        --
        PROCEDURE add_data_val
        (
            i_idx_section IN NUMBER,
            i_desc_value  IN VARCHAR2,
            i_value       IN NUMBER DEFAULT NULL,
            i_alt_value   IN VARCHAR2 DEFAULT NULL,
            i_vs_int_name IN VARCHAR2 DEFAULT NULL
        ) IS
            l_rec_data_val t_rec_ds_items_values;
        BEGIN
            l_rec_data_val := NEW t_rec_ds_items_values(id_ds_cmpt_mkt_rel => l_final_tbl_sections(i_idx_section).id_ds_cmpt_mkt_rel,
                                                        id_ds_component    => NULL,
                                                        internal_name      => i_vs_int_name,
                                                        flg_component_type => NULL,
                                                        item_desc          => i_desc_value,
                                                        item_value         => i_value,
                                                        item_alt_value     => i_alt_value,
                                                        item_xml_value     => NULL,
                                                        item_rank          => NULL);
        
            l_final_tbl_sections(i_idx_section).component_values.extend;
            l_final_tbl_sections(i_idx_section).component_values(l_final_tbl_sections(i_idx_section).component_values.count) := l_rec_data_val;
        END add_data_val;
        --
        PROCEDURE add_vs_value
        (
            i_idx_section     IN NUMBER,
            i_patient         IN patient.id_patient%TYPE,
            i_episode         IN episode.id_episode%TYPE,
            i_epis_triage     IN epis_triage.id_epis_triage%TYPE,
            i_vital_sign      IN vital_sign.id_vital_sign%TYPE,
            i_vs_int_name     IN vital_sign.intern_name_vital_sign%TYPE,
            i_tbl_vital_signs IN table_vital_signs
        ) IS
            l_triage          pk_edis_types.rec_triage;
            l_tbl_vital_signs pk_edis_types.table_vital_signs;
            l_rec_vital_sign  pk_edis_types.rec_vital_sign;
            --
            l_vs_parent_peak_flow     rec_vital_sign;
            l_vs_height               pk_vital_sign.rec_sign_v;
            l_vs_peak_flow_predict    pk_vital_sign.rec_sign_v;
            l_height_value            vital_sign_read.value%TYPE;
            l_peak_flow_predict_value vital_sign_read.value%TYPE;
            --
            l_desc_value pk_translation.t_desc_translation;
            --
            l_rec_vs_shockidx pk_edis_types.rec_vital_sign;
        BEGIN
            IF i_epis_triage IS NOT NULL
            THEN
                g_error := 'CALL GET_TRIAGE_SVD_DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                IF NOT get_triage_svd_data(i_lang        => i_lang,
                                           i_prof        => i_prof,
                                           i_epis_triage => i_epis_triage,
                                           o_triage      => l_triage,
                                           o_error       => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                l_tbl_vital_signs := l_triage.vital_signs;
            
                IF l_tbl_vital_signs.exists(1)
                THEN
                    IF i_vs_int_name = pk_edis_triage.g_vs_shock_index
                    THEN
                        --ALERT-275364 - EST New requirement: The system must provide the ability to ignore the urgency level obtained by the index the choc whenever required
                        FOR i IN l_tbl_vital_signs.first .. l_tbl_vital_signs.last
                        LOOP
                            l_rec_vital_sign := l_tbl_vital_signs(i);
                        
                            IF l_rec_vital_sign.internal_name = pk_edis_triage.g_vs_shock_index
                            THEN
                                l_rec_vs_shockidx := l_rec_vital_sign;
                            END IF;
                        END LOOP;
                    
                        IF l_rec_vs_shockidx.id_vital_sign IS NOT NULL
                        THEN
                            l_desc_value := l_rec_vs_shockidx.desc_vital_sign || ': ' || l_rec_vs_shockidx.desc_value || '; ';
                        
                            IF l_rec_vs_shockidx.is_to_ignore_result IS NOT NULL
                            THEN
                                l_desc_value := l_desc_value ||
                                                pk_message.get_message(i_lang      => i_lang,
                                                                       i_code_mess => l_code_msg_ignore_result) || ': ' ||
                                                pk_sysdomain.get_domain(i_code_dom => g_code_domain_yes_no,
                                                                        i_val      => l_rec_vs_shockidx.is_to_ignore_result,
                                                                        i_lang     => i_lang);
                            END IF;
                        END IF;
                    
                        IF l_desc_value IS NOT NULL
                        THEN
                            add_data_val(i_idx_section => i_idx_section, i_desc_value => l_desc_value, i_value => NULL);
                        END IF;
                    ELSE
                        FOR i IN l_tbl_vital_signs.first .. l_tbl_vital_signs.last
                        LOOP
                            l_rec_vital_sign := l_tbl_vital_signs(i);
                        
                            IF l_rec_vital_sign.id_vital_sign = i_vital_sign
                            THEN
                                add_data_val(i_idx_section => i_idx_section,
                                             i_desc_value  => l_rec_vital_sign.desc_value,
                                             i_value       => l_rec_vital_sign.value);
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                END IF;
            ELSIF i_vs_int_name = pk_edis_triage.g_vs_peak_flow_parent
            THEN
                IF i_tbl_vital_signs.exists(1)
                THEN
                    g_error := 'FIND HEIGHT VITAL_SIGN';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    FOR i IN i_tbl_vital_signs.first .. i_tbl_vital_signs.last
                    LOOP
                        CASE i_tbl_vital_signs(i).internal_name
                            WHEN pk_edis_triage.g_vs_peak_flow_parent THEN
                                l_vs_parent_peak_flow := i_tbl_vital_signs(i);
                            
                                IF l_vs_parent_peak_flow.child_vs.exists(1)
                                THEN
                                    FOR j IN l_vs_parent_peak_flow.child_vs.first .. l_vs_parent_peak_flow.child_vs.last
                                    LOOP
                                        CASE l_vs_parent_peak_flow.child_vs(j).internal_name
                                            WHEN pk_edis_triage.g_vs_height THEN
                                                l_vs_height := l_vs_parent_peak_flow.child_vs(j);
                                            WHEN pk_edis_triage.g_vs_peak_flow_expected THEN
                                                l_vs_peak_flow_predict := l_vs_parent_peak_flow.child_vs(j);
                                            ELSE
                                                NULL;
                                        END CASE;
                                    
                                        IF l_vs_height.id_vital_sign IS NOT NULL
                                           AND l_vs_peak_flow_predict.id_vital_sign IS NOT NULL
                                        THEN
                                            EXIT;
                                        END IF;
                                    END LOOP;
                                END IF;
                            
                                EXIT;
                            ELSE
                                NULL;
                        END CASE;
                    END LOOP;
                END IF;
            
                IF l_vs_height.id_vital_sign IS NOT NULL
                THEN
                    g_error := 'CALL PK_VITAL_SIGN.GET_VS_READ_VALUE - HEIGHT';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    l_height_value := pk_vital_sign.get_vs_read_value(i_lang       => i_lang,
                                                                      i_prof       => i_prof,
                                                                      i_patient    => i_patient,
                                                                      i_episode    => i_episode,
                                                                      i_vital_sign => l_vs_height.id_vital_sign);
                    IF l_height_value IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => l_height_value || --
                                                      CASE
                                                          WHEN l_vs_height.desc_unit_measure IS NOT NULL THEN
                                                           ' ' || l_vs_height.desc_unit_measure
                                                          ELSE
                                                           NULL
                                                      END,
                                     i_value       => l_height_value,
                                     i_vs_int_name => l_vs_height.internal_name);
                    
                        l_desc_value := l_vs_height.name_vs || ': ' || l_height_value || --
                                        CASE
                                            WHEN l_vs_height.desc_unit_measure IS NOT NULL THEN
                                             ' ' || l_vs_height.desc_unit_measure
                                            ELSE
                                             NULL
                                        END;
                    
                        --We need to have the patient height to calculate the peak flow predicted value
                        IF l_vs_peak_flow_predict.id_vital_sign IS NOT NULL
                        THEN
                            l_peak_flow_predict_value := pk_vital_sign.get_peak_flow_predict(i_lang       => i_lang,
                                                                                             i_prof       => i_prof,
                                                                                             i_pat_age    => pk_patient.get_pat_age(i_lang        => i_lang,
                                                                                                                                    i_dt_birth    => NULL,
                                                                                                                                    i_dt_deceased => NULL,
                                                                                                                                    i_age         => NULL,
                                                                                                                                    i_age_format  => 'YEARS',
                                                                                                                                    i_patient     => i_patient),
                                                                                             i_pat_gender => pk_patient.get_pat_gender(i_id_patient => i_patient),
                                                                                             i_pat_height => l_height_value);
                        
                            IF l_desc_value IS NOT NULL
                               AND l_peak_flow_predict_value IS NOT NULL
                            THEN
                                add_data_val(i_idx_section => i_idx_section,
                                             i_desc_value  => l_peak_flow_predict_value || --
                                                              CASE
                                                                  WHEN l_vs_peak_flow_predict.desc_unit_measure IS NOT NULL THEN
                                                                   ' ' || l_vs_peak_flow_predict.desc_unit_measure
                                                                  ELSE
                                                                   NULL
                                                              END,
                                             i_value       => l_peak_flow_predict_value,
                                             i_vs_int_name => l_vs_peak_flow_predict.internal_name);
                            
                                l_desc_value := l_desc_value || chr(13) || --
                                                l_vs_peak_flow_predict.name_vs || ': ' || l_peak_flow_predict_value || --
                                                CASE
                                                    WHEN l_vs_peak_flow_predict.desc_unit_measure IS NOT NULL THEN
                                                     ' ' || l_vs_peak_flow_predict.desc_unit_measure
                                                    ELSE
                                                     NULL
                                                END;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            
                IF l_desc_value IS NOT NULL
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_desc_value, i_value => NULL);
                END IF;
            END IF;
        END add_vs_value;
        --
        PROCEDURE add_values
        (
            i_idx_section   IN NUMBER,
            i_internal_name IN ds_component.internal_name%TYPE,
            i_epis_triage   IN epis_triage.id_epis_triage%TYPE
        ) IS
            l_triage pk_edis_types.rec_triage;
            --
            l_code_accomp_by CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M001';
            --
            l_msg_accomp_by       sys_message.desc_message%TYPE;
            l_name                pk_translation.t_desc_translation;
            l_contact             pk_translation.t_desc_translation;
            l_family_relationship pk_translation.t_desc_translation;
        BEGIN
            IF i_epis_triage IS NULL
            THEN
                --ADD Default values
                IF i_internal_name IN (g_ds_comp_chief_comp, g_ds_comp_est_motif_entree)
                THEN
                    g_error := 'OUT DATA VALUE - ADD CHIEF_COMP';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_anamnesis.id_epis_anamnesis IS NOT NULL
                       OR r_anamnesis.desc_epis_anamnesis IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => r_anamnesis.desc_epis_anamnesis,
                                     i_value       => r_anamnesis.id_epis_anamnesis);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_origin
                THEN
                    g_error := 'OUT DATA VALUE - ADD ORIGIN';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.id_origin IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => r_arrive.origin_desc,
                                     i_value       => r_arrive.id_origin);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_cause
                THEN
                    g_error := 'OUT DATA VALUE - ADD CAUSE';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.id_external_cause IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => r_arrive.external_cause_desc,
                                     i_value       => r_arrive.id_external_cause);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_comments
                THEN
                    g_error := 'OUT DATA VALUE - ADD COMMENTS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.notes IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section, i_desc_value => r_arrive.notes, i_value => NULL);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_desc_origin
                THEN
                    g_error := 'OUT DATA VALUE - ADD DESC_ORIGIN';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.triage_origin_desc IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section, i_desc_value => r_arrive.triage_origin_desc);
                    END IF;
                ELSIF i_internal_name IN (g_ds_comp_arrived_by, g_ds_comp_est_arrived_by)
                THEN
                    g_error := 'OUT DATA VALUE - ADD ARRIVED_BY';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.id_transp_entity IS NOT NULL
                       AND r_arrive.id_transp_entity <> -1
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => r_arrive.transp_entity,
                                     i_value       => r_arrive.id_transp_entity);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_emerg_cont
                THEN
                    g_error := 'OUT DATA VALUE - ADD EMERGENCY_CONTACT';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.emergency_contact IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section, i_desc_value => r_arrive.emergency_contact);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_letter
                THEN
                    g_error := 'OUT DATA VALUE - ADD LETTER';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF r_arrive.flg_letter IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => r_arrive.desc_letter,
                                     i_alt_value   => r_arrive.flg_letter);
                    END IF;
                ELSIF i_internal_name = g_ds_comp_est_entourage
                THEN
                    g_error := 'CALL PK_EDIS_LIST.GET_TRANSP_ENTITY_LIST';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF NOT pk_adt.get_emergency_contact(i_lang                => i_lang,
                                                        i_prof                => i_prof,
                                                        i_patient             => i_patient,
                                                        o_name                => l_name,
                                                        o_contact             => l_contact,
                                                        o_family_relationship => l_family_relationship,
                                                        o_error               => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    IF l_family_relationship IS NOT NULL
                    THEN
                        l_msg_accomp_by := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_accomp_by);
                        l_msg_accomp_by := REPLACE(srcstr => l_msg_accomp_by,
                                                   oldsub => '@1',
                                                   newsub => lower(l_family_relationship));
                    END IF;
                
                    IF l_name IS NOT NULL
                    THEN
                        IF l_msg_accomp_by IS NOT NULL
                        THEN
                            l_msg_accomp_by := l_msg_accomp_by || ' ';
                        END IF;
                    
                        l_msg_accomp_by := l_msg_accomp_by || l_name;
                    END IF;
                
                    IF l_contact IS NOT NULL
                    THEN
                        IF l_msg_accomp_by IS NOT NULL
                        THEN
                            l_msg_accomp_by := l_msg_accomp_by || ' ';
                        END IF;
                    
                        l_msg_accomp_by := l_msg_accomp_by || '(' || l_contact || ')';
                    END IF;
                
                    IF l_msg_accomp_by IS NOT NULL
                    THEN
                        add_data_val(i_idx_section => i_idx_section, i_desc_value => l_msg_accomp_by);
                    END IF;
                ELSIF i_internal_name = pk_edis_triage.g_ds_comp_est_femme_enceinte
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_rec_preg.desc_pregnant,
                                 i_alt_value   => l_rec_preg.flg_pregnant);
                ELSIF i_internal_name = pk_edis_triage.g_ds_comp_est_femme_encnt_wks
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_rec_preg.desc_weeks,
                                 i_value       => l_rec_preg.pregnancy_weeks);
                ELSIF i_internal_name = pk_edis_triage.g_ds_comp_est_femme_1mois_pp
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_rec_preg.desc_postpartum,
                                 i_alt_value   => l_rec_preg.flg_postpartum);
                END IF;
            
            ELSE
                g_error := 'CALL GET_TRIAGE_SVD_DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                IF NOT get_triage_svd_data(i_lang        => i_lang,
                                           i_prof        => i_prof,
                                           i_epis_triage => i_epis_triage,
                                           o_triage      => l_triage,
                                           o_error       => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'OUT DATA VALUE - ' || g_ds_comp_origin;
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                --ADD Saved values
                IF i_internal_name = g_ds_comp_origin
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.origin.desc_origin,
                                 i_value       => l_triage.origin.id_origin);
                ELSIF i_internal_name = g_ds_comp_desc_origin
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_triage.origin.desc_origin_ft);
                ELSIF i_internal_name = g_ds_comp_letter
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.desc_letter,
                                 i_alt_value   => l_triage.flg_letter);
                ELSIF i_internal_name IN (g_ds_comp_needs, g_ds_comp_est_needs)
                THEN
                    IF ((i_internal_name = g_ds_comp_est_needs AND nvl(l_needs_arrived_cfg, g_yes) = g_yes) OR
                       i_internal_name = g_ds_comp_needs)
                       AND l_triage.needs IS NOT NULL
                       AND l_triage.needs.count > 0
                    THEN
                        FOR i IN l_triage.needs.first .. l_triage.needs.last
                        LOOP
                            add_data_val(i_idx_section => i_idx_section,
                                         i_desc_value  => l_triage.needs(i).desc_necessity,
                                         i_value       => l_triage.needs(i).id_necessity);
                        END LOOP;
                    END IF;
                ELSIF i_internal_name IN (g_ds_comp_arrived_by, g_ds_comp_est_arrived_by)
                THEN
                    IF ((i_internal_name = g_ds_comp_est_arrived_by AND nvl(l_needs_arrived_cfg, g_yes) = g_yes) OR
                       i_internal_name = g_ds_comp_arrived_by)
                    THEN
                        add_data_val(i_idx_section => i_idx_section,
                                     i_desc_value  => l_triage.desc_transport,
                                     i_value       => l_triage.id_transp_entity);
                    END IF;
                ELSIF i_internal_name IN (g_ds_comp_chief_comp, g_ds_comp_est_motif_entree)
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.chief_complaint,
                                 i_value       => NULL);
                ELSIF i_internal_name IN (g_ds_comp_emerg_cont, g_ds_comp_est_entourage)
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_triage.emergency_contact);
                ELSIF i_internal_name = g_ds_comp_cause
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.cause_comments.desc_external_cause,
                                 i_value       => l_triage.cause_comments.id_external_cause);
                ELSIF i_internal_name = g_ds_comp_comments
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.cause_comments.comments,
                                 i_value       => NULL);
                ELSIF i_internal_name = g_ds_comp_est_femme_enceinte
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.pregnant.desc_pregnant,
                                 i_alt_value   => l_triage.pregnant.flg_pregnant);
                ELSIF i_internal_name = g_ds_comp_est_femme_encnt_wks
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.pregnant.desc_weeks,
                                 i_value       => l_triage.pregnant.pregnancy_weeks);
                ELSIF i_internal_name = g_ds_comp_est_femme_1mois_pp
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.pregnant.desc_postpartum,
                                 i_alt_value   => l_triage.pregnant.flg_postpartum);
                ELSIF i_internal_name = g_ds_comp_est_traitement
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_triage.treatment);
                ELSIF i_internal_name = g_ds_comp_est_notes
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_triage.initial_notes);
                
                ELSIF i_internal_name = g_ds_safeguard_under_two_years
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_under_two_years,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_under_two_years);
                ELSIF i_internal_name = g_ds_safeguard_abuse_sign
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_signs_abuse,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_signs_abuse);
                ELSIF i_internal_name = g_ds_safeguard_immobile
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_immobile,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_immobile);
                ELSIF i_internal_name = g_ds_safeguard_injury
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_injury,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_injury);
                ELSIF i_internal_name = g_ds_safeguard_protection_plan
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_protection_plan,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_protection_plan);
                ELSIF i_internal_name = g_ds_safeguard_attend_delay
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_attend_delay,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_attend_delay);
                ELSIF i_internal_name = g_ds_safeguard_domestic_abuse
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_domestic_abuse,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_domestic_abuse);
                
                ELSIF i_internal_name = g_ds_safeguard_expl_injury
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_possible_injury,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_possible_injury);
                ELSIF i_internal_name = g_ds_safeguard_has_social_w
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_has_social,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_has_social);
                ELSIF i_internal_name = g_ds_safeguard_social_name
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.safeguarding.social_work_name);
                ELSIF i_internal_name = g_ds_safeguard_social_add
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.safeguarding.social_work_address);
                ELSIF i_internal_name = g_ds_safeguard_social_services
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_social_services,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_social_services);
                ELSIF i_internal_name = g_ds_safeguard_social_reason
                THEN
                    add_data_val(i_idx_section => i_idx_section, i_desc_value => l_triage.safeguarding.social_reason);
                ELSIF i_internal_name = g_ds_safeguard_social_consent
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_consent_social,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_consent_social);
                ELSIF i_internal_name = g_ds_safeguard_social_infor
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                          l_triage.safeguarding.flg_info_sharing,
                                                                          i_lang),
                                 i_alt_value   => l_triage.safeguarding.flg_info_sharing);
                
                ELSIF i_internal_name = g_ds_safeguard_social_info_req
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => l_triage.safeguarding.social_info_received);
                
                ELSIF i_internal_name = g_ds_safeguard_social_dt
                THEN
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => pk_date_utils.date_char_tsz(i_lang,
                                                                              l_triage.safeguarding.dt_social_contact,
                                                                              i_prof.institution,
                                                                              i_prof.software));
                END IF;
            END IF;
        END add_values;
        --
        PROCEDURE add_new_section
        (
            i_ds_cmpt_mkt_rel      IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component_parent  IN ds_cmpt_mkt_rel.id_ds_component_parent%TYPE,
            i_ds_component         IN ds_component.id_ds_component%TYPE,
            i_component_desc       IN pk_translation.t_desc_translation,
            i_internal_name        IN ds_component.internal_name%TYPE,
            i_flg_component_type   IN ds_component.flg_component_type%TYPE DEFAULT pk_dynamic_screen.c_leaf_component,
            i_flg_data_type        IN ds_component.flg_data_type%TYPE,
            i_slg_internal_name    IN ds_component.slg_internal_name%TYPE DEFAULT NULL,
            i_addit_info_xml_value IN CLOB DEFAULT NULL,
            i_rank                 IN ds_cmpt_mkt_rel.rank%TYPE,
            i_max_len              IN ds_component.max_len%TYPE DEFAULT NULL,
            i_min_value            IN ds_component.min_value%TYPE DEFAULT NULL,
            i_max_value            IN ds_component.max_value%TYPE DEFAULT NULL,
            io_tbl_sections        IN OUT NOCOPY t_table_ds_sections
        ) IS
            l_proc_name CONSTANT VARCHAR2(30) := 'ADD_NEW_SECTION';
            --
            r_section t_rec_ds_sections;
        BEGIN
            g_error := 'NEW T_REC_DS_SECTIONS INSTANCE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            r_section := t_rec_ds_sections(id_ds_cmpt_mkt_rel     => i_ds_cmpt_mkt_rel,
                                           id_ds_component_parent => i_ds_component_parent,
                                           id_ds_component        => i_ds_component,
                                           component_desc         => i_component_desc,
                                           internal_name          => i_internal_name,
                                           flg_component_type     => i_flg_component_type,
                                           flg_data_type          => i_flg_data_type,
                                           slg_internal_name      => i_slg_internal_name,
                                           addit_info_xml_value   => i_addit_info_xml_value,
                                           rank                   => i_rank,
                                           max_len                => i_max_len,
                                           min_value              => i_min_value,
                                           max_value              => i_max_value);
        
            g_error := 'ADD SECTION TO IO_TBL_SECTIONS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            io_tbl_sections.extend;
            io_tbl_sections(io_tbl_sections.count) := r_section;
        END add_new_section;
        --
        PROCEDURE add_new_def_event
        (
            i_pk              IN ds_def_event.id_def_event%TYPE,
            i_ds_cmpt_mkt_rel IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_flg_event_type  IN ds_def_event.flg_event_type%TYPE,
            io_tbl_def_events IN OUT NOCOPY t_table_ds_def_events
        ) IS
            l_proc_name CONSTANT VARCHAR2(30) := 'ADD_NEW_DEF_EVENT';
            --
            r_ds_def_event t_rec_ds_def_events;
        BEGIN
            g_error := 'NEW T_REC_DS_DEF_EVENTS INSTANCE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            r_ds_def_event := t_rec_ds_def_events(id_ds_cmpt_mkt_rel => i_ds_cmpt_mkt_rel,
                                                  id_def_event       => i_pk,
                                                  flg_event_type     => i_flg_event_type);
        
            g_error := 'ADD DEF_EVENT TO IO_TBL_DEF_EVENTS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            io_tbl_def_events.extend;
            io_tbl_def_events(io_tbl_def_events.count) := r_ds_def_event;
        END add_new_def_event;
        --
        PROCEDURE add_new_event_target
        (
            i_ds_event             IN ds_event.id_ds_event%TYPE,
            i_orig_ds_cmpt_mkt_rel IN ds_event.id_ds_cmpt_mkt_rel%TYPE,
            i_value                IN ds_event.value%TYPE,
            i_targ_ds_cmpt_mkt_rel IN ds_event_target.id_ds_cmpt_mkt_rel%TYPE,
            i_flg_event_type       IN ds_event_target.flg_event_type%TYPE,
            io_tbl_events          IN OUT NOCOPY t_table_ds_events
        ) IS
            l_proc_name CONSTANT VARCHAR2(30) := 'ADD_NEW_EVENT_TARGET';
            --
            r_ds_event t_rec_ds_events;
        BEGIN
            g_error := 'NEW T_REC_DS_EVENTS INSTANCE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            r_ds_event := t_rec_ds_events(id_ds_event    => i_ds_event,
                                          origin         => i_orig_ds_cmpt_mkt_rel,
                                          VALUE          => i_value,
                                          target         => i_targ_ds_cmpt_mkt_rel,
                                          flg_event_type => i_flg_event_type);
        
            g_error := 'ADD DEF_EVENT TO IO_TBL_EVENTS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_proc_name);
            io_tbl_events.extend;
            io_tbl_events(io_tbl_events.count) := r_ds_event;
        END add_new_event_target;
        --
        PROCEDURE add_new_item
        (
            i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component       IN ds_component.id_ds_component%TYPE,
            i_internal_name      IN ds_component.internal_name%TYPE,
            i_flg_component_type IN ds_component.flg_component_type%TYPE,
            i_item_desc          IN pk_translation.t_desc_translation,
            i_item_value         IN sys_list.id_sys_list%TYPE,
            i_item_alt_value     IN sys_list_group_rel.flg_context%TYPE,
            i_item_xml_value     IN CLOB DEFAULT NULL,
            i_item_rank          IN sys_list_group_rel.rank%TYPE,
            io_tbl_items_values  IN OUT NOCOPY t_table_ds_items_values
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_NEW_ITEM';
            --
            r_item_value t_rec_ds_items_values;
        BEGIN
            g_error := 'NEW T_REC_DS_ITEMS_VALUES INSTANCE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            r_item_value := t_rec_ds_items_values(id_ds_cmpt_mkt_rel => i_ds_cmpt_mkt_rel,
                                                  id_ds_component    => i_ds_component,
                                                  internal_name      => i_internal_name,
                                                  flg_component_type => i_flg_component_type,
                                                  item_desc          => i_item_desc,
                                                  item_value         => i_item_value,
                                                  item_alt_value     => i_item_alt_value,
                                                  item_xml_value     => i_item_xml_value,
                                                  item_rank          => i_item_rank);
        
            g_error := 'ADD TO TABLE L_TBL_ITEMS_VALUES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            io_tbl_items_values.extend;
            io_tbl_items_values(io_tbl_items_values.count) := r_item_value;
        END add_new_item;
    
        PROCEDURE add_origin
        (
            i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component       IN ds_component.id_ds_component%TYPE,
            i_internal_name      IN ds_component.internal_name%TYPE,
            i_flg_component_type IN ds_component.flg_component_type%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_ORIGIN';
            --
            c_origin pk_list.cursor_origin;
            r_origin pk_list.rec_origin;
        BEGIN
            g_error := 'CALL PK_LIST.GET_ORIGIN_LIST';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            IF NOT pk_list.get_origin_list(i_lang => i_lang, i_prof => i_prof, o_origin => c_origin, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'ADD ALL ORIGINS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            LOOP
                FETCH c_origin
                    INTO r_origin;
                EXIT WHEN c_origin%NOTFOUND;
            
                add_new_item(i_ds_cmpt_mkt_rel    => i_ds_cmpt_mkt_rel,
                             i_ds_component       => i_ds_component,
                             i_internal_name      => i_internal_name,
                             i_flg_component_type => i_flg_component_type,
                             i_item_desc          => r_origin.origin,
                             i_item_value         => r_origin.id_origin,
                             i_item_alt_value     => NULL,
                             i_item_rank          => r_origin.rank,
                             io_tbl_items_values  => l_tbl_items_values);
            END LOOP;
        
            CLOSE c_origin;
        END add_origin;
    
        PROCEDURE add_yes_no_list
        (
            i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component       IN ds_component.id_ds_component%TYPE,
            i_internal_name      IN ds_component.internal_name%TYPE,
            i_flg_component_type IN ds_component.flg_component_type%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_ORIGIN';
            --
            c_list     pk_types.cursor_type;
            l_desc_val sys_domain.desc_val%TYPE;
            l_val      sys_domain.val%TYPE;
            l_img_name sys_domain.img_name%TYPE;
            l_rank     sys_domain.rank%TYPE;
        BEGIN
            g_error := 'CALL PK_LIST.GET_YES_NO_LIST';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            IF NOT pk_list.get_yes_no_list(i_lang => i_lang, o_list => c_list, o_error => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'ADD YES NO ORIGINS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            LOOP
                FETCH c_list
                    INTO l_desc_val, l_val, l_img_name, l_rank;
                EXIT WHEN c_list%NOTFOUND;
            
                add_new_item(i_ds_cmpt_mkt_rel    => i_ds_cmpt_mkt_rel,
                             i_ds_component       => i_ds_component,
                             i_internal_name      => i_internal_name,
                             i_flg_component_type => i_flg_component_type,
                             i_item_desc          => l_desc_val,
                             i_item_value         => NULL,
                             i_item_alt_value     => l_val,
                             i_item_rank          => l_rank,
                             io_tbl_items_values  => l_tbl_items_values);
            END LOOP;
        
            CLOSE c_list;
        END add_yes_no_list;
    
        PROCEDURE add_all_pat_necess(i_idx_section IN NUMBER) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_ALL_PAT_NECESS';
            --
            l_cfg_default_need CONSTANT sys_config.id_sys_config%TYPE := 'TRIAGE_DEFAULT_NEEDS';
            --
            c_necess pk_patient.cursor_necess;
            r_necess pk_patient.rec_necess;
            --
            l_rank              PLS_INTEGER;
            l_has_default_value BOOLEAN := FALSE;
        BEGIN
            g_error := 'CALL PK_PATIENT.GET_ALL_PAT_NECESS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
        
            IF NOT pk_patient.get_all_pat_necess(i_lang       => i_lang,
                                                 i_prof       => i_prof,
                                                 i_id_patient => i_patient,
                                                 i_id_episode => i_episode,
                                                 o_necess     => c_necess,
                                                 o_error      => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            l_rank := l_default_rank;
        
            g_error := 'ADD ALL PAT_NECESS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            LOOP
                FETCH c_necess
                    INTO r_necess;
                EXIT WHEN c_necess%NOTFOUND;
            
                add_new_item(i_ds_cmpt_mkt_rel    => l_final_tbl_sections(i_idx_section).id_ds_cmpt_mkt_rel,
                             i_ds_component       => l_final_tbl_sections(i_idx_section).id_ds_component,
                             i_internal_name      => l_final_tbl_sections(i_idx_section).internal_name,
                             i_flg_component_type => l_final_tbl_sections(i_idx_section).flg_component_type,
                             i_item_desc          => r_necess.necess,
                             i_item_value         => r_necess.id_necessity,
                             i_item_alt_value     => r_necess.flg_comb,
                             i_item_rank          => l_rank,
                             io_tbl_items_values  => l_tbl_items_values);
            
                IF r_necess.flg_status IN (pk_patient.g_pat_necess_active_config, pk_patient.g_pat_necess_active)
                   AND i_epis_triage IS NULL --Only add this value in a new triage, in detail screen show saved data
                THEN
                    l_has_default_value := TRUE;
                
                    add_data_val(i_idx_section => i_idx_section,
                                 i_desc_value  => r_necess.necess,
                                 i_value       => r_necess.id_necessity);
                END IF;
            
                l_rank := l_rank + l_default_rank;
            END LOOP;
        
            CLOSE c_necess;
        
            IF NOT l_has_default_value
            THEN
                NULL; --TODO:
            END IF;
        END add_all_pat_necess;
    
        PROCEDURE add_transp_entity_list
        (
            i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component       IN ds_component.id_ds_component%TYPE,
            i_internal_name      IN ds_component.internal_name%TYPE,
            i_flg_component_type IN ds_component.flg_component_type%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_TRANSP_ENTITY_LIST';
            --
            l_flg_transp_a CONSTANT transp_entity.flg_transp%TYPE := 'A'; --Arrived
            --
            c_transp pk_edis_list.cursor_transp;
            r_transp pk_edis_list.rec_transp;
        BEGIN
            g_error := 'CALL PK_EDIS_LIST.GET_TRANSP_ENTITY_LIST';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            IF NOT pk_edis_list.get_transp_entity_list(i_lang   => i_lang,
                                                       i_transp => l_flg_transp_a,
                                                       i_prof   => i_prof,
                                                       o_transp => c_transp,
                                                       o_error  => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'ADD ALL TRANSP_ENTITY_LIST';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            LOOP
                FETCH c_transp
                    INTO r_transp;
                EXIT WHEN c_transp%NOTFOUND;
            
                add_new_item(i_ds_cmpt_mkt_rel    => i_ds_cmpt_mkt_rel,
                             i_ds_component       => i_ds_component,
                             i_internal_name      => i_internal_name,
                             i_flg_component_type => i_flg_component_type,
                             i_item_desc          => r_transp.transp_entity,
                             i_item_value         => r_transp.id_transp_entity,
                             i_item_alt_value     => r_transp.flg_status,
                             i_item_rank          => r_transp.rank,
                             io_tbl_items_values  => l_tbl_items_values);
            END LOOP;
        
            CLOSE c_transp;
        END add_transp_entity_list;
    
        PROCEDURE add_sample_text
        (
            i_intern_name_sample_text_type IN sample_text_type.intern_name_sample_text_type%TYPE,
            io_section                     IN OUT t_rec_ds_sections
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_SAMPLE_TEXT';
        BEGIN
            g_error := 'ADD SAMPLE TEXT ADDITIONAL_INFO TO SECTION: ' || io_section.internal_name;
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            SELECT xmlelement("ADDITIONAL_INFO", xmlattributes(t.intern_name_sample_text_type)).getclobval()
              INTO io_section.addit_info_xml_value
              FROM (SELECT i_intern_name_sample_text_type intern_name_sample_text_type
                      FROM dual) t;
        END add_sample_text;
    
        PROCEDURE add_vital_signs
        (
            i_lang                IN language.id_language%TYPE DEFAULT NULL,
            i_prof                IN profissional,
            i_epis_triage         IN epis_triage.id_epis_triage%TYPE,
            i_ds_component_parent IN ds_cmpt_mkt_rel.id_ds_component_parent%TYPE,
            i_tbl_id_context      IN table_number DEFAULT NULL,
            i_flg_context         IN triage_vs_area.flg_context%TYPE DEFAULT pk_edis_triage.g_flg_context_id_ds_component
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_VITAL_SIGNS';
            --
            l_flg_view_t         CONSTANT vs_soft_inst.flg_view%TYPE := 'T'; --Triage
            l_flg_component_type CONSTANT ds_component.flg_component_type%TYPE := pk_dynamic_screen.c_leaf_component;
            l_disc_assessment_vs CONSTANT triage_discriminator.flg_assessment_type%TYPE := 'VS';
            l_code_msg_vs_crit   CONSTANT sys_message.code_message%TYPE := 'TRIAGE_ESI_T007'; --Critères des signes vitaux
            l_code_msg_age       CONSTANT sys_message.code_message%TYPE := 'TRIAGE_ESI_T008'; --Age
            --
            l_ds_component_age     CONSTANT ds_component.id_ds_component%TYPE := 12345600;
            l_ds_component_vs_crit CONSTANT ds_component.id_ds_component%TYPE := 12345601;
            l_ds_int_name_age      CONSTANT ds_component.internal_name%TYPE := 'PATIENT_AS_VS';
            l_ds_int_name_vs_crit  CONSTANT ds_component.internal_name%TYPE := 'VITAL_SIGN_CRIT';
            --
            l_ds_component_consent CONSTANT ds_component.id_ds_component%TYPE := 12345602; --Triage_disc_consent
            --
            l_vs_evaluation     triage_discriminator.flg_assessment_type%TYPE;
            l_add_evaluation_vs BOOLEAN := FALSE;
            c_discrim_child     pk_edis_types.cursor_discrim_child;
            r_discrim_child     pk_edis_types.rec_discrim_child;
            --
            l_tbl_triage_vs   table_number;
            l_tbl_vital_signs table_vital_signs;
            r_vital_sign      rec_vital_sign;
            --
            c_sign_v pk_vital_sign.cursor_sign_v;
            r_sign_v pk_vital_sign.rec_sign_v;
            --
            l_xml_parent_value xmltype;
            l_xml_value        xmltype;
            --
            l_rank PLS_INTEGER := 10;
            --
            l_is_pregn_exclusive_vs  BOOLEAN;
            l_tbl_pregn_exclusive_vs table_number;
            l_tbl_preg_ds_events     t_table_ds_events;
            l_preg_ds_event_yes      t_rec_ds_events;
            l_preg_ds_event_no       t_rec_ds_events;
            --
            l_discrim_with_consent VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
            --
            l_consent_group       triage_disc_consent.consent_group%TYPE;
            l_field_consent_added BOOLEAN := FALSE;
            l_id_ds_cmpt_mkt_rel  ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE;
            l_fgl_event_type      VARCHAR2(1);
        
            FUNCTION search_vs_and_add_child_vs RETURN BOOLEAN IS
                l_found_vs BOOLEAN := FALSE;
            BEGIN
                IF l_tbl_vital_signs IS NOT NULL
                   AND l_tbl_vital_signs.count > 0
                THEN
                    FOR i IN l_tbl_vital_signs.first .. l_tbl_vital_signs.last
                    LOOP
                        IF l_tbl_vital_signs(i).id_vital_sign = r_sign_v.id_vital_sign_parent
                            AND l_tbl_vital_signs(i).id_vital_sign != r_sign_v.id_vital_sign
                            AND NOT i_is_detail_call
                        THEN
                            l_tbl_vital_signs(i).child_vs.extend();
                            l_tbl_vital_signs(i).child_vs(l_tbl_vital_signs(i).child_vs.count) := r_sign_v;
                            l_found_vs := TRUE;
                            EXIT;
                        ELSIF (l_tbl_vital_signs(i).id_vital_sign = r_sign_v.id_vital_sign_parent AND l_tbl_vital_signs(i)
                              .id_vital_sign = r_sign_v.id_vital_sign)
                             --Is just to prevent errors in configuration where id_vital_sign is = to id_vital_sign_parent
                              OR (r_sign_v.id_vital_sign_parent IS NULL AND l_tbl_vital_signs(i)
                              .id_vital_sign = r_sign_v.id_vital_sign)
                        THEN
                            l_tbl_vital_signs(i).vs := r_sign_v;
                            l_found_vs := TRUE;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                RETURN l_found_vs;
            END search_vs_and_add_child_vs;
            --
            FUNCTION check_value_exists
            (
                i_table IN table_number,
                i_value IN NUMBER
            ) RETURN BOOLEAN IS
                l_count PLS_INTEGER;
            BEGIN
                SELECT COUNT(1)
                  INTO l_count
                  FROM TABLE(i_table)
                 WHERE column_value = i_value;
            
                RETURN(l_count > 0);
            END check_value_exists;
            --
            PROCEDURE add_shock_index_subform IS
                l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_SHOCK_INDEX_SUBFORM';
                --
                l_sub_form_pk      CONSTANT ds_component.id_ds_component%TYPE := r_vital_sign.id_ds_component +
                                                                                 10000000;
                l_ignore_result_pk CONSTANT ds_component.id_ds_component%TYPE := r_vital_sign.id_ds_component +
                                                                                 10000001;
                l_not_null         CONSTANT ds_event.value%TYPE := '@NOT_NULL';
                --
                c_list     pk_types.cursor_type;
                l_desc_val sys_domain.desc_val%TYPE;
                l_val      sys_domain.val%TYPE;
                l_img_name sys_domain.img_name%TYPE;
                l_rank_aux sys_domain.rank%TYPE;
                --
                l_idx_shock_index_subform PLS_INTEGER;
            BEGIN
                --ALERT-275364 - EST New requirement: The system must provide the ability to ignore the urgency level obtained by the index the choc whenever required
            
                g_error := 'ADD SECTION - ' || pk_edis_triage.g_vs_shock_index_subform;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_section(i_ds_cmpt_mkt_rel      => l_sub_form_pk,
                                i_ds_component_parent  => i_ds_component_parent,
                                i_ds_component         => l_sub_form_pk,
                                i_component_desc       => r_vital_sign.vs.name_vs,
                                i_internal_name        => pk_edis_triage.g_vs_shock_index_subform,
                                i_flg_component_type   => l_flg_component_type,
                                i_flg_data_type        => pk_dynamic_screen.c_data_type_fr,
                                i_slg_internal_name    => NULL,
                                i_addit_info_xml_value => NULL,
                                i_rank                 => l_rank,
                                i_max_len              => NULL,
                                i_min_value            => NULL,
                                i_max_value            => NULL,
                                io_tbl_sections        => l_final_tbl_sections);
            
                l_idx_shock_index_subform := l_final_tbl_sections.count;
            
                g_error := 'ADD DEF_EVENT - ' || pk_edis_triage.g_vs_shock_index_subform;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_def_event(i_pk              => l_sub_form_pk,
                                  i_ds_cmpt_mkt_rel => l_sub_form_pk,
                                  i_flg_event_type  => pk_alert_constant.g_inactive,
                                  io_tbl_def_events => l_tbl_def_events);
            
                g_error := 'ADD SECTION - ' || pk_edis_triage.g_vs_shock_index;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_section(i_ds_cmpt_mkt_rel      => r_vital_sign.id_ds_component,
                                i_ds_component_parent  => l_sub_form_pk,
                                i_ds_component         => r_vital_sign.id_ds_component,
                                i_component_desc       => r_vital_sign.vs.name_vs,
                                i_internal_name        => r_vital_sign.internal_name,
                                i_flg_component_type   => l_flg_component_type,
                                i_flg_data_type        => g_flg_data_type_vs,
                                i_slg_internal_name    => NULL,
                                i_addit_info_xml_value => NULL,
                                i_rank                 => l_rank + 1,
                                i_max_len              => NULL,
                                i_min_value            => r_vital_sign.vs.val_min,
                                i_max_value            => r_vital_sign.vs.val_max,
                                io_tbl_sections        => l_final_tbl_sections);
            
                g_error := 'ADD ITEM_VALUE - ' || pk_edis_triage.g_vs_shock_index;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_item(i_ds_cmpt_mkt_rel    => r_vital_sign.id_ds_component,
                             i_ds_component       => r_vital_sign.id_ds_component,
                             i_internal_name      => r_vital_sign.internal_name,
                             i_flg_component_type => l_flg_component_type,
                             i_item_desc          => r_vital_sign.vs.name_vs,
                             i_item_value         => r_vital_sign.vs.id_vital_sign,
                             i_item_alt_value     => g_flg_data_type_vs,
                             i_item_xml_value     => l_xml_value.getclobval(),
                             i_item_rank          => l_rank,
                             io_tbl_items_values  => l_tbl_items_values);
            
                g_error := 'ADD SECTION - ' || pk_edis_triage.g_vs_shock_index_ign_res;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_section(i_ds_cmpt_mkt_rel      => l_ignore_result_pk,
                                i_ds_component_parent  => l_sub_form_pk,
                                i_ds_component         => l_ignore_result_pk,
                                i_component_desc       => pk_message.get_message(i_lang      => i_lang,
                                                                                 i_code_mess => l_code_msg_ignore_result),
                                i_internal_name        => pk_edis_triage.g_vs_shock_index_ign_res,
                                i_flg_component_type   => l_flg_component_type,
                                i_flg_data_type        => pk_dynamic_screen.c_data_type_ms,
                                i_slg_internal_name    => NULL,
                                i_addit_info_xml_value => NULL,
                                i_rank                 => l_rank + 2,
                                i_max_len              => NULL,
                                i_min_value            => NULL,
                                i_max_value            => NULL,
                                io_tbl_sections        => l_final_tbl_sections);
            
                g_error := 'ADD DEF_EVENT - ' || pk_edis_triage.g_vs_shock_index_ign_res;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_new_def_event(i_pk              => l_ignore_result_pk,
                                  i_ds_cmpt_mkt_rel => l_ignore_result_pk,
                                  i_flg_event_type  => pk_alert_constant.g_active,
                                  io_tbl_def_events => l_tbl_def_events);
            
                g_error := 'CALL PK_LIST.GET_YES_NO_LIST';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                IF NOT pk_list.get_yes_no_list(i_lang => i_lang, o_list => c_list, o_error => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'ADD YES_NO ITEM_VALUES - ' || pk_edis_triage.g_vs_shock_index_ign_res;
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                LOOP
                    FETCH c_list
                        INTO l_desc_val, l_val, l_img_name, l_rank_aux;
                    EXIT WHEN c_list%NOTFOUND;
                
                    add_new_item(i_ds_cmpt_mkt_rel    => l_ignore_result_pk,
                                 i_ds_component       => l_ignore_result_pk,
                                 i_internal_name      => pk_edis_triage.g_vs_shock_index_ign_res,
                                 i_flg_component_type => l_flg_component_type,
                                 i_item_desc          => l_desc_val,
                                 i_item_value         => NULL,
                                 i_item_alt_value     => l_val,
                                 i_item_xml_value     => NULL,
                                 i_item_rank          => l_rank_aux,
                                 io_tbl_items_values  => l_tbl_items_values);
                END LOOP;
            
                CLOSE c_list;
            
                g_error := 'ADD SHOCK_INDEX SAVED DATA';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                add_vs_value(i_idx_section     => l_idx_shock_index_subform,
                             i_patient         => i_patient,
                             i_episode         => i_episode,
                             i_epis_triage     => i_epis_triage,
                             i_vital_sign      => r_vital_sign.vs.id_vital_sign,
                             i_vs_int_name     => r_vital_sign.vs.internal_name,
                             i_tbl_vital_signs => l_tbl_vital_signs);
            END add_shock_index_subform;
        
            PROCEDURE add_consent_field_values
            (
                i_lang               IN language.id_language%TYPE,
                i_id_discriminator   IN table_number DEFAULT NULL,
                i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
                i_ds_component       IN ds_component.id_ds_component%TYPE,
                i_internal_name      IN ds_component.internal_name%TYPE,
                i_flg_component_type IN ds_component.flg_component_type%TYPE,
                i_rank               IN PLS_INTEGER
            ) IS
                CURSOR c_cursor IS
                    SELECT tdc.id_triage_discriminator,
                           tdc.id_triage_cons_value,
                           pk_translation.get_translation(i_lang, tcv.code_triage_cons_value) desc_triage_cons_value,
                           tdc.flg_vs_mandatory,
                           tdc.flg_vs_enable,
                           tdc.flg_default,
                           tdc.rank
                      FROM triage_disc_consent tdc
                      JOIN triage_cons_value tcv
                        ON tcv.id_triage_cons_value = tdc.id_triage_cons_value
                     WHERE tdc.id_triage_discriminator = i_id_discriminator(1)
                     ORDER BY tdc.id_triage_discriminator, tdc.rank, desc_triage_cons_value;
            
                l_additional_info xmltype;
            
                l_code_msg_trg_disc_cons CONSTANT sys_message.code_message%TYPE := 'TRIAGE_DISC_CONSENT_M001';
                l_desc_msg_trg_disc_cons sys_message.desc_message%TYPE;
            
            BEGIN
                SELECT pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_msg_trg_disc_cons)
                  INTO l_desc_msg_trg_disc_cons
                  FROM dual;
            
                SELECT decode((SELECT COUNT(*)
                                FROM triage_disc_consent tdc
                               WHERE tdc.id_triage_discriminator = i_id_discriminator(1)),
                              0,
                              NULL,
                              l_desc_msg_trg_disc_cons)
                  INTO l_desc_msg_trg_disc_cons
                  FROM dual;
            
                add_new_section(i_ds_cmpt_mkt_rel     => i_ds_cmpt_mkt_rel,
                                i_ds_component_parent => i_ds_component_parent,
                                i_ds_component        => i_ds_cmpt_mkt_rel,
                                i_component_desc      => l_desc_msg_trg_disc_cons,
                                i_internal_name       => i_internal_name,
                                i_flg_component_type  => l_flg_component_type,
                                i_flg_data_type       => pk_dynamic_screen.c_data_type_ms,
                                i_rank                => i_rank,
                                io_tbl_sections       => l_final_tbl_sections);
            
                FOR i IN c_cursor
                LOOP
                
                    SELECT xmlelement("ADDITIONAL_INFO", xmlattributes(t.flg_default))
                      INTO l_additional_info
                      FROM (SELECT i.flg_default
                              FROM dual) t;
                
                    add_new_item(i_ds_cmpt_mkt_rel    => i_ds_cmpt_mkt_rel,
                                 i_ds_component       => i_ds_component,
                                 i_internal_name      => i_internal_name,
                                 i_flg_component_type => i_flg_component_type,
                                 i_item_desc          => i.desc_triage_cons_value,
                                 i_item_value         => i.id_triage_cons_value,
                                 i_item_alt_value     => i.flg_vs_enable,
                                 i_item_xml_value     => l_additional_info.getclobval(),
                                 i_item_rank          => i.rank,
                                 io_tbl_items_values  => l_tbl_items_values);
                END LOOP;
            
            END add_consent_field_values;
        
            FUNCTION get_vital_signs_mandatory
            (
                i_lang             IN language.id_language%TYPE,
                i_prof             IN profissional,
                i_id_discriminator IN triage_discriminator.id_triage_discriminator%TYPE,
                i_id_vital_sign    IN vital_sign.id_vital_sign%TYPE
            ) RETURN VARCHAR2 IS
                l_vital_sign_mand VARCHAR2(1);
            BEGIN
                SELECT md.flg_mandatory
                  INTO l_vital_sign_mand
                  FROM (SELECT column_value id_vital_sign, rownum rn
                          FROM TABLE(pk_utils.str_split_n(i_list  => pk_edis_triage.get_vs_list_by_field(i_lang,
                                                                                                         i_prof,
                                                                                                         i_id_discriminator,
                                                                                                         'ID_VITAL_SIGN'),
                                                          i_delim => ';'))) vs
                  JOIN (SELECT column_value flg_mandatory, rownum rn
                          FROM TABLE(pk_utils.str_split_c(p_list  => pk_edis_triage.get_vs_list_by_field(i_lang,
                                                                                                         i_prof,
                                                                                                         i_id_discriminator,
                                                                                                         'FLG_MANDATORY'),
                                                          p_delim => ';'))) md
                    ON md.rn = vs.rn
                 WHERE vs.id_vital_sign = i_id_vital_sign;
            
                RETURN l_vital_sign_mand;
            END get_vital_signs_mandatory;
        
        BEGIN
            g_error := 'CALL PK_EDIS_TRIAGE.TF_TRIAGE_VITAL_SIGNS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            l_tbl_triage_vs := pk_edis_triage.tf_triage_vital_signs(i_lang           => i_lang,
                                                                    i_prof           => i_prof,
                                                                    i_id_episode     => i_episode,
                                                                    i_tbl_id_context => i_tbl_id_context,
                                                                    i_flg_context    => i_flg_context);
        
            IF l_tbl_triage_vs IS NOT NULL
               AND l_tbl_triage_vs.count > 0
            THEN
                g_error := 'CALL PK_VITAL_SIGN.GET_VS_TRIAGE_HEADER';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                IF NOT pk_vital_sign.get_vs_triage_header(i_lang            => i_lang,
                                                          i_prof            => i_prof,
                                                          i_tbl_vital_sign  => l_tbl_triage_vs,
                                                          i_flg_view        => l_flg_view_t,
                                                          i_relation_domain => get_vs_relation_domain(i_tab_vital_sign => l_tbl_triage_vs),
                                                          i_patient         => i_patient,
                                                          o_sign_v          => c_sign_v,
                                                          o_error           => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                IF i_triage_discriminator IS NOT NULL
                THEN
                    g_error := 'IS TO ADD EVALUATION VS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name);
                    BEGIN
                        SELECT td.flg_assessment_type
                          INTO l_vs_evaluation
                          FROM triage_discriminator td
                         WHERE td.id_triage_discriminator = i_triage_discriminator;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_vs_evaluation := NULL;
                    END;
                
                    l_add_evaluation_vs := (l_vs_evaluation = l_disc_assessment_vs);
                END IF;
            
                IF l_id_triage_type = pk_edis_triage.g_triage_id_est
                THEN
                    g_error := 'GET PREGNANCY EXCLUSIVE VS''s';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name);
                    SELECT DISTINCT ttv.id_vital_sign
                      BULK COLLECT
                      INTO l_tbl_pregn_exclusive_vs
                      FROM triage_type_vs ttv
                     WHERE ttv.id_triage_type = pk_edis_triage.g_triage_id_est
                       AND ttv.flg_pregnant = pk_alert_constant.g_yes
                       AND NOT EXISTS (SELECT 1
                              FROM triage_type_vs ttv2
                             WHERE ttv2.id_triage_type = pk_edis_triage.g_triage_id_est
                               AND ttv2.id_vital_sign = ttv.id_vital_sign
                               AND ttv2.flg_pregnant = pk_alert_constant.g_no);
                
                    g_error := 'GET PK_DYNAMIC_SCREEN.TF_DS_EVENTS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name);
                    l_tbl_preg_ds_events := pk_dynamic_screen.tf_ds_events(i_lang           => i_lang,
                                                                           i_prof           => i_prof,
                                                                           i_component_name => pk_edis_triage.g_ds_comp_est_femme_enceinte,
                                                                           i_component_type => pk_dynamic_screen.c_leaf_component);
                
                    IF l_tbl_preg_ds_events IS NOT NULL
                       AND l_tbl_preg_ds_events.count > 0
                    THEN
                        g_error := 'LOOP THROUGH TBL_PREG_DS_EVENTS';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        FOR i IN l_tbl_preg_ds_events.first .. l_tbl_preg_ds_events.last
                        LOOP
                            IF l_tbl_preg_ds_events(i).value = pk_alert_constant.g_yes
                            THEN
                                l_preg_ds_event_yes := l_tbl_preg_ds_events(i);
                            ELSIF l_tbl_preg_ds_events(i).value = pk_alert_constant.g_no
                            THEN
                                l_preg_ds_event_no := l_tbl_preg_ds_events(i);
                            END IF;
                        END LOOP;
                    END IF;
                END IF;
                g_error := 'ADD VS TO SECTION TABLE';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                l_tbl_vital_signs := table_vital_signs();
            
                LOOP
                    FETCH c_sign_v
                        INTO r_sign_v;
                    EXIT WHEN c_sign_v%NOTFOUND;
                
                    IF r_sign_v.id_vital_sign_parent IS NULL
                       OR i_is_detail_call
                    THEN
                        IF NOT search_vs_and_add_child_vs()
                        THEN
                            r_vital_sign.id_ds_component := i_ds_component_parent || r_sign_v.id_vital_sign;
                            r_vital_sign.internal_name   := r_sign_v.internal_name;
                            r_vital_sign.id_vital_sign   := r_sign_v.id_vital_sign;
                            r_vital_sign.vs              := r_sign_v;
                            r_vital_sign.child_vs        := table_child_vs();
                        
                            l_tbl_vital_signs.extend();
                            l_tbl_vital_signs(l_tbl_vital_signs.count) := r_vital_sign;
                        END IF;
                    ELSE
                        IF NOT search_vs_and_add_child_vs()
                        THEN
                            r_vital_sign.id_ds_component := i_ds_component_parent || r_sign_v.id_vital_sign_parent;
                            r_vital_sign.internal_name   := r_sign_v.vs_parent_int_name;
                            r_vital_sign.id_vital_sign   := r_sign_v.id_vital_sign_parent;
                            r_vital_sign.vs              := NULL;
                            r_vital_sign.child_vs        := table_child_vs(r_sign_v);
                        
                            l_tbl_vital_signs.extend();
                            l_tbl_vital_signs(l_tbl_vital_signs.count) := r_vital_sign;
                        END IF;
                    END IF;
                END LOOP;
            
                CLOSE c_sign_v;
            
                IF l_tbl_vital_signs IS NOT NULL
                   AND l_tbl_vital_signs.count > 0
                THEN
                    IF l_add_evaluation_vs
                    THEN
                        g_error := 'ADD PATIENT AGE AS A VS - SECTION';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        add_new_section(i_ds_cmpt_mkt_rel      => i_ds_component_parent || l_ds_component_age,
                                        i_ds_component_parent  => i_ds_component_parent,
                                        i_ds_component         => i_ds_component_parent || l_ds_component_age,
                                        i_component_desc       => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_code_mess => l_code_msg_age),
                                        i_internal_name        => l_ds_int_name_age,
                                        i_flg_component_type   => l_flg_component_type,
                                        i_flg_data_type        => pk_dynamic_screen.c_data_type_n,
                                        i_slg_internal_name    => NULL,
                                        i_addit_info_xml_value => NULL,
                                        i_rank                 => l_rank,
                                        i_max_len              => NULL,
                                        i_min_value            => NULL,
                                        i_max_value            => NULL,
                                        io_tbl_sections        => l_final_tbl_sections);
                    
                        g_error := 'ADD PATIENT AGE AS A VS - DEF_EVENT';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        add_new_def_event(i_pk              => i_ds_component_parent || l_ds_component_age,
                                          i_ds_cmpt_mkt_rel => i_ds_component_parent || l_ds_component_age,
                                          i_flg_event_type  => pk_alert_constant.g_inactive,
                                          io_tbl_def_events => l_tbl_def_events);
                    
                        g_error := 'ADD PATIENT AGE AS A VS - VALUE';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        add_data_val(i_idx_section => l_final_tbl_sections.count,
                                     i_desc_value  => NULL,
                                     i_value       => pk_patient.get_pat_age(i_lang        => i_lang,
                                                                             i_dt_birth    => NULL,
                                                                             i_dt_deceased => NULL,
                                                                             i_age         => NULL,
                                                                             i_age_format  => 'YEARS',
                                                                             i_patient     => i_patient));
                    
                        l_rank := l_rank + 10;
                    END IF;
                
                    FOR i IN l_tbl_vital_signs.first .. l_tbl_vital_signs.last
                    LOOP
                        r_vital_sign := l_tbl_vital_signs(i);
                    
                        l_is_pregn_exclusive_vs := check_value_exists(i_table => l_tbl_pregn_exclusive_vs,
                                                                      i_value => r_vital_sign.vs.id_vital_sign);
                    
                        /*START*/
                        IF i_flg_context = pk_edis_triage.g_flg_context_id_triage_disc
                           AND i_tbl_id_context.exists(1)
                        THEN
                            --When calling add_vital_signs function with i_flg_context = 'D'iscriminator we only have one value in i_tbl_id_context
                            BEGIN
                                SELECT DISTINCT pk_alert_constant.g_yes, tdc.consent_group
                                  INTO l_discrim_with_consent, l_consent_group
                                  FROM triage_disc_consent tdc
                                 WHERE tdc.id_triage_discriminator = i_tbl_id_context(1)
                                   AND rownum = 1;
                            EXCEPTION
                                WHEN no_data_found THEN
                                    l_discrim_with_consent := pk_alert_constant.g_no;
                            END;
                        
                            --In this condition only enter one turn! has consent
                            IF l_discrim_with_consent = pk_alert_constant.g_yes
                               AND (NOT l_field_consent_added)
                            THEN
                                g_error := 'ADD CONSENT FIELD';
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                SELECT i_ds_component_parent || l_ds_component_consent || resultado.id_grp
                                  INTO l_id_ds_cmpt_mkt_rel
                                  FROM (SELECT tdc.consent_group, rownum id_grp
                                          FROM (SELECT DISTINCT t.consent_group
                                                  FROM triage_disc_consent t
                                                 ORDER BY t.consent_group) tdc) resultado
                                 WHERE resultado.consent_group = l_consent_group;
                            
                                add_new_def_event(i_pk              => l_id_ds_cmpt_mkt_rel,
                                                  i_ds_cmpt_mkt_rel => l_id_ds_cmpt_mkt_rel,
                                                  i_flg_event_type  => pk_dynamic_screen.g_event_mandatory,
                                                  io_tbl_def_events => l_tbl_def_events);
                            
                                add_consent_field_values(i_lang               => i_lang,
                                                         i_id_discriminator   => i_tbl_id_context,
                                                         i_ds_cmpt_mkt_rel    => l_id_ds_cmpt_mkt_rel,
                                                         i_ds_component       => l_id_ds_cmpt_mkt_rel,
                                                         i_internal_name      => l_consent_group,
                                                         i_flg_component_type => l_flg_component_type,
                                                         i_rank               => l_rank);
                            
                                l_field_consent_added := TRUE;
                            END IF;
                        
                            l_fgl_event_type := get_vital_signs_mandatory(i_lang             => i_lang,
                                                                          i_prof             => i_prof,
                                                                          i_id_discriminator => i_tbl_id_context(1),
                                                                          i_id_vital_sign    => r_vital_sign.id_vital_sign);
                        
                            FOR r_tdc IN (SELECT tdc.id_triage_cons_value,
                                                 (CASE
                                                      WHEN tdc.flg_vs_enable = pk_alert_constant.g_yes THEN
                                                       (CASE
                                                           WHEN l_fgl_event_type = pk_alert_constant.g_yes THEN
                                                            pk_dynamic_screen.g_event_mandatory
                                                           WHEN l_fgl_event_type = 'X' THEN
                                                            pk_dynamic_screen.g_event_active
                                                           WHEN tdc.flg_vs_mandatory = pk_alert_constant.g_yes THEN
                                                            pk_dynamic_screen.g_event_mandatory
                                                           ELSE
                                                            pk_dynamic_screen.g_event_active
                                                       END)
                                                      ELSE
                                                       pk_dynamic_screen.g_event_inactive
                                                  END) flg_mandatory
                                            FROM triage_disc_consent tdc
                                           WHERE tdc.id_triage_discriminator = i_tbl_id_context(1))
                            LOOP
                            
                                add_new_event_target(i_ds_event             => l_id_ds_cmpt_mkt_rel ||
                                                                               r_tdc.id_triage_cons_value, --to define an single id_ds_event
                                                     i_orig_ds_cmpt_mkt_rel => l_id_ds_cmpt_mkt_rel,
                                                     i_value                => r_tdc.id_triage_cons_value,
                                                     i_targ_ds_cmpt_mkt_rel => i_ds_component_parent ||
                                                                               r_vital_sign.vs.id_vital_sign,
                                                     i_flg_event_type       => r_tdc.flg_mandatory,
                                                     io_tbl_events          => l_tbl_events);
                            END LOOP;
                        END IF;
                        /*END*/
                        IF NOT l_is_pregn_exclusive_vs
                           OR (l_is_pregn_exclusive_vs AND l_pat_gender = pk_patient.g_pat_gender_female AND
                           l_pregn_area_available = pk_alert_constant.g_yes)
                        THEN
                            IF r_vital_sign.child_vs.count = 0
                            THEN
                                SELECT xmlelement("VITAL_SIGN",
                                                  xmlattributes(a.id_vital_sign, --
                                                                a.internal_name, --
                                                                a.val_min, --
                                                                a.val_max, --
                                                                a.rank_conc, --
                                                                a.id_vital_sign_parent, --
                                                                a.relation_type, --
                                                                a.format_num, --
                                                                a.flg_fill_type, --
                                                                a.flg_sum, --
                                                                a.name_vs, --
                                                                a.desc_unit_measure, --
                                                                a.id_unit_measure, --
                                                                a.dt_server, --
                                                                a.vs_flg_type, --
                                                                a.flg_validate, --
                                                                a.flg_save_to_db, --
                                                                a.flg_show_description, --
                                                                a.flg_calculate_trts))
                                  INTO l_xml_value
                                  FROM (SELECT r_vital_sign.vs.id_vital_sign,
                                               r_vital_sign.vs.internal_name,
                                               r_vital_sign.vs.val_min,
                                               r_vital_sign.vs.val_max,
                                               r_vital_sign.vs.rank_conc,
                                               r_vital_sign.vs.id_vital_sign_parent,
                                               r_vital_sign.vs.relation_type,
                                               r_vital_sign.vs.format_num,
                                               r_vital_sign.vs.flg_fill_type,
                                               r_vital_sign.vs.flg_sum,
                                               r_vital_sign.vs.name_vs,
                                               r_vital_sign.vs.desc_unit_measure,
                                               r_vital_sign.vs.id_unit_measure,
                                               r_vital_sign.vs.dt_server,
                                               r_vital_sign.vs.vs_flg_type,
                                               r_vital_sign.vs.flg_validate,
                                               r_vital_sign.vs.flg_save_to_db,
                                               r_vital_sign.vs.flg_show_description,
                                               r_vital_sign.vs.flg_calculate_trts
                                          FROM dual) a;
                            ELSE
                                l_xml_value := xmltype('<NOT></NOT>');
                            
                                IF r_vital_sign.child_vs IS NOT NULL
                                   AND r_vital_sign.child_vs.count > 0
                                THEN
                                    SELECT xmlelement("VITAL_SIGN_PARENT",
                                                      xmlattributes(a.id_vital_sign, --
                                                                    a.internal_name, --
                                                                    a.val_min, --
                                                                    a.val_max, --
                                                                    a.rank_conc, --
                                                                    a.id_vital_sign_parent, --
                                                                    a.relation_type, --
                                                                    a.format_num, --
                                                                    a.flg_fill_type, --
                                                                    a.flg_sum, --
                                                                    a.name_vs, --
                                                                    a.desc_unit_measure, --
                                                                    a.id_unit_measure, --
                                                                    a.dt_server, --
                                                                    a.vs_flg_type, --
                                                                    a.flg_validate, --
                                                                    a.flg_save_to_db, --
                                                                    a.flg_show_description, --
                                                                    a.flg_calculate_trts))
                                      INTO l_xml_parent_value
                                      FROM (SELECT r_vital_sign.vs.id_vital_sign,
                                                   r_vital_sign.vs.internal_name,
                                                   r_vital_sign.vs.val_min,
                                                   r_vital_sign.vs.val_max,
                                                   r_vital_sign.vs.rank_conc,
                                                   r_vital_sign.vs.id_vital_sign_parent,
                                                   r_vital_sign.vs.relation_type,
                                                   r_vital_sign.vs.format_num,
                                                   r_vital_sign.vs.flg_fill_type,
                                                   r_vital_sign.vs.flg_sum,
                                                   r_vital_sign.vs.name_vs,
                                                   r_vital_sign.vs.desc_unit_measure,
                                                   r_vital_sign.vs.id_unit_measure,
                                                   r_vital_sign.vs.dt_server,
                                                   r_vital_sign.vs.vs_flg_type,
                                                   r_vital_sign.vs.flg_validate,
                                                   r_vital_sign.vs.flg_save_to_db,
                                                   r_vital_sign.vs.flg_show_description,
                                                   r_vital_sign.vs.flg_calculate_trts
                                              FROM dual) a;
                                
                                    l_xml_value := NULL;
                                    FOR j IN r_vital_sign.child_vs.first .. r_vital_sign.child_vs.last
                                    LOOP
                                        r_sign_v := r_vital_sign.child_vs(j);
                                    
                                        SELECT xmlconcat(l_xml_value,
                                                         xmlagg(xmlelement("VITAL_SIGN",
                                                                           xmlattributes(a.id_vital_sign, --
                                                                                         a.internal_name, --
                                                                                         a.val_min, --
                                                                                         a.val_max, --
                                                                                         a.rank_conc, --
                                                                                         a.id_vital_sign_parent, --
                                                                                         a.vs_parent_int_name, --
                                                                                         a.relation_type, --
                                                                                         a.format_num, --
                                                                                         a.flg_fill_type, --
                                                                                         a.flg_sum, --
                                                                                         a.name_vs, --
                                                                                         a.desc_unit_measure, --
                                                                                         a.id_unit_measure, --
                                                                                         a.dt_server, --
                                                                                         a.vs_flg_type, --
                                                                                         a.flg_validate, --
                                                                                         a.flg_save_to_db, --
                                                                                         a.flg_show_description, --
                                                                                         a.flg_calculate_trts))))
                                          INTO l_xml_value
                                          FROM (SELECT r_sign_v.id_vital_sign,
                                                       r_sign_v.internal_name,
                                                       r_sign_v.val_min,
                                                       r_sign_v.val_max,
                                                       r_sign_v.rank_conc,
                                                       r_sign_v.id_vital_sign_parent,
                                                       r_sign_v.vs_parent_int_name,
                                                       r_sign_v.relation_type,
                                                       r_sign_v.format_num,
                                                       r_sign_v.flg_fill_type,
                                                       r_sign_v.flg_sum,
                                                       r_sign_v.name_vs,
                                                       r_sign_v.desc_unit_measure,
                                                       r_sign_v.id_unit_measure,
                                                       r_sign_v.dt_server,
                                                       r_sign_v.vs_flg_type,
                                                       r_sign_v.flg_validate,
                                                       r_sign_v.flg_save_to_db,
                                                       r_sign_v.flg_show_description,
                                                       r_sign_v.flg_calculate_trts
                                                  FROM dual) a;
                                    END LOOP;
                                
                                    SELECT appendchildxml(l_xml_parent_value,
                                                          l_xml_parent_value.getrootelement(),
                                                          l_xml_value)
                                      INTO l_xml_value
                                      FROM dual;
                                ELSE
                                    l_xml_value := xmltype('');
                                END IF;
                            END IF;
                        
                            IF r_vital_sign.internal_name = pk_edis_triage.g_vs_shock_index
                            THEN
                                --ALERT-275364 - EST New requirement: The system must provide the ability to ignore the urgency level obtained by the index the choc whenever required
                                add_shock_index_subform;
                            ELSE
                                add_new_item(i_ds_cmpt_mkt_rel    => r_vital_sign.id_ds_component,
                                             i_ds_component       => r_vital_sign.id_ds_component,
                                             i_internal_name      => r_vital_sign.internal_name,
                                             i_flg_component_type => l_flg_component_type,
                                             i_item_desc          => r_vital_sign.vs.name_vs,
                                             i_item_value         => r_vital_sign.vs.id_vital_sign,
                                             i_item_alt_value     => g_flg_data_type_vs,
                                             i_item_xml_value     => l_xml_value.getclobval(),
                                             i_item_rank          => l_rank,
                                             io_tbl_items_values  => l_tbl_items_values);
                            
                                g_error := 'NEW T_REC_DS_SECTIONS INSTANCE';
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                add_new_section(i_ds_cmpt_mkt_rel      => r_vital_sign.id_ds_component,
                                                i_ds_component_parent  => i_ds_component_parent,
                                                i_ds_component         => r_vital_sign.id_ds_component,
                                                i_component_desc       => r_vital_sign.vs.name_vs,
                                                i_internal_name        => r_vital_sign.internal_name,
                                                i_flg_component_type   => l_flg_component_type,
                                                i_flg_data_type        => g_flg_data_type_vs,
                                                i_slg_internal_name    => NULL,
                                                i_addit_info_xml_value => NULL,
                                                i_rank                 => l_rank,
                                                i_max_len              => NULL,
                                                i_min_value            => r_vital_sign.vs.val_min,
                                                i_max_value            => r_vital_sign.vs.val_max,
                                                io_tbl_sections        => l_final_tbl_sections);
                            END IF;
                        
                            IF l_is_pregn_exclusive_vs
                            THEN
                                IF (l_rec_preg.flg_pregnant = pk_alert_constant.g_yes AND
                                   l_discrim_with_consent = pk_alert_constant.g_no)
                                THEN
                                    g_error := 'NEW DEFAULT EVENT';
                                    pk_alertlog.log_debug(text            => g_error,
                                                          object_name     => g_package_name,
                                                          sub_object_name => l_inner_proc_name);
                                    add_new_def_event(i_pk              => r_vital_sign.id_ds_component,
                                                      i_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                      i_flg_event_type  => pk_alert_constant.g_active,
                                                      io_tbl_def_events => l_tbl_def_events);
                                ELSE
                                    g_error := 'NEW DEFAULT EVENT';
                                    pk_alertlog.log_debug(text            => g_error,
                                                          object_name     => g_package_name,
                                                          sub_object_name => l_inner_proc_name);
                                    add_new_def_event(i_pk              => r_vital_sign.id_ds_component,
                                                      i_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                      i_flg_event_type  => pk_alert_constant.g_inactive,
                                                      io_tbl_def_events => l_tbl_def_events);
                                END IF;
                            
                                g_error := 'NEW EVENT - YES - ' || r_vital_sign.vs.id_vital_sign;
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                add_new_event_target(i_ds_event             => l_preg_ds_event_yes.id_ds_event,
                                                     i_orig_ds_cmpt_mkt_rel => l_preg_ds_event_yes.origin,
                                                     i_value                => l_preg_ds_event_yes.value,
                                                     i_targ_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                     i_flg_event_type       => pk_alert_constant.g_active,
                                                     io_tbl_events          => l_tbl_events);
                            
                                g_error := 'NEW EVENT - NO - ' || r_vital_sign.vs.id_vital_sign;
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                add_new_event_target(i_ds_event             => l_preg_ds_event_no.id_ds_event,
                                                     i_orig_ds_cmpt_mkt_rel => l_preg_ds_event_no.origin,
                                                     i_value                => l_preg_ds_event_no.value,
                                                     i_targ_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                     i_flg_event_type       => pk_alert_constant.g_inactive,
                                                     io_tbl_events          => l_tbl_events);
                            ELSIF r_vital_sign.internal_name = pk_edis_triage.g_vs_shock_index
                            THEN
                                g_error := 'DEFAULT EVENT - ' || r_vital_sign.internal_name;
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                add_new_def_event(i_pk              => r_vital_sign.id_ds_component,
                                                  i_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                  i_flg_event_type  => pk_alert_constant.g_inactive,
                                                  io_tbl_def_events => l_tbl_def_events);
                            ELSE
                                IF l_discrim_with_consent = pk_alert_constant.g_yes
                                THEN
                                    g_error := 'NEW DEFAULT EVENT';
                                    pk_alertlog.log_debug(text            => g_error,
                                                          object_name     => g_package_name,
                                                          sub_object_name => l_inner_proc_name);
                                    add_new_def_event(i_pk              => r_vital_sign.id_ds_component,
                                                      i_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                      i_flg_event_type  => pk_alert_constant.g_inactive,
                                                      io_tbl_def_events => l_tbl_def_events);
                                ELSE
                                    g_error := 'NEW DEFAULT EVENT';
                                    pk_alertlog.log_debug(text            => g_error,
                                                          object_name     => g_package_name,
                                                          sub_object_name => l_inner_proc_name);
                                    add_new_def_event(i_pk              => r_vital_sign.id_ds_component,
                                                      i_ds_cmpt_mkt_rel => r_vital_sign.id_ds_component,
                                                      i_flg_event_type  => pk_alert_constant.g_active,
                                                      io_tbl_def_events => l_tbl_def_events);
                                END IF;
                            END IF;
                        
                            IF r_vital_sign.internal_name != pk_edis_triage.g_vs_shock_index
                            THEN
                                g_error := 'ADD VITAL_SIGN SAVED DATA';
                                pk_alertlog.log_debug(text            => g_error,
                                                      object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name);
                                add_vs_value(i_idx_section     => l_final_tbl_sections.count,
                                             i_patient         => i_patient,
                                             i_episode         => i_episode,
                                             i_epis_triage     => i_epis_triage,
                                             i_vital_sign      => r_vital_sign.vs.id_vital_sign,
                                             i_vs_int_name     => r_vital_sign.vs.internal_name,
                                             i_tbl_vital_signs => l_tbl_vital_signs);
                            END IF;
                        
                            l_rank := l_rank + 10;
                        END IF;
                    END LOOP;
                
                    IF l_add_evaluation_vs
                    THEN
                        g_error := 'ADD TRIAGE_DISCRIM_CHILD AS A VS - SECTION';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        add_new_section(i_ds_cmpt_mkt_rel      => i_ds_component_parent || l_ds_component_vs_crit,
                                        i_ds_component_parent  => i_ds_component_parent,
                                        i_ds_component         => i_ds_component_parent || l_ds_component_vs_crit,
                                        i_component_desc       => pk_message.get_message(i_lang      => i_lang,
                                                                                         i_code_mess => l_code_msg_vs_crit),
                                        i_internal_name        => l_ds_int_name_vs_crit,
                                        i_flg_component_type   => l_flg_component_type,
                                        i_flg_data_type        => pk_dynamic_screen.c_data_type_ms,
                                        i_slg_internal_name    => NULL,
                                        i_addit_info_xml_value => NULL,
                                        i_rank                 => l_rank,
                                        i_max_len              => NULL,
                                        i_min_value            => NULL,
                                        i_max_value            => NULL,
                                        io_tbl_sections        => l_final_tbl_sections);
                    
                        g_error := 'ADD TRIAGE_DISCRIM_CHILD AS A VS - DEF_EVENT';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        add_new_def_event(i_pk              => i_ds_component_parent || l_ds_component_vs_crit,
                                          i_ds_cmpt_mkt_rel => i_ds_component_parent || l_ds_component_vs_crit,
                                          i_flg_event_type  => pk_alert_constant.g_inactive,
                                          io_tbl_def_events => l_tbl_def_events);
                    
                        g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_DISCRIM_CHILD';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        IF NOT pk_edis_triage.get_triage_discrim_child(i_lang          => i_lang,
                                                                       i_prof          => i_prof,
                                                                       i_id_disc       => i_triage_discriminator,
                                                                       i_id_patient    => i_patient,
                                                                       o_discrim_child => c_discrim_child,
                                                                       o_error         => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        g_error := 'ADD TRIAGE_DISCRIM_CHILD AS A VS - MC ITEMS';
                        pk_alertlog.log_debug(text            => g_error,
                                              object_name     => g_package_name,
                                              sub_object_name => l_inner_proc_name);
                        LOOP
                            FETCH c_discrim_child
                                INTO r_discrim_child;
                            EXIT WHEN c_discrim_child%NOTFOUND;
                        
                            SELECT xmlelement("DISCRIM_CHILD",
                                              xmlattributes(a.id_triage, --
                                                            a.id_triage_color, --
                                                            a.id_triage_color_other, --
                                                            a.color_text, --
                                                            a.acuity, --
                                                            a.id_triage_discriminator, --
                                                            a.desc_discriminator, --
                                                            a.flg_accepted_option, --
                                                            a.flg_accuity_confirmation, --
                                                            a.flg_select_option, --
                                                            a.esi_level_header))
                              INTO l_xml_value
                              FROM (SELECT r_discrim_child.id_triage,
                                           r_discrim_child.id_triage_color,
                                           r_discrim_child.id_triage_color_other,
                                           r_discrim_child.color_text,
                                           r_discrim_child.acuity,
                                           r_discrim_child.id_triage_discriminator,
                                           r_discrim_child.desc_discriminator,
                                           r_discrim_child.flg_accepted_option,
                                           r_discrim_child.flg_accuity_confirmation,
                                           r_discrim_child.flg_select_option,
                                           r_discrim_child.esi_level_header
                                      FROM dual) a;
                        
                            add_new_item(i_ds_cmpt_mkt_rel    => i_ds_component_parent || l_ds_component_vs_crit,
                                         i_ds_component       => i_ds_component_parent || l_ds_component_vs_crit,
                                         i_internal_name      => l_ds_int_name_vs_crit,
                                         i_flg_component_type => l_flg_component_type,
                                         i_item_desc          => r_discrim_child.desc_discriminator,
                                         i_item_value         => r_discrim_child.id_triage_discriminator,
                                         i_item_alt_value     => NULL, --TODO: This flag must be changed when UX starts using this
                                         i_item_xml_value     => l_xml_value.getclobval(),
                                         i_item_rank          => l_rank,
                                         io_tbl_items_values  => l_tbl_items_values);
                        
                            l_rank := l_rank + 10;
                        END LOOP;
                    
                        CLOSE c_discrim_child;
                    END IF;
                END IF;
            END IF;
        END add_vital_signs;
    
        PROCEDURE get_anamnesis IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'GET_ANAMNESIS';
            --
            c_complaints pk_types.cursor_type;
            c_anamnesis  pk_edis_triage.cursor_anamnesis;
        BEGIN
            IF NOT l_anamnesis_already_called
            THEN
                g_error := 'CALL GET_COMPLAINT_TRIAGE';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                IF NOT pk_edis_triage.get_complaint_triage(i_lang      => i_lang,
                                                           i_prof      => i_prof,
                                                           i_epis      => i_episode,
                                                           o_comp_t    => c_complaints,
                                                           o_anamnesis => c_anamnesis,
                                                           o_error     => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                --Only first record is needed
                FETCH c_anamnesis
                    INTO r_anamnesis;
            
                CLOSE c_anamnesis;
            
                l_anamnesis_already_called := TRUE;
            END IF;
        END get_anamnesis;
    
        PROCEDURE get_arrive IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'GET_ARRIVE';
            --
            c_arrive pk_edis_proc.cursor_arrive;
        BEGIN
            IF NOT l_arrive_already_called
            THEN
                g_error := 'CALL PK_EDIS_PROC.GET_ARRIVE';
                pk_alertlog.log_debug(text            => g_error,
                                      object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name);
                IF NOT pk_edis_proc.get_arrive(i_lang    => i_lang,
                                               i_prof    => i_prof,
                                               i_id_epis => i_episode,
                                               o_arrive  => c_arrive,
                                               o_error   => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                --Only first record is needed
                FETCH c_arrive
                    INTO r_arrive;
            
                CLOSE c_arrive;
            
                l_arrive_already_called := TRUE;
            END IF;
        END get_arrive;
    
        PROCEDURE fill_pregnancy_rec IS
            l_ds_cmpt_mkt_rel_pk ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE;
        BEGIN
        
            l_rec_preg.flg_pregnant := pk_pregnancy.check_pat_is_preg(i_lang    => i_lang,
                                                                      i_prof    => i_prof,
                                                                      i_patient => i_patient);
        
            l_rec_preg.desc_pregnant := pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                                            i_prof              => i_prof,
                                                                            i_grp_internal_name => pk_edis_triage.g_ds_comp_lst_yes_no,
                                                                            i_flg_context       => l_rec_preg.flg_pregnant);
        
            l_rec_preg.pregnancy_weeks := pk_pregnancy.get_pregnancy_num_weeks(i_lang => i_lang,
                                                                               i_prof => i_prof,
                                                                               i_pat  => i_patient);
        
            --Remove weeks description because the label already has mentions it
            --IF l_rec_preg.pregnancy_weeks IS NOT NULL
            --THEN
            --    l_rec_preg.desc_weeks := l_rec_preg.pregnancy_weeks || ' ' ||
            --                             pk_message.get_message(i_lang      => i_lang,
            --                                                    i_code_mess => pk_pregnancy.g_code_msg_weeks);
            --END IF;
        
            l_rec_preg.flg_postpartum := pk_pregnancy.check_pat_1month_pos_partum(i_lang    => i_lang,
                                                                                  i_prof    => i_prof,
                                                                                  i_patient => i_patient);
        
            l_rec_preg.desc_postpartum := pk_sys_list.get_sys_list_value_desc(i_lang              => i_lang,
                                                                              i_prof              => i_prof,
                                                                              i_grp_internal_name => pk_edis_triage.g_ds_comp_lst_yes_no,
                                                                              i_flg_context       => l_rec_preg.flg_postpartum);
        
            IF l_rec_preg.flg_pregnant = pk_alert_constant.g_yes
            THEN
                BEGIN
                    SELECT t.id_ds_cmpt_mkt_rel
                      INTO l_ds_cmpt_mkt_rel_pk
                      FROM TABLE(l_tbl_sections) t
                     WHERE t.internal_name IN (pk_edis_triage.g_ds_comp_est_femme_1mois_pp);
                
                    IF l_tbl_def_events.exists(1)
                    THEN
                        FOR i IN l_tbl_def_events.first .. l_tbl_def_events.last
                        LOOP
                            IF l_tbl_def_events(i).id_ds_cmpt_mkt_rel = l_ds_cmpt_mkt_rel_pk
                            THEN
                                l_tbl_def_events(i).flg_event_type := pk_alert_constant.g_inactive;
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            ELSIF l_rec_preg.flg_postpartum = pk_alert_constant.g_yes
            THEN
                BEGIN
                    SELECT t.id_ds_cmpt_mkt_rel
                      INTO l_ds_cmpt_mkt_rel_pk
                      FROM TABLE(l_tbl_sections) t
                     WHERE t.internal_name IN (pk_edis_triage.g_ds_comp_est_femme_enc_fr);
                
                    IF l_tbl_def_events.exists(1)
                    THEN
                        FOR i IN l_tbl_def_events.first .. l_tbl_def_events.last
                        LOOP
                            IF l_tbl_def_events(i).id_ds_cmpt_mkt_rel = l_ds_cmpt_mkt_rel_pk
                            THEN
                                l_tbl_def_events(i).flg_event_type := pk_alert_constant.g_inactive;
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL;
                END;
            END IF;
        END fill_pregnancy_rec;
    
        PROCEDURE remove_pregn_questions
        (
            io_section      IN OUT t_table_ds_sections,
            io_def_events   IN OUT t_table_ds_def_events,
            io_events       IN OUT t_table_ds_events,
            io_items_values IN OUT t_table_ds_items_values
        ) IS
            l_section      t_table_ds_sections;
            l_def_events   t_table_ds_def_events;
            l_events       t_table_ds_events;
            l_items_values t_table_ds_items_values;
            --
            r_section    t_rec_ds_sections;
            r_def_events t_rec_ds_def_events;
            r_event      t_rec_ds_events;
            r_item_value t_rec_ds_items_values;
        
        BEGIN
            l_section      := io_section;
            l_def_events   := io_def_events;
            l_events       := io_events;
            l_items_values := io_items_values;
        
            FOR r_section IN (SELECT *
                                FROM TABLE(io_section) t
                               WHERE t.internal_name IN (pk_edis_triage.g_ds_comp_est_femme_enc_fr,
                                                         pk_edis_triage.g_ds_comp_est_femme_enceinte,
                                                         pk_edis_triage.g_ds_comp_est_femme_encnt_wks,
                                                         pk_edis_triage.g_ds_comp_est_femme_1mois_pp))
            LOOP
                --REMOVE SECTION
                FOR i IN io_section.first .. io_section.last
                LOOP
                    IF io_section(i).id_ds_cmpt_mkt_rel = r_section.id_ds_cmpt_mkt_rel
                        AND l_section.exists(i)
                    THEN
                        l_section.delete(i);
                        EXIT;
                    END IF;
                END LOOP;
            
                --REMOVE DEFAULT EVENTS
                IF io_def_events IS NOT NULL
                   AND io_def_events.count > 0
                THEN
                    FOR i IN io_def_events.first .. io_def_events.last
                    LOOP
                        IF io_def_events(i).id_ds_cmpt_mkt_rel = r_section.id_ds_cmpt_mkt_rel
                            AND l_def_events.exists(i)
                        THEN
                            l_def_events.delete(i);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                IF io_events IS NOT NULL
                   AND io_events.count > 0
                THEN
                    FOR r_event IN (SELECT *
                                      FROM TABLE(io_events) t
                                     WHERE r_section.id_ds_cmpt_mkt_rel IN (t.origin, t.target))
                    LOOP
                        --REMOVE EVENTS
                        FOR i IN io_events.first .. io_events.last
                        LOOP
                            IF io_events(i).id_ds_event = r_event.id_ds_event
                                AND l_events.exists(i)
                            THEN
                                l_events.delete(i);
                                EXIT;
                            END IF;
                        END LOOP;
                    END LOOP;
                END IF;
            
                IF io_items_values IS NOT NULL
                   AND io_items_values.count > 0
                THEN
                    --REMOVE ITEM_VALUES
                    FOR i IN io_items_values.first .. io_items_values.last
                    LOOP
                        IF io_items_values(i).id_ds_cmpt_mkt_rel = r_section.id_ds_cmpt_mkt_rel
                            AND l_items_values.exists(i)
                        THEN
                            l_items_values.delete(i);
                        END IF;
                    END LOOP;
                END IF;
            END LOOP;
        
            --RESET INDEXES
            io_section := t_table_ds_sections();
            FOR r_section IN (SELECT *
                                FROM TABLE(l_section))
            LOOP
                io_section.extend;
                io_section(io_section.count) := t_rec_ds_sections(id_ds_cmpt_mkt_rel     => r_section.id_ds_cmpt_mkt_rel,
                                                                  id_ds_component_parent => r_section.id_ds_component_parent,
                                                                  id_ds_component        => r_section.id_ds_component,
                                                                  component_desc         => r_section.component_desc,
                                                                  internal_name          => r_section.internal_name,
                                                                  flg_component_type     => r_section.flg_component_type,
                                                                  flg_data_type          => r_section.flg_data_type,
                                                                  slg_internal_name      => r_section.slg_internal_name,
                                                                  addit_info_xml_value   => r_section.addit_info_xml_value,
                                                                  rank                   => r_section.rank,
                                                                  max_len                => r_section.max_len,
                                                                  min_value              => r_section.min_value,
                                                                  max_value              => r_section.max_value);
            END LOOP;
        
            io_def_events := t_table_ds_def_events();
            FOR r_def_events IN (SELECT *
                                   FROM TABLE(l_def_events))
            LOOP
                io_def_events.extend;
                io_def_events(io_def_events.count) := t_rec_ds_def_events(id_ds_cmpt_mkt_rel => r_def_events.id_ds_cmpt_mkt_rel,
                                                                          id_def_event       => r_def_events.id_def_event,
                                                                          flg_event_type     => r_def_events.flg_event_type);
            END LOOP;
        
            io_events := t_table_ds_events();
            FOR r_event IN (SELECT *
                              FROM TABLE(l_events))
            LOOP
                io_events.extend;
                io_events(io_events.count) := t_rec_ds_events(id_ds_event    => r_event.id_ds_event,
                                                              origin         => r_event.origin,
                                                              VALUE          => r_event.value,
                                                              target         => r_event.target,
                                                              flg_event_type => r_event.flg_event_type);
            END LOOP;
        
            io_items_values := t_table_ds_items_values();
            FOR r_item_value IN (SELECT *
                                   FROM TABLE(l_items_values))
            LOOP
                io_items_values.extend;
                io_items_values(io_items_values.count) := t_rec_ds_items_values(id_ds_cmpt_mkt_rel => r_item_value.id_ds_cmpt_mkt_rel,
                                                                                id_ds_component    => r_item_value.id_ds_component,
                                                                                internal_name      => r_item_value.internal_name,
                                                                                flg_component_type => r_item_value.flg_component_type,
                                                                                item_desc          => r_item_value.item_desc,
                                                                                item_value         => r_item_value.item_value,
                                                                                item_alt_value     => r_item_value.item_alt_value,
                                                                                item_xml_value     => r_item_value.item_xml_value,
                                                                                item_rank          => r_item_value.item_rank);
            END LOOP;
        END remove_pregn_questions;
    
        PROCEDURE inact_weeks_def_event IS
            l_ds_cmpt_femme_encnt_wks ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE;
        BEGIN
            SELECT t.id_ds_cmpt_mkt_rel
              INTO l_ds_cmpt_femme_encnt_wks
              FROM TABLE(l_tbl_sections) t
             WHERE t.internal_name IN (pk_edis_triage.g_ds_comp_est_femme_encnt_wks);
        
            IF l_tbl_def_events IS NOT NULL
               AND l_tbl_def_events.count > 0
            THEN
                FOR i IN l_tbl_def_events.first .. l_tbl_def_events.last
                LOOP
                    IF l_tbl_def_events(i).id_ds_cmpt_mkt_rel = l_ds_cmpt_femme_encnt_wks
                    THEN
                        l_tbl_def_events(i).flg_event_type := pk_alert_constant.g_inactive;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END inact_weeks_def_event;
    
        PROCEDURE no_mand_chief_compl_def_event IS
            l_g_ds_comp_chief_comp ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE;
        BEGIN
            SELECT t.id_ds_cmpt_mkt_rel
              INTO l_g_ds_comp_chief_comp
              FROM TABLE(l_tbl_sections) t
             WHERE t.internal_name IN (pk_edis_triage.g_ds_comp_chief_comp);
        
            IF l_tbl_def_events IS NOT NULL
               AND l_tbl_def_events.count > 0
            THEN
                FOR i IN l_tbl_def_events.first .. l_tbl_def_events.last
                LOOP
                    IF l_tbl_def_events(i).id_ds_cmpt_mkt_rel = l_g_ds_comp_chief_comp
                    THEN
                        l_tbl_def_events(i).flg_event_type := pk_alert_constant.g_active;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END no_mand_chief_compl_def_event;
    
        PROCEDURE add_external_cause
        (
            i_ds_cmpt_mkt_rel    IN ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE,
            i_ds_component       IN ds_component.id_ds_component%TYPE,
            i_internal_name      IN ds_component.internal_name%TYPE,
            i_flg_component_type IN ds_component.flg_component_type%TYPE
        ) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'ADD_EXTERNAL_CAUSE';
        
            --
            CURSOR c_external_cause IS
                SELECT id_external_cause, desc_external_cause
                  FROM (SELECT ec.id_external_cause,
                               pk_translation.get_translation(i_lang, ec.code_external_cause) desc_external_cause
                          FROM external_cause ec
                         WHERE flg_available = g_yes
                         ORDER BY 2 ASC)
                 WHERE desc_external_cause IS NOT NULL;
        
            r_external_cause c_external_cause%ROWTYPE;
        
        BEGIN
            g_error := 'ADD EXTERNAL_CAUSE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_inner_proc_name);
            OPEN c_external_cause;
            LOOP
                FETCH c_external_cause
                    INTO r_external_cause;
                EXIT WHEN c_external_cause%NOTFOUND;
            
                add_new_item(i_ds_cmpt_mkt_rel    => i_ds_cmpt_mkt_rel,
                             i_ds_component       => i_ds_component,
                             i_internal_name      => i_internal_name,
                             i_flg_component_type => i_flg_component_type,
                             i_item_desc          => r_external_cause.desc_external_cause,
                             i_item_value         => r_external_cause.id_external_cause,
                             i_item_alt_value     => NULL,
                             i_item_rank          => NULL,
                             io_tbl_items_values  => l_tbl_items_values);
            END LOOP;
        
            CLOSE c_external_cause;
        END add_external_cause;
    BEGIN
        g_error := 'LOAD SYS_CFG TRIAGE_EST_SHOW_NEEDS_AND_TRANSPORT';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_needs_arrived_cfg   := pk_sysconfig.get_config('TRIAGE_EST_SHOW_NEEDS_AND_TRANSPORT', i_prof);
        l_needs_complaint_cfg := pk_sysconfig.get_config('TRIAGE_CTAS_COMPLAINT_MANDATORY', i_prof);
        g_error               := 'CALL GET_PAT_GENDER';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_pat_gender := pk_patient.get_pat_gender(i_id_patient => i_patient);
    
        IF l_pat_gender = pk_patient.g_pat_gender_female
        THEN
        
            IF NOT pk_woman_health.get_pat_preg_avail(i_lang             => i_lang,
                                                      i_patient          => i_patient,
                                                      i_prof             => i_prof,
                                                      o_avail            => l_pregn_area_available,
                                                      o_dt_min           => l_pregn_area_av_min_dt,
                                                      o_id_pat_pregnancy => l_id_pat_pregnancy,
                                                      o_dt_preg_init     => l_dt_preg_init,
                                                      o_dt_preg_end      => l_dt_preg_end,
                                                      o_error            => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
        g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_TYPE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_id_triage_type := pk_edis_triage.get_triage_type(i_lang => i_lang,
                                                           i_prof => i_prof,
                                                           
                                                           i_episode => i_episode);
    
        l_triage_ds_component := get_triage_config_by_name(i_lang,
                                                           i_prof,
                                                           i_episode,
                                                           l_id_triage_type,
                                                           'ID_TRIAGE_DS_COMPONENT');
    
        SELECT tdc.internal_name, tdc.flg_component_type
          INTO l_component_name_root, l_component_type_root
          FROM triage_ds_component tdc
         WHERE tdc.id_triage_ds_component = l_triage_ds_component;
        IF i_component_name IS NOT NULL
        THEN
            g_error := 'CALL PK_DYNAMIC_SCREEN.GET_DS_SECTION_COMPLETE_STRUCT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT pk_dynamic_screen.get_ds_section_complete_struct(i_lang           => i_lang,
                                                                    i_prof           => i_prof,
                                                                    i_component_name => i_component_name,
                                                                    i_component_type => i_component_type,
                                                                    i_patient        => i_patient,
                                                                    i_component_root => l_component_name_root,
                                                                    o_section        => l_tbl_sections,
                                                                    o_def_events     => l_tbl_def_events,
                                                                    o_events         => l_tbl_events,
                                                                    o_items_values   => l_tbl_items_values,
                                                                    o_error          => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            --If it's a men then remove pregnancy questions
            IF l_pat_gender != pk_patient.g_pat_gender_female
            THEN
                g_error := 'CALL REMOVE_PREGN_QUESTIONS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                remove_pregn_questions(io_section      => l_tbl_sections,
                                       io_def_events   => l_tbl_def_events,
                                       io_events       => l_tbl_events,
                                       io_items_values => l_tbl_items_values);
            ELSE
            
                IF l_pregn_area_available = pk_alert_constant.g_yes
                THEN
                    g_error := 'CALL FILL_PREGNANCY_REC';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    fill_pregnancy_rec;
                ELSE
                    g_error := 'CALL REMOVE_PREGN_QUESTIONS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    remove_pregn_questions(io_section      => l_tbl_sections,
                                           io_def_events   => l_tbl_def_events,
                                           io_events       => l_tbl_events,
                                           io_items_values => l_tbl_items_values);
                END IF;
            END IF;
        
            --l_tbl_sections - has all triage form fields
            FOR i IN l_tbl_sections.first .. l_tbl_sections.last
            LOOP
            
                r_section := l_tbl_sections(i);
            
                -- only processes fields that weren't configured to be shown
                IF r_section.internal_name NOT IN (g_ds_comp_est_needs, g_ds_comp_est_arrived_by)
                   OR (r_section.internal_name IN (g_ds_comp_est_needs, g_ds_comp_est_arrived_by) AND
                   nvl(l_needs_arrived_cfg, g_yes) = g_yes)
                THEN
                    --I only want multichoice fields and only a restrite group of them
                    --For instance, multichoice fields based on sys_list come automatically filled 
                    --from the pk_dynamic_screen.get_ds_section_complete_struct function call
                    IF r_section.flg_data_type IN (pk_dynamic_screen.c_data_type_ms, pk_dynamic_screen.c_data_type_mm)
                    THEN
                        CASE
                            WHEN r_section.internal_name = g_ds_comp_origin THEN
                                add_origin(i_ds_cmpt_mkt_rel    => r_section.id_ds_cmpt_mkt_rel,
                                           i_ds_component       => r_section.id_ds_component,
                                           i_internal_name      => r_section.internal_name,
                                           i_flg_component_type => r_section.flg_component_type);
                            WHEN r_section.internal_name IN (g_ds_comp_letter,
                                                             g_ds_safeguard_under_two_years,
                                                             g_ds_safeguard_immobile,
                                                             g_ds_safeguard_injury,
                                                             g_ds_safeguard_protection_plan,
                                                             g_ds_safeguard_attend_delay,
                                                             g_ds_safeguard_domestic_abuse,
                                                             g_ds_safeguard_expl_injury,
                                                             g_ds_safeguard_has_social_w,
                                                             g_ds_safeguard_social_services,
                                                             g_ds_safeguard_social_consent,
                                                             g_ds_safeguard_social_infor,
                                                             g_ds_safeguard_abuse_sign) THEN
                                add_yes_no_list(i_ds_cmpt_mkt_rel    => r_section.id_ds_cmpt_mkt_rel,
                                                i_ds_component       => r_section.id_ds_component,
                                                i_internal_name      => r_section.internal_name,
                                                i_flg_component_type => r_section.flg_component_type);
                            WHEN r_section.internal_name = g_ds_comp_arrived_by THEN
                                add_transp_entity_list(i_ds_cmpt_mkt_rel    => r_section.id_ds_cmpt_mkt_rel,
                                                       i_ds_component       => r_section.id_ds_component,
                                                       i_internal_name      => r_section.internal_name,
                                                       i_flg_component_type => r_section.flg_component_type);
                            WHEN r_section.internal_name = g_ds_comp_est_arrived_by THEN
                                add_transp_entity_list(i_ds_cmpt_mkt_rel    => r_section.id_ds_cmpt_mkt_rel,
                                                       i_ds_component       => r_section.id_ds_component,
                                                       i_internal_name      => r_section.internal_name,
                                                       i_flg_component_type => r_section.flg_component_type);
                            WHEN r_section.internal_name = g_ds_comp_cause THEN
                                add_external_cause(i_ds_cmpt_mkt_rel    => r_section.id_ds_cmpt_mkt_rel,
                                                   i_ds_component       => r_section.id_ds_component,
                                                   i_internal_name      => r_section.internal_name,
                                                   i_flg_component_type => r_section.flg_component_type);
                            ELSE
                                NULL;
                        END CASE;
                    ELSIF r_section.flg_data_type = pk_dynamic_screen.c_data_type_ft
                    THEN
                        CASE
                            WHEN r_section.internal_name = pk_edis_triage.g_ds_comp_est_entourage THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_entourage,
                                                io_section                     => r_section);
                            WHEN r_section.internal_name IN
                                 (pk_edis_triage.g_ds_comp_chief_comp, pk_edis_triage.g_ds_comp_est_motif_entree) THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_chief_comp,
                                                io_section                     => r_section);
                            WHEN r_section.internal_name = pk_edis_triage.g_ds_comp_est_traitement THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_traitment,
                                                io_section                     => r_section);
                            WHEN r_section.internal_name = pk_edis_triage.g_ds_comp_est_notes THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_autres_signes,
                                                io_section                     => r_section);
                            WHEN r_section.internal_name = pk_edis_triage.g_ds_comp_desc_origin THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_desc_origin,
                                                io_section                     => r_section);
                            WHEN r_section.internal_name = pk_edis_triage.g_ds_comp_accident_desc THEN
                                add_sample_text(i_intern_name_sample_text_type => pk_edis_triage.g_sample_text_accident_desc,
                                                io_section                     => r_section);
                            ELSE
                                NULL;
                        END CASE;
                    END IF;
                
                    IF r_section.internal_name IN (g_ds_comp_origin,
                                                   g_ds_comp_desc_origin,
                                                   g_ds_comp_letter,
                                                   g_ds_comp_arrived_by,
                                                   g_ds_comp_est_arrived_by,
                                                   g_ds_comp_emerg_cont,
                                                   g_ds_comp_cause)
                    THEN
                        get_arrive;
                    ELSIF r_section.internal_name IN (g_ds_comp_chief_comp, g_ds_comp_est_motif_entree)
                    THEN
                        get_anamnesis;
                    ELSIF r_section.internal_name IN (g_ds_comp_est_vsigns, g_ds_comp_vsigns)
                    THEN
                        --add to final table section the parameterized vital signs
                        --and add to item values the vital sign record
                        add_vital_signs(i_lang                => i_lang,
                                        i_prof                => i_prof,
                                        i_epis_triage         => i_epis_triage,
                                        i_ds_component_parent => r_section.id_ds_component);
                    
                        --Inform flash that this section has VS
                        r_section.flg_data_type := g_flg_data_type_vs;
                    END IF;
                
                    l_final_tbl_sections.extend();
                    l_final_tbl_sections(l_final_tbl_sections.count) := r_section;
                
                    --Function add_all_pat_necess also adds the default values so the call must be made after the section was added to the l_final_tbl_sections table
                    IF r_section.internal_name IN (g_ds_comp_needs, g_ds_comp_est_needs)
                    THEN
                        add_all_pat_necess(i_idx_section => l_final_tbl_sections.count);
                    END IF;
                
                    add_values(i_idx_section   => l_final_tbl_sections.count,
                               i_internal_name => r_section.internal_name,
                               i_epis_triage   => i_epis_triage);
                END IF;
            END LOOP;
        ELSIF i_triage_board IS NOT NULL
              OR i_triage_discriminator IS NOT NULL
        THEN
        
            IF l_pregn_area_available = pk_alert_constant.g_yes
            THEN
                g_error := 'CALL FILL_PREGNANCY_REC';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                fill_pregnancy_rec;
            END IF;
            --Only return vital sign section
            g_error := 'CALL PK_DYNAMIC_SCREEN.GET_DS_SECTION_COMPLETE_STRUCT - VITAL_SIGNS NODE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT pk_dynamic_screen.get_ds_section_complete_struct(i_lang           => i_lang,
                                                                    i_prof           => i_prof,
                                                                    i_component_name => pk_edis_triage.g_ds_comp_vital_signs_node,
                                                                    i_component_type => pk_dynamic_screen.c_node_component,
                                                                    o_section        => l_tbl_sections,
                                                                    o_def_events     => l_tbl_def_events,
                                                                    o_events         => l_tbl_events,
                                                                    o_items_values   => l_tbl_items_values,
                                                                    o_error          => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF l_tbl_sections.exists(1)
            THEN
                r_section := l_tbl_sections(1);
            
                --Inform flash that this section has VS
                r_section.flg_data_type := g_flg_data_type_vs;
            
                l_final_tbl_sections.extend();
                l_final_tbl_sections(l_final_tbl_sections.count) := r_section;
            
                g_error := 'CALL ADD_VITAL_SIGNS';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            
                add_vital_signs(i_lang                => i_lang,
                                i_prof                => i_prof,
                                i_epis_triage         => i_epis_triage,
                                i_ds_component_parent => r_section.id_ds_component,
                                i_tbl_id_context      => CASE
                                                             WHEN i_triage_board IS NOT NULL THEN
                                                              table_number(i_triage_board)
                                                             ELSE
                                                              table_number(i_triage_discriminator)
                                                         END,
                                i_flg_context         => CASE
                                                             WHEN i_triage_board IS NOT NULL THEN
                                                              pk_edis_triage.g_flg_context_id_triage_board
                                                             ELSE
                                                              pk_edis_triage.g_flg_context_id_triage_disc
                                                         END);
            END IF;
        ELSE
            g_error := 'NOT SUPPORTED';
            pk_alertlog.log_error(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            RAISE l_param_error;
        END IF;
    
        g_error := 'SET OUTPUT TABLE VARs';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        --The table must be reordered
        SELECT t_rec_ds_sections(id_ds_cmpt_mkt_rel     => a.id_ds_cmpt_mkt_rel,
                                 id_ds_component_parent => a.id_ds_component_parent,
                                 id_ds_component        => a.id_ds_component,
                                 component_desc         => a.component_desc,
                                 internal_name          => a.internal_name,
                                 flg_component_type     => a.flg_component_type,
                                 flg_data_type          => a.flg_data_type,
                                 slg_internal_name      => a.slg_internal_name,
                                 addit_info_xml_value   => a.addit_info_xml_value,
                                 rank                   => a.rank,
                                 max_len                => a.max_len,
                                 min_value              => a.min_value,
                                 max_value              => a.max_value,
                                 gender                 => a.gender,
                                 age_min_value          => a.age_min_value,
                                 age_min_unit_measure   => a.age_min_unit_measure,
                                 age_max_value          => a.age_max_value,
                                 age_max_unit_measure   => a.age_max_unit_measure,
                                 component_values       => a.component_values)
          BULK COLLECT
          INTO o_section
          FROM (SELECT b.id_ds_cmpt_mkt_rel,
                       b.id_ds_component_parent,
                       b.id_ds_component,
                       b.component_desc,
                       b.internal_name,
                       b.flg_component_type,
                       b.flg_data_type,
                       b.slg_internal_name,
                       b.addit_info_xml_value,
                       pk_dynamic_screen.get_section_rank(i_tbl_section     => l_final_tbl_sections,
                                                          i_ds_cmpt_mkt_rel => b.id_ds_cmpt_mkt_rel) rank,
                       b.max_len,
                       b.min_value,
                       b.max_value,
                       b.gender,
                       b.age_min_value,
                       b.age_min_unit_measure,
                       b.age_max_value,
                       b.age_max_unit_measure,
                       b.component_values
                  FROM TABLE(l_final_tbl_sections) b) a
         ORDER BY a.rank;
    
        o_events := l_tbl_events;
    
        IF nvl(l_rec_preg.flg_pregnant, pk_alert_constant.g_no) = pk_alert_constant.g_no
        THEN
            --Inactivate the default event of weeks field
            inact_weeks_def_event;
        END IF;
        IF nvl(l_needs_complaint_cfg, pk_alert_constant.g_yes) = pk_alert_constant.g_no
        THEN
            --NO MANDATORY the default event OF CHIEF COMPLAINT
            no_mand_chief_compl_def_event;
        END IF;
        o_def_events := l_tbl_def_events;
        --o_items_values - This cursor has all multichoice options for all triage form multichoice fields
        --               - And has all vital sign detail info
        o_items_values := l_tbl_items_values;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            o_section      := t_table_ds_sections();
            o_def_events   := t_table_ds_def_events();
            o_events       := t_table_ds_events();
            o_items_values := t_table_ds_items_values();
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
        
            o_section      := t_table_ds_sections();
            o_def_events   := t_table_ds_def_events();
            o_events       := t_table_ds_events();
            o_items_values := t_table_ds_items_values();
            RETURN FALSE;
    END get_section_data_int;

    FUNCTION get_section_data
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_component_name       IN ds_cmpt_mkt_rel.internal_name_parent%TYPE,
        i_component_type       IN ds_cmpt_mkt_rel.flg_component_type_parent%TYPE DEFAULT pk_dynamic_screen.c_node_component,
        i_triage_board         IN triage_board.id_triage_board%TYPE DEFAULT NULL,
        i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE DEFAULT NULL,
        o_section              OUT pk_types.cursor_type,
        o_def_events           OUT pk_types.cursor_type,
        o_events               OUT pk_types.cursor_type,
        o_items_values         OUT pk_types.cursor_type,
        o_data_val             OUT CLOB,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_SECTION_DATA';
        --    
        l_ret BOOLEAN;
        --
        l_tbl_sections     t_table_ds_sections;
        l_tbl_items_values t_table_ds_items_values;
        l_tbl_events       t_table_ds_events;
        l_tbl_def_events   t_table_ds_def_events;
        --
        l_xml_data xmltype;
    BEGIN
        g_error := 'CALL GET_SECTION_DATA_INT';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_ret := get_section_data_int(i_lang                 => i_lang,
                                      i_prof                 => i_prof,
                                      i_patient              => i_patient,
                                      i_episode              => i_episode,
                                      i_component_name       => i_component_name,
                                      i_component_type       => i_component_type,
                                      i_triage_board         => i_triage_board,
                                      i_triage_discriminator => i_triage_discriminator,
                                      o_section              => l_tbl_sections,
                                      o_def_events           => l_tbl_def_events,
                                      o_events               => l_tbl_events,
                                      o_items_values         => l_tbl_items_values,
                                      o_error                => o_error);
    
        IF l_ret
        THEN
            g_error := 'OPEN O_SECTION';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN o_section FOR
                SELECT t.id_ds_cmpt_mkt_rel,
                       t.id_ds_component_parent,
                       t.id_ds_component,
                       t.component_desc,
                       t.internal_name,
                       t.flg_component_type,
                       t.flg_data_type,
                       t.slg_internal_name,
                       t.addit_info_xml_value,
                       t.rank,
                       t.max_len,
                       t.min_value,
                       t.max_value
                  FROM TABLE(l_tbl_sections) t;
        
            g_error := 'OPEN O_EVENTS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN o_events FOR
                SELECT *
                  FROM TABLE(l_tbl_events);
        
            g_error := 'OPEN O_DEF_EVENTS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            OPEN o_def_events FOR
                SELECT *
                  FROM TABLE(l_tbl_def_events);
        
            g_error := 'OPEN O_ITEMS_VALUES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            --o_items_values - This cursor has all multichoice options for all triage form multichoice fields
            --               - And has all vital sign detail info
            OPEN o_items_values FOR
                SELECT *
                  FROM TABLE(l_tbl_items_values);
        
            FOR r_section IN (SELECT t.id_ds_cmpt_mkt_rel, t.internal_name, t.flg_data_type, t.component_values
                                FROM TABLE(l_tbl_sections) t)
            LOOP
                IF r_section.component_values.count = 1
                THEN
                    FOR r_value IN (SELECT t.id_ds_cmpt_mkt_rel, t.item_desc, t.item_value, t.item_alt_value
                                      FROM TABLE(r_section.component_values) t)
                    LOOP
                        SELECT xmlconcat(l_xml_data,
                                         xmlagg(xmlelement("COMPONENT_LEAF",
                                                           xmlattributes(a.id_ds_cmpt_mkt_rel,
                                                                         a.internal_name,
                                                                         a.desc_value,
                                                                         a.value,
                                                                         a.alt_value)))) data_val
                          INTO l_xml_data
                          FROM (SELECT r_value.id_ds_cmpt_mkt_rel AS id_ds_cmpt_mkt_rel,
                                       r_section.internal_name    AS internal_name,
                                       r_value.item_desc          AS desc_value,
                                       r_value.item_value         AS VALUE,
                                       r_value.item_alt_value     AS alt_value
                                  FROM dual
                                 WHERE r_value.item_desc IS NOT NULL
                                    OR r_value.item_value IS NOT NULL
                                    OR r_value.item_alt_value IS NOT NULL) a;
                    END LOOP;
                ELSIF r_section.component_values.count > 1
                      AND r_section.flg_data_type != g_flg_data_type_vs
                THEN
                    SELECT xmlconcat(l_xml_data,
                                     xmlagg(xmlelement("COMPONENT_LEAF",
                                                       xmlattributes(c.id_ds_cmpt_mkt_rel AS "ID_DS_CMPT_MKT_REL",
                                                                     c.internal_name AS "INTERNAL_NAME"), --
                                                       (SELECT xmlagg(xmlelement("SELECTED_ITEM",
                                                                                 xmlattributes(d.item_desc AS "DESC_VALUE",
                                                                                               d.item_value AS "VALUE",
                                                                                               d.item_alt_value AS
                                                                                               "ALT_VALUE")))
                                                          FROM TABLE(r_section.component_values) d
                                                         WHERE d.item_desc IS NOT NULL
                                                            OR d.item_value IS NOT NULL
                                                            OR d.item_alt_value IS NOT NULL))))
                      INTO l_xml_data
                      FROM (SELECT r_section.id_ds_cmpt_mkt_rel AS id_ds_cmpt_mkt_rel,
                                   r_section.internal_name      AS internal_name
                              FROM dual) c;
                ELSIF r_section.component_values.count > 1
                      AND r_section.flg_data_type = g_flg_data_type_vs
                THEN
                    SELECT xmlconcat(l_xml_data,
                                     xmlagg(xmlelement("COMPONENT_LEAF",
                                                       xmlattributes(c.internal_name AS "INTERNAL_NAME",
                                                                     c.desc_value AS "DESC_VALUE",
                                                                     c.value AS "VALUE",
                                                                     c.alt_value AS "ALT_VALUE") --
                                                       )))
                      INTO l_xml_data
                      FROM (SELECT t.id_ds_cmpt_mkt_rel AS id_ds_cmpt_mkt_rel,
                                   nvl(t.internal_name, r_section.internal_name) AS internal_name,
                                   t.item_desc AS desc_value,
                                   t.item_value AS VALUE,
                                   t.item_alt_value AS alt_value
                              FROM TABLE(r_section.component_values) t
                             WHERE --t.internal_name IS NULL
                            --  AND 
                             (t.item_desc IS NOT NULL OR t.item_value IS NOT NULL OR t.item_alt_value IS NOT NULL)) c;
                END IF;
            END LOOP;
        
            IF l_xml_data IS NOT NULL
            THEN
                --o_data_val - Has all the default triage form fields values
                SELECT xmlelement("COMPONENTS", l_xml_data).getclobval()
                  INTO o_data_val
                  FROM dual;
            END IF;
        ELSE
            pk_types.open_my_cursor(i_cursor => o_section);
            pk_types.open_my_cursor(i_cursor => o_def_events);
            pk_types.open_my_cursor(i_cursor => o_events);
            pk_types.open_my_cursor(i_cursor => o_items_values);
        
            o_data_val := NULL;
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
        
            pk_types.open_my_cursor(i_cursor => o_section);
            pk_types.open_my_cursor(i_cursor => o_def_events);
            pk_types.open_my_cursor(i_cursor => o_events);
            pk_types.open_my_cursor(i_cursor => o_items_values);
            o_data_val := NULL;
            RETURN FALSE;
    END get_section_data;

    /**************************************************************************
    * Set patient's complaint, registered during triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis                Episode ID
    * @param i_id_patient             Patient ID
    * @param i_desc_anamnesis         Complaint text
    * @param i_dt_end                 Triage end date
    * @param i_flg_complaint          Availability of the complaint screen
    * @param o_id_epis_anamnesis      Complaint record ID
    * @param o_error                  Error message
    *
    * @return                         -
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          07/12/2009
    **************************************************************************/
    PROCEDURE set_anamnesis_complaint
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_epis           IN episode.id_episode%TYPE,
        i_id_patient        IN patient.id_patient%TYPE,
        i_desc_anamnesis    IN epis_anamnesis.desc_epis_anamnesis%TYPE,
        i_dt_end            IN epis_anamnesis.dt_epis_anamnesis_tstz%TYPE,
        i_flg_complaint     IN sys_config.value%TYPE,
        o_id_epis_anamnesis OUT epis_anamnesis.id_epis_anamnesis%TYPE,
        o_error             OUT t_error_out
    ) IS
        l_func_name      VARCHAR2(200) := 'SET_ANAMNESIS_COMPLAINT';
        l_next_anamnesis epis_anamnesis.id_epis_anamnesis%TYPE;
        l_temp_records   sys_config.value%TYPE;
        l_rows           table_varchar := table_varchar();
    BEGIN
        g_error := ' GET CONFIGURATIONS (ANAMNESIS)';
    
        -- Insert complaint record
        IF i_desc_anamnesis IS NOT NULL
        THEN
            g_error := ' INSERT INTO EPIS_ANAMNESIS';
            pk_alertlog.log_debug(g_error);
            l_next_anamnesis := ts_epis_anamnesis.next_key;
            ts_epis_anamnesis.ins(id_epis_anamnesis_in      => l_next_anamnesis,
                                  dt_epis_anamnesis_tstz_in => i_dt_end,
                                  desc_epis_anamnesis_in    => i_desc_anamnesis,
                                  id_episode_in             => i_id_epis,
                                  id_professional_in        => i_prof.id,
                                  flg_type_in               => 'C',
                                  flg_temp_in               => 'D',
                                  id_institution_in         => i_prof.institution,
                                  id_software_in            => i_prof.software,
                                  id_patient_in             => i_id_patient,
                                  flg_status_in             => pk_alert_constant.g_epis_status_active,
                                  rows_out                  => l_rows);
        
            g_error := 'PROCESS INSERT WITH ID_EPIS_ANAMNESIS ' || l_next_anamnesis;
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_ANAMNESIS', l_rows, o_error);
        END IF;
    
        IF l_next_anamnesis IS NULL
           AND i_flg_complaint = pk_alert_constant.g_yes
        THEN
            BEGIN
                g_error := 'GET LAST COMPLAINT';
                pk_alertlog.log_debug(g_error);
                SELECT ea.id_epis_anamnesis
                  INTO l_next_anamnesis
                  FROM epis_anamnesis ea
                 WHERE ea.id_episode = i_id_epis
                   AND ea.flg_type = pk_complaint.g_epis_anam_flg_type_c
                   AND ea.dt_epis_anamnesis_tstz = (SELECT MAX(ea1.dt_epis_anamnesis_tstz)
                                                      FROM epis_anamnesis ea1
                                                     WHERE ea1.id_episode = ea.id_episode);
            EXCEPTION
                WHEN no_data_found THEN
                    NULL;
            END;
        END IF;
    
        o_id_epis_anamnesis := l_next_anamnesis;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              l_func_name,
                                              o_error);
    END set_anamnesis_complaint;
    /**************************************************************************
    * Set options selected by the user during triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_epis_triage            Triage event ID
    * @param i_tab_triage             Array of triage ID's
    * @param i_tab_option             Array of selected options
    * @param o_error                  Error message
    *
    * @return                         -
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          08/02/2010
    **************************************************************************/
    FUNCTION set_triage_options
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_epis_triage IN epis_triage.id_epis_triage%TYPE,
        i_triage      IN pk_edis_types.rec_triage,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200) := 'SET_TRIAGE_OPTIONS';
        l_param_error EXCEPTION;
    BEGIN
        -- test options and save if necessary
        IF i_triage.group_options IS NOT NULL
           AND i_triage.group_options.count > 0
        THEN
            FOR i IN i_triage.group_options.first .. i_triage.group_options.last
            LOOP
                IF i_triage.group_options(i).options IS NOT NULL
                    AND i_triage.group_options(i).options.count > 0
                THEN
                    FOR j IN i_triage.group_options(i).options.first .. i_triage.group_options(i).options.last
                    LOOP
                        IF i_triage.group_options(i).options(j).id_triage IS NOT NULL
                            AND
                            (i_triage.group_options(i).options(j).flg_selected_option IS NOT NULL OR
                              (i_triage.group_options(i).options(j).flg_selected_option IS NULL AND i_triage.group_options(i).options(j).id_triage_cons_value IS NOT NULL))
                        THEN
                            g_error := 'SAVE EPIS_TRIAGE_OPTION (' || i_triage.group_options(i).options(j).id_triage || ')';
                            pk_alertlog.log_debug(g_error);
                            ts_epis_triage_option.ins(id_epis_triage_in       => i_epis_triage,
                                                      id_triage_in            => i_triage.group_options(i).options(j).id_triage,
                                                      flg_selected_option_in  => i_triage.group_options(i).options(j).flg_selected_option,
                                                      id_triage_cons_value_in => i_triage.group_options(i).options(j).id_triage_cons_value);
                        END IF;
                    
                        -- save child_discriminators
                        IF i_triage.group_options(i).options(j).child_option.id_triage IS NOT NULL
                            AND i_triage.group_options(i).options(j).child_option.flg_accepted_option IS NOT NULL
                        THEN
                            g_error := 'SAVE EPIS_TRIAGE_OPTION (' || i_triage.group_options(i).options(j).id_triage || ')';
                            pk_alertlog.log_debug(g_error);
                            ts_epis_triage_option.ins(id_epis_triage_in       => i_epis_triage,
                                                      id_triage_in            => i_triage.group_options(i).options(j).child_option.id_triage,
                                                      flg_selected_option_in  => i_triage.group_options(i).options(j).child_option.flg_accepted_option,
                                                      id_triage_cons_value_in => NULL);
                        END IF;
                    END LOOP;
                END IF;
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_param_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'PARAM ERROR',
                                              'INVALID ARRAY SIZE',
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END set_triage_options;

    /**************************************************************************
    * Set data of GRID_TASK_* tables.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis                Episode ID
    * @param o_error                  Error message
    *
    * @return                         -
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          07/12/2009
    **************************************************************************/
    PROCEDURE set_grid_task
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_id_epis IN episode.id_episode%TYPE,
        o_error   OUT t_error_out
    ) IS
        l_func_name VARCHAR2(200) := 'SET_GRID_TASK';
        l_internal_error EXCEPTION;
    BEGIN
        g_error := 'PROCESS GRID TASK: ANALYSIS';
        pk_alertlog.log_debug(g_error);
        FOR r_analysis IN (SELECT ard.id_analysis_req_det, ard.id_analysis_req, ar.id_patient
                             FROM analysis_req_det ard
                             JOIN analysis_req ar
                               ON ar.id_analysis_req = ard.id_analysis_req
                            WHERE ar.id_episode = i_id_epis
                              AND EXISTS (SELECT 1
                                     FROM analysis_instit_soft ais
                                    INNER JOIN analysis_instit_recipient air
                                       ON air.id_analysis_instit_soft = ais.id_analysis_instit_soft
                                    WHERE ais.id_analysis = ard.id_analysis
                                      AND ais.flg_available = pk_alert_constant.g_available
                                      AND ais.id_institution = i_prof.institution
                                      AND ais.id_software = i_prof.software))
        LOOP
            g_error := 'PK_LAB_TESTS_API_DB.SET_LAB_TEST_GRID_TASK';
            IF NOT pk_lab_tests_api_db.set_lab_test_grid_task(i_lang             => i_lang,
                                                              i_prof             => i_prof,
                                                              i_patient          => r_analysis.id_patient,
                                                              i_episode          => i_id_epis,
                                                              i_analysis_req     => r_analysis.id_analysis_req,
                                                              i_analysis_req_det => r_analysis.id_analysis_req_det,
                                                              o_error            => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END LOOP;
    
        g_error := 'PROCESS GRID TASK: EXAMS';
        pk_alertlog.log_debug(g_error);
        FOR r_exam IN (SELECT erd.id_exam_req_det, erd.id_exam_req, erd.id_exam, er.id_episode
                         FROM exam_req_det erd
                         JOIN exam_req er
                           ON er.id_exam_req = erd.id_exam_req
                        WHERE er.id_episode = i_id_epis)
        LOOP
            g_error := 'PK_EXAMS_API_DB.SET_EXAM_GRID_TASK';
            IF NOT pk_exams_api_db.set_exam_grid_task(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_patient      => NULL,
                                                      i_episode      => i_id_epis,
                                                      i_exam_req     => r_exam.id_exam_req,
                                                      i_exam_req_det => r_exam.id_exam_req_det,
                                                      o_error        => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END LOOP;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.err_desc,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              l_func_name,
                                              o_error);
    END set_grid_task;

    /**************************************************************************
    * Set triage alerts.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis                Episode ID
    * @param i_epis_dt_begin          Episode begin date
    * @param o_error                  Error message
    *
    * @return                         -
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          07/12/2009
    **************************************************************************/
    PROCEDURE set_triage_alerts
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_epis       IN episode.id_episode%TYPE,
        i_epis_dt_begin IN episode.dt_begin_tstz%TYPE,
        i_dt_triage_end IN epis_triage.dt_end_tstz%TYPE DEFAULT NULL,
        o_error         OUT t_error_out
    ) IS
        l_func_name VARCHAR2(200) := 'SET_TRIAGE_ALERTS';
        l_internal_error EXCEPTION;
    BEGIN
    
        g_error := 'DELETE NURSE TRIAGE ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_edis_triage.set_alert_triage(i_lang, i_prof, i_id_epis, NULL, g_alert_nurse, g_type_rem, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'DELETE DOC TRIAGE ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_edis_triage.set_alert_triage(i_lang, i_prof, i_id_epis, NULL, g_alert_doc, g_type_rem, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'DELETE DOC TRIAGE REASSESS ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_edis_triage.set_alert_triage(i_lang, i_prof, i_id_epis, NULL, 'R', g_type_rem, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        g_error := 'INSERT DOC TRIAGE ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT
            pk_edis_triage.set_alert_triage(i_lang, i_prof, i_id_epis, i_epis_dt_begin, g_alert_doc, g_type_add, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
        g_error := 'INSERT DOC TRIAGE REASSESS ALERT';
        pk_alertlog.log_debug(g_error);
        IF NOT pk_edis_triage.set_alert_triage(i_lang, i_prof, i_id_epis, i_dt_triage_end, 'R', g_type_add, o_error)
        THEN
            RAISE l_internal_error;
        END IF;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.err_desc,
                                              g_error,
                                              'ALERT',
                                              g_package_name,
                                              l_func_name,
                                              o_error);
    END set_triage_alerts;

    /**************************************************************************
    * Returns the value for a given triage configuration.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode id
    * @param i_triage_type            Triage type ID
    * @param i_config                 Configuration name
    *
    * @return                         The value for the configuration; NULL on error.
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          04/12/2009
    **************************************************************************/
    FUNCTION get_triage_config_by_name
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_episode     IN episode.id_episode%TYPE,
        i_triage_type IN triage_type.id_triage_type%TYPE,
        i_config      IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(200) := 'GET_TRIAGE_CONFIG_BY_NAME';
        l_internal_error EXCEPTION;
        l_error t_error_out;
    
        l_row_triage_config triage_configuration%ROWTYPE;
        l_config_value      sys_config.value%TYPE;
    BEGIN
    
        g_error := 'GET CONFIGURATIONS';
        pk_alertlog.log_debug(g_error);
        IF NOT get_triage_config_row(i_lang        => i_lang,
                                     i_prof        => i_prof,
                                     i_episode     => i_episode,
                                     i_triage_type => i_triage_type,
                                     o_config_row  => l_row_triage_config,
                                     o_error       => l_error)
        THEN
            pk_alertlog.log_debug(g_error);
            RAISE l_internal_error;
        END IF;
    
        CASE i_config
            WHEN 'ID_INSTITUTION' THEN
                l_config_value := l_row_triage_config.id_institution;
            WHEN 'ID_SOFTWARE' THEN
                l_config_value := l_row_triage_config.id_software;
            WHEN 'ID_TRIAGE_TYPE' THEN
                l_config_value := l_row_triage_config.id_triage_type;
            WHEN 'FLG_BUTTONS' THEN
                l_config_value := l_row_triage_config.flg_buttons;
            WHEN 'FLG_CONSIDERATIONS' THEN
                l_config_value := l_row_triage_config.flg_considerations;
            WHEN 'NUM_EPIS_TRIAGE_AUDIT' THEN
                l_config_value := l_row_triage_config.num_epis_triage_audit;
            WHEN 'ID_REPORTS' THEN
                l_config_value := l_row_triage_config.id_reports;
            WHEN 'FLG_AUTO_PRINT_TAG' THEN
                l_config_value := l_row_triage_config.flg_auto_print_tag;
            WHEN 'FLG_CHANGE_COLOR' THEN
                l_config_value := l_row_triage_config.flg_change_color;
            WHEN 'FLG_COMPLAINT' THEN
                l_config_value := l_row_triage_config.flg_complaint;
            WHEN 'FLG_DEFAULT_VIEW' THEN
                l_config_value := l_row_triage_config.flg_default_view;
            WHEN 'FLG_CHECK_VITAL_SIGN' THEN
                l_config_value := l_row_triage_config.flg_check_vital_sign;
            WHEN 'FLG_ID_BOARD' THEN
                l_config_value := l_row_triage_config.flg_id_board;
            WHEN 'FLG_CHECK_AGE_LIMITS' THEN
                l_config_value := l_row_triage_config.flg_check_age_limits;
            WHEN 'ID_TRIAGE_DS_COMPONENT' THEN
                l_config_value := l_row_triage_config.id_triage_ds_component;
            WHEN 'FLG_FILTER_FLOWCHART' THEN
                l_config_value := l_row_triage_config.flg_filter_flowchart;
            WHEN 'FLG_TRIAGE_RES_GRIDS' THEN
                l_config_value := l_row_triage_config.flg_triage_res_grids;
            WHEN 'FLG_SHOW_COLOR_DESC' THEN
                l_config_value := l_row_triage_config.flg_show_color_desc;
            ELSE
                g_error := 'CONFIGURATION DOES NOT EXIST';
                pk_alertlog.log_debug(g_error);
                RAISE l_internal_error;
        END CASE;
    
        RETURN l_config_value;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.err_desc,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_triage_config_by_name;

    /**************************************************************************
    * Returns a string with the vital signs to be assessed 
    * in the current discriminator.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_disc                   Discriminator ID
    * @param i_field                  Type of data to return in the list (ID_VITAL_SIGN; FLG_MANDATORY; FLG_VS_TYPE)
    *
    * @return                         String with the vital sign data
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          14/12/2009
    **************************************************************************/
    FUNCTION get_vs_list_by_field
    (
        i_lang  IN language.id_language%TYPE,
        i_prof  IN profissional,
        i_disc  IN triage_discriminator.id_triage_discriminator%TYPE,
        i_field IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name    VARCHAR2(200) := 'GET_VS_LIST_BY_FIELD';
        l_error        t_error_out;
        l_field_values VARCHAR2(4000) := NULL;
        l_id_market    market.id_market%TYPE;
    
        -- Supported fields
        l_field_id_vital_sign CONSTANT VARCHAR2(32) := 'ID_VITAL_SIGN';
        l_field_flg_mandatory CONSTANT VARCHAR2(32) := 'FLG_MANDATORY';
        l_field_flg_vs_type   CONSTANT VARCHAR2(32) := 'FLG_VS_TYPE';
    
    BEGIN
    
        g_error     := 'GET MARKET ID';
        l_id_market := get_market(i_lang, i_prof);
    
        g_error := 'GET LIST OF FIELD VALUES (' || i_field || ')';
        pk_alertlog.log_debug(g_error);
        SELECT pk_utils.concatenate_list(CURSOR
                                         (SELECT decode(i_field, -- Select the value to return to the list
                                                        l_field_id_vital_sign,
                                                        to_char(id_vital_sign),
                                                        l_field_flg_mandatory,
                                                        flg_mandatory,
                                                        l_field_flg_vs_type,
                                                        pk_vital_sign.get_vital_sign_type(i_vital_sign => id_vital_sign),
                                                        NULL)
                                            FROM ( -- 1) This returns the configured values in TRIAGE_VS_AREA/TRIAGE_TYPE_VS
                                                  SELECT DISTINCT ttv.id_vital_sign id_vital_sign,
                                                                   nvl(tva.flg_mandatory, pk_alert_constant.g_yes) flg_mandatory,
                                                                   vs.rank rank
                                                    FROM triage_type_vs ttv
                                                    JOIN triage_vs_area tva
                                                      ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                                                    JOIN vital_sign vs
                                                      ON vs.id_vital_sign = ttv.id_vital_sign
                                                   WHERE tva.id_context = i_disc
                                                     AND tva.flg_context = g_flg_context_id_triage_disc
                                                     AND ttv.flg_available = pk_alert_constant.g_yes
                                                     AND ttv.id_parent IS NULL
                                                     AND tva.id_market IN (l_id_market, 0)
                                                  UNION ALL
                                                  -- 2) This returns the CHILD values of GLASGOW and TRTS
                                                  SELECT DISTINCT vsr.id_vital_sign_detail id_vital_sign,
                                                                   nvl(tva.flg_mandatory, pk_alert_constant.g_yes) flg_mandatory,
                                                                   --> This allows the related vital signs to be grouped together, with the parent at the end (e.g. Glasgow)
                                                                   vs.rank rank
                                                    FROM triage_type_vs ttv
                                                    JOIN triage_vs_area tva
                                                      ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                                                    JOIN vital_sign_relation vsr
                                                      ON vsr.id_vital_sign_parent = ttv.id_vital_sign
                                                  -- Join with VITAL_SIGN with different columns, to show 
                                                  -- the correct order when assessing TRTS (Manchester triage).
                                                    JOIN vital_sign vs
                                                      ON vs.id_vital_sign =
                                                         decode(vsr.relation_domain,
                                                                'M',
                                                                vsr.id_vital_sign_detail,
                                                                vsr.id_vital_sign_parent)
                                                   WHERE tva.id_context = i_disc
                                                     AND tva.flg_context = g_flg_context_id_triage_disc
                                                     AND ttv.flg_available = pk_alert_constant.g_yes
                                                     AND ttv.id_parent IS NULL
                                                     AND vsr.flg_available = pk_alert_constant.g_yes
                                                     AND vsr.relation_domain IN
                                                         (pk_alert_constant.g_vs_rel_sum, pk_alert_constant.g_vs_rel_man)
                                                     AND tva.id_market IN (l_id_market, 0)
                                                  UNION ALL
                                                  -- 3) This returns the CHILD values of the TRTS CHILDS (query 2)
                                                  SELECT DISTINCT vsr.id_vital_sign_detail id_vital_sign,
                                                                   pk_alert_constant.g_yes  flg_mandatory,
                                                                   vs.rank                  rank
                                                    FROM vital_sign_relation vsr
                                                    JOIN vital_sign vs
                                                      ON vs.id_vital_sign = vsr.id_vital_sign_parent
                                                   WHERE vsr.flg_available = pk_alert_constant.g_yes
                                                     AND vsr.id_vital_sign_parent IN
                                                         (SELECT vsr1.id_vital_sign_detail id_vital_sign
                                                            FROM triage_type_vs ttv
                                                            JOIN triage_vs_area tva
                                                              ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                                                            JOIN vital_sign_relation vsr1
                                                              ON vsr1.id_vital_sign_parent = ttv.id_vital_sign
                                                           WHERE tva.id_context = i_disc
                                                             AND tva.flg_context = g_flg_context_id_triage_disc
                                                             AND ttv.flg_available = pk_alert_constant.g_yes
                                                             AND ttv.id_parent IS NULL
                                                             AND vsr1.flg_available = pk_alert_constant.g_yes
                                                             AND vsr1.relation_domain = pk_alert_constant.g_vs_rel_man
                                                             AND tva.id_market IN (l_id_market, 0))
                                                   ORDER BY rank DESC, id_vital_sign ASC)),
                                         ';')
          INTO l_field_values
          FROM dual;
    
        RETURN l_field_values;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_vs_list_by_field;

    /**************************************************************************
    * Obtains the market ID of the current institution.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    *
    * @return                         Market ID
    *                        
    * @author                         José Brito
    * @version                        2.5.0.7.8
    * @since                          18/03/2010
    **************************************************************************/
    FUNCTION get_market
    (
        i_lang IN language.id_language%TYPE,
        i_prof IN profissional
    ) RETURN NUMBER IS
        l_func_name VARCHAR2(200) := 'GET_MARKET';
        l_id_market market.id_market%TYPE;
        l_error     t_error_out;
    BEGIN
        BEGIN
            g_error := 'GET INST. MARKET';
            SELECT i.id_market
              INTO l_id_market
              FROM institution i
             WHERE i.id_institution = i_prof.institution;
        EXCEPTION
            WHEN no_data_found THEN
                l_id_market := 0;
        END;
    
        RETURN nvl(l_id_market, 0);
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_market;

    /**************************************************************************
    * Returns a string with the full description for the current decision point,
    * for the ESI triage protocol.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_decision_point      Decision point ID
    * @param i_type                   (L) Long or (S) Short title
    *
    * @return                         String with description
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          23/12/2009
    **************************************************************************/
    FUNCTION get_esi_decision_point_title
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_decision_point IN triage_decision_point.id_triage_decision_point%TYPE,
        i_type              IN VARCHAR2
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(200) := 'GET_ESI_DECISION_POINT_TITLE';
        l_title     VARCHAR2(4000);
        l_type      VARCHAR2(1 CHAR);
    
        l_type_l CONSTANT VARCHAR2(1 CHAR) := 'L';
        l_type_s CONSTANT VARCHAR2(1 CHAR) := 'S';
    
        l_internal_error EXCEPTION;
        l_error t_error_out;
    BEGIN
    
        IF i_type IS NULL
        THEN
            l_type := l_type_l;
        
        ELSIF i_type IS NOT NULL
              AND i_type IN (l_type_l, l_type_s)
        THEN
            l_type := i_type;
        
        ELSE
            g_error := 'INVALID TITLE TYPE';
            pk_alertlog.log_debug(g_error);
            RAISE l_internal_error;
        END IF;
    
        g_error := 'GET DECISION POINT LABEL';
        pk_alertlog.log_debug(g_error);
        SELECT decode(l_type,
                      l_type_l,
                      pk_translation.get_translation(i_lang, tdp.code_prefix_decision_point) || ' - ',
                      '') || pk_translation.get_translation(i_lang, tdp.code_triage_decision_point)
          INTO l_title
          FROM triage_decision_point tdp
         WHERE tdp.id_triage_decision_point = i_id_decision_point;
    
        RETURN l_title;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_esi_decision_point_title;

    /**************************************************************************
    * Returns a label with the flowchart description, according to the
    * type of triage.
    *   
    * @param i_lang                       Language ID
    * @param i_prof                       Professional info
    * @param i_id_triage_board            Flowchart ID
    * @param i_id_triage_decision_point   Decision point ID, if applicable (ESI triage only)
    * @param i_id_triage_type             Triage type ID
    *
    * @return                         Label with the flowchart description
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          22/02/2010
    **************************************************************************/
    FUNCTION get_board_label
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_triage_board          IN triage_board.id_triage_board%TYPE,
        i_id_triage_decision_point IN triage_decision_point.id_triage_decision_point%TYPE,
        i_id_triage_type           IN triage_type.id_triage_type%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name         VARCHAR2(200) := 'GET_BOARD_LABEL';
        l_board_label       VARCHAR2(4000);
        l_show_board_number triage_configuration.flg_id_board%TYPE;
        l_error             t_error_out;
        l_param_error EXCEPTION;
    BEGIN
    
        g_error := 'GET BOARD NUMBER CONFIG';
        pk_alertlog.log_debug(g_error);
        l_show_board_number := get_triage_config_by_name(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_episode     => NULL,
                                                         i_triage_type => i_id_triage_type,
                                                         i_config      => 'FLG_ID_BOARD');
    
        IF i_id_triage_decision_point IS NULL
        THEN
            g_error := 'GET BOARD LABEL (2)';
            pk_alertlog.log_debug(g_error);
            SELECT decode(l_show_board_number, pk_alert_constant.g_yes, tb.board_number || ' - ') ||
                   pk_translation.get_translation(i_lang, tb.code_triage_board)
              INTO l_board_label
              FROM triage_board tb
             WHERE tb.id_triage_board = i_id_triage_board;
        
        ELSIF i_id_triage_decision_point IS NOT NULL
        THEN
            g_error := 'GET BOARD LABEL - DECISION POINT';
            pk_alertlog.log_debug(g_error);
            SELECT pk_translation.get_translation(i_lang, tdp.code_prefix_decision_point)
              INTO l_board_label
              FROM triage_decision_point tdp
             WHERE tdp.id_triage_decision_point = i_id_triage_decision_point;
        
        ELSE
            g_error := 'INVALID OR MISSING PARAMETERS';
            pk_alertlog.log_debug(g_error);
            RAISE l_param_error;
        END IF;
    
        RETURN l_board_label;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alertlog.log_warn(text            => g_error || ' (' || SQLCODE || ' - ' || SQLERRM || ')',
                                 object_name     => g_package_name,
                                 sub_object_name => l_func_name);
            RETURN NULL;
    END get_board_label;

    /**************************************************************************
    * Returns the discriminator description, according to the
    * type of triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis_triage         Triage event ID
    * @param i_acronym                Triage type acronym
    * @param i_id_disc                Discriminator ID
    * @param i_id_disc_parent         Discriminator parent ID
    * @param i_code_disc              Code for translation: discriminator
    * @param i_selected_option        Option selected by user to confirm discriminator (Yes/No)
    *
    * @return                         Label with the discriminator description
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          22/12/2009
    **************************************************************************/
    FUNCTION get_discriminator_desc
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_triage_type  IN triage_type.id_triage_type%TYPE,
        i_acronym         IN triage_type.acronym%TYPE,
        i_id_disc         IN triage_discriminator.id_triage_discriminator%TYPE,
        i_id_disc_parent  IN triage_discriminator.id_parent%TYPE,
        i_code_disc       IN triage_discriminator.code_triage_discriminator%TYPE,
        i_selected_option IN epis_triage.flg_selected_option%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name          VARCHAR2(200) := 'GET_DISCRIMINATOR_DESC';
        l_disc_label         VARCHAR2(4000);
        l_acronym            triage_type.acronym%TYPE;
        l_code_disc          triage_discriminator.code_triage_discriminator%TYPE;
        l_code_question_disc triage_discriminator.code_discrim_question%TYPE;
        l_config             sys_config.value%TYPE;
    
        l_is_question BOOLEAN := TRUE;
    
        l_error t_error_out;
        l_param_error EXCEPTION;
    BEGIN
    
        g_error  := 'GET CONFIGURATIONS';
        l_config := pk_sysconfig.get_config('NOT_TRIAGE_QUESTION', i_prof.institution, i_prof.software);
    
        -- Check if current discriminator is not a question, and should NOT be shown in the format:
        --       <Question>? <Answer>
        -- This is used for the blue discriminators, like 'No discriminators were selected'.
        IF instr(l_config, '|' || i_id_disc || '|') > 0
        THEN
            l_is_question := FALSE;
        END IF;
    
        -- Get the triage type acronym
        IF i_acronym IS NULL
           AND i_id_triage_type IS NOT NULL
        THEN
            g_error := 'GET TRIAGE ACRONYM';
            SELECT tt.acronym
              INTO l_acronym
              FROM triage_type tt
             WHERE tt.id_triage_type = i_id_triage_type;
        ELSIF i_acronym IS NOT NULL
        THEN
            l_acronym := i_acronym;
        ELSE
            g_error := 'INVALID/NULL TRIAGE TYPE';
            RAISE l_param_error;
        END IF;
    
        IF l_acronym = g_est
           AND i_id_disc IS NULL
        THEN
            l_disc_label := pk_message.get_message(i_lang => i_lang, i_code_mess => g_code_msg_not_applicable);
        ELSE
            IF i_code_disc IS NULL
            THEN
                g_error := 'GET CODES FOR TRANSLATION';
                SELECT td.code_triage_discriminator, td.code_discrim_question
                  INTO l_code_disc, l_code_question_disc
                  FROM triage_discriminator td
                 WHERE td.id_triage_discriminator = i_id_disc;
            ELSE
                l_code_disc := i_code_disc;
            END IF;
        
            -- Setup the discriminator label
            IF l_acronym IN (g_manchester, g_manchester_nl, g_manchester_uk, g_esi)
               AND l_is_question
            THEN
                IF i_id_disc_parent IS NULL
                THEN
                    -- No parent discriminator, show label as: "<Discriminator/Question>? <Yes/No>"
                    g_error := 'GET DISCRIMINATOR LABEL (1)';
                    pk_alertlog.log_debug(g_error);
                    l_disc_label := pk_translation.get_translation(i_lang, l_code_question_disc) ||
                                    pk_sysdomain.get_domain(g_code_domain_yes_no, i_selected_option, i_lang);
                ELSE
                    -- If exists parent discriminator, show label as: "<Parent discriminator/Question>? <Child discriminator/Answer>"
                    g_error := 'GET DISCRIMINATOR LABEL (2)';
                    pk_alertlog.log_debug(g_error);
                    SELECT pk_translation.get_translation(i_lang, td2.code_discrim_question) || ' ' ||
                           pk_translation.get_translation(i_lang, l_code_disc)
                      INTO l_disc_label
                      FROM triage_discriminator td
                      JOIN triage_discriminator td2
                        ON td2.id_triage_discriminator = td.id_triage_discriminator
                     WHERE td.id_triage_discriminator = i_id_disc_parent;
                END IF;
            
            ELSE
                -- Other triage types only show the discriminator; or, discriminators that aren't questions.
                g_error := 'GET DISCRIMINATOR LABEL (OTHER)';
                pk_alertlog.log_debug(g_error);
                l_disc_label := pk_translation.get_translation(i_lang, l_code_disc);
            
            END IF;
        END IF;
    
        RETURN l_disc_label;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_discriminator_desc;

    /**************************************************************************
    * Returns the ESI level if patient was triaged with ESI protocol.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_epis                   Episode ID
    * @param i_triage_color           Triage color ID    
    * @param i_type                   Description type: 
    *                                             - (S) Short description (e.g. "1", "2",...)
    *                                             - (F) Full description (e.g. "ESI 1", "ESI 2",...)
    *
    * @return                         ESI level number
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          12/01/2010
    **************************************************************************/
    FUNCTION get_epis_esi_level
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis         IN episode.id_episode%TYPE,
        i_triage_color IN triage_color.id_triage_color%TYPE,
        i_type         IN VARCHAR2 DEFAULT 'S'
    ) RETURN VARCHAR2 IS
        l_esi_level_desc VARCHAR2(200 CHAR);
    
        l_type_short CONSTANT VARCHAR2(1 CHAR) := 'S'; -- Short description (e.g. "1", "2",...)
        l_type_full  CONSTANT VARCHAR2(1 CHAR) := 'F'; -- Full description (e.g. "ESI 1", "ESI 2",...)
        l_type VARCHAR2(1 CHAR);
    BEGIN
        l_type := nvl(i_type, l_type_short);
    
        IF i_triage_color IS NULL
        THEN
            RETURN NULL;
        ELSIF l_type NOT IN (l_type_short, l_type_full)
        THEN
            RETURN NULL;
        END IF;
    
        BEGIN
            g_error := 'GET ESI LEVEL';
            pk_alertlog.log_debug(g_error);
            SELECT decode(l_type,
                          l_type_short,
                          to_char(telvl.esi_level),
                          (SELECT pk_translation.get_translation(i_lang, tco.code_triage_color)
                             FROM triage_color tco
                            WHERE tco.id_triage_color = telvl.id_triage_color))
              INTO l_esi_level_desc
              FROM triage_esi_level telvl
             WHERE telvl.id_triage_color = i_triage_color;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END;
    
        RETURN l_esi_level_desc;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_epis_esi_level;

    /**************************************************************************
    * Get the triage color information to display in the detail
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_type                   Info type: T - title, V - value
    * @param i_triage_type            Triage type ID
    * @param i_triage_color           Triage color ID
    * @param i_format                 L - long (default), S - short (just "Degré 1")
    *
    * @return                         Triage color description
    *                        
    * @author                         José Silva
    * @version                        2.6.0.3
    * @since                          04/11/2010
    **************************************************************************/
    FUNCTION get_triage_color_orig
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_type         IN VARCHAR2,
        i_triage_type  IN triage_type.id_triage_type%TYPE,
        i_triage_color IN triage_color.id_triage_color%TYPE,
        i_format       IN VARCHAR2 DEFAULT 'L'
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(200) := 'GET_TRIAGE_COLOR_INFO';
        l_ret       sys_message.desc_message%TYPE := '';
        l_error     t_error_out;
        l_title     sys_message.desc_message%TYPE;
    
        l_triage_no_info CONSTANT triage_type.id_triage_type%TYPE := 10;
    BEGIN
    
        g_error := 'CHECK TRIAGE TYPE';
        IF i_triage_type = g_triage_id_est
        THEN
            SELECT pk_message.get_message(i_lang, 'TRIAGE_EST_M004')
              INTO l_title
              FROM dual;
        ELSE
            SELECT pk_message.get_message(i_lang, 'TRIAGE_T010')
              INTO l_title
              FROM dual;
        END IF;
    
        g_error := 'GET COLOR ORIG';
        IF i_type = g_type_color_title
        THEN
            l_ret := l_title;
        ELSIF i_type = g_type_color_value
        THEN
            IF i_triage_color IS NOT NULL
               AND i_triage_type <> l_triage_no_info
            THEN
                l_ret := pk_translation.get_translation(i_lang, 'TRIAGE_COLOR.CODE_TRIAGE_COLOR.' || i_triage_color);
            
                IF i_format = 'L'
                THEN
                    l_ret := l_ret || ' - ' ||
                             pk_translation.get_translation(i_lang, 'TRIAGE_COLOR.CODE_ACCUITY.' || i_triage_color);
                END IF;
            END IF;
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN '';
    END get_triage_color_orig;

    /**************************************************************************
    * Returns the identifier for the "no triage" color, according to the
    * type of triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_triage_type         Triage type ID
    *
    * @return                         Color ID
    *                        
    * @author                         Pedro Fernandes
    * @version                        2.6
    * @since                          05/09/2016
    **************************************************************************/
    FUNCTION get_flag_no_color
    (
        i_lang        IN language.id_language%TYPE,
        i_prof        IN profissional,
        i_no_color_id IN triage_color.id_triage_color%TYPE
    ) RETURN VARCHAR IS
        l_func_name      VARCHAR2(200) := 'GET_FLAG_NO_COLOR';
        l_no_color_id    triage_color.flg_type%TYPE;
        l_id_triage_type triage_type.id_triage_type%TYPE;
        l_dummy          triage_type.acronym%TYPE;
        l_no_color_flg   triage_color_group.flg_type%TYPE := 'N';
        l_internal_error EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        IF i_no_color_id IS NULL
        THEN
        
            RETURN l_no_color_flg;
        
        END IF;
    
        g_error := 'GET_FLAG_NO_COLOR';
        pk_alertlog.log_debug(g_error);
    
        SELECT tco.flg_type
          INTO l_no_color_flg
          FROM triage_type tt
          JOIN triage_color tco
            ON tco.id_triage_type = tt.id_triage_type
          JOIN triage_color_group tcg
            ON tcg.id_triage_color_group = tco.id_triage_color_group
         WHERE tco.id_triage_color = i_no_color_id;
    
        RETURN l_no_color_flg;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_flag_no_color;
    /**************************************************************************
    * Returns the identifier for the "no triage" color, according to the
    * type of triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_triage_type         Triage type ID
    *
    * @return                         Color ID
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          23/12/2009
    **************************************************************************/
    FUNCTION get_id_no_color
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_triage_type IN triage_type.id_triage_type%TYPE
    ) RETURN NUMBER IS
        l_func_name      VARCHAR2(200) := 'GET_ID_NO_COLOR';
        l_no_color_id    triage_color.id_triage_color%TYPE;
        l_id_triage_type triage_type.id_triage_type%TYPE;
        l_dummy          triage_type.acronym%TYPE;
    
        l_internal_error EXCEPTION;
        l_error t_error_out;
    BEGIN
    
        IF i_id_triage_type IS NULL
        THEN
            g_error := 'GET DEFAULT TRIAGE TYPE';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_edis_triage.get_default_triage_type(i_lang           => i_lang,
                                                          i_prof           => i_prof,
                                                          o_triage_type    => l_id_triage_type,
                                                          o_triage_acronym => l_dummy,
                                                          o_error          => l_error)
            THEN
                RAISE l_internal_error;
            END IF;
        ELSE
            l_id_triage_type := i_id_triage_type;
        END IF;
    
        g_error := 'GET NO COLOR ID';
        pk_alertlog.log_debug(g_error);
        SELECT tco.id_triage_color
          INTO l_no_color_id
          FROM triage_type tt
          JOIN triage_color tco
            ON tco.id_triage_type = tt.id_triage_type
          JOIN triage_color_group tcg
            ON tcg.id_triage_color_group = tco.id_triage_color_group
         WHERE tt.id_triage_type = l_id_triage_type
           AND tcg.flg_type = 'S';
    
        RETURN l_no_color_id;
    
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              l_error.ora_sqlcode,
                                              l_error.ora_sqlerrm,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_id_no_color;

    /**************************************************************************
    * Parse XML parameter to database pl/sql record types
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_params                 XML with all input parameters
    * @param o_rec_triage             Triage record with all input parameters
    * @param o_error                  Error message
    *
    * @return                         TRUE if sucess, FALSE otherwise
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6.3
    * @since                          03/12/2012
    **************************************************************************/
    FUNCTION parse_triage_parameters
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_params     IN CLOB,
        o_rec_triage OUT pk_edis_types.rec_triage,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'PARSE_TRIAGE_PARAMETERS';
        --
        l_exception EXCEPTION;
        --
        l_root_node CONSTANT pk_translation.t_desc_translation := 'TRIAGE';
    
        CURSOR c_triage(i_triage IN xmltype) IS(
            SELECT a.id_patient,
                   a.id_episode,
                   a.id_triage_type,
                   a.id_triage_board,
                   a.id_triage_color, --ID_FINAL_COLOR in XML
                   a.id_triage_white_reason,
                   a.flg_changed_color,
                   a.id_triage_orig_color,
                   a.triage_duration,
                   a.notes,
                   a.accident_desc,
                   --CHECK_VS
                   a.chk_vs_flg_type,
                   extract(b.triage_records, '/TRIAGE/CHECK_VITAL_SIGNS') check_options,
                   --CONFIGURATIONS
                   a.flg_default_view,
                   a.flg_complaint,
                   --TABLES
                   extract(b.triage_records, '/TRIAGE/GROUP_OPTIONS') group_options,
                   extract(b.triage_records, '/TRIAGE/VITAL_SIGNS') vital_signs,
                   --TRIAGE_FORM
                   a.triage_form_int_name,
                   extract(b.triage_records, '/TRIAGE/TRIAGE_FORM') triage_form
              FROM (SELECT VALUE(p) triage_records
                      FROM TABLE(xmlsequence(extract(i_triage, '/TRIAGE'))) p) b,
                   xmltable('/TRIAGE' passing b.triage_records columns --
                            "ID_PATIENT" NUMBER(24) path '@ID_PATIENT', --
                            "ID_EPISODE" NUMBER(24) path '@ID_EPISODE', --
                            "ID_TRIAGE_TYPE" NUMBER(24) path '@ID_TRIAGE_TYPE', --
                            "ID_TRIAGE_BOARD" NUMBER(24) path '@ID_TRIAGE_BOARD', --
                            "ID_TRIAGE_WHITE_REASON" NUMBER(24) path '@ID_TRIAGE_WHITE_REASON', --
                            "ID_TRIAGE_COLOR" NUMBER(24) path '@ID_FINAL_COLOR', --
                            "FLG_CHANGED_COLOR" VARCHAR2(1 CHAR) path '@FLG_CHANGED_COLOR', --
                            "ID_TRIAGE_ORIG_COLOR" NUMBER(24) path '@ID_TRIAGE_ORIG_COLOR', --
                            "TRIAGE_DURATION" NUMBER(24) path '@TRIAGE_DURATION', --
                            "NOTES" VARCHAR2(1000 CHAR) path './FINAL_NOTES/.', --
                            "ACCIDENT_DESC" VARCHAR2(200 CHAR) path '@ACCIDENT_DESC', --
                            --CHECK_VS
                            "CHK_VS_FLG_TYPE" VARCHAR2(1 CHAR) path 'CHECK_VITAL_SIGNS/@FLG_TYPE', --
                            --CONFIGURATIONS
                            "FLG_DEFAULT_VIEW" VARCHAR2(2 CHAR) path '@FLG_DEFAULT_VIEW', --
                            "FLG_COMPLAINT" VARCHAR2(1 CHAR) path '@FLG_COMPLAINT', --
                            --CONFIGURATIONS
                            "TRIAGE_FORM_INT_NAME" VARCHAR2(200 CHAR) path 'TRIAGE_FORM/@INTERNAL_NAME' --
                            ) a);
    
        CURSOR c_check_options(i_check_options IN xmltype) IS(
            SELECT a.id_triage_board, a.id_triage_discriminator
              FROM (SELECT VALUE(p) check_options
                      FROM TABLE(xmlsequence(extract(i_check_options, '/CHECK_VITAL_SIGNS/CHECK_OPTION'))) p) b,
                   xmltable('/CHECK_OPTION' passing b.check_options columns --
                            "ID_TRIAGE_BOARD" NUMBER(24) path '@ID_TRIAGE_BOARD', --
                            "ID_TRIAGE_DISCRIMINATOR" NUMBER(24) path '@ID_TRIAGE_DISCRIMINATOR' --
                            ) a);
    
        CURSOR c_group_options(i_group_options IN xmltype) IS(
            SELECT a.id_triage_color, extract(b.group_options, '/GROUP_OPTION/OPTION') options
              FROM (SELECT VALUE(p) group_options
                      FROM TABLE(xmlsequence(extract(i_group_options, '/GROUP_OPTIONS/GROUP_OPTION'))) p) b,
                   xmltable('/GROUP_OPTION' passing b.group_options columns --
                            "ID_TRIAGE_COLOR" NUMBER(12) path '@ID_TRIAGE_COLOR' --
                            ) a);
    
        CURSOR c_options(i_options IN xmltype) IS(
            SELECT a.id_triage_discriminator,
                   a.id_triage,
                   (SELECT t.flg_reassess
                      FROM triage t
                     WHERE t.id_triage = a.id_triage) flg_reassess,
                   (decode((SELECT COUNT(1)
                             FROM triage_disc_consent tdc2
                            WHERE tdc2.id_triage_discriminator = a.id_triage_discriminator),
                           0,
                           pk_alert_constant.g_no,
                           pk_alert_constant.g_yes)) flg_triage_cons_mandatory,
                   a.id_triage_cons_value,
                   pk_message.get_message(i_lang, tcv.code_cons_detail_msg) title_consent,
                   pk_translation.get_translation(i_lang, tcv.code_triage_cons_value) desc_consent,
                   tdc.flg_vs_mandatory flg_triage_cons_vs_mand,
                   tdc.flg_vs_enable flg_triage_cons_vs_enab,
                   a.flg_selected_option,
                   a.urgency_level, --It's the urgency_level related with the user answer (It can be the urgency_level of the discriminator or the urgency_level_other)
                   nvl(a.id_triage_color,
                       (SELECT t.id_triage_color
                          FROM triage t
                         WHERE t.id_triage = a.id_triage)) id_triage_color, --It's the id_triage_color related with the user answer (It can be the id_triage_color of the discriminator or the id_triage_color_other)
                   decode(flg_type, g_flg_context_check_critical, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_critical_look,
                   extract(b.options, '/OPTION/CHILD_OPTION') child_option
              FROM (SELECT VALUE(p) options
                      FROM TABLE(xmlsequence(extract(i_options, '/OPTION'))) p) b,
                   xmltable('/OPTION' passing b.options columns --
                            "ID_TRIAGE_DISCRIMINATOR" NUMBER(24) path '@ID_TRIAGE_DISCRIMINATOR', --
                            "ID_TRIAGE" NUMBER(24) path '@ID_TRIAGE', --
                            "ID_TRIAGE_CONS_VALUE" NUMBER(24) path '@ID_TRIAGE_CONS_VALUE', --
                            "FLG_SELECTED_OPTION" VARCHAR2(1 CHAR) path '@FLG_SELECTED_OPTION', --
                            "URGENCY_LEVEL" VARCHAR2(1 CHAR) path '@URGENCY_LEVEL', --
                            "ID_TRIAGE_COLOR" NUMBER(24) path '@ID_TRIAGE_COLOR',
                            "FLG_TYPE" VARCHAR2(1 CHAR) path '@FLG_TYPE' --
                            ) a,
                   triage_disc_consent tdc,
                   triage_cons_value tcv
             WHERE tdc.id_triage_discriminator(+) = a.id_triage_discriminator
               AND tdc.id_triage_cons_value(+) = a.id_triage_cons_value
               AND tcv.id_triage_cons_value(+) = tdc.id_triage_cons_value);
    
        CURSOR c_child_option(i_child_option IN xmltype) IS(
            SELECT a.id_triage_discriminator
              FROM (SELECT VALUE(p) child_option
                      FROM TABLE(xmlsequence(extract(i_child_option, '/CHILD_OPTION'))) p) b,
                   xmltable('/CHILD_OPTION' passing b.child_option columns --
                            "ID_TRIAGE_DISCRIMINATOR" NUMBER(24) path '@ID_TRIAGE_DISCRIMINATOR' --
                            ) a);
    
        CURSOR c_vital_signs
        (
            i_vital_signs IN xmltype,
            i_age         IN vital_sign_unit_measure.age_min%TYPE
        ) IS(
            SELECT x.id_vital_sign,
                   decode(pk_vital_sign.get_vital_sign_type(i_vital_sign => x.id_vital_sign),
                          'C',
                          pk_vital_sign.get_vs_parent_triage(i_vital_sign => x.id_vital_sign),
                          NULL) id_vital_sign_parent,
                   x.value,
                   x.id_unit_measure,
                   CASE
                        WHEN vsi.id_unit_measure IS NULL THEN
                         NULL
                        ELSE
                         pk_vital_sign.get_vital_sign_unit_measure(i_lang, vsi.id_unit_measure, NULL)
                    END desc_unit_measure,
                   x.id_scales_element,
                   x.flg_save,
                   x.flg_fill_type,
                   x.urgency_level,
                   decode(vsr.id_vital_sign_relation,
                          NULL,
                          pk_translation.get_translation(i_lang, vs.code_vital_sign),
                          -- Return the parent's name if it's a child of BLOOD PRESSURE
                          (SELECT pk_translation.get_translation(i_lang, vs1.code_vital_sign)
                             FROM vital_sign vs1
                            WHERE vs1.id_vital_sign = vsr.id_vital_sign_parent)) desc_vital_sign,
                   vs.intern_name_vital_sign,
                   (SELECT pk_vital_sign_core.get_vsum_val_min(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_id_vital_sign   => vsi.id_vital_sign,
                                                               i_id_unit_measure => vsi.id_unit_measure,
                                                               i_id_institution  => i_prof.institution,
                                                               i_id_software     => i_prof.software,
                                                               i_age             => i_age)
                      FROM dual) val_min,
                   (SELECT pk_vital_sign_core.get_vsum_val_max(i_lang            => i_lang,
                                                               i_prof            => i_prof,
                                                               i_id_vital_sign   => vsi.id_vital_sign,
                                                               i_id_unit_measure => vsi.id_unit_measure,
                                                               i_id_institution  => i_prof.institution,
                                                               i_id_software     => i_prof.software,
                                                               i_age             => i_age)
                      FROM dual) val_max,
                   vsi.id_unit_measure id_config_unit_mea
              FROM (SELECT a.id_vital_sign,
                           a.value,
                           a.id_unit_measure,
                           a.id_scales_element,
                           a.flg_save,
                           a.flg_fill_type,
                           a.urgency_level
                      FROM (SELECT VALUE(p) vital_sign
                              FROM TABLE(xmlsequence(extract(i_vital_signs, '/VITAL_SIGNS/VITAL_SIGN'))) p) b,
                           xmltable('/VITAL_SIGN' passing b.vital_sign columns --
                                    "ID_VITAL_SIGN" NUMBER(24) path '@ID_VITAL_SIGN', --
                                    "VALUE" NUMBER(10, 3) path '@VALUE', --
                                    "ID_UNIT_MEASURE" NUMBER(24) path '@ID_UNIT_MEASURE', --
                                    "ID_SCALES_ELEMENT" NUMBER(24) path '@ID_SCALES_ELEMENT', --
                                    "FLG_SAVE" VARCHAR2(1 CHAR) path '@FLG_SAVE_TO_DB', --
                                    "FLG_FILL_TYPE" VARCHAR2(1 CHAR) path '@FLG_FILL_TYPE', --
                                    "URGENCY_LEVEL" NUMBER(6) path '@URGENCY_LEVEL') a) x
              JOIN vital_sign vs
                ON vs.id_vital_sign = x.id_vital_sign
              LEFT JOIN vs_soft_inst vsi
                ON vsi.id_vital_sign = vs.id_vital_sign
               AND vsi.id_software = i_prof.software
               AND vsi.id_institution = i_prof.institution
              LEFT JOIN vital_sign_relation vsr
                ON vsr.id_vital_sign_detail = vs.id_vital_sign
               AND vsr.relation_domain = 'C'
               AND vsr.flg_available = pk_alert_constant.g_yes
             WHERE nvl(vsi.flg_view, pk_edis_triage.g_flg_view_t) = pk_edis_triage.g_flg_view_t -- Blood pressure's FLG_VIEW (systolic/diastolic) are NULL
             );
    
        CURSOR c_form_sections(i_triage_form IN xmltype) IS(
            SELECT a.section_internal_name, extract(b.triage_form, '/SECTION') leafs
              FROM (SELECT VALUE(p) triage_form
                      FROM TABLE(xmlsequence(extract(i_triage_form, '/TRIAGE_FORM/SECTION'))) p) b,
                   xmltable('/SECTION' passing b.triage_form columns --
                            "SECTION_INTERNAL_NAME" VARCHAR2(200 CHAR) path '@INTERNAL_NAME' --
                            ) a);
    
        CURSOR c_sections_leafs(i_form_section IN xmltype) IS(
            SELECT a.leaf_internal_name, a.leaf_value, extract(b.triage_form, '/LEAF') selected_items
              FROM (SELECT VALUE(p) triage_form
                      FROM TABLE(xmlsequence(extract(i_form_section, '/SECTION/LEAF'))) p) b,
                   xmltable('/LEAF' passing b.triage_form columns --
                            "LEAF_INTERNAL_NAME" VARCHAR2(200 CHAR) path '@INTERNAL_NAME', --
                            "LEAF_VALUE" VARCHAR2(1000 CHAR) path '/.' --
                            ) a);
    
        CURSOR c_selected_items(i_selected_items IN xmltype) IS(
            SELECT a.item_value, a.alt_value
              FROM (SELECT VALUE(p) selected_items
                      FROM TABLE(xmlsequence(extract(i_selected_items, '/LEAF/SELECTED_ITEM'))) p) b,
                   xmltable('/SELECTED_ITEM' passing b.selected_items columns --
                            "ITEM_VALUE" NUMBER(24) path '@VALUE', --
                            "ALT_VALUE" VARCHAR2(2 CHAR) path '@ALT_VALUE') a);
        --
        r_triage            c_triage%ROWTYPE;
        r_selected_item     c_selected_items%ROWTYPE;
        l_rec_triage        pk_edis_types.rec_triage;
        l_tbl_check_options pk_edis_types.table_check_options;
        l_tbl_group_options pk_edis_types.table_group_options;
        l_rec_group_option  pk_edis_types.rec_group_option;
        l_tbl_options       pk_edis_types.table_options;
        l_rec_option        pk_edis_types.rec_option;
        l_rec_discrim_child pk_edis_types.rec_discrim_child;
        l_tbl_needs         pk_edis_types.table_needs;
        l_rec_need          pk_edis_types.rec_need;
        l_tbl_vital_signs   pk_edis_types.table_vital_signs;
        l_rec_vital_sign    pk_edis_types.rec_vital_sign;
        l_vs_rank           vs_soft_inst.rank%TYPE := 1;
        --
        l_peak_flow_expiratory_value vital_sign_read.value%TYPE := NULL;
        l_peak_flow_expected_index   PLS_INTEGER := NULL;
        l_peak_flow_expected_value   vital_sign_read.value%TYPE := NULL;
        --
        l_shock_index            PLS_INTEGER := NULL;
        l_blood_press_syst_value vital_sign_read.value%TYPE := NULL;
        l_heart_rate_value       vital_sign_read.value%TYPE := NULL;
        l_height_value           vital_sign_read.value%TYPE := NULL;
        --
        FUNCTION get_selected_item(i_selected_items IN xmltype) RETURN c_selected_items%ROWTYPE IS
            l_selected_item c_selected_items%ROWTYPE;
        BEGIN
            OPEN c_selected_items(i_selected_items => i_selected_items);
            FETCH c_selected_items
                INTO l_selected_item;
            CLOSE c_selected_items;
        
            RETURN l_selected_item;
        END get_selected_item;
        --
        --Calculates the ratio between the read value and the expected one
        FUNCTION get_peak_flow_percentage
        (
            i_expiratory_value IN vital_sign_read.value%TYPE,
            i_expected_value   IN vital_sign_read.value%TYPE
        ) RETURN vital_sign_read.value%TYPE IS
            l_ret vital_sign_read.value%TYPE := NULL;
        BEGIN
            IF i_expiratory_value IS NOT NULL
               AND i_expected_value IS NOT NULL
            THEN
                l_ret := i_expiratory_value / i_expected_value;
            END IF;
        
            RETURN l_ret;
        END get_peak_flow_percentage;
        --
        --Calculates the shock index value
        FUNCTION get_shock_index
        (
            i_lang                    IN language.id_language%TYPE,
            i_prof                    IN profissional,
            i_heart_rate              IN vital_sign_read.value%TYPE,
            i_systolic_blood_pressure IN vital_sign_read.value%TYPE
        ) RETURN vital_sign_desc.id_vital_sign_desc%TYPE IS
            l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_SHOCK_INDEX';
            --
            l_vsd_content_positive   CONSTANT vital_sign_desc.id_content%TYPE := 'TMP35.4114';
            l_vsd_content_negative   CONSTANT vital_sign_desc.id_content%TYPE := 'TMP35.4115';
            l_vs_content_shock_index CONSTANT vital_sign.id_content%TYPE := 'TMP33.3494';
            --
            l_market     market.id_market%TYPE;
            l_vital_sign vital_sign.id_vital_sign%TYPE;
            --
            l_ret vital_sign_desc.id_vital_sign_desc%TYPE;
        BEGIN
            IF i_heart_rate IS NOT NULL
               AND i_systolic_blood_pressure IS NOT NULL
            THEN
                g_error := 'GET SHOCK INDEX VS ID';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                SELECT vs.id_vital_sign
                  INTO l_vital_sign
                  FROM vital_sign vs
                 WHERE vs.id_content = l_vs_content_shock_index;
            
                g_error := 'CALL PK_UTILS.GET_INSTITUTION_MARKET';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_market := pk_utils.get_institution_market(i_lang => i_lang, i_id_institution => i_prof.institution);
            
                g_error := 'GET ID_MARKET TO BE USED';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                SELECT t.id_market
                  INTO l_market
                  FROM (SELECT vsd.id_market,
                               row_number() over(ORDER BY decode(vsd.id_market, l_market, 1, 2)) line_number
                          FROM vital_sign_desc vsd
                         WHERE vsd.id_vital_sign = l_vital_sign
                           AND vsd.flg_available = pk_alert_constant.g_yes
                           AND vsd.id_market IN (pk_alert_constant.g_id_market_all, l_market)) t
                 WHERE t.line_number = 1;
            
                g_error := 'GET ID_VITAL_SIGN_DESC';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                SELECT vsd.id_vital_sign_desc
                  INTO l_ret
                  FROM vital_sign_desc vsd
                 WHERE vsd.id_vital_sign = l_vital_sign
                   AND vsd.id_content = (CASE
                           WHEN i_heart_rate > i_systolic_blood_pressure THEN
                            l_vsd_content_positive
                           ELSE
                            l_vsd_content_negative
                       END)
                   AND vsd.id_market = l_market;
            ELSE
                l_ret := NULL;
            END IF;
        
            RETURN l_ret;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END get_shock_index;
        --
        FUNCTION get_vsd_attributes(i_rec_vital_sign IN pk_edis_types.rec_vital_sign) RETURN pk_edis_types.rec_vital_sign IS
            l_ret pk_edis_types.rec_vital_sign;
        BEGIN
            l_ret := i_rec_vital_sign;
        
            l_ret.desc_value := pk_vital_sign.get_vsd_desc(i_lang            => i_lang,
                                                           i_vital_sign_desc => i_rec_vital_sign.id_vital_sign_desc,
                                                           i_patient         => l_rec_triage.id_patient);
        
            BEGIN
                SELECT vsd.value
                  INTO l_ret.vsd_value
                  FROM vital_sign_desc vsd
                 WHERE vsd.id_vital_sign_desc = i_rec_vital_sign.id_vital_sign_desc;
            EXCEPTION
                WHEN no_data_found THEN
                    l_ret.vsd_value := NULL;
            END;
        
            RETURN l_ret;
        END get_vsd_attributes;
    BEGIN
        IF i_params IS NOT NULL
           AND instr(i_params, l_root_node) != 0
        THEN
            g_error := 'CALL SET_NLS_NUMERIC_CHARACTERS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            set_nls_numeric_characters(i_prof => i_prof);
        
            g_error := 'OPEN C_TRIAGE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            OPEN c_triage(i_triage => xmltype(i_params));
        
            g_error := 'FETCH DATA INTO R_TRIAGE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FETCH c_triage
                INTO r_triage;
        
            g_error := 'CLOSE C_TRIAGE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            CLOSE c_triage;
        
            --TRIAGE
            l_rec_triage.id_patient             := r_triage.id_patient;
            l_rec_triage.id_episode             := r_triage.id_episode;
            l_rec_triage.id_triage_type         := r_triage.id_triage_type;
            l_rec_triage.id_triage_board        := r_triage.id_triage_board;
            l_rec_triage.id_triage_color        := r_triage.id_triage_color;
            l_rec_triage.id_triage_white_reason := r_triage.id_triage_white_reason;
            l_rec_triage.flg_changed_color      := r_triage.flg_changed_color;
            l_rec_triage.id_triage_orig_color   := r_triage.id_triage_orig_color;
            l_rec_triage.triage_duration        := r_triage.triage_duration;
            l_rec_triage.notes                  := r_triage.notes;
            l_rec_triage.accident_desc          := r_triage.accident_desc;
            --CHECK_VS
            l_rec_triage.check_vs.flg_type := r_triage.chk_vs_flg_type;
            --CONFIGURATIONS
            l_rec_triage.flg_default_view := r_triage.flg_default_view;
            l_rec_triage.flg_complaint    := r_triage.flg_complaint;
        
            g_error := 'FILL CHECK OPTIONS TABLE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_tbl_check_options := pk_edis_types.table_check_options();
        
            FOR r_check_option IN c_check_options(i_check_options => r_triage.check_options)
            LOOP
                l_tbl_check_options.extend;
                l_tbl_check_options(l_tbl_check_options.count).id_triage_board := r_check_option.id_triage_board;
                l_tbl_check_options(l_tbl_check_options.count).id_triage_discriminator := r_check_option.id_triage_discriminator;
            END LOOP;
        
            l_rec_triage.check_vs.check_options := l_tbl_check_options;
        
            g_error := 'FILL OPTIONS TABLE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_tbl_group_options := pk_edis_types.table_group_options();
        
            FOR r_group_option IN c_group_options(i_group_options => r_triage.group_options)
            LOOP
                l_rec_group_option.id_triage_color := r_group_option.id_triage_color;
            
                l_tbl_options := pk_edis_types.table_options();
                FOR r_option IN c_options(i_options => r_group_option.options)
                LOOP
                    l_rec_option.id_triage_discriminator := r_option.id_triage_discriminator;
                    l_rec_option.id_triage               := r_option.id_triage;
                    l_rec_option.flg_reassess            := r_option.flg_reassess;
                    l_rec_option.id_triage_cons_value    := r_option.id_triage_cons_value;
                    l_rec_option.title_consent           := r_option.title_consent;
                    l_rec_option.desc_consent            := r_option.desc_consent;
                    l_rec_option.flg_triage_cons_vs_mand := r_option.flg_triage_cons_vs_mand;
                    l_rec_option.flg_triage_cons_vs_enab := r_option.flg_triage_cons_vs_enab;
                    l_rec_option.flg_selected_option     := r_option.flg_selected_option;
                    l_rec_option.urgency_level           := r_option.urgency_level;
                    l_rec_option.id_triage_color         := r_option.id_triage_color;
                    l_rec_option.flg_critical_look       := r_option.flg_critical_look;
                
                    --initialize l_rec_child_option
                    l_rec_discrim_child.id_triage                := NULL;
                    l_rec_discrim_child.id_triage_color          := NULL;
                    l_rec_discrim_child.id_triage_color_other    := NULL;
                    l_rec_discrim_child.color_text               := NULL;
                    l_rec_discrim_child.acuity                   := NULL;
                    l_rec_discrim_child.id_triage_discriminator  := NULL;
                    l_rec_discrim_child.desc_discriminator       := NULL;
                    l_rec_discrim_child.flg_accepted_option      := NULL;
                    l_rec_discrim_child.flg_accuity_confirmation := NULL;
                    l_rec_discrim_child.flg_select_option        := NULL;
                    l_rec_discrim_child.esi_level_header         := NULL;
                
                    FOR r_child_option IN c_child_option(i_child_option => r_option.child_option)
                    LOOP
                        l_rec_discrim_child := get_discrim_child_rec(i_lang       => i_lang,
                                                                     i_prof       => i_prof,
                                                                     i_id_disc    => r_child_option.id_triage_discriminator,
                                                                     i_id_patient => l_rec_triage.id_patient);
                    END LOOP;
                
                    l_rec_option.child_option := l_rec_discrim_child;
                
                    l_tbl_options.extend;
                    l_tbl_options(l_tbl_options.count) := l_rec_option;
                END LOOP;
            
                l_rec_group_option.options := l_tbl_options;
            
                l_tbl_group_options.extend;
                l_tbl_group_options(l_tbl_group_options.count) := l_rec_group_option;
            END LOOP;
        
            l_rec_triage.group_options := l_tbl_group_options;
        
            g_error := 'FILL VITAL_SIGNS TABLE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_tbl_vital_signs := pk_edis_types.table_vital_signs();
        
            FOR r_vital_sign IN c_vital_signs(i_vital_signs => r_triage.vital_signs,
                                              i_age         => pk_patient.get_pat_age(i_lang,
                                                                                      NULL,
                                                                                      NULL,
                                                                                      NULL,
                                                                                      'MONTHS',
                                                                                      l_rec_triage.id_patient))
            LOOP
                l_rec_vital_sign.id_vital_sign        := r_vital_sign.id_vital_sign;
                l_rec_vital_sign.desc_vital_sign      := r_vital_sign.desc_vital_sign;
                l_rec_vital_sign.id_vital_sign_parent := r_vital_sign.id_vital_sign_parent;
                l_rec_vital_sign.id_unit_measure      := r_vital_sign.id_unit_measure;
                l_rec_vital_sign.desc_unit_measure    := r_vital_sign.desc_unit_measure;
                l_rec_vital_sign.internal_name        := r_vital_sign.intern_name_vital_sign;
                l_rec_vital_sign.flg_fill_type        := r_vital_sign.flg_fill_type;
                l_rec_vital_sign.val_min              := r_vital_sign.val_min;
                l_rec_vital_sign.val_max              := r_vital_sign.val_max;
                l_rec_vital_sign.id_config_unit_mea   := r_vital_sign.id_config_unit_mea;
            
                l_rec_vital_sign.rank := l_vs_rank;
                l_vs_rank             := l_vs_rank + 1;
            
                --Initialize this values so the previous ones aren't used
                l_rec_vital_sign.value              := NULL;
                l_rec_vital_sign.id_vital_sign_desc := NULL;
                l_rec_vital_sign.vsd_value          := NULL;
            
                IF r_vital_sign.flg_fill_type = pk_alert_constant.g_vs_ft_multichoice
                THEN
                    l_rec_vital_sign.id_vital_sign_desc := r_vital_sign.value;
                    l_rec_vital_sign                    := get_vsd_attributes(i_rec_vital_sign => l_rec_vital_sign);
                ELSE
                    l_rec_vital_sign.value := r_vital_sign.value;
                END IF;
            
                l_rec_vital_sign.id_scales_element := r_vital_sign.id_scales_element;
                l_rec_vital_sign.flg_save          := r_vital_sign.flg_save;
                l_rec_vital_sign.urgency_level     := r_vital_sign.urgency_level;
            
                --ALERT-275364 - EST New requirement: The system must provide the ability to ignore the urgency level obtained by the index the choc whenever required
                IF l_rec_vital_sign.internal_name = pk_edis_triage.g_vs_shock_index
                THEN
                    SELECT nvl(extract(r_triage.triage_form, '/TRIAGE_FORM/SECTION/LEAF[@INTERNAL_NAME="Index_Choc_IGNORE_RESULT"]/SELECTED_ITEM/@ALT_VALUE').getstringval(),
                               pk_alert_constant.g_no) "IS_TO_IGNORE_RESULT"
                      INTO l_rec_vital_sign.is_to_ignore_result
                      FROM dual;
                ELSE
                    l_rec_vital_sign.is_to_ignore_result := pk_alert_constant.g_no;
                END IF;
            
                l_tbl_vital_signs.extend;
                l_tbl_vital_signs(l_tbl_vital_signs.count) := l_rec_vital_sign;
            
                --START - Automatic VS calculation - Peak-flow logic and Shock index
                CASE l_rec_vital_sign.internal_name
                    WHEN pk_edis_triage.g_vs_peak_flow_expiratory THEN
                        l_peak_flow_expiratory_value := l_rec_vital_sign.value;
                    WHEN pk_edis_triage.g_vs_peak_flow_expected THEN
                        l_peak_flow_expected_index := l_tbl_vital_signs.count; --I will need to calculate the peak-flow percentage and update this record with the result
                    WHEN pk_edis_triage.g_vs_shock_index THEN
                        l_shock_index := l_tbl_vital_signs.count;
                    WHEN pk_edis_triage.g_vs_blood_pressure_s THEN
                        l_blood_press_syst_value := l_rec_vital_sign.value;
                    WHEN pk_edis_triage.g_vs_pulse THEN
                        l_heart_rate_value := l_rec_vital_sign.value;
                    WHEN pk_edis_triage.g_vs_height THEN
                        l_height_value := l_rec_vital_sign.value;
                    ELSE
                        NULL;
                END CASE;
                --END   - Automatic VS calculation - Peak-flow logic and Shock index
            END LOOP;
        
            --START - Automatic VS calculation - Peak-flow logic and Shock index
            IF l_peak_flow_expected_index IS NOT NULL
            THEN
                g_error := 'CALL PK_VITAL_SIGN.GET_PEAK_FLOW_PREDICT';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_tbl_vital_signs(l_peak_flow_expected_index).value := pk_vital_sign.get_peak_flow_predict(i_lang       => i_lang,
                                                                                                           i_prof       => i_prof,
                                                                                                           i_pat_age    => pk_patient.get_pat_age(i_lang        => i_lang,
                                                                                                                                                  i_dt_birth    => NULL,
                                                                                                                                                  i_dt_deceased => NULL,
                                                                                                                                                  i_age         => NULL,
                                                                                                                                                  i_age_format  => 'YEARS',
                                                                                                                                                  i_patient     => l_rec_triage.id_patient),
                                                                                                           i_pat_gender => pk_patient.get_pat_gender(i_id_patient => l_rec_triage.id_patient),
                                                                                                           i_pat_height => l_height_value);
            
                l_peak_flow_expected_value := l_tbl_vital_signs(l_peak_flow_expected_index).value;
            
                g_error := 'CALCULATE PEAK_FLOW_PERCENTAGE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_tbl_vital_signs(l_peak_flow_expected_index).peak_flow_percentage := get_peak_flow_percentage(i_expiratory_value => l_peak_flow_expiratory_value,
                                                                                                               i_expected_value   => l_peak_flow_expected_value);
            END IF;
        
            IF l_shock_index IS NOT NULL
            THEN
                g_error := 'CALCULATE SHOCK_INDEX';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_tbl_vital_signs(l_shock_index).id_vital_sign_desc := get_shock_index(i_lang                    => i_lang,
                                                                                       i_prof                    => i_prof,
                                                                                       i_heart_rate              => l_heart_rate_value,
                                                                                       i_systolic_blood_pressure => l_blood_press_syst_value);
            
                IF l_tbl_vital_signs(l_shock_index).id_vital_sign_desc IS NOT NULL
                THEN
                    l_tbl_vital_signs(l_shock_index) := get_vsd_attributes(i_rec_vital_sign => l_tbl_vital_signs(l_shock_index));
                END IF;
            END IF;
            --END   - Automatic VS calculation - Peak-flow logic and Shock index
        
            l_rec_triage.vital_signs := l_tbl_vital_signs;
        
            g_error := 'LOOP THROUGH TRIAGE_FORM';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR r_form_section IN c_form_sections(i_triage_form => r_triage.triage_form)
            LOOP
                FOR r_section_leaf IN c_sections_leafs(i_form_section => r_form_section.leafs)
                LOOP
                    CASE
                        WHEN r_triage.triage_form_int_name = pk_edis_triage.g_ds_comp_triage_est THEN
                            --EST FORM
                            CASE r_section_leaf.leaf_internal_name
                                WHEN pk_edis_triage.g_ds_comp_est_entourage THEN
                                    --Free Text
                                    l_rec_triage.emergency_contact := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_est_motif_entree THEN
                                    --Free text
                                    l_rec_triage.chief_complaint := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_est_femme_enceinte THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.pregnant.flg_pregnant := nvl(r_selected_item.alt_value,
                                                                              pk_alert_constant.g_no);
                                WHEN pk_edis_triage.g_ds_comp_est_femme_encnt_wks THEN
                                    --Numeric keypad
                                    l_rec_triage.pregnant.pregnancy_weeks := to_number(r_section_leaf.leaf_value);
                                WHEN pk_edis_triage.g_ds_comp_est_femme_1mois_pp THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.pregnant.flg_postpartum := nvl(r_selected_item.alt_value,
                                                                                pk_alert_constant.g_no);
                                WHEN pk_edis_triage.g_ds_comp_est_traitement THEN
                                    --Free text
                                    l_rec_triage.treatment := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_est_notes THEN
                                    --Free text
                                    l_rec_triage.initial_notes := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_cause THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.cause_comments.id_external_cause := r_selected_item.item_value;
                                WHEN pk_edis_triage.g_ds_comp_comments THEN
                                    --Free text
                                    l_rec_triage.cause_comments.comments := r_section_leaf.leaf_value;
                                WHEN g_ds_comp_est_needs THEN
                                    --Multichoice with multiple choices
                                    g_error := 'FILL NEEDS TABLE';
                                    pk_alertlog.log_debug(object_name     => g_package_name,
                                                          sub_object_name => l_func_name,
                                                          text            => g_error);
                                    l_tbl_needs := pk_edis_types.table_needs();
                                
                                    FOR r_selected_item IN c_selected_items(i_selected_items => r_section_leaf.selected_items)
                                    LOOP
                                        l_rec_need.id_necessity := r_selected_item.item_value;
                                        l_rec_need.flg_status   := nvl(r_selected_item.alt_value,
                                                                       pk_alert_constant.g_active);
                                    
                                        l_tbl_needs.extend;
                                        l_tbl_needs(l_tbl_needs.count) := l_rec_need;
                                    END LOOP;
                                
                                    l_rec_triage.needs := l_tbl_needs;
                                WHEN pk_edis_triage.g_ds_comp_est_arrived_by THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.id_transp_entity := r_selected_item.item_value;
                                ELSE
                                    NULL;
                            END CASE;
                        WHEN r_triage.triage_form_int_name IN
                             (pk_edis_triage.g_ds_comp_triage,
                              pk_edis_triage.g_ds_comp_triage_sa,
                              pk_edis_triage.g_ds_comp_triage_ctas) THEN
                            --GENERAL FORM KNOW AS CHIEF COMPLAINT FORM
                            CASE r_section_leaf.leaf_internal_name
                                WHEN pk_edis_triage.g_ds_comp_origin THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.origin.id_origin := r_selected_item.item_value;
                                WHEN pk_edis_triage.g_ds_comp_desc_origin THEN
                                    --Free text
                                    l_rec_triage.origin.desc_origin_ft := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_letter THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.flg_letter := r_selected_item.alt_value;
                                WHEN pk_edis_triage.g_ds_comp_needs THEN
                                    --Multichoice with multiple choices
                                    g_error := 'FILL NEEDS TABLE';
                                    pk_alertlog.log_debug(object_name     => g_package_name,
                                                          sub_object_name => l_func_name,
                                                          text            => g_error);
                                    l_tbl_needs := pk_edis_types.table_needs();
                                
                                    FOR r_selected_item IN c_selected_items(i_selected_items => r_section_leaf.selected_items)
                                    LOOP
                                        l_rec_need.id_necessity := r_selected_item.item_value;
                                        l_rec_need.flg_status   := nvl(r_selected_item.alt_value,
                                                                       pk_alert_constant.g_active);
                                    
                                        l_tbl_needs.extend;
                                        l_tbl_needs(l_tbl_needs.count) := l_rec_need;
                                    END LOOP;
                                
                                    l_rec_triage.needs := l_tbl_needs;
                                WHEN pk_edis_triage.g_ds_comp_arrived_by THEN
                                    --Multichoice of single choice
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.id_transp_entity := r_selected_item.item_value;
                                WHEN pk_edis_triage.g_ds_comp_cause THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.cause_comments.id_external_cause := r_selected_item.item_value;
                                WHEN pk_edis_triage.g_ds_comp_comments THEN
                                    --Free text
                                    l_rec_triage.cause_comments.comments := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_emerg_cont THEN
                                    --Free text
                                    l_rec_triage.emergency_contact := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_comp_chief_comp THEN
                                    --Free text
                                    l_rec_triage.chief_complaint := r_section_leaf.leaf_value;
                                WHEN g_ds_safeguard_under_two_years THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_under_two_years := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_abuse_sign THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_signs_abuse := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_immobile THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_immobile := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_injury THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_injury := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_protection_plan THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_protection_plan := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_attend_delay THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_attend_delay := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_domestic_abuse THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_domestic_abuse := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_expl_injury THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_possible_injury := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_has_social_w THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_has_social := r_selected_item.alt_value;
                                WHEN pk_edis_triage.g_ds_safeguard_social_name THEN
                                    --Free text
                                    l_rec_triage.safeguarding.social_work_name := r_section_leaf.leaf_value;
                                WHEN pk_edis_triage.g_ds_safeguard_social_add THEN
                                    --Free text
                                    l_rec_triage.safeguarding.social_work_address := r_section_leaf.leaf_value;
                                WHEN g_ds_safeguard_social_services THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_social_services := r_selected_item.alt_value;
                                WHEN pk_edis_triage.g_ds_safeguard_social_reason THEN
                                    --Free text
                                    l_rec_triage.safeguarding.social_reason := r_section_leaf.leaf_value;
                                WHEN g_ds_safeguard_social_consent THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_consent_social := r_selected_item.alt_value;
                                WHEN g_ds_safeguard_social_infor THEN
                                    r_selected_item := get_selected_item(i_selected_items => r_section_leaf.selected_items);
                                
                                    l_rec_triage.safeguarding.flg_info_sharing := r_selected_item.alt_value;
                                WHEN pk_edis_triage.g_ds_safeguard_social_dt THEN
                                    --Date field
                                    l_rec_triage.safeguarding.dt_social_contact := pk_date_utils.get_string_tstz(i_lang      => i_lang,
                                                                                                                 i_prof      => i_prof,
                                                                                                                 i_timestamp => r_section_leaf.leaf_value,
                                                                                                                 i_timezone  => NULL);
                                WHEN pk_edis_triage.g_ds_safeguard_social_info_req THEN
                                    --Free text
                                    l_rec_triage.safeguarding.social_info_received := r_section_leaf.leaf_value;
                                ELSE
                                    NULL;
                            END CASE;
                        ELSE
                            g_error := 'FORM ' || r_triage.triage_form_int_name || ' IS NOT SUPPORTED';
                            RAISE l_exception;
                    END CASE;
                END LOOP;
            END LOOP;
        
            g_error := 'SET OUTPUT PARAMETER';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            o_rec_triage := l_rec_triage;
        
            g_error := 'CALL SET_NLS_NUMERIC_CHARACTERS TO RESET';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            set_nls_numeric_characters(i_prof => i_prof);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END parse_triage_parameters;

    /********************************************************************************************
    * Get vital signs by triage type and context
    *
    * @param i_lang                Language ID
    * @param i_prof                Professional info
    * @param i_id_episode          Context PK's, it can be the id_triage_board, id_triage_discriminator or NULL
    * @param i_id_context          Context PK's, it can be the id_triage_board, id_triage_discriminator or NULL
    * @param i_flg_context         Context flag
    * @param i_id_triage_type      Triage type id
    * @param i_pat_gender          Patient gender
    *    
    * @values i_flg_context        B - Triage Board
    *                              D - Triage Discriminator
    *                              F - Triage Form
    *    
    * @return                      Vital signs id's
    *
    * @author                      Alexandre Santos
    * @version                     2.6.3
    * @since                       07-12-2012
    **********************************************************************************************/
    FUNCTION tf_triage_vital_signs
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_episode     IN episode.id_episode%TYPE,
        i_tbl_id_context IN table_number,
        i_flg_context    IN triage_vs_area.flg_context%TYPE,
        i_id_triage_type IN triage_type.id_triage_type%TYPE DEFAULT NULL,
        i_pat_gender     IN patient.gender%TYPE DEFAULT NULL
    ) RETURN table_number IS
        l_func_name CONSTANT VARCHAR2(30) := 'TF_TRIAGE_VITAL_SIGNS';
        --
        l_id_triage_type triage_type.id_triage_type%TYPE;
        l_pat_gender     patient.gender%TYPE;
        l_ret            table_number;
    BEGIN
        IF i_id_triage_type IS NOT NULL
        THEN
            l_id_triage_type := i_id_triage_type;
        ELSE
            IF i_id_episode IS NOT NULL
            THEN
                g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_TYPE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_id_triage_type := pk_edis_triage.get_triage_type(i_lang    => i_lang,
                                                                   i_prof    => i_prof,
                                                                   i_episode => i_id_episode);
            END IF;
        END IF;
    
        IF i_pat_gender IS NOT NULL
        THEN
            l_pat_gender := i_pat_gender;
        ELSE
            g_error := 'GET PAT_GENDER';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            SELECT pk_patient.get_pat_gender(i_id_patient => epis.id_patient)
              INTO l_pat_gender
              FROM episode epis
             WHERE epis.id_episode = i_id_episode;
        END IF;
    
        g_error := 'GET VITAL SIGN''s';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        SELECT DISTINCT t.id_vital_sign
          BULK COLLECT
          INTO l_ret
          FROM ( --Parent vital signs
                 SELECT ttv.id_vital_sign
                   FROM triage_type_vs ttv
                   JOIN triage_vs_area tva
                     ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                  WHERE (tva.id_context IN (SELECT /*+opt_estimate(table t rows=1)*/
                                             column_value id_context
                                              FROM TABLE(i_tbl_id_context) t) --
                        OR (tva.id_context IS NULL AND i_tbl_id_context IS NULL))
                    AND ttv.id_triage_type = l_id_triage_type
                    AND tva.flg_context = i_flg_context
                    AND pk_vital_sign.get_vs_parent_triage(i_vital_sign => ttv.id_vital_sign) IS NULL
                    AND ttv.flg_available = pk_alert_constant.g_yes
                    AND (nvl(l_pat_gender, pk_patient.g_pat_gender_female) != pk_patient.g_pat_gender_male OR
                        (l_pat_gender = pk_patient.g_pat_gender_male AND ttv.flg_pregnant = pk_alert_constant.g_no AND
                        ttv.flg_postpartum = pk_alert_constant.g_no))
                 UNION ALL
                 --Child vital signs whose parents aren't configured in triage
                SELECT ttv.id_vital_sign
                  FROM triage_type_vs ttv
                  JOIN triage_vs_area tva
                    ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                 WHERE (tva.id_context IN (SELECT /*+opt_estimate(table t rows=1)*/
                                            column_value id_context
                                             FROM TABLE(i_tbl_id_context) t) --
                       OR (tva.id_context IS NULL AND i_tbl_id_context IS NULL))
                   AND ttv.id_triage_type = l_id_triage_type
                   AND tva.flg_context = i_flg_context
                   AND pk_vital_sign.get_vs_parent_triage(i_vital_sign => ttv.id_vital_sign) NOT IN
                       (SELECT ttv1.id_vital_sign
                          FROM triage_type_vs ttv1
                          JOIN triage_vs_area tva1
                            ON ttv1.id_triage_type_vs = tva1.id_triage_type_vs
                         WHERE (tva1.id_context IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                     column_value id_context
                                                      FROM TABLE(i_tbl_id_context) t) --
                               OR (tva1.id_context IS NULL AND i_tbl_id_context IS NULL))
                           AND ttv1.id_triage_type = l_id_triage_type
                           AND tva1.flg_context = i_flg_context
                           AND ttv1.flg_available = pk_alert_constant.g_yes)
                   AND ttv.flg_available = pk_alert_constant.g_yes
                   AND (nvl(l_pat_gender, pk_patient.g_pat_gender_female) != pk_patient.g_pat_gender_male OR
                       (l_pat_gender = pk_patient.g_pat_gender_male AND ttv.flg_pregnant = pk_alert_constant.g_no AND
                       ttv.flg_postpartum = pk_alert_constant.g_no))) t;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END tf_triage_vital_signs;

    /**************************************************************************
    * Detailed information about a triage event.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis_triage         Triage event ID
    * @param o_epis_triage            Triage Info
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.1
    * @since                          10-12-2012
    **************************************************************************/
    FUNCTION get_epis_triage_detail
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_triage IN epis_triage.id_epis_triage%TYPE,
        i_flg_call       IN VARCHAR2 DEFAULT pk_edis_hist.g_call_detail,
        o_epis_triage    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_TRIAGE_DETAIL';
        l_triage pk_edis_types.rec_triage;
        l_internal_error EXCEPTION;
        r_epis_triage            epis_triage%ROWTYPE;
        l_detail_schema          t_table_ds_sections;
        l_last_node_used         VARCHAR2(200) := '';
        l_last_node_loaded_value BOOLEAN := FALSE;
        l_final_item_value       VARCHAR2(32767) := '';
        l_new_node_title         VARCHAR2(200) := '';
        l_new_node_internal_name VARCHAR2(200) := '';
        l_title_type             VARCHAR(2 CHAR);
        --EMR-4797
        l_ef_status     epis_fast_track.flg_status%TYPE;
        l_ef_activation epis_fast_track.dt_activation%TYPE;
        l_ef_prof       epis_fast_track.id_prof_enable%TYPE;
        --EMR-4797 END
    
        CURSOR c_epis_triage IS
            SELECT et.id_epis_triage,
                   et.dt_begin_tstz,
                   t.id_triage_type,
                   tt.acronym,
                   td.id_triage_discriminator,
                   td.id_parent,
                   td.code_triage_discriminator,
                   et.flg_selected_option,
                   t.id_triage,
                   et.id_episode,
                   et.id_triage_color,
                   get_triage_color_orig(i_lang, i_prof, g_type_color_title, tc.id_triage_type, et.id_triage_color_orig) title_triage_color,
                   pk_translation.get_translation(i_lang, tc.code_triage_color) ||
                   decode(tcg.flg_type, g_no, NULL, ' - ' || pk_translation.get_translation(i_lang, tc.code_accuity)) ||
                   chr(10) || '(' || pk_message.get_message(i_lang, 'TRIAGE_T039') || chr(32) ||
                   get_triage_color_orig(i_lang, i_prof, g_type_color_value, tc.id_triage_type, tc_orig.id_triage_color) || ')' desc_triage_color,
                   get_board_label(i_lang, i_prof, et.id_triage_board, td.id_triage_decision_point, t.id_triage_type) desc_flowchart,
                   et.id_professional
              FROM epis_triage et
              JOIN triage_color tc
                ON tc.id_triage_color = et.id_triage_color
              JOIN triage_type tt
                ON tt.id_triage_type = tc.id_triage_type
              LEFT JOIN triage t
                ON t.id_triage = et.id_triage
              LEFT JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
              JOIN triage_color_group tcg
                ON tcg.id_triage_color_group = tc.id_triage_color_group
              LEFT JOIN triage_color tc_orig
                ON tc_orig.id_triage_color = et.id_triage_color_orig
              LEFT JOIN triage_board tb
                ON tb.id_triage_board = t.id_triage_board
             WHERE et.id_epis_triage = i_id_epis_triage;
    
    BEGIN
        g_error := 'FETCH DATA INTO R_EPIS_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        FOR r_epis_triage IN c_epis_triage
        LOOP
        
            -- Initialize history table
            pk_edis_hist.init_vars;
        
            -- Create a new line in history table with current history record 
            pk_edis_hist.add_line(i_history        => r_epis_triage.id_epis_triage,
                                  i_dt_hist        => r_epis_triage.dt_begin_tstz,
                                  i_record_state   => pk_alert_constant.g_flg_status_a,
                                  i_desc_rec_state => NULL);
        
            g_error := 'GET SAVED DATA';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF NOT get_triage_svd_data(i_lang        => i_lang,
                                       i_prof        => i_prof,
                                       i_epis_triage => i_id_epis_triage,
                                       i_flg_call    => i_flg_call,
                                       o_triage      => l_triage,
                                       o_error       => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'FETCH CONFIGURATIONS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_detail_schema := pk_edis_triage.tf_detail_schema(i_lang        => i_lang,
                                                               i_prof        => i_prof,
                                                               i_episode     => r_epis_triage.id_episode,
                                                               i_epis_triage => r_epis_triage.id_epis_triage, --i_show_additional_info => false,
                                                               i_flg_call    => i_flg_call);
        
            SELECT decode(l_triage.id_triage_type,
                          g_triage_id_est,
                          pk_edis_hist.g_type_subtitle,
                          pk_edis_hist.g_type_title)
              INTO l_title_type
              FROM dual;
        
            g_error := 'LOAD VALUES TO SCREEN';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR r_section IN (SELECT *
                                FROM TABLE(l_detail_schema) t)
            LOOP
                IF (r_section.internal_name IN ('TRI_EST', 'TRIAGE', 'TRI_SA') AND
                   l_triage.id_triage_type = g_triage_id_est)
                   OR (r_section.internal_name = 'TRIAGEM_HIST')
                THEN
                    pk_edis_hist.add_value(i_label => r_section.component_desc,
                                           i_value => NULL,
                                           i_type  => pk_edis_hist.g_type_title,
                                           i_code  => r_section.internal_name);
                ELSE
                    IF l_last_node_loaded_value = TRUE
                       AND r_section.flg_component_type <> pk_dynamic_screen.c_leaf_component
                    THEN
                        pk_edis_hist.add_value(i_label => NULL,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_empty_line);
                    
                        l_last_node_loaded_value := FALSE;
                    END IF;
                
                    IF r_section.component_values.exists(1)
                       AND r_section.flg_component_type = pk_dynamic_screen.c_root_component
                    THEN
                        IF r_section.component_values.count > 1
                        THEN
                            FOR l_values IN (SELECT t.*
                                               FROM TABLE(r_section.component_values) t)
                            LOOP
                                l_final_item_value := l_final_item_value || l_values.item_desc || ';' || chr(32);
                            END LOOP;
                        ELSE
                            IF r_section.internal_name IN
                               (g_ds_def_crit_int_name, g_ds_other_crit_int_name, g_ds_critical_look)
                            THEN
                                l_final_item_value := r_section.component_values(1).item_xml_value;
                            ELSE
                                l_final_item_value := r_section.component_values(1).item_desc;
                            END IF;
                        END IF;
                    
                        IF l_final_item_value IS NOT NULL
                           OR l_final_item_value <> ''
                        THEN
                            -- adds (Title + Content) for roots that have a value (TRIAGE_BOARD, DEFINING_CRITERIA, OTHER_CRITERIA)
                            pk_edis_hist.add_value(i_label => r_section.component_desc,
                                                   i_value => NULL,
                                                   i_type  => pk_edis_hist.g_type_title,
                                                   i_code  => r_section.internal_name);
                        
                            pk_edis_hist.add_value(i_label => NULL,
                                                   i_value => l_final_item_value,
                                                   i_type  => pk_edis_hist.g_type_content,
                                                   i_code  => r_section.internal_name || '_VALUE');
                        
                            pk_edis_hist.add_value(i_label => NULL,
                                                   i_value => NULL,
                                                   i_type  => pk_edis_hist.g_type_empty_line);
                        END IF;
                    
                        l_final_item_value := '';
                    ELSIF r_section.component_values.exists(1)
                          OR r_section.flg_component_type = pk_dynamic_screen.c_node_component
                    THEN
                        -- adds info for form fields  
                        IF r_section.flg_component_type = pk_dynamic_screen.c_node_component
                        THEN
                            IF r_section.component_desc <> nvl(l_last_node_used, '-')
                            THEN
                                -- saves section Title to display later if it has values and if it is a new one
                                l_new_node_title         := r_section.component_desc;
                                l_new_node_internal_name := r_section.internal_name;
                            END IF;
                        ELSE
                            -- adds Content Value with label (in a section)
                            IF r_section.component_values.count > 1
                            THEN
                                FOR l_values IN (SELECT t.*
                                                   FROM TABLE(r_section.component_values) t)
                                LOOP
                                    l_final_item_value := l_final_item_value || l_values.item_desc || ';' || chr(32);
                                END LOOP;
                            ELSIF r_section.component_values.count = 1
                            THEN
                                IF r_section.internal_name = g_ds_fast_track_reason
                                THEN
                                    l_final_item_value := r_section.component_values(1).item_xml_value;
                                ELSE
                                    l_final_item_value := r_section.component_values(1).item_desc;
                                END IF;
                            END IF;
                        
                            IF l_final_item_value IS NOT NULL
                            THEN
                            
                                -- adds new subtitle  
                                IF l_new_node_title IS NOT NULL
                                   OR r_section.internal_name = g_ds_fast_track_signature
                                THEN
                                    pk_edis_hist.add_value(i_label => l_new_node_title,
                                                           i_value => NULL,
                                                           i_type  => l_title_type,
                                                           i_code  => l_new_node_internal_name);
                                
                                    l_last_node_used         := r_section.component_desc;
                                    l_new_node_title         := '';
                                    l_new_node_internal_name := '';
                                END IF;
                                IF r_section.internal_name <> g_ds_fast_track_signature
                                THEN
                                    pk_edis_hist.add_value(i_label => r_section.component_desc,
                                                           i_value => l_final_item_value,
                                                           i_type  => pk_edis_hist.g_type_content,
                                                           i_code  => r_section.internal_name);
                                ELSE
                                    pk_edis_hist.add_value(i_label => r_section.component_desc,
                                                           i_value => l_final_item_value,
                                                           i_type  => pk_edis_hist.g_type_signature,
                                                           i_code  => r_section.internal_name);
                                END IF;
                            
                                IF r_section.internal_name = g_ds_fast_track_signature
                                THEN
                                    pk_edis_hist.add_value(i_label => NULL,
                                                           i_value => NULL,
                                                           i_type  => pk_edis_hist.g_type_empty_line);
                                    pk_edis_hist.add_line(i_history => r_section.id_ds_cmpt_mkt_rel,
                                                          
                                                          i_dt_hist        => NULL,
                                                          i_record_state   => 'A',
                                                          i_desc_rec_state => NULL);
                                    pk_edis_hist.add_value(i_label => NULL,
                                                           i_value => NULL,
                                                           i_type  => pk_edis_hist.g_type_empty_line);
                                END IF;
                                l_final_item_value       := '';
                                l_last_node_loaded_value := TRUE;
                            END IF;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        
            pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
        
            IF i_flg_call = pk_edis_hist.g_call_detail
            THEN
                BEGIN
                    --EMR-4797 Signature when confirmed Status for Detail page
                    SELECT ef.flg_status, ef.dt_activation, ef.id_prof_enable
                      INTO l_ef_status, l_ef_activation, l_ef_prof
                      FROM epis_fast_track ef
                     WHERE ef.id_epis_triage = r_epis_triage.id_epis_triage;
                EXCEPTION
                    WHEN OTHERS THEN
                        NULL;
                END;
            END IF;
        
            IF l_ef_status = pk_fast_track.g_fast_track_confirm
            THEN
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, 'COMMON_M046') || ':',
                                       i_value => pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                             i_prof                => i_prof,
                                                                             i_id_episode          => l_triage.id_episode,
                                                                             i_date                => l_ef_activation,
                                                                             i_id_prof_last_change => l_ef_prof,
                                                                             i_desc_signature      => pk_message.get_message(i_lang,
                                                                                                                             i_prof,
                                                                                                                             'COMMON_M046') || ':'),
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            ELSE
                --signature
                pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, 'COMMON_M107'),
                                       i_value => pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                             i_prof                => i_prof,
                                                                             i_id_episode          => l_triage.id_episode,
                                                                             i_date                => r_epis_triage.dt_begin_tstz,
                                                                             i_id_prof_last_change => r_epis_triage.id_professional),
                                       i_type  => pk_edis_hist.g_type_signature,
                                       i_code  => 'SIGNATURE');
            END IF;
            --EMR-4797 END
        
        END LOOP;
    
        g_error := 'OPEN O_EPIS_TRIAGE CURSOR';
        alertlog.pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_epis_triage FOR
            SELECT t.id_history,
                   t.dt_history,
                   t.tbl_labels,
                   t.tbl_values,
                   t.tbl_types,
                   t.tbl_info_labels,
                   t.tbl_info_values,
                   t.tbl_codes
              FROM TABLE(pk_edis_hist.tf_hist) t;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_internal_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.err_desc,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_epis_triage);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_types.open_my_cursor(o_epis_triage);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_triage_detail;

    /**************************************************************************
    * Returns a label with the discriminator description, according to the
    * type of triage.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_triage_type         Triage type ID
    * @param i_acronym                Triage type acronym
    * @param i_id_disc                Discriminator ID
    * @param i_id_disc_parent         Discriminator parent ID
    * @param i_code_disc              Code for translation: discriminator
    * @param i_selected_option        Option selected by user to confirm discriminator (Yes/No)
    * @param i_id_epis_triage         Epis Triage ID
    * @param i_id_triage              Triage ID
    *
    * @return                         Label with the discriminator description
    *                        
    * @author                         José Brito
    * @version                        2.6
    * @since                          22/12/2009
    **************************************************************************/
    FUNCTION get_discriminator_label
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_triage_type  IN triage_type.id_triage_type%TYPE,
        i_acronym         IN triage_type.acronym%TYPE,
        i_id_disc         IN triage_discriminator.id_triage_discriminator%TYPE,
        i_id_disc_parent  IN triage_discriminator.id_parent%TYPE,
        i_code_disc       IN triage_discriminator.code_triage_discriminator%TYPE,
        i_selected_option IN epis_triage.flg_selected_option%TYPE,
        i_id_epis_triage  IN epis_triage.id_epis_triage%TYPE,
        i_id_triage       IN triage.id_triage%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name VARCHAR2(200) := 'GET_DISCRIMINATOR_LABEL';
    
        l_error t_error_out;
        l_param_error EXCEPTION;
        l_label   translation.desc_lang_1%TYPE;
        l_acronym triage_type.acronym%TYPE;
    
        l_id_triage_discriminator triage_discriminator.id_triage_discriminator%TYPE;
        l_code_disc               triage_discriminator.code_triage_discriminator%TYPE;
        l_id_disc_parent          triage_discriminator.id_parent%TYPE;
        l_selected_option         epis_triage.flg_selected_option%TYPE;
    
        CURSOR c_discrim_options IS
            SELECT td.id_triage_discriminator, td.code_triage_discriminator, td.id_parent, eto.flg_selected_option
              FROM epis_triage_option eto
              JOIN triage t
                ON t.id_triage = eto.id_triage
              LEFT JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
             WHERE eto.id_epis_triage = i_id_epis_triage;
    BEGIN
    
        -- Get the triage type acronym
        IF i_acronym IS NULL
           AND i_id_triage_type IS NOT NULL
        THEN
            g_error := 'GET TRIAGE ACRONYM';
            SELECT tt.acronym
              INTO l_acronym
              FROM triage_type tt
             WHERE tt.id_triage_type = i_id_triage_type;
        ELSIF i_acronym IS NOT NULL
        THEN
            l_acronym := i_acronym;
        ELSE
            g_error := 'INVALID/NULL TRIAGE TYPE';
            RAISE l_param_error;
        END IF;
    
        IF l_acronym IN (g_est, g_esi)
        THEN
            -- Triagem EST, é necessário ir À EPIS_TRIAGE_OPTION
            OPEN c_discrim_options;
            LOOP
                FETCH c_discrim_options
                    INTO l_id_triage_discriminator, l_code_disc, l_id_disc_parent, l_selected_option;
                EXIT WHEN c_discrim_options%NOTFOUND;
            
                l_label := l_label || get_discriminator_desc(i_lang            => i_lang,
                                                             i_prof            => i_prof,
                                                             i_id_triage_type  => i_id_triage_type,
                                                             i_acronym         => l_acronym,
                                                             i_id_disc         => l_id_triage_discriminator,
                                                             i_id_disc_parent  => l_id_disc_parent,
                                                             i_code_disc       => l_code_disc,
                                                             i_selected_option => l_selected_option) || '; ';
            END LOOP;
        
            CLOSE c_discrim_options;
        
        ELSE
            l_label := get_discriminator_desc(i_lang            => i_lang,
                                              i_prof            => i_prof,
                                              i_id_triage_type  => i_id_triage_type,
                                              i_acronym         => l_acronym,
                                              i_id_disc         => i_id_disc,
                                              i_id_disc_parent  => i_id_disc_parent,
                                              i_code_disc       => i_code_disc,
                                              i_selected_option => i_selected_option);
        END IF;
        RETURN l_label;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            RETURN NULL;
    END get_discriminator_label;

    /**
    * Returns the presentation structure to be shown in the detail screen 
    *
    * @param   i_lang                      Professional preferred language
    * @param   i_prof                      Professional identification and its context (institution and software)
    * @param   i_episode                   Episode id
    * @param   i_epis_triage               Epis triage id
    * @param   i_triage_type               Triage type id
    * @param   i_ds_component              Dynamic screen root component in use by this triage type
    * @param   i_ds_comp_type              Dynamic screen root component type in use by this triage type
    * @param   i_ds_tbl_nodes              Dynamic screen nodes table
    *
    * @return  Presentation schema for the detail screen
    *
    * @author  Alexandre Santos
    * @version v2.6
    * @since   26-12-2011
    */
    FUNCTION tf_detail_schema
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_epis_triage          IN epis_triage.id_epis_triage%TYPE DEFAULT NULL,
        i_triage_type          IN triage_type.id_triage_type%TYPE DEFAULT NULL,
        i_ds_component         IN ds_component.internal_name%TYPE DEFAULT NULL,
        i_ds_comp_type         IN ds_component.flg_component_type%TYPE DEFAULT NULL,
        i_ds_tbl_nodes         IN t_table_ds_sections DEFAULT NULL,
        i_show_additional_info IN BOOLEAN DEFAULT TRUE,
        i_flg_call             IN VARCHAR2 DEFAULT pk_edis_hist.g_call_detail
    ) RETURN t_table_ds_sections IS
        l_func_name CONSTANT VARCHAR2(50) := 'TF_DETAIL_SCHEMA';
        --
        l_ds_root_pk                 CONSTANT ds_component.id_ds_component%TYPE := 1000000;
        l_ds_root_int_name           CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_DETAIL';
        l_ds_tri_board_pk            CONSTANT ds_component.id_ds_component%TYPE := 1000001;
        l_ds_tri_board_int_name      CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_BOARD';
        l_ds_defin_crit_pk           CONSTANT ds_component.id_ds_component%TYPE := 1000002;
        l_ds_other_crit_pk           CONSTANT ds_component.id_ds_component%TYPE := 1000003;
        l_ds_color_pk                CONSTANT ds_component.id_ds_component%TYPE := 1000004;
        l_ds_color_int_name          CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_COLOR_DESC';
        l_ds_notes_pk                CONSTANT ds_component.id_ds_component%TYPE := 1000005;
        l_ds_notes_int_name          CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_FINAL_NOTES';
        l_ds_vs_node_name            CONSTANT ds_component.internal_name%TYPE := 'TRIAGE_VITAL_SIGNS_NODE';
        l_code_trans_vs_node         CONSTANT ds_component.code_ds_component%TYPE := 'DS_COMPONENT.CODE_DS_COMPONENT.48';
        l_ds_fast_track              CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK';
        l_ds_fast_track_pk           CONSTANT ds_component.id_ds_component%TYPE := 1000008;
        l_ds_fast_track_name         CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK_NAME';
        l_ds_fast_track_name_pk      CONSTANT ds_component.id_ds_component%TYPE := 1000009;
        l_ds_fast_track_type         CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK_TYPE';
        l_ds_fast_track_type_pk      CONSTANT ds_component.id_ds_component%TYPE := 1000010;
        l_ds_fast_track_reas_pk      CONSTANT ds_component.id_ds_component%TYPE := 1000011;
        l_ds_fast_track_notes_pk     CONSTANT ds_component.id_ds_component%TYPE := 1000012;
        l_ds_fast_track_notes        CONSTANT ds_component.internal_name%TYPE := 'FAST_TRACK_NOTES';
        l_ds_fast_track_signature_pk CONSTANT ds_component.id_ds_component%TYPE := 1000013;
        l_ds_root_hist               CONSTANT ds_component.id_ds_component%TYPE := 1000014;
        l_ds_root_hist_pk ds_component.id_ds_component%TYPE;
        l_ds_tri_critical_look_pk   CONSTANT ds_component.id_ds_component%TYPE := 1000015;
        l_ds_tri_crit_look_int_name CONSTANT ds_component.internal_name%TYPE := 'CRITICAL_LOOK';
        --
        l_patient           patient.id_patient%TYPE;
        l_row_triage_config triage_configuration%ROWTYPE;
        l_component_name    triage_ds_component.internal_name%TYPE;
        l_component_type    triage_ds_component.flg_component_type%TYPE;
        l_add_vs_node       BOOLEAN := FALSE;
        --
        l_triage_acronym   triage_type.acronym%TYPE;
        l_triage_type_desc pk_translation.t_desc_translation;
        --
        l_flowchart pk_translation.t_desc_translation;
    
        l_discriminator            pk_translation.t_desc_translation;
        l_reason_for_visit         pk_translation.t_desc_translation;
        l_fchart_selection         pk_translation.t_desc_translation;
        l_protocol                 pk_translation.t_desc_translation;
        l_confirmation             pk_translation.t_desc_translation;
        l_current_prof             pk_translation.t_desc_translation;
        l_other_discriminator      sys_domain.desc_val%TYPE;
        l_defining_criteria        VARCHAR2(1000 CHAR);
        l_critical_look            sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'TRIAGE_CTAS_T001');
        l_fast_track_section       sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T013');
        l_fast_track               sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T001');
        l_fast_track_type          sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T012');
        l_fast_track_reason_enable sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T014');
        l_fast_track_notes_enable  sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T018');
        l_fast_track_notes_disable sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T017');
        l_fast_track_enable        sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T009');
        l_fast_track_disable       sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                           i_code_mess => 'FAST_TRACK_T002');
        l_fast_track_notes         sys_message.desc_message%TYPE;
        l_fast_track_reason        sys_message.desc_message%TYPE;
    
        l_fast_track_date sys_message.desc_message%TYPE;
    
        l_fast_track_reason_disable sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                            i_code_mess => 'FAST_TRACK_T019');
    
        --
        l_ret_tbl_sections t_table_ds_sections := t_table_ds_sections();
        l_ds_root_rec      t_rec_ds_sections;
        l_tbl_nodes        t_table_ds_sections;
        l_tbl_leafs        t_table_ds_sections;
        l_tbl_def_events   t_table_ds_def_events;
        l_tbl_items_values t_table_ds_items_values;
        l_tbl_events       t_table_ds_events;
        --
        l_triage pk_edis_types.rec_triage;
        l_rec_vs pk_edis_types.rec_vital_sign;
        -- EMR-4797
        l_date_signature  epis_fast_track.dt_activation%TYPE;
        l_title_signature sys_message.desc_message%TYPE;
        l_prof_signature  epis_fast_track.id_prof_enable%TYPE;
        --
        l_error t_error_out;
        l_internal_error EXCEPTION;
        l_critical_look_str pk_translation.t_desc_translation;
        --
        FUNCTION get_ds_section_rec
        (
            i_ds_cmpt_mkt_rel     NUMBER,
            i_ds_component_parent NUMBER,
            i_ds_component        NUMBER,
            i_component_desc      VARCHAR2,
            i_internal_name       VARCHAR2,
            i_flg_component_type  VARCHAR2,
            i_rank                NUMBER,
            i_max_len             NUMBER DEFAULT NULL
        ) RETURN t_rec_ds_sections IS
        BEGIN
            RETURN t_rec_ds_sections(id_ds_cmpt_mkt_rel     => i_ds_cmpt_mkt_rel,
                                     id_ds_component_parent => i_ds_component_parent,
                                     id_ds_component        => i_ds_component,
                                     component_desc         => i_component_desc,
                                     internal_name          => i_internal_name,
                                     flg_component_type     => i_flg_component_type,
                                     flg_data_type          => NULL,
                                     slg_internal_name      => NULL,
                                     addit_info_xml_value   => NULL,
                                     rank                   => i_rank,
                                     max_len                => i_max_len,
                                     min_value              => NULL,
                                     max_value              => NULL);
        END get_ds_section_rec;
        --
        PROCEDURE add_saved_data
        (
            i_section_tbl_idx NUMBER,
            i_item_desc       VARCHAR2,
            i_item_value      NUMBER,
            i_item_alt_value  VARCHAR2,
            i_item_xml_value  CLOB DEFAULT NULL
        ) IS
            l_tbl_component_values t_table_ds_items_values;
        BEGIN
            g_error := 'ADD ELEMENT SAVED DATA';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_tbl_component_values := l_ret_tbl_sections(i_section_tbl_idx).component_values;
        
            l_tbl_component_values.extend;
            l_tbl_component_values(l_tbl_component_values.count) := t_rec_ds_items_values(id_ds_cmpt_mkt_rel => NULL,
                                                                                          id_ds_component    => NULL,
                                                                                          internal_name      => NULL,
                                                                                          flg_component_type => NULL,
                                                                                          item_desc          => i_item_desc,
                                                                                          item_value         => i_item_value,
                                                                                          item_alt_value     => i_item_alt_value,
                                                                                          item_xml_value     => i_item_xml_value,
                                                                                          item_rank          => NULL);
        
            l_ret_tbl_sections(i_section_tbl_idx).component_values := l_tbl_component_values;
        END add_saved_data;
    
        PROCEDURE add_triage_board(i_rank IN NUMBER) IS
        BEGIN
            g_error := 'ADD TRIAGE_BOARD ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO FLASH
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_tri_board_pk,
                                                                               i_ds_component_parent => l_ds_root_pk,
                                                                               i_ds_component        => l_ds_tri_board_pk,
                                                                               i_component_desc      => l_flowchart,
                                                                               i_internal_name       => l_ds_tri_board_int_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => i_rank);
        
            IF i_epis_triage IS NOT NULL
            THEN
                g_error := 'ADD TRIAGE_BOARD SAVED DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                               i_item_desc       => l_triage.desc_triage_board,
                               i_item_value      => l_triage.id_triage_board,
                               i_item_alt_value  => NULL);
            END IF;
        END add_triage_board;
    
        PROCEDURE add_critical_look(i_rank IN NUMBER) IS
        BEGIN
            g_error := 'ADD CRITICAL_LOOK ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO FLASH
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_tri_critical_look_pk,
                                                                               i_ds_component_parent => l_ds_root_pk,
                                                                               i_ds_component        => l_ds_tri_critical_look_pk,
                                                                               i_component_desc      => l_critical_look,
                                                                               i_internal_name       => l_ds_tri_crit_look_int_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => i_rank);
        
            IF i_epis_triage IS NOT NULL
            THEN
                g_error := 'ADD TRIAGE_BOARD SAVED DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                /*        add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                i_item_desc       => l_triage.critical_look_description,
                i_item_value      => l_triage.id_triage_board,
                i_item_alt_value  => NULL);*/
                add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                               i_item_desc       => NULL,
                               i_item_value      => NULL,
                               i_item_alt_value  => NULL,
                               i_item_xml_value  => l_triage.critical_look_description);
            
            END IF;
        END add_critical_look;
    
        PROCEDURE add_fast_track
        (
            i_rank     IN NUMBER,
            i_flg_type IN VARCHAR2
        ) IS
            l_ind              NUMBER;
            l_fast_track_title sys_message.desc_message%TYPE;
        
            PROCEDURE inner_add_fast_track
            (
                i          NUMBER,
                i_flg_type IN VARCHAR2
            ) IS
            BEGIN
                IF (i_flg_type = pk_edis_hist.g_call_hist AND i = l_triage.fast_track.count AND l_triage.fast_track(i)
                   .flg_activation_type = pk_fast_track.g_ft_triggered_activation)
                   OR (i_flg_type = pk_edis_hist.g_call_detail AND i = l_triage.fast_track.count AND l_triage.fast_track(i)
                   .flg_activation_type = pk_fast_track.g_ft_manual_activation AND
                   i_flg_call = pk_edis_hist.g_call_hist)
                   OR (i_flg_call = pk_edis_hist.g_call_detail
                   --AND l_triage.fast_track(i).flg_status IN (pk_fast_track.g_fast_track_active, pk_fast_track.g_fast_track_confirm) 
                   AND i > 2)
                THEN
                    RETURN;
                END IF;
                IF i_flg_type = pk_edis_hist.g_call_hist
                   AND l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_active
                THEN
                    l_fast_track_title  := l_fast_track_enable;
                    l_fast_track_notes  := l_fast_track_notes_enable;
                    l_fast_track_reason := l_fast_track_reason_enable;
                    --EMR-4797    
                ELSIF i_flg_type = pk_edis_hist.g_call_hist
                      AND l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_confirm
                THEN
                    l_fast_track_title  := pk_message.get_message(i_lang, 'FAST_TRACK_T049'); -- Confirmação de Via Verde
                    l_fast_track_notes  := pk_message.get_message(i_lang, 'FAST_TRACK_T048'); -- Notas de Confirmacao
                    l_fast_track_reason := pk_message.get_message(i_lang, 'FAST_TRACK_T047'); -- Motivo(s) de Confirmação
                    --EMR-4797 END
                ELSIF i_flg_type = pk_edis_hist.g_call_hist
                      AND l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_disabled
                THEN
                    l_fast_track_title  := l_fast_track_disable;
                    l_fast_track_notes  := l_fast_track_notes_disable;
                    l_fast_track_reason := l_fast_track_reason_disable;
                ELSE
                    --EMR-4797
                    IF l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_confirm
                    THEN
                        l_fast_track_title  := pk_message.get_message(i_lang, 'FAST_TRACK_T049'); -- Confirmação de Via Verde
                        l_fast_track_notes  := pk_message.get_message(i_lang, 'FAST_TRACK_T048'); -- Notas de Confirmacao
                        l_fast_track_reason := pk_message.get_message(i_lang, 'FAST_TRACK_T047'); -- Motivo(s) de Confirmação
                    ELSE
                        l_fast_track_title  := l_fast_track;
                        l_fast_track_reason := l_fast_track_reason_enable;
                        l_fast_track_notes  := l_fast_track_notes_enable;
                    END IF;
                    --EMR-4797 END
                END IF;
                --     l_fast_track_title := 'i_flg_type:' || i_flg_type || 'Type:' || l_triage.fast_track(i).flg_type;
                IF i_epis_triage IS NOT NULL
                THEN
                    g_error := 'ADD FAST_TRACK ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO FLASH
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                
                    l_ret_tbl_sections.extend;
                    l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_pk,
                                                                                       i_ds_component_parent => l_ds_root_pk,
                                                                                       i_ds_component        => l_ds_fast_track_pk,
                                                                                       i_component_desc      => l_fast_track_title,
                                                                                       i_internal_name       => l_ds_fast_track,
                                                                                       i_flg_component_type  => pk_dynamic_screen.c_node_component,
                                                                                       i_rank                => i_rank);
                    add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                   i_item_desc       => NULL,
                                   i_item_value      => NULL,
                                   i_item_alt_value  => NULL);
                
                    l_ret_tbl_sections.extend;
                    l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_name_pk,
                                                                                       i_ds_component_parent => l_ds_fast_track_pk,
                                                                                       i_ds_component        => l_ds_fast_track_name_pk,
                                                                                       i_component_desc      => l_fast_track,
                                                                                       i_internal_name       => l_ds_fast_track_name,
                                                                                       i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                       i_rank                => i_rank + 1);
                    g_error := 'ADD TRIAGE_BOARD SAVED DATA';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                   i_item_desc       => l_triage.fast_track(i).desc_fast_track,
                                   i_item_value      => l_triage.fast_track(i).id_fast_track,
                                   i_item_alt_value  => NULL);
                
                    --                   IF l_triage.fast_track(i).flg_activation_type = pk_fast_track.g_ft_manual_activation
                    --                   THEN
                    IF (l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_active OR --Active 
                       l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_confirm) --Or Confirmed 
                       AND l_triage.fast_track(i).flg_activation_type = pk_fast_track.g_ft_manual_activation -- EMR-4797
                    THEN
                        l_ret_tbl_sections.extend;
                        l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_type_pk,
                                                                                           i_ds_component_parent => l_ds_fast_track_pk,
                                                                                           i_ds_component        => l_ds_fast_track_type_pk,
                                                                                           i_component_desc      => l_fast_track_type,
                                                                                           i_internal_name       => l_ds_fast_track_type,
                                                                                           i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                           i_rank                => i_rank + 2);
                    
                        add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                       i_item_desc       => l_triage.fast_track(i).desc_flg_type,
                                       i_item_value      => l_triage.fast_track(i).id_fast_track,
                                       i_item_alt_value  => NULL);
                    END IF;
                    IF l_triage.fast_track(i).reason IS NOT NULL
                    THEN
                        l_ret_tbl_sections.extend;
                        l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_reas_pk,
                                                                                           i_ds_component_parent => l_ds_fast_track_pk,
                                                                                           i_ds_component        => l_ds_fast_track_reas_pk,
                                                                                           i_component_desc      => l_fast_track_reason,
                                                                                           i_internal_name       => g_ds_fast_track_reason,
                                                                                           i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                           i_rank                => i_rank + 3);
                    
                        add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                       i_item_desc       => NULL,
                                       i_item_value      => NULL,
                                       i_item_alt_value  => NULL,
                                       i_item_xml_value  => l_triage.fast_track(i).reason);
                    
                        l_ret_tbl_sections.extend;
                        l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_notes_pk,
                                                                                           i_ds_component_parent => l_ds_fast_track_pk,
                                                                                           i_ds_component        => l_ds_fast_track_notes_pk,
                                                                                           i_component_desc      => l_fast_track_notes,
                                                                                           i_internal_name       => l_ds_fast_track_notes,
                                                                                           i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                           i_rank                => i_rank + 4);
                    
                        add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                       i_item_desc       => l_triage.fast_track(i).notes,
                                       i_item_value      => l_triage.fast_track(i).id_fast_track,
                                       i_item_alt_value  => NULL);
                    
                        IF i_flg_type = pk_edis_hist.g_call_hist
                        THEN
                        
                            l_ret_tbl_sections.extend;
                            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_fast_track_signature_pk,
                                                                                               i_ds_component_parent => l_ds_fast_track_pk,
                                                                                               i_ds_component        => l_ds_fast_track_signature_pk,
                                                                                               i_component_desc      => NULL,
                                                                                               i_internal_name       => g_ds_fast_track_signature,
                                                                                               i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                               i_rank                => i_rank + 5);
                            --EMR-4797
                            IF l_triage.fast_track(i).flg_status = pk_fast_track.g_fast_track_confirm
                            THEN
                                /*    BEGIN
                                    SELECT eft.dt_activation
                                      INTO l_date_signature
                                      FROM epis_fast_track eft
                                     WHERE eft.id_epis_triage = l_triage.id_epis_triage
                                       AND eft.id_fast_track = l_triage.fast_track(i).id_fast_track;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        l_date_signature := NULL;
                                END;*/
                                l_title_signature := pk_message.get_message(i_lang      => i_lang,
                                                                            i_code_mess => 'COMMON_M046');
                            ELSE
                                l_title_signature := pk_message.get_message(i_lang      => i_lang,
                                                                            i_code_mess => 'COMMON_M107');
                            END IF;
                            l_prof_signature := l_triage.fast_track(i).id_professional;
                            l_date_signature := l_triage.fast_track(i).fast_track_date;
                        
                            add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                           i_item_desc       => pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                                           i_prof                => i_prof,
                                                                                           i_id_episode          => l_triage.id_episode,
                                                                                           i_date                => l_date_signature,
                                                                                           i_id_prof_last_change => l_prof_signature,
                                                                                           i_desc_signature      => l_title_signature),
                                           i_item_value      => l_triage.fast_track(i).id_fast_track,
                                           i_item_alt_value  => NULL);
                            --EMR-4797 END              
                        
                        END IF;
                    END IF;
                END IF;
            END inner_add_fast_track;
        BEGIN
            IF l_triage.fast_track.exists(1)
            THEN
                IF i_flg_call = pk_edis_hist.g_call_detail
                   AND l_triage.fast_track(1)
                  .flg_status IN (pk_fast_track.g_fast_track_active, pk_fast_track.g_fast_track_confirm) --EMR-4797
                THEN
                    inner_add_fast_track(1, i_flg_type);
                    /*                    IF l_triage.fast_track(1).flg_status = pk_fast_track.g_fast_track_confirm
                    THEN
                        --EMR-4797
                        inner_add_fast_track(2, i_flg_type);
                    END IF;*/
                ELSIF i_flg_call = pk_edis_hist.g_call_hist
                      AND i_flg_type = pk_edis_hist.g_call_hist
                THEN
                    FOR l IN 1 .. l_triage.fast_track.count
                    LOOP
                        inner_add_fast_track(l, i_flg_type);
                    END LOOP;
                ELSE
                    inner_add_fast_track(l_triage.fast_track.count, i_flg_type);
                END IF;
            END IF;
        END add_fast_track;
    BEGIN
        IF i_ds_component IS NULL
           OR i_ds_comp_type IS NULL
           OR i_triage_type IS NULL
        THEN
            g_error := 'CALL GET_TRIAGE_CONFIG_ROW';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT get_triage_config_row(i_lang        => i_lang,
                                         i_prof        => i_prof,
                                         i_episode     => i_episode,
                                         i_triage_type => NULL,
                                         o_config_row  => l_row_triage_config,
                                         o_error       => l_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'GET COMPONENT NAME AND TYPE';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            SELECT tdc.internal_name, tdc.flg_component_type
              INTO l_component_name, l_component_type
              FROM triage_ds_component tdc
             WHERE tdc.id_triage_ds_component = l_row_triage_config.id_triage_ds_component;
        ELSE
            l_component_name                   := i_ds_component;
            l_component_type                   := i_ds_comp_type;
            l_row_triage_config.id_triage_type := i_triage_type;
        END IF;
    
        IF l_component_name IN (pk_edis_triage.g_ds_comp_triage, g_ds_comp_triage_ctas)
        THEN
            l_add_vs_node := TRUE;
        END IF;
    
        g_error := 'GET TRIAGE_TYPE DESC';
        pk_alertlog.log_debug(g_error);
        SELECT pk_translation.get_translation(i_lang => i_lang, i_code_mess => tt.code_triage_type), tt.acronym
          INTO l_triage_type_desc, l_triage_acronym
          FROM triage_type tt
         WHERE tt.id_triage_type = l_row_triage_config.id_triage_type;
    
        g_error := 'CALL GET_TRIAGE_LABELS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        IF NOT get_triage_labels(i_lang             => i_lang,
                                 i_prof             => i_prof,
                                 i_episode          => NULL,
                                 i_triage_acronym   => l_triage_acronym,
                                 o_flowchart        => l_flowchart,
                                 o_discriminator    => l_discriminator,
                                 o_reason_for_visit => l_reason_for_visit,
                                 o_fchart_selection => l_fchart_selection,
                                 o_protocol         => l_protocol,
                                 o_confirmation     => l_confirmation,
                                 o_current_prof     => l_current_prof,
                                 o_other_discrim    => l_other_discriminator,
                                 o_error            => l_error)
        THEN
            RAISE l_internal_error;
        END IF;
    
        IF i_epis_triage IS NOT NULL
        THEN
            g_error := 'CALL GET_TRIAGE_SVD_DATA';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT get_triage_svd_data(i_lang        => i_lang,
                                       i_prof        => i_prof,
                                       i_epis_triage => i_epis_triage,
                                       o_triage      => l_triage,
                                       o_error       => l_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        IF i_flg_call = pk_edis_hist.g_call_hist
        THEN
            add_fast_track(i_rank => 10, i_flg_type => pk_edis_hist.g_call_hist);
            l_ds_root_hist_pk := l_ds_root_hist;
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_root_hist_pk,
                                                                               i_ds_component_parent => NULL,
                                                                               i_ds_component        => l_ds_root_hist_pk,
                                                                               i_component_desc      => l_protocol,
                                                                               i_internal_name       => 'TRIAGEM_HIST',
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => NULL);
            add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                           i_item_desc       => NULL,
                           i_item_value      => NULL,
                           i_item_alt_value  => NULL);
        
        END IF;
        g_error := 'ADD ROOT ELEMENT'; --CORRESPONDS TO DETAIL NODE OF THE XML SENT TO FLASH
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_ret_tbl_sections.extend;
        l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_root_pk,
                                                                           i_ds_component_parent => l_ds_root_hist_pk,
                                                                           i_ds_component        => l_ds_root_pk,
                                                                           i_component_desc      => l_triage_type_desc,
                                                                           i_internal_name       => l_ds_root_int_name,
                                                                           i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                           i_rank                => NULL);
    
        IF i_epis_triage IS NOT NULL
           AND i_show_additional_info
           AND nvl(i_flg_call, pk_edis_hist.g_call_detail) <> 'S'
        THEN
            g_error := 'ADD TRIAGE_BOARD FOR DETAIL';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            add_critical_look(i_rank => 20);
            IF i_triage_type <> g_triage_id_atas
            THEN
                add_triage_board(i_rank => 50);
            END IF;
        END IF;
    
        g_error := 'CALL PK_DYNAMIC_SCREEN.GET_DS_SECTION_REC';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_ds_root_rec := pk_dynamic_screen.get_ds_section_rec(i_lang           => i_lang,
                                                              i_prof           => i_prof,
                                                              i_component_name => l_component_name,
                                                              i_component_type => l_component_type);
    
        l_ds_root_rec.id_ds_component_parent := l_ds_root_pk;
    
        g_error := 'ADD DS ROOT ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO FLASH
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_ret_tbl_sections.extend;
        l_ret_tbl_sections(l_ret_tbl_sections.count) := l_ds_root_rec;
    
        IF i_ds_tbl_nodes.exists(1)
        THEN
            l_tbl_nodes := i_ds_tbl_nodes;
        ELSE
            g_error := 'GET NODES';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT get_section_events_list_int(i_lang                 => i_lang,
                                               i_prof                 => i_prof,
                                               i_episode              => i_episode,
                                               i_show_additional_info => i_show_additional_info,
                                               o_section              => l_tbl_nodes,
                                               o_def_events           => l_tbl_def_events,
                                               o_error                => l_error)
            THEN
                RAISE l_internal_error;
            END IF;
        END IF;
    
        IF l_tbl_nodes.exists(1)
        THEN
            g_error := 'GET ID_PATIENT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            SELECT id_patient
              INTO l_patient
              FROM episode epis
             WHERE epis.id_episode = i_episode;
        
            FOR i IN l_tbl_nodes.first .. l_tbl_nodes.last
            LOOP
                IF (l_tbl_nodes(i).internal_name IN (g_ds_comp_est_vsigns, g_ds_comp_vsigns) AND i_show_additional_info)
                   OR l_tbl_nodes(i).internal_name NOT IN (g_ds_comp_est_vsigns, g_ds_comp_vsigns)
                   OR
                   (l_tbl_nodes(i)
                   .internal_name != g_ds_comp_triage_general AND nvl(i_flg_call, pk_edis_hist.g_call_detail) <> 'S')
                THEN
                    l_ret_tbl_sections.extend; --CORRESPONDS TO SECTION NODE OF THE XML SENT TO FLASH
                    l_ret_tbl_sections(l_ret_tbl_sections.count) := l_tbl_nodes(i);
                
                    g_error := 'GET LEAFS';
                    pk_alertlog.log_debug(text            => g_error,
                                          object_name     => g_package_name,
                                          sub_object_name => l_func_name);
                    IF get_section_data_int(i_lang           => i_lang,
                                            i_prof           => i_prof,
                                            i_patient        => l_patient,
                                            i_episode        => i_episode,
                                            i_epis_triage    => i_epis_triage,
                                            i_component_name => l_tbl_nodes(i).internal_name,
                                            i_component_type => l_tbl_nodes(i).flg_component_type,
                                            o_section        => l_tbl_leafs,
                                            o_def_events     => l_tbl_def_events,
                                            o_events         => l_tbl_events,
                                            o_items_values   => l_tbl_items_values,
                                            o_error          => l_error)
                    THEN
                        IF l_tbl_leafs IS NOT NULL
                           AND l_tbl_leafs.count > 0
                        THEN
                            FOR j IN l_tbl_leafs.first .. l_tbl_leafs.last
                            LOOP
                                IF j != 1
                                THEN
                                    l_ret_tbl_sections.extend; --CORRESPONDS TO ITEM NODE OF THE XML SENT TO FLASH
                                    l_ret_tbl_sections(l_ret_tbl_sections.count) := l_tbl_leafs(j);
                                END IF;
                            END LOOP;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        END IF;
    
        IF i_show_additional_info
           AND l_add_vs_node
           AND l_ret_tbl_sections.exists(3) --Index 3 corresponds to the general node of the generic triage form
        THEN
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => g_ds_vs_node_pk,
                                                                               i_ds_component_parent => l_ret_tbl_sections(3).id_ds_component_parent,
                                                                               i_ds_component        => g_ds_vs_node_pk,
                                                                               i_component_desc      => pk_translation.get_translation(i_lang      => i_lang,
                                                                                                                                       i_code_mess => l_code_trans_vs_node),
                                                                               i_internal_name       => l_ds_vs_node_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_node_component,
                                                                               i_rank                => 100);
        
            IF i_epis_triage IS NOT NULL
               AND l_triage.vital_signs.exists(1)
            THEN
                FOR i IN l_triage.vital_signs.first .. l_triage.vital_signs.last
                LOOP
                    l_rec_vs := l_triage.vital_signs(i);
                
                    l_ret_tbl_sections.extend;
                    l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => g_ds_vs_node_pk ||
                                                                                                                l_rec_vs.id_vital_sign,
                                                                                       i_ds_component_parent => g_ds_vs_node_pk,
                                                                                       i_ds_component        => g_ds_vs_node_pk ||
                                                                                                                l_rec_vs.id_vital_sign,
                                                                                       i_component_desc      => l_rec_vs.desc_vital_sign,
                                                                                       i_internal_name       => l_rec_vs.internal_name,
                                                                                       i_flg_component_type  => pk_dynamic_screen.c_leaf_component,
                                                                                       i_rank                => l_rec_vs.rank);
                
                    add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                   i_item_desc       => l_rec_vs.desc_value,
                                   i_item_value      => l_rec_vs.value,
                                   i_item_alt_value  => NULL);
                END LOOP;
            END IF;
        END IF;
    
        IF i_show_additional_info
        THEN
            IF i_epis_triage IS NULL
               AND i_triage_type IN (g_triage_id_ctas_p, g_triage_id_ctas_a)
            THEN
                g_error := 'ADD critical look FOR TRIAGE CONFIRMATION SCREEN';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                add_critical_look(i_rank => 200);
            END IF;
            IF i_epis_triage IS NULL
            THEN
                g_error := 'ADD TRIAGE_BOARD FOR TRIAGE CONFIRMATION SCREEN';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                add_triage_board(i_rank => 210);
            END IF;
        
            IF i_epis_triage IS NOT NULL
            THEN
                g_error := 'ADD COLOR INFO ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO DETAIL SCREEN
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
                l_ret_tbl_sections.extend;
                l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_color_pk,
                                                                                   i_ds_component_parent => l_ds_root_pk,
                                                                                   i_ds_component        => l_ds_color_pk,
                                                                                   i_component_desc      => get_triage_color_orig(i_lang,
                                                                                                                                  i_prof,
                                                                                                                                  g_type_color_title,
                                                                                                                                  l_triage.id_triage_type,
                                                                                                                                  l_triage.id_triage_orig_color),
                                                                                   i_internal_name       => l_ds_color_int_name,
                                                                                   i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                                   i_rank                => 250);
            
                g_error := 'ADD COLOR INFO FROM SAVED DATA';
                pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            
                add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                               i_item_desc       => l_triage.desc_triage_color,
                               i_item_value      => l_triage.id_triage_color,
                               i_item_alt_value  => NULL);
            END IF;
        
            g_error := 'ADD DEFINING CRITERIA ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO DETAIL SCREEN
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_defin_crit_pk,
                                                                               i_ds_component_parent => l_ds_root_pk,
                                                                               i_ds_component        => l_ds_defin_crit_pk,
                                                                               i_component_desc      => l_discriminator,
                                                                               i_internal_name       => g_ds_def_crit_int_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => 300);
        
            IF i_epis_triage IS NOT NULL
               AND l_triage.defining_criterias.exists(1)
            THEN
                IF nvl(l_triage.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                THEN
                    add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                                   i_item_desc       => NULL,
                                   i_item_value      => NULL,
                                   i_item_alt_value  => NULL,
                                   i_item_xml_value  => get_defining_criteria_str(i_lang                  => i_lang,
                                                                                  i_tbl_defining_criteria => l_triage.defining_criterias));
                
                END IF;
            END IF;
        
            g_error := 'ADD OTHER CRITERIA ELEMENT'; --CORRESPONDS TO BLOCK NODE OF THE XML SENT TO FLASH AND DETAIL SCREEN
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_other_crit_pk,
                                                                               i_ds_component_parent => l_ds_root_pk,
                                                                               i_ds_component        => l_ds_other_crit_pk,
                                                                               i_component_desc      => l_other_discriminator,
                                                                               i_internal_name       => g_ds_other_crit_int_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => 400);
        
            IF i_epis_triage IS NOT NULL
               AND l_triage.other_criterias.exists(1)
            THEN
                l_critical_look_str := get_critical_look_desc_str(i_lang                => i_lang,
                                                                  i_epis_triage         => i_epis_triage,
                                                                  i_flg_critical_look   => l_triage.flg_critical_look,
                                                                  i_flg_selected_option => pk_alert_constant.g_no);
                add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                               i_item_desc       => NULL,
                               i_item_value      => NULL,
                               i_item_alt_value  => NULL,
                               i_item_xml_value  => get_defining_criteria_str(i_lang                  => i_lang,
                                                                              i_tbl_defining_criteria => l_triage.other_criterias,
                                                                              i_critical_look_str     => l_critical_look_str));
            END IF;
            g_error := 'ADD FINAL NOTES ELEMENT';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            l_ret_tbl_sections.extend;
            l_ret_tbl_sections(l_ret_tbl_sections.count) := get_ds_section_rec(i_ds_cmpt_mkt_rel     => l_ds_notes_pk,
                                                                               i_ds_component_parent => l_ds_root_pk,
                                                                               i_ds_component        => l_ds_notes_pk,
                                                                               i_component_desc      => pk_message.get_message(i_lang,
                                                                                                                               'TRIAGE_T016'),
                                                                               i_internal_name       => l_ds_notes_int_name,
                                                                               i_flg_component_type  => pk_dynamic_screen.c_root_component,
                                                                               i_rank                => 450,
                                                                               i_max_len             => 1000);
        
            g_error := 'ADD FINAL NOTES ELEMENT SAVED DATA';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            add_saved_data(i_section_tbl_idx => l_ret_tbl_sections.count,
                           i_item_desc       => l_triage.notes,
                           i_item_value      => NULL,
                           i_item_alt_value  => NULL);
        
            IF i_epis_triage IS NOT NULL
            THEN
                add_fast_track(i_rank => 500, i_flg_type => pk_edis_hist.g_call_detail);
            END IF;
        
        END IF;
    
        RETURN l_ret_tbl_sections;
    EXCEPTION
        WHEN l_internal_error THEN
            RETURN t_table_ds_sections();
    END tf_detail_schema;

    /**
    * Returns the id_context based on the area to be validated
    *
    * @param   i_flg_type                  F - Form; B - Triage board; D - Triage discriminator
    * @param   i_triage_board              Triage board pk
    * @param   i_triage_discriminator      Triage discriminator pk
    * @param   i_null_value                Value used when flg_type = F
    *
    * @return  If the area is F returns the i_null_value, if it's B returns the id_triage_board, 
    *          if it's D returns the id_triage_discriminator otherwise returns NULL
    *
    * @author  Alexandre Santos
    * @version v2.6
    * @since   28-12-2011
    */
    FUNCTION get_vs_area_id_cxt
    (
        i_flg_type             IN triage_vs_area.flg_context%TYPE,
        i_triage_board         IN triage_vs_area.id_context%TYPE,
        i_triage_discriminator IN triage_vs_area.id_context%TYPE,
        i_null_value           IN PLS_INTEGER DEFAULT g_null_value
    ) RETURN triage_vs_area.id_context%TYPE IS
        l_ret triage_vs_area.id_context%TYPE;
    BEGIN
        CASE i_flg_type
            WHEN pk_edis_triage.g_flg_context_id_triage_board THEN
                l_ret := i_triage_board;
            WHEN pk_edis_triage.g_flg_context_id_triage_disc THEN
                l_ret := i_triage_discriminator;
            WHEN pk_edis_triage.g_flg_context_id_ds_component THEN
                l_ret := i_null_value;
            ELSE
                l_ret := NULL;
        END CASE;
    
        RETURN l_ret;
    END get_vs_area_id_cxt;

    /**************************************************************************
    * Register triage event.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_params                 Method parameters (XML format)
    * @param o_epis_triage            Triage event ID
    * @param o_epis_anamnesis         Patient complaint ID
    * @param o_shortcut               Shortcut to follow after end of triage
    * @param o_error                  Error message
    *
    * @return                         TRUE/FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.1
    * @since                          21-12-2012
    *
    **************************************************************************/
    FUNCTION create_epis_triage
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_params         IN CLOB,
        o_epis_triage    OUT epis_triage.id_epis_triage%TYPE,
        o_epis_anamnesis OUT epis_anamnesis.id_epis_anamnesis%TYPE,
        o_shortcut       OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'CREATE_EPIS_TRIAGE';
        l_exception EXCEPTION;
    
        l_triage pk_edis_types.rec_triage;
    BEGIN
    
        g_error := 'CALL PARSE_TRIAGE_PARAMETERS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT parse_triage_parameters(i_lang       => i_lang,
                                       i_prof       => i_prof,
                                       i_params     => i_params,
                                       o_rec_triage => l_triage,
                                       o_error      => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'CALL CREATE_EPIS_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT create_epis_triage(i_lang           => i_lang,
                                  i_prof           => i_prof,
                                  i_triage         => l_triage,
                                  o_epis_triage    => o_epis_triage,
                                  o_epis_anamnesis => o_epis_anamnesis,
                                  o_shortcut       => o_shortcut,
                                  o_error          => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              o_error.err_desc,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_epis_triage;

    /**************************************************************************
    * Register triage event.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_triage                 Triage info
    * @param o_epis_triage            Triage event ID
    * @param o_epis_anamnesis         Patient complaint ID
    * @param o_shortcut               Shortcut to follow after end of triage
    * @param o_error                  Error message
    *
    * @return                         TRUE/FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.1
    * @since                          21-12-2012
    *
    **************************************************************************/
    FUNCTION create_epis_triage_internal
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_triage         IN pk_edis_types.rec_triage,
        o_epis_triage    OUT epis_triage.id_epis_triage%TYPE,
        o_epis_anamnesis OUT epis_anamnesis.id_epis_anamnesis%TYPE,
        o_shortcut       OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'CREATE_EPIS_TRIAGE';
        l_exception EXCEPTION;
        l_sysdate_tstz             TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_id_necessity_tbl         table_number := table_number();
        l_necessity_flg_active_tbl table_varchar := table_varchar();
        l_rows_ei                  table_varchar;
        l_id_vital_signs_tbl       table_number := table_number();
        l_vital_signs_value_tbl    table_number := table_number();
        l_vs_unit_measure_tbl      table_number := table_number();
        l_vs_scales_element_tbl    table_number := table_number();
        l_next_anamnesis           epis_anamnesis.id_epis_anamnesis%TYPE;
        l_next_triage              epis_triage.id_epis_triage%TYPE;
        l_previous_triage          epis_triage.id_epis_triage%TYPE;
        l_rows                     table_varchar;
        l_id_presc                 presc.id_presc%TYPE;
        l_id_transportation        transportation.id_transportation%TYPE;
        l_safeguarding_alert       sys_alert.id_sys_alert%TYPE := 311;
        l_treatment                epis_triage.treatment%TYPE;
        l_alert_safeguarding       sys_config.value%TYPE;
        CURSOR c_sh_complaint IS
            SELECT a.id_sys_shortcut
              FROM sys_shortcut a
             WHERE a.intern_name = 'TRIAGE_CREATE'
               AND a.id_software = i_prof.software
               AND a.id_parent IS NULL
               AND a.id_institution = (SELECT MAX(b.id_institution)
                                         FROM sys_shortcut b
                                        WHERE b.id_software = a.id_software
                                          AND b.id_institution IN (i_prof.institution, 0)
                                          AND b.intern_name = a.intern_name
                                          AND b.id_parent IS NULL)
             ORDER BY id_institution DESC;
    
        PROCEDURE load_needs_tbl IS
        BEGIN
            IF i_triage.needs IS NOT NULL
               AND i_triage.needs.count > 0
            THEN
                FOR i IN i_triage.needs.first .. i_triage.needs.last
                LOOP
                    IF i_triage.needs(i).id_necessity IS NOT NULL
                    THEN
                        l_id_necessity_tbl.extend;
                        l_id_necessity_tbl(l_id_necessity_tbl.count) := i_triage.needs(i).id_necessity;
                    
                        l_necessity_flg_active_tbl.extend;
                        l_necessity_flg_active_tbl(l_necessity_flg_active_tbl.count) := i_triage.needs(i).flg_status;
                    END IF;
                END LOOP;
            END IF;
        END load_needs_tbl;
    
        PROCEDURE load_vital_signs IS
        BEGIN
            IF i_triage.vital_signs IS NOT NULL
               AND i_triage.vital_signs.count > 0
            THEN
                FOR i IN i_triage.vital_signs.first .. i_triage.vital_signs.last
                LOOP
                    IF (i_triage.vital_signs(i).value IS NOT NULL OR i_triage.vital_signs(i).id_vital_sign_desc IS NOT NULL)
                       AND nvl(i_triage.vital_signs(i).flg_save, g_no) = g_yes
                    THEN
                        l_id_vital_signs_tbl.extend;
                        l_id_vital_signs_tbl(l_id_vital_signs_tbl.count) := i_triage.vital_signs(i).id_vital_sign;
                    
                        l_vital_signs_value_tbl.extend;
                        l_vital_signs_value_tbl(l_vital_signs_value_tbl.count) := nvl(i_triage.vital_signs(i).value,
                                                                                      i_triage.vital_signs(i).id_vital_sign_desc);
                    
                        l_vs_unit_measure_tbl.extend;
                        l_vs_unit_measure_tbl(l_vs_unit_measure_tbl.count) := i_triage.vital_signs(i).id_unit_measure;
                    
                        l_vs_scales_element_tbl.extend;
                        l_vs_scales_element_tbl(l_vs_scales_element_tbl.count) := i_triage.vital_signs(i).id_scales_element;
                    END IF;
                END LOOP;
            END IF;
        END load_vital_signs;
    
    BEGIN
    
        -- When the discriminators "Reassess" or "Secondary triage" are selected,
        --  the application loads the shortcut to return to complaint screen
        IF i_triage.flg_reassess IN (g_flg_reassess_yes, g_flg_reassess_secondary)
        THEN
            g_error := 'OPEN C_SH_COMPLAINT';
            OPEN c_sh_complaint;
            FETCH c_sh_complaint
                INTO o_shortcut;
            CLOSE c_sh_complaint;
        END IF;
    
        -- Saving process begins:
        IF i_triage.flg_reassess = g_flg_reassess_secondary
        THEN
            -- IMPORTANT!!
            -- When setting a "secondary triage" the function returns without saving.
            RETURN TRUE;
        ELSE
        
            g_error := 'CALL SET_ANAMNESIS_COMPLAINT';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            set_anamnesis_complaint(i_lang              => i_lang,
                                    i_prof              => i_prof,
                                    i_id_epis           => i_triage.id_episode,
                                    i_id_patient        => i_triage.id_patient,
                                    i_desc_anamnesis    => i_triage.chief_complaint,
                                    i_dt_end            => i_triage.dt_triage_end,
                                    i_flg_complaint     => i_triage.flg_complaint,
                                    o_id_epis_anamnesis => l_next_anamnesis,
                                    o_error             => o_error);
        
            IF i_triage.emergency_contact IS NOT NULL
               AND i_triage.id_triage_type != pk_edis_triage.g_triage_id_est
            THEN
                g_error := 'CALL PK_ADT.ADD_EMERGENCY_CONTACT';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                IF NOT pk_adt.add_emergency_contact(i_lang    => i_lang,
                                                    i_prof    => i_prof,
                                                    i_patient => i_triage.id_patient,
                                                    i_contact => i_triage.emergency_contact,
                                                    o_error   => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        
            IF i_triage.flg_complaint = pk_alert_constant.g_yes
               AND i_triage.id_triage_white_reason IS NULL
            THEN
                g_error := 'CALL PK_EDIS_PROC.SET_ARRIVE_INTERNAL';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_edis_proc.set_arrive_internal(i_lang                  => i_lang,
                                                        i_prof                  => i_prof,
                                                        i_id_epis               => i_triage.id_episode,
                                                        i_dt_transportation_str => pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                               i_date => i_triage.dt_triage_end,
                                                                                                               i_prof => i_prof),
                                                        i_id_transp_entity      => i_triage.id_transp_entity,
                                                        i_flg_time              => 'E',
                                                        i_notes                 => i_triage.cause_comments.comments,
                                                        i_origin                => i_triage.origin.id_origin,
                                                        i_external_cause        => i_triage.cause_comments.id_external_cause,
                                                        i_companion             => NULL, -- IMPORTANT: Will keep the previous record
                                                        i_internal_type         => 'T', -- Registered in triage
                                                        i_sysdate               => l_sysdate_tstz,
                                                        o_id_transportation     => l_id_transportation,
                                                        o_error                 => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        
            -- 
            g_error := 'PROCESS TREATMENT';
            pk_alertlog.log_debug(g_error);
            SELECT nvl2(REPLACE(REPLACE(REPLACE(i_triage.treatment, chr(32), ''), chr(10), ''), chr(13), ''),
                        i_triage.treatment,
                        NULL)
              INTO l_treatment
              FROM dual;
        
            g_error := 'SAVE EPIS_TRIAGE';
            pk_alertlog.log_debug(g_error);
            ts_epis_triage.ins(id_epis_triage_out        => l_next_triage,
                               id_episode_in             => i_triage.id_episode,
                               id_triage_color_in        => i_triage.id_triage_color,
                               id_triage_in              => i_triage.id_triage,
                               id_professional_in        => i_prof.id,
                               dt_begin_tstz_in          => i_triage.dt_triage_begin,
                               dt_end_tstz_in            => i_triage.dt_triage_end,
                               flg_letter_in             => i_triage.flg_letter,
                               notes_in                  => i_triage.notes,
                               id_origin_in              => i_triage.origin.id_origin,
                               desc_origin_in            => i_triage.origin.desc_origin_ft,
                               id_triage_white_reason_in => i_triage.id_triage_white_reason,
                               id_epis_anamnesis_in      => l_next_anamnesis,
                               id_triage_color_orig_in   => i_triage.id_triage_orig_color,
                               id_transp_entity_in       => i_triage.id_transp_entity,
                               flg_selected_option_in    => i_triage.flg_selected_option,
                               emergency_contact_in      => i_triage.emergency_contact,
                               flg_pregnant_in           => i_triage.pregnant.flg_pregnant,
                               preg_weeks_in             => i_triage.pregnant.pregnancy_weeks,
                               flg_postpartum_in         => i_triage.pregnant.flg_postpartum,
                               treatment_in              => l_treatment,
                               id_triage_board_in        => i_triage.id_triage_board,
                               initial_notes_in          => i_triage.initial_notes,
                               accident_desc_in          => i_triage.accident_desc,
                               id_transportation_in      => l_id_transportation,
                               flg_under_two_years_in    => i_triage.safeguarding.flg_under_two_years,
                               flg_immobile_in           => i_triage.safeguarding.flg_immobile,
                               flg_unexplained_injury_in => i_triage.safeguarding.flg_injury,
                               flg_protection_plan_in    => i_triage.safeguarding.flg_protection_plan,
                               flg_attendance_delay_in   => i_triage.safeguarding.flg_attend_delay,
                               flg_domestic_abuse_in     => i_triage.safeguarding.flg_domestic_abuse,
                               flg_possible_injury_in    => i_triage.safeguarding.flg_possible_injury,
                               flg_has_social_work_in    => i_triage.safeguarding.flg_has_social,
                               social_work_name_in       => i_triage.safeguarding.social_work_name,
                               social_work_address_in    => i_triage.safeguarding.social_work_address,
                               flg_social_services_in    => i_triage.safeguarding.flg_social_services,
                               social_reason_in          => i_triage.safeguarding.social_reason,
                               flg_consent_social_in     => i_triage.safeguarding.flg_consent_social,
                               flg_info_sharing_in       => i_triage.safeguarding.flg_info_sharing,
                               dt_social_contact_in      => i_triage.safeguarding.dt_social_contact,
                               social_info_received_in   => i_triage.safeguarding.social_info_received,
                               flg_signs_abuse_in        => i_triage.safeguarding.flg_signs_abuse,
                               flg_critical_look_in      => i_triage.flg_critical_look,
                               rows_out                  => l_rows);
        
            g_error := 'CALL SET_TRIAGE_OPTIONS';
            pk_alertlog.log_debug(g_error);
            IF NOT set_triage_options(i_lang        => i_lang,
                                      i_prof        => i_prof,
                                      i_epis_triage => l_next_triage,
                                      i_triage      => i_triage,
                                      o_error       => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF l_treatment IS NOT NULL
            THEN
                g_error := 'CALL PK_API_PFH_IN.CREATE_REPORTED_FREETEXT';
                pk_alertlog.log_debug(g_error);
                -- call Medication API to register treatment in the Medication report
                pk_api_pfh_in.create_reported_freetext(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_id_patient   => i_triage.id_patient,
                                                       i_id_episode   => i_triage.id_episode,
                                                       i_desc_product => l_treatment,
                                                       o_id_presc     => l_id_presc,
                                                       o_error        => o_error);
            END IF;
        
            IF i_triage.flg_complaint = pk_alert_constant.g_yes
               AND i_triage.id_triage_white_reason IS NULL
            THEN
                g_error := 'CALL LOAD_NEEDS_TBL';
                pk_alertlog.log_debug(g_error);
                load_needs_tbl;
            
                g_error := 'CALL PK_PATIENT.SET_PAT_NECESS_INTERNAL';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_patient.set_pat_necess(i_lang             => i_lang,
                                                 i_prof             => i_prof,
                                                 i_id_patient       => i_triage.id_patient,
                                                 i_id_episode       => i_triage.id_episode,
                                                 i_tbl_id_necessity => l_id_necessity_tbl,
                                                 i_tbl_flg_status   => l_necessity_flg_active_tbl,
                                                 i_sysdate          => l_sysdate_tstz,
                                                 i_id_epis_triage   => l_next_triage,
                                                 o_error            => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        
            g_error := 'UPDATE EPIS_INFO';
            pk_alertlog.log_debug(g_error);
            ts_epis_info.upd(id_episode_in => i_triage.id_episode,
                             -- Main triage related columns
                             triage_flg_letter_in   => i_triage.flg_letter,
                             triage_flg_letter_nin  => FALSE,
                             triage_acuity_in       => nvl(i_triage.triage_color_color, '0x787864'),
                             triage_acuity_nin      => FALSE,
                             triage_color_text_in   => nvl(i_triage.triage_color_text, '0xFFFFFF'),
                             triage_color_text_nin  => FALSE,
                             triage_rank_acuity_in  => nvl(i_triage.triage_color_rank, 999),
                             triage_rank_acuity_nin => FALSE,
                             id_triage_color_in     => i_triage.id_triage_color,
                             -- Remaining triage related columns
                             id_first_triage_in         => CASE i_triage.epis_triage_count
                                                               WHEN 0 THEN
                                                                i_triage.id_triage
                                                               ELSE
                                                                NULL
                                                           END,
                             id_first_triage_nin        => FALSE,
                             id_first_triage_wr_in      => CASE i_triage.epis_triage_count
                                                               WHEN 0 THEN
                                                                i_triage.id_triage_white_reason
                                                               ELSE
                                                                NULL
                                                           END,
                             id_first_triage_wr_nin     => FALSE,
                             id_triage_in               => i_triage.id_triage,
                             id_triage_nin              => FALSE,
                             id_triage_white_reason_in  => i_triage.id_triage_white_reason,
                             id_triage_white_reason_nin => FALSE,
                             rows_out                   => l_rows_ei);
        
            -- Process vital signs registered during triage
            load_vital_signs;
        
            IF l_id_vital_signs_tbl IS NOT NULL
               AND l_vital_signs_value_tbl IS NOT NULL
               AND l_id_vital_signs_tbl.count > 0
               AND l_vital_signs_value_tbl.count > 0
            THEN
                g_error := 'SET VS EPIS_TRIAGE';
                pk_alertlog.log_debug(g_error);
                IF NOT pk_edis_triage.set_triage_vs(i_lang              => i_lang,
                                                    i_prof              => i_prof,
                                                    i_prof_cat_type     => i_triage.id_prof_cat,
                                                    i_id_epis           => i_triage.id_episode,
                                                    i_patient           => i_triage.id_patient,
                                                    i_epis_triage       => l_next_triage,
                                                    i_dt_triage_begin   => i_triage.dt_triage_begin,
                                                    i_vs_id             => l_id_vital_signs_tbl,
                                                    i_vs_val            => l_vital_signs_value_tbl,
                                                    i_unit_meas         => l_vs_unit_measure_tbl,
                                                    i_scales_element_id => l_vs_scales_element_tbl,
                                                    o_error             => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        
            IF i_triage.id_triage_type = pk_edis_triage.g_triage_id_est
               AND i_triage.vital_signs.exists(1)
            THEN
                FOR i IN i_triage.vital_signs.first .. i_triage.vital_signs.last
                LOOP
                    IF i_triage.vital_signs(i).urgency_level IS NOT NULL
                        OR i_triage.vital_signs(i).is_to_ignore_result = pk_alert_constant.g_yes
                    THEN
                        ts_epis_triage_vs.ins(id_epis_triage_in    => l_next_triage,
                                              id_vital_sign_in     => i_triage.vital_signs(i).id_vital_sign,
                                              urgency_level_in     => i_triage.vital_signs(i).urgency_level,
                                              flg_ignore_result_in => i_triage.vital_signs(i).is_to_ignore_result);
                    END IF;
                END LOOP;
            END IF;
        
            --Needed for the Integration of ALERT with the Billing System Red UC
            --This call must be made before calling pk_visit.set_first_obs
            g_error := 'CALL TO PK_PATIENT_TRACKING.SET_CARE_STAGE_TRIAGE';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_patient_tracking.set_care_stage_triage(i_lang    => i_lang,
                                                             i_prof    => i_prof,
                                                             i_episode => i_triage.id_episode,
                                                             o_error   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'CALL TO SET_FIRST_OBS';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_visit.set_first_obs(i_lang                => i_lang,
                                          i_id_episode          => i_triage.id_episode,
                                          i_pat                 => NULL,
                                          i_prof                => i_prof,
                                          i_prof_cat_type       => i_triage.id_prof_cat,
                                          i_dt_last_interaction => l_sysdate_tstz,
                                          i_dt_first_obs        => l_sysdate_tstz,
                                          i_flg_triage_call     => pk_alert_constant.g_yes,
                                          o_error               => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            -- FINAL PROCESSING:
            -- Grid Task + Fast Track + Alerts + Data Governance
            g_error := 'SET GRID_TASK';
            pk_alertlog.log_debug(g_error);
            set_grid_task(i_lang => i_lang, i_prof => i_prof, i_id_epis => i_triage.id_episode, o_error => o_error);
        
            g_error := 'SET EPISODE FAST TRACK';
            pk_alertlog.log_debug(g_error);
            IF i_triage.id_triage_type <> g_triage_id_est
               AND i_triage.id_triage IS NOT NULL
            THEN
                IF NOT pk_fast_track.set_epis_fast_track_auto(i_lang           => i_lang,
                                                              i_prof           => i_prof,
                                                              i_id_episode     => i_triage.id_episode,
                                                              i_id_triage      => i_triage.id_triage,
                                                              i_id_epis_triage => l_next_triage,
                                                              o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        
            g_error := 'SET TRIAGE ALERTS';
            pk_alertlog.log_debug(g_error);
            set_triage_alerts(i_lang          => i_lang,
                              i_prof          => i_prof,
                              i_id_epis       => i_triage.id_episode,
                              i_epis_dt_begin => i_triage.episode_dt_begin,
                              i_dt_triage_end => i_triage.dt_triage_end,
                              o_error         => o_error);
        
            l_alert_safeguarding := pk_sysconfig.get_config(i_code_cf => g_cfg_alert_triage_safeguard, i_prof => i_prof);
            IF nvl(l_alert_safeguarding, pk_alert_constant.g_no) = pk_alert_constant.g_yes
            THEN
                -- safeguarding alert
                IF (i_triage.safeguarding.flg_immobile = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_injury = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_protection_plan = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_attend_delay = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_domestic_abuse = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_possible_injury = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_has_social = pk_alert_constant.g_yes OR
                   i_triage.safeguarding.flg_social_services = pk_alert_constant.g_yes)
                
                THEN
                
                    g_error := 'INSERT PEDRIATIC ALERTS';
                    pk_alertlog.log_debug(g_error);
                    IF NOT pk_alerts.insert_sys_alert_event(i_lang                => i_lang,
                                                            i_prof                => i_prof,
                                                            i_sys_alert           => l_safeguarding_alert,
                                                            i_id_episode          => i_triage.id_episode,
                                                            i_id_record           => l_next_triage,
                                                            i_dt_record           => current_timestamp,
                                                            i_id_professional     => NULL,
                                                            i_id_room             => NULL,
                                                            i_id_clinical_service => NULL,
                                                            i_flg_type_dest       => NULL,
                                                            i_replace1            => NULL,
                                                            o_error               => o_error)
                    THEN
                        NULL;
                    END IF;
                
                ELSIF i_triage.safeguarding.flg_under_two_years = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_immobile = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_injury = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_protection_plan = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_attend_delay = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_domestic_abuse = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_possible_injury = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_has_social = pk_alert_constant.g_no
                      AND i_triage.safeguarding.flg_social_services = pk_alert_constant.g_no
                THEN
                    -- if a triage is being created and it does not activate the safeguarding alert, delete previous safeguarding alerts
                    BEGIN
                        SELECT id_epis_triage
                          INTO l_previous_triage
                          FROM (SELECT et.id_epis_triage
                                  FROM epis_triage et
                                 WHERE et.id_episode = i_triage.id_episode
                                   AND et.id_epis_triage <> l_next_triage
                                 ORDER BY dt_end_tstz DESC)
                         WHERE rownum = 1;
                    
                        IF NOT pk_alerts.delete_sys_alert_event(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_id_sys_alert => l_safeguarding_alert,
                                                                i_id_record    => l_previous_triage,
                                                                o_error        => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                    EXCEPTION
                        WHEN no_data_found THEN
                            NULL; -- no triage data for this episode, proceed as normal
                    END;
                END IF;
            ELSE
                -- do not generate alert              
                -- if a triage is being created and it does not activate the safeguarding alert, delete previous safeguarding alerts
                BEGIN
                    SELECT id_epis_triage
                      INTO l_previous_triage
                      FROM (SELECT et.id_epis_triage
                              FROM epis_triage et
                             WHERE et.id_episode = i_triage.id_episode
                               AND et.id_epis_triage <> l_next_triage
                             ORDER BY dt_end_tstz DESC)
                     WHERE rownum = 1;
                
                    IF NOT pk_alerts.delete_sys_alert_event(i_lang         => i_lang,
                                                            i_prof         => i_prof,
                                                            i_id_sys_alert => l_safeguarding_alert,
                                                            i_id_record    => l_previous_triage,
                                                            o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                EXCEPTION
                    WHEN no_data_found THEN
                        NULL; -- no triage data for this episode, proceed as normal
                END;
            END IF;
            g_error := 'DATA GOVERNANCE PROCESSING';
            pk_alertlog.log_debug(g_error);
            t_data_gov_mnt.process_insert(i_lang, i_prof, 'EPIS_TRIAGE', l_rows, o_error);
            t_data_gov_mnt.process_update(i_lang       => i_lang,
                                          i_prof       => i_prof,
                                          i_table_name => 'EPIS_INFO',
                                          i_rowids     => l_rows_ei,
                                          o_error      => o_error);
        
            o_epis_anamnesis := l_next_anamnesis;
            o_epis_triage    := l_next_triage;
        
            g_error := 'UPDATE MVIEW';
            pk_alertlog.log_debug(g_error);
            pk_episode.update_mv_episodes();
        
            g_error := 'SEND TRIAGE EVENT';
            pk_alertlog.log_debug(g_error);
            pk_ia_event_common.end_of_triage(l_next_triage, i_triage.id_episode);
        
            g_error := 'CALL PK_ADT_CORE.SET_DT_ARRIVAL';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_adt_core.set_dt_arrival(i_lang       => i_lang,
                                              i_prof       => i_prof,
                                              i_id_episode => i_triage.id_episode,
                                              i_dt_arrival => l_sysdate_tstz,
                                              o_error      => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              o_error.err_desc,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_epis_triage_internal;

    /**************************************************************************
    * Register triage event.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_triage                 Triage info
    * @param o_epis_triage            Triage event ID
    * @param o_epis_anamnesis         Patient complaint ID
    * @param o_shortcut               Shortcut to follow after end of triage
    * @param o_error                  Error message
    *
    * @return                         TRUE/FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.1
    * @since                          21-12-2012
    *
    **************************************************************************/
    FUNCTION create_epis_triage
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_triage         IN pk_edis_types.rec_triage,
        o_epis_triage    OUT epis_triage.id_epis_triage%TYPE,
        o_epis_anamnesis OUT epis_anamnesis.id_epis_anamnesis%TYPE,
        o_shortcut       OUT sys_shortcut.id_sys_shortcut%TYPE,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(30) := 'CREATE_EPIS_TRIAGE';
        l_exception EXCEPTION;
        l_sysdate_tstz TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_triage pk_edis_types.rec_triage;
    
        -- FLASH REQUIREMENT: get all needs that were not selected by the user, flash only sends selectected choices made by the user and the recording process needs to save all options (even if not selected)
        PROCEDURE fill_missing_needs IS
            c_necess            pk_patient.cursor_necess;
            r_necess            pk_patient.rec_necess;
            l_add_to_collection BOOLEAN := TRUE;
            l_need              pk_edis_types.rec_need;
        BEGIN
            g_error := 'CALL PK_PATIENT.GET_ALL_PAT_NECESS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            IF NOT pk_patient.get_all_pat_necess(i_lang       => i_lang,
                                                 i_prof       => i_prof,
                                                 i_id_patient => l_triage.id_patient,
                                                 i_id_episode => l_triage.id_episode,
                                                 o_necess     => c_necess,
                                                 o_error      => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'ADD ALL PAT_NECESS';
            pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
            LOOP
                FETCH c_necess
                    INTO r_necess;
                EXIT WHEN c_necess%NOTFOUND;
            
                IF l_triage.needs IS NOT NULL
                   AND l_triage.needs.count > 0
                THEN
                    FOR i IN l_triage.needs.first .. l_triage.needs.last
                    LOOP
                        IF l_triage.needs(i).id_necessity IS NOT NULL
                            AND l_triage.needs(i).id_necessity = r_necess.id_necessity
                        THEN
                            -- if the need is already in the collection it is discarded
                            l_add_to_collection := FALSE;
                        END IF;
                    END LOOP;
                ELSE
                    l_triage.needs := pk_edis_types.table_needs();
                END IF;
            
                IF l_add_to_collection
                THEN
                    l_need.id_necessity   := r_necess.id_necessity;
                    l_need.desc_necessity := r_necess.necess;
                    l_need.flg_status     := pk_patient.g_pat_necess_inactive;
                
                    l_triage.needs.extend;
                    l_triage.needs(l_triage.needs.count) := l_need;
                END IF;
            
                l_add_to_collection := TRUE;
            END LOOP;
        
            CLOSE c_necess;
        END fill_missing_needs;
    
        PROCEDURE fill_missing_data IS
            l_rec_color triage_color%ROWTYPE;
            --
            l_rec_grp_option   pk_edis_types.rec_group_option;
            l_rec_option       pk_edis_types.rec_option;
            l_rec_child_option pk_edis_types.rec_discrim_child;
            --
            l_discrim_with_consent VARCHAR2(1);
            l_critical_look        VARCHAR2(1 CHAR);
        BEGIN
            g_error              := 'GET PROF CATEGORY';
            l_triage.id_prof_cat := pk_edis_list.get_prof_cat(i_prof);
        
            IF l_triage.triage_duration IS NOT NULL
               OR (l_triage.dt_triage_begin IS NOT NULL AND l_triage.dt_triage_end IS NOT NULL)
            THEN
                -- Get the begin date based on the duration of the triage:
                --     subtract the amount of milliseconds to the current date.
                g_error := 'GET TRIAGE DATES (1)';
                pk_alertlog.log_debug(g_error);
                l_triage.dt_triage_begin := pk_date_utils.add_to_ltstz(l_sysdate_tstz,
                                                                       - (l_triage.triage_duration / 1000),
                                                                       'SECOND');
                l_triage.dt_triage_end   := l_sysdate_tstz;
            
            ELSE
                g_error := 'TRIAGE DURATION ERROR';
                RAISE l_exception;
            END IF;
        
            -- fill defining criteria values for saving
            g_error := 'CALL GET_DEFINING_CRITERIA';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            --We don't want to take in consideration the VS's when evaluating the defining criteria, 
            --here the def crit is used to save the value in epis_triage table
            l_triage.defining_criterias := get_defining_criteria(i_lang            => i_lang,
                                                                 i_tbl_grp_options => l_triage.group_options,
                                                                 i_tbl_vital_signs => NULL,
                                                                 i_triage_type     => l_triage.id_triage_type);
        
            IF l_triage.defining_criterias IS NOT NULL
               AND l_triage.defining_criterias.count > 0
            THEN
                FOR i IN l_triage.defining_criterias.first .. l_triage.defining_criterias.last
                LOOP
                    -- if there are several Yes, only the last one is stored
                    IF l_triage.defining_criterias(i).discrim_answer = g_yes
                    THEN
                        -- if it is a Yes answer, it is the main defining criteria. If it receives a child, saves the child, if not, saves the parent
                        IF l_triage.defining_criterias(i).child_criteria.id_triage IS NOT NULL
                        THEN
                            l_triage.id_triage           := l_triage.defining_criterias(i).child_criteria.id_triage;
                            l_triage.flg_selected_option := l_triage.defining_criterias(i).child_criteria.flg_accepted_option;
                            l_triage.flg_reassess        := l_triage.defining_criterias(i).child_criteria.flg_reassess;
                        ELSE
                            IF l_triage.defining_criterias(i).flg_critical_look = pk_alert_constant.g_no
                            THEN
                                l_triage.id_triage           := l_triage.defining_criterias(i).id_triage;
                                l_triage.flg_selected_option := l_triage.defining_criterias(i).discrim_answer;
                                l_triage.flg_reassess        := l_triage.defining_criterias(i).flg_reassess;
                            ELSE
                                l_critical_look := pk_alert_constant.g_yes;
                            END IF;
                        END IF;
                    ELSIF l_triage.defining_criterias(i).discrim_answer = g_no
                           AND l_triage.defining_criterias.count = 1
                    THEN
                        -- if it is a No answer and there is only 1
                        IF l_triage.defining_criterias(i).child_criteria.id_triage IS NOT NULL
                        THEN
                            -- if it receives a child, saves the child, if not, saves the parent
                            l_triage.id_triage           := l_triage.defining_criterias(i).child_criteria.id_triage;
                            l_triage.flg_selected_option := l_triage.defining_criterias(i).child_criteria.flg_accepted_option;
                            l_triage.flg_reassess        := l_triage.defining_criterias(i).child_criteria.flg_reassess;
                        ELSE
                            l_triage.id_triage           := l_triage.defining_criterias(i).id_triage;
                            l_triage.flg_selected_option := l_triage.defining_criterias(i).discrim_answer;
                            l_triage.flg_reassess        := l_triage.defining_criterias(i).flg_reassess;
                        END IF;
                    ELSE
                        -- the other possible situation is when there are several No answers, in this case these values should be null so nothing is saved in table epis_triage or epis_info
                        l_triage.id_triage           := NULL;
                        l_triage.flg_selected_option := NULL;
                        l_triage.flg_reassess        := NULL;
                    END IF;
                END LOOP;
                IF l_triage.id_triage_type = g_triage_id_ctas_p
                THEN
                    IF l_critical_look = pk_alert_constant.g_yes
                       AND l_triage.id_triage IS NULL
                    THEN
                        l_triage.flg_critical_look := pk_alert_constant.g_yes;
                    END IF;
                END IF;
            END IF;
        
            IF l_triage.id_triage_type = pk_edis_triage.g_triage_id_esi
               AND l_triage.id_triage IS NULL
               AND l_triage.group_options.exists(1)
            THEN
                l_rec_grp_option := l_triage.group_options(l_triage.group_options.count);
            
                IF l_rec_grp_option.options.exists(1)
                THEN
                    l_rec_option       := l_rec_grp_option.options(l_rec_grp_option.options.count);
                    l_rec_child_option := l_rec_option.child_option;
                
                    IF l_rec_child_option.flg_accepted_option = pk_alert_constant.g_yes
                    THEN
                        l_triage.id_triage           := l_rec_option.id_triage;
                        l_triage.flg_selected_option := l_rec_option.flg_selected_option;
                        l_triage.flg_reassess        := l_rec_option.flg_reassess;
                    END IF;
                END IF;
            END IF;
        
            g_error := 'GET COLOR INFO';
            BEGIN
                SELECT tc.*
                  INTO l_rec_color
                  FROM triage_color tc
                 WHERE tc.id_triage_color = l_triage.id_triage_color;
            
                l_triage.triage_color_color := l_rec_color.color;
                l_triage.triage_color_text  := l_rec_color.color_text;
                l_triage.triage_color_rank  := l_rec_color.rank;
            EXCEPTION
                WHEN no_data_found THEN
                    g_error := 'TRIAGE COLOR NOT FOUND';
                    pk_alertlog.log_debug(g_error);
                    RAISE l_exception;
            END;
        
            BEGIN
                g_error := 'CHECK EXISTING TRIAGES';
                pk_alertlog.log_debug(g_error);
                SELECT COUNT(*)
                  INTO l_triage.epis_triage_count
                  FROM epis_triage t
                 WHERE t.id_episode = l_triage.id_episode;
            EXCEPTION
                WHEN no_data_found THEN
                    l_triage.epis_triage_count := 0;
            END;
        
            g_error := 'CALL FILL_MISSING_NEEDS';
            pk_alertlog.log_debug(g_error);
            fill_missing_needs;
        END fill_missing_data;
    
        PROCEDURE validate_params IS
        BEGIN
            g_error := 'CHECK TRIAGE COLOR';
            pk_alertlog.log_debug(g_error);
            IF l_triage.id_triage_color IS NULL
               AND l_triage.id_triage_white_reason IS NULL
               AND l_triage.id_triage_board IS NULL
            THEN
                g_error := 'TRIAGE VALUES NOT FOUND';
                pk_alertlog.log_debug(g_error);
                RAISE l_exception;
            END IF;
        
            IF l_triage.dt_triage_end <= l_triage.dt_triage_begin
            THEN
                g_error := 'INVALID BEGIN OR END DATE';
                pk_alertlog.log_debug(g_error);
                RAISE l_exception;
            END IF;
        
            g_error := 'CHECK IF EPISODE IS ACTIVE';
            pk_alertlog.log_debug(g_error);
            BEGIN
                SELECT e.dt_begin_tstz
                  INTO l_triage.episode_dt_begin
                  FROM episode e
                 WHERE id_episode = l_triage.id_episode
                   AND flg_status = pk_alert_constant.g_epis_status_active;
            EXCEPTION
                WHEN no_data_found THEN
                    g_error := REPLACE(pk_message.get_message(i_lang, 'COMMON_M013'),
                                       '@1',
                                       pk_message.get_message(i_lang, 'EDIS_TRIAGE_M002'));
                    RAISE l_exception;
            END;
        
            IF (l_triage.id_triage IS NULL OR l_triage.flg_selected_option IS NULL)
               AND l_triage.group_options IS NULL
            THEN
                g_error := 'NO ID_TRIAGE RECEIVED';
                RAISE l_exception;
            END IF;
        
        END validate_params;
    
    BEGIN
        g_error := 'INITIALIZE L_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_triage := i_triage;
    
        g_error := 'CALL FILL_MISSING_DATA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        fill_missing_data;
    
        g_error := 'VALIDATE SAVE PARAMETERS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        validate_params;
    
        g_error := 'CALL CREATE_EPIS_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT create_epis_triage_internal(i_lang           => i_lang,
                                           i_prof           => i_prof,
                                           i_triage         => l_triage,
                                           o_epis_triage    => o_epis_triage,
                                           o_epis_anamnesis => o_epis_anamnesis,
                                           o_shortcut       => o_shortcut,
                                           o_error          => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            pk_alert_exceptions.process_error(i_lang,
                                              o_error.ora_sqlcode,
                                              o_error.ora_sqlerrm,
                                              o_error.err_desc,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_utils.undo_changes;
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END create_epis_triage;

    /*************************************************************************************
    * Returns the set of vital signs that show on the top of the board (EST Triage only)
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_episode                Episode ID
    * @param i_triage_board           Board (flowchart) ID
    * @param o_vital_sign             Vital sign data
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.2
    * @since                          23/11/2009
    ***************************************************************************************/
    FUNCTION get_triage_board_vital_signs
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_triage_board IN triage_board.id_triage_board%TYPE,
        i_id_triage_type  IN triage_type.id_triage_type%TYPE,
        o_vital_sign      OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name VARCHAR2(200) := 'GET_BOARD_VITAL_SIGNS';
        l_internal_error EXCEPTION;
        l_tab_vital_sign table_number;
    BEGIN
        g_error := 'CALL PK_EDIS_TRIAGE.TF_TRIAGE_VITAL_SIGNS';
        pk_alertlog.log_debug(g_error);
        l_tab_vital_sign := pk_edis_triage.tf_triage_vital_signs(i_lang           => i_lang,
                                                                 i_prof           => i_prof,
                                                                 i_id_episode     => i_id_episode,
                                                                 i_tbl_id_context => table_number(i_id_triage_board),
                                                                 i_flg_context    => pk_edis_triage.g_flg_context_id_triage_board,
                                                                 i_id_triage_type => i_id_triage_type);
    
        IF l_tab_vital_sign IS NOT NULL
           AND l_tab_vital_sign.count > 0
        THEN
            -- Return the data of the required vital signs, for all discriminators
            g_error := 'GET VITAL SIGN DATA';
            pk_alertlog.log_debug(g_error);
            IF NOT pk_vital_sign.get_vs_triage_header(i_lang            => i_lang,
                                                      i_prof            => i_prof,
                                                      i_tbl_vital_sign  => l_tab_vital_sign,
                                                      i_flg_view        => 'T',
                                                      i_relation_domain => get_vs_relation_domain(i_tab_vital_sign => l_tab_vital_sign),
                                                      i_patient         => pk_episode.get_id_patient(i_id_episode),
                                                      o_sign_v          => o_vital_sign,
                                                      o_error           => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_vital_sign);
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_triage_board_vital_signs;

    FUNCTION check_est_additional_attrib
    (
        i_triage_type         IN triage_type.id_triage_type%TYPE,
        i_vs_value            IN vital_sign_read.value%TYPE,
        i_vital_sign_desc     IN vital_sign_desc.id_vital_sign_desc%TYPE,
        i_vsd_value           IN vital_sign_desc.value%TYPE,
        i_pat_age             IN patient.age%TYPE,
        i_flg_pregnant        IN epis_triage.flg_pregnant%TYPE,
        i_pregnancy_weeks     IN epis_triage.preg_weeks%TYPE,
        i_flg_postpartum      IN epis_triage.flg_postpartum%TYPE,
        i_ttv_vs_min          IN triage_type_vs.val_min%TYPE,
        i_ttv_vs_max          IN triage_type_vs.val_max%TYPE,
        i_ttv_vs_desc_related IN triage_type_vs.id_vs_desc_related%TYPE,
        i_ttv_age_min         IN triage_type_vs.age_min%TYPE,
        i_ttv_age_max         IN triage_type_vs.age_max%TYPE,
        i_ttv_flg_pregnant    IN triage_type_vs.flg_pregnant%TYPE,
        i_ttv_min_preg_weeks  IN triage_type_vs.min_preg_weeks%TYPE,
        i_ttv_max_preg_weeks  IN triage_type_vs.max_preg_weeks%TYPE,
        i_ttv_flg_postpartum  IN triage_type_vs.flg_postpartum%TYPE
    ) RETURN VARCHAR2 IS
        l_ret VARCHAR2(1) := pk_alert_constant.g_no;
        --
        l_flg_pregnant   epis_triage.flg_pregnant%TYPE := nvl(i_flg_pregnant, pk_alert_constant.g_no);
        l_flg_postpartum epis_triage.flg_postpartum%TYPE := nvl(i_flg_postpartum, pk_alert_constant.g_no);
    BEGIN
        --In EST triage the vital sign gives the level of the triage.
        --In all the other triages the vital sign is present in a question (triage_discriminator) 
        --and tells if the answer to it is Yes or No
        IF i_triage_type NOT IN (pk_edis_triage.g_triage_id_est, g_triage_id_ctas_a, g_triage_id_ctas_p)
        THEN
            l_ret := pk_alert_constant.g_yes;
        ELSE
            --if is EST triage
            l_ret := pk_alert_constant.g_no;
        
            --VALIDATE VALUE
            IF i_vital_sign_desc IS NULL
            THEN
                IF (i_vs_value >= i_ttv_vs_min OR i_ttv_vs_min IS NULL OR i_vs_value IS NULL)
                   AND (i_vs_value <= i_ttv_vs_max OR i_ttv_vs_max IS NULL OR i_vs_value IS NULL)
                THEN
                    l_ret := pk_alert_constant.g_yes;
                ELSE
                    l_ret := pk_alert_constant.g_no;
                END IF;
            ELSE
                IF i_ttv_vs_desc_related IS NOT NULL
                THEN
                    IF i_vital_sign_desc = i_ttv_vs_desc_related
                    THEN
                        l_ret := pk_alert_constant.g_yes;
                    ELSE
                        l_ret := pk_alert_constant.g_no;
                    END IF;
                END IF;
            
                IF l_ret = pk_alert_constant.g_yes
                   AND (i_vsd_value >= i_ttv_vs_min OR i_ttv_vs_min IS NULL OR i_vsd_value IS NULL)
                   AND (i_vsd_value <= i_ttv_vs_max OR i_ttv_vs_max IS NULL OR i_vsd_value IS NULL)
                THEN
                    l_ret := pk_alert_constant.g_yes;
                ELSE
                    l_ret := pk_alert_constant.g_no;
                END IF;
            END IF;
        
            --VALIDATE AGE
            IF l_ret = pk_alert_constant.g_yes
               AND (i_pat_age >= i_ttv_age_min OR i_ttv_age_min IS NULL OR i_pat_age IS NULL)
               AND (i_pat_age <= i_ttv_age_max OR i_ttv_age_max IS NULL OR i_pat_age IS NULL)
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_no;
            END IF;
        
            --VALIDATE PREGNANCY
            IF l_ret = pk_alert_constant.g_yes
               AND l_flg_pregnant = i_ttv_flg_pregnant
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_no;
            END IF;
        
            --VALIDATE PREGNANCY WEEKS
            IF l_ret = pk_alert_constant.g_yes
               AND l_flg_pregnant = pk_alert_constant.g_no
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSIF l_ret = pk_alert_constant.g_yes
                  AND l_flg_pregnant = pk_alert_constant.g_yes
                  AND (i_pregnancy_weeks >= i_ttv_min_preg_weeks OR i_pregnancy_weeks IS NULL OR
                  i_ttv_min_preg_weeks IS NULL)
                  AND (i_pregnancy_weeks <= i_ttv_max_preg_weeks OR i_pregnancy_weeks IS NULL OR
                  i_ttv_max_preg_weeks IS NULL)
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_no;
            END IF;
        
            --VALIDATE POSTPARTUM
            IF l_ret = pk_alert_constant.g_yes
               AND l_flg_postpartum = i_ttv_flg_postpartum
            THEN
                l_ret := pk_alert_constant.g_yes;
            ELSE
                l_ret := pk_alert_constant.g_no;
            END IF;
        END IF;
    
        RETURN l_ret;
    END check_est_additional_attrib;

    /**************************************************************************
    * Returns the data about a given vital sign, considering the unit measure
    * in use by the institution.
    * Also returns the vital sign data related with the current discriminator.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_triage_type            Triage type id
    * @param i_pat_age                Patient age
    * @param i_check_type             This function only handles with type F, B and D. The origin of the validation is A
    *                                 validate if it's a type B or D before calling it and send this value instead of A 
    * @param i_rec_check_vs           Record with the information needed to get the correct configuration 
    * @param i_rec_preg               Record with the pregnancy data
    * @param io_rec_vs                Vital sign data
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6
    * @since                          28/12/2012
    **************************************************************************/
    FUNCTION get_vital_sign_data
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_triage_type  IN triage_type.id_triage_type%TYPE,
        i_pat_age      IN NUMBER,
        i_check_type   IN VARCHAR2,
        i_rec_check_vs IN pk_edis_types.rec_check_option,
        i_rec_preg     IN pk_edis_types.rec_pregnant,
        io_rec_vs      IN OUT pk_edis_types.rec_vital_sign,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(50) := 'GET_VITAL_SIGN_DATA';
        --
        l_id_market        market.id_market%TYPE;
        l_vs_has_limits    VARCHAR2(1 CHAR);
        l_has_child_record VARCHAR2(1 CHAR);
        l_vs_area_id_ctx   triage_vs_area.id_context%TYPE;
        --    
        l_config_error EXCEPTION;
    BEGIN
        g_error := 'GET MARKET ID';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_id_market := pk_edis_triage.get_market(i_lang => i_lang, i_prof => i_prof);
    
        g_error := 'CALL PK_EDIS_TRIAGE.GET_VS_AREA_ID_CXT';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_vs_area_id_ctx := pk_edis_triage.get_vs_area_id_cxt(i_flg_type             => i_check_type,
                                                              i_triage_board         => i_rec_check_vs.id_triage_board,
                                                              i_triage_discriminator => i_rec_check_vs.id_triage_discriminator);
    
        g_error := 'GET AREA VITAL SIGNS DATA (' || io_rec_vs.id_vital_sign || ', ' || io_rec_vs.id_unit_measure || ' ,' ||
                   l_vs_area_id_ctx || ', ' || io_rec_vs.is_to_ignore_result || ', ' || i_check_type || ', ' ||
                   l_id_market || ', ' || io_rec_vs.val_max || ', ' || io_rec_vs.vsd_value || ', ' || io_rec_vs.value || ', ' ||
                   io_rec_vs.vsd_value || ', ' || io_rec_vs.id_config_unit_mea || ', ' || io_rec_vs.val_min || ', ' ||
                   io_rec_vs.internal_name || ')';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF i_triage_type = pk_edis_triage.g_triage_id_est
           AND io_rec_vs.is_to_ignore_result = pk_alert_constant.g_yes
        THEN
            --ALERT-275364 - EST New requirement: The system must provide the ability to ignore the urgency level obtained by the index the choc whenever required
            io_rec_vs.id_triage_vs_area := NULL;
            io_rec_vs.id_triage_type_vs := NULL;
            io_rec_vs.vs_area_min_value := NULL;
            io_rec_vs.vs_area_max_value := NULL;
            io_rec_vs.has_child_record  := NULL;
            io_rec_vs.flg_mandatory     := NULL;
            io_rec_vs.flg_available     := NULL;
        ELSIF io_rec_vs.value IS NOT NULL
              OR io_rec_vs.id_vital_sign_desc IS NOT NULL
              OR i_triage_type <> pk_edis_triage.g_triage_id_est
        THEN
            BEGIN
                SELECT id_triage_vs_area,
                       id_triage_type_vs,
                       val_min,
                       val_max,
                       has_child_record,
                       flg_mandatory,
                       flg_available,
                       flg_has_limits
                  INTO io_rec_vs.id_triage_vs_area,
                       io_rec_vs.id_triage_type_vs,
                       io_rec_vs.vs_area_min_value,
                       io_rec_vs.vs_area_max_value,
                       l_has_child_record,
                       io_rec_vs.flg_mandatory,
                       io_rec_vs.flg_available,
                       l_vs_has_limits
                  FROM (SELECT tva.id_triage_vs_area,
                                tva.id_triage_type_vs,
                                -- Convert values if the institution uses a different unit measure than the specified
                                -- for the min/max values of the discriminator.
                                decode(io_rec_vs.id_unit_measure,
                                        -- a) Vital sign doesn't have unit measure (U.M.). Use the specified value in triage, or maximum value.
                                      NULL,
                                      nvl(ttv.val_min, io_rec_vs.val_min),
                                      -- b) U.M. in triage is the same as the configured U.M., or isn't specified.
                                        nvl(ttv.id_unit_measure, io_rec_vs.id_config_unit_mea),
                                        nvl(ttv.val_min, io_rec_vs.val_min),
                                        -- c) U.M. in triage is different from the configured U.M.
                                        decode(ttv.val_min,
                                                -- c.1) Triage doesn't specify a limit. No need for conversion.
                                             NULL,
                                             io_rec_vs.val_min,
                                             -- c.2) Triage specifies limit. Conversion required, from the specified U.M. in the triage, to the configured U.M.
                                             pk_vital_sign.get_unit_mea_conversion(ttv.val_min,
                                                                                   ttv.id_vital_sign,
                                                                                   ttv.id_unit_measure,
                                                                                   io_rec_vs.id_unit_measure))) val_min,
                               decode(io_rec_vs.id_unit_measure,
                                      NULL,
                                      nvl(ttv.val_max, io_rec_vs.val_max),
                                      nvl(ttv.id_unit_measure, io_rec_vs.id_config_unit_mea),
                                      nvl(ttv.val_max, io_rec_vs.val_max),
                                      decode(ttv.val_max,
                                             NULL,
                                             io_rec_vs.val_max,
                                             pk_vital_sign.get_unit_mea_conversion(ttv.val_max,
                                                                                   ttv.id_vital_sign,
                                                                                   ttv.id_unit_measure,
                                                                                   io_rec_vs.id_unit_measure))) val_max,
                               decode((SELECT COUNT(*)
                                        FROM triage_type_vs ttv1
                                        JOIN triage_vs_area tva1
                                          ON ttv1.id_triage_type_vs = tva1.id_triage_type_vs
                                       WHERE ttv1.flg_available = pk_alert_constant.g_yes
                                         AND ttv1.id_vital_sign = ttv.id_vital_sign
                                         AND ttv1.id_parent = ttv.id_triage_type_vs
                                         AND tva1.id_market = tva.id_market),
                                      0,
                                      pk_alert_constant.g_no,
                                      pk_alert_constant.g_yes) has_child_record,
                               nvl(tva.flg_mandatory, pk_alert_constant.g_yes) flg_mandatory, -- por omissão é obrigatório
                               ttv.flg_available,
                               decode(ttv.val_max,
                                      NULL,
                                      decode(ttv.val_min, NULL, pk_alert_constant.g_no, pk_alert_constant.g_yes),
                                      pk_alert_constant.g_yes) flg_has_limits,
                               row_number() over(ORDER BY age_min ASC) line_number
                          FROM triage_type_vs ttv
                          JOIN triage_vs_area tva
                            ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                         WHERE ttv.id_vital_sign = io_rec_vs.id_vital_sign
                           AND nvl(tva.id_context, pk_edis_triage.g_null_value) = l_vs_area_id_ctx
                           AND tva.flg_context = i_check_type
                           AND ttv.flg_available = pk_alert_constant.g_yes
                           AND ttv.id_triage_type = i_triage_type
                           AND ttv.id_parent IS NULL --
                              -- Validate limits per market
                           AND (tva.id_market = l_id_market OR tva.id_market = 0 AND NOT EXISTS
                                (SELECT 0
                                   FROM triage_type_vs ttv1
                                   JOIN triage_vs_area tva1
                                     ON ttv1.id_triage_type_vs = tva1.id_triage_type_vs
                                  WHERE ttv1.flg_available = pk_alert_constant.g_yes
                                    AND ttv1.id_vital_sign = ttv.id_vital_sign
                                    AND nvl(tva.id_context, pk_edis_triage.g_null_value) = l_vs_area_id_ctx
                                    AND tva.flg_context = i_check_type
                                    AND ttv1.id_parent IS NULL
                                    AND tva1.id_market = l_id_market))
                              --In EST triage the vital sign gives the level of the triagem.
                              --In all the other triages, the vital sign is present in a question (triage_discriminator) 
                              --and tells if the answer to it is Yes or No
                           AND ((io_rec_vs.internal_name = pk_edis_triage.g_vs_peak_flow_expected AND
                               io_rec_vs.peak_flow_percentage IS NOT NULL) OR
                               io_rec_vs.internal_name != pk_edis_triage.g_vs_peak_flow_expected)
                           AND pk_edis_triage.check_est_additional_attrib(i_triage_type => i_triage_type,
                                                                          --START - Peak-flow logic
                                                                          i_vs_value => CASE io_rec_vs.internal_name
                                                                                            WHEN
                                                                                             pk_edis_triage.g_vs_peak_flow_expected THEN
                                                                                             io_rec_vs.peak_flow_percentage
                                                                                            ELSE
                                                                                             io_rec_vs.value
                                                                                        END,
                                                                          --END   - Peak-flow logic                                                                                           
                                                                          i_vital_sign_desc     => io_rec_vs.id_vital_sign_desc,
                                                                          i_vsd_value           => io_rec_vs.vsd_value,
                                                                          i_pat_age             => i_pat_age,
                                                                          i_flg_pregnant        => i_rec_preg.flg_pregnant,
                                                                          i_pregnancy_weeks     => i_rec_preg.pregnancy_weeks,
                                                                          i_flg_postpartum      => i_rec_preg.flg_postpartum,
                                                                          i_ttv_vs_min          => ttv.val_min,
                                                                          i_ttv_vs_max          => ttv.val_max,
                                                                          i_ttv_vs_desc_related => ttv.id_vs_desc_related,
                                                                          i_ttv_age_min         => ttv.age_min,
                                                                          i_ttv_age_max         => ttv.age_max,
                                                                          i_ttv_flg_pregnant    => ttv.flg_pregnant,
                                                                          i_ttv_min_preg_weeks  => ttv.min_preg_weeks,
                                                                          i_ttv_max_preg_weeks  => ttv.max_preg_weeks,
                                                                          i_ttv_flg_postpartum  => ttv.flg_postpartum) =
                               pk_alert_constant.g_yes)
                 WHERE line_number = 1;
            EXCEPTION
                WHEN no_data_found THEN
                    io_rec_vs.id_triage_vs_area := NULL;
                    io_rec_vs.id_triage_type_vs := NULL;
                    io_rec_vs.vs_area_min_value := NULL;
                    io_rec_vs.vs_area_max_value := NULL;
                    io_rec_vs.has_child_record  := NULL;
                    io_rec_vs.flg_mandatory     := NULL;
                    io_rec_vs.flg_available     := NULL;
            END;
        END IF;
    
        io_rec_vs.has_child_record := (l_has_child_record = pk_alert_constant.g_yes);
        io_rec_vs.has_limits       := (l_vs_has_limits = pk_alert_constant.g_yes);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN l_config_error THEN
            pk_alert_exceptions.process_error(i_lang,
                                              'CONFIG ERROR',
                                              'INVALID VITAL SIGN CONFIGURATION',
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END get_vital_sign_data;

    /**************************************************************************
    * Validates the registered value for a vital sign, checking if it is within
    * the limits of the child records for the current discriminator.
    * BASED ON: validate_discrim_child
    *
    * @param i_lang                    Language ID
    * @param i_prof                    Professional info
    * @param i_pat_age                 Patient age
    * @param i_triage_acronym          Acronym of the current triage type
    * @param i_cur_vs                  Current vs record
    * @param i_tbl_vital_signs         Table with all vital signs
    * @param io_values_within_range    Check if registered value is within the discriminator limits: (Y) Yes (N) No
    * @param o_id_triage_vs_area       Record of TRIAGE_VS_AREA which validates if vital sign is within range
    * @param o_error                   Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Alexandre Santos
    * @version                        2.6
    * @since                          28/12/2012
    **************************************************************************/
    FUNCTION check_vs_child
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_pat_age              IN NUMBER,
        i_triage_acronym       IN triage_type.acronym%TYPE,
        i_cur_vs               IN pk_edis_types.rec_vital_sign,
        i_tbl_vital_signs      IN pk_edis_types.table_vital_signs,
        io_values_within_range IN OUT VARCHAR2,
        o_id_triage_vs_area    OUT triage_vs_area.id_triage_vs_area%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(50) := 'CHECK_VS_CHILD';
    
        l_id_triage_vs_area triage_vs_area.id_triage_vs_area%TYPE;
    
        l_tab_tva                    table_number;
        l_id_vital_sign_related      table_number;
        l_id_vital_sign_desc_related table_number;
        l_flg_validate_limits        table_varchar;
    
        l_id_market market.id_market%TYPE;
    
        l_total_count NUMBER(6) := 0;
        l_count       NUMBER(6) := 0;
    BEGIN
        g_error := 'GET MARKET ID';
        pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        l_id_market := pk_edis_triage.get_market(i_lang => i_lang, i_prof => i_prof);
    
        -- Check if the registered value fits in any of the child records.
        BEGIN
            g_error := 'GET DISCRIM CHILD DATA (' || i_cur_vs.id_vital_sign || ')';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            SELECT t.id_triage_vs_area, t.id_vital_sign_related, t.id_vs_desc_related, flg_validate_limits
              BULK COLLECT
              INTO l_tab_tva, l_id_vital_sign_related, l_id_vital_sign_desc_related, l_flg_validate_limits
              FROM (SELECT tva.id_triage_vs_area,
                           ttv.id_vital_sign_related,
                           ttv.id_vs_desc_related,
                           -- VICENZA triage: if the patient doesn't have a registered age, don't validade any limits
                           decode(ttv.age_max, -1, pk_alert_constant.g_no, pk_alert_constant.g_yes) flg_validate_limits,
                           decode(i_cur_vs.id_unit_measure,
                                  NULL,
                                  nvl(ttv.val_min, i_cur_vs.val_min),
                                  nvl(ttv.id_unit_measure, i_cur_vs.id_config_unit_mea),
                                  nvl(ttv.val_min, i_cur_vs.val_min),
                                  decode(ttv.val_min,
                                         NULL,
                                         i_cur_vs.val_min,
                                         pk_vital_sign.get_unit_mea_conversion(ttv.val_min,
                                                                               ttv.id_vital_sign,
                                                                               ttv.id_unit_measure,
                                                                               i_cur_vs.id_unit_measure))) val_min,
                           decode(i_cur_vs.id_unit_measure,
                                  NULL,
                                  nvl(ttv.val_max, i_cur_vs.val_max),
                                  nvl(ttv.id_unit_measure, i_cur_vs.id_config_unit_mea),
                                  nvl(ttv.val_max, i_cur_vs.val_max),
                                  decode(ttv.val_max,
                                         NULL,
                                         i_cur_vs.val_max,
                                         pk_vital_sign.get_unit_mea_conversion(ttv.val_max,
                                                                               ttv.id_vital_sign,
                                                                               ttv.id_unit_measure,
                                                                               i_cur_vs.id_unit_measure))) val_max
                      FROM triage_type_vs ttv
                      JOIN triage_vs_area tva
                        ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                     WHERE ttv.id_vital_sign = i_cur_vs.id_vital_sign
                       AND ttv.id_parent = i_cur_vs.id_triage_type_vs
                       AND (i_pat_age >= ttv.age_min OR ttv.age_min IS NULL OR i_pat_age IS NULL)
                       AND (i_pat_age <= ttv.age_max OR ttv.age_max IS NULL OR i_pat_age IS NULL)
                       AND tva.id_market IN (l_id_market, 0)
                     ORDER BY tva.rank) t
             WHERE i_cur_vs.value BETWEEN t.val_min AND t.val_max
                OR flg_validate_limits = pk_alert_constant.g_no;
        
        EXCEPTION
            WHEN no_data_found THEN
                l_tab_tva                    := NULL;
                l_id_vital_sign_related      := NULL;
                l_id_vital_sign_desc_related := NULL;
                l_flg_validate_limits        := NULL;
        END;
    
        IF l_tab_tva.exists(1)
        THEN
            IF l_flg_validate_limits(1) = pk_alert_constant.g_no
            THEN
                NULL;
            ELSIF l_id_vital_sign_related(1) IS NULL
                  AND l_id_vital_sign_desc_related(1) IS NULL
            THEN
                -- In this case there's no dependencies between vital signs, so all we need to check is
                -- if there are any intervals for which the discriminator is accepted, and return the 
                -- corresponding ID_TRIAGE_TYPE_VS (if more than one record is found, returns always the first).
                g_error := 'CHECK VITAL SIGNS (1)';
                pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                IF l_tab_tva.count > 0
                THEN
                    o_id_triage_vs_area    := nvl(o_id_triage_vs_area, l_tab_tva(1));
                    io_values_within_range := pk_alert_constant.g_yes;
                END IF;
            
            ELSIF l_id_vital_sign_related(1) IS NOT NULL
                  AND l_id_vital_sign_desc_related(1) IS NOT NULL
            THEN
                l_total_count := 0; -- Reset variable. Controls if have been found child records that accept the discriminator.
            
                -- Loop through the related values of the child records. Check if the registered value
                -- of the related vital sign is accepted along with the current value of the current vital sign.
                g_error := 'LOOP CHILD RELATED VITAL SIGNS (' || i_cur_vs.id_vital_sign || ')';
                pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                FOR k IN l_id_vital_sign_desc_related.first .. l_id_vital_sign_desc_related.last
                LOOP
                    -- Find related vital sign, and registered value
                    g_error := 'LOOP CHILD RELATED VITAL SIGNS (' || i_cur_vs.id_vital_sign || ')';
                    pk_alertlog.log_debug(g_error);
                    IF i_tbl_vital_signs IS NOT NULL
                       AND i_tbl_vital_signs.count > 0
                    THEN
                        FOR x IN i_tbl_vital_signs.first .. i_tbl_vital_signs.last
                        LOOP
                            IF i_tbl_vital_signs(x)
                             .id_vital_sign = l_id_vital_sign_related(k)
                                AND i_tbl_vital_signs(x).id_vital_sign_desc = l_id_vital_sign_desc_related(k)
                            THEN
                                l_count := l_count + 1;
                            END IF;
                        END LOOP;
                    ELSE
                        l_count := 0;
                    END IF;
                
                    l_id_triage_vs_area := CASE l_count
                                               WHEN 0 THEN
                                                NULL
                                               ELSE
                                                nvl(o_id_triage_vs_area, l_tab_tva(k))
                                           END;
                
                    l_total_count := l_total_count + l_count;
                END LOOP;
            
                IF l_total_count > 0
                THEN
                    -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
                    IF i_triage_acronym IN (pk_edis_triage.g_vic)
                    THEN
                        io_values_within_range := NULL;
                    END IF;
                
                    -- Accept discriminator, or keep the previous value if it was already assigned (which can be "No").
                    io_values_within_range := nvl(io_values_within_range, pk_alert_constant.g_yes);
                    o_id_triage_vs_area    := nvl(o_id_triage_vs_area, l_id_triage_vs_area);
                ELSE
                    -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
                    IF io_values_within_range = pk_alert_constant.g_yes
                       AND i_triage_acronym IN (pk_edis_triage.g_vic)
                    THEN
                        NULL;
                    ELSE
                        -- Values not within range. Discriminator not accepted.
                        io_values_within_range := pk_alert_constant.g_no;
                    END IF;
                END IF;
            END IF;
        
        ELSE
            -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
            IF io_values_within_range = pk_alert_constant.g_yes
               AND i_triage_acronym IN (pk_edis_triage.g_vic)
            THEN
                NULL;
            ELSE
                -- Values not within range. Discriminator not accepted.
                io_values_within_range := pk_alert_constant.g_no;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            RETURN FALSE;
    END check_vs_child;

    FUNCTION get_vs_urgency_level(i_vital_sign IN pk_edis_types.rec_vital_sign) RETURN pk_edis_types.rec_vs_result IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_VS_URGENCY_LEVEL';
        --
        l_rec_vs_urg_level pk_edis_types.rec_vs_result;
    BEGIN
        IF i_vital_sign.id_triage_type_vs IS NOT NULL
        THEN
            g_error := 'GET URG LEVEL FOR ID_TRIAGE_TYPE_VS: ' || i_vital_sign.id_triage_type_vs || '; ID_VITAL_SIGN: ' ||
                       i_vital_sign.id_vital_sign;
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            BEGIN
                SELECT ttv.id_vital_sign, tel.esi_level
                  INTO l_rec_vs_urg_level.id_vital_sign, l_rec_vs_urg_level.urgency_level
                  FROM triage_type_vs ttv
                  JOIN triage_esi_level tel
                    ON tel.id_triage_color = ttv.id_triage_color
                 WHERE ttv.id_triage_type_vs = i_vital_sign.id_triage_type_vs;
            EXCEPTION
                WHEN no_data_found THEN
                    l_rec_vs_urg_level.id_vital_sign        := i_vital_sign.id_vital_sign;
                    l_rec_vs_urg_level.id_vital_sign_parent := i_vital_sign.id_vital_sign_parent;
                    l_rec_vs_urg_level.urgency_level        := NULL;
            END;
        ELSE
            l_rec_vs_urg_level.id_vital_sign        := i_vital_sign.id_vital_sign;
            l_rec_vs_urg_level.id_vital_sign_parent := i_vital_sign.id_vital_sign_parent;
            l_rec_vs_urg_level.urgency_level        := NULL;
        END IF;
    
        IF l_rec_vs_urg_level.urgency_level IS NOT NULL
           AND i_vital_sign.id_vital_sign_parent IS NOT NULL
        THEN
            l_rec_vs_urg_level.id_vital_sign        := i_vital_sign.id_vital_sign_parent;
            l_rec_vs_urg_level.id_vital_sign_parent := NULL;
        END IF;
    
        RETURN l_rec_vs_urg_level;
    END get_vs_urgency_level;

    PROCEDURE remove_dup_urg_level_vs(io_tbl_vital_signs IN OUT pk_edis_types.table_vs_results) IS
        l_lower_level CONSTANT PLS_INTEGER := 10000;
        --
        l_aux_table pk_edis_types.table_vs_results;
        l_found     BOOLEAN;
    BEGIN
        IF io_tbl_vital_signs IS NOT NULL
           AND io_tbl_vital_signs.count > 0
        THEN
            l_aux_table := pk_edis_types.table_vs_results();
        
            FOR i IN io_tbl_vital_signs.first .. io_tbl_vital_signs.last
            LOOP
                IF l_aux_table.count = 0
                THEN
                    l_found := FALSE;
                ELSE
                    l_found := FALSE;
                
                    FOR j IN l_aux_table.first .. l_aux_table.last
                    LOOP
                        IF io_tbl_vital_signs(i).id_vital_sign = l_aux_table(j).id_vital_sign
                        THEN
                            IF nvl(io_tbl_vital_signs(i).urgency_level, l_lower_level) <=
                               nvl(l_aux_table(j).urgency_level, l_lower_level)
                            THEN
                                l_aux_table(j).urgency_level := io_tbl_vital_signs(i).urgency_level;
                            END IF;
                        
                            l_found := TRUE;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                IF NOT l_found
                THEN
                    l_aux_table.extend;
                    l_aux_table(l_aux_table.count) := io_tbl_vital_signs(i);
                END IF;
            END LOOP;
        
            io_tbl_vital_signs := l_aux_table;
        END IF;
    END remove_dup_urg_level_vs;

    FUNCTION get_higher_vs_urg_level(i_tbl_vital_signs IN pk_edis_types.table_vital_signs)
        RETURN triage_esi_level.esi_level%TYPE IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_HIGHER_VS_URG_LEVEL';
        --
        l_lower_level CONSTANT PLS_INTEGER := 10000;
        --
        l_rec_higher_vs_urg_level pk_edis_types.rec_vital_sign;
    BEGIN
        IF i_tbl_vital_signs IS NOT NULL
           AND i_tbl_vital_signs.count > 0
        THEN
            g_error := 'LOOP THROUGH TABLE OF URGENCY LEVEL VS';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            FOR i IN i_tbl_vital_signs.first .. i_tbl_vital_signs.last
            LOOP
                IF i_tbl_vital_signs(i).urgency_level < nvl(l_rec_higher_vs_urg_level.urgency_level, l_lower_level)
                THEN
                    l_rec_higher_vs_urg_level := i_tbl_vital_signs(i);
                END IF;
            END LOOP;
        END IF;
    
        RETURN l_rec_higher_vs_urg_level.urgency_level;
    END get_higher_vs_urg_level;

    -- calculates the label displayed in the header (created due to proposé/imposé distinction)
    FUNCTION get_urgency_level_desc
    (
        i_lang          IN language.id_language%TYPE,
        i_urgency_level IN triage_esi_level.esi_level%TYPE,
        i_triage_type   IN triage.id_triage_type%TYPE
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_URGENCY_LEVEL_DESC';
        l_code_message sys_message.code_message%TYPE;
        l_ret          sys_message.desc_message%TYPE;
    BEGIN
        IF i_urgency_level IS NOT NULL
        THEN
            IF i_urgency_level = 1
            THEN
                IF i_triage_type IN (g_triage_id_ctas_p, g_triage_id_ctas_a, g_triage_id_sa)
                THEN
                    l_code_message := 'TRIAGE_CTAS_M001';
                ELSE
                    l_code_message := 'TRIAGE_EST_M003';
                END IF;
            ELSE
                IF i_triage_type IN (g_triage_id_ctas_p, g_triage_id_ctas_a, g_triage_id_sa)
                THEN
                    l_code_message := 'TRIAGE_CTAS_M002';
                ELSE
                    l_code_message := 'TRIAGE_EST_M010';
                END IF;
            END IF;
        
            l_ret := REPLACE(pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_message),
                             '@1',
                             CASE i_urgency_level
                                 WHEN g_est_min_vs_level THEN
                                  pk_message.get_message(i_lang => i_lang, i_code_mess => g_code_msg_level_3_and_4)
                                 ELSE
                                  to_char(i_urgency_level)
                             END);
        END IF;
    
        RETURN l_ret;
    END get_urgency_level_desc;

    PROCEDURE fill_vs_extra_info
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_rec_vital_sign  IN pk_edis_types.rec_vital_sign,
        io_tbl_vs_results IN OUT pk_edis_types.table_vs_results
    ) IS
        l_code_msg_peak_flow CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M016'; --@1 de la valeur prédite
        --
        l_decimal_symbol sys_config.value%TYPE;
    BEGIN
        l_decimal_symbol := pk_sysconfig.get_config(g_cfg_decimal_symbol, i_prof);
    
        IF io_tbl_vs_results.count = 0
        THEN
            io_tbl_vs_results.extend;
            io_tbl_vs_results(io_tbl_vs_results.count).id_vital_sign := i_rec_vital_sign.id_vital_sign;
            io_tbl_vs_results(io_tbl_vs_results.count).id_vital_sign_parent := i_rec_vital_sign.id_vital_sign_parent;
        END IF;
    
        io_tbl_vs_results(io_tbl_vs_results.count).internal_name := i_rec_vital_sign.internal_name;
        io_tbl_vs_results(io_tbl_vs_results.count).rank := i_rec_vital_sign.rank;
    
        --START - Peak-flow logic
        IF i_rec_vital_sign.internal_name = pk_edis_triage.g_vs_peak_flow_expected
           AND i_rec_vital_sign.peak_flow_percentage IS NOT NULL
        THEN
            io_tbl_vs_results(io_tbl_vs_results.count).message := REPLACE(pk_message.get_message(i_lang      => i_lang,
                                                                                                 i_code_mess => l_code_msg_peak_flow),
                                                                          '@1',
                                                                          pk_utils.to_str(i_number         => round(i_rec_vital_sign.peak_flow_percentage * 100,
                                                                                                                    1),
                                                                                          i_decimal_symbol => l_decimal_symbol) || '%');
        END IF;
        --END   - Peak-flow logic
    
        io_tbl_vs_results(io_tbl_vs_results.count).value := nvl(i_rec_vital_sign.id_vital_sign_desc,
                                                                i_rec_vital_sign.value);
    
        IF i_rec_vital_sign.value IS NOT NULL
        THEN
            io_tbl_vs_results(io_tbl_vs_results.count).desc_value := pk_utils.to_str(i_number         => i_rec_vital_sign.value,
                                                                                     i_decimal_symbol => l_decimal_symbol);
        
            IF i_rec_vital_sign.desc_unit_measure IS NOT NULL
            THEN
                io_tbl_vs_results(io_tbl_vs_results.count).desc_value := io_tbl_vs_results(io_tbl_vs_results.count).desc_value || ' ' ||
                                                                          i_rec_vital_sign.desc_unit_measure;
            END IF;
        ELSIF i_rec_vital_sign.id_vital_sign_desc IS NOT NULL
        THEN
            io_tbl_vs_results(io_tbl_vs_results.count).desc_value := i_rec_vital_sign.desc_value;
        END IF;
    
        IF io_tbl_vs_results(io_tbl_vs_results.count).message IS NOT NULL
        THEN
            IF io_tbl_vs_results(io_tbl_vs_results.count).desc_value IS NOT NULL
            THEN
                io_tbl_vs_results(io_tbl_vs_results.count).desc_value := io_tbl_vs_results(io_tbl_vs_results.count).desc_value || ' ';
            END IF;
        
            io_tbl_vs_results(io_tbl_vs_results.count).desc_value := io_tbl_vs_results(io_tbl_vs_results.count).desc_value || '(' || io_tbl_vs_results(io_tbl_vs_results.count).message || ')';
        END IF;
    END fill_vs_extra_info;

    FUNCTION check_vital_signs
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_rec_triage IN pk_edis_types.rec_triage,
        o_result     OUT pk_edis_types.rec_chk_result,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_VITAL_SIGNS';
        --
        l_check_vs     pk_edis_types.rec_check_vital_signs;
        l_check_option pk_edis_types.rec_check_option;
        l_check_type   VARCHAR2(1);
        --
        l_tbl_ctx_vital_sign pk_edis_types.table_vital_signs;
        l_rec_ctx_vital_sign pk_edis_types.rec_vital_sign;
        --
        l_tbl_vs_results pk_edis_types.table_vs_results := pk_edis_types.table_vs_results();
        --
        l_dummy CONSTANT VARCHAR2(10) := 'DUMMY';
        --
        l_curr_result pk_edis_types.rec_chk_result;
        --VALIDATE_VS vars
        l_rec_vs_val pk_edis_types.rec_validate_vs;
        --VALIDATE_DISCRIMINATOR_ALL vars
        l_exists_message BOOLEAN := FALSE;
        --
        --
        l_exception EXCEPTION;
        --
        FUNCTION get_context_vs
        (
            i_check_option IN pk_edis_types.rec_check_option,
            i_check_type   IN VARCHAR2
        ) RETURN pk_edis_types.table_vital_signs IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_CONTEXT_VS';
            --
            l_tbl_ctx_vs pk_edis_types.table_vital_signs := pk_edis_types.table_vital_signs();
            l_tbl_vs     table_number;
            --
            l_tbl_all_vs     pk_edis_types.table_vital_signs;
            l_rec_vital_sign pk_edis_types.rec_vital_sign;
            --
            l_vs_area_id_ctx triage_vs_area.id_context%TYPE;
            --
            l_count PLS_INTEGER;
        BEGIN
            g_error := 'CALL PK_EDIS_TRIAGE.GET_VS_AREA_ID_CXT';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_vs_area_id_ctx := pk_edis_triage.get_vs_area_id_cxt(i_flg_type             => i_check_type,
                                                                  i_triage_board         => i_check_option.id_triage_board,
                                                                  i_triage_discriminator => i_check_option.id_triage_discriminator);
        
            g_error := 'GET ALL CONTEXT VS ID''s';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_inner_func_name, text => g_error);
            SELECT DISTINCT ttv.id_vital_sign
              BULK COLLECT
              INTO l_tbl_vs
              FROM triage_type_vs ttv
              JOIN triage_vs_area tva
                ON tva.id_triage_type_vs = ttv.id_triage_type_vs
             WHERE ttv.flg_available = pk_alert_constant.g_yes
               AND nvl(tva.id_context, pk_edis_triage.g_null_value) = l_vs_area_id_ctx
               AND tva.flg_context = i_check_type;
        
            l_tbl_all_vs := i_rec_triage.vital_signs;
        
            g_error := 'LOOP THROUGH ALL VS AND FILL THE CTX VS TABLE';
            pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_inner_func_name, text => g_error);
            FOR i IN l_tbl_all_vs.first .. l_tbl_all_vs.last
            LOOP
                l_rec_vital_sign := l_tbl_all_vs(i);
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM TABLE(l_tbl_vs)
                 WHERE column_value = l_rec_vital_sign.id_vital_sign;
            
                IF l_count > 0
                THEN
                    l_tbl_ctx_vs.extend;
                    l_tbl_ctx_vs(l_tbl_ctx_vs.count) := l_rec_vital_sign;
                END IF;
            END LOOP;
        
            RETURN l_tbl_ctx_vs;
        END get_context_vs;
        --
        --This function is based on function pk_edis_triage.get_pain_conversion
        FUNCTION get_vs_value(i_rec_vital_sign IN pk_edis_types.rec_vital_sign) RETURN vital_sign_read.value%TYPE IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'GET_VS_VALUE';
            --SCALES
            l_pain_scale        CONSTANT vital_sign_scales_element.id_vital_sign_scales%TYPE := 2;
            l_faces_scale       CONSTANT vital_sign_scales_element.id_vital_sign_scales%TYPE := 1;
            l_triage_pain_scale CONSTANT vital_sign_scales_element.id_vital_sign_scales%TYPE := 3;
            l_triage_face_scale CONSTANT vital_sign_scales_element.id_vital_sign_scales%TYPE := 4;
            --
            l_id_scale vital_sign_scales_element.id_vs_scales_element%TYPE;
            --
            l_ret vital_sign_read.value%TYPE;
        BEGIN
            IF i_rec_vital_sign.internal_name = g_vs_pain
               AND i_rec_vital_sign.id_scales_element IS NOT NULL
            THEN
                BEGIN
                    g_error := 'GET ID_VITAL_SIGN_SCALES OF ID_SCALES_ELEMENT = ' || i_rec_vital_sign.id_scales_element;
                    pk_alertlog.log_error(object_name     => g_package_name,
                                          sub_object_name => l_inner_func_name,
                                          text            => g_error);
                    SELECT vsse.id_vital_sign_scales
                      INTO l_id_scale
                      FROM vital_sign_scales_element vsse
                     WHERE vsse.id_vs_scales_element = i_rec_vital_sign.id_scales_element;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_id_scale := NULL;
                END;
            
                CASE l_id_scale
                    WHEN l_pain_scale THEN
                        l_ret := i_rec_vital_sign.value;
                    WHEN l_faces_scale THEN
                        l_ret := i_rec_vital_sign.value * 2;
                    WHEN l_triage_face_scale THEN
                        l_ret := i_rec_vital_sign.value * 2;
                    WHEN l_triage_pain_scale THEN
                        l_ret := i_rec_vital_sign.value;
                    ELSE
                        l_ret := i_rec_vital_sign.value;
                END CASE;
            ELSE
                l_ret := nvl(i_rec_vital_sign.value, i_rec_vital_sign.id_vital_sign_desc);
            END IF;
        
            -- multichoice values that must be validated using the range values
            IF i_rec_vital_sign.flg_fill_type = 'V'
               AND i_rec_vital_sign.internal_name NOT IN (g_vs_pulse_rythm, g_vs_glasgow, g_vs_rythm_pulse)
               AND l_ret IS NOT NULL
            THEN
                l_ret := i_rec_vital_sign.vsd_value;
            END IF;
        
            RETURN l_ret;
        END get_vs_value;
    
        PROCEDURE init_validate_vs_vars(io_vs_val IN OUT pk_edis_types.rec_validate_vs) IS
        BEGIN
            io_vs_val.vs_value               := NULL;
            io_vs_val.only_optional_vs       := NULL;
            io_vs_val.missing_vs_exclusive   := NULL;
            io_vs_val.finish_esi_validation  := FALSE;
            io_vs_val.values_within_range    := NULL;
            io_vs_val.id_triage_vs_area      := NULL;
            io_vs_val.msg_text_range_yes     := NULL;
            io_vs_val.msg_text_range_no      := NULL;
            io_vs_val.vsd_value              := NULL;
            io_vs_val.checked_blood_pressure := FALSE;
            io_vs_val.missing_vs_mandatory   := FALSE;
            io_vs_val.msg_text_y             := NULL;
            io_vs_val.msg_text_x             := NULL;
            io_vs_val.mandatory_no_limits    := FALSE;
        END init_validate_vs_vars;
    
        PROCEDURE validate_vs(io_vs_val IN OUT pk_edis_types.rec_validate_vs) IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'VALIDATE_VS';
        BEGIN
            g_error := 'CALL GET_VS_VALUE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_proc_name, text => g_error);
            io_vs_val.vs_value := get_vs_value(i_rec_vital_sign => l_rec_ctx_vital_sign);
        
            -- Confirm that exists mandatory or exclusive vital signs to check.
            IF (l_rec_ctx_vital_sign.flg_mandatory <> pk_alert_constant.g_no OR
               (l_rec_ctx_vital_sign.has_limits AND io_vs_val.vs_value IS NOT NULL))
               AND i_rec_triage.triage_type_acronym != 'ESI'
               AND NOT l_rec_ctx_vital_sign.has_child_record
            THEN
                io_vs_val.only_optional_vs := FALSE;
            END IF;
        
            IF l_rec_ctx_vital_sign.flg_mandatory = 'X'
               AND i_rec_triage.triage_type_acronym != 'ESI'
               AND io_vs_val.vs_value IS NOT NULL
            THEN
                -- Check if at least one "exclusive" vital sign has been filled.
                io_vs_val.missing_vs_exclusive := FALSE;
            END IF;
        
            IF l_rec_ctx_vital_sign.has_child_record
               AND io_vs_val.vs_value IS NOT NULL
            THEN
                -- Validate child record, when exists.
                IF (NOT io_vs_val.finish_esi_validation AND i_rec_triage.triage_type_acronym = 'ESI')
                   OR i_rec_triage.triage_type_acronym <> 'ESI'
                THEN
                    g_error := 'CALL CHECK_VS_CHILD';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    IF NOT check_vs_child(i_lang                 => i_lang,
                                          i_prof                 => i_prof,
                                          i_pat_age              => i_rec_triage.patient_age,
                                          i_triage_acronym       => i_rec_triage.triage_type_acronym,
                                          i_cur_vs               => l_rec_ctx_vital_sign,
                                          i_tbl_vital_signs      => i_rec_triage.vital_signs,
                                          io_values_within_range => io_vs_val.values_within_range,
                                          o_id_triage_vs_area    => io_vs_val.id_triage_vs_area,
                                          o_error                => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                END IF;
            
                IF i_rec_triage.triage_type_acronym = 'ESI'
                   AND io_vs_val.id_triage_vs_area IS NOT NULL
                THEN
                    -- In ESI triage, after finding the first value in range , there's no need to continue validation.
                    io_vs_val.values_within_range   := pk_alert_constant.g_yes;
                    io_vs_val.finish_esi_validation := TRUE;
                ELSIF io_vs_val.values_within_range IS NOT NULL
                      AND i_rec_triage.triage_type_acronym != 'ESI'
                THEN
                    IF io_vs_val.values_within_range = pk_alert_constant.g_no
                    THEN
                        io_vs_val.msg_text_range_no := io_vs_val.msg_text_range_no || chr(10) ||
                                                       l_rec_ctx_vital_sign.desc_vital_sign;
                    ELSIF io_vs_val.values_within_range = pk_alert_constant.g_yes
                    THEN
                        io_vs_val.msg_text_range_yes := io_vs_val.msg_text_range_yes || chr(10) ||
                                                        l_rec_ctx_vital_sign.desc_vital_sign;
                    END IF;
                
                    io_vs_val.only_optional_vs := FALSE;
                ELSIF i_rec_triage.triage_type_acronym != 'ESI'
                THEN
                    io_vs_val.only_optional_vs := nvl(io_vs_val.only_optional_vs, TRUE);
                END IF;
            ELSIF l_rec_ctx_vital_sign.flg_fill_type = 'V'
                  AND l_rec_ctx_vital_sign.internal_name = 'AVPU_scale'
            THEN
                IF i_rec_triage.triage_type_acronym != 'ESI'
                   OR (i_rec_triage.triage_type_acronym = 'ESI' AND NOT io_vs_val.finish_esi_validation)
                THEN
                    IF io_vs_val.vs_value IS NOT NULL
                    THEN
                        -- ALERT-107368 - ESI triage - AVUP Scale (2010-08-25 ASantos)
                        -- This is a new multichoice in ESI triage
                        io_vs_val.vsd_value := CASE io_vs_val.vs_value
                                                   WHEN 0 THEN
                                                    pk_alert_constant.g_no
                                                   WHEN 1 THEN
                                                    pk_alert_constant.g_yes
                                                   ELSE
                                                    NULL
                                               END;
                    
                        io_vs_val.id_triage_vs_area := nvl(io_vs_val.id_triage_vs_area,
                                                           l_rec_ctx_vital_sign.id_triage_vs_area);
                    
                        IF nvl(l_check_option.discriminator_answer.flg_selected_option, io_vs_val.vsd_value) =
                           io_vs_val.vsd_value
                        THEN
                            -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
                            IF i_rec_triage.triage_type_acronym IN (pk_edis_triage.g_vic)
                            THEN
                                io_vs_val.values_within_range := NULL;
                            END IF;
                        
                            IF nvl(i_rec_triage.triage_type_acronym, l_dummy) = 'ESI'
                               AND io_vs_val.vsd_value = pk_alert_constant.g_yes
                            THEN
                                io_vs_val.values_within_range   := pk_alert_constant.g_yes;
                                io_vs_val.finish_esi_validation := TRUE;
                            ELSE
                                io_vs_val.values_within_range := nvl(io_vs_val.values_within_range,
                                                                     pk_alert_constant.g_yes);
                            END IF;
                        ELSE
                            io_vs_val.values_within_range := pk_alert_constant.g_no;
                            io_vs_val.msg_text_range_no   := io_vs_val.msg_text_range_no || chr(10) ||
                                                             l_rec_ctx_vital_sign.desc_vital_sign;
                        END IF;
                    ELSE
                        io_vs_val.id_triage_vs_area   := nvl(io_vs_val.id_triage_vs_area,
                                                             l_rec_ctx_vital_sign.id_triage_vs_area);
                        io_vs_val.values_within_range := nvl(io_vs_val.values_within_range, pk_alert_constant.g_yes);
                    END IF;
                END IF;
            
            ELSIF ((l_rec_ctx_vital_sign.flg_fill_type = 'V' AND l_rec_ctx_vital_sign.internal_name = 'PULSE_RYTHM') OR
                  (io_vs_val.vs_value BETWEEN l_rec_ctx_vital_sign.vs_area_min_value AND
                  l_rec_ctx_vital_sign.vs_area_max_value AND l_rec_ctx_vital_sign.has_limits))
                  AND io_vs_val.vs_value IS NOT NULL
            THEN
                -- Accept discriminator, or keep the previous value if it was already assigned (which can be "No").
            
                -- IMPORTANT:
                -- So far, the only vital sign filled with a multichoice in triage (except Glasgow)
                -- is Pulse Rythm, and its value does not affect the acceptance of the discriminator.
                -- Therefore, either accepts the discriminator, or keep the previous assigned value to this variable.
            
                -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
                IF i_rec_triage.triage_type_acronym IN (pk_edis_triage.g_vic)
                THEN
                    io_vs_val.values_within_range := NULL;
                END IF;
            
                io_vs_val.values_within_range := nvl(io_vs_val.values_within_range, pk_alert_constant.g_yes);
                io_vs_val.id_triage_vs_area   := nvl(io_vs_val.id_triage_vs_area,
                                                     l_rec_ctx_vital_sign.id_triage_vs_area);
            
                IF nvl(l_check_option.discriminator_answer.flg_selected_option, l_check_option.flg_accepted_option) <>
                   l_check_option.flg_accepted_option
                   AND l_check_vs.flg_type = 'A'
                THEN
                    -- The user DIDN'T ACCEPT the discriminator. Store the name of the vital sign to warn user.
                    io_vs_val.msg_text_range_yes := io_vs_val.msg_text_range_yes || chr(10) ||
                                                    l_rec_ctx_vital_sign.desc_vital_sign;
                END IF;
            
                IF i_rec_triage.triage_type_acronym = 'ESI'
                   AND io_vs_val.values_within_range = pk_alert_constant.g_yes
                THEN
                    io_vs_val.finish_esi_validation := TRUE;
                END IF;
            
            ELSIF io_vs_val.vs_value IS NULL
                  AND l_rec_ctx_vital_sign.flg_mandatory = pk_alert_constant.g_yes
                  AND (l_rec_ctx_vital_sign.flg_available = pk_alert_constant.g_yes OR
                  (l_rec_ctx_vital_sign.flg_available = pk_alert_constant.g_no AND
                  NOT io_vs_val.checked_blood_pressure))
                  AND i_rec_triage.triage_type_acronym != 'ESI'
            THEN
                io_vs_val.values_within_range  := pk_alert_constant.g_no;
                io_vs_val.missing_vs_mandatory := TRUE;
                io_vs_val.msg_text_y           := io_vs_val.msg_text_y || chr(10) ||
                                                  l_rec_ctx_vital_sign.desc_vital_sign;
            
                IF l_rec_ctx_vital_sign.flg_available = pk_alert_constant.g_no
                THEN
                    io_vs_val.checked_blood_pressure := TRUE; -- Avoid warning message to show "Blood pressure" twice
                END IF;
            ELSIF io_vs_val.vs_value IS NULL
                  AND l_rec_ctx_vital_sign.flg_mandatory = 'X'
                  AND nvl(i_rec_triage.triage_type_acronym, l_dummy) != 'ESI'
            THEN
                -- If a mandatory VS has already been filled, then the value of the variable doesn't change.
                io_vs_val.missing_vs_exclusive := nvl(io_vs_val.missing_vs_exclusive, TRUE);
                io_vs_val.msg_text_x           := io_vs_val.msg_text_x || chr(10) ||
                                                  l_rec_ctx_vital_sign.desc_vital_sign;
            
            ELSIF l_rec_ctx_vital_sign.flg_mandatory = pk_alert_constant.g_no
                  AND (NOT l_rec_ctx_vital_sign.has_limits OR io_vs_val.vs_value IS NULL)
            THEN
                -- If the vital sign is not mandatory, then it doesn't matter if there's no registered value.
                io_vs_val.only_optional_vs := nvl(io_vs_val.only_optional_vs, TRUE);
            ELSIF io_vs_val.vs_value IS NULL
                  AND i_rec_triage.triage_type_acronym = 'ESI'
            THEN
                -- If the vital sign is not mandatory, then it doesn't matter if there's no registered value.
                -- However, we cannot assume the discriminator will be accepted, so...
                io_vs_val.values_within_range := coalesce(io_vs_val.values_within_range, -- ... just keep the same value,
                                                          l_check_option.discriminator_answer.flg_selected_option, -- or the user selection,
                                                          pk_alert_constant.g_yes); -- or accept the registered value.
            
                io_vs_val.only_optional_vs := nvl(io_vs_val.only_optional_vs, TRUE);
            ELSE
                IF i_rec_triage.triage_type_acronym != 'ESI'
                   OR (i_rec_triage.triage_type_acronym = 'ESI' AND NOT io_vs_val.finish_esi_validation)
                THEN
                    -- VICENZA triage only needs one confirmed vital sign in order to accept the discriminator
                    IF io_vs_val.values_within_range = pk_alert_constant.g_yes
                       AND i_rec_triage.triage_type_acronym IN (pk_edis_triage.g_vic)
                    THEN
                        NULL;
                    ELSE
                        -- Values not within range. Discriminator not accepted.
                        io_vs_val.values_within_range := pk_alert_constant.g_no;
                    END IF;
                    --se for obrigatório, não tiver limites e tiver sidoalor temos de aceitar a
                    --opção tomada pelo utilizador
                
                    io_vs_val.mandatory_no_limits := l_rec_ctx_vital_sign.flg_mandatory IN
                                                     (pk_alert_constant.g_yes, 'X') AND
                                                     NOT l_rec_ctx_vital_sign.has_limits AND
                                                     io_vs_val.vs_value IS NOT NULL;
                
                    IF (io_vs_val.mandatory_no_limits)
                    THEN
                        io_vs_val.values_within_range := pk_alert_constant.g_yes;
                        io_vs_val.id_triage_vs_area   := nvl(io_vs_val.id_triage_vs_area,
                                                             l_rec_ctx_vital_sign.id_triage_vs_area);
                    
                    END IF;
                
                    IF l_check_option.discriminator_answer.flg_selected_option = l_check_option.flg_accepted_option
                       AND l_check_vs.flg_type = 'A'
                       AND io_vs_val.values_within_range = pk_alert_constant.g_no
                    THEN
                        -- The user tried to ACCEPT the discriminator. Store the name of the vital sign to warn user.
                        io_vs_val.msg_text_range_no := io_vs_val.msg_text_range_no || chr(10) ||
                                                       l_rec_ctx_vital_sign.desc_vital_sign;
                    END IF;
                END IF;
            END IF;
        END validate_vs;
    
        FUNCTION validate_consent
        (
            i_option        IN pk_edis_types.rec_option,
            i_tbl_triag_vs  IN pk_edis_types.table_vital_signs,
            i_vs_val        IN pk_edis_types.rec_validate_vs,
            o_consent_title OUT VARCHAR2,
            o_consent_msg   OUT VARCHAR2,
            o_btn_select    OUT VARCHAR2
        ) RETURN BOOLEAN IS
            l_inner_func_name CONSTANT VARCHAR2(30) := 'VALIDATE_CONSENT';
            --
            l_code_msg_error_title CONSTANT sys_message.code_message%TYPE := 'TRIAGE_T011';
            l_code_msg_error_msg   CONSTANT sys_message.code_message%TYPE := 'TRIAGE_M006';
        
            l_code_title                 CONSTANT sys_message.code_message%TYPE := 'COMMON_M080';
            l_consent_code_missing_value CONSTANT sys_message.code_message%TYPE := 'TRIAGE_DISC_CONSENT_M003'; --You cannot proceed without filling in the following field: @1
            l_replace_str                CONSTANT sys_message.code_message%TYPE := '@1';
            --
            l_selected_cons_value triage_disc_consent%ROWTYPE;
        
            l_mandatory_unfilled_vs sys_message.desc_message%TYPE;
            --
            l_ret BOOLEAN;
        BEGIN
            l_ret         := TRUE;
            o_btn_select  := pk_alert_constant.g_active;
            o_consent_msg := NULL;
        
            IF i_option.id_triage_discriminator IS NOT NULL
            THEN
                IF i_option.discr_consent_values.exists(1)
                   AND i_option.id_triage_cons_value IS NULL
                THEN
                    --This means that there is consent configure for the current triage_discriminator, 
                    --but the user didn't select any consent anwser
                    g_error := 'CURRENT DISCRIMINATOR VS NEED CONSENT BUT INPUT PARAMETER IS NULL';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_func_name,
                                          text            => g_error);
                    o_consent_title := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_title);
                    o_consent_msg   := REPLACE(srcstr => pk_message.get_message(i_lang      => i_lang,
                                                                                i_code_mess => l_consent_code_missing_value),
                                               oldsub => l_replace_str,
                                               newsub => i_option.desc_triage_discriminator);
                    l_ret           := FALSE;
                ELSIF i_option.discr_consent_values.exists(1)
                      AND i_option.id_triage_cons_value IS NOT NULL
                THEN
                    FOR i IN i_option.discr_consent_values.first .. i_option.discr_consent_values.last
                    LOOP
                        IF i_option.discr_consent_values(i).id_triage_cons_value = i_option.id_triage_cons_value
                        THEN
                            l_selected_cons_value := i_option.discr_consent_values(i);
                            EXIT;
                        END IF;
                    END LOOP;
                
                    IF l_selected_cons_value.id_triage_cons_value IS NULL
                    THEN
                        --This means there isn't a match between the user selected consent and the content available for this discriminator
                        g_error := 'CURRENT DISCRIMINATOR CONSENT VALUES DON''T MATCH WITH INPUT PARAMETER VALUE';
                        pk_alertlog.log_error(object_name     => g_package_name,
                                              sub_object_name => l_inner_func_name,
                                              text            => g_error);
                        RAISE l_exception;
                    ELSIF l_selected_cons_value.flg_vs_mandatory = pk_alert_constant.g_yes
                          AND i_vs_val.missing_vs_mandatory
                    THEN
                        --I need to validate if VS were filled only if they are mandatory
                        IF i_tbl_triag_vs IS NOT NULL
                           AND i_tbl_triag_vs.count > 0
                        THEN
                            l_ret := TRUE;
                        
                            FOR i IN i_tbl_triag_vs.first .. i_tbl_triag_vs.last
                            LOOP
                                IF i_tbl_triag_vs(i).value IS NULL
                                    AND i_tbl_triag_vs(i).vsd_value IS NULL
                                THEN
                                    l_mandatory_unfilled_vs := l_mandatory_unfilled_vs || chr(10) || i_tbl_triag_vs(i).desc_vital_sign;
                                    l_ret                   := FALSE;
                                END IF;
                            END LOOP;
                        
                            IF NOT l_ret
                            THEN
                                o_consent_title := pk_message.get_message(i_lang      => i_lang,
                                                                          i_code_mess => l_code_msg_error_title);
                                o_consent_msg   := pk_message.get_message(i_lang      => i_lang,
                                                                          i_code_mess => l_code_msg_error_msg) ||
                                                   chr(10) || l_mandatory_unfilled_vs;
                            END IF;
                        ELSE
                            l_ret := TRUE;
                        END IF;
                    ELSIF l_selected_cons_value.flg_vs_enable = pk_alert_constant.g_no
                    THEN
                        --When VS are disable means that the user doesn't consent with VS reading so there isn't any selected option
                        o_btn_select := pk_alert_constant.g_inactive;
                        l_ret        := TRUE;
                    END IF;
                ELSE
                    l_ret := TRUE;
                END IF;
            END IF;
        
            RETURN l_ret;
        END validate_consent;
    
        FUNCTION get_check_result
        (
            i_vs_val       IN pk_edis_types.rec_validate_vs,
            i_check_type   IN VARCHAR2,
            i_check_option IN pk_edis_types.rec_check_option
        ) RETURN pk_edis_types.rec_chk_result IS
            l_check_result pk_edis_types.rec_chk_result;
            --
            l_msg_text_range sys_message.desc_message%TYPE;
            --CONSENT vars
            l_has_passed_consent_check BOOLEAN;
            l_consent_btn_select       VARCHAR2(1);
        BEGIN
            l_check_result.id_triage_vs_area := i_vs_val.id_triage_vs_area;
        
            IF i_vs_val.finish_esi_validation
            THEN
                l_check_result.select_option := l_check_option.flg_accepted_option;
            ELSIF i_vs_val.values_within_range IS NULL
                  AND i_vs_val.only_optional_vs
                  OR i_vs_val.mandatory_no_limits
            THEN
                l_check_result.select_option := l_check_option.discriminator_answer.flg_selected_option;
            ELSIF i_vs_val.values_within_range = pk_alert_constant.g_yes
            THEN
                IF i_vs_val.vsd_value IS NULL
                THEN
                    l_check_result.select_option := l_check_option.flg_accepted_option; -- Discriminator can be accepted, since values are within range.
                ELSE
                    l_check_result.select_option := i_vs_val.vsd_value;
                END IF;
            ELSE
                IF i_vs_val.vsd_value IS NULL
                THEN
                    -- If values aren't within range, the answer will be opposite of the acceptance option.
                    l_check_result.select_option := CASE l_check_option.flg_accepted_option
                                                        WHEN pk_alert_constant.g_yes THEN
                                                         pk_alert_constant.g_no
                                                        ELSE
                                                         pk_alert_constant.g_yes
                                                    END;
                ELSE
                    l_check_result.select_option := i_vs_val.vsd_value;
                END IF;
            END IF;
        
            g_error := 'CALL VALIDATE_CONSENT';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_has_passed_consent_check := validate_consent(i_option        => l_check_option.discriminator_answer,
                                                           i_tbl_triag_vs  => l_tbl_ctx_vital_sign,
                                                           i_vs_val        => i_vs_val,
                                                           o_consent_title => l_check_result.msg_title,
                                                           o_consent_msg   => l_check_result.msg,
                                                           o_btn_select    => l_consent_btn_select);
        
            g_error := 'SET RESULT ID_TRIAGE_DISCRIMINATOR';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF i_check_option.id_triage_discriminator IS NOT NULL
            THEN
                l_check_result.id_triage_discrim := i_check_option.id_triage_discriminator;
                l_check_result.desc_discrim      := i_check_option.desc_option;
            END IF;
        
            ----------------------------------------------------------------------------------------
            -- SETUP WARNING MESSAGES, if required
            ----------------------------------------------------------------------------------------
            -- Finally, check if its required to warn the user that there are missing values...
            IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
            THEN
                IF i_check_type = pk_edis_triage.g_flg_context_id_triage_disc
                   AND i_vs_val.vsd_value IS NOT NULL
                THEN
                    l_check_result.select_option := i_vs_val.vsd_value;
                
                    IF i_vs_val.values_within_range = pk_alert_constant.g_no
                    THEN
                        l_check_result.flg_show  := pk_alert_constant.g_yes;
                        l_check_result.button    := 'R';
                        l_check_result.msg_title := pk_message.get_message(i_lang, 'TRIAGE_T041');
                        l_check_result.msg       := REPLACE(pk_message.get_message(i_lang, 'TRIAGE_M005'),
                                                            '@1',
                                                            pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                                    l_check_result.select_option,
                                                                                    i_lang));
                    ELSE
                        l_check_result.flg_show  := pk_alert_constant.g_no;
                        l_check_result.button    := NULL;
                        l_check_result.msg_title := NULL;
                        l_check_result.msg       := NULL;
                    END IF;
                ELSE
                    l_check_result.flg_show      := pk_alert_constant.g_no;
                    l_check_result.select_option := NULL;
                    l_check_result.button        := NULL;
                    l_check_result.msg_title     := NULL;
                    l_check_result.msg           := NULL;
                END IF;
            ELSIF NOT l_has_passed_consent_check
            THEN
                l_check_result.flg_show      := pk_alert_constant.g_yes;
                l_check_result.select_option := NULL;
                l_check_result.button        := 'R';
                l_check_result.msg_rank      := pk_edis_triage.g_rank_very_important;
            ELSIF l_has_passed_consent_check
                  AND l_consent_btn_select = pk_alert_constant.g_inactive
            THEN
                l_check_result.flg_show      := pk_alert_constant.g_no;
                l_check_result.select_option := NULL;
                l_check_result.button        := NULL;
                l_check_result.msg_title     := NULL;
                l_check_result.msg           := NULL;
            ELSIF (i_vs_val.missing_vs_mandatory OR nvl(i_vs_val.missing_vs_exclusive, FALSE))
                  AND (i_rec_triage.triage_type_acronym <> 'ESI' AND
                  l_check_vs.flg_check_vital_sign = pk_edis_triage.g_triage_conf_chk_vs_yes)
            THEN
                g_error                  := 'CONFIGURE WARNING MESSAGE - MISSING VITAL SIGNS';
                l_check_result.flg_show  := pk_alert_constant.g_yes;
                l_check_result.button    := 'R';
                l_check_result.msg_title := pk_message.get_message(i_lang, 'TRIAGE_T011');
                IF i_vs_val.missing_vs_mandatory
                THEN
                    l_check_result.msg := pk_message.get_message(i_lang, 'TRIAGE_M006') || chr(10) ||
                                          i_vs_val.msg_text_y;
                ELSE
                    l_check_result.msg := pk_message.get_message(i_lang, 'TRIAGE_M007') || chr(10) ||
                                          i_vs_val.msg_text_x;
                END IF;
            
                l_check_result.select_option     := CASE l_check_option.flg_accepted_option
                                                        WHEN pk_alert_constant.g_yes THEN
                                                         pk_alert_constant.g_no
                                                        ELSE
                                                         pk_alert_constant.g_yes
                                                    END;
                l_check_result.id_triage_vs_area := NULL;
            
                -- Assign message ranking
                l_check_result.msg_rank := pk_edis_triage.g_rank_important;
            ELSIF (i_vs_val.missing_vs_mandatory OR nvl(i_vs_val.missing_vs_exclusive, FALSE))
                  AND i_rec_triage.triage_type_acronym <> 'ESI'
                  AND l_check_vs.flg_check_vital_sign = pk_edis_triage.g_triage_conf_chk_vs_no
            THEN
                -- ... or, its not required to register vital signs but some are missing, so warn the user.
                g_error                  := 'CONFIGURE WARNING MESSAGE - MISSING VITAL SIGNS (2)';
                l_check_result.flg_show  := pk_alert_constant.g_yes;
                l_check_result.button    := 'X'; -- Different o_result.button, so Flash uses a different modal window.
                l_check_result.msg_title := pk_message.get_message(i_lang, 'COMMON_M080');
                l_check_result.msg       := pk_message.get_message(i_lang, 'TRIAGE_M009');
            
                -- Assign message ranking
                l_check_result.msg_rank := pk_edis_triage.g_rank_important;
                -- No caso de o sinal vital não ter limites e ser mandatório.   
            ELSIF i_vs_val.mandatory_no_limits
            THEN
                l_check_result.flg_show  := pk_alert_constant.g_no;
                l_check_result.button    := NULL;
                l_check_result.msg_title := NULL;
                l_check_result.msg       := NULL;
                -- Or finally, check if its required to warn user that the selected option will be changed.
            ELSIF l_check_result.select_option <>
                  nvl(l_check_option.discriminator_answer.flg_selected_option, l_check_result.select_option)
                  AND NOT i_vs_val.only_optional_vs -- Allows to change the answer, when there's only optional vital signs to check.
            THEN
            
                g_error                 := 'CONFIGURE WARNING MESSAGE - SELECTED OPTION ';
                l_check_result.flg_show := pk_alert_constant.g_yes;
                l_check_result.button   := 'R';
            
                IF l_check_vs.flg_type = 'A'
                THEN
                    g_error := 'GET VITAL SIGN LIST';
                    IF l_check_result.select_option = pk_alert_constant.g_yes
                    THEN
                        l_msg_text_range := i_vs_val.msg_text_range_yes;
                    ELSE
                        l_msg_text_range := i_vs_val.msg_text_range_no;
                    END IF;
                
                    l_check_result.msg_title := pk_message.get_message(i_lang, 'COMMON_M080');
                    l_check_result.msg       := REPLACE(pk_message.get_message(i_lang, 'TRIAGE_M008'),
                                                        '@1',
                                                        l_check_option.desc_option) || chr(10) || l_msg_text_range;
                
                ELSE
                    l_check_result.msg_title := pk_message.get_message(i_lang, 'TRIAGE_T041');
                    l_check_result.msg       := REPLACE(pk_message.get_message(i_lang, 'TRIAGE_M005'),
                                                        '@1',
                                                        pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                                l_check_result.select_option,
                                                                                i_lang));
                END IF;
            
                -- Assign message ranking
                l_check_result.msg_rank := pk_edis_triage.g_rank_very_important;
            
            ELSIF i_rec_triage.triage_type_acronym = 'ESI'
                  AND l_check_result.select_option <>
                  nvl(l_check_option.discriminator_answer.flg_selected_option, l_check_result.select_option)
            THEN
                l_check_result.flg_show  := pk_alert_constant.g_yes;
                l_check_result.msg_title := pk_message.get_message(i_lang, 'TRIAGE_T041');
                l_check_result.msg       := REPLACE(pk_message.get_message(i_lang, 'TRIAGE_M005'),
                                                    '@1',
                                                    pk_sysdomain.get_domain(g_code_domain_yes_no,
                                                                            l_check_result.select_option,
                                                                            i_lang));
            
                -- Assign message ranking
                l_check_result.msg_rank := pk_edis_triage.g_rank_very_important;
            ELSE
                l_check_result.flg_show  := pk_alert_constant.g_no;
                l_check_result.button    := NULL;
                l_check_result.msg_title := NULL;
                l_check_result.msg       := NULL;
            END IF;
        
            RETURN l_check_result;
        END get_check_result;
    
        PROCEDURE prepare_final_result
        (
            i_check_option    IN pk_edis_types.rec_check_option,
            i_current_chk_res IN pk_edis_types.rec_chk_result,
            io_final_chk_res  IN OUT pk_edis_types.rec_chk_result
        ) IS
            FUNCTION validate_esi_vs RETURN BOOLEAN IS
                l_count PLS_INTEGER;
                --
                l_ret BOOLEAN := FALSE;
            BEGIN
                IF l_check_type = pk_edis_triage.g_flg_context_id_triage_disc --Only applies when validation a discriminator of ESI triage
                   AND i_rec_triage.triage_type_acronym = pk_edis_triage.g_esi
                THEN
                    SELECT COUNT(*)
                      INTO l_count
                      FROM triage_discriminator td
                      JOIN triage t
                        ON t.id_triage_discriminator = td.id_triage_discriminator
                     WHERE td.id_parent = i_check_option.id_triage_discriminator
                       AND td.flg_available = pk_alert_constant.g_yes
                       AND t.flg_available = pk_alert_constant.g_yes
                       AND t.id_triage_type = i_rec_triage.id_triage_type;
                
                    l_ret := (l_count > 0);
                END IF;
            
                RETURN l_ret;
            END validate_esi_vs;
        BEGIN
            --Based on the logic of validate_discriminator_vs_all after the call to validate_discriminator_vs
            IF (i_check_option.discriminator_answer.flg_selected_option = i_current_chk_res.flg_accepted_option OR
               NOT l_exists_message OR i_current_chk_res.msg_rank > io_final_chk_res.msg_rank)
               AND i_current_chk_res.flg_show = pk_alert_constant.g_yes
            THEN
                -- There is a warning message to show.
                -- OR
                -- User is trying to accept the discriminator, but there is a message to show, so...
                -- ...overwrite all previous warning messages.
                io_final_chk_res.flg_show          := i_current_chk_res.flg_show;
                io_final_chk_res.select_option     := i_current_chk_res.select_option;
                io_final_chk_res.id_triage_vs_area := i_current_chk_res.id_triage_vs_area;
                io_final_chk_res.id_triage_discrim := i_current_chk_res.id_triage_discrim;
                io_final_chk_res.desc_discrim      := i_current_chk_res.desc_discrim;
                io_final_chk_res.msg_title         := i_current_chk_res.msg_title;
                io_final_chk_res.msg               := htf.escape_sc(ctext => i_current_chk_res.msg);
                io_final_chk_res.button            := i_current_chk_res.button;
            
                IF i_check_option.discriminator_answer.flg_selected_option = i_current_chk_res.flg_accepted_option
                THEN
                    -- This is the most important message to show: 
                    --  something is wrong and the user is trying to accept the discriminator.
                    -- Therefore assign the highest message rank to avoid overwrite.
                    io_final_chk_res.msg_rank := pk_edis_triage.g_rank_highest_importance;
                ELSE
                    io_final_chk_res.msg_rank := i_current_chk_res.msg_rank;
                END IF;
            
                l_exists_message := TRUE;
            ELSIF i_current_chk_res.flg_show = pk_alert_constant.g_no
                  AND NOT l_exists_message
            THEN
                io_final_chk_res.flg_show          := i_current_chk_res.flg_show;
                io_final_chk_res.select_option     := i_current_chk_res.select_option;
                io_final_chk_res.id_triage_vs_area := i_current_chk_res.id_triage_vs_area;
                io_final_chk_res.id_triage_discrim := i_current_chk_res.id_triage_discrim;
                io_final_chk_res.desc_discrim      := i_current_chk_res.desc_discrim;
                io_final_chk_res.msg_title         := i_current_chk_res.msg_title;
                io_final_chk_res.msg               := htf.escape_sc(ctext => i_current_chk_res.msg);
                io_final_chk_res.button            := i_current_chk_res.button;
            
                io_final_chk_res.msg_rank := pk_edis_triage.g_rank_less_important;
            END IF;
        
            IF validate_esi_vs --Only applies when validating parent discriminators
            THEN
                --Based on the logic of validate_discriminator_vs_esi after the call to validate_discriminator_vs
                IF i_current_chk_res.id_triage_vs_area IS NOT NULL
                THEN
                    g_error := 'GET CORRESPONDING DISCRIMINATOR (1)';
                    pk_alertlog.log_debug(g_error);
                    SELECT tva.id_context,
                           t.id_triage,
                           pk_translation.get_translation(i_lang, td.code_triage_discriminator),
                           pk_alert_constant.g_yes flg_select_option,
                           nvl(t.flg_accepted_option, pk_alert_constant.g_yes) flg_accepted_option
                      INTO io_final_chk_res.id_triage_discrim,
                           io_final_chk_res.id_triage,
                           io_final_chk_res.desc_discrim,
                           io_final_chk_res.select_option,
                           io_final_chk_res.flg_accepted_option
                      FROM triage_type_vs ttv
                      JOIN triage_vs_area tva
                        ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                      JOIN triage_discriminator td
                        ON td.id_triage_discriminator = tva.id_context
                       AND tva.flg_context = pk_edis_triage.g_flg_context_id_triage_disc
                      JOIN triage t
                        ON t.id_triage_discriminator = td.id_triage_discriminator
                     WHERE tva.id_triage_vs_area = i_current_chk_res.id_triage_vs_area
                       AND td.flg_available = pk_alert_constant.g_yes
                       AND t.flg_available = pk_alert_constant.g_yes;
                END IF;
            
                IF i_current_chk_res.id_triage_vs_area IS NULL
                   OR io_final_chk_res.id_triage_discrim = i_check_option.id_triage_discriminator
                THEN
                    -- Vital signs not within the limits. Return "Not included".
                    g_error := 'GET CORRESPONDING DISCRIMINATOR (2)';
                    pk_alertlog.log_debug(g_error);
                    SELECT td.id_triage_discriminator,
                           t.id_triage,
                           pk_translation.get_translation(i_lang, td.code_triage_discriminator),
                           pk_alert_constant.g_no flg_select_option,
                           nvl(t.flg_accepted_option, pk_alert_constant.g_yes) flg_accepted_option
                      INTO io_final_chk_res.id_triage_discrim,
                           io_final_chk_res.id_triage,
                           io_final_chk_res.desc_discrim,
                           io_final_chk_res.select_option,
                           io_final_chk_res.flg_accepted_option
                      FROM triage_discriminator td
                      JOIN triage t
                        ON t.id_triage_discriminator = td.id_triage_discriminator
                     WHERE td.id_parent = i_check_option.id_triage_discriminator
                       AND td.flg_available = pk_alert_constant.g_yes
                       AND t.flg_available = pk_alert_constant.g_yes
                       AND NOT EXISTS (SELECT 0
                              FROM triage_type_vs ttv
                              JOIN triage_vs_area tva
                                ON ttv.id_triage_type_vs = tva.id_triage_type_vs
                             WHERE tva.id_context = td.id_triage_discriminator
                               AND tva.flg_context = pk_edis_triage.g_flg_context_id_triage_disc
                               AND ttv.flg_available = pk_alert_constant.g_yes);
                END IF;
            END IF;
        
            IF io_final_chk_res.id_triage_discrim != i_check_option.id_triage_discriminator
            THEN
                io_final_chk_res.id_parent_tri_discrim := i_check_option.id_triage_discriminator;
            END IF;
        END prepare_final_result;
    
        FUNCTION get_vs_disc_urgency_level
        (
            i_lang           IN language.id_language%TYPE,
            i_prof           IN profissional,
            i_triage_type    IN triage_type.id_triage_type%TYPE,
            i_pat_age        IN NUMBER,
            i_check_type     IN VARCHAR2,
            i_rec_check_vs   IN pk_edis_types.rec_check_option,
            i_rec_preg       IN pk_edis_types.rec_pregnant,
            i_rec_vital_sign IN pk_edis_types.rec_vital_sign
        ) RETURN pk_edis_types.rec_vs_result IS
            l_rec_frm_vital_sign pk_edis_types.rec_vital_sign;
        BEGIN
            l_rec_frm_vital_sign := i_rec_vital_sign;
        
            g_error := 'CALL PK_EDIS_TRIAGE.GET_VITAL_SIGN_DATA - FORM CTX - ID_VITAL_SIGN: ' ||
                       l_rec_ctx_vital_sign.id_vital_sign;
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF NOT pk_edis_triage.get_vital_sign_data(i_lang         => i_lang,
                                                      i_prof         => i_prof,
                                                      i_triage_type  => i_rec_triage.id_triage_type,
                                                      i_pat_age      => i_rec_triage.patient_age,
                                                      i_check_type   => pk_edis_triage.g_flg_context_id_ds_component,
                                                      i_rec_check_vs => l_check_option,
                                                      i_rec_preg     => i_rec_triage.pregnant,
                                                      io_rec_vs      => l_rec_frm_vital_sign,
                                                      o_error        => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            g_error := 'CALL GET_VS_URGENCY_LEVEL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            RETURN get_vs_urgency_level(i_vital_sign => l_rec_frm_vital_sign);
        END get_vs_disc_urgency_level;
    BEGIN
        l_check_vs := i_rec_triage.check_vs;
    
        g_error := 'LOOP THROUGH ALL CHECK_OPTIONS';
        pk_alertlog.log_error(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        FOR i IN l_check_vs.check_options.first .. l_check_vs.check_options.last
        LOOP
            l_check_option := l_check_vs.check_options(i);
        
            IF l_check_vs.flg_type = pk_edis_triage.g_flg_context_check_all
            THEN
                IF l_check_option.id_triage_board IS NOT NULL
                THEN
                    l_check_type := pk_edis_triage.g_flg_context_id_triage_board;
                ELSE
                    l_check_type := pk_edis_triage.g_flg_context_id_triage_disc;
                END IF;
            ELSE
                l_check_type := l_check_vs.flg_type;
            END IF;
        
            g_error := 'CALL GET_CONTEXT_VS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_tbl_ctx_vital_sign := get_context_vs(i_check_option => l_check_option, i_check_type => l_check_type);
        
            --If l_tbl_ctx_vital_sign has 0 elements means that the current context doesn't have any vital sign so there is nothing to check
            IF l_tbl_ctx_vital_sign IS NOT NULL
               AND l_tbl_ctx_vital_sign.count > 0
            THEN
                g_error := 'CALL INIT_VALIDATE_VS_VARS';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                init_validate_vs_vars(io_vs_val => l_rec_vs_val);
            
                g_error := 'LOOP THROUGH CONTEXT VS';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                FOR j IN l_tbl_ctx_vital_sign.first .. l_tbl_ctx_vital_sign.last
                LOOP
                    l_rec_ctx_vital_sign := l_tbl_ctx_vital_sign(j);
                
                    g_error := 'CALL PK_EDIS_TRIAGE.GET_VITAL_SIGN_DATA - ID_VITAL_SIGN: ' ||
                               l_rec_ctx_vital_sign.id_vital_sign;
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_func_name,
                                          text            => g_error);
                    IF NOT pk_edis_triage.get_vital_sign_data(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_triage_type  => i_rec_triage.id_triage_type,
                                                              i_pat_age      => i_rec_triage.patient_age,
                                                              i_check_type   => l_check_type,
                                                              i_rec_check_vs => l_check_option,
                                                              i_rec_preg     => i_rec_triage.pregnant,
                                                              io_rec_vs      => l_rec_ctx_vital_sign,
                                                              o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
                       AND l_rec_ctx_vital_sign.id_triage_type_vs IS NOT NULL
                    THEN
                        g_error := 'CALL GET_VS_URGENCY_LEVEL';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_func_name,
                                              text            => g_error);
                        l_tbl_vs_results.extend;
                        l_tbl_vs_results(l_tbl_vs_results.count) := get_vs_urgency_level(i_vital_sign => l_rec_ctx_vital_sign);
                    ELSIF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
                          AND l_check_type IN (pk_edis_triage.g_flg_context_id_triage_disc,
                                               pk_edis_triage.g_flg_context_id_triage_board)
                    THEN
                        g_error := 'CALL GET_VS_DISC_URGENCY_LEVEL';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_func_name,
                                              text            => g_error);
                        l_tbl_vs_results.extend;
                        l_tbl_vs_results(l_tbl_vs_results.count) := get_vs_disc_urgency_level(i_lang           => i_lang,
                                                                                              i_prof           => i_prof,
                                                                                              i_triage_type    => i_rec_triage.id_triage_type,
                                                                                              i_pat_age        => i_rec_triage.patient_age,
                                                                                              i_check_type     => pk_edis_triage.g_flg_context_id_ds_component,
                                                                                              i_rec_check_vs   => l_check_option,
                                                                                              i_rec_preg       => i_rec_triage.pregnant,
                                                                                              i_rec_vital_sign => l_rec_ctx_vital_sign);
                    ELSE
                        g_error := 'SET URGENCY_LEVEL TO NULL';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_func_name,
                                              text            => g_error);
                        l_tbl_vs_results.extend;
                        l_tbl_vs_results(l_tbl_vs_results.count).id_vital_sign := l_rec_ctx_vital_sign.id_vital_sign;
                        l_tbl_vs_results(l_tbl_vs_results.count).id_vital_sign_parent := l_rec_ctx_vital_sign.id_vital_sign_parent;
                    END IF;
                
                    g_error := 'CALL FILL_VS_EXTRA_INFO';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_func_name,
                                          text            => g_error);
                    fill_vs_extra_info(i_lang            => i_lang,
                                       i_prof            => i_prof,
                                       i_rec_vital_sign  => l_rec_ctx_vital_sign,
                                       io_tbl_vs_results => l_tbl_vs_results);
                
                    IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
                       AND l_check_type = pk_edis_triage.g_flg_context_id_triage_disc
                    THEN
                        IF l_rec_ctx_vital_sign.id_triage_vs_area IS NOT NULL
                           AND (l_rec_ctx_vital_sign.value IS NOT NULL OR
                           l_rec_ctx_vital_sign.id_vital_sign_desc IS NOT NULL)
                        THEN
                            l_rec_vs_val.id_triage_vs_area   := l_rec_ctx_vital_sign.id_triage_vs_area;
                            l_rec_vs_val.vsd_value           := pk_alert_constant.g_yes;
                            l_rec_vs_val.values_within_range := pk_alert_constant.g_yes;
                        
                            IF l_check_option.discriminator_answer.flg_selected_option = pk_alert_constant.g_no
                            THEN
                                --The user answered NO but the answer must be a YES
                                l_rec_vs_val.vsd_value           := pk_alert_constant.g_yes;
                                l_rec_vs_val.values_within_range := pk_alert_constant.g_no;
                            END IF;
                        ELSIF l_rec_ctx_vital_sign.id_triage_vs_area IS NULL
                              AND (l_rec_ctx_vital_sign.value IS NOT NULL OR
                              l_rec_ctx_vital_sign.id_vital_sign_desc IS NOT NULL)
                              AND nvl(l_rec_vs_val.vsd_value, pk_alert_constant.g_yes) = pk_alert_constant.g_yes
                        THEN
                            l_rec_vs_val.vsd_value           := pk_alert_constant.g_no;
                            l_rec_vs_val.values_within_range := pk_alert_constant.g_yes;
                        
                            IF l_check_option.discriminator_answer.flg_selected_option = pk_alert_constant.g_yes
                            THEN
                                --The user answered YES but the answer must be a NO
                                l_rec_vs_val.vsd_value           := pk_alert_constant.g_no;
                                l_rec_vs_val.values_within_range := pk_alert_constant.g_no;
                            END IF;
                        END IF;
                    ELSIF i_rec_triage.id_triage_type != pk_edis_triage.g_triage_id_est
                          AND l_rec_ctx_vital_sign.id_triage_vs_area IS NOT NULL
                    THEN
                        IF i_rec_triage.id_triage_type != pk_edis_triage.g_triage_id_esi
                           OR (l_rec_vs_val.id_triage_vs_area IS NULL AND NOT l_rec_vs_val.finish_esi_validation AND
                           i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_esi)
                        THEN
                            l_rec_vs_val.id_triage_vs_area := l_rec_ctx_vital_sign.id_triage_vs_area;
                        END IF;
                    
                        g_error := 'CALL VALIDATE_VS - ID_TRIAGE_VS_AREA: ' || l_rec_ctx_vital_sign.id_triage_vs_area;
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_func_name,
                                              text            => g_error);
                        validate_vs(io_vs_val => l_rec_vs_val);
                    END IF;
                
                    --Update Vital Sign
                    l_tbl_ctx_vital_sign(j) := l_rec_ctx_vital_sign;
                END LOOP;
            
                g_error := 'CALL GET_CHECK_RESULT';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_curr_result := get_check_result(i_vs_val       => l_rec_vs_val,
                                                  i_check_type   => l_check_vs.flg_type,
                                                  i_check_option => l_check_option);
            
                g_error := 'CALL PREPARE_FINAL_RESULT';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                prepare_final_result(i_check_option    => l_check_option,
                                     i_current_chk_res => l_curr_result,
                                     io_final_chk_res  => o_result);
            END IF;
        END LOOP;
    
        g_error := 'CALL REMOVE_DUP_URG_LEVEL_VS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        remove_dup_urg_level_vs(io_tbl_vital_signs => l_tbl_vs_results);
    
        o_result.vital_signs := l_tbl_vs_results;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        
    END check_vital_signs;

    FUNCTION check_triage
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_rec_triage IN pk_edis_types.rec_triage,
        o_result     OUT pk_edis_types.rec_chk_result,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_TRIAGE';
        --
        --The system prompts the user about the vital signs incompatibility with the selected triage reason
        l_code_title_vs_incomp_tb CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M009';
        l_code_msg_vs_incomp_tb   CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M008';
        --
        l_rec_triage       pk_edis_types.rec_triage;
        l_rec_grp_option   pk_edis_types.rec_group_option;
        l_rec_option       pk_edis_types.rec_option;
        l_rec_child_option pk_edis_types.rec_discrim_child;
        --
        l_triage_board            triage_board.id_triage_board%TYPE := NULL;
        l_count_urg_level         PLS_INTEGER;
        l_tbl_triage_board_levels table_number;
        --
        l_current_triage_level triage_esi_level.esi_level%TYPE := NULL;
        l_aux_triage_level     triage_esi_level.esi_level%TYPE := NULL;
        --
        l_rec_degree  pk_edis_types.rec_degree;
        l_tbl_degrees pk_edis_types.table_degrees := pk_edis_types.table_degrees();
        --
        l_code_can_change_color CONSTANT sys_config.id_sys_config%TYPE := 'FLG_CHANGE_COLOR';
        l_code_show_color_desc  CONSTANT sys_config.id_sys_config%TYPE := 'FLG_SHOW_COLOR_DESC';
        --
        l_total_options          PLS_INTEGER;
        l_total_no_answers       PLS_INTEGER;
        l_all_answers_are_no     BOOLEAN;
        l_total_critital         PLS_INTEGER;
        l_tbl_critical_look_yes  table_number := table_number();
        l_tbl_critical_look_no   table_number := table_number();
        t_total_critical_answers PLS_INTEGER;
    
        l_aux_1 VARCHAR2(1 CHAR);
        l_aux2  VARCHAR2(1 CHAR);
        --
        l_all_vs_are_empty  BOOLEAN;
        l_is_to_validate_vs BOOLEAN;
        --
        CURSOR c_degrees(i_show_color_desc IN triage_configuration.flg_show_color_desc%TYPE) IS
            SELECT tc.id_triage_color,
                   decode(i_show_color_desc,
                          pk_alert_constant.g_yes,
                          pk_translation.get_translation(i_lang, tc.code_triage_color),
                          NULL) desc_triage_color,
                   tc.color,
                   tc.color_text,
                   pk_translation.get_translation(i_lang, tc.code_accuity) desc_accuity,
                   tel.esi_level urgency_level,
                   decode(tcg.internal_name, -- José Brito 20/11/2009 ALERT-57921
                          'EXPIRED',
                          pk_message.get_message(i_lang, g_code_msg_not_applicable),
                          decode(tc.flg_show,
                                 pk_alert_constant.g_yes,
                                 decode(tci.obs_time,
                                        0,
                                        pk_message.get_message(i_lang, 'TRIAGE_EST_M014'),
                                        tci.obs_time || ' ' || pk_message.get_message(i_lang, 'TRIAGE_T038')),
                                 pk_message.get_message(i_lang, g_code_msg_not_applicable))) desc_time_max,
                   -- FLG_SHOW é passado ao Flash para que ele possa ver descriminadores como o 'Reavaliar'      
                   tc.flg_show,
                   -- ESI Protocol data
                   decode(l_rec_triage.triage_type_acronym,
                          pk_edis_triage.g_esi,
                          (SELECT pk_translation.get_translation(i_lang, tc.code_triage_color)
                             FROM dual),
                          NULL) esi_level_header,
                   CASE
                        WHEN l_rec_triage.id_triage_type IN
                             (g_triage_id_ctas_p, g_triage_id_ctas_a, g_triage_id_sa, pk_edis_triage.g_triage_id_atas) THEN
                         decode(tci.reassess_time,
                                0,
                                pk_message.get_message(i_lang, 'TRIAGE_CTAS_M003'),
                                tci.reassess_time || ' ' || pk_message.get_message(i_lang, 'TRIAGE_T038') || ' (' ||
                                tci.reassess_time || '/' || tci.reassess_time || ')')
                        ELSE
                         NULL
                    END desc_reassess_time
            
              FROM triage_color tc
              JOIN triage_color_time_inst tci
                ON tci.id_triage_color = tc.id_triage_color -- José Brito 26/03/2009 ALERT-20512 Configurable observation times in triage
               AND (tci.id_institution = 0 AND NOT EXISTS
                    (SELECT 0
                       FROM triage_color_time_inst t1
                      WHERE t1.id_triage_color = tc.id_triage_color
                        AND t1.id_institution = i_prof.institution) OR tci.id_institution = i_prof.institution)
              JOIN triage_color_group tcg
                ON tcg.id_triage_color_group = tc.id_triage_color_group
              LEFT JOIN triage_esi_level tel
                ON tel.id_triage_color = tc.id_triage_color
             WHERE tc.id_triage_type = l_rec_triage.id_triage_type
               AND tc.flg_available = pk_alert_constant.g_yes
               AND (EXISTS (SELECT 0
                              FROM triage t
                             WHERE t.id_triage_color = tc.id_triage_color) OR
                    (tc.id_triage_type IN (pk_edis_triage.g_triage_id_latour,
                                                  pk_edis_triage.g_triage_id_sa,
                                                  pk_edis_triage.g_triage_id_ctas_a,
                                                  pk_edis_triage.g_triage_id_ctas_p) AND tc.flg_type = 'M'))
             ORDER BY tc.rank;
    
        r_degree c_degrees%ROWTYPE;
        --
        l_exception EXCEPTION;
        --
        --This function is called only when all answers to the discriminators were no
        FUNCTION get_board_emerg_level
        (
            i_patient               IN patient.id_patient%TYPE,
            i_episode               IN episode.id_episode%TYPE,
            i_triage_board          IN triage_board.id_triage_board%TYPE,
            i_tbl_defining_criteria IN pk_edis_types.table_defining_criteria
        ) RETURN triage_esi_level.esi_level%TYPE IS
            l_inner_func_name CONSTANT VARCHAR2(50) := 'GET_BOARD_EMERG_LEVEL';
            --
            CURSOR c_triage_board_level IS
                SELECT DISTINCT tel.esi_level, tel.id_triage_color
                  FROM triage_board_acuity_lvl tbal
                  JOIN triage_esi_level tel
                    ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                 WHERE tbal.id_triage_board = i_triage_board
                 ORDER BY tel.esi_level DESC;
        
            r_triage_board_level c_triage_board_level%ROWTYPE;
        
            CURSOR c_discriminators(i_triage_color IN triage_color.id_triage_color%TYPE) IS
                SELECT t.id_triage_discriminator
                  FROM TABLE(pk_edis_triage.tf_triage_discrim(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_patient      => i_patient,
                                                              i_episode      => i_episode,
                                                              i_triage_board => i_triage_board,
                                                              i_triage_color => i_triage_color)) t;
        
            l_tbl_board_discrs     table_number;
            l_tbl_def_crit_discrs  table_number := table_number();
            l_total_discrs_matches PLS_INTEGER;
            --
            l_all_discr_are_no BOOLEAN := TRUE;
            --
            l_ret triage_esi_level.esi_level%TYPE;
        BEGIN
            g_error := 'FILL DEF_CRIT_DISCRS TABLE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func_name, text => g_error);
            FOR i IN i_tbl_defining_criteria.first .. i_tbl_defining_criteria.last
            LOOP
                IF i_tbl_defining_criteria(i).discrim_answer = pk_alert_constant.g_no
                THEN
                    l_tbl_def_crit_discrs.extend;
                    l_tbl_def_crit_discrs(l_tbl_def_crit_discrs.count) := i_tbl_defining_criteria(i).id_triage_discriminator;
                ELSE
                    l_all_discr_are_no := FALSE;
                    EXIT;
                END IF;
            END LOOP;
        
            IF l_all_discr_are_no
            THEN
                g_error := 'LOOP THROUGH BOARD LEVELS';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name,
                                      text            => g_error);
                FOR r_triage_board_level IN c_triage_board_level
                LOOP
                    OPEN c_discriminators(i_triage_color => r_triage_board_level.id_triage_color);
                    FETCH c_discriminators BULK COLLECT
                        INTO l_tbl_board_discrs;
                    CLOSE c_discriminators;
                
                    IF l_tbl_board_discrs.count != l_tbl_def_crit_discrs.count
                    THEN
                        SELECT COUNT(*)
                          INTO l_total_discrs_matches
                          FROM TABLE(l_tbl_def_crit_discrs) t
                         WHERE t.column_value IN (SELECT a.column_value
                                                    FROM TABLE(l_tbl_board_discrs) a);
                    
                        IF l_total_discrs_matches != l_tbl_board_discrs.count
                        THEN
                            --This function assumes that all the user answers in i_tbl_defining_criteria were no
                            --So we only need to compare the answers given by the user with the total number of discriminators
                            --of the current level if they differ it means that the user didn't answer some question
                            --The c_triage_board_level is order descendent by urgency level
                            --So if this is true this is the current level  
                            l_ret              := r_triage_board_level.esi_level;
                            l_all_discr_are_no := FALSE;
                            EXIT;
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        
            IF l_ret IS NULL
               AND l_all_discr_are_no
            THEN
                g_error := 'GET MINIMUN URGENCY LEVEL WITH ANY DISCRIMS';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name,
                                      text            => g_error);
                --The user answered no to all discriminators
                --Return the minimum urgency level of the board that hasn't any discriminator
                SELECT MAX(tel.esi_level)
                  INTO l_ret
                  FROM triage_board_acuity_lvl tbal
                  JOIN triage_esi_level tel
                    ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                 WHERE tbal.id_triage_board = i_triage_board
                   AND tel.esi_level NOT IN (SELECT tel2.esi_level
                                               FROM triage t
                                               JOIN triage_color tc
                                                 ON tc.id_triage_color = t.id_triage_color
                                               JOIN triage_esi_level tel2
                                                 ON tel2.id_triage_color = tc.id_triage_color
                                              WHERE t.id_triage_board = i_triage_board);
            END IF;
            IF l_ret IS NULL
            THEN
                g_error := 'GET MINIMUN BOARD URGENCY LEVEL';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_func_name,
                                      text            => g_error);
                --Triage board as any discriminators or the user didn't answer any discriminator
                --Return the minimum urgency level of the board
                SELECT MAX(tel.esi_level)
                  INTO l_ret
                  FROM triage_board_acuity_lvl tbal
                  JOIN triage_esi_level tel
                    ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                 WHERE tbal.id_triage_board = i_triage_board;
            END IF;
        
            RETURN l_ret;
        END get_board_emerg_level;
    
        PROCEDURE add_vs_not_validated IS
            l_found BOOLEAN;
        BEGIN
            IF l_rec_triage.vital_signs.exists(1)
            THEN
                FOR i IN l_rec_triage.vital_signs.first .. l_rec_triage.vital_signs.last
                LOOP
                    l_found := FALSE;
                
                    IF o_result.vital_signs.count > 0
                    THEN
                        FOR j IN o_result.vital_signs.first .. o_result.vital_signs.last
                        LOOP
                            IF l_rec_triage.vital_signs(i).id_vital_sign = o_result.vital_signs(j).id_vital_sign
                            THEN
                                l_found := TRUE;
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                
                    IF NOT l_found
                    THEN
                        o_result.vital_signs.extend;
                        o_result.vital_signs(o_result.vital_signs.count).id_vital_sign := l_rec_triage.vital_signs(i).id_vital_sign;
                        o_result.vital_signs(o_result.vital_signs.count).id_vital_sign_parent := l_rec_triage.vital_signs(i).id_vital_sign_parent;
                        o_result.vital_signs(o_result.vital_signs.count).urgency_level := l_rec_triage.vital_signs(i).urgency_level;
                    
                        g_error := 'CALL FILL_VS_EXTRA_INFO';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_func_name,
                                              text            => g_error);
                        fill_vs_extra_info(i_lang            => i_lang,
                                           i_prof            => i_prof,
                                           i_rec_vital_sign  => l_rec_triage.vital_signs(i),
                                           io_tbl_vs_results => o_result.vital_signs);
                    END IF;
                END LOOP;
            END IF;
        END add_vs_not_validated;
    
        PROCEDURE fill_parent_vs_detail IS
            TYPE table_vs_by_rank IS TABLE OF pk_edis_types.rec_vs_result INDEX BY BINARY_INTEGER;
            l_tbl_vs_by_rank table_vs_by_rank;
            l_tbl_idx        BINARY_INTEGER;
            --
            l_found BOOLEAN;
            --
            l_rec_vs                 pk_edis_types.rec_vital_sign;
            l_index_parent_vs        PLS_INTEGER;
            l_desc_value             pk_translation.t_desc_translation;
            l_blood_press_syst_value vital_sign_read.value%TYPE;
            l_blood_press_dias_value vital_sign_read.value%TYPE;
            l_vs_internal_name       vital_sign.intern_name_vital_sign%TYPE;
        BEGIN
            IF l_rec_triage.vital_signs.exists(1)
            THEN
                FOR i IN l_rec_triage.vital_signs.first .. l_rec_triage.vital_signs.last
                LOOP
                    l_tbl_vs_by_rank.delete;
                    l_tbl_idx                := NULL;
                    l_found                  := FALSE;
                    l_rec_vs                 := l_rec_triage.vital_signs(i);
                    l_index_parent_vs        := NULL;
                    l_desc_value             := NULL;
                    l_blood_press_syst_value := NULL;
                    l_blood_press_dias_value := NULL;
                    l_vs_internal_name       := NULL;
                
                    CASE l_rec_vs.flg_fill_type
                        WHEN pk_alert_constant.g_vs_rel_group THEN
                            FOR j IN o_result.vital_signs.first .. o_result.vital_signs.last
                            LOOP
                                IF l_rec_vs.id_vital_sign = o_result.vital_signs(j).id_vital_sign
                                THEN
                                    l_index_parent_vs := j;
                                END IF;
                            
                                IF l_rec_vs.id_vital_sign = o_result.vital_signs(j).id_vital_sign_parent
                                THEN
                                    l_tbl_vs_by_rank(o_result.vital_signs(j).rank) := o_result.vital_signs(j);
                                END IF;
                            END LOOP;
                        
                            l_tbl_idx := l_tbl_vs_by_rank.first;
                            WHILE l_tbl_idx IS NOT NULL
                            LOOP
                                IF l_tbl_vs_by_rank(l_tbl_idx).desc_value IS NOT NULL
                                THEN
                                    l_desc_value := l_desc_value ||
                                                    pk_vital_sign.get_vs_desc(i_lang       => i_lang,
                                                                              i_vital_sign => l_tbl_vs_by_rank(l_tbl_idx).id_vital_sign) || ': ' || l_tbl_vs_by_rank(l_tbl_idx).desc_value ||
                                                    chr(13);
                                END IF;
                                l_tbl_idx := l_tbl_vs_by_rank.next(l_tbl_idx);
                            END LOOP;
                        
                            IF l_desc_value IS NOT NULL
                            THEN
                                l_desc_value := substr(str1 => l_desc_value, pos => 1, len => length(l_desc_value) - 1);
                            END IF;
                        
                            IF l_index_parent_vs IS NOT NULL
                            THEN
                                o_result.vital_signs(l_index_parent_vs).desc_value := l_desc_value;
                            END IF;
                        WHEN pk_alert_constant.g_vs_ft_bar_keypad THEN
                            FOR j IN o_result.vital_signs.first .. o_result.vital_signs.last
                            LOOP
                                IF l_rec_vs.id_vital_sign = o_result.vital_signs(j).id_vital_sign
                                THEN
                                    l_index_parent_vs := j;
                                    l_desc_value      := l_rec_vs.desc_unit_measure;
                                END IF;
                            
                                IF l_rec_vs.id_vital_sign = o_result.vital_signs(j).id_vital_sign_parent
                                THEN
                                    SELECT vs.intern_name_vital_sign
                                      INTO l_vs_internal_name
                                      FROM vital_sign vs
                                     WHERE vs.id_vital_sign = o_result.vital_signs(j).id_vital_sign;
                                
                                    IF l_vs_internal_name = pk_edis_triage.g_vs_blood_pressure_s
                                    THEN
                                        l_blood_press_syst_value := o_result.vital_signs(j).value;
                                    ELSIF l_vs_internal_name = pk_edis_triage.g_vs_blood_pressure_d
                                    THEN
                                        l_blood_press_dias_value := o_result.vital_signs(j).value;
                                    END IF;
                                END IF;
                            
                                IF l_index_parent_vs IS NOT NULL
                                   AND l_blood_press_syst_value IS NOT NULL
                                   AND l_blood_press_dias_value IS NOT NULL
                                THEN
                                    --All the needed values were found so we can exit the loop
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            IF l_index_parent_vs IS NOT NULL
                               AND l_blood_press_syst_value IS NOT NULL
                               AND l_blood_press_dias_value IS NOT NULL
                            THEN
                                o_result.vital_signs(l_index_parent_vs).desc_value := l_blood_press_syst_value || '/' ||
                                                                                      l_blood_press_dias_value || ' ' ||
                                                                                      l_desc_value;
                            END IF;
                        ELSE
                            NULL;
                    END CASE;
                
                END LOOP;
            END IF;
        END fill_parent_vs_detail;
    
        FUNCTION get_min_est_level RETURN triage_esi_level.esi_level%TYPE IS
            l_min_level triage_esi_level.esi_level%TYPE;
        BEGIN
            SELECT MAX(tel.esi_level) --I want the minimum EST triage level
              INTO l_min_level
              FROM triage_board_acuity_lvl tbal
              JOIN triage_esi_level tel
                ON tel.id_triage_esi_level = tbal.id_triage_esi_level
             WHERE tbal.id_triage_board = l_triage_board;
        
            RETURN l_min_level;
        END get_min_est_level;
    
        PROCEDURE calculate_proteinuria_vs
        (
            io_tbl_vital_signs_result IN OUT pk_edis_types.table_vs_results,
            io_tbl_vital_signs        IN OUT pk_edis_types.table_vital_signs
        ) IS
            l_vs_idx_prot PLS_INTEGER;
            l_vs_idx_ta   PLS_INTEGER;
            l_vs_idx_tas  PLS_INTEGER;
            l_vs_idx_tad  PLS_INTEGER;
            --
            l_urg_lvl_proteinuria triage_esi_level.esi_level%TYPE;
            l_urg_lvl_ta          triage_esi_level.esi_level%TYPE;
        BEGIN
            IF io_tbl_vital_signs_result.exists(1)
            THEN
                FOR i IN io_tbl_vital_signs_result.first .. io_tbl_vital_signs_result.last
                LOOP
                    CASE io_tbl_vital_signs_result(i).internal_name
                        WHEN pk_edis_triage.g_vs_blood_pressure THEN
                            l_vs_idx_ta := i;
                        WHEN pk_edis_triage.g_vs_blood_pressure_s THEN
                            l_vs_idx_tas := i;
                        WHEN pk_edis_triage.g_vs_blood_pressure_d THEN
                            l_vs_idx_tad := i;
                        WHEN pk_edis_triage.g_vs_proteinuria THEN
                            l_vs_idx_prot := i;
                        ELSE
                            NULL;
                    END CASE;
                END LOOP;
            
                IF l_vs_idx_prot IS NOT NULL
                THEN
                    IF l_vs_idx_ta IS NULL
                       OR l_vs_idx_tas IS NULL
                       OR l_vs_idx_tad IS NULL
                    THEN
                        io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level := NULL;
                    ELSE
                        l_urg_lvl_proteinuria := io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level;
                        l_urg_lvl_ta          := io_tbl_vital_signs_result(l_vs_idx_ta).urgency_level;
                    
                        IF l_urg_lvl_proteinuria = g_est_min_vs_level
                           AND l_urg_lvl_ta != 1
                        THEN
                            io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level := g_est_min_vs_level;
                        ELSIF l_urg_lvl_proteinuria IN (1, 2)
                              AND l_urg_lvl_ta = g_est_min_vs_level
                        THEN
                            io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level := 2;
                        ELSIF l_urg_lvl_proteinuria = 1
                              AND l_urg_lvl_ta = 2
                        THEN
                            io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level := 1;
                        ELSE
                            io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level := NULL;
                        END IF;
                    END IF;
                
                    --update proteinuria vital sign urgency level in input table
                    IF io_tbl_vital_signs.exists(1)
                    THEN
                        FOR i IN io_tbl_vital_signs.first .. io_tbl_vital_signs.last
                        LOOP
                            IF io_tbl_vital_signs(i).internal_name = pk_edis_triage.g_vs_proteinuria
                            THEN
                                io_tbl_vital_signs(i).urgency_level := io_tbl_vital_signs_result(l_vs_idx_prot).urgency_level;
                                EXIT;
                            END IF;
                        END LOOP;
                    END IF;
                END IF;
            END IF;
        END calculate_proteinuria_vs;
    
        PROCEDURE get_critical_look_level(o_level OUT triage_esi_level.esi_level%TYPE) IS
            l_level triage_esi_level.esi_level%TYPE;
            l_count NUMBER;
        BEGIN
            SELECT COUNT(DISTINCT t.id_triage_board)
              INTO l_count
              FROM triage t
             WHERE t.id_triage IN (SELECT /*+opt_estimate(table t rows=1)*/
                                    column_value
                                     FROM TABLE(l_tbl_critical_look_yes) t);
        
            CASE l_count
                WHEN 3 THEN
                    o_level := 1;
                WHEN 2 THEN
                    o_level := 2;
                WHEN 1 THEN
                    o_level := 3;
                ELSE
                    o_level := NULL;
            END CASE;
        
        END get_critical_look_level;
    
    BEGIN
        l_rec_triage := i_rec_triage;
    
        IF l_rec_triage.check_vs.flg_type IS NOT NULL
           AND l_rec_triage.vital_signs.exists(1)
        THEN
            l_is_to_validate_vs := TRUE;
        
            IF l_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_esi
            THEN
                l_all_vs_are_empty := TRUE;
            
                FOR i IN l_rec_triage.vital_signs.first .. l_rec_triage.vital_signs.last
                LOOP
                    IF l_rec_triage.vital_signs(i).value IS NOT NULL
                        OR l_rec_triage.vital_signs(i).id_vital_sign_desc IS NOT NULL
                    THEN
                        l_all_vs_are_empty := FALSE;
                        EXIT;
                    END IF;
                END LOOP;
            
                l_is_to_validate_vs := NOT l_all_vs_are_empty;
            END IF;
        
            IF l_is_to_validate_vs
            THEN
                g_error := 'CALL PK_EDIS_TRIAGE.CHECK_VITAL_SIGNS';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                IF NOT check_vital_signs(i_lang       => i_lang,
                                         i_prof       => i_prof,
                                         i_rec_triage => l_rec_triage,
                                         o_result     => o_result,
                                         o_error      => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                g_error := 'UPDATE VS URGENCY LEVEL';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                IF o_result.vital_signs.exists(1)
                THEN
                    FOR i IN o_result.vital_signs.first .. o_result.vital_signs.last
                    LOOP
                        FOR j IN l_rec_triage.vital_signs.first .. l_rec_triage.vital_signs.last
                        LOOP
                            IF l_rec_triage.vital_signs(j).id_vital_sign = o_result.vital_signs(i).id_vital_sign
                            THEN
                                l_rec_triage.vital_signs(j).urgency_level := o_result.vital_signs(i).urgency_level;
                                EXIT;
                            END IF;
                        END LOOP;
                    END LOOP;
                END IF;
            END IF;
        END IF;
    
        IF NOT o_result.vital_signs.exists(1)
        THEN
            o_result.vital_signs := pk_edis_types.table_vs_results();
        END IF;
    
        --Add to the output var VS not validated
        add_vs_not_validated;
    
        --Fill value of parent VS's
        fill_parent_vs_detail;
    
        g_error := 'CALL CALCULATE_PROTEINURIA_VS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        calculate_proteinuria_vs(io_tbl_vital_signs_result => o_result.vital_signs,
                                 io_tbl_vital_signs        => l_rec_triage.vital_signs);
    
        g_error := 'UPDATE DESC_VALUE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF o_result.vital_signs.exists(1)
           AND l_rec_triage.vital_signs.exists(1)
           AND i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
        THEN
            FOR i IN o_result.vital_signs.first .. o_result.vital_signs.last
            LOOP
                FOR j IN l_rec_triage.vital_signs.first .. l_rec_triage.vital_signs.last
                LOOP
                    IF l_rec_triage.vital_signs(j).id_vital_sign = o_result.vital_signs(i).id_vital_sign
                        AND o_result.vital_signs(i).urgency_level IS NOT NULL
                    THEN
                        --The value must be updated because it's being used to show the defining criteria
                        l_rec_triage.vital_signs(j).desc_value := o_result.vital_signs(i).desc_value;
                        EXIT;
                    END IF;
                END LOOP;
            END LOOP;
        END IF;
    
        IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
        THEN
            g_error := 'CALL GET_HIGHER_URG_LEVEL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            o_result.triage_level.higher_vs_urgency_level := get_higher_vs_urg_level(i_tbl_vital_signs => l_rec_triage.vital_signs);
            o_result.triage_level.urgency_level_desc      := get_urgency_level_desc(i_lang          => i_lang,
                                                                                    i_urgency_level => o_result.triage_level.higher_vs_urgency_level,
                                                                                    i_triage_type   => i_rec_triage.id_triage_type);
        
            l_current_triage_level := o_result.triage_level.higher_vs_urgency_level;
        
        END IF;
    
        l_triage_board := l_rec_triage.id_triage_board;
    
        g_error := 'SET CURRENT TRIAGE_LEVEL';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF l_rec_triage.group_options IS NOT NULL
           AND l_rec_triage.group_options.count > 0
        THEN
            l_total_options    := 0;
            l_total_no_answers := 0;
        
            FOR i IN l_rec_triage.group_options.first .. l_rec_triage.group_options.last
            LOOP
                l_rec_grp_option := l_rec_triage.group_options(i);
            
                IF l_rec_grp_option.options IS NOT NULL
                   AND l_rec_grp_option.options.count > 0
                THEN
                    l_total_options := l_total_options + l_rec_grp_option.options.count;
                
                    FOR j IN l_rec_grp_option.options.first .. l_rec_grp_option.options.last
                    LOOP
                        l_rec_option       := l_rec_grp_option.options(j);
                        l_rec_child_option := l_rec_option.child_option;
                    
                        --Update the value of flg_selected_option when the previous validation of VS demands it to the user
                        IF o_result.id_triage_discrim = l_rec_option.id_triage_discriminator
                           OR o_result.id_parent_tri_discrim = l_rec_option.id_triage_discriminator
                           AND o_result.select_option IS NOT NULL
                        THEN
                            IF l_rec_option.id_triage IS NOT NULL
                            THEN
                                SELECT decode(o_result.select_option,
                                              pk_alert_constant.g_yes,
                                              t.id_triage_color,
                                              t.id_triage_color_other)
                                  INTO l_rec_option.id_triage_color
                                  FROM triage t
                                 WHERE t.id_triage = l_rec_option.id_triage;
                            
                                l_rec_triage.group_options(i).options(j).id_triage_color := l_rec_option.id_triage_color;
                            
                                IF l_rec_option.id_triage_color IS NOT NULL
                                THEN
                                    BEGIN
                                        SELECT tel.esi_level
                                          INTO l_rec_option.urgency_level
                                          FROM triage_esi_level tel
                                         WHERE tel.id_triage_color = l_rec_option.id_triage_color;
                                    EXCEPTION
                                        WHEN no_data_found THEN
                                            l_rec_option.urgency_level := NULL;
                                    END;
                                
                                    l_rec_triage.group_options(i).options(j).urgency_level := l_rec_option.urgency_level;
                                END IF;
                            END IF;
                        
                            l_rec_option.flg_selected_option := o_result.select_option;
                            l_rec_triage.group_options(i).options(j).flg_selected_option := o_result.select_option;
                        ELSIF nvl(l_rec_option.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_yes
                        THEN
                            l_total_critital := l_total_critital + 1;
                            IF l_rec_option.flg_selected_option = pk_alert_constant.g_yes
                            THEN
                                l_tbl_critical_look_yes.extend;
                                l_tbl_critical_look_yes(l_tbl_critical_look_yes.last) := l_rec_option.id_triage;
                            ELSE
                                l_tbl_critical_look_no.extend;
                                l_tbl_critical_look_no(l_tbl_critical_look_no.last) := l_rec_option.id_triage;
                            
                            END IF;
                        END IF;
                    
                        --Update child discriminator
                        IF l_rec_option.id_triage_discriminator = o_result.id_parent_tri_discrim
                        THEN
                            l_rec_child_option := get_discrim_child_rec(i_lang       => i_lang,
                                                                        i_prof       => i_prof,
                                                                        i_id_disc    => o_result.id_triage_discrim,
                                                                        i_id_patient => l_rec_triage.id_patient);
                            l_rec_triage.group_options(i).options(j).child_option := l_rec_child_option;
                        END IF;
                        l_aux_1 := l_rec_option.flg_critical_look;
                        l_aux2  := l_rec_option.flg_selected_option;
                        IF (l_rec_option.flg_selected_option = pk_alert_constant.g_yes AND
                           nvl(l_rec_child_option.flg_accuity_confirmation, pk_alert_constant.g_yes) =
                           pk_alert_constant.g_yes OR
                           (l_rec_child_option.id_triage_discriminator IS NOT NULL AND
                           l_rec_child_option.flg_accuity_confirmation = pk_alert_constant.g_yes AND
                           l_rec_child_option.flg_select_option = pk_alert_constant.g_yes))
                           AND nvl(l_rec_option.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                        THEN
                            --An yes answer to one discriminator sets the urgency level
                            --Only one yes is allowed
                            l_current_triage_level                := l_rec_option.urgency_level;
                            o_result.triage_level.id_triage_color := l_rec_option.id_triage_color;
                            EXIT;
                        ELSIF (l_rec_option.flg_selected_option = pk_alert_constant.g_no AND
                              l_rec_option.id_triage_color IS NOT NULL AND
                              l_rec_grp_option.id_triage_color != l_rec_option.id_triage_color)
                              OR (l_rec_child_option.id_triage_discriminator IS NOT NULL AND
                              l_rec_child_option.flg_accuity_confirmation = pk_alert_constant.g_yes AND
                              l_rec_child_option.flg_select_option = pk_alert_constant.g_no)
                        THEN
                            --In some triages the NO to the last question sets the urgency level
                            --For instance the answer no to the last discriminator in Green color Board sets the
                            --color to Blue
                            --An no answer with a urgency level sets the urgency level
                            --Only one no with a urgency level is allowed
                            l_current_triage_level                := l_rec_option.urgency_level;
                            o_result.triage_level.id_triage_color := l_rec_option.id_triage_color;
                            l_total_no_answers                    := l_total_no_answers + 1;
                            EXIT;
                        ELSIF l_rec_option.flg_selected_option = pk_alert_constant.g_no
                        THEN
                            l_total_no_answers := l_total_no_answers + 1;
                        END IF;
                    END LOOP;
                END IF;
            END LOOP;
        
            l_all_answers_are_no := (l_total_options = l_total_no_answers);
        ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_triage_board
              AND l_triage_board IS NOT NULL
              AND l_current_triage_level IS NULL --This means that there isn't any VS urgency level assigned
        THEN
            g_error := 'CALL GET_MIN_EST_LEVEL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_current_triage_level := get_min_est_level;
        END IF;
    
        IF i_rec_triage.id_triage_type IN (g_triage_id_ctas_p)
           AND l_tbl_critical_look_yes.exists(1)
        THEN
            -- verify the critical look level
            get_critical_look_level(o_result.triage_level.higher_vs_urgency_level);
        
            l_aux_triage_level := o_result.triage_level.higher_vs_urgency_level;
            IF (l_current_triage_level IS NULL AND l_aux_triage_level IS NOT NULL)
               OR (l_aux_triage_level < l_current_triage_level)
            THEN
                l_current_triage_level := l_aux_triage_level;
            END IF;
        
            o_result.triage_level.urgency_level_desc   := get_urgency_level_desc(i_lang          => i_lang,
                                                                                 i_urgency_level => l_current_triage_level,
                                                                                 i_triage_type   => i_rec_triage.id_triage_type);
            o_result.triage_level.current_triage_level := l_current_triage_level;
            SELECT tc.id_triage_color
              INTO o_result.triage_level.id_triage_color
              FROM triage_esi_level tel
              JOIN triage_color tc
                ON tel.id_triage_color = tc.id_triage_color
             WHERE tel.esi_level = l_current_triage_level
               AND tc.id_triage_type = l_rec_triage.id_triage_type;
            IF l_aux_triage_level = 1
            THEN
                o_result.flg_critical_look := pk_alert_constant.g_yes;
            END IF;
        END IF;
        g_error := 'CALL GET_DEFINING_CRITERIA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        o_result.triage_level.defining_criteria := get_defining_criteria(i_lang            => i_lang,
                                                                         i_tbl_grp_options => l_rec_triage.group_options,
                                                                         i_tbl_vital_signs => l_rec_triage.vital_signs,
                                                                         i_triage_type     => l_rec_triage.id_triage_type);
    
        g_error := 'CALL GET_OTHER_DEF_CRITERIA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        o_result.triage_level.other_defining_criteria := get_other_def_criteria(i_lang                   => i_lang,
                                                                                i_tbl_grp_options        => l_rec_triage.group_options,
                                                                                i_tbl_defining_criterias => o_result.triage_level.defining_criteria);
    
        IF o_result.triage_level.defining_criteria.exists(1)
        THEN
            IF i_rec_triage.id_triage_type IN (pk_edis_triage.g_triage_id_est, pk_edis_triage.g_triage_id_ctas_p)
            THEN
                g_error := 'CALL GET_BOARD_EMERG_LEVEL';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_aux_triage_level := get_board_emerg_level(i_patient               => i_rec_triage.id_patient,
                                                            i_episode               => i_rec_triage.id_episode,
                                                            i_triage_board          => i_rec_triage.id_triage_board,
                                                            i_tbl_defining_criteria => o_result.triage_level.defining_criteria);
            
                IF (l_current_triage_level IS NULL AND l_aux_triage_level IS NOT NULL)
                   OR (l_aux_triage_level < l_current_triage_level)
                THEN
                    l_current_triage_level := l_aux_triage_level;
                END IF;
            ELSIF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_esi
            THEN
                IF o_result.triage_level.defining_criteria(1).child_criteria.id_triage_color IS NOT NULL
                THEN
                    SELECT tel.esi_level
                      INTO l_current_triage_level
                      FROM triage_esi_level tel
                     WHERE tel.id_triage_color = o_result.triage_level.defining_criteria(1).child_criteria.id_triage_color;
                END IF;
            END IF;
        END IF;
    
        --We must select the higher urgency level
        IF l_current_triage_level IS NULL
           OR (o_result.triage_level.higher_vs_urgency_level IS NOT NULL AND
           o_result.triage_level.higher_vs_urgency_level < l_current_triage_level)
        THEN
            l_current_triage_level := o_result.triage_level.higher_vs_urgency_level;
        END IF;
    
        g_error := 'SET OUTPUT VAR WITH THE CURRENT TRIAGE LEVEL - ' || l_current_triage_level;
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        o_result.triage_level.current_triage_level := l_current_triage_level;
    
        IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
           AND l_triage_board IS NOT NULL
           AND o_result.triage_level.current_triage_level IS NULL
        THEN
            g_error := 'CALL GET_MIN_EST_LEVEL';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            o_result.triage_level.current_triage_level := get_min_est_level;
        END IF;
    
        g_error := 'SET CURRENT_TRIAGE_LEVEL';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
           AND l_triage_board IS NOT NULL
           AND o_result.triage_level.current_triage_level IS NOT NULL
        THEN
            IF l_all_answers_are_no
               AND o_result.triage_level.current_triage_level = g_est_min_vs_level
            THEN
                o_result.triage_level.flg_valid_board_level := pk_alert_constant.g_yes;
            ELSE
            
                SELECT COUNT(*)
                  INTO l_count_urg_level
                  FROM triage_board_acuity_lvl tbal
                  JOIN triage_esi_level tel
                    ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                 WHERE tbal.id_triage_board = l_triage_board
                   AND tbal.flg_available = pk_alert_constant.g_yes
                   AND tel.flg_available = pk_alert_constant.g_yes
                   AND tel.esi_level = o_result.triage_level.current_triage_level;
            
                IF l_count_urg_level = 0
                THEN
                    o_result.triage_level.flg_valid_board_level := pk_alert_constant.g_no;
                ELSE
                    o_result.triage_level.flg_valid_board_level := pk_alert_constant.g_yes;
                END IF;
            
                IF o_result.triage_level.higher_vs_urgency_level IS NOT NULL
                   AND o_result.triage_level.higher_vs_urgency_level > o_result.triage_level.current_triage_level
                   AND o_result.triage_level.higher_vs_urgency_level != g_est_min_vs_level
                   AND l_all_answers_are_no
                THEN
                    --verify if vs urgency level is a valid board level
                    SELECT COUNT(*)
                      INTO l_count_urg_level
                      FROM triage_board_acuity_lvl tbal
                      JOIN triage_esi_level tel
                        ON tel.id_triage_esi_level = tbal.id_triage_esi_level
                     WHERE tbal.id_triage_board = l_triage_board
                       AND tbal.flg_available = pk_alert_constant.g_yes
                       AND tel.flg_available = pk_alert_constant.g_yes
                       AND ((o_result.triage_level.higher_vs_urgency_level = g_est_min_vs_level AND
                           tel.esi_level IN (3, 4)) OR tel.esi_level = o_result.triage_level.higher_vs_urgency_level);
                
                    IF l_count_urg_level = 0
                    THEN
                        o_result.triage_level.flg_valid_board_level := pk_alert_constant.g_no;
                    ELSE
                        o_result.triage_level.flg_valid_board_level := pk_alert_constant.g_yes;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        --The system prompts the user about the vital signs incompatibility with the selected triage reason
        IF o_result.triage_level.flg_valid_board_level = pk_alert_constant.g_no
        THEN
            o_result.flg_show  := pk_alert_constant.g_yes;
            o_result.msg_title := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_title_vs_incomp_tb);
            o_result.msg       := pk_message.get_message(i_lang => i_lang, i_code_mess => l_code_msg_vs_incomp_tb);
            o_result.button    := NULL;
        END IF;
    
        g_error := 'SET TRIAGE_CAN_CHANGE_COLOR';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF l_rec_triage.triage_type_acronym IN (g_manchester, g_manchester_nl)
        THEN
            o_result.triage_level.triage_can_change_color := pk_alert_constant.g_no;
        ELSIF l_rec_triage.triage_type_acronym = pk_edis_triage.g_est
        THEN
            o_result.triage_level.triage_can_change_color := pk_alert_constant.g_yes;
        ELSE
            o_result.triage_level.triage_can_change_color := pk_edis_triage.get_triage_config_by_name(i_lang        => i_lang,
                                                                                                      i_prof        => i_prof,
                                                                                                      i_episode     => l_rec_triage.id_episode,
                                                                                                      i_triage_type => l_rec_triage.id_triage_type,
                                                                                                      i_config      => l_code_can_change_color);
        END IF;
    
        BEGIN
            SELECT DISTINCT tel.esi_level
              BULK COLLECT
              INTO l_tbl_triage_board_levels
              FROM triage_board_acuity_lvl tbal
              JOIN triage_esi_level tel
                ON tel.id_triage_esi_level = tbal.id_triage_esi_level
             WHERE tbal.id_triage_board = l_triage_board
               AND tbal.flg_available = pk_alert_constant.g_yes
               AND tel.flg_available = pk_alert_constant.g_yes;
        EXCEPTION
            WHEN no_data_found THEN
                l_tbl_triage_board_levels := table_number();
        END;
    
        g_error := 'FILL DEGREES TABLE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        FOR r_degree IN c_degrees(i_show_color_desc => pk_edis_triage.get_triage_config_by_name(i_lang        => i_lang,
                                                                                                i_prof        => i_prof,
                                                                                                i_episode     => l_rec_triage.id_episode,
                                                                                                i_triage_type => l_rec_triage.id_triage_type,
                                                                                                i_config      => l_code_show_color_desc))
        LOOP
            l_rec_degree.id_triage_color    := r_degree.id_triage_color;
            l_rec_degree.desc_triage_color  := r_degree.desc_triage_color;
            l_rec_degree.color              := r_degree.color;
            l_rec_degree.color_text         := r_degree.color_text;
            l_rec_degree.desc_accuity       := r_degree.desc_accuity;
            l_rec_degree.urgency_level      := r_degree.urgency_level;
            l_rec_degree.desc_time_max      := r_degree.desc_time_max;
            l_rec_degree.flg_show           := r_degree.flg_show;
            l_rec_degree.esi_level_header   := r_degree.esi_level_header;
            l_rec_degree.desc_reassess_time := r_degree.desc_reassess_time;
        
            IF i_rec_triage.id_triage_type IN (pk_edis_triage.g_triage_id_est, pk_edis_triage.g_triage_id_esi)
            THEN
                IF l_rec_degree.urgency_level = o_result.triage_level.current_triage_level
                THEN
                    l_rec_degree.flg_selected := pk_alert_constant.g_yes;
                ELSE
                    l_rec_degree.flg_selected := pk_alert_constant.g_no;
                END IF;
            ELSIF l_rec_degree.id_triage_color = o_result.triage_level.id_triage_color
            THEN
                l_rec_degree.flg_selected := pk_alert_constant.g_yes;
            ELSE
                l_rec_degree.flg_selected := pk_alert_constant.g_no;
            END IF;
        
            IF l_rec_degree.flg_selected = pk_alert_constant.g_yes
            THEN
                l_rec_degree.flg_active := pk_alert_constant.g_yes;
            ELSIF o_result.triage_level.triage_can_change_color = pk_alert_constant.g_no
            THEN
                l_rec_degree.flg_active := pk_alert_constant.g_no;
            ELSIF l_rec_degree.urgency_level <= o_result.triage_level.current_triage_level
                  AND i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_est
            THEN
                SELECT COUNT(*)
                  INTO l_count_urg_level
                  FROM TABLE(l_tbl_triage_board_levels) t
                 WHERE t.column_value = l_rec_degree.urgency_level;
            
                IF l_count_urg_level > 0
                THEN
                    l_rec_degree.flg_active := pk_alert_constant.g_yes;
                ELSE
                    l_rec_degree.flg_active := pk_alert_constant.g_no;
                END IF;
            ELSIF o_result.triage_level.triage_can_change_color = pk_alert_constant.g_yes
                  AND i_rec_triage.id_triage_type != pk_edis_triage.g_triage_id_est
            THEN
                l_rec_degree.flg_active := pk_alert_constant.g_yes;
            ELSE
                l_rec_degree.flg_active := pk_alert_constant.g_no;
            END IF;
        
            l_tbl_degrees.extend;
            l_tbl_degrees(l_tbl_degrees.count) := l_rec_degree;
        END LOOP;
    
        IF (i_rec_triage.id_triage_type NOT IN (pk_edis_triage.g_triage_id_est, pk_edis_triage.g_triage_id_esi) AND
           o_result.triage_level.id_triage_color IS NULL)
           OR (i_rec_triage.id_triage_type = pk_edis_triage.g_triage_id_esi AND
           o_result.triage_level.current_triage_level IS NULL)
        THEN
            l_tbl_degrees(l_tbl_degrees.count).flg_selected := pk_alert_constant.g_yes;
        END IF;
    
        o_result.triage_level.degrees := l_tbl_degrees;
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END check_triage;

    FUNCTION check_triage
    (
        i_lang   IN language.id_language%TYPE,
        i_prof   IN profissional,
        i_params IN CLOB,
        o_result OUT CLOB,
        o_error  OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'CHECK_TRIAGE';
        --
        l_rec_triage     pk_edis_types.rec_triage;
        l_rec_chk_result pk_edis_types.rec_chk_result;
        --
        l_exception     EXCEPTION;
        l_invalid_param EXCEPTION;
        --
        PROCEDURE validate_params IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'VALIDATE_PARAMS';
            --
            l_rec_check_option pk_edis_types.rec_check_option;
            l_rec_option       pk_edis_types.rec_option;
        BEGIN
            --CHECK ID_EPISODE
            IF l_rec_triage.id_episode IS NULL
            THEN
                g_error := 'MISSING ID_EPISODE';
                pk_alertlog.log_error(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                RAISE l_invalid_param;
            END IF;
        
            --CHECK_OPTIONS
            IF (l_rec_triage.check_vs.check_options IS NULL OR l_rec_triage.check_vs.check_options.count = 0)
               AND l_rec_triage.check_vs.flg_type IS NULL
            THEN
                --The purpose of this call is not the validation of vital signs but only get the level of triage 
                NULL;
            ELSIF (l_rec_triage.check_vs.check_options IS NULL OR l_rec_triage.check_vs.check_options.count = 0)
                  AND l_rec_triage.check_vs.flg_type NOT IN
                  (pk_edis_triage.g_flg_context_id_ds_component, g_flg_context_check_critical)
            THEN
                g_error := 'THERE IS NO OPTIONS TO CHECK';
                pk_alertlog.log_error(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                RAISE l_invalid_param;
            ELSE
                IF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_ds_component
                THEN
                    --In the form check there is no option, so I'm removing possible options sent by flash that shouldn't been sent
                    --To prevent errors I will initialize the table and add a record with all attributes with null value
                    g_error := 'VALIDATE FORM PARAM';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    l_rec_check_option.id_triage_board         := NULL;
                    l_rec_check_option.id_triage_discriminator := NULL;
                    l_rec_triage.check_vs.check_options        := pk_edis_types.table_check_options(l_rec_check_option);
                ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_triage_board
                THEN
                    g_error := 'VALIDATE BOARD PARAM';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                    LOOP
                        l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                    
                        IF l_rec_check_option.id_triage_board IS NULL
                        THEN
                            g_error := 'MISSING ID_TRIAGE_BOARD IN CHECK OPTION';
                            pk_alertlog.log_error(object_name     => g_package_name,
                                                  sub_object_name => l_inner_proc_name,
                                                  text            => g_error);
                            RAISE l_invalid_param;
                        END IF;
                    
                        IF l_rec_check_option.id_triage_discriminator IS NOT NULL
                        THEN
                            l_rec_check_option.id_triage_discriminator := NULL;
                            l_rec_triage.check_vs.check_options(i) := l_rec_check_option;
                        END IF;
                    END LOOP;
                ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_triage_disc
                THEN
                    g_error := 'VALIDATE DISCRIMINATOR PARAM';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                    LOOP
                        l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                    
                        IF l_rec_check_option.id_triage_board IS NOT NULL
                        THEN
                            l_rec_check_option.id_triage_board := NULL;
                            l_rec_triage.check_vs.check_options(i) := l_rec_check_option;
                        END IF;
                    
                        IF l_rec_check_option.id_triage_discriminator IS NULL
                        THEN
                            g_error := 'MISSING ID_TRIAGE_DISCRIMINATOR IN CHECK OPTION';
                            pk_alertlog.log_error(object_name     => g_package_name,
                                                  sub_object_name => l_inner_proc_name,
                                                  text            => g_error);
                            RAISE l_invalid_param;
                        END IF;
                    END LOOP;
                ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_check_all
                THEN
                    g_error := 'VALIDATE CHECK_ALL PARAM';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                    LOOP
                        l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                    
                        IF l_rec_check_option.id_triage_board IS NOT NULL
                           AND l_rec_check_option.id_triage_discriminator IS NOT NULL
                        THEN
                            g_error := 'ONLY ONE OF ATTRIBUTES (BOARD AND DISCRIM) CAN BE FILLED';
                            pk_alertlog.log_error(object_name     => g_package_name,
                                                  sub_object_name => l_inner_proc_name,
                                                  text            => g_error);
                            RAISE l_invalid_param;
                        END IF;
                    
                        IF l_rec_check_option.id_triage_board IS NULL
                           AND l_rec_check_option.id_triage_discriminator IS NULL
                           AND l_rec_triage.id_triage_type NOT IN (g_triage_id_ctas_p, g_triage_id_ctas_a)
                        THEN
                            g_error := 'ONE OF ATTRIBUTES (BOARD OR DISCRIM) MUST BE FILLED';
                            pk_alertlog.log_error(object_name     => g_package_name,
                                                  sub_object_name => l_inner_proc_name,
                                                  text            => g_error);
                            RAISE l_invalid_param;
                        END IF;
                    END LOOP;
                ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_check_critical
                THEN
                    l_rec_check_option.id_triage_board         := NULL;
                    l_rec_check_option.id_triage_discriminator := NULL;
                    l_rec_triage.check_vs.check_options        := pk_edis_types.table_check_options(l_rec_check_option);
                ELSE
                    g_error := 'INVALID CHECK TYPE';
                    pk_alertlog.log_error(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    RAISE l_invalid_param;
                END IF;
            END IF;
        
            --OPTIONS VALIDATION
            IF l_rec_triage.group_options IS NOT NULL
               AND l_rec_triage.group_options.count > 0
            THEN
                FOR i IN l_rec_triage.group_options.first .. l_rec_triage.group_options.last
                LOOP
                    IF l_rec_triage.group_options(i).options IS NOT NULL
                        AND l_rec_triage.group_options(i).options.count > 0
                    THEN
                        FOR j IN l_rec_triage.group_options(i).options.first .. l_rec_triage.group_options(i).options.last
                        LOOP
                            l_rec_option := l_rec_triage.group_options(i).options(j);
                        
                            IF l_rec_option.id_triage_discriminator IS NULL
                            THEN
                                g_error := 'ID_TRIAGE_DISCRIMINATOR MISSING IN OPTION';
                                pk_alertlog.log_error(object_name     => g_package_name,
                                                      sub_object_name => l_inner_proc_name,
                                                      text            => g_error);
                                RAISE l_invalid_param;
                            END IF;
                        END LOOP;
                    END IF;
                END LOOP;
            END IF;
        END validate_params;
        --
        PROCEDURE fill_missing_data IS
            l_inner_proc_name CONSTANT VARCHAR2(30) := 'FILL_MISSING_DATA';
            --
            l_patient_age NUMBER(4, 1);
            l_dt_birth    patient.dt_birth%TYPE;
            --
            l_rec_check_option pk_edis_types.rec_check_option;
            l_rec_option_g     pk_edis_types.rec_option;
            --
            FUNCTION get_accepted_option
            (
                i_triage_board         IN triage_board.id_triage_board%TYPE,
                i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE
            ) RETURN VARCHAR2 IS
                l_ret VARCHAR2(1);
            BEGIN
                SELECT nvl(t.flg_accepted_option, pk_alert_constant.g_yes) -- The default acceptance option is "YES" 
                  INTO l_ret
                  FROM triage t
                 WHERE t.id_triage_discriminator = i_triage_discriminator
                   AND (t.id_triage_board = i_triage_board OR i_triage_board IS NULL)
                   AND t.flg_available = pk_alert_constant.g_yes;
            
                RETURN l_ret;
            END get_accepted_option;
        
            FUNCTION get_board_desc(i_triage_board IN triage_board.id_triage_board%TYPE) RETURN VARCHAR2 IS
                l_ret pk_translation.t_desc_translation;
            BEGIN
                SELECT pk_translation.get_translation(i_lang, td.code_triage_board)
                  INTO l_ret
                  FROM triage_board td
                 WHERE td.id_triage_board = i_triage_board;
            
                RETURN l_ret;
            END get_board_desc;
        
            FUNCTION get_discriminator_desc(i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE)
                RETURN VARCHAR2 IS
                l_ret pk_translation.t_desc_translation;
            BEGIN
                SELECT pk_translation.get_translation(i_lang, td.code_triage_discriminator)
                  INTO l_ret
                  FROM triage_discriminator td
                 WHERE td.id_triage_discriminator = i_triage_discriminator;
            
                RETURN l_ret;
            END get_discriminator_desc;
        
            FUNCTION get_discriminator_answer(i_triage_discriminator IN triage_discriminator.id_triage_discriminator%TYPE)
                RETURN pk_edis_types.rec_option IS
                l_rec_group_option pk_edis_types.rec_group_option;
                l_rec_option       pk_edis_types.rec_option;
                --
                l_found BOOLEAN := FALSE;
            BEGIN
                IF l_rec_triage.group_options IS NOT NULL
                   AND l_rec_triage.group_options.count > 0
                THEN
                    FOR i IN l_rec_triage.group_options.first .. l_rec_triage.group_options.last
                    LOOP
                        l_rec_group_option := l_rec_triage.group_options(i);
                    
                        IF l_rec_group_option.options IS NOT NULL
                           AND l_rec_group_option.options.count > 0
                        THEN
                            FOR j IN l_rec_group_option.options.first .. l_rec_group_option.options.last
                            LOOP
                                l_rec_option := l_rec_group_option.options(j);
                            
                                IF i_triage_discriminator IN
                                   (l_rec_option.id_triage_discriminator,
                                    l_rec_option.child_option.id_triage_discriminator)
                                THEN
                                    l_found := TRUE;
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            IF l_found
                            THEN
                                EXIT;
                            END IF;
                        END IF;
                    END LOOP;
                END IF;
            
                IF l_found
                THEN
                    RETURN l_rec_option;
                ELSE
                    --This validation is here and not in the validate_params function to prevent an additional loop through the same tables
                    g_error := 'MISSING USER ANSWER TO ID_TRIAGE_DISCRIMINATOR: ' || i_triage_discriminator;
                    pk_alertlog.log_error(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    RAISE l_invalid_param;
                END IF;
            END get_discriminator_answer;
        BEGIN
            --ID_PATIENT
            IF l_rec_triage.id_patient IS NULL
            THEN
                l_rec_triage.id_patient := pk_episode.get_id_patient(i_episode => l_rec_triage.id_episode);
            END IF;
        
            --PATIENT_AGE
            IF l_rec_triage.patient_age IS NULL
            THEN
                g_error := 'GET PATIENT_AGE';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                SELECT nvl(p.age, trunc(months_between(SYSDATE, p.dt_birth) / 12)) age, p.dt_birth
                  INTO l_patient_age, l_dt_birth
                  FROM patient p
                 WHERE p.id_patient = l_rec_triage.id_patient;
            
                IF l_patient_age = 0
                THEN
                    g_error := 'GET PATIENT MONTHS';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_proc_name,
                                          text            => g_error);
                    l_patient_age := trunc(nvl(months_between(SYSDATE, l_dt_birth), 0) / 12, 2);
                END IF;
            
                g_error := 'SET PATIENT_AGE';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                l_rec_triage.patient_age := l_patient_age;
            END IF;
        
            --TRIAGE_TYPE
            IF l_rec_triage.id_triage_type IS NULL
            THEN
                g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_CONFIG_BY_NAME - GET ID_TRIAGE_TYPE';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                l_rec_triage.id_triage_type := pk_edis_triage.get_triage_config_by_name(i_lang        => i_lang,
                                                                                        i_prof        => i_prof,
                                                                                        i_episode     => l_rec_triage.id_episode,
                                                                                        i_triage_type => NULL,
                                                                                        i_config      => 'ID_TRIAGE_TYPE');
            END IF;
        
            --TRIAGE_TYPE_ACRONYM
            IF l_rec_triage.triage_type_acronym IS NULL
            THEN
                g_error := 'GET TRIAGE_TYPE ACRONYM';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                SELECT tt.acronym
                  INTO l_rec_triage.triage_type_acronym
                  FROM triage_type tt
                 WHERE tt.id_triage_type = l_rec_triage.id_triage_type;
            END IF;
        
            --FILL OPTION                                                                                  
            IF l_rec_triage.group_options IS NOT NULL
               AND l_rec_triage.group_options.count > 0
            THEN
                FOR i IN l_rec_triage.group_options.first .. l_rec_triage.group_options.last
                LOOP
                    IF l_rec_triage.group_options(i).options IS NOT NULL
                        AND l_rec_triage.group_options(i).options.count > 0
                    THEN
                        FOR j IN l_rec_triage.group_options(i).options.first .. l_rec_triage.group_options(i).options.last
                        LOOP
                            l_rec_option_g := l_rec_triage.group_options(i).options(j);
                        
                            l_rec_option_g.desc_triage_discriminator := get_discriminator_desc(i_triage_discriminator => l_rec_option_g.id_triage_discriminator);
                        
                            SELECT tdc.*
                              BULK COLLECT
                              INTO l_rec_option_g.discr_consent_values
                              FROM triage_disc_consent tdc
                             WHERE tdc.id_triage_discriminator = l_rec_option_g.id_triage_discriminator
                               AND EXISTS (SELECT 1
                                      FROM triage_cons_value tcv
                                     WHERE tcv.id_triage_cons_value = tdc.id_triage_cons_value);
                        
                            IF l_rec_option_g.discr_consent_values.count = 0
                               AND l_rec_option_g.id_triage_cons_value IS NOT NULL
                            THEN
                                --This validation is here and not in the validate_params function to prevent an additional loop through the same tables
                                --This means that there is no consent configure for the current triage_discriminator, 
                                --so it shouldn't have any selected consent anwser from user
                                g_error := 'CURRENT DISCRIMINATOR DOESN''T NEED ANY CONSENT BUT CONSENT INPUT PARAMETER HAS A VALUE';
                                RAISE l_invalid_param;
                            END IF;
                        
                            l_rec_triage.group_options(i).options(j) := l_rec_option_g;
                        END LOOP;
                    END IF;
                END LOOP;
            END IF;
        
            --CHECK_OPTIONS
            IF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_triage_board
            THEN
                g_error := 'SET DESC_BOARD';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                LOOP
                    l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                    l_rec_check_option.desc_option := get_board_desc(i_triage_board => l_rec_check_option.id_triage_board);
                    l_rec_triage.check_vs.check_options(i) := l_rec_check_option;
                END LOOP;
            ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_id_triage_disc
            THEN
                g_error := 'SET FLG_ACCEPTED_OPTION AND DESC_DISCRIMINATOR';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                LOOP
                    l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                
                    l_rec_check_option.flg_accepted_option  := get_accepted_option(i_triage_board         => l_rec_triage.id_triage_board,
                                                                                   i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                    l_rec_check_option.desc_option          := get_discriminator_desc(i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                    l_rec_check_option.discriminator_answer := get_discriminator_answer(i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                
                    l_rec_triage.check_vs.check_options(i) := l_rec_check_option;
                END LOOP;
            ELSIF l_rec_triage.check_vs.flg_type = pk_edis_triage.g_flg_context_check_all
            THEN
                g_error := 'SET FLG_ACCEPTED_OPTION AND DESC_DISCRIMINATOR OR DESC_BOARD';
                pk_alertlog.log_debug(object_name     => g_package_name,
                                      sub_object_name => l_inner_proc_name,
                                      text            => g_error);
                IF l_rec_triage.check_vs.check_options IS NOT NULL
                   AND l_rec_triage.check_vs.check_options.count > 0
                THEN
                    FOR i IN l_rec_triage.check_vs.check_options.first .. l_rec_triage.check_vs.check_options.last
                    LOOP
                        l_rec_check_option := l_rec_triage.check_vs.check_options(i);
                    
                        IF l_rec_check_option.id_triage_discriminator IS NOT NULL
                        THEN
                            l_rec_check_option.flg_accepted_option  := get_accepted_option(i_triage_board         => l_rec_triage.id_triage_board,
                                                                                           i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                            l_rec_check_option.desc_option          := get_discriminator_desc(i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                            l_rec_check_option.discriminator_answer := get_discriminator_answer(i_triage_discriminator => l_rec_check_option.id_triage_discriminator);
                        ELSE
                            IF l_rec_check_option.id_triage_board IS NOT NULL
                            THEN
                                l_rec_check_option.desc_option := get_board_desc(i_triage_board => l_rec_check_option.id_triage_board);
                            END IF;
                        END IF;
                    
                        l_rec_triage.check_vs.check_options(i) := l_rec_check_option;
                    END LOOP;
                END IF;
            END IF;
        
            --FLG_CHECK_VITAL_SIGN
            g_error := 'CALL PK_EDIS_TRIAGE.GET_TRIAGE_CONFIG_BY_NAME - GET FLG_CHECK_VITAL_SIGN';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_proc_name, text => g_error);
            l_rec_triage.check_vs.flg_check_vital_sign := pk_edis_triage.get_triage_config_by_name(i_lang        => i_lang,
                                                                                                   i_prof        => i_prof,
                                                                                                   i_episode     => l_rec_triage.id_episode,
                                                                                                   i_triage_type => l_rec_triage.id_triage_type,
                                                                                                   i_config      => 'FLG_CHECK_VITAL_SIGN');
        END fill_missing_data;
        --
        --Output example
        --<OUT_PARAMS>
        --  <MESSAGE FLG_SHOW="" TITLE="" MSG="" BUTTON="" RANK=""/>
        --  <OPTION ID_TRIAGE_VS_AREA="" SELECT_OPTION="" FLG_ACCEPTED_OPTION=""/>
        --  <ESI ID_TRIAGE_DISCRIM="" DESC_DISCRIM="" ID_TRIAGE=""/>
        --  <VITAL_SIGNS DETAIL_SCHEMA_PARENT_NODE="">
        --    <VITAL_SIGN ID_VITAL_SIGN="" URGENCY_LEVEL="" URGENCY_LEVEL_DESC="" VALUE="" DESC_VALUE="" FLG_ACTIVE="" />
        --  </VITAL_SIGNS>
        --  <TRIAGE_LEVEL CURRENT_TRIAGE_LEVEL="" HIGHER_VS_URGENCY_LEVEL="" URGENCY_LEVEL_DESC="" FLG_VALID_BOARD_LEVEL="" >
        --    <DEGREES>
        --      <DEGREE URGENCY_LEVEL="" ID_TRIAGE_COLOR="" FLG_SELECTED="" FLG_ACTIVE="" />
        --    </DEGREES>
        --    <DEFINING_CRITERIA>
        --      <CRITERIA ID_TRIAGE_DISCRIMINATOR="" DESC_CRITERIA="" DISCRIM_ANSWER="" DESC_DISCRIM_ANSWER="">
        --        <CHILD_CRITERIA ID_TRIAGE_DISCRIMINATOR="" DESC_CRITERIA="" DISCRIM_ANSWER="" DESC_DISCRIM_ANSWER="" />
        --      </CRITERIA>
        --    </DEFINING_CRITERIA>
        --    <OTHER_DEFINING_CRITERIA>
        --      <CRITERIA ID_TRIAGE_DISCRIMINATOR="" DESC_CRITERIA="" DISCRIM_ANSWER="" DESC_DISCRIM_ANSWER="" />
        --    </OTHER_DEFINING_CRITERIA>
        --  </TRIAGE_LEVEL>
        --</OUT_PARAMS>
        --
        FUNCTION get_out_param
        (
            i_triage_type_acronym IN triage_type.acronym%TYPE,
            i_rec_chk_vs          IN pk_edis_types.rec_check_vital_signs,
            i_rec_chk_result      IN pk_edis_types.rec_chk_result
        ) RETURN CLOB IS
            l_inner_func CONSTANT VARCHAR2(30) := 'GET_OUT_PARAM';
            --
            l_doc                 xmldom.domdocument;
            l_main_node           xmldom.domnode;
            l_root_node           xmldom.domnode;
            l_param_node          xmldom.domnode;
            l_subparam_node       xmldom.domnode;
            l_subsubparam_node    xmldom.domnode; -- :)
            l_subsubsubparam_node xmldom.domnode; -- :)
            l_item_elmt           xmldom.domelement;
            --
            l_code_msg_level CONSTANT sys_message.code_message%TYPE := 'TRIAGE_EST_M004';
            l_msg_level sys_message.desc_message%TYPE := pk_message.get_message(i_lang      => i_lang,
                                                                                i_code_mess => l_code_msg_level);
            --
            l_ret CLOB;
            --
            PROCEDURE add_attribute
            (
                i_name       IN VARCHAR2,
                i_value      IN VARCHAR2,
                io_item_elmt IN OUT xmldom.domelement
            ) IS
            BEGIN
                IF i_value IS NOT NULL
                THEN
                    xmldom.setattribute(io_item_elmt, i_name, i_value);
                END IF;
            END add_attribute;
        BEGIN
            g_error := 'ADD ROOT ELEMENT';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            l_doc       := xmldom.newdomdocument;
            l_main_node := xmldom.makenode(l_doc);
            l_item_elmt := xmldom.createelement(l_doc, 'OUT_PARAMS');
        
            l_root_node := xmldom.appendchild(l_main_node, xmldom.makenode(l_item_elmt));
        
            g_error := 'ADD MESSAGE NODE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            l_item_elmt := xmldom.createelement(l_doc, 'MESSAGE');
        
            add_attribute(io_item_elmt => l_item_elmt, i_name => 'FLG_SHOW', i_value => i_rec_chk_result.flg_show);
            add_attribute(io_item_elmt => l_item_elmt, i_name => 'TITLE', i_value => i_rec_chk_result.msg_title);
            add_attribute(io_item_elmt => l_item_elmt, i_name => 'MSG', i_value => i_rec_chk_result.msg);
            add_attribute(io_item_elmt => l_item_elmt, i_name => 'BUTTON', i_value => i_rec_chk_result.button);
            add_attribute(io_item_elmt => l_item_elmt, i_name => 'RANK', i_value => i_rec_chk_result.msg_rank);
        
            l_param_node := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
            l_item_elmt  := xmldom.createelement(l_doc, 'CONFIRMATION');
            -- IF i_rec_chk_result.flg_critical_look = PK_ALERT_CONSTANT.G_YES THEN 
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'FLG_FORCE',
                          i_value      => i_rec_chk_result.flg_critical_look);
            -- END IF;
            l_param_node := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
            IF i_rec_chk_vs.flg_type != pk_edis_triage.g_flg_context_check_all
            THEN
                g_error := 'ADD OPTION NODE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
                l_item_elmt := xmldom.createelement(l_doc, 'OPTION');
            
                IF i_triage_type_acronym != pk_edis_triage.g_esi
                THEN
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE_VS_AREA',
                                  i_value      => i_rec_chk_result.id_triage_vs_area);
                END IF;
            
                IF i_triage_type_acronym IN
                   (pk_edis_triage.g_est, pk_edis_triage.g_esi, pk_edis_triage.g_ctas_ped, g_ctas_adult)
                THEN
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_PARENT_TRIAGE_DISCRIMINATOR',
                                  i_value      => i_rec_chk_result.id_parent_tri_discrim);
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE_DISCRIMINATOR',
                                  i_value      => i_rec_chk_result.id_triage_discrim);
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_TRIAGE_DISCRIMINATOR',
                                  i_value      => i_rec_chk_result.desc_discrim);
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE',
                                  i_value      => i_rec_chk_result.id_triage);
                END IF;
            
                add_attribute(io_item_elmt => l_item_elmt,
                              i_name       => 'SELECT_OPTION',
                              i_value      => i_rec_chk_result.select_option);
                add_attribute(io_item_elmt => l_item_elmt,
                              i_name       => 'FLG_ACCEPTED_OPTION',
                              i_value      => i_rec_chk_result.flg_accepted_option);
            
                l_param_node := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
            END IF;
        
            g_error := 'ADD VITAL_SIGNS NODE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            l_item_elmt := xmldom.createelement(l_doc, 'VITAL_SIGNS');
        
            l_param_node := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
        
            IF i_rec_chk_result.vital_signs IS NOT NULL
               AND i_rec_chk_result.vital_signs.count > 0
            THEN
                g_error := 'SET DETAIL_SCHEMA_PARENT_NODE ID';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
                add_attribute(io_item_elmt => l_item_elmt,
                              i_name       => 'DETAIL_SCHEMA_PARENT_NODE',
                              i_value      => g_ds_vs_node_pk);
            
                FOR i IN i_rec_chk_result.vital_signs.first .. i_rec_chk_result.vital_signs.last
                LOOP
                    g_error := 'ADD VITAL_SIGN NODE';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_func,
                                          text            => g_error);
                    l_item_elmt := xmldom.createelement(l_doc, 'VITAL_SIGN');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_VITAL_SIGN',
                                  i_value      => i_rec_chk_result.vital_signs(i).id_vital_sign);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'URGENCY_LEVEL',
                                  i_value      => i_rec_chk_result.vital_signs(i).urgency_level);
                
                    IF i_rec_chk_result.vital_signs(i).urgency_level IS NOT NULL
                    THEN
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'URGENCY_LEVEL_DESC',
                                      i_value      => '(' || l_msg_level || ' ' ||
                                                     
                                                      CASE i_rec_chk_result.vital_signs(i).urgency_level
                                                          WHEN g_est_min_vs_level THEN
                                                           pk_message.get_message(i_lang      => i_lang,
                                                                                  i_code_mess => g_code_msg_level_3_and_4)
                                                          ELSE
                                                           to_char(i_rec_chk_result.vital_signs(i).urgency_level)
                                                      END || ')');
                    END IF;
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'VALUE',
                                  i_value      => i_rec_chk_result.vital_signs(i).value);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_VALUE',
                                  i_value      => i_rec_chk_result.vital_signs(i).desc_value);
                
                    l_subparam_node := xmldom.appendchild(l_param_node, xmldom.makenode(l_item_elmt));
                END LOOP;
            END IF;
        
            g_error := 'ADD TRIAGE_LEVEL NODE';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            l_item_elmt := xmldom.createelement(l_doc, 'TRIAGE_LEVEL');
        
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'CURRENT_TRIAGE_LEVEL',
                          i_value      => i_rec_chk_result.triage_level.current_triage_level);
        
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'HIGHER_VS_URGENCY_LEVEL',
                          i_value      => i_rec_chk_result.triage_level.higher_vs_urgency_level);
        
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'URGENCY_LEVEL_DESC',
                          i_value      => i_rec_chk_result.triage_level.urgency_level_desc);
        
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'FLG_VALID_BOARD_LEVEL',
                          i_value      => i_rec_chk_result.triage_level.flg_valid_board_level);
        
            add_attribute(io_item_elmt => l_item_elmt,
                          i_name       => 'TRIAGE_CAN_CHANGE_COLOR',
                          i_value      => i_rec_chk_result.triage_level.triage_can_change_color);
        
            l_param_node := xmldom.appendchild(l_root_node, xmldom.makenode(l_item_elmt));
        
            IF i_rec_chk_result.triage_level.degrees IS NOT NULL
               AND i_rec_chk_result.triage_level.degrees.count > 0
            THEN
                g_error := 'ADD DEGREES NODE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
                l_item_elmt := xmldom.createelement(l_doc, 'DEGREES');
            
                l_subparam_node := xmldom.appendchild(l_param_node, xmldom.makenode(l_item_elmt));
            
                FOR i IN i_rec_chk_result.triage_level.degrees.first .. i_rec_chk_result.triage_level.degrees.last
                LOOP
                    g_error := 'ADD DEGREE NODE';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_func,
                                          text            => g_error);
                    l_item_elmt := xmldom.createelement(l_doc, 'DEGREE');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE_COLOR',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).id_triage_color);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_TRIAGE_COLOR',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).desc_triage_color);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'COLOR',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).color);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'COLOR_TEXT',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).color_text);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_ACCUITY',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).desc_accuity);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'URGENCY_LEVEL',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).urgency_level);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_TIME_MAX',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).desc_time_max);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_REASSESS_TIME',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).desc_reassess_time);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'FLG_SHOW',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).flg_show);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ESI_LEVEL_HEADER',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).esi_level_header);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'FLG_SELECTED',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).flg_selected);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'FLG_ACTIVE',
                                  i_value      => i_rec_chk_result.triage_level.degrees(i).flg_active);
                
                    l_subsubparam_node := xmldom.appendchild(l_subparam_node, xmldom.makenode(l_item_elmt));
                END LOOP;
            END IF;
        
            IF i_rec_chk_result.triage_level.defining_criteria IS NOT NULL
               AND i_rec_chk_result.triage_level.defining_criteria.count > 0
            THEN
                g_error := 'ADD DEFINING_CRITERIA NODE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
                l_item_elmt := xmldom.createelement(l_doc, 'DEFINING_CRITERIA');
            
                l_subparam_node := xmldom.appendchild(l_param_node, xmldom.makenode(l_item_elmt));
            
                FOR i IN i_rec_chk_result.triage_level.defining_criteria.first .. i_rec_chk_result.triage_level.defining_criteria.last
                LOOP
                    g_error := 'ADD CRITERIA NODE';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_func,
                                          text            => g_error);
                    l_item_elmt := xmldom.createelement(l_doc, 'CRITERIA');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE_DISCRIMINATOR',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).id_triage_discriminator);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_CRITERIA',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).desc_criteria);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DISCRIM_ANSWER',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).discrim_answer);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_DISCRIM_ANSWER',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).desc_discrim_answer);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'FLG_CRITICAL_LOOK',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).flg_critical_look);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'BOX',
                                  i_value      => i_rec_chk_result.triage_level.defining_criteria(i).box);
                
                    l_subsubparam_node := xmldom.appendchild(l_subparam_node, xmldom.makenode(l_item_elmt));
                
                    IF i_rec_chk_result.triage_level.defining_criteria(i).child_criteria.id_triage_discriminator IS NOT NULL
                    THEN
                        g_error := 'ADD CHILD_CRITERIA NODE';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_inner_func,
                                              text            => g_error);
                        l_item_elmt := xmldom.createelement(l_doc, 'CHILD_CRITERIA');
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'ID_TRIAGE_DISCRIMINATOR',
                                      i_value      => i_rec_chk_result.triage_level.defining_criteria(i).child_criteria.id_triage_discriminator);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DESC_CRITERIA',
                                      i_value      => i_rec_chk_result.triage_level.defining_criteria(i).child_criteria.desc_discriminator);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DISCRIM_ANSWER',
                                      i_value      => i_rec_chk_result.triage_level.defining_criteria(i).child_criteria.flg_accepted_option);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DESC_DISCRIM_ANSWER',
                                      i_value      => i_rec_chk_result.triage_level.defining_criteria(i).child_criteria.desc_accepted_option);
                    
                        l_subsubsubparam_node := xmldom.appendchild(l_subsubparam_node, xmldom.makenode(l_item_elmt));
                    END IF;
                END LOOP;
            END IF;
        
            IF i_rec_chk_result.triage_level.other_defining_criteria IS NOT NULL
               AND i_rec_chk_result.triage_level.other_defining_criteria.count > 0
            THEN
                g_error := 'ADD OTHER_DEFINING_CRITERIA NODE';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
                l_item_elmt := xmldom.createelement(l_doc, 'OTHER_DEFINING_CRITERIA');
            
                l_subparam_node := xmldom.appendchild(l_param_node, xmldom.makenode(l_item_elmt));
            
                FOR i IN i_rec_chk_result.triage_level.other_defining_criteria.first .. i_rec_chk_result.triage_level.other_defining_criteria.last
                LOOP
                    g_error := 'ADD CRITERIA NODE';
                    pk_alertlog.log_debug(object_name     => g_package_name,
                                          sub_object_name => l_inner_func,
                                          text            => g_error);
                    l_item_elmt := xmldom.createelement(l_doc, 'CRITERIA');
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'ID_TRIAGE_DISCRIMINATOR',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).id_triage_discriminator);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_CRITERIA',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).desc_criteria);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DISCRIM_ANSWER',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).discrim_answer);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'DESC_DISCRIM_ANSWER',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).desc_discrim_answer);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'FLG_CRITICAL_LOOK',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).flg_critical_look);
                
                    add_attribute(io_item_elmt => l_item_elmt,
                                  i_name       => 'BOX',
                                  i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).box);
                
                    l_subsubparam_node := xmldom.appendchild(l_subparam_node, xmldom.makenode(l_item_elmt));
                
                    IF i_rec_chk_result.triage_level.other_defining_criteria(i).child_criteria.id_triage_discriminator IS NOT NULL
                    THEN
                        g_error := 'ADD CHILD_CRITERIA NODE';
                        pk_alertlog.log_debug(object_name     => g_package_name,
                                              sub_object_name => l_inner_func,
                                              text            => g_error);
                        l_item_elmt := xmldom.createelement(l_doc, 'CHILD_CRITERIA');
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'ID_TRIAGE_DISCRIMINATOR',
                                      i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).child_criteria.id_triage_discriminator);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DESC_CRITERIA',
                                      i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).child_criteria.desc_discriminator);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DISCRIM_ANSWER',
                                      i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).child_criteria.flg_accepted_option);
                    
                        add_attribute(io_item_elmt => l_item_elmt,
                                      i_name       => 'DESC_DISCRIM_ANSWER',
                                      i_value      => i_rec_chk_result.triage_level.other_defining_criteria(i).child_criteria.desc_accepted_option);
                    
                        l_subsubsubparam_node := xmldom.appendchild(l_subsubparam_node, xmldom.makenode(l_item_elmt));
                    END IF;
                END LOOP;
            END IF;
        
            g_error := 'WRITE XML DOC TO CLOB';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_inner_func, text => g_error);
            dbms_lob.createtemporary(l_ret, TRUE);
            xmldom.writetoclob(l_doc, l_ret);
            xmldom.freedocument(l_doc);
        
            RETURN l_ret;
        END get_out_param;
    BEGIN
        g_error := 'CALL PK_EDIS_TRIAGE.PARSE_TRIAGE_PARAMETERS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT pk_edis_triage.parse_triage_parameters(i_lang       => i_lang,
                                                      i_prof       => i_prof,
                                                      i_params     => i_params,
                                                      o_rec_triage => l_rec_triage,
                                                      o_error      => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'CALL VALIDATE_PARAMS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        validate_params;
    
        g_error := 'CALL FILL_MISSING_DATA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        fill_missing_data;
    
        g_error := 'CALL PK_EDIS_TRIAGE.CHECK_VITAL_SIGNS';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT check_triage(i_lang       => i_lang,
                            i_prof       => i_prof,
                            i_rec_triage => l_rec_triage,
                            o_result     => l_rec_chk_result,
                            o_error      => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'CALL GET_OUT_PARAM';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        o_result := get_out_param(i_triage_type_acronym => l_rec_triage.triage_type_acronym,
                                  i_rec_chk_vs          => l_rec_triage.check_vs,
                                  i_rec_chk_result      => l_rec_chk_result);
    
        RETURN TRUE;
    EXCEPTION
        WHEN l_exception THEN
            RETURN FALSE;
        WHEN l_invalid_param THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => '-20100',
                                              i_sqlerrm  => 'INVALID PARAMETER',
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang     => i_lang,
                                              i_sqlcode  => SQLCODE,
                                              i_sqlerrm  => SQLERRM,
                                              i_message  => g_error,
                                              i_owner    => g_owner,
                                              i_package  => g_package_name,
                                              i_function => l_func_name,
                                              o_error    => o_error);
            RETURN FALSE;
    END check_triage;
    /**
    * Get triage description.
    * Used for the task timeline easy access (HandP import mechanism).
    *
    * @param i_lang              language identifier
    * @param i_prof              logged professional structure
    * @param i_id_epis_triage    id_epis_triage identifier
    * @param i_desc_type         desc_type S-short/L-long
    *
    * @return               Triage description
    *
    * @author               Sergio Dias
    * @version              2.6.3.5
    * @since                24/05/2013
    */
    FUNCTION get_task_description
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_triage IN epis_triage.id_epis_triage%TYPE,
        i_desc_type      IN VARCHAR2
    ) RETURN CLOB IS
        l_func_name VARCHAR2(30) := 'GET_TASK_DESCRIPTION';
        l_ret       CLOB;
        l_triage    pk_edis_types.rec_triage;
        o_error     t_error_out;
        l_exception EXCEPTION;
        --
        l_flowchart     sys_domain.desc_val%TYPE;
        l_discriminator sys_domain.desc_val%TYPE;
        l_internal_error EXCEPTION;
        l_dummy    VARCHAR2(2000);
        l_other    sys_domain.desc_val%TYPE;
        l_criteria translation.desc_lang_1%TYPE;
    
        l_detail_schema          t_table_ds_sections;
        l_last_node_used         VARCHAR2(200) := '';
        l_last_node_loaded_value BOOLEAN := FALSE;
        l_final_item_value       VARCHAR2(2000) := '';
        l_new_node_title         VARCHAR2(200) := '';
        l_new_node_internal_name VARCHAR2(200) := '';
        l_title_type             VARCHAR(2 CHAR);
    
        CURSOR c_epis_triage IS
            SELECT et.id_epis_triage,
                   et.dt_begin_tstz,
                   t.id_triage_type,
                   tt.acronym,
                   td.id_triage_discriminator,
                   td.id_parent,
                   td.code_triage_discriminator,
                   et.flg_selected_option,
                   t.id_triage,
                   et.id_episode,
                   et.id_triage_color,
                   get_triage_color_orig(i_lang, i_prof, g_type_color_title, tc.id_triage_type, et.id_triage_color_orig) title_triage_color,
                   pk_translation.get_translation(i_lang, tc.code_triage_color) ||
                   decode(tcg.flg_type, g_no, NULL, ' - ' || pk_translation.get_translation(i_lang, tc.code_accuity)) ||
                   nvl2(et.id_triage_color_orig,
                        chr(10) || '(' || REPLACE(REPLACE(pk_message.get_message(i_lang, 'TRIAGE_T047'),
                                                          '@1',
                                                          pk_edis_triage.get_triage_color_orig(i_lang,
                                                                                               i_prof,
                                                                                               g_type_color_value,
                                                                                               tc.id_triage_type,
                                                                                               et.id_triage_color_orig,
                                                                                               'S')),
                                                  '@2',
                                                  pk_edis_triage.get_triage_color_orig(i_lang,
                                                                                       i_prof,
                                                                                       g_type_color_value,
                                                                                       tc.id_triage_type,
                                                                                       et.id_triage_color,
                                                                                       'S')) || ')',
                        NULL) desc_triage_color,
                   get_board_label(i_lang, i_prof, et.id_triage_board, td.id_triage_decision_point, t.id_triage_type) desc_flowchart,
                   decode(l_triage.id_triage_type,
                          g_triage_id_ctas_p,
                          pk_message.get_message(i_lang, 'TRIAGE_CTAS_T003'),
                          g_triage_id_ctas_a,
                          pk_message.get_message(i_lang, 'TRIAGE_CTAS_T001'),
                          NULL) desc_critical,
                   pk_utils.concatenate_list(CURSOR
                                             (SELECT pk_translation.get_translation(i_lang, tb.code_triage_board) || ': ' || aux
                                                FROM triage_board tb
                                                JOIN (SELECT t.id_triage_board,
                                                            listagg(pk_translation.get_translation(i_lang,
                                                                                                   td.code_triage_discriminator),
                                                                    ',') within GROUP(ORDER BY t.rank) aux
                                                       FROM epis_triage_option eto
                                                       JOIN triage t
                                                         ON eto.id_triage = t.id_triage
                                                       JOIN triage_discriminator td
                                                         ON t.id_triage_discriminator = td.id_triage_discriminator
                                                      WHERE eto.id_epis_triage = i_id_epis_triage
                                                        AND eto.flg_selected_option = pk_alert_constant.g_yes
                                                        AND t.flg_critical_look = pk_alert_constant.g_yes
                                                      GROUP BY t.id_triage_board) t
                                                  ON tb.id_triage_board = t.id_triage_board),
                                             chr(10)) critical_look_description,
                   et.flg_critical_look
              FROM epis_triage et
              JOIN triage_color tc
                ON tc.id_triage_color = et.id_triage_color
              JOIN triage_type tt
                ON tt.id_triage_type = tc.id_triage_type
              LEFT JOIN triage t
                ON t.id_triage = et.id_triage
              LEFT JOIN triage_discriminator td
                ON td.id_triage_discriminator = t.id_triage_discriminator
              JOIN triage_color_group tcg
                ON tcg.id_triage_color_group = tc.id_triage_color_group
              LEFT JOIN triage_color tc_orig
                ON tc_orig.id_triage_color = et.id_triage_color_orig
              LEFT JOIN triage_board tb
                ON tb.id_triage_board = t.id_triage_board
             WHERE et.id_epis_triage = i_id_epis_triage;
    
        r_epis_triage c_epis_triage%ROWTYPE;
    BEGIN
        g_error := 'CALL GET_TRIAGE_SVD_DATA';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        IF NOT get_triage_svd_data(i_lang        => i_lang,
                                   i_prof        => i_prof,
                                   i_epis_triage => i_id_epis_triage,
                                   o_triage      => l_triage,
                                   o_error       => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'FETCH C_EPIS_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        OPEN c_epis_triage;
        FETCH c_epis_triage
            INTO r_epis_triage;
        CLOSE c_epis_triage;
    
        IF l_triage.id_triage_white_reason IS NOT NULL
        THEN
            -- Priority
            l_ret := l_ret || r_epis_triage.title_triage_color || g_colon || g_space || r_epis_triage.desc_triage_color ||
                     chr(10);
        
            -- Reason for visit
            l_ret := l_ret || pk_message.get_message(i_lang, i_prof, 'TRIAGE_T017') || g_colon || g_space ||
                     l_triage.desc_white_reason || chr(10);
        
            IF l_triage.notes IS NOT NULL
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, i_prof, 'TRIAGE_T016') || g_colon || g_space ||
                         l_triage.notes || chr(10);
            END IF;
        
        ELSE
        
            g_error := 'CALL get_triage_labels';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF NOT get_triage_labels(i_lang             => i_lang,
                                     i_prof             => i_prof,
                                     i_episode          => r_epis_triage.id_episode,
                                     i_triage_acronym   => r_epis_triage.acronym,
                                     o_flowchart        => l_flowchart,
                                     o_discriminator    => l_discriminator,
                                     o_reason_for_visit => l_dummy,
                                     o_fchart_selection => l_dummy,
                                     o_protocol         => l_dummy,
                                     o_confirmation     => l_dummy,
                                     o_current_prof     => l_dummy,
                                     o_other_discrim    => l_other,
                                     o_error            => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            IF l_triage.id_triage_type = g_triage_id_est
            THEN
                -- Degré
                l_ret := l_ret || r_epis_triage.title_triage_color || g_colon || g_space ||
                         r_epis_triage.desc_triage_color || chr(10);
                -- Motif
                l_ret := l_ret || l_flowchart || g_colon || g_space || r_epis_triage.desc_flowchart || chr(10);
                -- Critéres
                l_ret := l_ret || pk_message.get_message(i_lang, i_prof, 'TRIAGE_EST_M006') || ':' || chr(10) ||
                         get_defining_criteria_str(i_lang                  => i_lang,
                                                   i_tbl_defining_criteria => l_triage.defining_criterias,
                                                   i_prefix                => chr(32)) || chr(10);
            
                -- notes
                IF l_triage.notes IS NOT NULL
                THEN
                    l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T016') || g_colon || g_space ||
                             l_triage.notes || chr(10);
                END IF;
            
                l_ret := l_ret || chr(10);
            
                g_error := 'FETCH CONFIGURATIONS';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                l_detail_schema := pk_edis_triage.tf_detail_schema(i_lang                 => i_lang,
                                                                   i_prof                 => i_prof,
                                                                   i_episode              => r_epis_triage.id_episode,
                                                                   i_epis_triage          => r_epis_triage.id_epis_triage,
                                                                   i_show_additional_info => FALSE);
            
                SELECT decode(l_triage.id_triage_type,
                              g_triage_id_est,
                              pk_edis_hist.g_type_subtitle,
                              pk_edis_hist.g_type_title)
                  INTO l_title_type
                  FROM dual;
            
                g_error := 'LOAD VALUES TO SCREEN';
                pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
                FOR r_section IN (SELECT *
                                    FROM TABLE(l_detail_schema) t)
                LOOP
                    IF r_section.internal_name IN ('TRI_EST', 'TRIAGE')
                    THEN
                        l_ret := l_ret || r_section.component_desc || chr(10);
                    ELSE
                        IF l_last_node_loaded_value = TRUE
                           AND r_section.flg_component_type <> pk_dynamic_screen.c_leaf_component
                        THEN
                            l_last_node_loaded_value := FALSE;
                        END IF;
                    
                        IF r_section.component_values.exists(1)
                           AND r_section.flg_component_type = pk_dynamic_screen.c_root_component
                        THEN
                            l_ret := l_ret || chr(32) || r_section.component_desc || chr(10);
                        
                            IF r_section.component_values.count > 1
                            THEN
                                FOR l_values IN (SELECT t.*
                                                   FROM TABLE(r_section.component_values) t)
                                LOOP
                                    l_final_item_value := l_final_item_value || l_values.item_desc || ';' || chr(10);
                                END LOOP;
                            ELSE
                                l_final_item_value := r_section.component_values(1).item_desc;
                            END IF;
                        
                            l_ret := l_ret || chr(32) || l_final_item_value || chr(10);
                        
                            l_final_item_value := '';
                        
                        ELSIF r_section.component_values.exists(1)
                              OR r_section.flg_component_type = pk_dynamic_screen.c_node_component
                        THEN
                            -- adds info for form fields  
                            IF r_section.flg_component_type = pk_dynamic_screen.c_node_component
                            THEN
                                IF r_section.component_desc <> nvl(l_last_node_used, '-')
                                THEN
                                    -- saves section Title to display later if it has values and if it is a new one
                                    l_new_node_title         := r_section.component_desc;
                                    l_new_node_internal_name := r_section.internal_name;
                                END IF;
                            ELSE
                                -- adds Content Value with label (in a section)
                                IF r_section.component_values.count > 1
                                THEN
                                    FOR l_values IN (SELECT t.*
                                                       FROM TABLE(r_section.component_values) t)
                                    LOOP
                                        l_final_item_value := l_final_item_value || l_values.item_desc || ';' ||
                                                              chr(10);
                                    END LOOP;
                                ELSIF r_section.component_values.count = 1
                                THEN
                                    l_final_item_value := r_section.component_values(1).item_desc;
                                END IF;
                            
                                IF l_final_item_value IS NOT NULL
                                THEN
                                
                                    -- adds new subtitle  
                                    IF l_new_node_title IS NOT NULL
                                    THEN
                                        l_ret := l_ret || chr(32) || l_new_node_title || chr(10);
                                    
                                        l_last_node_used         := r_section.component_desc;
                                        l_new_node_title         := '';
                                        l_new_node_internal_name := '';
                                    END IF;
                                
                                    l_ret := l_ret || chr(32) || chr(32) || r_section.component_desc || ':' || chr(32) ||
                                             l_final_item_value || chr(10);
                                
                                    l_final_item_value       := '';
                                    l_last_node_loaded_value := TRUE;
                                END IF;
                            END IF;
                        
                        END IF;
                    END IF;
                END LOOP;
            ELSE
            
                -- Priority
                l_ret := l_ret || r_epis_triage.title_triage_color || g_colon || g_space ||
                         r_epis_triage.desc_triage_color || chr(10);
            
                IF l_triage.id_triage_type NOT IN (g_triage_id_latour, g_triage_id_ppau, g_triage_id_sa)
                THEN
                    IF l_triage.id_triage_type IN (g_triage_id_ctas_a, g_triage_id_ctas_p)
                    THEN
                        l_ret := l_ret || r_epis_triage.desc_critical || g_colon || g_space ||
                                 r_epis_triage.critical_look_description || chr(10);
                        IF nvl(r_epis_triage.flg_critical_look, pk_alert_constant.g_no) = pk_alert_constant.g_no
                        THEN
                        
                            -- Flowchart
                            l_ret := l_ret || l_flowchart || g_colon || g_space || r_epis_triage.desc_flowchart ||
                                     chr(10);
                            -- Key question/discriminator
                            l_ret := l_ret || l_discriminator || g_colon ||
                                     get_defining_criteria_str(i_lang                  => i_lang,
                                                               i_tbl_defining_criteria => l_triage.defining_criterias,
                                                               i_prefix                => g_space) || chr(10);
                        END IF;
                    END IF;
                    IF l_triage.id_triage_type IN (g_triage_id_ctas_a, g_triage_id_ctas_p)
                    THEN
                        l_ret := l_ret || l_discriminator || g_colon ||
                                 get_defining_criteria_str(i_lang                  => i_lang,
                                                           i_tbl_defining_criteria => l_triage.other_criterias,
                                                           i_prefix                => g_space) || chr(10);
                    
                    ELSE
                        -- Criteria (vital sign)
                        BEGIN
                            SELECT pk_translation.get_translation(i_lang, td.code_triage_discriminator), et.id_triage
                              INTO l_criteria, l_triage.id_triage
                              FROM triage_discriminator td
                              JOIN triage t
                                ON t.id_triage_discriminator = td.id_triage_discriminator
                              JOIN epis_triage et
                                ON et.id_triage = t.id_triage
                             WHERE et.id_epis_triage = l_triage.id_epis_triage;
                        
                            IF l_triage.id_triage IS NOT NULL
                            THEN
                                IF l_triage.id_triage_type = g_triage_id_atas
                                THEN
                                    l_ret := l_ret || l_discriminator || g_colon || g_space || l_criteria || chr(10);
                                ELSE
                                    l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_ESI_T007') || g_colon ||
                                             g_space || l_criteria || chr(10);
                                END IF;
                            END IF;
                        EXCEPTION
                            WHEN no_data_found THEN
                                NULL;
                        END;
                    END IF;
                END IF;
            
                -- notes
                IF l_triage.notes IS NOT NULL
                THEN
                    l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T016') || g_colon || g_space ||
                             l_triage.notes || chr(10);
                END IF;
            END IF;
        END IF;
    
        -- General Triage Data
        IF l_triage.id_triage_type <> g_triage_id_est
           OR l_triage.id_triage_white_reason IS NOT NULL
        THEN
            -- Origin
            IF l_triage.origin.desc_origin IS NOT NULL
            
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T033') || g_colon || g_space ||
                         l_triage.origin.desc_origin || chr(10);
            END IF;
        
            -- Origin description
            IF l_triage.origin.desc_origin_ft IS NOT NULL
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T029') || g_colon || g_space ||
                         l_triage.origin.desc_origin_ft || chr(10);
            END IF;
        
            -- Letter
            IF l_triage.flg_letter IS NOT NULL
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T034') || g_colon || g_space ||
                         l_triage.desc_letter || chr(10);
            END IF;
        
            -- Needs
            IF l_triage.needs IS NOT NULL
               AND l_triage.needs.count > 0
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T031') || g_colon || g_space;
            
                FOR i IN l_triage.needs.first .. l_triage.needs.last
                LOOP
                    l_ret := l_ret || l_triage.needs(i).desc_necessity || chr(10);
                END LOOP;
            
            END IF;
        
            -- Arrived by
            IF l_triage.desc_transport IS NOT NULL
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T042') || g_colon || g_space ||
                         l_triage.desc_transport || chr(10);
            END IF;
            -- Emergency contact
            IF l_triage.emergency_contact IS NOT NULL
            THEN
                l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T043') || g_colon || g_space ||
                         l_triage.emergency_contact || chr(10);
            END IF;
        
            IF l_triage.id_triage_type = g_triage_id_esi
            THEN
                -- chief complaint
                IF l_triage.chief_complaint IS NOT NULL
                THEN
                    l_ret := l_ret || pk_message.get_message(i_lang, 'TRIAGE_T032') || g_colon || g_space ||
                             l_triage.chief_complaint || chr(10);
                END IF;
            END IF;
        END IF;
    
        IF l_triage.safeguarding.flg_possible_injury IS NOT NULL
           OR l_triage.safeguarding.flg_has_social IS NOT NULL
           OR l_triage.safeguarding.flg_immobile IS NOT NULL
           OR l_triage.safeguarding.flg_protection_plan IS NOT NULL
        THEN
        
            SELECT l_ret || chr(10) ||
                   pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || ':' ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard;
        
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) ||
                   pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_possible_injury, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_expl_injury;
        
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) ||
                   pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_has_social, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_has_social_w;
        
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) ||
                   pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_protection_plan, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_protection_plan;
        
            IF l_triage.safeguarding.flg_protection_plan = pk_alert_constant.g_yes
            THEN
                IF l_triage.safeguarding.social_work_name IS NOT NULL
                THEN
                    SELECT l_ret ||
                           pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                           g_colon || chr(32) || l_triage.safeguarding.social_work_name || chr(10)
                      INTO l_ret
                      FROM ds_component ds
                     WHERE ds.internal_name = g_ds_safeguard_social_name;
                END IF;
                IF l_triage.safeguarding.social_work_address IS NOT NULL
                THEN
                    SELECT l_ret ||
                           pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                           g_colon || chr(32) || l_triage.safeguarding.social_work_address || chr(10)
                      INTO l_ret
                      FROM ds_component ds
                     WHERE ds.internal_name = g_ds_safeguard_social_add;
                END IF;
            END IF;
        
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) ||
                   pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_attend_delay, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_attend_delay;
        
            --  IF l_triage.safeguarding.flg_under_two_years = pk_alert_constant.g_yes THEN
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) || pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_immobile, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_immobile;
        
            IF l_triage.safeguarding.flg_injury IS NOT NULL
            THEN
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       chr(32) ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_injury, i_lang) ||
                       chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_injury;
            END IF;
        
            IF l_triage.safeguarding.flg_domestic_abuse IS NOT NULL
            THEN
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       chr(32) ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_domestic_abuse, i_lang) ||
                       chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_domestic_abuse;
            END IF;
        
            SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                   chr(32) ||
                   pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_social_services, i_lang) ||
                   chr(10)
              INTO l_ret
              FROM ds_component ds
             WHERE ds.internal_name = g_ds_safeguard_social_services;
        
            IF l_triage.safeguarding.flg_social_services = pk_alert_constant.g_yes
            THEN
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       g_colon || chr(32) || l_triage.safeguarding.social_reason || chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_social_reason;
            
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       chr(32) ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_consent_social, i_lang) ||
                       chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_social_consent;
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       chr(32) ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, l_triage.safeguarding.flg_info_sharing, i_lang) ||
                       chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_social_infor;
            
                SELECT l_ret || pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                       g_colon || chr(32) ||
                       pk_date_utils.date_char_tsz(i_lang => i_lang,
                                                   i_date => l_triage.safeguarding.dt_social_contact,
                                                   i_inst => i_prof.institution,
                                                   i_soft => i_prof.software) || chr(10)
                  INTO l_ret
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_social_dt;
            
                IF l_triage.safeguarding.social_info_received IS NOT NULL
                THEN
                    SELECT l_ret ||
                           pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) ||
                           g_colon || chr(32) || l_triage.safeguarding.social_reason || chr(10)
                      INTO l_ret
                      FROM ds_component ds
                     WHERE ds.internal_name = g_ds_safeguard_social_info_req;
                END IF;
            END IF;
            -- END IF;
        END IF;
        RETURN l_ret;
    END get_task_description;

    /*************************************************************************************
    * Returns a flag that indicates if the '+' button is active in the Triage screen
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_episode             Episode ID
    * @param i_id_triage_type         Triage Type ID
    * @param o_can_create_triage      Variable that tells if this institution can repeat the triage. Values Y/N
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.6
    * @since                          8/7/2013
    ***************************************************************************************/
    FUNCTION get_can_create_triage
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_episode        IN episode.id_episode%TYPE,
        i_id_triage_type    IN triage_type.id_triage_type%TYPE DEFAULT NULL,
        o_can_create_triage OUT VARCHAR2,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name         VARCHAR2(30) := 'GET_CAN_CREATE_TRIAGE';
        l_id_triage_type    triage_type.id_triage_type%TYPE;
        l_flg_status        episode.flg_status%TYPE;
        l_can_repeat_triage VARCHAR2(1 CHAR);
        l_triage_count      NUMBER;
    
        l_internal_error EXCEPTION;
    
    BEGIN
    
        -- checks if episode is still active
        IF i_id_episode IS NOT NULL
        THEN
            IF NOT pk_episode.get_flg_status(i_lang       => i_lang,
                                             i_prof       => i_prof,
                                             i_id_episode => i_id_episode,
                                             o_flg_status => l_flg_status,
                                             o_error      => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            IF l_flg_status <> pk_alert_constant.g_active
            THEN
                o_can_create_triage := g_no;
            END IF;
        END IF;
    
        -- if episode is still active, checks if it can create more than one triage    
        IF o_can_create_triage IS NULL
        THEN
        
            IF i_id_triage_type IS NULL
            THEN
                l_id_triage_type := get_triage_type(i_lang => i_lang, i_prof => i_prof, i_episode => i_id_episode);
            ELSE
                l_id_triage_type := i_id_triage_type;
            END IF;
        
            IF l_id_triage_type = g_triage_id_est
            THEN
                l_can_repeat_triage := pk_sysconfig.get_config(g_cfg_can_repeat_triage,
                                                               i_prof.institution,
                                                               i_prof.software);
            ELSE
                l_can_repeat_triage := g_yes;
                o_can_create_triage := g_yes;
            END IF;
        
            IF l_can_repeat_triage = g_no
            THEN
                --if it cannot repeat the triage, checks if there is already a triage for this episode
                BEGIN
                    g_error := 'CHECK EXISTING TRIAGES';
                    pk_alertlog.log_debug(g_error);
                    SELECT COUNT(1)
                      INTO l_triage_count
                      FROM epis_triage t
                     WHERE t.id_episode = i_id_episode;
                EXCEPTION
                    WHEN no_data_found THEN
                        l_triage_count := 0;
                END;
            
                IF l_triage_count = 0
                THEN
                    o_can_create_triage := g_yes;
                ELSE
                    o_can_create_triage := g_no;
                END IF;
            ELSE
                o_can_create_triage := g_yes;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            o_can_create_triage := g_yes;
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_can_create_triage;

    /*************************************************************************************
    * Returns the fields to be displayed in the Safeguarding alert popup
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_sys_alert_event     Sys_alert_event identifier
    * @param o_msg_title              Title message to be displayed in the alert popup
    * @param o_msg_text               Title message to be displayed in the alert popup
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Sergio Dias
    * @version                        2.6.3.8.5
    * @since                          Nov-25-2013
    ***************************************************************************************/
    FUNCTION get_safeguard_info
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_sys_alert_event IN sys_alert_event.id_sys_alert_event%TYPE,
        o_msg_title          OUT VARCHAR2,
        o_msg_text           OUT VARCHAR2,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name              VARCHAR2(30) := 'GET_SAFEGUARD_INFO';
        l_flg_under_two_years    VARCHAR2(1 CHAR);
        l_flg_immobile           VARCHAR2(1 CHAR);
        l_flg_unexplained_injury VARCHAR2(1 CHAR);
        l_flg_protection_plan    VARCHAR2(1 CHAR);
        l_flg_attendance_delay   VARCHAR2(1 CHAR);
        l_flg_domestic_abuse     VARCHAR2(1 CHAR);
    BEGIN
        SELECT et.flg_under_two_years,
               et.flg_immobile,
               et.flg_unexplained_injury,
               et.flg_protection_plan,
               et.flg_attendance_delay,
               et.flg_domestic_abuse
          INTO l_flg_under_two_years,
               l_flg_immobile,
               l_flg_unexplained_injury,
               l_flg_protection_plan,
               l_flg_attendance_delay,
               l_flg_domestic_abuse
          FROM epis_triage et
         WHERE et.id_epis_triage = (SELECT sae.id_record
                                      FROM sys_alert_event sae
                                     WHERE sae.id_sys_alert_event = i_id_sys_alert_event);
    
        IF l_flg_under_two_years = pk_alert_constant.g_yes
           OR l_flg_immobile = pk_alert_constant.g_yes
           OR l_flg_unexplained_injury = pk_alert_constant.g_yes
           OR l_flg_protection_plan = pk_alert_constant.g_yes
           OR l_flg_attendance_delay = pk_alert_constant.g_yes
           OR l_flg_domestic_abuse = pk_alert_constant.g_yes
        THEN
            o_msg_title := pk_message.get_message(i_lang, 'V_ALERT_M105');
            o_msg_text  := pk_message.get_message(i_lang, 'V_ALERT_M106') || chr(10);
        
            IF l_flg_under_two_years = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_under_two_years;
            END IF;
        
            IF l_flg_immobile = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_immobile;
            END IF;
        
            IF l_flg_unexplained_injury = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_injury;
            END IF;
        
            IF l_flg_protection_plan = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_protection_plan;
            END IF;
        
            IF l_flg_attendance_delay = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_attend_delay;
            END IF;
        
            IF l_flg_domestic_abuse = pk_alert_constant.g_yes
            THEN
                SELECT o_msg_text || chr(10) || '<b>' ||
                       pk_translation.get_translation(i_lang => i_lang, i_code_mess => ds.code_ds_component) || '</b> ' ||
                       pk_sysdomain.get_domain(g_code_domain_yes_no, g_yes, i_lang)
                  INTO o_msg_text
                  FROM ds_component ds
                 WHERE ds.internal_name = g_ds_safeguard_domestic_abuse;
            END IF;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_safeguard_info;

    /**********************************************************************************************
    * This function returns a string with all read vital signs during a triage, and is to be used in reports
    *   
    * @param i_lang                   the id language
    * @param i_prof                   professional, software and institution ids
    * @param i_id_epis_triage         episode triage id 
    * @param i_sep                    new line separator
    *
    * @return                         Stirng with vital sign data
    *                        
    * @author                         Alexandre Santos
    * @version                        1.0 
    * @since                          2014/08/18
    **********************************************************************************************/
    FUNCTION get_epis_triage_vs_desc
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_triage IN epis_triage.id_epis_triage%TYPE,
        i_sep            IN VARCHAR2 DEFAULT NULL
    ) RETURN VARCHAR2 IS
        l_func_name CONSTANT VARCHAR2(32 CHAR) := 'GET_EPIS_TRIAGE_VS_DESC';
        --
        l_tbl_vs pk_edis_types.table_vital_signs;
        l_rec_vs pk_edis_types.rec_vital_sign;
        --
        l_error t_error_out;
        --
        l_ret VARCHAR2(1000 CHAR);
    BEGIN
        g_error := 'CALL GET_VITAL_SIGNS';
        pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        l_tbl_vs := get_vital_signs(i_lang => i_lang, i_prof => i_prof, i_epis_triage => i_id_epis_triage);
    
        IF l_tbl_vs.exists(1)
        THEN
            FOR i IN l_tbl_vs.first .. l_tbl_vs.last
            LOOP
                l_rec_vs := l_tbl_vs(i);
            
                l_ret := l_ret || l_rec_vs.desc_vital_sign || ' - ' || l_rec_vs.desc_value || nvl(i_sep, chr(10));
            END LOOP;
        END IF;
    
        RETURN l_ret;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              l_error);
            pk_alert_exceptions.reset_error_state;
            RETURN NULL;
    END get_epis_triage_vs_desc;

    /**************************************************************************
    * Detailed information about a triage safeguarding
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_id_epis_triage         Triage event ID
    * @param o_epis_triage            Triage Info
    * @param o_error                  Error message
    *
    * @return                         TRUE / FALSE
    *                        
    * @author                         Elisabete Bugalho
    * @version                        2.6.5.2.1
    * @since                          2016/09/09
    **************************************************************************/
    FUNCTION get_epis_triage_safeguarding
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_epis_triage IN epis_triage.id_epis_triage%TYPE,
        o_epis_triage    OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
        l_func_name CONSTANT VARCHAR2(30) := 'GET_EPIS_TRIAGE_DETAIL';
        l_triage pk_edis_types.rec_triage;
        l_internal_error EXCEPTION;
        r_epis_triage            epis_triage%ROWTYPE;
        l_detail_schema          t_table_ds_sections;
        l_last_node_used         VARCHAR2(200) := '';
        l_last_node_loaded_value BOOLEAN := FALSE;
        l_final_item_value       VARCHAR2(32767) := '';
        l_new_node_title         VARCHAR2(200) := '';
        l_new_node_internal_name VARCHAR2(200) := '';
        l_title_type             VARCHAR(2 CHAR);
        l_flg_call               VARCHAR2(1 CHAR) := 'S';
    
        CURSOR c_epis_triage IS
            SELECT et.id_epis_triage, et.dt_begin_tstz, tt.id_triage_type, et.id_professional, et.id_episode
              FROM epis_triage et
              JOIN triage_color tc
                ON tc.id_triage_color = et.id_triage_color
              JOIN triage_type tt
                ON tt.id_triage_type = tc.id_triage_type
             WHERE et.id_epis_triage = i_id_epis_triage;
    BEGIN
        g_error := 'FETCH DATA INTO R_EPIS_TRIAGE';
        pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
        FOR r_epis_triage IN c_epis_triage
        LOOP
        
            -- Initialize history table
            pk_edis_hist.init_vars;
        
            -- Create a new line in history table with current history record 
            pk_edis_hist.add_line(i_history        => r_epis_triage.id_epis_triage,
                                  i_dt_hist        => r_epis_triage.dt_begin_tstz,
                                  i_record_state   => pk_alert_constant.g_flg_status_a,
                                  i_desc_rec_state => NULL);
        
            g_error := 'GET SAVED DATA';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            IF NOT get_triage_svd_data(i_lang        => i_lang,
                                       i_prof        => i_prof,
                                       i_epis_triage => i_id_epis_triage,
                                       i_flg_call    => l_flg_call,
                                       o_triage      => l_triage,
                                       o_error       => o_error)
            THEN
                RAISE l_internal_error;
            END IF;
        
            g_error := 'FETCH CONFIGURATIONS';
            pk_alertlog.log_debug(object_name => g_package_name, sub_object_name => l_func_name, text => g_error);
            l_detail_schema := pk_edis_triage.tf_detail_schema(i_lang                 => i_lang,
                                                               i_prof                 => i_prof,
                                                               i_episode              => r_epis_triage.id_episode,
                                                               i_epis_triage          => r_epis_triage.id_epis_triage,
                                                               i_triage_type          => r_epis_triage.id_triage_type,
                                                               i_ds_component         => g_ds_safeguard,
                                                               i_ds_comp_type         => pk_dynamic_screen.c_node_component,
                                                               i_show_additional_info => FALSE,
                                                               i_flg_call             => l_flg_call);
            FOR r_section IN (SELECT *
                                FROM TABLE(l_detail_schema) t)
            LOOP
            
                IF l_last_node_loaded_value = TRUE
                   AND r_section.flg_component_type <> pk_dynamic_screen.c_leaf_component
                THEN
                    pk_edis_hist.add_value(i_label => NULL, i_value => NULL, i_type => pk_edis_hist.g_type_empty_line);
                
                    l_last_node_loaded_value := FALSE;
                END IF;
            
                IF r_section.component_values.exists(1)
                   AND r_section.flg_component_type = pk_dynamic_screen.c_root_component
                THEN
                    IF r_section.component_values.count > 1
                    THEN
                        FOR l_values IN (SELECT t.*
                                           FROM TABLE(r_section.component_values) t)
                        LOOP
                            l_final_item_value := l_final_item_value || l_values.item_desc || ';' || chr(32);
                        END LOOP;
                    ELSE
                    
                        l_final_item_value := r_section.component_values(1).item_desc;
                    
                    END IF;
                
                    IF l_final_item_value IS NOT NULL
                       OR l_final_item_value <> ''
                    THEN
                        -- adds (Title + Content) for roots that have a value (TRIAGE_BOARD, DEFINING_CRITERIA, OTHER_CRITERIA)
                        pk_edis_hist.add_value(i_label => r_section.component_desc,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_title,
                                               i_code  => r_section.internal_name);
                    
                        pk_edis_hist.add_value(i_label => NULL,
                                               i_value => l_final_item_value,
                                               i_type  => pk_edis_hist.g_type_content,
                                               i_code  => r_section.internal_name || '_VALUE');
                    
                        pk_edis_hist.add_value(i_label => NULL,
                                               i_value => NULL,
                                               i_type  => pk_edis_hist.g_type_empty_line);
                    END IF;
                
                    l_final_item_value := '';
                ELSIF r_section.component_values.exists(1)
                      OR r_section.flg_component_type = pk_dynamic_screen.c_leaf_component
                THEN
                
                    -- adds Content Value with label (in a section)
                    IF r_section.component_values.count > 1
                    THEN
                        FOR l_values IN (SELECT t.*
                                           FROM TABLE(r_section.component_values) t)
                        LOOP
                            l_final_item_value := l_final_item_value || l_values.item_desc || ';' || chr(32);
                        END LOOP;
                    ELSIF r_section.component_values.count = 1
                    THEN
                    
                        l_final_item_value := r_section.component_values(1).item_desc;
                    END IF;
                
                    IF l_final_item_value IS NOT NULL
                    THEN
                    
                        pk_edis_hist.add_value(i_label => r_section.component_desc,
                                               i_value => l_final_item_value,
                                               i_type  => pk_edis_hist.g_type_content,
                                               i_code  => r_section.internal_name);
                    
                        l_final_item_value       := '';
                        l_last_node_loaded_value := TRUE;
                    END IF;
                
                END IF;
            
            END LOOP;
            --signature
            pk_edis_hist.add_value(i_label => pk_message.get_message(i_lang, i_prof, 'COMMON_M107'),
                                   i_value => pk_edis_hist.get_signature(i_lang                => i_lang,
                                                                         i_prof                => i_prof,
                                                                         i_id_episode          => l_triage.id_episode,
                                                                         i_date                => r_epis_triage.dt_begin_tstz,
                                                                         i_id_prof_last_change => r_epis_triage.id_professional),
                                   i_type  => pk_edis_hist.g_type_signature,
                                   i_code  => 'SIGNATURE');
        
        END LOOP;
    
        g_error := 'OPEN O_EPIS_TRIAGE CURSOR';
        alertlog.pk_alertlog.log_debug(text => g_error, object_name => g_package_name, sub_object_name => l_func_name);
        OPEN o_epis_triage FOR
            SELECT t.id_history,
                   t.dt_history,
                   t.tbl_labels,
                   t.tbl_values,
                   t.tbl_types,
                   t.tbl_info_labels,
                   t.tbl_info_values,
                   t.tbl_codes
              FROM TABLE(pk_edis_hist.tf_hist) t;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_owner,
                                              g_package_name,
                                              l_func_name,
                                              o_error);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_epis_triage_safeguarding;

    /**************************************************************************
    * Returns the triage acronym for the most actual triage in given eisode.
    *   
    * @param i_lang                   Language ID
    * @param i_prof                   Professional info
    * @param i_epis                   Episode ID
    * @return                         triage acronym
    *                        
    * @author                         Anna Kurowska
    * @version                        2.7.1
    * @since                          10/03/2017
    **************************************************************************/
    FUNCTION get_epis_triage_acronym
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_episode IN episode.id_episode%TYPE
    ) RETURN triage_type.acronym%TYPE IS
        l_acronym_desc triage_type.acronym%TYPE;
    BEGIN
        BEGIN
            g_error := 'GET EPIS TRIAGE ACRONYM';
            pk_alertlog.log_debug(g_error);
            SELECT tt.acronym
              INTO l_acronym_desc
              FROM triage_type tt
              JOIN triage t
                ON t.id_triage_type = tt.id_triage_type
              JOIN epis_triage et
                ON et.id_triage = t.id_triage
             WHERE et.id_episode = i_episode
               AND rownum = 1
             ORDER BY et.dt_end_tstz DESC;
        
        EXCEPTION
            WHEN no_data_found THEN
                RETURN get_triage_acronym(i_lang => i_lang, i_prof => i_prof, i_episode => i_episode);
        END;
    
        RETURN l_acronym_desc;
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_epis_triage_acronym;

    /* *******************************************************************************************
    *  Get current state of Triage for viewer checlist 
    *             
    * @param    i_lang          Language ID
    * @param    i_prof          Logged professional structure
    * @param    i_scope_type    Scope flag | 'P' - Patient, 'E' - Episode, 'V' - Visit 
    * @param    i_id_episode    Episode ID
    * @param    i_id_patient    Patient ID
    *
    * @return VARCHAR2  Viewer checklist status | 'N' - Not started , 'C' - Complete, 'O' - On going
    * 
    * @author                     
    * @version                    
    * @since                              
    **********************************************************************************************/
    FUNCTION get_vwr_triage
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_scope_type IN VARCHAR2,
        i_id_episode IN episode.id_episode%TYPE,
        i_id_patient IN patient.id_patient%TYPE
    ) RETURN VARCHAR2 IS
    
        l_count    NUMBER;
        l_status   VARCHAR2(1 CHAR) := pk_viewer_checklist.g_checklist_not_started;
        l_episodes table_number := table_number();
    BEGIN
    
        l_episodes := pk_episode.get_scope(i_lang       => i_lang,
                                           i_prof       => i_prof,
                                           i_patient    => i_id_patient,
                                           i_episode    => i_id_episode,
                                           i_flg_filter => i_scope_type);
    
        SELECT COUNT(*)
          INTO l_count
          FROM epis_triage et
         WHERE id_episode IN (SELECT column_value id_episode
                                FROM TABLE(l_episodes));
    
        IF l_count > 0
        THEN
            l_status := pk_viewer_checklist.g_checklist_completed;
        END IF;
    
        RETURN l_status;
    
    END get_vwr_triage;

    FUNCTION check_board_level_msg
    (
        i_id_triage_board IN triage_board.id_triage_board%TYPE,
        i_urgency_level   IN NUMBER
    ) RETURN VARCHAR2 IS
        l_count NUMBER;
    BEGIN
        IF i_urgency_level IS NOT NULL
        THEN
            SELECT COUNT(1)
              INTO l_count
              FROM triage_board_acuity_lvl tbal
              JOIN triage_esi_level tel
                ON tel.id_triage_esi_level = tbal.id_triage_esi_level
             WHERE tel.esi_level <= i_urgency_level
               AND tbal.flg_available = g_yes
               AND tel.flg_available = g_yes
               AND tbal.id_triage_board = i_id_triage_board;
        
            IF l_count = 0
            THEN
                RETURN pk_alert_constant.g_yes;
            ELSE
                RETURN pk_alert_constant.g_no;
            END IF;
        ELSE
            RETURN pk_alert_constant.g_no;
        END IF;
    
    END check_board_level_msg;

    FUNCTION get_critical_look_str
    (
        i_lang              IN language.id_language%TYPE,
        i_epis_triage       IN epis_triage.id_epis_triage%TYPE,
        i_flg_critical_look IN epis_triage.flg_critical_look%TYPE
    ) RETURN VARCHAR2 IS
        l_ret pk_translation.t_desc_translation;
        l_aux pk_translation.t_desc_translation;
    BEGIN
    
        SELECT pk_utils.concatenate_list(CURSOR (SELECT pk_translation.get_translation(i_lang, tb.code_triage_board) || ' (' ||
                                                 total || ')'
                                            FROM triage_board tb
                                            JOIN (SELECT t.id_triage_board, COUNT(1) total
                                                   FROM epis_triage_option eto
                                                   JOIN triage t
                                                     ON eto.id_triage = t.id_triage
                                                  WHERE eto.id_epis_triage = i_epis_triage
                                                    AND eto.flg_selected_option = pk_alert_constant.g_yes
                                                    AND t.flg_critical_look = pk_alert_constant.g_yes
                                                  GROUP BY t.id_triage_board) t
                                              ON tb.id_triage_board = t.id_triage_board),
                                         ', ')
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    END get_critical_look_str;

    FUNCTION get_critical_look_desc_str
    (
        i_lang                IN language.id_language%TYPE,
        i_epis_triage         IN epis_triage.id_epis_triage%TYPE,
        i_flg_critical_look   IN epis_triage.flg_critical_look%TYPE,
        i_flg_selected_option IN epis_triage_option.flg_selected_option%TYPE DEFAULT pk_alert_constant.g_yes
    ) RETURN VARCHAR2 IS
        l_ret pk_translation.t_desc_translation;
        l_aux pk_translation.t_desc_translation;
    BEGIN
    
        SELECT pk_utils.concatenate_list(CURSOR (SELECT pk_translation.get_translation(i_lang, tb.code_triage_board) || ': ' || aux
                                            FROM triage_board tb
                                            JOIN (SELECT t.id_triage_board,
                                                        listagg(pk_translation.get_translation(i_lang,
                                                                                               td.code_triage_discriminator),
                                                                ',') within GROUP(ORDER BY t.rank) aux
                                                   FROM epis_triage_option eto
                                                   JOIN triage t
                                                     ON eto.id_triage = t.id_triage
                                                   JOIN triage_discriminator td
                                                     ON t.id_triage_discriminator = td.id_triage_discriminator
                                                  WHERE eto.id_epis_triage = i_epis_triage
                                                    AND eto.flg_selected_option = i_flg_selected_option
                                                    AND t.flg_critical_look = pk_alert_constant.g_yes
                                                  GROUP BY t.id_triage_board) t
                                              ON tb.id_triage_board = t.id_triage_board),
                                         chr(10))
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    END get_critical_look_desc_str;

BEGIN
    g_package_name := pk_alertlog.who_am_i;
    pk_alertlog.log_init(g_package_name);
END pk_edis_triage;
/
