/*-- Last Change Revision: $Rev: 2055768 $*/
/*-- Last Change by: $Author: diogo.oliveira $*/
/*-- Date of last change: $Date: 2023-02-23 15:11:25 +0000 (qui, 23 fev 2023) $*/


CREATE OR REPLACE PACKAGE BODY pk_order_sets IS

    -- logging variables
    g_package_owner VARCHAR2(30);
    g_package_name  VARCHAR2(30);
    g_error         VARCHAR2(4000);

    -- debug mode enabled/disabled
    g_debug BOOLEAN;

    -- max size used to truncate clob fields
    g_trunc_clob_max_size CONSTANT NUMBER := 1000;

    g_flg_force_diet VARCHAR2(1 CHAR) := pk_alert_constant.g_no;

    FUNCTION trunc_clob_to_varchar2
    (
        i_clob     IN CLOB,
        i_max_size IN NUMBER
    ) RETURN VARCHAR2 IS
        l_varchar_string            VARCHAR2(32767); -- Maximum length for PL/SQL VARCHAR2 type
        l_max_size_without_ellipsis NUMBER;
        l_ellipis_str CONSTANT VARCHAR2(10 CHAR) := '...';
    BEGIN
    
        -- check if clob is greater than max size
        IF length(i_clob) > i_max_size
        THEN
        
            -- calculate max size without ellipsis
            l_max_size_without_ellipsis := i_max_size - length(l_ellipis_str);
        
            -- convert clob to varchar2 and truncate it to max size
            l_varchar_string := pk_string_utils.clob_to_varchar2(i_clob, l_max_size_without_ellipsis);
        
            -- append ellipsis to the string
            l_varchar_string := l_varchar_string || l_ellipis_str;
        
        ELSE
        
            -- convert clob to varchar2 and truncate it to max size
            l_varchar_string := pk_string_utils.clob_to_varchar2(i_clob, i_max_size);
        
        END IF;
    
        RETURN l_varchar_string;
    
    END trunc_clob_to_varchar2;

    FUNCTION get_task_types(i_reqs IN t_tbl_odst_task_req) RETURN table_number IS
    
        l_task_types table_number := table_number();
    
    BEGIN
    
        IF i_reqs.count != 0
        THEN
            SELECT DISTINCT req.task_type
              BULK COLLECT
              INTO l_task_types
              FROM TABLE(CAST(i_reqs AS t_tbl_odst_task_req)) req;
        END IF;
    
        RETURN l_task_types;
    
    END get_task_types;

    FUNCTION get_task_requests
    (
        i_task_type IN task_type.id_task_type%TYPE,
        i_reqs      IN t_tbl_odst_task_req
    ) RETURN table_number IS
    
        l_task_reqs table_number;
    
    BEGIN
    
        SELECT DISTINCT req.task_request
          BULK COLLECT
          INTO l_task_reqs
          FROM TABLE(CAST(i_reqs AS t_tbl_odst_task_req)) req
         WHERE req.task_type = i_task_type;
    
        RETURN l_task_reqs;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN table_number(); -- emtpy array
    END get_task_requests;

    FUNCTION get_order_set_task_by_req
    (
        i_task_request IN order_set_process_task.id_request%TYPE,
        i_reqs         IN t_tbl_odst_task_req
    ) RETURN order_set_process_task.id_order_set_process_task%TYPE IS
    
        l_ret order_set_process_task.id_order_set_process_task%TYPE;
    
    BEGIN
    
        SELECT req.order_set_task
          INTO l_ret
          FROM TABLE(CAST(i_reqs AS t_tbl_odst_task_req)) req
         WHERE req.task_request = i_task_request;
    
        RETURN l_ret;
    
    END get_order_set_task_by_req;

    FUNCTION concat_table_timestamp_tstz
    (
        i_tbl1 IN table_timestamp_tstz,
        i_tbl2 IN table_timestamp_tstz
    ) RETURN table_timestamp_tstz IS
    
        l_ret table_timestamp_tstz := i_tbl1;
    
    BEGIN
    
        FOR i IN 1 .. i_tbl2.count
        LOOP
            l_ret.extend;
            l_ret(l_ret.count) := i_tbl2(i);
        END LOOP;
    
        RETURN l_ret;
    
    END concat_table_timestamp_tstz;

    FUNCTION check_modular_task_type(i_task_type task_type.id_task_type%TYPE) RETURN VARCHAR2 IS
    
        l_flag task_type.flg_modular_workflow%TYPE;
    BEGIN
    
        SELECT flg_modular_workflow
          INTO l_flag
          FROM task_type tsk_type
         WHERE tsk_type.id_task_type = i_task_type;
    
        RETURN l_flag;
    
    END check_modular_task_type;

    FUNCTION check_recm_availability
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        o_flg_recm_avail OUT VARCHAR2,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_market market.id_market%TYPE := pk_utils.get_institution_market(i_lang, i_prof.institution);
    
    BEGIN
    
        g_error := 'CHECK RECM AVAILABILITY';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- "RECM/despachos" field must be available only for PT market
        IF l_market = pk_alert_constant.g_id_market_pt
        THEN
            o_flg_recm_avail := pk_alert_constant.g_yes;
        ELSE
            o_flg_recm_avail := pk_alert_constant.g_no;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_RECM_AVAILABILITY',
                                              o_error);
            RETURN FALSE;
    END check_recm_availability;

    FUNCTION check_order_set_task_avail
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_task_type IN order_set_task_soft_inst.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
    
    BEGIN
    
        RETURN pk_order_sets.check_order_set_task_avail(i_lang         => i_lang,
                                                        i_professional => i_prof.id,
                                                        i_institution  => i_prof.institution,
                                                        i_software     => i_prof.software,
                                                        i_task_type    => i_id_task_type);
    END check_order_set_task_avail;

    FUNCTION check_order_set_task_avail
    (
        i_lang         IN language.id_language%TYPE,
        i_professional IN professional.id_professional%TYPE,
        i_institution  IN institution.id_institution%TYPE,
        i_software     IN software.id_software%TYPE,
        i_task_type    IN order_set_task_soft_inst.id_task_type%TYPE
    ) RETURN VARCHAR2 result_cache IS
    
        l_prof   profissional := profissional(i_professional, i_institution, i_software);
        l_market market.id_market%TYPE := pk_utils.get_institution_market(i_lang, l_prof.institution);
    
        l_available VARCHAR2(1 CHAR);
    
    BEGIN
    
        g_error := 'CHECK IF ORDER SET TASK IS AVAILABLE';
        BEGIN
            SELECT flg_available
              INTO l_available
              FROM (
                    -- verify if the task is available for the current software and institution
                    SELECT nvl((SELECT flg_available
                                  FROM (SELECT ost_task_si.flg_available
                                          FROM order_set_task_soft_inst ost_task_si
                                         WHERE ost_task_si.id_software IN (g_all_software, l_prof.software)
                                           AND ost_task_si.id_institution IN (g_all_institution, l_prof.institution)
                                           AND ost_task_si.id_market IN (g_all_markets, l_market)
                                           AND ost_task_si.id_task_type = i_task_type
                                         ORDER BY ost_task_si.id_market      DESC,
                                                  ost_task_si.id_institution DESC,
                                                  ost_task_si.id_software    DESC,
                                                  ost_task_si.flg_available)
                                 WHERE rownum = 1),
                                g_not_available) flg_available
                      FROM dual
                    UNION ALL
                    -- verify if the professional has permission to execute this type of task
                    SELECT nvl((SELECT flg_available
                                  FROM (SELECT actp.flg_available
                                          FROM action act, action_permission actp
                                         WHERE act.subject = g_action_order_set_exec
                                           AND act.id_action = actp.id_action
                                           AND actp.id_category =
                                               (SELECT pc.id_category
                                                  FROM prof_cat pc
                                                 WHERE pc.id_professional = l_prof.id
                                                   AND pc.id_institution = l_prof.institution)
                                           AND actp.id_profile_template IN (SELECT ppt.id_profile_template
                                                                              FROM prof_profile_template ppt
                                                                             WHERE ppt.id_professional = l_prof.id
                                                                               AND ppt.id_institution = l_prof.institution
                                                                               AND ppt.id_software = l_prof.software
                                                                            UNION ALL
                                                                            SELECT g_all_profile_template id_profile_template
                                                                              FROM dual)
                                           AND actp.id_task_type = i_task_type
                                         ORDER BY actp.id_profile_template DESC, actp.flg_available)
                                 WHERE rownum = 1),
                                g_not_available) flg_available
                      FROM dual
                     ORDER BY flg_available)
             WHERE rownum = 1;
        
            RETURN l_available;
        
        EXCEPTION
            -- if no data found returns task not available
            WHEN no_data_found THEN
                RETURN g_not_available;
        END;
    END check_order_set_task_avail;

    FUNCTION check_os_existing_hidrics_task
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        i_acronym      IN hidrics_type.acronym%TYPE,
        o_exists       OUT VARCHAR2,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_internal_error EXCEPTION;
    
    BEGIN
    
        o_exists := g_no;
    
        RETURN TRUE;
    END;

    FUNCTION get_task_presel
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_presel VARCHAR2(1 CHAR);
    
    BEGIN
    
        SELECT odst_tsk_det.vvalue
          INTO l_presel
          FROM order_set_task_detail odst_tsk_det
         WHERE odst_tsk_det.id_order_set_task = i_order_set_task
           AND odst_tsk_det.flg_detail_type = g_task_det_adv_input
           AND odst_tsk_det.id_advanced_input_field = g_adv_input_field_selected
           AND rownum = 1;
    
        RETURN l_presel;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN pk_alert_constant.g_no;
    END get_task_presel;

    FUNCTION get_proc_task_presel
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_presel VARCHAR2(1 CHAR);
    
    BEGIN
    
        pk_alertlog.log_debug('get task pre-selection: (y)es or (n)o', g_package_name);
        SELECT odst_proc_tsk_det.vvalue
          INTO l_presel
          FROM order_set_process_task_det odst_proc_tsk_det
         WHERE odst_proc_tsk_det.id_order_set_process_task = i_order_set_process_task
           AND odst_proc_tsk_det.flg_detail_type = g_task_det_adv_input
           AND odst_proc_tsk_det.id_advanced_input_field = g_adv_input_field_selected;
    
        RETURN l_presel;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN pk_alert_constant.g_no;
        
        WHEN too_many_rows THEN
            RETURN pk_alert_constant.g_yes;
    END get_proc_task_presel;

    FUNCTION get_task_type_rank
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_task_type IN order_set_task_soft_inst.id_task_type%TYPE
    ) RETURN order_set_task_soft_inst.rank%TYPE IS
    
        l_rank   order_set_task_soft_inst.rank%TYPE;
        l_market market.id_market%TYPE := pk_utils.get_institution_market(i_lang, i_prof.institution);
    
    BEGIN
    
        pk_alertlog.log_debug('GET TASK TYPE RANK', g_package_name);
        SELECT rank
          INTO l_rank
          FROM (SELECT rank
                  FROM order_set_task_soft_inst
                 WHERE id_task_type = i_id_task_type
                   AND id_institution IN (i_prof.institution, g_all_institution)
                   AND id_software IN (i_prof.software, g_all_software)
                   AND id_market IN (l_market, g_all_markets)
                 ORDER BY id_market DESC, id_institution DESC, id_software DESC)
         WHERE rownum = 1;
    
        RETURN l_rank;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_task_type_rank;

    FUNCTION check_episode_support_task
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_dependency_type      IN table_number,
        i_task_dependency_from IN table_number,
        i_task_dependency_to   IN table_number,
        i_order_set_task       IN order_set_task.id_order_set_task%TYPE,
        i_task_type            IN task_type.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
    
        l_flg_episode_task task_type.flg_episode_task%TYPE;
    
    BEGIN
        -- get task type episode support flag value
        SELECT tsk_type.flg_episode_task
          INTO l_flg_episode_task
          FROM task_type tsk_type
         WHERE tsk_type.id_task_type = i_task_type;
    
        -- task type represents an episode            
        IF l_flg_episode_task = pk_alert_constant.g_tt_tde_support_epis
        THEN
            RETURN pk_alert_constant.g_yes;
        END IF;
    
        -- task type cannot be considered as an episode
        IF l_flg_episode_task = pk_alert_constant.g_tt_tde_support_task
        THEN
            RETURN pk_alert_constant.g_no;
        END IF;
    
        -- search for start2start dependency
        IF (i_dependency_type.count > 0)
        THEN
            FOR i IN i_dependency_type.first .. i_dependency_type.last
            LOOP
            
                -- verify if start2start dependency was found
                IF (i_dependency_type(i) = pk_alert_constant.g_tde_rel_start2start AND
                   i_task_dependency_to(i) = i_order_set_task)
                THEN
                
                    -- verify if task is included in a future episode
                    -- if so, the task is considered an episode
                    IF (i_task_dependency_from(i) = to_number(g_depend_future_epis))
                    THEN
                        RETURN pk_alert_constant.g_yes;
                    ELSE
                        RETURN pk_alert_constant.g_no;
                    END IF;
                
                END IF;
            END LOOP;
        END IF;
    
        RETURN pk_alert_constant.g_no;
    
    END check_episode_support_task;

    FUNCTION get_task_dependency_rank
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_dependencies_scope   IN table_number,
        i_flg_process          IN VARCHAR2,
        i_dependency_type      IN table_number,
        i_task_dependency_from IN table_number,
        i_task_dependency_to   IN table_number,
        o_tasks_rank           OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dependency      table_number;
        l_dependency_root table_number;
        l_tasks_rank      table_number := table_number();
    
        l_drec t_rec_tde_network := t_rec_tde_network(NULL, NULL, NULL, NULL, NULL);
        l_dtbl t_tbl_tde_network := t_tbl_tde_network();
    
        l_dep_root_rec t_rec_odst_depend_root := t_rec_odst_depend_root(NULL, NULL, NULL);
        l_dep_root_tbl t_tbl_odst_depend_root := t_tbl_odst_depend_root();
    
        -- function used to get a dependency index
        FUNCTION get_dependency_index
        (
            i_dependency      IN NUMBER,
            i_dependency_list IN table_number
        ) RETURN NUMBER IS
        BEGIN
            FOR i IN 1 .. i_dependency_list.count
            LOOP
                IF i_dependency_list(i) = i_dependency
                THEN
                    RETURN i;
                END IF;
            END LOOP;
        
            RETURN NULL;
        
        END get_dependency_index;
    
    BEGIN
    
        g_error := 'GET ORDER SET TASKS RANK';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- verify order set dependencies scope
        -- order sets back-office
        IF i_flg_process = pk_alert_constant.g_no
        THEN
        
            -- prepare rank arrays
            SELECT id_order_set_task, NULL root
              BULK COLLECT
              INTO l_dependency, l_dependency_root
              FROM (SELECT odst_tsk.id_order_set_task,
                           (SELECT check_episode_support_task(i_lang,
                                                              i_prof,
                                                              i_dependency_type,
                                                              i_task_dependency_from,
                                                              i_task_dependency_to,
                                                              odst_tsk.id_order_set_task,
                                                              odst_tsk.id_task_type)
                              FROM dual) flg_schedule_task,
                           (SELECT get_task_desc(i_lang,
                                                 i_prof,
                                                 odst_tsk.id_order_set_task,
                                                 odst_tsk.id_task_type,
                                                 i_flg_process,
                                                 pk_alert_constant.g_no,
                                                 g_task_desc_extended_format,
                                                 pk_alert_constant.g_no)
                              FROM dual) task_desc,
                           (SELECT get_task_instructions_desc(i_lang,
                                                              i_prof,
                                                              table_number(odst_tsk.id_order_set_task),
                                                              i_flg_process)
                              FROM dual) task_instruct
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                                      column_value
                                                       FROM TABLE(i_dependencies_scope) t)
                     ORDER BY flg_schedule_task,
                              get_task_type_rank(i_lang, i_prof, odst_tsk.id_task_type),
                              odst_tsk.id_task_type,
                              task_desc,
                              task_instruct);
        
            -- order sets front-office
        ELSE
            -- prepare rank arrays
            SELECT id_order_set_process_task, NULL root
              BULK COLLECT
              INTO l_dependency, l_dependency_root
              FROM (SELECT odst_proc_tsk.id_order_set_process_task,
                           odst_proc_tsk.flg_schedule flg_schedule_task,
                           (SELECT get_task_desc(i_lang,
                                                 i_prof,
                                                 odst_proc_tsk.id_order_set_process_task,
                                                 odst_proc_tsk.id_task_type,
                                                 i_flg_process,
                                                 pk_alert_constant.g_no,
                                                 g_task_desc_extended_format,
                                                 pk_alert_constant.g_no)
                              FROM dual) task_desc,
                           (SELECT get_task_instructions_desc(i_lang,
                                                              i_prof,
                                                              table_number(odst_proc_tsk.id_order_set_process_task),
                                                              i_flg_process)
                              FROM dual) task_instruct
                      FROM order_set_process_task odst_proc_tsk
                     INNER JOIN order_set_process odst_proc
                        ON (odst_proc_tsk.id_order_set_process = odst_proc.id_order_set_process)
                     INNER JOIN order_set odst
                        ON (odst.id_order_set = odst_proc.id_order_set)
                     WHERE odst_proc_tsk.id_order_set_process IN
                           (SELECT /*+ opt_estimate(table t rows = 1) */
                             column_value
                              FROM TABLE(i_dependencies_scope) t)
                     ORDER BY flg_schedule_task,
                              get_task_type_rank(i_lang, i_prof, odst_proc_tsk.id_task_type),
                              pk_sysdomain.get_rank(i_lang, g_odst_ptsk_flg_status_domain, odst_proc_tsk.flg_status),
                              upper(odst.title),
                              odst_proc_tsk.id_task_type,
                              task_desc,
                              task_instruct);
        
        END IF;
    
        -- process dependencies into l_dtbl    
        FOR i IN 1 .. i_dependency_type.count
        LOOP
            l_drec.id_relationship_type    := i_dependency_type(i);
            l_drec.id_task_dependency_from := i_task_dependency_from(i);
            l_drec.id_task_dependency_to   := i_task_dependency_to(i);
            l_dtbl.extend;
            l_dtbl(i) := l_drec;
        END LOOP;
    
        -- calculate the most deep root of each dependency
        FOR rec IN (SELECT DISTINCT id_task_dependency_to,
                                    first_value(id_task_dependency_from) over(PARTITION BY id_task_dependency_to ORDER BY lvl DESC) AS root
                      FROM (SELECT LEVEL AS lvl, drl.id_task_dependency_to, drl.id_task_dependency_from
                              FROM TABLE(CAST(l_dtbl AS t_tbl_tde_network)) drl
                             START WITH NOT EXISTS
                             (SELECT 1
                                           FROM TABLE(CAST(l_dtbl AS t_tbl_tde_network)) f2s
                                          WHERE f2s.id_task_dependency_to = drl.id_task_dependency_from
                                            AND f2s.id_task_dependency_from NOT IN
                                                (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                                    AND drl.id_task_dependency_from NOT IN
                                        (to_number(g_depend_current_epis), to_number(g_depend_future_epis))
                            CONNECT BY PRIOR drl.id_task_dependency_to = drl.id_task_dependency_from
                                   AND drl.id_task_dependency_from NOT IN
                                       (to_number(g_depend_current_epis), to_number(g_depend_future_epis))))
        LOOP
            l_dependency_root(get_dependency_index(rec.id_task_dependency_to, l_dependency)) := rec.root;
        END LOOP;
    
        -- process dependencies and its root into l_dep_root_tbl 
        FOR i IN 1 .. l_dependency.count
        LOOP
            l_dep_root_rec.id_dependency := l_dependency(i);
            l_dep_root_rec.id_root       := l_dependency_root(i);
            l_dep_root_rec.order_num     := i;
            l_dep_root_tbl.extend;
            l_dep_root_tbl(i) := l_dep_root_rec;
        END LOOP;
    
        -- calculate rank of each dependency
        SELECT id_dependency
          BULK COLLECT
          INTO l_tasks_rank
          FROM (SELECT id_dependency, id_root, order_num
                  FROM TABLE(CAST(l_dep_root_tbl AS t_tbl_odst_depend_root))) dep_root
         START WITH dep_root.id_root IS NULL
        CONNECT BY dep_root.id_root = PRIOR dep_root.id_dependency
         ORDER SIBLINGS BY dep_root.order_num;
    
        -- copy tasks rank to the output parameter
        o_tasks_rank := l_tasks_rank;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_DEPENDENCY_RANK',
                                              o_error);
        
            RETURN FALSE;
    END get_task_dependency_rank;

    FUNCTION get_odst_depends_network
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_dependencies_scope   IN table_number,
        i_flg_process          IN VARCHAR2,
        o_dependency_type      OUT table_number,
        o_task_dependency_from OUT table_number,
        o_task_dependency_to   OUT table_number,
        o_task_type_from       OUT table_number,
        o_task_type_to         OUT table_number,
        o_task_schedule_from   OUT table_varchar,
        o_task_schedule_to     OUT table_varchar,
        o_lag_min              OUT table_number,
        o_lag_max              OUT table_number,
        o_lag_unit_measure     OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dependency_type      table_number := table_number();
        l_task_dependency_from table_number := table_number();
        l_task_dependency_to   table_number := table_number();
        l_task_type_from       table_number := table_number();
        l_task_type_to         table_number := table_number();
        l_task_schedule_from   table_varchar := table_varchar();
        l_task_schedule_to     table_varchar := table_varchar();
        l_lag_min              table_number := table_number();
        l_lag_max              table_number := table_number();
        l_lag_unit_measure     table_number := table_number();
    
    BEGIN
    
        g_error := 'GET TASK DEPENDENCIES NETWORK';
        -- verify order set dependencies scope
        -- order sets back-office
        IF i_flg_process = pk_alert_constant.g_no
        THEN
            -- << gets all dependencies existing in the order set >>
            SELECT odst_tsk_dep.id_relationship_type dependency_type,
                   odst_tsk_dep.id_order_set_task_from task_dependency_from,
                   nvl(odst_tsk_from.id_task_type,
                       decode(odst_tsk_dep.id_order_set_task_from,
                              to_number(g_depend_current_epis),
                              pk_alert_constant.g_task_current_epis,
                              to_number(g_depend_future_epis),
                              pk_alert_constant.g_task_future_epis)) task_type_from,
                   odst_tsk_dep.id_order_set_task_to task_dependency_to,
                   odst_tsk_to.id_task_type task_type_to,
                   odst_tsk_dep.lag_min lag_min,
                   odst_tsk_dep.lag_max lag_max,
                   odst_tsk_dep.id_unit_measure_lag lag_unit_measure
              BULK COLLECT
              INTO l_dependency_type,
                   l_task_dependency_from,
                   l_task_type_from,
                   l_task_dependency_to,
                   l_task_type_to,
                   l_lag_min,
                   l_lag_max,
                   l_lag_unit_measure
              FROM order_set_task_dependency odst_tsk_dep
             INNER JOIN order_set_task odst_tsk_to
                ON (odst_tsk_dep.id_order_set_task_to = odst_tsk_to.id_order_set_task)
              LEFT JOIN order_set_task odst_tsk_from
                ON (odst_tsk_dep.id_order_set_task_from = odst_tsk_from.id_order_set_task)
             WHERE odst_tsk_dep.id_order_set IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                                  column_value
                                                   FROM TABLE(i_dependencies_scope) t);
        
            -- << for each dependency, verify if it is an episode (schedule task) or not >>
            FOR i IN 1 .. l_dependency_type.count
            LOOP
                l_task_schedule_from.extend;
                l_task_schedule_from(i) := check_episode_support_task(i_lang,
                                                                      i_prof,
                                                                      l_dependency_type,
                                                                      l_task_dependency_from,
                                                                      l_task_dependency_to,
                                                                      l_task_dependency_from(i),
                                                                      l_task_type_from(i));
            
                l_task_schedule_to.extend;
                l_task_schedule_to(i) := check_episode_support_task(i_lang,
                                                                    i_prof,
                                                                    l_dependency_type,
                                                                    l_task_dependency_from,
                                                                    l_task_dependency_to,
                                                                    l_task_dependency_to(i),
                                                                    l_task_type_to(i));
            END LOOP;
        
            -- order sets front-office
        ELSE
            -- << gets all dependencies existing in the order set process >>
            SELECT odst_proc_tsk_dep.id_relationship_type dependency_type,
                   odst_proc_tsk_dep.id_order_set_proc_task_from task_dependency_from,
                   nvl(odst_proc_tsk_from.id_task_type,
                       decode(odst_proc_tsk_dep.id_order_set_proc_task_from,
                              to_number(g_depend_current_epis),
                              pk_alert_constant.g_task_current_epis,
                              to_number(g_depend_future_epis),
                              pk_alert_constant.g_task_future_epis)) task_type_from,
                   odst_proc_tsk_from.flg_schedule task_schedule_from,
                   odst_proc_tsk_dep.id_order_set_proc_task_to task_dependency_to,
                   odst_proc_tsk_to.id_task_type task_type_to,
                   odst_proc_tsk_to.flg_schedule task_schedule_to,
                   odst_proc_tsk_dep.lag_min lag_min,
                   odst_proc_tsk_dep.lag_max lag_max,
                   odst_proc_tsk_dep.id_unit_measure_lag lag_unit_measure
              BULK COLLECT
              INTO l_dependency_type,
                   l_task_dependency_from,
                   l_task_type_from,
                   l_task_schedule_from,
                   l_task_dependency_to,
                   l_task_type_to,
                   l_task_schedule_to,
                   l_lag_min,
                   l_lag_max,
                   l_lag_unit_measure
              FROM order_set_process_task_depend odst_proc_tsk_dep
             INNER JOIN order_set_process_task odst_proc_tsk_to
                ON odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk_to.id_order_set_process_task
              LEFT JOIN order_set_process_task odst_proc_tsk_from
                ON odst_proc_tsk_dep.id_order_set_proc_task_from = odst_proc_tsk_from.id_order_set_process_task
             WHERE odst_proc_tsk_dep.id_order_set_process IN
                   (SELECT /*+ opt_estimate(table t rows = 1) */
                     column_value
                      FROM TABLE(i_dependencies_scope) t);
        END IF;
    
        -- copy results to output parameters
        o_dependency_type      := l_dependency_type;
        o_task_dependency_from := l_task_dependency_from;
        o_task_dependency_to   := l_task_dependency_to;
        o_task_type_from       := l_task_type_from;
        o_task_type_to         := l_task_type_to;
        o_task_schedule_from   := l_task_schedule_from;
        o_task_schedule_to     := l_task_schedule_to;
        o_lag_min              := l_lag_min;
        o_lag_max              := l_lag_max;
        o_lag_unit_measure     := l_lag_unit_measure;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_DEPENDS_NETWORK',
                                              o_error);
            RETURN FALSE;
    END get_odst_depends_network;

    FUNCTION get_task_depends_network
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_task         IN order_set_task.id_order_set_task%TYPE,
        i_popup_dependency_type  IN table_number DEFAULT NULL,
        i_popup_dependency       IN table_number DEFAULT NULL,
        i_popup_lag_min          IN table_number DEFAULT NULL,
        i_popup_lag_max          IN table_number DEFAULT NULL,
        i_popup_lag_unit_measure IN table_number DEFAULT NULL,
        o_dependency_type        OUT table_number,
        o_task_dependency_from   OUT table_number,
        o_task_dependency_to     OUT table_number,
        o_task_type_from         OUT table_number,
        o_task_type_to           OUT table_number,
        o_task_schedule_from     OUT table_varchar,
        o_task_schedule_to       OUT table_varchar,
        o_lag_min                OUT table_number,
        o_lag_max                OUT table_number,
        o_lag_unit_measure       OUT table_number,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
        -- gets type of the order set task 
        l_task_type task_type.id_task_type%TYPE := get_odst_task_type(i_lang, i_prof, i_order_set_task);
    
        l_dependency_type      table_number := table_number();
        l_task_dependency_from table_number := table_number();
        l_task_dependency_to   table_number := table_number();
        l_task_type_from       table_number := table_number();
        l_task_type_to         table_number := table_number();
        l_task_schedule_from   table_varchar := table_varchar();
        l_task_schedule_to     table_varchar := table_varchar();
        l_lag_min              table_number := table_number();
        l_lag_max              table_number := table_number();
        l_lag_unit_measure     table_number := table_number();
    
        l_depend_index PLS_INTEGER;
    
    BEGIN
    
        g_error := 'GET TASK DEPENDENCIES NETWORK';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- << gets all dependencies existing in the order set >>
        SELECT odst_tsk_dep.id_relationship_type dependency_type,
               odst_tsk_dep.id_order_set_task_from task_dependency_from,
               nvl(odst_tsk_from.id_task_type,
                   decode(odst_tsk_dep.id_order_set_task_from,
                          to_number(g_depend_current_epis),
                          pk_alert_constant.g_task_current_epis,
                          to_number(g_depend_future_epis),
                          pk_alert_constant.g_task_future_epis)) task_type_from,
               odst_tsk_dep.id_order_set_task_to task_dependency_to,
               odst_tsk_to.id_task_type task_type_to,
               odst_tsk_dep.lag_min lag_min,
               odst_tsk_dep.lag_max lag_max,
               odst_tsk_dep.id_unit_measure_lag lag_unit_measure
          BULK COLLECT
          INTO l_dependency_type,
               l_task_dependency_from,
               l_task_type_from,
               l_task_dependency_to,
               l_task_type_to,
               l_lag_min,
               l_lag_max,
               l_lag_unit_measure
          FROM order_set_task_dependency odst_tsk_dep
         INNER JOIN order_set_task odst_tsk_to
            ON (odst_tsk_dep.id_order_set_task_to = odst_tsk_to.id_order_set_task)
          LEFT JOIN order_set_task odst_tsk_from
            ON (odst_tsk_dep.id_order_set_task_from = odst_tsk_from.id_order_set_task)
        -- if pop-up dependencies parameters are not empty,
        -- task dependencies (and not task dependents) existing in the database will be ignored 
        -- (pop-up dependencies will override them)
         WHERE ((i_popup_dependency_type IS NOT NULL AND odst_tsk_dep.id_order_set_task_to != i_order_set_task) OR
               i_popup_dependency_type IS NULL)
              -- return only tasks of the current order set
           AND odst_tsk_dep.id_order_set =
               (SELECT odst_tsk.id_order_set
                  FROM order_set_task odst_tsk
                 WHERE odst_tsk.id_order_set_task = i_order_set_task);
    
        -- get last dependencies array index
        l_depend_index := l_dependency_type.count;
    
        -- << add pop-up task dependencies to the network if they exist >>
        -- loop for each pop-up task dependency
        IF i_popup_dependency_type IS NOT NULL
        THEN
            FOR i IN 1 .. i_popup_dependency_type.count
            LOOP
                -- create an index for a new dependency
                l_dependency_type.extend;
                l_task_dependency_from.extend;
                l_task_dependency_to.extend;
                l_task_type_from.extend;
                l_task_type_to.extend;
                l_lag_min.extend;
                l_lag_max.extend;
                l_lag_unit_measure.extend;
            
                -- get index
                l_depend_index := l_depend_index + 1;
            
                -- copy new dependency to dependencies array
                l_dependency_type(l_depend_index) := i_popup_dependency_type(i);
                l_task_dependency_from(l_depend_index) := i_popup_dependency(i);
                l_task_type_from(l_depend_index) := (CASE i_popup_dependency(i)
                                                        WHEN to_number(g_depend_current_epis) THEN
                                                         pk_alert_constant.g_task_current_epis
                                                        WHEN to_number(g_depend_future_epis) THEN
                                                         pk_alert_constant.g_task_future_epis
                                                        ELSE
                                                         get_odst_task_type(i_lang, i_prof, i_popup_dependency(i))
                                                    END);
                l_task_dependency_to(l_depend_index) := i_order_set_task;
                l_task_type_to(l_depend_index) := l_task_type;
                l_lag_min(l_depend_index) := CASE
                                                 WHEN i_popup_lag_min(i) = -1 THEN
                                                  NULL
                                                 ELSE
                                                  i_popup_lag_min(i)
                                             END;
                l_lag_max(l_depend_index) := CASE
                                                 WHEN i_popup_lag_max(i) = -1 THEN
                                                  NULL
                                                 ELSE
                                                  i_popup_lag_max(i)
                                             END;
                l_lag_unit_measure(l_depend_index) := i_popup_lag_unit_measure(i);
            
            END LOOP;
        END IF;
    
        -- << for each dependency, verify if it is an episode (schedule task) or not >>
        FOR i IN 1 .. l_dependency_type.count
        LOOP
            l_task_schedule_from.extend;
            l_task_schedule_from(i) := check_episode_support_task(i_lang,
                                                                  i_prof,
                                                                  l_dependency_type,
                                                                  l_task_dependency_from,
                                                                  l_task_dependency_to,
                                                                  l_task_dependency_from(i),
                                                                  l_task_type_from(i));
        
            l_task_schedule_to.extend;
            l_task_schedule_to(i) := check_episode_support_task(i_lang,
                                                                i_prof,
                                                                l_dependency_type,
                                                                l_task_dependency_from,
                                                                l_task_dependency_to,
                                                                l_task_dependency_to(i),
                                                                l_task_type_to(i));
        END LOOP;
    
        -- copy results to output parameters
        o_dependency_type      := l_dependency_type;
        o_task_dependency_from := l_task_dependency_from;
        o_task_dependency_to   := l_task_dependency_to;
        o_task_type_from       := l_task_type_from;
        o_task_type_to         := l_task_type_to;
        o_task_schedule_from   := l_task_schedule_from;
        o_task_schedule_to     := l_task_schedule_to;
        o_lag_min              := l_lag_min;
        o_lag_max              := l_lag_max;
        o_lag_unit_measure     := l_lag_unit_measure;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_DEPENDS_NETWORK',
                                              o_error);
            RETURN FALSE;
    END get_task_depends_network;

    FUNCTION update_depends_preselection
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_order_set_task       IN order_set_task.id_order_set_task%TYPE,
        o_changed_dependencies OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_odst_tsk_preselection VARCHAR2(1 CHAR);
        l_predecessors          table_number;
        l_sucessors             table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
        -- get preselection value of the order set task
        l_odst_tsk_preselection := get_task_presel(i_lang, i_prof, i_order_set_task);
        -- get task dependencies network
        IF NOT get_task_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_order_set_task       => i_order_set_task,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        
        THEN
            g_error := 'error found while calling get_task_depends_network function';
            RAISE l_exception;
        END IF;
    
        -- if the order set task pre-selection value is false,
        -- then update all sucessors with this value
        IF l_odst_tsk_preselection = pk_alert_constant.g_no
        THEN
        
            -- get all sucessors
            l_sucessors := pk_tde_db.get_sucessor_dependencies(i_dependency           => i_order_set_task,
                                                               i_relationship_type    => l_dependency_type,
                                                               i_task_dependency_from => l_task_dependency_from,
                                                               i_task_dependency_to   => l_task_dependency_to,
                                                               i_task_type_from       => l_task_type_from,
                                                               i_task_type_to         => l_task_type_to);
        
            -- all sucessors must be unselected
            UPDATE order_set_task_detail odst_tsk_det
               SET odst_tsk_det.vvalue = pk_alert_constant.g_no
             WHERE odst_tsk_det.id_advanced_input_field = g_adv_input_field_selected
               AND odst_tsk_det.vvalue != pk_alert_constant.g_no
               AND odst_tsk_det.id_order_set_task IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                                       column_value
                                                        FROM TABLE(l_sucessors) t)
            RETURNING odst_tsk_det.id_order_set_task BULK COLLECT INTO o_changed_dependencies;
        
            -- if the order set task pre-selection value is true,
            -- then update all predecessors with this value
        ELSE
        
            -- get all predecessors   
            l_predecessors := pk_tde_db.get_predecessor_dependencies(i_dependency           => i_order_set_task,
                                                                     i_relationship_type    => l_dependency_type,
                                                                     i_task_dependency_from => l_task_dependency_from,
                                                                     i_task_dependency_to   => l_task_dependency_to,
                                                                     i_task_type_from       => l_task_type_from,
                                                                     i_task_type_to         => l_task_type_to);
        
            -- all predecessors must be selected
            UPDATE order_set_task_detail odst_tsk_det
               SET odst_tsk_det.vvalue = pk_alert_constant.g_yes
             WHERE odst_tsk_det.id_advanced_input_field = g_adv_input_field_selected
               AND odst_tsk_det.vvalue != pk_alert_constant.g_yes
               AND odst_tsk_det.id_order_set_task IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                                       column_value
                                                        FROM TABLE(l_predecessors) t)
            RETURNING odst_tsk_det.id_order_set_task BULK COLLECT INTO o_changed_dependencies;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_DEPENDS_PRESELECTION',
                                              o_error);
            RETURN FALSE;
    END update_depends_preselection;

    FUNCTION set_task_presel
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_order_set_task       IN table_number,
        i_flg_task_selected    IN VARCHAR2,
        o_updated_presel_tasks OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_changed_tasks     table_number;
        l_all_changed_tasks table_number := table_number();
    
        l_exception EXCEPTION;
    
    BEGIN
    
        pk_alertlog.log_debug('set task pre-selection', g_package_name);
        FOR i IN 1 .. i_order_set_task.count
        LOOP
        
            l_changed_tasks := table_number();
        
            -- update flg_task_selected (task pre-selection) status
            UPDATE order_set_task_detail odst_tsk_det
               SET odst_tsk_det.vvalue = i_flg_task_selected
             WHERE odst_tsk_det.id_order_set_task = i_order_set_task(i)
               AND odst_tsk_det.flg_detail_type = g_task_det_adv_input
               AND odst_tsk_det.id_advanced_input_field = g_adv_input_field_selected;
        
            -- if previous update had no effect, then insert new record          
            IF (SQL%ROWCOUNT = 0)
            THEN
                INSERT INTO order_set_task_detail
                    (id_order_set_task_detail,
                     id_order_set_task,
                     flg_value_type,
                     vvalue,
                     flg_detail_type,
                     id_advanced_input,
                     id_advanced_input_field,
                     id_advanced_input_field_det)
                VALUES
                    (seq_order_set_task_detail.nextval,
                     i_order_set_task(i),
                     g_task_det_value_type_varchar,
                     i_flg_task_selected,
                     g_task_det_adv_input,
                     NULL,
                     g_adv_input_field_selected,
                     NULL);
            END IF;
        
            -- update dependent tasks selection
            IF NOT update_depends_preselection(i_lang, i_prof, i_order_set_task(i), l_changed_tasks, o_error)
            THEN
                g_error := 'error found while updating task dependencies';
                RAISE l_exception;
            END IF;
        
            -- add own selected task to the changed tasks array
            l_changed_tasks.extend;
            l_changed_tasks(l_changed_tasks.count) := i_order_set_task(i);
        
            -- collect all changed tasks into a single collection
            l_all_changed_tasks := l_all_changed_tasks MULTISET UNION DISTINCT l_changed_tasks;
        
        END LOOP;
    
        -- commit changes
        COMMIT;
    
        -- open cursor to change dependent tasks pre-selection status 
        OPEN o_updated_presel_tasks FOR
            SELECT order_set_task.column_value id_order_set_task,
                   i_flg_task_selected flg_task_selected,
                   pk_sysdomain.get_domain(g_odst_tsks_order_stat_domain, i_flg_task_selected, i_lang) task_selected_desc
              FROM TABLE(l_all_changed_tasks) order_set_task;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_TASK_PRESEL',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_updated_presel_tasks);
            RETURN FALSE;
    END set_task_presel;

    FUNCTION set_proc_task_presel
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_order_set_proc_task       IN table_number,
        i_flg_task_selected         IN VARCHAR2,
        o_updated_presel_proc_tasks OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
        l_exception EXCEPTION;
    BEGIN
        pk_alertlog.log_debug('set process task selection', g_package_name);
    
        FOR i IN 1 .. i_order_set_proc_task.count
        LOOP
        
            -- update flg_task_selected (task selection) status
            UPDATE order_set_process_task_det odst_proc_tsk_det
               SET odst_proc_tsk_det.vvalue = i_flg_task_selected
             WHERE odst_proc_tsk_det.id_order_set_process_task = i_order_set_proc_task(i)
               AND odst_proc_tsk_det.flg_detail_type = g_task_det_adv_input
               AND odst_proc_tsk_det.id_advanced_input_field = g_adv_input_field_selected;
        
            -- if previous update had no effect, then insert new record          
            IF (SQL%ROWCOUNT = 0)
            THEN
                INSERT INTO order_set_process_task_det
                    (id_order_set_process_task_det,
                     id_order_set_process_task,
                     flg_value_type,
                     vvalue,
                     flg_detail_type,
                     id_advanced_input,
                     id_advanced_input_field,
                     id_advanced_input_field_det)
                VALUES
                    (seq_order_set_process_task_det.nextval,
                     i_order_set_proc_task(i),
                     g_task_det_value_type_varchar,
                     i_flg_task_selected,
                     g_task_det_adv_input,
                     NULL,
                     g_adv_input_field_selected,
                     NULL);
            END IF;
        
        -- TODO: update here task selection according to its dependencies
        
        END LOOP;
    
        -- commit changes
        COMMIT;
    
        -- open cursor to change dependent process tasks selection status 
        OPEN o_updated_presel_proc_tasks FOR
            SELECT order_set_proc_task.column_value id_order_set_process_task,
                   i_flg_task_selected flg_task_selected,
                   pk_sysdomain.get_domain(g_odst_tsks_order_stat_domain, i_flg_task_selected, i_lang) task_selected_desc
              FROM TABLE(i_order_set_proc_task) order_set_proc_task;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PROC_TASK_PRESEL',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_updated_presel_proc_tasks);
            RETURN FALSE;
    END set_proc_task_presel;

    FUNCTION get_task_rank
    (
        i_task_ranks     IN table_number,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN NUMBER IS
    BEGIN
    
        g_error := 'GET DEPENDENCY ORDER';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        FOR i IN 1 .. i_task_ranks.count
        LOOP
        
            -- search for order set task and returns its dependency order
            IF i_task_ranks(i) = i_order_set_task
            THEN
                RETURN i;
            END IF;
        
        END LOOP;
    
        RETURN NULL;
    
    END get_task_rank;

    FUNCTION get_odst_task_type
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN order_set_task.id_task_type%TYPE IS
    
        l_task_type order_set_task.id_task_type%TYPE;
    
    BEGIN
    
        pk_alertlog.log_debug('GET ORDER SET TASK TYPE', g_package_name);
        SELECT odst_task.id_task_type
          INTO l_task_type
          FROM order_set_task odst_task
         WHERE odst_task.id_order_set_task = i_order_set_task;
    
        RETURN l_task_type;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_odst_task_type;

    FUNCTION get_odst_proc_task_type
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN order_set_process_task.id_task_type%TYPE IS
    
        l_task_type order_set_task.id_task_type%TYPE;
    
    BEGIN
    
        pk_alertlog.log_debug('GET ORDER SET PROCESS TASK TYPE', g_package_name);
        SELECT odst_proc_task.id_task_type
          INTO l_task_type
          FROM order_set_process_task odst_proc_task
         WHERE odst_proc_task.id_order_set_process_task = i_order_set_process_task;
    
        RETURN l_task_type;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_odst_proc_task_type;

    FUNCTION get_task_detail_description
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_episode         IN episode.id_episode%TYPE,
        i_task_type       IN task_type.id_task_type%TYPE,
        i_flg_detail_type IN order_set_task_detail.flg_detail_type%TYPE,
        i_detail_nvalue   IN order_set_task_detail.nvalue%TYPE,
        i_detail_dvalue   IN order_set_task_detail.dvalue%TYPE,
        i_detail_vvalue   IN order_set_task_detail.vvalue%TYPE
    ) RETURN VARCHAR2 IS
    
        l_task_detail_desc VARCHAR2(1000 CHAR);
    
        l_error t_error_out;
        l_exception EXCEPTION;
    
        -- auxiliary variables
        l_follow_up_type_desc     pk_translation.t_desc_translation;
        l_follow_up_type_unit_mea pk_translation.t_desc_translation;
    
    BEGIN
    
        g_error := 'GET TASK DETAIL DESCRIPTION';
        CASE i_flg_detail_type
            WHEN g_tsk_det_type_follow_in THEN
                -- Discharge instructions: Follow-up in
                IF NOT pk_discharge.get_follow_up_type_desc(i_lang                    => i_lang,
                                                            i_prof                    => i_prof,
                                                            i_follow_up_type          => i_detail_nvalue,
                                                            o_follow_up_type_desc     => l_follow_up_type_desc,
                                                            o_follow_up_type_unit_mea => l_follow_up_type_unit_mea,
                                                            o_error                   => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- process follow-up in value
                CASE i_detail_nvalue
                -- Date
                    WHEN pk_discharge.g_follow_up_date THEN
                        l_task_detail_desc := pk_date_utils.date_char_tsz(i_lang,
                                                                          pk_date_utils.get_string_tstz(i_lang,
                                                                                                        i_prof,
                                                                                                        i_detail_vvalue,
                                                                                                        NULL),
                                                                          i_prof.institution,
                                                                          i_prof.software);
                        -- Number of days
                    WHEN pk_discharge.g_follow_up_days THEN
                        l_task_detail_desc := TRIM(i_detail_vvalue || ' ' || l_follow_up_type_unit_mea);
                        -- SOS
                    WHEN pk_discharge.g_follow_up_sos THEN
                        l_task_detail_desc := l_follow_up_type_desc;
                END CASE;
            
            WHEN g_tsk_det_type_follow_with THEN
                -- Discharge instructions: Follow-up with
                l_task_detail_desc := pk_discharge.get_follow_up_with_entity_desc(i_lang        => i_lang,
                                                                                  i_prof        => i_prof,
                                                                                  i_entity_prof => i_detail_nvalue);
            WHEN g_tsk_det_type_prof THEN
                -- Professional
                l_task_detail_desc := pk_opinion.get_opinion_prof_desc(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_opinion_prof => i_detail_nvalue);
            WHEN g_tsk_det_type_diag THEN
                -- Diagnosis
                l_task_detail_desc := pk_diagnosis.get_epis_diag_desc(i_lang            => i_lang,
                                                                      i_prof            => i_prof,
                                                                      i_episode         => i_episode,
                                                                      i_diagnosis       => i_detail_nvalue,
                                                                      i_alert_diagnosis => to_number(i_detail_vvalue));
            
            WHEN g_tsk_det_type_inp_adm THEN
                -- Inpatient: indication for admission
                l_task_detail_desc := pk_admission_request.get_adm_indication_desc(i_prof              => i_prof,
                                                                                   i_lang              => i_lang,
                                                                                   i_id_adm_indication => i_detail_nvalue);
            WHEN g_tsk_det_type_surg_proc THEN
                -- Inpatient: surgical procedure
                l_task_detail_desc := pk_surgery_request.get_sr_interv_description(i_lang            => i_lang,
                                                                                   i_prof            => i_prof,
                                                                                   i_sr_intervention => i_detail_nvalue);
            
            WHEN g_tsk_det_type_appoint_locat THEN
                -- Appointment: Location
                l_task_detail_desc := pk_utils.get_institution_name(i_lang           => i_lang,
                                                                    i_id_institution => i_detail_nvalue);
            
            WHEN g_tsk_det_type_appoint_type THEN
                -- Appointment: type of appointment
                l_task_detail_desc := pk_events.get_type_of_visit_desc(i_lang          => i_lang,
                                                                       i_prof          => i_prof,
                                                                       i_dep_clin_serv => i_detail_nvalue,
                                                                       i_task_type     => i_task_type);
            
            ELSE
                -- unknown task detail
                l_task_detail_desc := NULL;
        END CASE;
    
        RETURN l_task_detail_desc;
    
    EXCEPTION
        WHEN OTHERS THEN
            RETURN NULL;
    END get_task_detail_description;

    FUNCTION get_odst_tasks_det_data
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_order_set_tasks IN table_number,
        i_flg_detail_type    IN table_varchar
    ) RETURN pk_types.cursor_type IS
    
        l_count_order_set_tasks CONSTANT PLS_INTEGER := i_id_order_set_tasks.count;
    
        c_order_set_tasks_details pk_types.cursor_type;
    
    BEGIN
    
        -- optimizes query if only one task ID is given
        IF l_count_order_set_tasks > 1
        THEN
            -- get order set tasks details data 
            OPEN c_order_set_tasks_details FOR
                SELECT /*+opt_estimate(table os_tsk rows=1)*/
                DISTINCT nvl2(common_odst_td.flg_detail_type, odst_td.flg_value_type, NULL) flg_value_type,
                         nvl2(common_odst_td.flg_detail_type, odst_td.nvalue, NULL) nvalue,
                         nvl2(common_odst_td.flg_detail_type,
                              pk_date_utils.date_send_tsz(i_lang, odst_td.dvalue, i_prof),
                              NULL) dvalue,
                         nvl2(common_odst_td.flg_detail_type, odst_td.vvalue, NULL) vvalue,
                         odst_td.flg_detail_type,
                         odst_td.id_advanced_input,
                         odst_td.id_advanced_input_field,
                         odst_td.id_advanced_input_field_det,
                         nvl2(common_odst_td.flg_detail_type, odst_td.id_unit_measure, NULL) id_unit_measure,
                         -- indicates if this field has multiple values for all selected tasks or not
                         nvl2(common_odst_td.flg_detail_type, g_no, g_yes) flg_multi_values,
                         nvl2(common_odst_td.flg_detail_type,
                              get_task_detail_description(i_lang,
                                                          i_prof,
                                                          NULL, -- episode ID is not necessary in this context
                                                          get_odst_task_type(i_lang, i_prof, os_tsk.column_value),
                                                          odst_td.flg_detail_type,
                                                          odst_td.nvalue,
                                                          odst_td.dvalue,
                                                          odst_td.vvalue),
                              NULL) task_detail_desc
                  FROM ((order_set_task_detail odst_td JOIN TABLE(i_id_order_set_tasks) os_tsk ON
                        odst_td.id_order_set_task = os_tsk.column_value) LEFT OUTER JOIN
                       -- verify which advanced input fields have the same value for all selected tasks
                        (SELECT /*+opt_estimate(table odst_tsk rows=1)*/
                          odst_tsk_det.flg_detail_type,
                          odst_tsk_det.id_advanced_input,
                          odst_tsk_det.id_advanced_input_field,
                          odst_tsk_det.id_advanced_input_field_det
                           FROM order_set_task_detail odst_tsk_det, TABLE(i_id_order_set_tasks) odst_tsk
                          WHERE odst_tsk_det.id_order_set_task = odst_tsk.column_value
                          GROUP BY odst_tsk_det.flg_detail_type,
                                   odst_tsk_det.id_advanced_input,
                                   odst_tsk_det.id_advanced_input_field,
                                   odst_tsk_det.id_advanced_input_field_det
                         HAVING COUNT(DISTINCT(nvl(to_char(odst_tsk_det.flg_value_type), -1))) = 1 AND COUNT(DISTINCT(nvl(to_char(odst_tsk_det.nvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_tsk_det.dvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_tsk_det.vvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_tsk_det.id_unit_measure), -1))) <= 1 AND COUNT(odst_tsk_det.id_order_set_task_detail) = l_count_order_set_tasks)
                        common_odst_td ON
                        odst_td.flg_detail_type = common_odst_td.flg_detail_type AND
                        nvl(odst_td.id_advanced_input, -1) = nvl(common_odst_td.id_advanced_input, -1) AND
                        nvl(odst_td.id_advanced_input_field, -1) = nvl(common_odst_td.id_advanced_input_field, -1) AND
                        nvl(odst_td.id_advanced_input_field_det, -1) =
                        nvl(common_odst_td.id_advanced_input_field_det, -1))
                 WHERE (i_flg_detail_type IS NULL OR
                       (i_flg_detail_type IS NOT NULL AND
                       odst_td.flg_detail_type IN
                       (SELECT /*+opt_estimate(table det_type rows=1)*/
                           det_type.column_value
                            FROM TABLE(i_flg_detail_type) det_type)))
                -- order by fields rank                                                   
                 ORDER BY odst_td.flg_detail_type,
                          odst_td.id_advanced_input,
                          (SELECT ord_aisi.rank
                             FROM advanced_input_soft_inst ord_aisi
                            WHERE ord_aisi.id_institution IN (g_all_institution, i_prof.institution)
                              AND ord_aisi.id_software IN (g_all_software, i_prof.software)
                              AND ord_aisi.flg_active = g_yes
                              AND ord_aisi.id_advanced_input = nvl(odst_td.id_advanced_input, -1)
                              AND ord_aisi.id_advanced_input_field = nvl(odst_td.id_advanced_input_field, -1)),
                          (SELECT ord_aifd.rank
                             FROM advanced_input_field_det ord_aifd
                            WHERE ord_aifd.id_advanced_input_field_det = nvl(odst_td.id_advanced_input_field_det, -1));
        ELSE
            -- get order set task details data 
            OPEN c_order_set_tasks_details FOR
                SELECT /*+opt_estimate(table os_tsk rows=1)*/
                DISTINCT odst_td.flg_value_type,
                         odst_td.nvalue nvalue,
                         pk_date_utils.date_send_tsz(i_lang, odst_td.dvalue, i_prof) dvalue,
                         odst_td.vvalue vvalue,
                         odst_td.flg_detail_type,
                         odst_td.id_advanced_input,
                         odst_td.id_advanced_input_field,
                         odst_td.id_advanced_input_field_det,
                         odst_td.id_unit_measure,
                         -- indicates if this field has multiple values for all selected tasks or not
                         g_no flg_multi_values,
                         get_task_detail_description(i_lang,
                                                     i_prof,
                                                     NULL, -- episode ID is not necessary in this context
                                                     get_odst_task_type(i_lang, i_prof, os_tsk.column_value),
                                                     odst_td.flg_detail_type,
                                                     odst_td.nvalue,
                                                     odst_td.dvalue,
                                                     odst_td.vvalue) task_detail_desc
                  FROM order_set_task_detail odst_td
                  JOIN TABLE(i_id_order_set_tasks) os_tsk
                    ON odst_td.id_order_set_task = os_tsk.column_value
                 WHERE (i_flg_detail_type IS NULL OR
                       (i_flg_detail_type IS NOT NULL AND
                       odst_td.flg_detail_type IN
                       (SELECT /*+opt_estimate(table det_type rows=1)*/
                           det_type.column_value
                            FROM TABLE(i_flg_detail_type) det_type)))
                -- order by fields rank                                                   
                 ORDER BY odst_td.flg_detail_type,
                          odst_td.id_advanced_input,
                          (SELECT ord_aisi.rank
                             FROM advanced_input_soft_inst ord_aisi
                            WHERE ord_aisi.id_institution IN (g_all_institution, i_prof.institution)
                              AND ord_aisi.id_software IN (g_all_software, i_prof.software)
                              AND ord_aisi.flg_active = g_yes
                              AND ord_aisi.id_advanced_input = nvl(odst_td.id_advanced_input, -1)
                              AND ord_aisi.id_advanced_input_field = nvl(odst_td.id_advanced_input_field, -1)),
                          (SELECT ord_aifd.rank
                             FROM advanced_input_field_det ord_aifd
                            WHERE ord_aifd.id_advanced_input_field_det = nvl(odst_td.id_advanced_input_field_det, -1));
        
        END IF;
    
        RETURN c_order_set_tasks_details;
    
    END get_odst_tasks_det_data;

    FUNCTION get_odst_proc_tasks_det_data
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_episode                 IN episode.id_episode%TYPE,
        i_id_order_set_proc_tasks IN table_number,
        i_flg_detail_type         IN table_varchar
    ) RETURN pk_types.cursor_type IS
        l_count_odst_proc_tasks CONSTANT PLS_INTEGER := i_id_order_set_proc_tasks.count;
    
        c_odst_proc_tasks_details pk_types.cursor_type;
    BEGIN
    
        -- optimizes query if only one task ID is given
        IF l_count_odst_proc_tasks > 1
        THEN
            -- get order set process tasks details data 
            OPEN c_odst_proc_tasks_details FOR
                SELECT /*+opt_estimate(table os_prc_tsk rows=1)*/
                DISTINCT nvl2(common_odst_prc_td.flg_detail_type, odst_prc_td.flg_value_type, NULL) flg_value_type,
                         nvl2(common_odst_prc_td.flg_detail_type, odst_prc_td.nvalue, NULL) nvalue,
                         nvl2(common_odst_prc_td.flg_detail_type,
                              pk_date_utils.date_send_tsz(i_lang, odst_prc_td.dvalue, i_prof),
                              NULL) dvalue,
                         nvl2(common_odst_prc_td.flg_detail_type, odst_prc_td.vvalue, NULL) vvalue,
                         odst_prc_td.flg_detail_type,
                         odst_prc_td.id_advanced_input,
                         odst_prc_td.id_advanced_input_field,
                         odst_prc_td.id_advanced_input_field_det,
                         nvl2(common_odst_prc_td.flg_detail_type, odst_prc_td.id_unit_measure, NULL) id_unit_measure,
                         -- indicates if this field has multiple values for all selected tasks or not
                         nvl2(common_odst_prc_td.flg_detail_type, g_no, g_yes) flg_multi_values,
                         nvl2(common_odst_prc_td.flg_detail_type,
                              get_task_detail_description(i_lang,
                                                          i_prof,
                                                          i_episode,
                                                          get_odst_proc_task_type(i_lang, i_prof, os_prc_tsk.column_value),
                                                          odst_prc_td.flg_detail_type,
                                                          odst_prc_td.nvalue,
                                                          odst_prc_td.dvalue,
                                                          odst_prc_td.vvalue),
                              NULL) task_detail_desc
                  FROM ((order_set_process_task_det odst_prc_td JOIN TABLE(i_id_order_set_proc_tasks) os_prc_tsk ON
                        odst_prc_td.id_order_set_process_task = os_prc_tsk.column_value) LEFT OUTER JOIN
                       -- verify which advanced input fields have the same value for all selected tasks
                        (SELECT /*+opt_estimate(table odst_prc_tsk rows=1)*/
                          odst_prc_tsk_det.flg_detail_type,
                          odst_prc_tsk_det.id_advanced_input,
                          odst_prc_tsk_det.id_advanced_input_field,
                          odst_prc_tsk_det.id_advanced_input_field_det
                           FROM order_set_process_task_det odst_prc_tsk_det,
                                TABLE(i_id_order_set_proc_tasks) odst_prc_tsk
                          WHERE odst_prc_tsk_det.id_order_set_process_task = odst_prc_tsk.column_value
                          GROUP BY odst_prc_tsk_det.flg_detail_type,
                                   odst_prc_tsk_det.id_advanced_input,
                                   odst_prc_tsk_det.id_advanced_input_field,
                                   odst_prc_tsk_det.id_advanced_input_field_det
                         HAVING COUNT(DISTINCT(nvl(to_char(odst_prc_tsk_det.flg_value_type), -1))) = 1 AND COUNT(DISTINCT(nvl(to_char(odst_prc_tsk_det.nvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_prc_tsk_det.dvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_prc_tsk_det.vvalue), -1))) <= 1 AND COUNT(DISTINCT(nvl(to_char(odst_prc_tsk_det.id_unit_measure), -1))) <= 1 AND COUNT(odst_prc_tsk_det.id_order_set_process_task_det) = l_count_odst_proc_tasks)
                        common_odst_prc_td ON
                        odst_prc_td.flg_detail_type = common_odst_prc_td.flg_detail_type AND
                        nvl(odst_prc_td.id_advanced_input, -1) = nvl(common_odst_prc_td.id_advanced_input, -1) AND
                        nvl(odst_prc_td.id_advanced_input_field, -1) =
                        nvl(common_odst_prc_td.id_advanced_input_field, -1) AND
                        nvl(odst_prc_td.id_advanced_input_field_det, -1) =
                        nvl(common_odst_prc_td.id_advanced_input_field_det, -1))
                 WHERE (i_flg_detail_type IS NULL OR
                       (i_flg_detail_type IS NOT NULL AND
                       odst_prc_td.flg_detail_type IN
                       (SELECT /*+opt_estimate(table det_type rows=1)*/
                           det_type.column_value
                            FROM TABLE(i_flg_detail_type) det_type)))
                -- order by fields rank
                 ORDER BY odst_prc_td.flg_detail_type,
                          odst_prc_td.id_advanced_input,
                          (SELECT ord_aisi.rank
                             FROM advanced_input_soft_inst ord_aisi
                            WHERE ord_aisi.id_institution IN (g_all_institution, i_prof.institution)
                              AND ord_aisi.id_software IN (g_all_software, i_prof.software)
                              AND ord_aisi.flg_active = g_yes
                              AND ord_aisi.id_advanced_input = nvl(odst_prc_td.id_advanced_input, -1)
                              AND ord_aisi.id_advanced_input_field = nvl(odst_prc_td.id_advanced_input_field, -1)),
                          (SELECT ord_aifd.rank
                             FROM advanced_input_field_det ord_aifd
                            WHERE ord_aifd.id_advanced_input_field_det =
                                  nvl(odst_prc_td.id_advanced_input_field_det, -1));
        ELSE
            -- get order set process task details data 
            OPEN c_odst_proc_tasks_details FOR
                SELECT /*+opt_estimate(table os_prc_tsk rows=1)*/
                DISTINCT odst_prc_td.flg_value_type,
                         odst_prc_td.nvalue nvalue,
                         pk_date_utils.date_send_tsz(i_lang, odst_prc_td.dvalue, i_prof) dvalue,
                         odst_prc_td.vvalue vvalue,
                         odst_prc_td.flg_detail_type,
                         odst_prc_td.id_advanced_input,
                         odst_prc_td.id_advanced_input_field,
                         odst_prc_td.id_advanced_input_field_det,
                         odst_prc_td.id_unit_measure,
                         -- indicates if this field has multiple values for all selected tasks or not
                         g_no flg_multi_values,
                         get_task_detail_description(i_lang,
                                                     i_prof,
                                                     i_episode,
                                                     get_odst_proc_task_type(i_lang, i_prof, os_prc_tsk.column_value),
                                                     odst_prc_td.flg_detail_type,
                                                     odst_prc_td.nvalue,
                                                     odst_prc_td.dvalue,
                                                     odst_prc_td.vvalue) task_detail_desc
                  FROM order_set_process_task_det odst_prc_td
                  JOIN TABLE(i_id_order_set_proc_tasks) os_prc_tsk
                    ON odst_prc_td.id_order_set_process_task = os_prc_tsk.column_value
                 WHERE (i_flg_detail_type IS NULL OR
                       (i_flg_detail_type IS NOT NULL AND
                       odst_prc_td.flg_detail_type IN
                       (SELECT /*+opt_estimate(table det_type rows=1)*/
                           det_type.column_value
                            FROM TABLE(i_flg_detail_type) det_type)))
                -- order by fields rank
                 ORDER BY odst_prc_td.flg_detail_type,
                          odst_prc_td.id_advanced_input,
                          (SELECT ord_aisi.rank
                             FROM advanced_input_soft_inst ord_aisi
                            WHERE ord_aisi.id_institution IN (g_all_institution, i_prof.institution)
                              AND ord_aisi.id_software IN (g_all_software, i_prof.software)
                              AND ord_aisi.flg_active = g_yes
                              AND ord_aisi.id_advanced_input = nvl(odst_prc_td.id_advanced_input, -1)
                              AND ord_aisi.id_advanced_input_field = nvl(odst_prc_td.id_advanced_input_field, -1)),
                          (SELECT ord_aifd.rank
                             FROM advanced_input_field_det ord_aifd
                            WHERE ord_aifd.id_advanced_input_field_det =
                                  nvl(odst_prc_td.id_advanced_input_field_det, -1));
        END IF;
    
        RETURN c_odst_proc_tasks_details;
    
    END get_odst_proc_tasks_det_data;

    FUNCTION replace_dependencies_refs_rank
    (
        i_lang       IN language.id_language%TYPE,
        i_str        sys_message.desc_message%TYPE,
        i_tasks_rank table_number
    ) RETURN VARCHAR2 IS
    
        l_str                  sys_message.desc_message%TYPE := i_str;
        l_begin_ref_position   NUMBER;
        l_end_ref_position     NUMBER;
        l_dependency_reference order_set_task.id_order_set_task%TYPE;
        l_desc_reference       VARCHAR2(200 CHAR);
    BEGIN
    
        -- verify if the string is null        
        IF l_str IS NULL
        THEN
            RETURN NULL;
        END IF;
    
        -- loop for each replace dependency reference
        LOOP
            -- search for next dependency reference
            l_begin_ref_position := instr(l_str, '@');
        
            -- exit if no more references were found
            EXIT WHEN l_begin_ref_position = 0;
        
            -- get end position of the dependency reference
            l_end_ref_position := instr(l_str, ']', l_begin_ref_position);
        
            -- get dependency reference
            l_dependency_reference := to_number(substr(l_str,
                                                       l_begin_ref_position + 2,
                                                       l_end_ref_position - l_begin_ref_position - 2));
        
            -- get dependency reference rank/description
            l_desc_reference := (CASE l_dependency_reference
                                    WHEN to_number(g_depend_current_epis) THEN
                                     pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_current_epis, i_lang)
                                    WHEN to_number(g_depend_future_epis) THEN
                                     pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_future_epis, i_lang)
                                    ELSE
                                     to_char(get_task_rank(i_tasks_rank, l_dependency_reference))
                                END);
        
            -- replace dependency reference by its description
            l_str := REPLACE(l_str, '@[' || to_char(l_dependency_reference) || ']', l_desc_reference);
        END LOOP;
    
        RETURN l_str;
    
    END replace_dependencies_refs_rank;

    FUNCTION get_task_instructions_desc
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_tasks          IN table_number,
        i_flg_process_tasks IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        c_tasks_details pk_types.cursor_type;
    
        l_last_id_advanced_input_field order_set_task_detail.id_advanced_input_field%TYPE := -1;
        l_return_desc                  VARCHAR2(4000);
    
        TYPE r_tsk_det_data IS RECORD(
            flg_value_type              order_set_task_detail.flg_value_type%TYPE,
            nvalue                      order_set_task_detail.nvalue%TYPE,
            dvalue                      VARCHAR2(30),
            vvalue                      order_set_task_detail.vvalue%TYPE,
            flg_detail_type             order_set_task_detail.flg_detail_type%TYPE,
            id_advanced_input           order_set_task_detail.id_advanced_input%TYPE,
            id_advanced_input_field     order_set_task_detail.id_advanced_input_field%TYPE,
            id_advanced_input_field_det order_set_task_detail.id_advanced_input_field_det%TYPE,
            id_unit_measure             order_set_task_detail.id_unit_measure%TYPE,
            flg_multi_values            VARCHAR2(1 CHAR),
            task_detail_desc            VARCHAR2(1000 CHAR));
    
        rec r_tsk_det_data;
    
        l_field_type           advanced_input_field.type%TYPE;
        l_field_format_message sys_message.desc_message%TYPE;
        l_value_desc           sys_domain.desc_val%TYPE;
        l_id_task_type         order_set_task.id_task_type%TYPE;
        l_flg_modular_workflow task_type.flg_modular_workflow%TYPE;
        l_id_request           order_set_process_task.id_request%TYPE;
        l_epis_info_desc       VARCHAR2(1000 CHAR);
    
        l_error    t_error_out;
        l_aux_desc VARCHAR2(1000 CHAR);
    
        l_description_hidrics VARCHAR2(1000 CHAR);
        l_flg_status_hidrics  VARCHAR2(1000 CHAR);
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- for each "order set task/order set process task"
        FOR i IN 1 .. i_id_tasks.count
        LOOP
        
            g_error := 'GET TYPE OF THE TASKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            SELECT id_task_type, check_modular_task_type(id_task_type), id_request
              INTO l_id_task_type, l_flg_modular_workflow, l_id_request
              FROM (SELECT id_task_type, NULL id_request
                      FROM order_set_task
                     WHERE id_order_set_task = i_id_tasks(i)
                       AND i_flg_process_tasks = g_no
                    UNION ALL
                    SELECT id_task_type, id_request
                      FROM order_set_process_task
                     WHERE id_order_set_process_task = i_id_tasks(i)
                       AND i_flg_process_tasks = g_yes);
        
            -- if modular workflow is not supported           
            IF l_flg_modular_workflow = g_modular_workflow_no_support
            THEN
                g_error := 'GET TASK DETAILS DATA';
                -- get tasks details data
                -- verify if task IDs belong to an order set or an order set process, and call respective function
                IF (i_flg_process_tasks = g_no)
                THEN
                    -- order set tasks 
                    c_tasks_details := get_odst_tasks_det_data(i_lang,
                                                               i_prof,
                                                               i_id_tasks,
                                                               table_varchar(g_task_det_adv_input));
                ELSE
                    -- ORDER SET process tasks 
                    c_tasks_details := get_odst_proc_tasks_det_data(i_lang,
                                                                    i_prof,
                                                                    NULL, -- this parameter is not necessary to process task instructions
                                                                    i_id_tasks,
                                                                    table_varchar(g_task_det_adv_input));
                END IF;
            
                g_error := 'BUILD INSTRUCTIONS DESCRIPTION';
                -- loop for all details building the instructions description
                LOOP
                    FETCH c_tasks_details
                        INTO rec;
                
                    EXIT WHEN c_tasks_details%NOTFOUND;
                
                    -- discard "selected" field (this field is now considered in a separated grid column)
                    IF rec.flg_detail_type = g_task_det_adv_input
                       AND rec.id_advanced_input_field = g_adv_input_field_selected
                    THEN
                        CONTINUE;
                    END IF;
                
                    -- empty fields are not showed
                    IF (rec.nvalue IS NOT NULL OR rec.dvalue IS NOT NULL OR rec.vvalue IS NOT NULL OR
                       rec.flg_multi_values = g_yes)
                    THEN
                    
                        -- verify if data belongs to a new field
                        IF (l_last_id_advanced_input_field != rec.id_advanced_input_field)
                        THEN
                        
                            -- concatenate field description
                            l_return_desc := l_return_desc || g_separator ||
                                             REPLACE(pk_translation.get_translation(i_lang,
                                                                                    'ADVANCED_INPUT_FIELD.CODE_ADVANCED_INPUT_FIELD.' ||
                                                                                    rec.id_advanced_input_field),
                                                     '-') || ': ';
                        
                            -- set last advanced input field ID
                            l_last_id_advanced_input_field := rec.id_advanced_input_field;
                        ELSE
                            -- if data belongs to the previous field, concatenate separator
                            l_return_desc := l_return_desc || g_separator;
                        END IF;
                    
                        -- concatenate field data
                        -- if is a field that contains multiple values,
                        -- then show "multiple" message instead of the field's value
                        IF (rec.flg_multi_values = g_yes)
                        THEN
                            l_return_desc := l_return_desc || pk_message.get_message(i_lang, g_message_multiple_val);
                        ELSE
                        
                            -- get field type 
                            SELECT TYPE
                              INTO l_field_type
                              FROM advanced_input_field aif
                             WHERE aif.id_advanced_input_field = rec.id_advanced_input_field;
                        
                            -- if data is a multichoice value, concatenate its description instead of its value               
                            IF (l_field_type = pk_advanced_input.g_multichoice)
                            THEN
                            
                                -- get multichoice value description
                                SELECT pk_sysdomain.get_domain(aimf.code_sys_domain, aimf.multi_field_val, i_lang)
                                  INTO l_value_desc
                                  FROM advanced_input_multi_field aimf
                                 WHERE aimf.id_advanced_input_field = rec.id_advanced_input_field
                                   AND aimf.multi_field_val = rec.vvalue;
                            
                                l_return_desc := l_return_desc || l_value_desc;
                            ELSE
                                -- get field format message
                                BEGIN
                                    SELECT pk_message.get_message(i_lang, aifd.format_message)
                                      INTO l_field_format_message
                                      FROM advanced_input_field_det aifd
                                     WHERE aifd.id_advanced_input_field_det = rec.id_advanced_input_field_det;
                                EXCEPTION
                                    WHEN no_data_found THEN
                                        NULL;
                                END;
                            
                                l_return_desc := l_return_desc || coalesce(
                                                                           
                                                                           to_char(rec.nvalue, l_field_format_message),
                                                                           
                                                                           -- on specific case of the discharge instruction, follow-up appointment dates or diet prescriptions, it should be only shown a short date
                                                                           (CASE
                                                                               WHEN (rec.id_advanced_input_field IN (101, 103, 104, 136, 137))
                                                                               
                                                                                THEN
                                                                                pk_date_utils.date_chr_short_read_tsz(i_lang,
                                                                                                                      pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                    i_prof,
                                                                                                                                                    rec.dvalue,
                                                                                                                                                    NULL),
                                                                                                                      i_prof)
                                                                           
                                                                               ELSE
                                                                                pk_date_utils.dt_chr_date_hour_tsz(i_lang,
                                                                                                                   pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                 i_prof,
                                                                                                                                                 rec.dvalue,
                                                                                                                                                 NULL),
                                                                                                                   i_prof)
                                                                           END),
                                                                           
                                                                           -- on specific case of the monitoring interval, hours have to be forced to the right format
                                                                           (CASE
                                                                               WHEN (rec.id_advanced_input_field = 98 AND instr(rec.vvalue, ':') != 0)
                                                                               
                                                                                THEN
                                                                                substr(rec.vvalue, 1, instr(rec.vvalue, ':')) ||
                                                                                lpad(substr(rec.vvalue, instr(rec.vvalue, ':') + 1), 2, '0')
                                                                           
                                                                               ELSE
                                                                                to_char(rec.vvalue)
                                                                           END));
                            
                            END IF;
                        
                            -- concatenate field unit if it exists
                            IF (rec.id_unit_measure IS NOT NULL)
                            THEN
                                l_return_desc := l_return_desc || ' ' ||
                                                 pk_translation.get_translation(i_lang,
                                                                                'UNIT_MEASURE.CODE_UNIT_MEASURE.' ||
                                                                                rec.id_unit_measure);
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            
                --Obtain episode info
                IF l_id_task_type IN (pk_order_sets.g_odst_task_appoint_social,
                                      pk_order_sets.g_odst_task_appoint_nurse,
                                      pk_order_sets.g_odst_task_appoint_medical,
                                      pk_order_sets.g_odst_task_appoint_nutrition,
                                      pk_order_sets.g_odst_task_appoint_rehabilit)
                   AND i_flg_process_tasks = pk_alert_constant.g_yes
                   AND l_id_request IS NOT NULL
                THEN
                    BEGIN
                        SELECT pk_translation.get_translation(i_lang, cs.code_clinical_service) || '; ' ||
                               pk_translation.get_translation(i_lang, se.code_sch_event_abrv) || '; ' ||
                               nvl2(cr.id_prof_requested,
                                    pk_prof_utils.get_name_signature(i_lang, i_prof, cr.id_prof_requested),
                                    pk_events.get_fe_request_prof_str(i_lang,
                                                                      i_prof,
                                                                      cr.id_consult_req,
                                                                      pk_alert_constant.g_no))
                          INTO l_epis_info_desc
                          FROM consult_req cr
                          JOIN sch_event se
                            ON se.id_sch_event = cr.id_sch_event
                          JOIN dep_clin_serv dsc
                            ON dsc.id_dep_clin_serv = cr.id_dep_clin_serv
                          JOIN clinical_service cs
                            ON cs.id_clinical_service = dsc.id_clinical_service
                         WHERE cr.id_episode_to_exec = l_id_request;
                    EXCEPTION
                        WHEN OTHERS THEN
                            l_epis_info_desc := NULL;
                    END;
                
                    IF l_epis_info_desc IS NOT NULL
                    THEN
                        l_return_desc := l_return_desc || '; ' || l_epis_info_desc;
                    END IF;
                END IF;
            ELSE
            
                -- modular workflow is supported
                CASE
                -- get task intructions/directions for medication task type
                    WHEN l_id_task_type = g_odst_task_medication THEN
                    
                        l_return_desc := l_return_desc || g_separator ||
                                         pk_api_pfh_ordertools_in.get_medication_directions(i_lang         => i_lang,
                                                                                            i_prof         => i_prof,
                                                                                            i_id_presc     => CASE
                                                                                                               i_flg_process_tasks
                                                                                                                  WHEN
                                                                                                                   pk_alert_constant.g_yes THEN
                                                                                                                   get_odst_proc_task_link(i_id_tasks(i),
                                                                                                                                           get_odst_proc_task_link_type(i_id_tasks(i)))
                                                                                                                  ELSE
                                                                                                                   get_odst_task_link(i_id_tasks(i),
                                                                                                                                      get_odst_task_link_type(i_id_tasks(i)))
                                                                                                              END,
                                                                                            i_flg_complete => CASE
                                                                                                               i_flg_process_tasks
                                                                                                                  WHEN -- dates are necessary when we are working with processes
                                                                                                                   pk_alert_constant.g_yes THEN
                                                                                                                   pk_api_pfh_ordertools_in.g_med_complete_directions_yes
                                                                                                                  ELSE
                                                                                                                   pk_api_pfh_ordertools_in.g_med_complete_directions_no
                                                                                                              END);
                    
                -- get task intructions/directions for institutionalized diet task types
                    WHEN l_id_task_type = g_odst_task_instit_diet THEN
                    
                        IF NOT pk_diet.get_task_instructions(i_lang             => i_lang,
                                                             i_prof             => i_prof,
                                                             i_diet_prof_instit => CASE i_flg_process_tasks
                                                                                       WHEN pk_alert_constant.g_yes THEN
                                                                                        get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                       ELSE
                                                                                        get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                           i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                   END,
                                                             i_flg_process      => i_flg_process_tasks,
                                                             o_task_instr       => l_aux_desc,
                                                             o_error            => l_error)
                        THEN
                            g_error := 'error found while calling pk_diet.get_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                -- get task intructions/directions for lab test task types
                    WHEN l_id_task_type = g_odst_task_analysis THEN
                    
                        -- check if tasks was already requested or not
                        IF l_id_request IS NOT NULL
                        THEN
                        
                            IF NOT
                                pk_lab_tests_external_api_db.get_lab_test_task_instructions(i_lang              => i_lang,
                                                                                            i_prof              => i_prof,
                                                                                            i_task_request      => NULL,
                                                                                            i_task_request_det  => l_id_request,
                                                                                            i_flg_showdate      => CASE
                                                                                                                    i_flg_process_tasks
                                                                                                                       WHEN
                                                                                                                        pk_alert_constant.g_yes THEN
                                                                                                                        pk_alert_constant.g_yes
                                                                                                                       ELSE
                                                                                                                        pk_alert_constant.g_no
                                                                                                                   END,
                                                                                            o_task_instructions => l_aux_desc,
                                                                                            o_error             => l_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_instructions function';
                                RAISE l_exception;
                            END IF;
                        
                            -- task not requested yet
                        ELSE
                        
                            IF NOT
                                pk_lab_tests_external_api_db.get_lab_test_task_instructions(i_lang             => i_lang,
                                                                                            i_prof             => i_prof,
                                                                                            i_task_request     => CASE
                                                                                                                   i_flg_process_tasks
                                                                                                                      WHEN
                                                                                                                       pk_alert_constant.g_yes THEN
                                                                                                                       get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                                               i_id_flg_task_link_type     => g_task_link_predefined)
                                                                                                                      ELSE
                                                                                                                       get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                                          i_id_flg_task_link_type => g_task_link_predefined)
                                                                                                                  END,
                                                                                            i_task_request_det => NULL,
                                                                                            
                                                                                            i_flg_showdate      => CASE
                                                                                                                    i_flg_process_tasks
                                                                                                                       WHEN
                                                                                                                        pk_alert_constant.g_yes THEN
                                                                                                                        pk_alert_constant.g_yes
                                                                                                                       ELSE
                                                                                                                        pk_alert_constant.g_no
                                                                                                                   END,
                                                                                            o_task_instructions => l_aux_desc,
                                                                                            o_error             => l_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_instructions function';
                                RAISE l_exception;
                            END IF;
                        
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                -- get task intructions/directions for imaging or other exam task types
                    WHEN l_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    
                        -- check if tasks was already requested or not
                        IF l_id_request IS NOT NULL
                        THEN
                        
                            IF NOT
                                pk_exams_external_api_db.get_exam_task_instructions(i_lang              => i_lang,
                                                                                    i_prof              => i_prof,
                                                                                    i_task_request      => NULL,
                                                                                    i_task_request_det  => l_id_request,
                                                                                    i_flg_showdate      => CASE
                                                                                                            i_flg_process_tasks
                                                                                                               WHEN
                                                                                                                pk_alert_constant.g_yes THEN
                                                                                                                pk_alert_constant.g_yes
                                                                                                               ELSE
                                                                                                                pk_alert_constant.g_no
                                                                                                           END,
                                                                                    o_task_instructions => l_aux_desc,
                                                                                    o_error             => l_error)
                            THEN
                                g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_instructions function';
                                RAISE l_exception;
                            END IF;
                            -- task not requested yet
                        ELSE
                        
                            IF NOT
                                pk_exams_external_api_db.get_exam_task_instructions(i_lang              => i_lang,
                                                                                    i_prof              => i_prof,
                                                                                    i_task_request      => CASE
                                                                                                            i_flg_process_tasks
                                                                                                               WHEN
                                                                                                                pk_alert_constant.g_yes THEN
                                                                                                                get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                                        i_id_flg_task_link_type     => g_task_link_predefined)
                                                                                                               ELSE
                                                                                                                get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                                   i_id_flg_task_link_type => g_task_link_predefined)
                                                                                                           END,
                                                                                    i_task_request_det  => NULL,
                                                                                    i_flg_showdate      => CASE
                                                                                                            i_flg_process_tasks
                                                                                                               WHEN
                                                                                                                pk_alert_constant.g_yes THEN
                                                                                                                pk_alert_constant.g_yes
                                                                                                               ELSE
                                                                                                                pk_alert_constant.g_no
                                                                                                           END,
                                                                                    o_task_instructions => l_aux_desc,
                                                                                    o_error             => l_error)
                            THEN
                                g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_instructions function';
                                RAISE l_exception;
                            END IF;
                        
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                    WHEN l_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    
                        BEGIN
                            pk_inp_hidrics_pbl.get_therapeutic_status(i_lang         => i_lang,
                                                                      i_prof         => i_prof,
                                                                      i_id_request   => CASE i_flg_process_tasks
                                                                                            WHEN pk_alert_constant.g_yes THEN
                                                                                             get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                     i_id_flg_task_link_type     => g_task_link_predefined)
                                                                                            ELSE
                                                                                             get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                i_id_flg_task_link_type => g_task_link_predefined)
                                                                                        END,
                                                                      o_description  => l_description_hidrics,
                                                                      o_instructions => l_aux_desc,
                                                                      o_flg_status   => l_flg_status_hidrics);
                        
                        EXCEPTION
                            WHEN OTHERS THEN
                                g_error := 'error found while calling pk_inp_hidrics_pbl.get_therapeutic_status function';
                                RAISE l_exception;
                        END;
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                        -- get task intructions/directions for communication orders task types
                    WHEN l_id_task_type = g_odst_task_procedure THEN
                    
                        IF NOT
                            pk_procedures_external_api_db.get_procedure_task_instruction(i_lang              => i_lang,
                                                                                         i_prof              => i_prof,
                                                                                         i_task_request      => CASE
                                                                                                                 i_flg_process_tasks
                                                                                                                    WHEN
                                                                                                                     pk_alert_constant.g_yes THEN
                                                                                                                     get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                                             i_id_flg_task_link_type     => g_task_link_predefined)
                                                                                                                    ELSE
                                                                                                                     get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                                        i_id_flg_task_link_type => g_task_link_predefined)
                                                                                                                END,
                                                                                         i_task_request_det  => NULL,
                                                                                         i_flg_showdate      => CASE
                                                                                                                 i_flg_process_tasks
                                                                                                                    WHEN
                                                                                                                     pk_alert_constant.g_yes THEN
                                                                                                                     pk_alert_constant.g_yes
                                                                                                                    ELSE
                                                                                                                     pk_alert_constant.g_no
                                                                                                                END,
                                                                                         o_task_instructions => l_aux_desc,
                                                                                         o_error             => l_error)
                        THEN
                            g_error := 'error found while calling pk_procedures_external_api_db.get_procedure_task_instruction function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    WHEN l_id_task_type = g_odst_task_bp THEN
                    
                        IF NOT
                            pk_bp_external_api_db.get_bp_task_instructions(i_lang              => i_lang,
                                                                           i_prof              => i_prof,
                                                                           i_task_request      => CASE i_flg_process_tasks
                                                                                                      WHEN
                                                                                                       pk_alert_constant.g_yes THEN
                                                                                                       get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                               i_id_flg_task_link_type     => g_task_link_predefined)
                                                                                                      ELSE
                                                                                                       get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                          i_id_flg_task_link_type => g_task_link_predefined)
                                                                                                  END,
                                                                           i_task_request_det  => NULL,
                                                                           i_flg_showdate      => CASE i_flg_process_tasks
                                                                                                      WHEN
                                                                                                       pk_alert_constant.g_yes THEN
                                                                                                       pk_alert_constant.g_yes
                                                                                                      ELSE
                                                                                                       pk_alert_constant.g_no
                                                                                                  END,
                                                                           o_task_instructions => l_aux_desc,
                                                                           o_error             => l_error)
                        THEN
                            g_error := 'error found while calling pk_bp_external_api_db.get_bp_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                    WHEN l_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                    
                        IF NOT pk_comm_orders_order_sets.get_task_instructions(i_lang                => i_lang,
                                                                               i_prof                => i_prof,
                                                                               i_task_request        => CASE
                                                                                                         i_flg_process_tasks
                                                                                                            WHEN
                                                                                                             pk_alert_constant.g_yes THEN
                                                                                                             get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                                     i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                                            ELSE
                                                                                                             get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                                i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                                        END,
                                                                               i_flg_show_start_date => i_flg_process_tasks,
                                                                               o_task_instr          => l_aux_desc,
                                                                               o_error               => l_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.get_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                -- get task intructions/directions for supplies or surgical supplies task types
                    WHEN l_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                    
                        IF NOT pk_supplies_order_sets.get_task_instructions(i_lang         => i_lang,
                                                                            i_prof         => i_prof,
                                                                            i_task_request => CASE i_flg_process_tasks
                                                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                                                   get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                           i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                                  ELSE
                                                                                                   get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                      i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                              END,
                                                                            o_task_instr   => l_aux_desc,
                                                                            o_error        => l_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.get_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                    WHEN l_id_task_type = g_odst_task_inpatient THEN
                    
                        IF NOT pk_admission_request.get_task_instructions(i_lang         => i_lang,
                                                                          i_prof         => i_prof,
                                                                          i_task_request => CASE i_flg_process_tasks
                                                                                                WHEN pk_alert_constant.g_yes THEN
                                                                                                 get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                         i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                                ELSE
                                                                                                 get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                    i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                            END,
                                                                          o_task_instr   => l_aux_desc,
                                                                          o_error        => l_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.get_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                    WHEN l_id_task_type = g_odst_task_inp_surg THEN
                        IF NOT pk_admission_request.get_task_instructions(i_lang         => i_lang,
                                                                          i_prof         => i_prof,
                                                                          i_task_request => CASE i_flg_process_tasks
                                                                                                WHEN pk_alert_constant.g_yes THEN
                                                                                                 get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                         i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                                ELSE
                                                                                                 get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                    i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                            END,
                                                                          o_task_instr   => l_aux_desc,
                                                                          o_error        => l_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.get_task_instructions function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    WHEN l_id_task_type = g_odst_task_consult THEN
                        IF NOT pk_opinion.get_consult_instruction(i_lang              => i_lang,
                                                                  i_prof              => i_prof,
                                                                  i_opinion           => CASE i_flg_process_tasks
                                                                                             WHEN pk_alert_constant.g_yes THEN
                                                                                              get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                      i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                             ELSE
                                                                                              get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                 i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                         END,
                                                                  o_task_instructions => l_aux_desc,
                                                                  o_error             => l_error)
                        THEN
                            g_error := 'error found while calling pk_opinion.get_consult_instruction function';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    
                    WHEN l_id_task_type = g_odst_task_patient_education THEN
                        IF NOT
                            pk_patient_education_api_db.get_pat_education_instructions(i_lang              => i_lang,
                                                                                       i_prof              => i_prof,
                                                                                       i_nurse_tea_req     => CASE
                                                                                                               i_flg_process_tasks
                                                                                                                  WHEN
                                                                                                                   pk_alert_constant.g_yes THEN
                                                                                                                   get_odst_proc_task_link(i_id_order_set_process_task => i_id_tasks(i),
                                                                                                                                           i_id_flg_task_link_type     => get_odst_proc_task_link_type(i_id_order_set_process_task => i_id_tasks(i)))
                                                                                                                  ELSE
                                                                                                                   get_odst_task_link(i_id_order_set_task     => i_id_tasks(i),
                                                                                                                                      i_id_flg_task_link_type => get_odst_task_link_type(i_id_order_set_task => i_id_tasks(i)))
                                                                                                              END,
                                                                                       o_task_instructions => l_aux_desc,
                                                                                       o_error             => l_error)
                        THEN
                            g_error := 'error found while calling pk_patient_education_api_db.get_pat_education_instructions';
                            RAISE l_exception;
                        END IF;
                    
                        l_return_desc := l_return_desc || g_separator || l_aux_desc;
                    ELSE
                        g_error := 'modular1 workflow is not supported for task type [' || l_id_task_type || ']';
                        RAISE l_exception;
                END CASE;
            END IF;
        END LOOP;
    
        -- replace first separators characters
        RETURN substr(l_return_desc, length(g_separator) + 1);
    END get_task_instructions_desc;

    FUNCTION get_task_desc
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_task                 IN order_set_task.id_order_set_task%TYPE,
        i_id_task_type            IN order_set_task.id_task_type%TYPE,
        i_flg_process_task        IN VARCHAR2,
        i_flg_bold_task_title     IN VARCHAR2,
        i_flg_task_desc_format    IN VARCHAR2,
        i_flg_show_mandatory_sign IN VARCHAR2,
        i_flg_show_task_notes     IN VARCHAR2 DEFAULT 'N'
    ) RETURN VARCHAR2 IS
        l_format_bold_string VARCHAR2(10 CHAR) := (CASE i_flg_bold_task_title
                                                      WHEN pk_alert_constant.g_yes THEN
                                                       '<b>@</b>'
                                                      ELSE
                                                       '@'
                                                  END);
    
        CURSOR c_get_descriptions IS
        -- Appointment episodes
            SELECT REPLACE(l_format_bold_string, '@', upper(substr(task_desc, 1, 1)) || substr(task_desc, 2)) ||
                   -- append appointment specialty description
                    nvl2(id_appoint_type,
                         decode(i_flg_task_desc_format,
                                g_task_desc_detail_format,
                                ' (' ||
                                -- get appointment specialty description
                                 get_task_detail_description(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             i_id_task_type,
                                                             g_tsk_det_type_appoint_type,
                                                             id_appoint_type,
                                                             NULL,
                                                             NULL) || ')',
                                
                                chr(10) ||
                                -- get appointment specialty description
                                 get_task_detail_description(i_lang,
                                                             i_prof,
                                                             NULL,
                                                             i_id_task_type,
                                                             g_tsk_det_type_appoint_type,
                                                             id_appoint_type,
                                                             NULL,
                                                             NULL)),
                         NULL) task_desc
              FROM (SELECT pk_translation.get_translation(i_lang,
                                                          'TASK_TYPE.CODE_TASK_TYPE.' || g_odst_task_group_appoints) ||
                           ' - ' ||
                           pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || i_id_task_type) task_desc,
                           -- get appointment specialty ID
                           -- show specialty of the appoinment only for extended and detail formats
                           decode(i_flg_task_desc_format,
                                  g_task_desc_short_format,
                                  NULL,
                                  (CASE i_flg_process_task
                                      WHEN pk_alert_constant.g_yes THEN
                                       get_odst_proc_task_det_val(i_lang,
                                                                  i_prof,
                                                                  i_id_task,
                                                                  g_tsk_det_type_appoint_type,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL)
                                      ELSE
                                       get_odst_task_det_val(i_lang,
                                                             i_prof,
                                                             i_id_task,
                                                             g_tsk_det_type_appoint_type,
                                                             NULL,
                                                             NULL,
                                                             NULL)
                                  END)) id_appoint_type
                      FROM dual
                     WHERE i_id_task_type IN (g_odst_task_appoint_social,
                                              g_odst_task_appoint_nurse,
                                              g_odst_task_appoint_medical,
                                              g_odst_task_appoint_nutrition,
                                              g_odst_task_appoint_psychology,
                                              g_odst_task_appoint_rehabilit))
            
            UNION ALL
            
            -- Follow-up appointment, Discharge instructions, Inpatient episodes and Patient education
            SELECT REPLACE(l_format_bold_string, '@', upper(substr(task_type_desc, 1, 1)) || substr(task_type_desc, 2)) ||
                   -- append nurse teaching notes to Patient education tasks
                    nvl2(tsk_notes,
                         decode(i_flg_task_desc_format,
                                g_task_desc_short_format,
                                NULL,
                                g_task_desc_detail_format,
                                ' (' || tsk_notes || ')',
                                -- g_task_desc_extended_format (default)
                                chr(10) || tsk_notes),
                         NULL) task_desc
              FROM (SELECT
                     -- get task type description
                      pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || i_id_task_type) task_type_desc,
                      -- get nurse teaching notes for Patient education tasks
                      decode(i_id_task_type,
                             g_odst_task_patient_education,
                             decode(i_flg_process_task,
                                    pk_alert_constant.g_yes,
                                    get_odst_proc_task_det_val(i_lang, i_prof, i_id_task, 'N', NULL, NULL, NULL),
                                    get_odst_task_det_val(i_lang, i_prof, i_id_task, 'N', NULL, NULL, NULL)),
                             NULL) tsk_notes
                       FROM dual
                      WHERE i_id_task_type IN (g_odst_task_followup_appoint,
                                               g_odst_task_discharge_instruct,
                                               g_odst_task_inpatient,
                                               g_odst_task_inp_surg,
                                               g_odst_task_inpatient_ptbr,
                                               g_odst_task_inp_surg_ptbr)
                         OR
                           -- show patient education notes as task descriptions if they don't have task link
                           (i_id_task_type = g_odst_task_patient_education AND
                           i_flg_process_task = pk_alert_constant.g_yes AND
                           get_odst_proc_task_link(i_id_task, g_task_link_null) IS NULL)
                        OR (i_id_task_type = g_odst_task_patient_education AND
                           i_flg_process_task = pk_alert_constant.g_no AND
                           get_odst_task_link(i_id_task, g_task_link_null) IS NULL))
            UNION ALL
            SELECT REPLACE(l_format_bold_string,
                           '@',
                           decode(i_id_task_type,
                                  -- prescription of predefined diet
                                  g_odst_task_predef_diet,
                                  (SELECT dpi.desc_diet
                                     FROM diet_prof_instit dpi
                                    WHERE dpi.id_diet_prof_instit = to_number(tsk_link.id_task_link)),
                                  -- Patient education
                                  g_odst_task_patient_education,
                                  pk_patient_education_api_db.get_nurse_teach_topic_title(i_lang,
                                                                                          i_prof,
                                                                                          to_number(tsk_link.id_task_link)),
                                  -- Procedure
                                  g_odst_task_procedure,
                                  pk_procedures_api_db.get_alias_translation(i_lang,
                                                                              i_prof,
                                                                              pk_task_type.get_task_type_code_translation(i_lang,
                                                                                                                          i_id_task_type) ||
                                                                              tsk_link.id_task_link,
                                                                              NULL) ||
                                  -- procedure codification
                                   (SELECT ' (' || pk_translation.get_translation(i_lang, c.code_codification) || ')'
                                      FROM interv_codification ec, codification c
                                     WHERE tsk_link.id_task_link_codif IS NOT NULL
                                       AND ec.id_interv_codification = to_number(tsk_link.id_task_link_codif)
                                       AND ec.id_codification = c.id_codification),
                                  pk_translation.get_translation(i_lang,
                                                                 decode(i_id_task_type,
                                                                        -- Specialty appointment
                                                                        g_odst_task_specialty_appoint,
                                                                        (SELECT cs.code_clinical_service
                                                                           FROM dep_clin_serv dcs, clinical_service cs
                                                                          WHERE cs.id_clinical_service =
                                                                                dcs.id_clinical_service
                                                                            AND dcs.id_dep_clin_serv =
                                                                                to_number(tsk_link.id_task_link)),
                                                                        -- Consult/Opinion
                                                                        g_odst_task_consult,
                                                                        decode(tsk_link.flg_task_link_type,
                                                                               g_task_link_clin_serv,
                                                                               (SELECT cli.code_clinical_service
                                                                                  FROM clinical_service cli
                                                                                 WHERE cli.id_clinical_service =
                                                                                       to_number(tsk_link.id_task_link)),
                                                                               (SELECT spec.code_speciality
                                                                                  FROM speciality spec
                                                                                 WHERE spec.id_speciality =
                                                                                       to_number(tsk_link.id_task_link))),
                                                                        -- Other tasks
                                                                        pk_task_type.get_task_type_code_translation(i_lang,
                                                                                                                    i_id_task_type) ||
                                                                        tsk_link.id_task_link)))) task_desc
              FROM (SELECT tl.id_task_link       id_task_link,
                           tl.flg_task_link_type flg_task_link_type,
                           tlg.id_task_link      id_task_link_group,
                           tlc.id_task_link      id_task_link_codif
                      FROM (SELECT odst_tl.id_task_link, odst_tl.id_order_set_task, odst_tl.flg_task_link_type
                              FROM order_set_task_link odst_tl
                             WHERE odst_tl.flg_task_link_type IN
                                   (g_task_link_null, g_task_link_analysis, g_task_link_exam, g_task_link_clin_serv)
                               AND odst_tl.id_order_set_task = i_id_task) tl
                      FULL OUTER JOIN (SELECT odst_tlg.id_task_link, odst_tlg.id_order_set_task
                                        FROM order_set_task_link odst_tlg
                                       WHERE odst_tlg.flg_task_link_type = g_task_link_group
                                         AND odst_tlg.id_order_set_task = i_id_task) tlg
                        ON (tl.id_order_set_task = tlg.id_order_set_task)
                      LEFT OUTER JOIN (SELECT odst_tlc.id_task_link, odst_tlc.id_order_set_task
                                        FROM order_set_task_link odst_tlc
                                       WHERE odst_tlc.flg_task_link_type = g_task_link_codification
                                         AND odst_tlc.id_order_set_task = i_id_task) tlc
                        ON (tl.id_order_set_task = tlc.id_order_set_task)
                     WHERE i_flg_process_task = g_no
                    UNION ALL
                    SELECT tl.id_task_link       id_task_link,
                           tl.flg_task_link_type flg_task_link_type,
                           tlg.id_task_link      id_task_link_group,
                           tlc.id_task_link      id_task_link_codif
                      FROM (SELECT odst_prc_tl.id_task_link,
                                   odst_prc_tl.id_order_set_process_task,
                                   odst_prc_tl.flg_task_link_type
                              FROM order_set_process_task_link odst_prc_tl
                             WHERE odst_prc_tl.flg_task_link_type IN
                                   (g_task_link_null, g_task_link_analysis, g_task_link_exam, g_task_link_clin_serv)
                               AND odst_prc_tl.id_order_set_process_task = i_id_task) tl
                      FULL OUTER JOIN (SELECT odst_prc_tlg.id_task_link, odst_prc_tlg.id_order_set_process_task
                                        FROM order_set_process_task_link odst_prc_tlg
                                       WHERE odst_prc_tlg.flg_task_link_type = g_task_link_group
                                         AND odst_prc_tlg.id_order_set_process_task = i_id_task) tlg
                        ON (tl.id_order_set_process_task = tlg.id_order_set_process_task)
                      LEFT OUTER JOIN (SELECT odst_prc_tlc.id_task_link, odst_prc_tlc.id_order_set_process_task
                                        FROM order_set_process_task_link odst_prc_tlc
                                       WHERE odst_prc_tlc.flg_task_link_type = g_task_link_codification
                                         AND odst_prc_tlc.id_order_set_process_task = i_id_task) tlc
                        ON (tl.id_order_set_process_task = tlc.id_order_set_process_task)
                     WHERE i_flg_process_task = g_yes) tsk_link
             WHERE i_id_task_type IN (g_odst_task_specialty_appoint,
                                      g_odst_task_image_exam,
                                      g_odst_task_other_exam,
                                      g_odst_task_monitoring,
                                      g_odst_task_procedure,
                                      g_odst_task_analysis,
                                      g_odst_task_consult,
                                      g_odst_task_predef_diet,
                                      g_odst_task_patient_education);
    
        l_id_request       order_set_process_task.id_request%TYPE;
        l_return_desc      table_varchar;
        l_task_description VARCHAR2(1000 CHAR);
    
        l_exception EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        -- get task request id 
        SELECT id_request
          INTO l_id_request
          FROM (SELECT id_task_type, NULL id_request
                  FROM order_set_task
                 WHERE id_order_set_task = i_id_task
                   AND i_flg_process_task = g_no
                UNION ALL
                SELECT id_task_type, id_request
                  FROM order_set_process_task
                 WHERE id_order_set_process_task = i_id_task
                   AND i_flg_process_task = g_yes);
    
        -- get task description (new task types should be implemented in the case statement)
        CASE
        -- medication task type
            WHEN i_id_task_type = g_odst_task_medication THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                RETURN REPLACE(l_format_bold_string,
                               '@',
                               pk_api_pfh_ordertools_in.get_medication_description(i_lang     => i_lang,
                                                                                   i_prof     => i_prof,
                                                                                   i_id_presc => l_id_request));
            
        -- institutionalized task type
            WHEN i_id_task_type = g_odst_task_instit_diet THEN
                IF NOT pk_diet.get_diet_description(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_diet_type   => pk_diet.g_diet_type_inst, -- institutionalized diet task type doesn't need id_task
                                                    i_diet_name   => NULL,
                                                    i_flg_default => pk_alert_constant.g_no,
                                                    o_diet_descr  => l_task_description,
                                                    o_error       => l_error)
                THEN
                    g_error := 'error found while calling pk_diet.get_diet_description function';
                    RAISE l_exception;
                END IF;
                RETURN REPLACE(l_format_bold_string, '@', l_task_description) ||(CASE i_flg_show_mandatory_sign WHEN
                                                                                 pk_alert_constant.g_yes THEN ' *' END);
            
        -- lab test task type
            WHEN i_id_task_type = g_odst_task_analysis THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                   AND l_id_request IS NOT NULL
                THEN
                
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_task_title(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_task_request     => NULL,
                                                                                i_task_request_det => l_id_request,
                                                                                o_task_desc        => l_task_description,
                                                                                o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF (i_flg_process_task = pk_alert_constant.g_yes)
                    THEN
                    
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_task_title(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_task_request     => l_id_request,
                                                                                i_task_request_det => NULL,
                                                                                o_task_desc        => l_task_description,
                                                                                o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_title function';
                        RAISE l_exception;
                    END IF;
                
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description) ||(CASE i_flg_show_mandatory_sign WHEN
                                                                                 pk_alert_constant.g_yes THEN ' *' END);
            
        -- image and other exam task type
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                   AND l_id_request IS NOT NULL
                THEN
                
                    IF NOT pk_exams_external_api_db.get_exam_task_title(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_task_request     => NULL,
                                                                        i_task_request_det => l_id_request,
                                                                        o_task_desc        => l_task_description,
                                                                        o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF (i_flg_process_task = pk_alert_constant.g_yes)
                    THEN
                    
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_exams_external_api_db.get_exam_task_title(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_task_request     => l_id_request,
                                                                        i_task_request_det => NULL,
                                                                        o_task_desc        => l_task_description,
                                                                        o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_title function';
                        RAISE l_exception;
                    END IF;
                
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description) ||(CASE i_flg_show_mandatory_sign WHEN
                                                                                 pk_alert_constant.g_yes THEN ' *' END);
                -- procedures
            WHEN i_id_task_type = g_odst_task_procedure THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                   AND l_id_request IS NOT NULL
                THEN
                
                    IF NOT pk_procedures_external_api_db.get_procedure_task_title(i_lang             => i_lang,
                                                                                  i_prof             => i_prof,
                                                                                  i_task_request     => NULL,
                                                                                  i_task_request_det => l_id_request,
                                                                                  o_task_desc        => l_task_description,
                                                                                  o_error            => l_error)
                    THEN
                        g_error := 'error found while calling  pk_procedures_external_api_db.get_procedure_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF (i_flg_process_task = pk_alert_constant.g_yes)
                    THEN
                    
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_procedures_external_api_db.get_procedure_task_title(i_lang             => i_lang,
                                                                                  i_prof             => i_prof,
                                                                                  i_task_request     => l_id_request,
                                                                                  i_task_request_det => NULL,
                                                                                  o_task_desc        => l_task_description,
                                                                                  o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_procedures_external_api_db.get_procedure_task_title function';
                        RAISE l_exception;
                    END IF;
                
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description) ||(CASE i_flg_show_mandatory_sign WHEN
                                                                                 pk_alert_constant.g_yes THEN ' *' END);
            
            WHEN i_id_task_type = g_odst_task_bp THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                   AND l_id_request IS NOT NULL
                THEN
                
                    IF NOT pk_bp_external_api_db.get_bp_task_title(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_task_request     => l_id_request,
                                                                   i_task_request_det => NULL,
                                                                   o_task_desc        => l_task_description,
                                                                   o_error            => l_error)
                    THEN
                        g_error := 'error found while calling  pk_bp_external_api_db.get_bp_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF (i_flg_process_task = pk_alert_constant.g_yes)
                    THEN
                    
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_bp_external_api_db.get_bp_task_title(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_task_request     => l_id_request,
                                                                   i_task_request_det => NULL,
                                                                   o_task_desc        => l_task_description,
                                                                   o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_bp_external_api_db.get_bp_task_title function';
                        RAISE l_exception;
                    END IF;
                
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description) ||(CASE i_flg_show_mandatory_sign WHEN
                                                                                 pk_alert_constant.g_yes THEN ' *' END);
            
        -- communication order task type
            WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                IF i_flg_show_task_notes = pk_alert_constant.g_no
                THEN
                    RETURN REPLACE(l_format_bold_string,
                                   '@',
                                   pk_comm_orders_order_sets.get_task_title(i_lang           => i_lang,
                                                                            i_prof           => i_prof,
                                                                            i_task_request   => l_id_request,
                                                                            i_flg_with_notes => i_flg_show_task_notes));
                ELSE
                    RETURN pk_comm_orders_order_sets.get_task_title(i_lang           => i_lang,
                                                                    i_prof           => i_prof,
                                                                    i_task_request   => l_id_request,
                                                                    i_flg_with_notes => i_flg_show_task_notes);
                END IF;
            
        -- supplies or surgical supplies task type
            WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                IF i_flg_show_task_notes = pk_alert_constant.g_no
                THEN
                    RETURN REPLACE(l_format_bold_string,
                                   '@',
                                   pk_supplies_order_sets.get_task_title(i_lang           => i_lang,
                                                                         i_prof           => i_prof,
                                                                         i_task_request   => l_id_request,
                                                                         i_flg_with_notes => i_flg_show_task_notes));
                
                ELSE
                    RETURN pk_supplies_order_sets.get_task_title(i_lang           => i_lang,
                                                                 i_prof           => i_prof,
                                                                 i_task_request   => l_id_request,
                                                                 i_flg_with_notes => i_flg_show_task_notes);
                END IF;
            
            WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                IF NOT pk_inp_hidrics_pbl.get_odst_task_title(i_lang             => i_lang,
                                                              i_prof             => i_prof,
                                                              i_task_request     => l_id_request,
                                                              i_task_request_det => NULL,
                                                              o_task_desc        => l_task_description,
                                                              o_error            => l_error)
                THEN
                    g_error := 'error found while calling pk_inp_hidrics_pbl.get_odst_task_title function';
                    RAISE l_exception;
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description);
            
            WHEN i_id_task_type = g_odst_task_inpatient THEN
            
                SELECT '<b>' || pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.34') || '</b>'
                  INTO l_task_description
                  FROM dual;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description);
            
            WHEN i_id_task_type = g_odst_task_inp_surg THEN
            
                SELECT '<b>' || pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.35') || '</b>'
                  INTO l_task_description
                  FROM dual;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description);
            
            WHEN i_id_task_type = g_odst_task_consult THEN
            
                IF NOT pk_opinion.get_consult_title(i_lang      => i_lang,
                                               i_prof      => i_prof,
                                               i_opinion   => CASE
                                                                  WHEN i_flg_process_task = pk_alert_constant.g_yes THEN
                                                                   get_odst_proc_task_link(i_id_task,
                                                                                           get_odst_proc_task_link_type(i_id_task))
                                                                  ELSE
                                                                   get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task))
                                                              END,
                                               o_task_desc => l_task_description,
                                               o_error     => l_error)
                THEN
                    g_error := 'error found while calling pk_opinion.get_consult_title function';
                    RAISE l_exception;
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description);
            
            WHEN i_id_task_type = g_odst_task_patient_education THEN
            
                IF NOT pk_patient_education_api_db.get_pat_education_title(i_lang          => i_lang,
                                                                      i_prof          => i_prof,
                                                                      i_nurse_tea_req => CASE
                                                                                             WHEN i_flg_process_task =
                                                                                                  pk_alert_constant.g_yes THEN
                                                                                              get_odst_proc_task_link(i_id_task,
                                                                                                                      get_odst_proc_task_link_type(i_id_task))
                                                                                             ELSE
                                                                                              get_odst_task_link(i_id_task,
                                                                                                                 get_odst_task_link_type(i_id_task))
                                                                                         END,
                                                                      o_task_desc     => l_task_description,
                                                                      o_error         => l_error)
                THEN
                    g_error := 'error found while calling pk_patient_education_api_db.get_pat_education_title';
                    RAISE l_exception;
                END IF;
            
                RETURN REPLACE(l_format_bold_string, '@', l_task_description);
            
            ELSE
                g_error := 'GET TASK DESCRIPTIONS';
                pk_alertlog.log_debug(g_error, g_package_name);
                -- get task descriptions
                OPEN c_get_descriptions;
                FETCH c_get_descriptions BULK COLLECT
                    INTO l_return_desc;
                CLOSE c_get_descriptions;
                -- concatenate all returned descriptions
                RETURN pk_utils.concat_table(l_return_desc, g_separator)
                -- append mandatory sign
                ||(CASE i_flg_show_mandatory_sign WHEN pk_alert_constant.g_yes THEN '*' END);
        END CASE;
    
    END get_task_desc;

    FUNCTION get_task_id
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_odst_proc_task IN order_set_process_task.id_order_set_process_task%TYPE,
        i_id_task_type      IN order_set_task.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
    
        l_task_id VARCHAR2(1000);
    
        l_exception EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        -- get task id
        CASE
        
        -- lab test task type
            WHEN i_id_task_type = g_odst_task_analysis THEN
            
                IF NOT pk_lab_tests_external_api_db.get_lab_test_id(i_lang             => i_lang,
                                                                    i_prof             => i_prof,
                                                                    i_task_request     => get_odst_proc_task_link(i_id_odst_proc_task,
                                                                                                                  g_task_link_predefined),
                                                                    i_task_request_det => NULL,
                                                                    o_lab_test_id      => l_task_id,
                                                                    o_error            => l_error)
                THEN
                    g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_id function';
                    RAISE l_exception;
                END IF;
            
                -- return task id            
                RETURN l_task_id;
            
        -- image and other exam task type
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
            
                IF NOT pk_exams_external_api_db.get_exam_id(i_lang             => i_lang,
                                                            i_prof             => i_prof,
                                                            i_task_request     => get_odst_proc_task_link(i_id_odst_proc_task,
                                                                                                          g_task_link_predefined),
                                                            i_task_request_det => NULL,
                                                            o_exam_id          => l_task_id,
                                                            o_error            => l_error)
                THEN
                    g_error := 'error found while calling pk_exams_external_api_db.get_exam_id function';
                    RAISE l_exception;
                END IF;
            
                -- return task id            
                RETURN l_task_id;
            
            ELSE
                -- return task id 
                RETURN get_odst_proc_task_link(i_id_odst_proc_task, get_odst_proc_task_link_type(i_id_odst_proc_task));
        END CASE;
    
    END get_task_id;

    FUNCTION get_task_desc_array
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_task                 IN order_set_task.id_order_set_task%TYPE,
        i_id_task_type            IN order_set_task.id_task_type%TYPE,
        i_flg_process_task        IN VARCHAR2,
        i_flg_bold_task_title     IN VARCHAR2,
        i_flg_task_desc_format    IN VARCHAR2,
        i_flg_show_mandatory_sign IN VARCHAR2
    ) RETURN t_tbl_odst_task IS
    
        l_format_bold_string VARCHAR2(10 CHAR) := (CASE i_flg_bold_task_title
                                                      WHEN pk_alert_constant.g_yes THEN
                                                       '<b>@</b>'
                                                      ELSE
                                                       '@'
                                                  END);
    
        CURSOR c_get_descriptions IS
        -- Appointment episodes
            SELECT t_rec_odst_task(i_id_task,
                                   i_id_task_type,
                                   id_appoint_type,
                                   REPLACE(l_format_bold_string,
                                            '@',
                                            upper(substr(task_desc, 1, 1)) || substr(task_desc, 2)) ||
                                   -- append appointment specialty description
                                    nvl2(id_appoint_type,
                                         decode(i_flg_task_desc_format,
                                                g_task_desc_detail_format,
                                                ' (' ||
                                                -- get appointment specialty description
                                                 get_task_detail_description(i_lang,
                                                                             i_prof,
                                                                             NULL,
                                                                             i_id_task_type,
                                                                             g_tsk_det_type_appoint_type,
                                                                             id_appoint_type,
                                                                             NULL,
                                                                             NULL) || ')',
                                                
                                                chr(10) ||
                                                -- get appointment specialty description
                                                 get_task_detail_description(i_lang,
                                                                             i_prof,
                                                                             NULL,
                                                                             i_id_task_type,
                                                                             g_tsk_det_type_appoint_type,
                                                                             id_appoint_type,
                                                                             NULL,
                                                                             NULL)),
                                         NULL)) task_desc
              FROM (SELECT pk_translation.get_translation(i_lang,
                                                          'TASK_TYPE.CODE_TASK_TYPE.' || g_odst_task_group_appoints) ||
                           ' - ' ||
                           pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || i_id_task_type) task_desc,
                           -- get appointment specialty ID
                           -- show specialty of the appoinment only for extended and detail formats
                           decode(i_flg_task_desc_format,
                                  g_task_desc_short_format,
                                  NULL,
                                  (CASE i_flg_process_task
                                      WHEN pk_alert_constant.g_yes THEN
                                       get_odst_proc_task_det_val(i_lang,
                                                                  i_prof,
                                                                  i_id_task,
                                                                  g_tsk_det_type_appoint_type,
                                                                  NULL,
                                                                  NULL,
                                                                  NULL)
                                      ELSE
                                       get_odst_task_det_val(i_lang,
                                                             i_prof,
                                                             i_id_task,
                                                             g_tsk_det_type_appoint_type,
                                                             NULL,
                                                             NULL,
                                                             NULL)
                                  END)) id_appoint_type
                      FROM dual
                     WHERE i_id_task_type IN (g_odst_task_appoint_social,
                                              g_odst_task_appoint_nurse,
                                              g_odst_task_appoint_medical,
                                              g_odst_task_appoint_nutrition,
                                              g_odst_task_appoint_psychology,
                                              g_odst_task_appoint_rehabilit))
            UNION ALL
            -- Follow-up appointment, Discharge instructions, Inpatient episodes and Patient education
            SELECT t_rec_odst_task(i_id_task,
                                   i_id_task_type,
                                   NULL,
                                   REPLACE(l_format_bold_string,
                                            '@',
                                            upper(substr(task_type_desc, 1, 1)) || substr(task_type_desc, 2)) ||
                                   -- append nurse teaching notes to Patient education tasks
                                    nvl2(tsk_notes,
                                         decode(i_flg_task_desc_format,
                                                g_task_desc_short_format,
                                                NULL,
                                                g_task_desc_detail_format,
                                                ' (' || tsk_notes || ')',
                                                -- g_task_desc_extended_format (default)
                                                chr(10) || tsk_notes),
                                         NULL)) task_desc
              FROM (SELECT
                     -- get task type description
                      pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || i_id_task_type) task_type_desc,
                      -- get nurse teaching notes for Patient education tasks
                      decode(i_id_task_type,
                             g_odst_task_patient_education,
                             decode(i_flg_process_task,
                                    pk_alert_constant.g_yes,
                                    get_odst_proc_task_det_val(i_lang, i_prof, i_id_task, 'N', NULL, NULL, NULL),
                                    get_odst_task_det_val(i_lang, i_prof, i_id_task, 'N', NULL, NULL, NULL)),
                             NULL) tsk_notes
                       FROM dual
                      WHERE i_id_task_type IN (g_odst_task_followup_appoint,
                                               g_odst_task_discharge_instruct,
                                               g_odst_task_inpatient,
                                               g_odst_task_inp_surg,
                                               g_odst_task_inpatient_ptbr,
                                               g_odst_task_inp_surg_ptbr)
                         OR
                           -- show patient education notes as task descriptions if they don't have task link
                           (i_id_task_type = g_odst_task_patient_education AND
                           i_flg_process_task = pk_alert_constant.g_yes AND
                           get_odst_proc_task_link(i_id_task, g_task_link_null) IS NULL)
                        OR (i_id_task_type = g_odst_task_patient_education AND
                           i_flg_process_task = pk_alert_constant.g_no AND
                           get_odst_task_link(i_id_task, g_task_link_null) IS NULL))
            UNION ALL
            SELECT t_rec_odst_task(i_id_task,
                                   i_id_task_type,
                                   tsk_link.id_task_link,
                                   REPLACE(l_format_bold_string,
                                           '@',
                                           decode(i_id_task_type,
                                                  -- prescription of predefined diet
                                                  g_odst_task_predef_diet,
                                                  (SELECT dpi.desc_diet
                                                     FROM diet_prof_instit dpi
                                                    WHERE dpi.id_diet_prof_instit = to_number(tsk_link.id_task_link)),
                                                  -- Patient education
                                                  g_odst_task_patient_education,
                                                  pk_patient_education_api_db.get_nurse_teach_topic_title(i_lang,
                                                                                                          i_prof,
                                                                                                          to_number(tsk_link.id_task_link)),
                                                  -- Procedure
                                                  g_odst_task_procedure,
                                                  pk_procedures_api_db.get_alias_translation(i_lang,
                                                                                              i_prof,
                                                                                              pk_task_type.get_task_type_code_translation(i_lang,
                                                                                                                                          i_id_task_type) ||
                                                                                              tsk_link.id_task_link,
                                                                                              NULL) ||
                                                  -- procedure codification
                                                   (SELECT ' (' ||
                                                           pk_translation.get_translation(i_lang, c.code_codification) || ')'
                                                      FROM interv_codification ec, codification c
                                                     WHERE tsk_link.id_task_link_codif IS NOT NULL
                                                       AND ec.id_interv_codification =
                                                           to_number(tsk_link.id_task_link_codif)
                                                       AND ec.id_codification = c.id_codification),
                                                  pk_translation.get_translation(i_lang,
                                                                                 decode(i_id_task_type,
                                                                                        -- Specialty appointment
                                                                                        g_odst_task_specialty_appoint,
                                                                                        (SELECT cs.code_clinical_service
                                                                                           FROM dep_clin_serv    dcs,
                                                                                                clinical_service cs
                                                                                          WHERE cs.id_clinical_service =
                                                                                                dcs.id_clinical_service
                                                                                            AND dcs.id_dep_clin_serv =
                                                                                                to_number(tsk_link.id_task_link)),
                                                                                        -- Consult/Opinion
                                                                                        g_odst_task_consult,
                                                                                        (SELECT spec.code_speciality
                                                                                           FROM speciality spec
                                                                                          WHERE spec.id_speciality =
                                                                                                to_number(tsk_link.id_task_link)),
                                                                                        -- Other tasks
                                                                                        pk_task_type.get_task_type_code_translation(i_lang,
                                                                                                                                    i_id_task_type) ||
                                                                                        tsk_link.id_task_link))))) task_desc
              FROM (SELECT tl.id_task_link  id_task_link,
                           tlg.id_task_link id_task_link_group,
                           tlc.id_task_link id_task_link_codif
                      FROM (SELECT odst_tl.id_task_link, odst_tl.id_order_set_task
                              FROM order_set_task_link odst_tl
                             WHERE odst_tl.flg_task_link_type IN
                                   (g_task_link_null, g_task_link_analysis, g_task_link_exam)
                               AND odst_tl.id_order_set_task = i_id_task) tl
                      FULL OUTER JOIN (SELECT odst_tlg.id_task_link, odst_tlg.id_order_set_task
                                        FROM order_set_task_link odst_tlg
                                       WHERE odst_tlg.flg_task_link_type = g_task_link_group
                                         AND odst_tlg.id_order_set_task = i_id_task) tlg
                        ON (tl.id_order_set_task = tlg.id_order_set_task)
                      LEFT OUTER JOIN (SELECT odst_tlc.id_task_link, odst_tlc.id_order_set_task
                                        FROM order_set_task_link odst_tlc
                                       WHERE odst_tlc.flg_task_link_type = g_task_link_codification
                                         AND odst_tlc.id_order_set_task = i_id_task) tlc
                        ON (tl.id_order_set_task = tlc.id_order_set_task)
                     WHERE i_flg_process_task = g_no
                    UNION ALL
                    SELECT tl.id_task_link  id_task_link,
                           tlg.id_task_link id_task_link_group,
                           tlc.id_task_link id_task_link_codif
                      FROM (SELECT odst_prc_tl.id_task_link, odst_prc_tl.id_order_set_process_task
                              FROM order_set_process_task_link odst_prc_tl
                             WHERE odst_prc_tl.flg_task_link_type IN
                                   (g_task_link_null, g_task_link_analysis, g_task_link_exam)
                               AND odst_prc_tl.id_order_set_process_task = i_id_task) tl
                      FULL OUTER JOIN (SELECT odst_prc_tlg.id_task_link, odst_prc_tlg.id_order_set_process_task
                                        FROM order_set_process_task_link odst_prc_tlg
                                       WHERE odst_prc_tlg.flg_task_link_type = g_task_link_group
                                         AND odst_prc_tlg.id_order_set_process_task = i_id_task) tlg
                        ON (tl.id_order_set_process_task = tlg.id_order_set_process_task)
                      LEFT OUTER JOIN (SELECT odst_prc_tlc.id_task_link, odst_prc_tlc.id_order_set_process_task
                                        FROM order_set_process_task_link odst_prc_tlc
                                       WHERE odst_prc_tlc.flg_task_link_type = g_task_link_codification
                                         AND odst_prc_tlc.id_order_set_process_task = i_id_task) tlc
                        ON (tl.id_order_set_process_task = tlc.id_order_set_process_task)
                     WHERE i_flg_process_task = g_yes) tsk_link
             WHERE i_id_task_type IN (g_odst_task_specialty_appoint,
                                      g_odst_task_image_exam,
                                      g_odst_task_other_exam,
                                      g_odst_task_monitoring,
                                      g_odst_task_procedure,
                                      g_odst_task_bp,
                                      g_odst_task_analysis,
                                      g_odst_task_consult,
                                      g_odst_task_predef_diet,
                                      g_odst_task_patient_education);
    
        l_id_request       order_set_process_task.id_request%TYPE;
        l_return_desc      t_tbl_odst_task;
        l_task_description VARCHAR2(1000 CHAR);
    
        l_exception EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        -- get task request id 
        SELECT id_request
          INTO l_id_request
          FROM (SELECT id_task_type, NULL id_request
                  FROM order_set_task
                 WHERE id_order_set_task = i_id_task
                   AND i_flg_process_task = g_no
                UNION ALL
                SELECT id_task_type, id_request
                  FROM order_set_process_task
                 WHERE id_order_set_process_task = i_id_task
                   AND i_flg_process_task = g_yes);
    
        -- get task description (new task types should be implemented in the case statement)
        CASE
        -- medication task type
            WHEN i_id_task_type = g_odst_task_medication THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string,
                                                               '@',
                                                               pk_api_pfh_ordertools_in.get_medication_description(i_lang     => i_lang,
                                                                                                                   i_prof     => i_prof,
                                                                                                                   i_id_presc => l_id_request))));
            
        -- institutionalized task type
            WHEN i_id_task_type = g_odst_task_instit_diet THEN
                IF NOT pk_diet.get_diet_description(i_lang        => i_lang,
                                                    i_prof        => i_prof,
                                                    i_diet_type   => pk_diet.g_diet_type_inst, -- institutionalized diet task type doesn't need id_task
                                                    i_diet_name   => NULL,
                                                    i_flg_default => pk_alert_constant.g_no,
                                                    o_diet_descr  => l_task_description,
                                                    o_error       => l_error)
                THEN
                    g_error := 'error found while calling pk_diet.get_diet_description function';
                    RAISE l_exception;
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       NULL,
                                                       REPLACE(l_format_bold_string, '@', l_task_description) ||
                                                       (CASE i_flg_show_mandatory_sign WHEN pk_alert_constant.g_yes THEN ' *' END)));
            
        -- lab test task type
            WHEN i_id_task_type = g_odst_task_analysis THEN
            
                IF l_id_request IS NOT NULL
                THEN
                
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_task_title(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_task_request     => NULL,
                                                                                i_task_request_det => l_id_request,
                                                                                o_task_desc        => l_task_description,
                                                                                o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF i_flg_process_task = pk_alert_constant.g_yes
                    THEN
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_task_title(i_lang             => i_lang,
                                                                                i_prof             => i_prof,
                                                                                i_task_request     => l_id_request,
                                                                                i_task_request_det => NULL,
                                                                                o_task_desc        => l_task_description,
                                                                                o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_task_title function';
                        RAISE l_exception;
                    END IF;
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string, '@', l_task_description) ||
                                                       (CASE i_flg_show_mandatory_sign WHEN pk_alert_constant.g_yes THEN ' *' END)));
            
        -- image and other exam task type
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
            
                IF l_id_request IS NOT NULL
                THEN
                    IF NOT pk_exams_external_api_db.get_exam_task_title(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_task_request     => NULL,
                                                                        i_task_request_det => l_id_request,
                                                                        o_task_desc        => l_task_description,
                                                                        o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_title function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                
                    IF (i_flg_process_task = pk_alert_constant.g_yes)
                    THEN
                        l_id_request := get_odst_proc_task_link(i_id_task, g_task_link_predefined);
                    ELSE
                        l_id_request := get_odst_task_link(i_id_task, g_task_link_predefined);
                    END IF;
                
                    IF NOT pk_exams_external_api_db.get_exam_task_title(i_lang             => i_lang,
                                                                        i_prof             => i_prof,
                                                                        i_task_request     => l_id_request,
                                                                        i_task_request_det => NULL,
                                                                        o_task_desc        => l_task_description,
                                                                        o_error            => l_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.get_exam_task_title function';
                        RAISE l_exception;
                    END IF;
                
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string, '@', l_task_description) ||
                                                       (CASE i_flg_show_mandatory_sign WHEN pk_alert_constant.g_yes THEN ' *' END)));
            
        -- communication order task type
            WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string,
                                                               '@',
                                                               pk_comm_orders_order_sets.get_task_title(i_lang         => i_lang,
                                                                                                        i_prof         => i_prof,
                                                                                                        i_task_request => l_id_request))));
            
        -- supplies or surgical supplies task type
            WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string,
                                                               '@',
                                                               pk_supplies_order_sets.get_task_title(i_lang         => i_lang,
                                                                                                     i_prof         => i_prof,
                                                                                                     i_task_request => l_id_request))));
            
            WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
            
                IF (i_flg_process_task = pk_alert_constant.g_yes)
                THEN
                    l_id_request := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                ELSE
                    l_id_request := get_odst_task_link(i_id_task, get_odst_task_link_type(i_id_task));
                END IF;
            
                IF NOT pk_inp_hidrics_pbl.get_odst_task_title(i_lang             => i_lang,
                                                              i_prof             => i_prof,
                                                              i_task_request     => l_id_request,
                                                              i_task_request_det => NULL,
                                                              o_task_desc        => l_task_description,
                                                              o_error            => l_error)
                THEN
                    g_error := 'error found while calling pk_inp_hidrics_pbl.get_odst_task_title function';
                    RAISE l_exception;
                END IF;
            
                RETURN t_tbl_odst_task(t_rec_odst_task(i_id_task,
                                                       i_id_task_type,
                                                       l_id_request,
                                                       REPLACE(l_format_bold_string, '@', l_task_description)));
            
            ELSE
                g_error := 'GET TASK DESCRIPTIONS';
                pk_alertlog.log_debug(g_error, g_package_name);
                -- get task descriptions
                OPEN c_get_descriptions;
                FETCH c_get_descriptions BULK COLLECT
                    INTO l_return_desc;
                CLOSE c_get_descriptions;
            
                -- return array of descriptions
                RETURN l_return_desc;
            
        END CASE;
    
    END get_task_desc_array;

    FUNCTION get_group_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_task      IN order_set_task.id_order_set_task%TYPE,
        i_id_task_type IN order_set_task.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
    
        -- get group descriptions
        CURSOR c_get_group_descriptions IS
            SELECT decode(i_id_task_type,
                          -- lab test
                          g_odst_task_analysis,
                          -- lab test group description
                          (SELECT pk_lab_tests_api_db.get_alias_translation(i_lang,
                                                                            i_prof,
                                                                            'G',
                                                                            ag.code_analysis_group,
                                                                            NULL)
                             FROM analysis_group ag
                            WHERE ag.id_analysis_group = to_number(tl.id_task_link)),
                          -- image exam
                          g_odst_task_image_exam,
                          -- image exam group description
                          (SELECT pk_translation.get_translation(i_lang, eg.code_exam_group)
                             FROM exam_group eg
                            WHERE eg.id_exam_group = to_number(tl.id_task_link)),
                          -- other exam
                          g_odst_task_other_exam,
                          -- other exam group description
                          (SELECT pk_translation.get_translation(i_lang, eg.code_exam_group)
                             FROM exam_group eg
                            WHERE eg.id_exam_group = to_number(tl.id_task_link))) task_group_desc
              FROM order_set_task_link tl
             WHERE tl.id_order_set_task = i_id_task
               AND tl.flg_task_link_type = g_task_link_group
               AND i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam, g_odst_task_analysis);
    
        l_group_description VARCHAR2(1000 CHAR);
    
    BEGIN
        -- get group description
        OPEN c_get_group_descriptions;
        FETCH c_get_group_descriptions
            INTO l_group_description;
        CLOSE c_get_group_descriptions;
    
        RETURN l_group_description;
    
    END get_group_desc;

    FUNCTION get_odst_proc_task_group_desc
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_desc VARCHAR2(1000 CHAR);
    
    BEGIN
    
        -- loop through all task groups of this order set process task
        FOR rec IN (SELECT pk_string_utils.clob_to_sqlvarchar2(pk_translation.get_translation_trs(tg.code_task_group)) task_group_desc
                      FROM order_set_process_task_group ostg, task_group tg
                     WHERE ostg.id_order_set_process_task = i_order_set_process_task
                       AND ostg.id_task_group = tg.id_task_group
                     ORDER BY tg.rank, task_group_desc)
        LOOP
            l_return_desc := l_return_desc || g_separator || rec.task_group_desc;
        END LOOP;
    
        -- check if the order set process task has any task group defined for it
        IF l_return_desc IS NOT NULL
        THEN
            -- remove first separator character
            RETURN substr(l_return_desc, length(g_separator) + 1);
        ELSE
        
            -- define that this order set process task is in the "Other tasks" group
            RETURN pk_message.get_message(i_lang, 'TASK_GROUP_M007');
        END IF;
    
    END get_odst_proc_task_group_desc;

    FUNCTION get_odst_proc_tsk_grp_tooltip
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_desc VARCHAR2(1000 CHAR);
    
    BEGIN
    
        -- loop through all task groups of this order set process task
        FOR rec IN (SELECT pk_string_utils.clob_to_sqlvarchar2(pk_translation.get_translation_trs(tg.code_task_group)) task_group_desc,
                           tg.notes
                      FROM order_set_process_task_group ostg, task_group tg
                     WHERE ostg.id_order_set_process_task = i_order_set_process_task
                       AND ostg.id_task_group = tg.id_task_group
                     ORDER BY tg.rank, task_group_desc)
        LOOP
            l_return_desc := l_return_desc || pk_string_utils.g_new_line || '<b>' || rec.task_group_desc || '</b>' ||
                             pk_string_utils.g_new_line || htf.escape_sc(rec.notes) || (CASE
                                 WHEN rec.notes IS NOT NULL THEN
                                  pk_string_utils.g_new_line
                             END);
        END LOOP;
    
        -- check if the order set process task has any task group defined for it
        IF l_return_desc IS NOT NULL
        THEN
            -- remove first separator character
            RETURN substr(l_return_desc, length(pk_string_utils.g_new_line) + 1);
        ELSE
        
            -- define that this order set process task is in the "Other tasks" group
            RETURN '<b>' || pk_message.get_message(i_lang, 'TASK_GROUP_M007') || '</b>';
        END IF;
    
    END get_odst_proc_tsk_grp_tooltip;

    FUNCTION get_odst_proc_task_group_rank
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN NUMBER IS
    
        l_rank NUMBER;
    
    BEGIN
    
        BEGIN
            SELECT MAX(tg.rank)
              INTO l_rank
              FROM order_set_process_task_group ostg, task_group tg
             WHERE ostg.id_order_set_process_task = i_order_set_process_task
               AND ostg.id_task_group = tg.id_task_group
             GROUP BY ostg.id_order_set_process_task;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END;
    
        RETURN l_rank;
    
    END get_odst_proc_task_group_rank;

    FUNCTION get_order_set_task_group_desc
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_desc VARCHAR2(1000 CHAR);
    
    BEGIN
    
        -- loop through all task groups of this order set task
        FOR rec IN (SELECT pk_string_utils.clob_to_sqlvarchar2(pk_translation.get_translation_trs(tg.code_task_group)) task_group_desc
                      FROM order_set_task_group ostg, task_group tg
                     WHERE ostg.id_order_set_task = i_order_set_task
                       AND ostg.id_task_group = tg.id_task_group
                     ORDER BY tg.rank, task_group_desc)
        LOOP
            l_return_desc := l_return_desc || g_separator || rec.task_group_desc;
        END LOOP;
    
        -- check if the order set task has any task group defined for it
        IF l_return_desc IS NOT NULL
        THEN
            -- remove first separator character
            RETURN substr(l_return_desc, length(g_separator) + 1);
        ELSE
        
            -- define that this order set task is in the "Other tasks" group
            RETURN pk_message.get_message(i_lang, 'TASK_GROUP_M007');
        END IF;
    
    END get_order_set_task_group_desc;

    FUNCTION get_order_set_tsk_grp_tooltip
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_desc VARCHAR2(1000 CHAR);
    
    BEGIN
    
        -- loop through all task groups of this order set task
        FOR rec IN (SELECT pk_string_utils.clob_to_sqlvarchar2(pk_translation.get_translation_trs(tg.code_task_group)) task_group_desc,
                           tg.notes
                      FROM order_set_task_group ostg, task_group tg
                     WHERE ostg.id_order_set_task = i_order_set_task
                       AND ostg.id_task_group = tg.id_task_group
                     ORDER BY tg.rank, task_group_desc)
        LOOP
            l_return_desc := l_return_desc || pk_string_utils.g_new_line || '<b>' || rec.task_group_desc || '</b>' ||
                             pk_string_utils.g_new_line || htf.escape_sc(rec.notes) || (CASE
                                 WHEN rec.notes IS NOT NULL THEN
                                  pk_string_utils.g_new_line
                             END);
        
        END LOOP;
    
        -- check if the order set task has any task group defined for it
        IF l_return_desc IS NOT NULL
        THEN
            -- remove first separator character
            RETURN substr(l_return_desc, length(pk_string_utils.g_new_line) + 1);
        ELSE
        
            -- define that this order set task is in the "Other tasks" group
            RETURN '<b>' || pk_message.get_message(i_lang, 'TASK_GROUP_M007') || '</b>';
        END IF;
    
    END get_order_set_tsk_grp_tooltip;

    FUNCTION get_order_set_task_group_rank
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN NUMBER IS
    
        l_rank NUMBER;
    BEGIN
    
        BEGIN
            SELECT MAX(tg.rank)
              INTO l_rank
              FROM order_set_task_group ostg, task_group tg
             WHERE ostg.id_order_set_task = i_order_set_task
               AND ostg.id_task_group = tg.id_task_group
             GROUP BY ostg.id_order_set_task;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END;
    
        RETURN l_rank;
    
    END get_order_set_task_group_rank;

    FUNCTION get_order_set_task_group_ids
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE
    ) RETURN table_number IS
    
        l_ids table_number := table_number();
    
    BEGIN
    
        BEGIN
            SELECT ostg.id_task_group
              BULK COLLECT
              INTO l_ids
              FROM order_set_task_group ostg, task_group tg
             WHERE ostg.id_order_set_task = i_order_set_task
               AND ostg.id_task_group = tg.id_task_group
             ORDER BY ostg.id_task_group;
        EXCEPTION
            WHEN no_data_found THEN
                NULL;
        END;
    
        RETURN l_ids;
    
    END get_order_set_task_group_ids;

    FUNCTION get_tasks_desc_by_type
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set_task.id_order_set%TYPE,
        i_id_task_type IN order_set_task.id_task_type%TYPE
    ) RETURN CLOB IS
    
        CURSOR c_odst_tasks IS
            SELECT to_clob(task_desc || decode(task_instruct, '', '', ': [') || task_instruct ||
                           decode(task_instruct, '', '', ']'))
              FROM (SELECT get_task_desc(i_lang,
                                         i_prof,
                                         odst_tsk.id_order_set_task,
                                         odst_tsk.id_task_type,
                                         pk_alert_constant.g_no,
                                         pk_alert_constant.g_no,
                                         g_task_desc_detail_format,
                                         pk_alert_constant.g_no) task_desc,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_tsk.id_order_set_task),
                                                      pk_alert_constant.g_no) task_instruct
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set = i_id_order_set
                       AND ((i_id_task_type != g_odst_task_group_episodes AND odst_tsk.id_task_type = i_id_task_type) OR
                           (i_id_task_type = g_odst_task_group_episodes AND
                           odst_tsk.id_task_type IN (g_odst_task_appoint_social,
                                                       g_odst_task_appoint_nurse,
                                                       g_odst_task_appoint_medical,
                                                       g_odst_task_appoint_nutrition,
                                                       g_odst_task_appoint_psychology,
                                                       g_odst_task_appoint_rehabilit,
                                                       g_odst_task_inpatient,
                                                       g_odst_task_inp_surg,
                                                       g_odst_task_inpatient_ptbr,
                                                       g_odst_task_inp_surg_ptbr))));
    
        ibt_desc table_clob;
    
    BEGIN
    
        g_error := 'GET TASKS DESCRIPTIONS FOR THE TASK TYPE';
        -- get descriptions
        OPEN c_odst_tasks;
        FETCH c_odst_tasks BULK COLLECT
            INTO ibt_desc;
        CLOSE c_odst_tasks;
    
        -- concatenate and return descriptions
        RETURN pk_utils.concat_table(ibt_desc, g_separator2);
    
    END get_tasks_desc_by_type;

    FUNCTION get_proc_tasks_desc_by_type
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process_task.id_order_set_process%TYPE,
        i_id_task_type         IN order_set_process_task.id_task_type%TYPE
    ) RETURN VARCHAR2 IS
    
        CURSOR c_odst_proc_tasks IS
            SELECT task_desc || decode(task_instruct, '', '', ': [') || task_instruct ||
                   decode(task_instruct, '', '', ']')
              FROM (SELECT get_task_desc(i_lang,
                                         i_prof,
                                         odst_proc_tsk.id_order_set_process_task,
                                         odst_proc_tsk.id_task_type,
                                         pk_alert_constant.g_yes,
                                         pk_alert_constant.g_no,
                                         g_task_desc_detail_format,
                                         pk_alert_constant.g_no) task_desc,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_proc_tsk.id_order_set_process_task),
                                                      pk_alert_constant.g_yes) task_instruct
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
                       AND ((i_id_task_type != g_odst_task_group_episodes AND
                           odst_proc_tsk.id_task_type = i_id_task_type) OR
                           (i_id_task_type = g_odst_task_group_episodes AND
                           odst_proc_tsk.id_task_type IN (g_odst_task_appoint_social,
                                                            g_odst_task_appoint_nurse,
                                                            g_odst_task_appoint_medical,
                                                            g_odst_task_appoint_nutrition,
                                                            g_odst_task_appoint_psychology,
                                                            g_odst_task_appoint_rehabilit,
                                                            g_odst_task_inpatient,
                                                            g_odst_task_inp_surg,
                                                            g_odst_task_inpatient_ptbr,
                                                            g_odst_task_inp_surg_ptbr))));
    
        ibt_desc table_varchar;
    
    BEGIN
    
        g_error := 'GET PROCESS TASKS DESCRIPTIONS FOR THE TASK TYPE';
        -- get descriptions
        OPEN c_odst_proc_tasks;
        FETCH c_odst_proc_tasks BULK COLLECT
            INTO ibt_desc;
        CLOSE c_odst_proc_tasks;
    
        -- concatenate and return descriptions
        RETURN pk_utils.concat_table(ibt_desc, g_separator2);
    
    END get_proc_tasks_desc_by_type;

    FUNCTION get_odst_task_link
    (
        i_id_order_set_task     IN order_set_task_link.id_order_set_task%TYPE,
        i_id_flg_task_link_type IN order_set_task_link.flg_task_link_type%TYPE
    ) RETURN order_set_task_link.id_task_link%TYPE IS
    
        l_return_val order_set_task_link.id_task_link%TYPE;
    
    BEGIN
    
        -- get task link
        BEGIN
            SELECT id_task_link
              INTO l_return_val
              FROM order_set_task_link
             WHERE id_order_set_task = i_id_order_set_task
               AND nvl(flg_task_link_type, -1) = nvl(i_id_flg_task_link_type, nvl(flg_task_link_type, -1));
        EXCEPTION
            -- if no data found or select returns more than one row, function returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    
    END get_odst_task_link;

    FUNCTION get_odst_task_links_all
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_tasks   IN table_number,
        o_order_set_task_links OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'GET ALL TASK LINKS';
        OPEN o_order_set_task_links FOR
            SELECT /*+opt_estimate(table odst_tsk_ids rows=1)*/
             id_order_set_task,
             id_task_link,
             decode(flg_task_link_type, g_task_link_null, NULL, flg_task_link_type) flg_task_link_type
              FROM order_set_task_link, TABLE(i_id_order_set_tasks) odst_tsk_ids
             WHERE id_order_set_task = odst_tsk_ids.column_value;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_TASK_LINKS_ALL',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_task_links);
            RETURN FALSE;
    END get_odst_task_links_all;

    FUNCTION get_odst_task_link_type(i_id_order_set_task IN order_set_task_link.id_order_set_task%TYPE)
        RETURN order_set_task_link.flg_task_link_type%TYPE IS
    
        l_return_val order_set_task_link.flg_task_link_type%TYPE;
    
    BEGIN
    
        -- get "most heavy" task link type
        BEGIN
            SELECT flg_task_link_type
              INTO l_return_val
              FROM (SELECT flg_task_link_type
                      FROM order_set_task_link
                     WHERE id_order_set_task = i_id_order_set_task
                    -- order task link types by weights 
                     ORDER BY decode(flg_task_link_type,
                                     g_task_link_null,
                                     g_task_link_null_weight,
                                     g_task_link_analysis,
                                     g_task_link_analysis_weight,
                                     g_task_link_exam,
                                     g_task_link_exam_weight,
                                     g_task_link_group,
                                     g_task_link_group_weight,
                                     -1) DESC)
             WHERE rownum = 1;
        
        EXCEPTION
            -- if no data found returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    
    END get_odst_task_link_type;

    FUNCTION get_odst_proc_task_link
    (
        i_id_order_set_process_task IN order_set_process_task_link.id_order_set_process_task%TYPE,
        i_id_flg_task_link_type     IN order_set_process_task_link.flg_task_link_type%TYPE
    ) RETURN order_set_process_task_link.id_task_link%TYPE IS
    
        l_return_val order_set_process_task_link.id_task_link%TYPE;
    
    BEGIN
    
        -- get task link
        BEGIN
            SELECT id_task_link
              INTO l_return_val
              FROM order_set_process_task_link
             WHERE id_order_set_process_task = i_id_order_set_process_task
               AND nvl(flg_task_link_type, -1) = nvl(i_id_flg_task_link_type, nvl(flg_task_link_type, -1));
        EXCEPTION
            -- if no data found or select returns more than one row, function returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    END get_odst_proc_task_link;

    FUNCTION get_odst_task_det_val
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set_task           IN order_set_task_detail.id_order_set_task%TYPE,
        i_flg_detail_type             IN order_set_task_detail.flg_detail_type%TYPE,
        i_id_advanced_input           IN order_set_task_detail.id_advanced_input%TYPE,
        i_id_advanced_input_field     IN order_set_task_detail.id_advanced_input_field%TYPE,
        i_id_advanced_input_field_det IN order_set_task_detail.id_advanced_input_field_det%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_val VARCHAR2(4000);
    
    BEGIN
    
        -- get task link
        BEGIN
            SELECT decode(flg_value_type,
                          g_task_det_value_type_number,
                          to_char(nvalue),
                          g_task_det_value_type_varchar,
                          vvalue,
                          g_task_det_value_type_date,
                          pk_date_utils.date_send_tsz(i_lang, dvalue, i_prof),
                          NULL)
              INTO l_return_val
              FROM order_set_task_detail
             WHERE id_order_set_task = i_id_order_set_task
               AND flg_detail_type = i_flg_detail_type
               AND nvl(id_advanced_input, -1) = nvl(i_id_advanced_input, nvl(id_advanced_input, -1))
               AND nvl(id_advanced_input_field, -1) = nvl(i_id_advanced_input_field, nvl(id_advanced_input_field, -1))
               AND nvl(id_advanced_input_field_det, -1) =
                   nvl(i_id_advanced_input_field_det, nvl(id_advanced_input_field_det, -1));
        EXCEPTION
            -- if no data found or select returns more than one row, function returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    
    END get_odst_task_det_val;

    FUNCTION get_odst_task_multi_link
    (
        i_id_order_set_task     IN order_set_task_link.id_order_set_task%TYPE,
        i_id_flg_task_link_type IN order_set_task_link.flg_task_link_type%TYPE
    ) RETURN table_number IS
    
        l_return_vals table_number;
    
    BEGIN
    
        -- get task links
        SELECT to_number(id_task_link)
          BULK COLLECT
          INTO l_return_vals
          FROM order_set_task_link
         WHERE id_order_set_task = i_id_order_set_task
           AND nvl(flg_task_link_type, -1) = nvl(i_id_flg_task_link_type, nvl(flg_task_link_type, -1));
    
        RETURN l_return_vals;
    
    END get_odst_task_multi_link;

    FUNCTION get_odst_proc_task_multi_link
    (
        i_id_order_set_process_task IN order_set_process_task_link.id_order_set_process_task%TYPE,
        i_id_flg_task_link_type     IN order_set_process_task_link.flg_task_link_type%TYPE
    ) RETURN table_number IS
        l_return_vals table_number;
    BEGIN
    
        -- get task links
        SELECT to_number(id_task_link)
          BULK COLLECT
          INTO l_return_vals
          FROM order_set_process_task_link
         WHERE id_order_set_process_task = i_id_order_set_process_task
           AND nvl(flg_task_link_type, -1) = nvl(i_id_flg_task_link_type, nvl(flg_task_link_type, -1));
    
        RETURN l_return_vals;
    END get_odst_proc_task_multi_link;

    FUNCTION get_odst_proc_task_link_type(i_id_order_set_process_task IN order_set_process_task_link.id_order_set_process_task%TYPE)
        RETURN order_set_process_task_link.flg_task_link_type%TYPE IS
    
        l_return_val order_set_process_task_link.flg_task_link_type%TYPE;
    
    BEGIN
    
        -- get "most heavy" task link type
        BEGIN
            SELECT flg_task_link_type
              INTO l_return_val
              FROM (SELECT flg_task_link_type
                      FROM order_set_process_task_link
                     WHERE id_order_set_process_task = i_id_order_set_process_task
                    -- order task link types by weights 
                     ORDER BY decode(flg_task_link_type,
                                     g_task_link_null,
                                     g_task_link_null_weight,
                                     g_task_link_analysis,
                                     g_task_link_analysis_weight,
                                     g_task_link_exam,
                                     g_task_link_exam_weight,
                                     g_task_link_group,
                                     g_task_link_group_weight,
                                     -1) DESC)
             WHERE rownum = 1;
        
        EXCEPTION
            -- if no data found returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    
    END get_odst_proc_task_link_type;

    FUNCTION get_odst_proc_task_det_val
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set_process_task   IN order_set_process_task_det.id_order_set_process_task%TYPE,
        i_flg_detail_type             IN order_set_process_task_det.flg_detail_type%TYPE,
        i_id_advanced_input           IN order_set_process_task_det.id_advanced_input%TYPE,
        i_id_advanced_input_field     IN order_set_process_task_det.id_advanced_input_field%TYPE,
        i_id_advanced_input_field_det IN order_set_process_task_det.id_advanced_input_field_det%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_val VARCHAR2(4000);
    
    BEGIN
    
        -- get task link
        BEGIN
            SELECT decode(flg_value_type,
                          g_task_det_value_type_number,
                          to_char(nvalue),
                          g_task_det_value_type_varchar,
                          vvalue,
                          g_task_det_value_type_date,
                          pk_date_utils.date_send_tsz(i_lang, dvalue, i_prof),
                          NULL)
              INTO l_return_val
              FROM order_set_process_task_det
             WHERE id_order_set_process_task = i_id_order_set_process_task
               AND flg_detail_type = i_flg_detail_type
               AND nvl(id_advanced_input, -1) = nvl(i_id_advanced_input, nvl(id_advanced_input, -1))
               AND nvl(id_advanced_input_field, -1) = nvl(i_id_advanced_input_field, nvl(id_advanced_input_field, -1))
               AND nvl(id_advanced_input_field_det, -1) =
                   nvl(i_id_advanced_input_field_det, nvl(id_advanced_input_field_det, -1));
        EXCEPTION
            -- if no data found or select returns more than one row, function returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_val;
    
    END get_odst_proc_task_det_val;

    FUNCTION get_odst_proc_task_det_unit
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set_process_task   IN order_set_process_task_det.id_order_set_process_task%TYPE,
        i_flg_detail_type             IN order_set_process_task_det.flg_detail_type%TYPE,
        i_id_advanced_input           IN order_set_process_task_det.id_advanced_input%TYPE,
        i_id_advanced_input_field     IN order_set_process_task_det.id_advanced_input_field%TYPE,
        i_id_advanced_input_field_det IN order_set_process_task_det.id_advanced_input_field_det%TYPE
    ) RETURN order_set_process_task_det.id_unit_measure%TYPE IS
    
        l_return_unit order_set_process_task_det.id_unit_measure%TYPE;
    
    BEGIN
    
        -- get task link
        BEGIN
            SELECT id_unit_measure
              INTO l_return_unit
              FROM order_set_process_task_det
             WHERE id_order_set_process_task = i_id_order_set_process_task
               AND flg_detail_type = i_flg_detail_type
               AND nvl(id_advanced_input, -1) = nvl(i_id_advanced_input, nvl(id_advanced_input, -1))
               AND nvl(id_advanced_input_field, -1) = nvl(i_id_advanced_input_field, nvl(id_advanced_input_field, -1))
               AND nvl(id_advanced_input_field_det, -1) =
                   nvl(i_id_advanced_input_field_det, nvl(id_advanced_input_field_det, -1));
        EXCEPTION
            -- if no data found or select returns more than one row, function returns null
            WHEN OTHERS THEN
                RETURN NULL;
        END;
    
        RETURN l_return_unit;
    
    END get_odst_proc_task_det_unit;

    PROCEDURE get_odst_task_det_multi_val
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_order_set_task IN order_set_task_detail.id_order_set_task%TYPE,
        i_flg_detail_type   IN order_set_task_detail.flg_detail_type%TYPE,
        o_nvalues           OUT table_number,
        o_vvalues           OUT table_varchar,
        o_dvalues           OUT table_varchar
    ) AS
    
    BEGIN
        -- get task details
        SELECT to_char(nvalue), vvalue, pk_date_utils.date_send_tsz(i_lang, dvalue, i_prof)
          BULK COLLECT
          INTO o_nvalues, o_vvalues, o_dvalues
          FROM order_set_task_detail
         WHERE id_order_set_task = i_id_order_set_task
           AND flg_detail_type = i_flg_detail_type;
    
    END get_odst_task_det_multi_val;

    PROCEDURE get_odst_prc_tsk_det_multi_val
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_id_order_set_process_task IN order_set_process_task_det.id_order_set_process_task%TYPE,
        i_flg_detail_type           IN order_set_process_task_det.flg_detail_type%TYPE,
        o_nvalues                   OUT table_number,
        o_vvalues                   OUT table_varchar,
        o_dvalues                   OUT table_varchar
    ) AS
    
    BEGIN
    
        -- get task link
        SELECT to_char(nvalue), vvalue, pk_date_utils.date_send_tsz(i_lang, dvalue, i_prof)
          BULK COLLECT
          INTO o_nvalues, o_vvalues, o_dvalues
          FROM order_set_process_task_det
         WHERE id_order_set_process_task = i_id_order_set_process_task
           AND flg_detail_type = i_flg_detail_type;
    
    END get_odst_prc_tsk_det_multi_val;

    FUNCTION get_order_set_proc_task_status
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_patient          IN patient.id_patient%TYPE,
        i_id_episode          IN episode.id_episode%TYPE,
        i_id_request          IN order_set_process_task.id_request%TYPE,
        i_id_task_type        IN order_set_process_task.id_task_type%TYPE,
        o_new_flg_task_status OUT order_set_process_task.flg_status%TYPE,
        o_status_string       OUT VARCHAR2,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_result       BOOLEAN;
        l_flg_finished VARCHAR2(1 CHAR) := g_no;
        l_flg_canceled VARCHAR2(1 CHAR) := g_no;
        l_o_flg_status VARCHAR2(30);
    
        error_unexpected EXCEPTION;
    
    BEGIN
    
        g_error := 'GET TASK STATUS';
        -- get task status
        CASE
            WHEN i_id_task_type IN (g_odst_task_predef_diet, g_odst_task_instit_diet) THEN
                -- predefined or institutionalized diet prescriptions
                g_error  := g_error || ' / ' || 'PREDEFINED DIET OR INSTITUTIONALIZED DIET PRESCRIPTION';
                l_result := pk_diet.get_diet_status(i_lang          => i_lang,
                                                    i_prof          => i_prof,
                                                    i_diet          => i_id_request,
                                                    o_status_string => o_status_string,
                                                    o_flag_canceled => l_flg_canceled,
                                                    o_flag_finished => l_flg_finished,
                                                    o_error         => o_error);
            
                -- always query predefined or institutionalized diet task type module about task status (override previous function call)
                l_flg_finished := g_no;
                --l_flg_canceled := g_no; -- this code removal will avoid order set to be considered always as interrupted
        
            WHEN i_id_task_type = g_odst_task_followup_appoint THEN
                -- Follow-up appointment
                g_error  := g_error || ' / ' || 'FOLLOW-UP_APPOINTMENT';
                l_result := pk_consult_req.get_subs_req_status(i_lang           => i_lang,
                                                               i_prof           => i_prof,
                                                               i_epis           => i_id_episode,
                                                               i_id_consult_req => i_id_request,
                                                               o_flg_status     => l_o_flg_status,
                                                               o_status_string  => o_status_string,
                                                               o_flg_finished   => l_flg_finished,
                                                               o_flg_canceled   => l_flg_canceled,
                                                               o_error          => o_error);
            
            WHEN i_id_task_type = g_odst_task_specialty_appoint THEN
                -- Specialty appointment
                g_error  := g_error || ' / ' || 'SPECIALTY APPOINTMENT';
                l_result := pk_consult_req.get_subs_req_status(i_lang           => i_lang,
                                                               i_prof           => i_prof,
                                                               i_epis           => i_id_episode,
                                                               i_id_consult_req => i_id_request,
                                                               o_flg_status     => l_o_flg_status,
                                                               o_status_string  => o_status_string,
                                                               o_flg_finished   => l_flg_finished,
                                                               o_flg_canceled   => l_flg_canceled,
                                                               o_error          => o_error);
            
            WHEN i_id_task_type = g_odst_task_consult THEN
                -- consult/opinion
                g_error  := g_error || ' / ' || 'CONSULT';
                l_result := pk_opinion.get_opinion_status(i_lang          => i_lang,
                                                          i_prof          => i_prof,
                                                          i_id_opinion    => i_id_request,
                                                          o_flg_status    => l_o_flg_status,
                                                          o_status_string => o_status_string,
                                                          o_flg_finished  => l_flg_finished,
                                                          o_flg_canceled  => l_flg_canceled,
                                                          o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_discharge_instruct THEN
                -- discharge instruction
                g_error        := g_error || ' / ' || 'DISCHARGE INSTRUCTION';
                l_result       := TRUE;
                l_flg_finished := g_yes;
                l_flg_canceled := g_no;
            
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                -- Image or Other exam
                g_error  := g_error || ' / ' || 'IMAGE OR OTHER EXAM';
                l_result := pk_exams_external_api_db.get_exam_status(i_lang          => i_lang,
                                                                     i_prof          => i_prof,
                                                                     i_task_request  => i_id_request,
                                                                     o_flg_status    => l_o_flg_status,
                                                                     o_status_string => o_status_string,
                                                                     o_error         => o_error);
            
                -- always query exams module about task status
                l_flg_finished := g_no;
                l_flg_canceled := g_no;
            
            WHEN i_id_task_type = g_odst_task_monitoring THEN
                -- Monitoring
                g_error  := g_error || ' / ' || 'MONITORING';
                l_result := pk_monitorization.get_monitor_req_status(i_lang              => i_lang,
                                                                     i_prof              => i_prof,
                                                                     i_id_monitorization => i_id_request,
                                                                     o_flg_status        => l_o_flg_status,
                                                                     o_status_string     => o_status_string,
                                                                     o_flg_finished      => l_flg_finished,
                                                                     o_flg_canceled      => l_flg_canceled,
                                                                     o_error             => o_error);
            
            WHEN i_id_task_type = g_odst_task_procedure THEN
                -- procedure
                g_error  := g_error || ' / ' || 'PROCEDURE';
                l_result := pk_procedures_external_api_db.get_procedure_status(i_lang          => i_lang,
                                                                               i_prof          => i_prof,
                                                                               i_task_request  => i_id_request,
                                                                               o_flg_status    => l_o_flg_status,
                                                                               o_status_string => o_status_string,
                                                                               o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_bp THEN
            
                g_error  := g_error || ' / ' || 'PROCEDURE';
                l_result := pk_bp_external_api_db.get_bp_status(i_lang          => i_lang,
                                                                i_prof          => i_prof,
                                                                i_task_request  => i_id_request,
                                                                o_flg_status    => l_o_flg_status,
                                                                o_status_string => o_status_string,
                                                                o_error         => o_error);
            
            WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
            
                -- procedure
                g_error  := g_error || ' / ' || 'HIDRICS';
                l_result := pk_inp_hidrics_pbl.get_hidric_status(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_task_request  => i_id_request,
                                                                 o_flg_status    => l_o_flg_status,
                                                                 o_status_string => o_status_string,
                                                                 o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_patient_education THEN
                -- patient education
                g_error := g_error || ' / ' || 'PATIENT EDUCATION';
            
                l_result := pk_patient_education_api_db.get_nurse_teach_status(i_lang             => i_lang,
                                                                               i_prof             => i_prof,
                                                                               i_id_nurse_tea_req => i_id_request,
                                                                               o_flg_status       => l_o_flg_status,
                                                                               o_status_string    => o_status_string,
                                                                               o_flg_finished     => l_flg_finished,
                                                                               o_flg_canceled     => l_flg_canceled,
                                                                               o_error            => o_error);
            
            WHEN i_id_task_type = g_odst_task_analysis THEN
                -- Lab tests
                g_error  := g_error || ' / ' || 'ANALYSIS';
                l_result := pk_lab_tests_external_api_db.get_lab_test_status(i_lang          => i_lang,
                                                                             i_prof          => i_prof,
                                                                             i_task_request  => i_id_request,
                                                                             o_flg_status    => l_o_flg_status,
                                                                             o_status_string => o_status_string,
                                                                             o_error         => o_error);
            
                -- always query lab tests module about task status
                l_flg_finished := g_no;
                l_flg_canceled := g_no;
            
            WHEN i_id_task_type = g_odst_task_appoint_social THEN
                -- Social Assistance Appointment
                g_error := g_error || ' / ' || 'SOCIAL ASSISTANCE APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_nurse THEN
                -- Nursing Appointment
                g_error := g_error || ' / ' || 'NURSING APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_medical THEN
            
                -- Medical Appointment
                g_error := g_error || ' / ' || 'MEDICAL APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_nutrition THEN
            
                -- Nutrition Appointment
                g_error := g_error || ' / ' || 'NUTRITION APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_psychology THEN
                -- Psychology Appointment
                g_error := g_error || ' / ' || 'PSYCHOLOGY APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_rehabilit THEN
            
                -- Rehabilitation Appointment
                g_error := g_error || ' / ' || 'REHABILITATION APPOINTMENT';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_inpatient THEN
                -- Inpatient Episode
                g_error := g_error || ' / ' || 'INPATIENT EPISODE';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_inp_surg THEN
                -- Inpatient With Surgery Episode
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_inpatient_ptbr THEN
                -- Inpatient Episode for pt/br markets
                g_error := g_error || ' / ' || 'INPATIENT EPISODE FOR PT/BR MARKETS';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_inp_surg_ptbr THEN
                -- Inpatient With Surgery Episode for pt/br markets
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE FOR PT/BR MARKETS';
            
                l_result := pk_events.get_epis_status(i_lang          => i_lang,
                                                      i_prof          => i_prof,
                                                      i_patient       => i_id_patient,
                                                      i_episode       => i_id_request,
                                                      o_status_string => o_status_string,
                                                      o_flag_canceled => l_flg_canceled,
                                                      o_flag_finished => l_flg_finished,
                                                      o_error         => o_error);
            
            WHEN i_id_task_type = g_odst_task_medication THEN
                -- New medication
                g_error := g_error || ' / ' || 'NEW MEDICATION';
            
                l_result := pk_api_pfh_ordertools_in.get_medication_status(i_lang          => i_lang,
                                                                           i_prof          => i_prof,
                                                                           i_id_presc      => i_id_request,
                                                                           o_status_string => o_status_string,
                                                                           o_error         => o_error);
            
                -- always query medication module about task status
                l_flg_finished := g_no;
                l_flg_canceled := g_no;
            
            WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                -- Communication order
                g_error := g_error || ' / ' || 'COMMUNICATION ORDER';
            
                l_result := pk_comm_orders_order_sets.get_comm_order_status(i_lang              => i_lang,
                                                                            i_prof              => i_prof,
                                                                            i_id_comm_order_req => i_id_request,
                                                                            o_task_status       => o_status_string,
                                                                            o_error             => o_error);
            
                -- always query communication orders module about task status
                l_flg_finished := g_no;
                l_flg_canceled := g_no;
            
            WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                -- supplies or surgical supplies task type
                g_error  := g_error || ' / ' || 'SUPPLIES OR SURGICAL SUPPLIES';
                l_result := pk_supplies_order_sets.get_supply_wf_status(i_lang               => i_lang,
                                                                        i_prof               => i_prof,
                                                                        i_id_supply_workflow => i_id_request,
                                                                        o_task_status        => o_status_string,
                                                                        o_error              => o_error);
            
                -- always query supplies module about task status
                l_flg_finished := g_no;
                l_flg_canceled := g_no;
            
            ELSE
                l_result := FALSE;
                g_error  := g_error || ' / ' || 'UNKNOWN ORDER SET TASK TYPE / ' || i_id_task_type;
        END CASE;
    
        -- raise exception when an error occurs
        IF (l_result = FALSE)
        THEN
            RAISE error_unexpected;
        END IF;
    
        -- calculate new task status    
        IF (l_flg_finished = g_yes OR l_flg_canceled = g_yes)
        THEN
        
            SELECT decode(l_flg_finished, g_yes, g_order_set_proc_tsk_finished, g_order_set_proc_tsk_canceled)
              INTO o_new_flg_task_status
              FROM dual;
        ELSE
            o_new_flg_task_status := g_order_set_proc_tsk_running;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- external error
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASK_STATUS',
                                              o_error);
            RETURN FALSE;
            -- unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASK_STATUS',
                                              o_error);
            RETURN FALSE;
    END get_order_set_proc_task_status;

    FUNCTION get_odst_proc_task_status_str
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_patient      IN patient.id_patient%TYPE,
        i_id_episode      IN episode.id_episode%TYPE,
        i_id_request      IN order_set_process_task.id_request%TYPE,
        i_id_task_type    IN order_set_process_task.id_task_type%TYPE,
        i_flg_task_status IN order_set_process.flg_status%TYPE
    ) RETURN VARCHAR2 IS
    
        l_new_flg_task_status order_set_process_task.flg_status%TYPE;
        l_status_str          VARCHAR2(200);
    
        error_unexpected EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        -- if task status is not running, then build task status string here
        IF i_flg_task_status != g_order_set_proc_tsk_running
        THEN
            RETURN pk_utils.get_status_string_immediate(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_display_type => pk_alert_constant.g_display_type_icon,
                                                        i_flg_state    => i_flg_task_status,
                                                        i_value_text   => NULL,
                                                        i_value_date   => NULL,
                                                        i_value_icon   => g_odst_ptsk_flg_status_domain);
        END IF;
    
        -- get task status string
        IF NOT get_order_set_proc_task_status(i_lang,
                                              i_prof,
                                              i_id_patient,
                                              i_id_episode,
                                              i_id_request,
                                              i_id_task_type,
                                              l_new_flg_task_status,
                                              l_status_str,
                                              l_error)
        THEN
        
            g_error := g_error || ' / ' || l_error.err_desc;
            RAISE error_unexpected;
        END IF;
    
        RETURN l_status_str;
    
    END get_odst_proc_task_status_str;

    FUNCTION refresh_odst_procs_status
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_patient              IN patient.id_patient%TYPE,
        i_id_episode              IN episode.id_episode%TYPE,
        i_flg_refresh_task_status IN VARCHAR2,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_new_flg_task_status     order_set_process_task.flg_status%TYPE;
        l_status_string           VARCHAR2(200);
        l_sysdate                 TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_flg_task_status_updated BOOLEAN := FALSE;
    
        CURSOR c_proc_tasks IS
            SELECT odst_proc_tsk.id_order_set_process_task,
                   odst_proc_tsk.id_task_type,
                   odst_proc_tsk.id_request,
                   odst_proc_tsk.flg_status
              FROM order_set_process_task odst_proc_tsk, order_set_process odst_proc
             WHERE odst_proc.id_patient = i_id_patient
               AND odst_proc.flg_status = g_order_set_proc_running
               AND odst_proc_tsk.id_order_set_process = odst_proc.id_order_set_process
               AND odst_proc_tsk.flg_status = g_order_set_proc_tsk_running
               AND odst_proc_tsk.flg_discard_type = g_task_not_discard;
    
        CURSOR c_odst_procs IS
            SELECT odst_proc.id_order_set_process
              FROM order_set_process odst_proc
             WHERE odst_proc.id_patient = i_id_patient
               AND odst_proc.flg_status = g_order_set_proc_running;
    
        error_unexpected EXCEPTION;
    
    BEGIN
    
        IF (i_flg_refresh_task_status = g_yes)
        THEN
        
            g_error := 'REFRESH STATUS OF THE TASKS';
            FOR rec IN c_proc_tasks
            LOOP
                -- get order set task status
                IF NOT get_order_set_proc_task_status(i_lang,
                                                      i_prof,
                                                      i_id_patient,
                                                      i_id_episode,
                                                      rec.id_request,
                                                      rec.id_task_type,
                                                      l_new_flg_task_status,
                                                      l_status_string,
                                                      o_error)
                THEN
                    RAISE error_unexpected;
                END IF;
            
                -- update order set process task status
                UPDATE order_set_process_task
                   SET flg_status = l_new_flg_task_status, dt_status_tstz = l_sysdate, id_professional = i_prof.id
                 WHERE id_order_set_process_task = rec.id_order_set_process_task
                   AND flg_status = g_order_set_proc_tsk_running
                   AND l_new_flg_task_status != g_order_set_proc_tsk_running;
            
                -- indicate if at least one task was updated
                IF (SQL%ROWCOUNT > 0)
                THEN
                    l_flg_task_status_updated := TRUE;
                END IF;
            
            END LOOP;
        END IF;
    
        IF l_flg_task_status_updated
           OR i_flg_refresh_task_status = g_no
        THEN
        
            g_error := 'REFRESH STATUS OF THE PROCESSES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            FOR rec IN c_odst_procs
            LOOP
                -- update order set process status
                UPDATE order_set_process odst_proc
                   SET odst_proc.flg_status     =
                       (SELECT decode(flg_status,
                                      g_order_set_proc_tsk_temp,
                                      g_order_set_proc_temp,
                                      g_order_set_proc_tsk_finished,
                                      g_order_set_proc_finished,
                                      g_order_set_proc_tsk_canceled,
                                      g_order_set_proc_canceled,
                                      g_order_set_proc_tsk_running,
                                      g_order_set_proc_running)
                          FROM (SELECT odst_proc_tsk.flg_status
                                  FROM order_set_process_task odst_proc_tsk
                                 WHERE odst_proc_tsk.id_order_set_process = rec.id_order_set_process
                                   AND odst_proc_tsk.flg_discard_type = g_task_not_discard
                                 ORDER BY decode(odst_proc_tsk.flg_status,
                                                 g_order_set_proc_tsk_temp,
                                                 g_odst_proc_tsk_temp_weight,
                                                 g_order_set_proc_tsk_running,
                                                 g_odst_proc_tsk_run_weight,
                                                 g_order_set_proc_tsk_finished,
                                                 g_odst_proc_tsk_fin_weight,
                                                 g_order_set_proc_tsk_canceled,
                                                 g_odst_proc_tsk_can_weight) DESC)
                         WHERE rownum = 1),
                       odst_proc.dt_status_tstz =
                       (SELECT MAX(odst_proc_tsk.dt_status_tstz)
                          FROM order_set_process_task odst_proc_tsk
                         WHERE odst_proc_tsk.id_order_set_process = rec.id_order_set_process
                           AND odst_proc_tsk.flg_discard_type = g_task_not_discard),
                       odst_proc.id_professional = i_prof.id
                 WHERE odst_proc.id_order_set_process = rec.id_order_set_process;
            
            END LOOP;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- error while getting order set task status 
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'REFRESH_ODST_PROCS_STATUS',
                                              o_error);
            RETURN FALSE;
            -- internal unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'REFRESH_ODST_PROCS_STATUS',
                                              o_error);
            RETURN FALSE;
    END refresh_odst_procs_status;

    FUNCTION cancel_odst_proc_task_episode
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE,
        i_transaction_id         IN VARCHAR2,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_odst_proc_task_type order_set_process_task.id_order_set_process_task%TYPE := get_odst_proc_task_type(i_lang,
                                                                                                               i_prof,
                                                                                                               i_order_set_process_task);
        l_id_waiting_list     waiting_list.id_waiting_list%TYPE;
        l_episode_req_id      episode.id_episode%TYPE;
        l_flg_order_set_task  order_set_process_task.flg_order_set_task%TYPE;
    
        l_msg_error VARCHAR2(1000 CHAR);
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'DELETE AN ORDER SET PROCESS EPISODE';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- get episode request ID (episode ID) and flag that indicates if task was created within order set process
        SELECT odst_proc_tsk.id_request, odst_proc_tsk.flg_order_set_task
          INTO l_episode_req_id, l_flg_order_set_task
          FROM order_set_process_task odst_proc_tsk
         WHERE odst_proc_tsk.id_order_set_process_task = i_order_set_process_task;
    
        -- cancel inpatient episode if its requisition was created for this order set process
        IF l_odst_proc_task_type IN
           (g_odst_task_inpatient, g_odst_task_inp_surg, g_odst_task_inpatient_ptbr, g_odst_task_inp_surg_ptbr)
           AND l_flg_order_set_task = pk_alert_constant.g_yes
        THEN
        
            -- get episode waiting list ID
            IF NOT pk_wtl_pbl_core.get_episode_wtl(i_lang    => i_lang,
                                                   i_prof    => i_prof,
                                                   i_episode => l_episode_req_id,
                                                   o_wtl     => l_id_waiting_list,
                                                   o_error   => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            -- cancel episode
            IF NOT pk_wtl_pbl_core.cancel_wtlist(i_lang             => i_lang,
                                                 i_prof             => i_prof,
                                                 i_wtl_id           => l_id_waiting_list,
                                                 i_id_cancel_reason => NULL,
                                                 i_notes_cancel     => NULL,
                                                 i_transaction_id   => i_transaction_id,
                                                 i_flg_rolback      => pk_alert_constant.g_no,
                                                 o_msg_error        => l_msg_error,
                                                 o_error            => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
        ELSE
            -- unknown episode type
            g_error := g_error || ' / ' || 'UNKNOWN EPISODE TYPE';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ODST_PROC_TASK_EPISODE',
                                              o_error);
        
            RETURN FALSE;
    END cancel_odst_proc_task_episode;

    FUNCTION cancel_odst_proc_tasks_intern
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_patient       IN patient.id_patient%TYPE,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_proc_tasks    IN table_number,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        i_cancel_notes     IN VARCHAR2,
        i_prof_order       IN order_set_process.id_prof_order%TYPE,
        i_dt_order         IN VARCHAR2,
        i_order_type       IN order_set_process.id_order_type%TYPE,
        i_transaction_id   IN VARCHAR2,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_cancel_result BOOLEAN;
        l_prof_cat      category.flg_type%TYPE := pk_prof_utils.get_category(i_lang, i_prof);
        l_sysdate       TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_cancel_notes_text pk_translation.t_desc_translation;
    
        l_task_cancelled BOOLEAN;
    
        l_cancel_predefined_tasks table_number;
    
        CURSOR c_proc_tasks IS
            SELECT odst_proc_tsk.id_order_set_process_task, odst_proc_tsk.id_task_type, odst_proc_tsk.id_request
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.flg_status = g_order_set_proc_tsk_running
               AND odst_proc_tsk.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tsk rows=1)*/
                     tsk.column_value
                      FROM TABLE(i_id_proc_tasks) tsk);
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    
        error_unexpected EXCEPTION;
    
    BEGIN
        -- check if cancel notes is null. if so, then change cancel notes text using the cancel reason description
        IF i_cancel_notes IS NULL
           AND i_id_cancel_reason IS NOT NULL
        THEN
            SELECT pk_translation.get_translation(i_lang, cr.code_cancel_reason)
              INTO l_cancel_notes_text
              FROM cancel_reason cr
             WHERE cr.id_cancel_reason = i_id_cancel_reason;
        ELSE
            l_cancel_notes_text := i_cancel_notes;
        END IF;
    
        g_error := 'CANCEL ORDER SET PROCESS TASKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(i_transaction_id, i_prof);
    
        FOR rec IN c_proc_tasks
        LOOP
            -- by default, the task was successfully cancelled.
            -- this confirmation should be provided by the api responsible for canceling each task.
            l_task_cancelled := TRUE;
            l_cancel_result  := FALSE;
        
            CASE
                WHEN rec.id_task_type IN (g_odst_task_predef_diet, g_odst_task_instit_diet) THEN
                    -- predefined or institutionalized diet prescriptions
                    -- check if predefined or institutionalized diet can be cancelled
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        g_error         := g_error || ' / ' || 'PREDEFINED OR INSTITUTIONALIZED DIET PRESCRIPTION';
                        l_cancel_result := pk_diet.cancel_diet(i_lang    => i_lang,
                                                               i_prof    => i_prof,
                                                               i_id_diet => rec.id_request,
                                                               i_notes   => i_cancel_notes,
                                                               i_reason  => i_id_cancel_reason,
                                                               o_error   => o_error);
                    ELSE
                        -- no error should be raised
                        l_cancel_result := TRUE;
                        -- predefined diet cancel action cannot be performed
                        l_task_cancelled := FALSE;
                    END IF;
                
                WHEN rec.id_task_type = g_odst_task_followup_appoint THEN
                    -- Follow-up appointment
                    g_error         := g_error || ' / ' || 'FOLLOW-UP APPOINTMENT';
                    l_cancel_result := pk_consult_req.cancel_consult_req(i_lang         => i_lang,
                                                                         i_consult_req  => rec.id_request,
                                                                         i_prof_cancel  => i_prof,
                                                                         i_notes_cancel => l_cancel_notes_text,
                                                                         i_commit_data  => pk_alert_constant.g_no,
                                                                         o_error        => o_error);
                WHEN rec.id_task_type = g_odst_task_specialty_appoint THEN
                    -- Specialty appointment
                    g_error         := g_error || ' / ' || 'SPECIALTY APPOINTMENT';
                    l_cancel_result := pk_consult_req.cancel_consult_req(i_lang         => i_lang,
                                                                         i_consult_req  => rec.id_request,
                                                                         i_prof_cancel  => i_prof,
                                                                         i_notes_cancel => l_cancel_notes_text,
                                                                         i_commit_data  => pk_alert_constant.g_no,
                                                                         o_error        => o_error);
                WHEN rec.id_task_type = g_odst_task_consult THEN
                    -- consult/opinion
                    g_error         := g_error || ' / ' || 'OPINION';
                    l_cancel_result := pk_opinion.cancel_opinion(i_lang          => i_lang,
                                                                 i_opinion       => rec.id_request,
                                                                 i_prof          => i_prof,
                                                                 i_notes         => i_cancel_notes,
                                                                 i_cancel_reason => i_id_cancel_reason,
                                                                 i_commit_data   => pk_alert_constant.g_no,
                                                                 o_error         => o_error);
                
                WHEN rec.id_task_type = g_odst_task_discharge_instruct THEN
                    -- discharge instructions
                    g_error         := g_error || ' / ' || 'DISCHARGE INSTRUCTIONS';
                    l_cancel_result := TRUE;
                
                WHEN rec.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    -- image or other exam
                    g_error := g_error || ' / ' || 'IMAGE OR OTHER EXAM';
                
                    -- check if it's possible to cancel this exam task or not
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        -- cancel exam task
                        IF NOT pk_exams_external_api_db.cancel_exam_task(i_lang           => i_lang,
                                                                         i_prof           => i_prof,
                                                                         i_task_request   => rec.id_request,
                                                                         i_reason         => i_id_cancel_reason,
                                                                         i_reason_notes   => i_cancel_notes,
                                                                         i_prof_order     => i_prof_order,
                                                                         i_dt_order       => i_dt_order,
                                                                         i_order_type     => i_order_type,
                                                                         i_transaction_id => l_transaction_id,
                                                                         o_error          => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        l_cancel_result := TRUE;
                    END IF;
                
                WHEN rec.id_task_type = g_odst_task_monitoring THEN
                    -- Monitoring
                    g_error         := g_error || ' / ' || 'MONITORING';
                    l_cancel_result := pk_monitorization.cancel_monitor_req(i_lang              => i_lang,
                                                                            i_prof              => i_prof,
                                                                            i_id_monitorization => table_number(rec.id_request),
                                                                            i_notes             => i_cancel_notes,
                                                                            i_prof_cat_type     => l_prof_cat,
                                                                            i_id_cancel_reason  => i_id_cancel_reason,
                                                                            i_prof_ordered      => i_prof_order,
                                                                            i_dt_ordered        => i_dt_order,
                                                                            i_order_type        => i_order_type,
                                                                            i_commit_data       => pk_alert_constant.g_no,
                                                                            o_error             => o_error);
                
                WHEN rec.id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    -- Hidrics
                    g_error         := g_error || ' / ' || 'HIDRICS';
                    l_cancel_result := pk_inp_hidrics_pbl.cancel_epis_hidrics(i_lang          => i_lang,
                                                                              i_prof          => i_prof,
                                                                              i_epis_hidrics  => table_number(rec.id_request),
                                                                              i_cancel_reason => i_id_cancel_reason,
                                                                              i_cancel_notes  => i_cancel_notes,
                                                                              o_error         => o_error);
                
                WHEN rec.id_task_type = g_odst_task_procedure THEN
                    -- procedimentos
                    g_error         := g_error || ' / ' || 'PROCEDURE';
                    l_cancel_result := pk_procedures_external_api_db.cancel_procedure_task(i_lang             => i_lang,
                                                                                           i_prof             => i_prof,
                                                                                           i_interv_presc_det => table_number(rec.id_request),
                                                                                           i_dt_cancel        => NULL,
                                                                                           i_cancel_reason    => i_id_cancel_reason,
                                                                                           i_cancel_notes     => i_cancel_notes,
                                                                                           i_prof_order       => i_prof_order,
                                                                                           i_dt_order         => i_dt_order,
                                                                                           i_order_type       => i_order_type,
                                                                                           o_error            => o_error);
                WHEN rec.id_task_type = g_odst_task_bp THEN
                    -- procedimentos
                    g_error         := g_error || ' / ' || 'PROCEDURE';
                    l_cancel_result := pk_bp_external_api_db.cancel_bp_task(i_lang          => i_lang,
                                                                            i_prof          => i_prof,
                                                                            i_bp_det        => table_number(rec.id_request),
                                                                            i_dt_cancel     => NULL,
                                                                            i_cancel_reason => i_id_cancel_reason,
                                                                            i_cancel_notes  => i_cancel_notes,
                                                                            i_prof_order    => i_prof_order,
                                                                            i_dt_order      => i_dt_order,
                                                                            i_order_type    => i_order_type,
                                                                            o_error         => o_error);
                WHEN rec.id_task_type = g_odst_task_patient_education THEN
                    -- patient education
                    g_error         := g_error || ' / ' || 'PATIENT EDUCATION';
                    l_cancel_result := pk_patient_education_api_db.cancel_patient_education(i_lang             => i_lang,
                                                                                            i_prof             => i_prof,
                                                                                            i_id_nurse_tea_req => table_number(rec.id_request),
                                                                                            i_id_cancel_reason => i_id_cancel_reason,
                                                                                            i_cancel_notes     => i_cancel_notes,
                                                                                            o_error            => o_error);
                
                WHEN rec.id_task_type = g_odst_task_analysis THEN
                    -- lab tests
                    g_error := g_error || ' / ' || 'LAB TEST';
                
                    -- check if it's possible to cancel this lab test task or not
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        -- cancel lab test task
                        IF NOT pk_lab_tests_external_api_db.cancel_lab_test_task(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_task_request => rec.id_request,
                                                                                 i_reason       => i_id_cancel_reason,
                                                                                 i_reason_notes => i_cancel_notes,
                                                                                 i_prof_order   => i_prof_order,
                                                                                 i_dt_order     => i_dt_order,
                                                                                 i_order_type   => i_order_type,
                                                                                 o_error        => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        l_cancel_result := TRUE;
                    END IF;
                
                WHEN rec.id_task_type = g_odst_task_medication THEN
                    -- New medication task
                    g_error := g_error || ' / ' || 'NEW MEDICATION';
                
                    -- check if it's possible to cancel this medication task or not
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        -- cancel medication task
                        IF NOT pk_api_pfh_ordertools_in.cancel_medication(i_lang          => i_lang,
                                                                          i_prof          => i_prof,
                                                                          i_patient       => i_id_patient,
                                                                          i_episode       => i_id_episode,
                                                                          i_presc         => table_number(rec.id_request),
                                                                          i_cancel_reason => table_number(i_id_cancel_reason),
                                                                          i_cancel_notes  => table_varchar(i_cancel_notes),
                                                                          i_dt_cancel     => table_timestamp_tstz(l_sysdate),
                                                                          i_prof_co_sign  => i_prof_order,
                                                                          i_order_type    => i_order_type,
                                                                          i_dt_co_sign    => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                           i_prof,
                                                                                                                           i_dt_order,
                                                                                                                           NULL),
                                                                          o_presc         => l_cancel_predefined_tasks,
                                                                          o_error         => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        l_cancel_result := TRUE;
                    END IF;
                
                WHEN rec.id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                    -- communication order
                    g_error := g_error || ' / ' || 'COMMUNICATION ORDER';
                
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        l_cancel_result := pk_comm_orders_order_sets.set_action_cancel(i_lang              => i_lang,
                                                                                       i_prof              => i_prof,
                                                                                       i_id_comm_order_req => table_number(rec.id_request),
                                                                                       i_id_episode        => i_id_episode,
                                                                                       i_id_cancel_reason  => i_id_cancel_reason,
                                                                                       i_notes_cancel      => i_cancel_notes,
                                                                                       i_dt_order          => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                            i_prof,
                                                                                                                                            i_dt_order,
                                                                                                                                            NULL),
                                                                                       i_id_prof_order     => i_prof_order,
                                                                                       i_id_order_type     => i_order_type,
                                                                                       o_error             => o_error);
                    END IF;
                
                WHEN rec.id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                    -- supplies or surgical supplies task type
                    g_error := g_error || ' / ' || 'SUPPLIES OR SURGICAL SUPPLIES';
                
                    IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                                   i_prof_id                => i_prof.id,
                                                   i_prof_inst              => i_prof.institution,
                                                   i_prof_soft              => i_prof.software,
                                                   i_episode                => i_id_episode,
                                                   i_order_set_process_task => rec.id_order_set_process_task) =
                       pk_alert_constant.g_yes
                    THEN
                        l_cancel_result := pk_supplies_order_sets.set_action_cancel(i_lang             => i_lang,
                                                                                    i_prof             => i_prof,
                                                                                    i_supply_workflow  => table_number(rec.id_request),
                                                                                    i_id_episode       => i_id_episode,
                                                                                    i_id_cancel_reason => i_id_cancel_reason,
                                                                                    i_cancel_notes     => i_cancel_notes,
                                                                                    o_error            => o_error);
                    END IF;
                ELSE
                    l_cancel_result := FALSE;
                    g_error         := g_error || ' / ' || 'UNKNOWN ORDER SET TASK TYPE';
            END CASE;
        
            -- exit loop when an error occurs
            IF (l_cancel_result = FALSE)
            THEN
                RAISE error_unexpected;
            END IF;
        
            -- the order set task is updated only if effectively, the api has successfully canceled the associated task.
            IF l_task_cancelled = TRUE
            THEN
                -- this validates tasks that its status does not allow a cancellation, such as a prescription for the outside 
                -- pharmacy already printed. thus, in case of try to cancel an entire order-set where there are tasks in this
                -- condition the order-set will marked as "interrupted"(also know as "discontinued") instead of "cancelled".
            
                -- update order set process task status
                UPDATE order_set_process_task
                   SET flg_status      = g_order_set_proc_tsk_canceled,
                       dt_status_tstz  = l_sysdate,
                       id_professional = i_prof.id
                 WHERE id_order_set_process_task = rec.id_order_set_process_task;
            END IF;
        END LOOP;
    
        IF i_transaction_id IS NULL
        THEN
            pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- external unexpected error
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ODST_PROC_TASKS_INTERN',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
            -- internal unexpected error            
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ODST_PROC_TASKS_INTERN',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            RETURN FALSE;
    END cancel_odst_proc_tasks_intern;

    FUNCTION cancel_order_set_proc_tasks
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_patient       IN patient.id_patient%TYPE,
        i_id_episode       IN episode.id_episode%TYPE,
        i_id_proc_tasks    IN table_number,
        i_id_cancel_reason IN cancel_reason.id_cancel_reason%TYPE,
        i_cancel_notes     IN VARCHAR2,
        i_prof_order       IN order_set_process.id_prof_order%TYPE,
        i_dt_order         IN VARCHAR2,
        i_order_type       IN order_set_process.id_order_type%TYPE,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    
        error_unexpected EXCEPTION;
    
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        -- cancel order set process tasks
        g_error := 'CALL FUNCTION TO CANCEL ORDER SET PROCESS TASKS';
        IF NOT cancel_odst_proc_tasks_intern(i_lang,
                                             i_prof,
                                             i_id_patient,
                                             i_id_episode,
                                             i_id_proc_tasks,
                                             i_id_cancel_reason,
                                             i_cancel_notes,
                                             i_prof_order,
                                             i_dt_order,
                                             i_order_type,
                                             l_transaction_id,
                                             o_error)
        THEN
            RAISE error_unexpected;
        END IF;
    
        g_error := 'REFRESH ORDER SET PROCESSES STATUS';
        -- refresh order set processes status
        IF NOT refresh_odst_procs_status(i_lang, i_prof, i_id_patient, i_id_episode, g_no, o_error)
        THEN
            RAISE error_unexpected;
        END IF;
    
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- external unexpected error
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET_PROC_TASKS',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- internal unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET_PROC_TASKS',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_order_set_proc_tasks;

    FUNCTION request_order_set_proc_tasks
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_patient               IN patient.id_patient%TYPE,
        i_id_episode               IN episode.id_episode%TYPE,
        i_id_order_set_process     IN order_set_process.id_order_set_process%TYPE,
        i_id_proc_tasks            IN table_number,
        i_clinical_question_ospt   IN table_number,
        i_clinical_question_id     IN table_table_number,
        i_clinical_question_answer IN table_table_varchar,
        i_clinical_question_notes  IN table_table_varchar,
        i_cdr_call                 IN cdr_call.id_cdr_call%TYPE,
        i_transaction_id           IN VARCHAR2, -- TODO: check if this is needed in all order requests
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- auxiliary local variables
        ibt_i_flg_time             table_varchar;
        ibtt_i_diagnosis           table_table_number;
        ibt_nurse_tea_req          table_number;
        ibt_description            table_clob;
        l_o_id_nurse_tea_topic     table_number;
        l_o_title_topic            table_varchar;
        l_o_desc_diagnosis         table_varchar;
        ibt_id_nurse_tea_req_sugg  table_number;
        ibt_desc_topic_aux         table_varchar;
        ibt_presc_id               table_number;
        ibt_dt_begin               table_varchar;
        ibt_notes                  table_varchar;
        ibt_order_recurrence       table_number;
        l_follow_up_in             VARCHAR2(30 CHAR);
        l_id_follow_up_type        NUMBER;
        l_tbl_follow_up_in         table_varchar;
        l_tbl_id_follow_up_type    table_number;
        l_flg_follow_up_type       follow_up_entity.flg_type%TYPE;
        l_follow_up_type_desc      pk_translation.t_desc_translation;
        l_follow_up_type_unit_mea  pk_translation.t_desc_translation;
        l_flg_time                 VARCHAR2(1 CHAR);
        l_interval                 VARCHAR2(30 CHAR);
        l_clinical_question_id     table_table_number;
        l_clinical_question_answer table_table_varchar;
        l_clinical_question_notes  table_table_varchar;
        l_clinical_question_index  NUMBER;
        l_id_discharge_note        discharge_notes.id_discharge_notes%TYPE;
        l_reports_pat              reports.id_reports%TYPE;
        l_monit_unit_measure       order_set_process_task_det.id_unit_measure%TYPE;
    
        l_diet_id_diet              diet_prof_instit.id_diet_prof_instit%TYPE;
        l_diet_desc                 diet_prof_instit.desc_diet%TYPE;
        l_diet_food_plan            diet_prof_instit.food_plan%TYPE;
        l_diet_notes                diet_prof_instit.notes%TYPE;
        l_o_diet                    pk_types.cursor_type;
        l_o_diet_schedule           pk_types.cursor_type;
        l_o_diet_food               pk_types.cursor_type;
        ibt_i_diet_id_diet_schedule table_number;
        ibt_i_diet_id_diet          table_number;
        ibt_i_diet_quantity         table_number;
        ibt_i_diet_id_unit          table_number;
        ibt_i_diet_notes_diet       table_varchar;
        ibt_i_diet_dt_hour          table_varchar;
        ibt_i_diet_sched_id         table_number;
        ibt_i_diet_sched_hour       table_varchar;
    
        l_dummy_vc       VARCHAR2(4000);
        l_dummy_array_nr table_number;
        l_dummy_array_vc table_varchar;
    
        l_prof_id             NUMBER;
        l_prof_name_free_text VARCHAR2(200);
    
        l_id_req                   NUMBER;
        ibt_req_det                table_number;
        ibt_id_odst_proc_task      table_number;
        ibt_temp_req               table_number;
        ibt_temp_req_det_array     table_table_number;
        ibt_temp_id_odst_proc_task table_number;
    
        ibt_nvalues table_number;
        ibt_vvalues table_varchar;
        ibt_dvalues table_varchar;
    
        l_counter        PLS_INTEGER;
        l_request_result BOOLEAN;
        l_prof_cat       category.flg_type%TYPE := pk_prof_utils.get_category(i_lang, i_prof);
        l_sysdate        TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_cosign_dt_order_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        l_cosign_dt_order      VARCHAR2(200);
        l_cosign_id_prof_order order_set_process.id_prof_order%TYPE;
        l_cosign_id_order_type order_set_process.id_order_type%TYPE;
    
        l_final_cosign_dt_order_tstz TIMESTAMP WITH LOCAL TIME ZONE;
        l_final_cosign_dt_order      VARCHAR2(200);
        l_final_cosign_id_prof_order order_set_process.id_prof_order%TYPE;
        l_final_cosign_id_order_type order_set_process.id_order_type%TYPE;
    
        l_cosign_dt_order_array      table_varchar;
        l_cosign_id_order_type_array table_number;
        l_cosign_id_prof_order_array table_number;
    
        l_msg_warning VARCHAR2(1000 CHAR);
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
        ibt_task_dependency     table_number;
        ibt_flg_start_depending table_varchar;
    
        -- cursor with all tasks, except episodes
        CURSOR c_proc_tasks_types IS
            SELECT DISTINCT odst_proc_tsk.id_task_type
              FROM order_set_process_task odst_proc_tsk
             INNER JOIN task_type tsk_type
                ON odst_proc_tsk.id_task_type = tsk_type.id_task_type
             WHERE odst_proc_tsk.flg_status = g_order_set_proc_tsk_temp
               AND odst_proc_tsk.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tsk rows=1)*/
                     tsk.column_value
                      FROM TABLE(i_id_proc_tasks) tsk)
                  -- ignore episode tasks
               AND tsk_type.flg_episode_task != pk_alert_constant.g_tt_tde_support_epis;
    
        -- cursor with all episodes
        CURSOR c_proc_episodes IS
            SELECT odst_proc_tsk.id_order_set_process_task, odst_proc_tsk.id_request id_episode
              FROM order_set_process_task odst_proc_tsk
              JOIN task_type tsk_type
                ON odst_proc_tsk.id_task_type = tsk_type.id_task_type
             WHERE odst_proc_tsk.flg_status = g_order_set_proc_tsk_temp
               AND odst_proc_tsk.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tsk rows=1)*/
                     tsk.column_value
                      FROM TABLE(i_id_proc_tasks) tsk)
                  -- consider only episode tasks
               AND tsk_type.flg_episode_task = pk_alert_constant.g_tt_tde_support_epis;
    
        -- cursor with all tasks and episodes
        CURSOR c_proc_tasks(in_id_task_type order_set_process_task.id_task_type%TYPE) IS
            SELECT odst_proc_tsk.id_order_set_process_task
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.flg_status = g_order_set_proc_tsk_temp
               AND odst_proc_tsk.id_task_type = in_id_task_type
               AND odst_proc_tsk.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tsk rows=1)*/
                     tsk.column_value
                      FROM TABLE(i_id_proc_tasks) tsk);
    
        CURSOR c_proc_tasks_links(in_id_task_type order_set_process_task.id_task_type%TYPE) IS
            SELECT ospt.id_order_set_process_task, odst_proc_tsk_lnk.id_task_link
              FROM order_set_process_task_link odst_proc_tsk_lnk
              JOIN order_set_process_task ospt
                ON ospt.id_order_set_process_task = odst_proc_tsk_lnk.id_order_set_process_task
             WHERE ospt.id_task_type = in_id_task_type
               AND ospt.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tsk rows=1)*/
                     tsk.column_value
                      FROM TABLE(i_id_proc_tasks) tsk);
    
        error_unexpected EXCEPTION;
    
        -- table of objects to contain task and dependencies information
        l_tskd t_tbl_odst_dependency;
    
        -- dependency
        l_dependency tde_task_dependency.id_task_dependency%TYPE;
    
        -- replicate order set process task records for new req dets
        PROCEDURE replicate_order_set_proc_tasks
        (
            in_order_set_proc_task      IN order_set_process_task.id_order_set_process_task%TYPE,
            in_new_req_det              IN table_number,
            inout_ibt_id_odst_proc_task IN OUT table_number,
            inout_ibt_req_det           IN OUT table_number
        ) IS
            TYPE t_order_set_proc_task IS TABLE OF order_set_process_task%ROWTYPE INDEX BY PLS_INTEGER;
            ibt_order_set_proc_task     t_order_set_proc_task;
            l_order_order_proc_task     order_set_process_task%ROWTYPE;
            l_count_new_odst_proc_tasks NUMBER;
            l_count_odst_proc_tasks     NUMBER;
        BEGIN
            -- get data of the existing order process task record
            SELECT id_order_set_process,
                   id_task_type,
                   flg_status,
                   dt_status_tstz,
                   id_request,
                   dt_request_tstz,
                   id_professional,
                   flg_schedule,
                   flg_order_set_task,
                   flg_discard_type
              INTO l_order_order_proc_task.id_order_set_process,
                   l_order_order_proc_task.id_task_type,
                   l_order_order_proc_task.flg_status,
                   l_order_order_proc_task.dt_status_tstz,
                   l_order_order_proc_task.id_request,
                   l_order_order_proc_task.dt_request_tstz,
                   l_order_order_proc_task.id_professional,
                   l_order_order_proc_task.flg_schedule,
                   l_order_order_proc_task.flg_order_set_task,
                   l_order_order_proc_task.flg_discard_type
              FROM order_set_process_task ospt
             WHERE ospt.id_order_set_process_task = in_order_set_proc_task;
        
            -- add new req dets to the collection
            l_count_odst_proc_tasks     := inout_ibt_id_odst_proc_task.count + 1;
            l_count_new_odst_proc_tasks := ibt_order_set_proc_task.count + 1;
        
            -- loop all req dets
            FOR i IN 1 .. in_new_req_det.count
            LOOP
                -- check if it's the first req det or not
                IF (i = 1)
                THEN
                    -- use existing order set process task record to store the first req det 
                    inout_ibt_id_odst_proc_task.extend;
                    inout_ibt_id_odst_proc_task(l_count_odst_proc_tasks) := in_order_set_proc_task;
                ELSE
                    -- create order set process task records for the remaining req dets
                    inout_ibt_id_odst_proc_task.extend;
                    inout_ibt_id_odst_proc_task(l_count_odst_proc_tasks) := seq_order_set_process_task.nextval;
                
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).id_order_set_process_task := inout_ibt_id_odst_proc_task(l_count_odst_proc_tasks);
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).id_order_set_process := l_order_order_proc_task.id_order_set_process;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).id_task_type := l_order_order_proc_task.id_task_type;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).flg_status := l_order_order_proc_task.flg_status;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).dt_status_tstz := l_order_order_proc_task.dt_status_tstz;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).id_request := l_order_order_proc_task.id_request;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).dt_request_tstz := l_order_order_proc_task.dt_request_tstz;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).id_professional := l_order_order_proc_task.id_professional;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).flg_schedule := l_order_order_proc_task.flg_schedule;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).flg_order_set_task := l_order_order_proc_task.flg_order_set_task;
                    ibt_order_set_proc_task(l_count_new_odst_proc_tasks).flg_discard_type := l_order_order_proc_task.flg_discard_type;
                
                    l_count_new_odst_proc_tasks := l_count_new_odst_proc_tasks + 1;
                
                END IF;
            
                inout_ibt_req_det.extend;
                inout_ibt_req_det(l_count_odst_proc_tasks) := in_new_req_det(i);
            
                l_count_odst_proc_tasks := l_count_odst_proc_tasks + 1;
            END LOOP;
        
            --  replicate order set process tasks
            FORALL i IN 1 .. ibt_order_set_proc_task.count
                INSERT INTO order_set_process_task
                VALUES ibt_order_set_proc_task
                    (i); -- replicate n - 1 records (n = number of req dets and 1 is the original record)
        
            -- replicate order set process task links                        
            FORALL i IN 1 .. ibt_order_set_proc_task.count
                INSERT INTO order_set_process_task_link
                    (id_order_set_process_task, flg_task_link_type, id_task_link)
                    SELECT ibt_order_set_proc_task(i).id_order_set_process_task id_order_set_process_task,
                           flg_task_link_type,
                           id_task_link
                      FROM order_set_process_task_link osptl
                     WHERE osptl.id_order_set_process_task = in_order_set_proc_task;
        END replicate_order_set_proc_tasks;
    
        -- get default room of a given lab test
        FUNCTION get_default_lab_test_room(in_analysis IN analysis.id_analysis%TYPE) RETURN analysis_room.id_room%TYPE IS
        
            CURSOR c_lab_room IS
                SELECT ar.id_room
                  FROM analysis_room ar, room r, department d
                 WHERE ar.id_analysis = in_analysis
                   AND ar.flg_type = pk_lab_tests_constant.g_arm_flg_type_room_pat
                   AND ar.id_institution = i_prof.institution
                   AND ar.flg_available = pk_lab_tests_constant.g_available
                   AND ar.id_room = r.id_room
                   AND r.id_department = d.id_department
                   AND d.id_institution = i_prof.institution
                 ORDER BY ar.flg_default DESC;
        
            l_room  analysis_room.id_room%TYPE;
            l_found BOOLEAN;
        
        BEGIN
        
            OPEN c_lab_room;
            FETCH c_lab_room
                INTO l_room;
            l_found := c_lab_room%FOUND;
            CLOSE c_lab_room;
        
            IF l_found
            THEN
                RETURN l_room;
            ELSE
                RETURN NULL;
            END IF;
        
        END get_default_lab_test_room;
    
        -- get all order set tasks and links from a task group
        PROCEDURE get_tasks_from_group
        (
            in_group                    IN order_set_process_task_link.id_task_link%TYPE,
            in_task_type                IN task_type.id_task_type%TYPE,
            out_id_order_set_proc_tasks OUT table_number,
            out_id_tasks_links          OUT table_number
        ) IS
        BEGIN
        
            SELECT ospt.id_order_set_process_task,
                   get_odst_proc_task_link(ospt.id_order_set_process_task,
                                           get_odst_proc_task_link_type(ospt.id_order_set_process_task))
              BULK COLLECT
              INTO out_id_order_set_proc_tasks, out_id_tasks_links
              FROM order_set_process_task ospt
              JOIN order_set_process_task_link osptl
                ON ospt.id_order_set_process_task = osptl.id_order_set_process_task
             WHERE osptl.flg_task_link_type = pk_order_sets.g_task_link_group
               AND osptl.id_task_link = in_group
               AND ospt.id_task_type = in_task_type
               AND ospt.id_order_set_process = i_id_order_set_process;
        
        END get_tasks_from_group;
    
        -- procedure to create task dependency information to synchronize with TDE
        PROCEDURE create_task_dependency_info(o_dtbl OUT t_tbl_odst_dependency) IS
        
            -- cursor for dependency information extraction
            CURSOR c_task_dependencies IS
                SELECT ospt.id_order_set_process_task,
                       nvl2(depend.id_order_set_process_task, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_create_dependency,
                       ospt.id_task_type,
                       decode(ospt.id_order_set_process_task,
                              to_number(g_depend_current_epis),
                              i_id_episode,
                              ospt.id_request) id_request,
                       ospt.flg_schedule,
                       -- start depending is only active if is not a schedulable task and if is waiting for other tasks
                       decode(ospt.flg_schedule,
                              pk_alert_constant.g_yes,
                              pk_alert_constant.g_no,
                              (SELECT decode(COUNT(1), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes)
                                 FROM dual
                                WHERE EXISTS (SELECT 1
                                         FROM order_set_process_task_depend
                                        WHERE id_relationship_type = pk_alert_constant.g_tde_rel_finish2start
                                          AND id_order_set_proc_task_to = ospt.id_order_set_process_task))) flg_start_depending
                  FROM order_set_process_task ospt
                  LEFT JOIN (SELECT id_order_set_proc_task_from id_order_set_process_task
                               FROM order_set_process_task_depend
                              WHERE id_order_set_process = i_id_order_set_process
                             UNION
                             SELECT id_order_set_proc_task_to id_order_set_process_task
                               FROM order_set_process_task_depend
                              WHERE id_order_set_process = i_id_order_set_process) depend
                    ON depend.id_order_set_process_task = ospt.id_order_set_process_task
                 WHERE ospt.flg_status = g_order_set_proc_tsk_temp
                   AND ospt.id_order_set_process = i_id_order_set_process
                   AND ospt.id_order_set_process_task IN
                       (SELECT /*+opt_estimate(table tsk rows=1)*/
                         tsk.column_value
                          FROM TABLE(i_id_proc_tasks) tsk);
        
            -- record for task dependency information
            l_rec t_rec_odst_dependency := t_rec_odst_dependency(NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        
            -- current episode needs an associated dependency?
            l_curr_epis_dependency VARCHAR2(1 CHAR);
        
        BEGIN
            -- init table of task dependencies information
            o_dtbl := t_tbl_odst_dependency();
        
            -- process all tasks and their dependency (if available)
            FOR rec IN c_task_dependencies
            LOOP
                l_rec.id_order_set_process_task := rec.id_order_set_process_task;
                l_rec.id_task_type              := rec.id_task_type;
                l_rec.id_request                := rec.id_request;
                l_rec.flg_create_dependency     := rec.flg_create_dependency;
                l_rec.flg_schedule              := rec.flg_schedule;
                l_rec.flg_start_depending       := rec.flg_start_depending;
            
                -- if task has dependencies, then create the dependency id
                IF rec.flg_create_dependency = pk_alert_constant.g_yes
                THEN
                    IF NOT pk_tde_db.create_dependency(i_lang          => i_lang,
                                                       i_task_type     => l_rec.id_task_type,
                                                       i_task_request  => l_rec.id_request,
                                                       i_task_state    => CASE l_rec.flg_start_depending
                                                                              WHEN pk_alert_constant.g_no THEN
                                                                               pk_alert_constant.g_tde_task_state_requested
                                                                              ELSE
                                                                               pk_alert_constant.g_tde_task_state_start_depend
                                                                          END,
                                                       i_task_schedule => l_rec.flg_schedule,
                                                       -- created id_task_dependency is stored in task record
                                                       o_task_dependency => l_rec.id_task_dependency,
                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_tde_db.create_dependency function';
                        RAISE error_unexpected;
                    END IF;
                END IF;
            
                -- add record to the collection
                o_dtbl.extend;
                o_dtbl(o_dtbl.count) := l_rec;
            
            END LOOP;
        
            -- check if current episode dependency is needed
            SELECT decode(COUNT(1), 0, pk_alert_constant.g_no, pk_alert_constant.g_yes)
              INTO l_curr_epis_dependency
              FROM dual
             WHERE EXISTS
             (SELECT 1
                      FROM order_set_process_task_depend
                     WHERE id_order_set_process = i_id_order_set_process
                       AND id_order_set_proc_task_from = to_number(g_depend_current_epis)
                       AND id_order_set_proc_task_to IN (SELECT /*+opt_estimate(table tsk rows=1)*/
                                                          tsk.column_value
                                                           FROM TABLE(i_id_proc_tasks) tsk));
        
            -- create current episode dependency if needed    
            IF l_curr_epis_dependency = pk_alert_constant.g_yes
            THEN
                l_rec.id_order_set_process_task := to_number(g_depend_current_epis);
                l_rec.id_task_type              := pk_alert_constant.g_task_current_epis;
                l_rec.id_request                := i_id_episode;
                l_rec.flg_create_dependency     := pk_alert_constant.g_yes;
                l_rec.flg_schedule              := pk_alert_constant.g_yes;
                l_rec.flg_start_depending       := pk_alert_constant.g_no;
            
                IF NOT pk_tde_db.create_dependency(i_lang          => i_lang,
                                                   i_task_type     => l_rec.id_task_type,
                                                   i_task_request  => l_rec.id_request,
                                                   i_task_state    => pk_alert_constant.g_tde_task_state_requested,
                                                   i_task_schedule => l_rec.flg_schedule,
                                                   -- created id_task_dependency is stored in task record
                                                   o_task_dependency => l_rec.id_task_dependency,
                                                   o_error           => o_error)
                THEN
                    g_error := 'error found while calling pk_tde_db.create_dependency function for current episode';
                    RAISE error_unexpected;
                END IF;
            
                -- add record to the collection
                o_dtbl.extend;
                o_dtbl(o_dtbl.count) := l_rec;
            
            END IF;
        
        END create_task_dependency_info;
    
        -- procedure to set task dependency id and starting mode from dependency network collection, for a given task
        PROCEDURE set_task_dependency
        (
            i_odst_process_task   IN order_set_process_task.id_order_set_process_task%TYPE,
            i_dtbl                IN t_tbl_odst_dependency,
            o_task_dependency     OUT tde_task_dependency.id_task_dependency%TYPE,
            o_flg_start_depending OUT VARCHAR2
        ) IS
        
        BEGIN
        
            SELECT depend.id_task_dependency, depend.flg_start_depending
              INTO o_task_dependency, o_flg_start_depending
              FROM TABLE(CAST(i_dtbl AS t_tbl_odst_dependency)) depend
             WHERE depend.id_order_set_process_task = i_odst_process_task;
        
        EXCEPTION
            WHEN no_data_found THEN
                o_task_dependency     := NULL;
                o_flg_start_depending := pk_alert_constant.g_no;
        END set_task_dependency;
    
        -- get order set task dependency id 
        FUNCTION get_task_dependency
        (
            i_odst_process_task IN order_set_process_task.id_order_set_process_task%TYPE,
            i_dtbl              IN t_tbl_odst_dependency
        ) RETURN tde_task_dependency.id_task_dependency%TYPE IS
        
            l_dependency tde_task_dependency.id_task_dependency%TYPE;
        
        BEGIN
        
            SELECT depend.id_task_dependency
              INTO l_dependency
              FROM TABLE(CAST(i_dtbl AS t_tbl_odst_dependency)) depend
             WHERE depend.id_order_set_process_task = i_odst_process_task;
        
            RETURN l_dependency;
        
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END get_task_dependency;
    
        -- procedure to create task relationships between dependencies, with TDE synchronization
        PROCEDURE create_task_dependency_rels(i_dtbl IN t_tbl_odst_dependency) IS
        
            -- cursor for dependency relationships extraction
            CURSOR c_task_dependency_rels IS
                SELECT id_relationship_type,
                       id_order_set_proc_task_from,
                       id_order_set_proc_task_to,
                       lag_min,
                       lag_max,
                       id_unit_measure_lag
                  FROM order_set_process_task_depend
                 WHERE id_order_set_process = i_id_order_set_process
                   AND (id_order_set_proc_task_from IN (SELECT /*+opt_estimate(table tsk1 rows=1)*/
                                                         tsk1.column_value
                                                          FROM TABLE(i_id_proc_tasks) tsk1
                                                        UNION ALL
                                                        SELECT to_number(g_depend_current_epis)
                                                          FROM dual
                                                        UNION ALL
                                                        SELECT to_number(g_depend_future_epis)
                                                          FROM dual) AND
                       id_order_set_proc_task_to IN (SELECT /*+opt_estimate(table tsk2 rows=1)*/
                                                       tsk2.column_value
                                                        FROM TABLE(i_id_proc_tasks) tsk2));
        
        BEGIN
        
            FOR rec IN c_task_dependency_rels
            LOOP
                IF NOT pk_tde_db.create_dependency_relationship(i_lang                 => i_lang,
                                                                i_relationship_type    => rec.id_relationship_type,
                                                                i_task_dependency_from => get_task_dependency(rec.id_order_set_proc_task_from,
                                                                                                              i_dtbl),
                                                                i_task_dependency_to   => get_task_dependency(rec.id_order_set_proc_task_to,
                                                                                                              i_dtbl),
                                                                i_lag_min              => rec.lag_min,
                                                                i_lag_max              => rec.lag_max,
                                                                i_unit_measure_lag     => rec.id_unit_measure_lag,
                                                                o_error                => o_error)
                THEN
                    g_error := 'error found while calling pk_tde_db.create_dependency_relationship function';
                    RAISE error_unexpected;
                END IF;
            END LOOP;
        
        END create_task_dependency_rels;
    
        -- get episode destination of an order set process task
        FUNCTION get_task_episode_destination(i_id_odst_proc_task IN order_set_process_task.id_order_set_process_task%TYPE)
            RETURN VARCHAR2 IS
        
            l_include_episode order_set_process_task_depend.id_order_set_proc_task_from%TYPE;
            l_flg_schedule    order_set_process_task.flg_schedule%TYPE;
            l_episode_req     order_set_process_task.id_request%TYPE;
        
        BEGIN
        
            -- get flag schedule 
            SELECT odst_proc_tsk.flg_schedule
              INTO l_flg_schedule
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.id_order_set_process_task = i_id_odst_proc_task;
        
            -- if the task is for schedule, flag time value is "to be defined"
            IF l_flg_schedule = pk_alert_constant.g_yes
            THEN
                RETURN NULL;
            END IF;
        
            -- get episode in which the task is included
            BEGIN
                SELECT odst_proc_tsk_dep.id_order_set_proc_task_from, odst_proc_tsk.id_request
                  INTO l_include_episode, l_episode_req
                  FROM order_set_process_task_depend odst_proc_tsk_dep
                  LEFT OUTER JOIN order_set_process_task odst_proc_tsk
                    ON odst_proc_tsk_dep.id_order_set_proc_task_from = odst_proc_tsk.id_order_set_process_task
                 WHERE odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start
                   AND odst_proc_tsk_dep.id_order_set_proc_task_to = i_id_odst_proc_task;
            EXCEPTION
                WHEN no_data_found THEN
                    l_include_episode := to_number(g_depend_current_epis);
            END;
        
            -- verify if the task will be executed in the current or in a future episode
            IF l_include_episode = to_number(g_depend_current_epis)
            THEN
                RETURN i_id_episode;
            ELSE
                RETURN l_episode_req;
            END IF;
        
        END get_task_episode_destination;
    
        -- gets the index number in the array i_clinical_question_ospt for the given i_order_set_process_task value
        FUNCTION get_clinical_question_index(i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE)
            RETURN PLS_INTEGER IS
        
            l_index PLS_INTEGER := 0;
        
        BEGIN
        
            IF i_clinical_question_ospt IS NOT NULL
            THEN
                FOR i IN 1 .. i_clinical_question_ospt.count
                LOOP
                    IF i_clinical_question_ospt(i) = i_order_set_process_task
                    THEN
                        l_index := i;
                        EXIT; -- exit for loop
                    END IF;
                END LOOP;
            END IF;
            RETURN l_index; -- zero if no index was found, >0 for existing indexes
        
        END get_clinical_question_index;
    
    BEGIN
        -- this procedure will also create the necessary id_task_dependency value to use in task requests
        g_error := 'create task dependencies';
        create_task_dependency_info(l_tskd);
    
        -- create task dependency relationships
        g_error := 'create task dependency relationships';
        create_task_dependency_rels(l_tskd);
    
        g_error := 'GET ORDER SET PROCESS CO-SIGN AND DIAGNOSES INFO ';
        SELECT odst_proc.dt_order dt_order_tstz,
               pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_order, i_prof) dt_order,
               odst_proc.id_prof_order,
               odst_proc.id_order_type,
               odst_proc.clinical_indications
          INTO l_cosign_dt_order_tstz,
               l_cosign_dt_order,
               l_cosign_id_prof_order,
               l_cosign_id_order_type,
               l_clinical_indications
          FROM order_set_process odst_proc
         WHERE odst_proc.id_order_set_process = i_id_order_set_process;
    
        -- if the order set already has diagnoses
        IF l_clinical_indications IS NOT NULL
        THEN
            -- get diagnosis records
        
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                         i_prof   => i_prof,
                                                         i_params => l_clinical_indications);
        
            l_rec_diagnoses.id_patient := i_id_patient;
            l_rec_diagnoses.id_episode := i_id_episode;
        END IF;
    
        g_error := 'REQUEST ORDER SET PROCESS TASKS';
        -- loop for each task_type
        FOR rec_tsk_type IN c_proc_tasks_types
        LOOP
        
            CASE rec_tsk_type.id_task_type
            -- << Follow-up appointment >>
                WHEN g_odst_task_followup_appoint THEN
                    g_error := g_error || ' / ' || 'FOLLOW-UP APPOINTMENT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each follow-up appointment task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        l_request_result := pk_consult_req.set_consult_req(i_lang             => i_lang,
                                                                           i_episode          => i_id_episode,
                                                                           i_prof_req         => i_prof,
                                                                           i_pat              => i_id_patient,
                                                                           i_instit_requests  => NULL,
                                                                           i_instit_requested => NULL,
                                                                           i_consult_type     => NULL,
                                                                           i_clinical_service => NULL,
                                                                           i_dt_scheduled_str => get_odst_proc_task_det_val(i_lang,
                                                                                                                            i_prof,
                                                                                                                            rec_tsk.id_order_set_process_task,
                                                                                                                            'A',
                                                                                                                            NULL,
                                                                                                                            101,
                                                                                                                            NULL),
                                                                           i_flg_type_date    => 'D',
                                                                           i_notes            => get_odst_proc_task_det_val(i_lang,
                                                                                                                            i_prof,
                                                                                                                            rec_tsk.id_order_set_process_task,
                                                                                                                            'R',
                                                                                                                            NULL,
                                                                                                                            NULL,
                                                                                                                            NULL),
                                                                           i_dep_clin_serv    => NULL,
                                                                           i_prof_requested   => i_prof.id,
                                                                           i_prof_cat_type    => l_prof_cat,
                                                                           i_id_complaint     => NULL,
                                                                           i_commit_data      => g_no,
                                                                           i_flg_type         => pk_consult_req.g_flg_type_subsequent,
                                                                           o_consult_req      => l_id_req,
                                                                           o_error            => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- get request ID
                        ibt_req_det(l_counter) := l_id_req;
                    
                    END LOOP;
                
            -- << Specialty appointment >>
                WHEN g_odst_task_specialty_appoint THEN
                    g_error := g_error || ' / ' || 'SPECIALTY APPOINTMENT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each specialty appointment task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        l_request_result := pk_consult_req.set_consult_req(i_lang             => i_lang,
                                                                           i_episode          => i_id_episode,
                                                                           i_prof_req         => i_prof,
                                                                           i_pat              => i_id_patient,
                                                                           i_instit_requests  => NULL,
                                                                           i_instit_requested => NULL,
                                                                           i_consult_type     => NULL,
                                                                           i_clinical_service => NULL,
                                                                           i_dt_scheduled_str => NULL,
                                                                           i_flg_type_date    => NULL,
                                                                           i_notes            => get_odst_proc_task_det_val(i_lang,
                                                                                                                            i_prof,
                                                                                                                            rec_tsk.id_order_set_process_task,
                                                                                                                            'R',
                                                                                                                            NULL,
                                                                                                                            NULL,
                                                                                                                            NULL),
                                                                           i_dep_clin_serv    => get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                                                                         g_task_link_null),
                                                                           i_prof_requested   => get_odst_proc_task_det_val(i_lang,
                                                                                                                            i_prof,
                                                                                                                            rec_tsk.id_order_set_process_task,
                                                                                                                            'P',
                                                                                                                            NULL,
                                                                                                                            NULL,
                                                                                                                            NULL),
                                                                           i_prof_cat_type    => l_prof_cat,
                                                                           i_id_complaint     => NULL,
                                                                           i_commit_data      => g_no,
                                                                           i_flg_type         => pk_consult_req.g_flg_type_speciality,
                                                                           o_consult_req      => l_id_req,
                                                                           o_error            => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- get request ID
                        ibt_req_det(l_counter) := l_id_req;
                    
                    END LOOP;
                
            -- << predefined diet prescriptions >>
                WHEN g_odst_task_predef_diet THEN
                    g_error := g_error || ' / ' || 'PREDEFINED DIET PRESCRIPTIONS';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each specialty appointment task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        -- get predefined diet details to use in create_diet                                              
                        l_request_result := pk_diet.get_diet(i_lang          => i_lang,
                                                             i_prof          => i_prof,
                                                             i_type_diet     => pk_diet.g_diet_type_defi,
                                                             i_id_patient    => NULL,
                                                             i_id_diet       => get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                                                        g_task_link_null),
                                                             o_diet          => l_o_diet,
                                                             o_diet_schedule => l_o_diet_schedule,
                                                             o_diet_food     => l_o_diet_food,
                                                             o_error         => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- OPEN l_o_diet; (already opened by pk_diet.get_diet)
                        FETCH l_o_diet
                            INTO l_diet_id_diet,
                                 l_diet_desc,
                                 l_dummy_vc,
                                 l_dummy_vc,
                                 l_diet_food_plan,
                                 l_dummy_vc,
                                 l_dummy_vc,
                                 l_diet_notes,
                                 l_dummy_vc,
                                 l_dummy_vc,
                                 l_dummy_vc,
                                 l_dummy_vc;
                        CLOSE l_o_diet;
                    
                        -- OPEN l_o_diet_schedule; (already opened by pk_diet.get_diet)
                        FETCH l_o_diet_schedule BULK COLLECT
                            INTO ibt_i_diet_sched_id, l_dummy_array_nr, ibt_i_diet_sched_hour;
                        CLOSE l_o_diet_schedule;
                    
                        -- OPEN l_o_diet_food; (already opened by pk_diet.get_diet)
                        FETCH l_o_diet_food BULK COLLECT
                            INTO ibt_i_diet_id_diet_schedule,
                                 l_dummy_array_nr,
                                 ibt_i_diet_id_diet,
                                 l_dummy_array_nr,
                                 l_dummy_array_vc,
                                 ibt_i_diet_notes_diet,
                                 ibt_i_diet_quantity,
                                 l_dummy_array_vc,
                                 ibt_i_diet_id_unit,
                                 l_dummy_array_nr,
                                 l_dummy_array_nr,
                                 l_dummy_array_vc,
                                 l_dummy_array_nr,
                                 l_dummy_array_vc,
                                 l_dummy_array_nr;
                        CLOSE l_o_diet_food;
                    
                        -- fill ibt_i_diet_dt_hour array
                        ibt_i_diet_dt_hour := table_varchar();
                        IF ibt_i_diet_id_diet_schedule.count > 0
                        THEN
                            FOR i1 IN ibt_i_diet_id_diet_schedule.first .. ibt_i_diet_id_diet_schedule.last
                            LOOP
                                ibt_i_diet_dt_hour.extend();
                                IF ibt_i_diet_sched_id.count > 0
                                THEN
                                    FOR i2 IN ibt_i_diet_sched_id.first .. ibt_i_diet_sched_id.last
                                    LOOP
                                        IF ibt_i_diet_sched_id(i2) = ibt_i_diet_id_diet_schedule(i1)
                                        THEN
                                            ibt_i_diet_dt_hour(i1) := ibt_i_diet_sched_hour(i2);
                                        END IF;
                                    END LOOP;
                                END IF;
                            END LOOP;
                        END IF;
                    
                        -- associate diet to patient
                        l_request_result := pk_diet.create_diet(i_lang         => i_lang,
                                                                i_prof         => i_prof,
                                                                i_patient      => i_id_patient,
                                                                i_episode      => i_id_episode,
                                                                i_id_epis_diet => NULL,
                                                                i_id_diet_type => pk_diet.g_diet_type_defi,
                                                                i_desc_diet    => l_diet_desc,
                                                                -- get start date
                                                                i_dt_begin_str => get_odst_proc_task_det_val(i_lang,
                                                                                                             i_prof,
                                                                                                             rec_tsk.id_order_set_process_task,
                                                                                                             'A',
                                                                                                             NULL,
                                                                                                             136,
                                                                                                             NULL),
                                                                -- get end date                               
                                                                i_dt_end_str => get_odst_proc_task_det_val(i_lang,
                                                                                                           i_prof,
                                                                                                           rec_tsk.id_order_set_process_task,
                                                                                                           'A',
                                                                                                           NULL,
                                                                                                           137,
                                                                                                           NULL),
                                                                i_food_plan  => l_diet_food_plan,
                                                                -- get tab specific value "patient needs help"
                                                                i_flg_help           => get_odst_proc_task_det_val(i_lang,
                                                                                                                   i_prof,
                                                                                                                   rec_tsk.id_order_set_process_task,
                                                                                                                   'H',
                                                                                                                   NULL,
                                                                                                                   NULL,
                                                                                                                   NULL),
                                                                i_notes              => l_diet_notes,
                                                                i_id_diet_predefined => l_diet_id_diet,
                                                                i_id_diet_schedule   => ibt_i_diet_id_diet_schedule,
                                                                i_id_diet            => ibt_i_diet_id_diet,
                                                                i_quantity           => ibt_i_diet_quantity,
                                                                i_id_unit            => ibt_i_diet_id_unit,
                                                                i_notes_diet         => ibt_i_diet_notes_diet,
                                                                i_dt_hour            => ibt_i_diet_dt_hour,
                                                                i_commit             => g_no,
                                                                -- get tab specific value "extend diet after discharge"  
                                                                i_flg_institution => get_odst_proc_task_det_val(i_lang,
                                                                                                                i_prof,
                                                                                                                rec_tsk.id_order_set_process_task,
                                                                                                                'X',
                                                                                                                NULL,
                                                                                                                NULL,
                                                                                                                NULL),
                                                                i_flg_force       => g_flg_force_diet,
                                                                o_id_epis_diet    => l_id_req,
                                                                o_msg_warning     => l_msg_warning,
                                                                o_error           => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                           OR l_msg_warning IS NOT NULL
                        THEN
                            o_error.ora_sqlerrm := 'DIET_ERR001';
                            RAISE error_unexpected;
                        END IF;
                    
                        -- get request ID
                        ibt_req_det(l_counter) := l_id_req;
                    
                    END LOOP;
                
            -- << consult/opinion >>
                WHEN g_odst_task_consult THEN
                    g_error := g_error || ' / ' || 'OPINION';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each consult/opinion task
                    FOR rec_tsk IN c_proc_tasks_links(rec_tsk_type.id_task_type)
                    LOOP
                    
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        l_id_req := rec_tsk.id_task_link;
                    
                        l_request_result := pk_opinion.create_opinion_from_order_set(i_lang       => i_lang,
                                                                                     i_prof       => i_prof,
                                                                                     i_id_episode => i_id_episode,
                                                                                     i_id_opinion => l_id_req,
                                                                                     o_opinion    => l_id_req,
                                                                                     o_error      => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- get request ID
                        ibt_req_det(l_counter) := l_id_req;
                    
                    END LOOP;
                
            -- << discharge instructions >>
                WHEN g_odst_task_discharge_instruct THEN
                    g_error := g_error || ' / ' || 'DISCHARGE INSTRUCTIONS';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each discharge instructions task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        -- get follow-up type
                        get_odst_prc_tsk_det_multi_val(i_lang,
                                                       i_prof,
                                                       i_id_order_set_process_task => rec_tsk.id_order_set_process_task,
                                                       
                                                       i_flg_detail_type => 'U',
                                                       o_nvalues         => ibt_nvalues,
                                                       o_vvalues         => ibt_vvalues,
                                                       o_dvalues         => ibt_dvalues);
                    
                        -- verify if exists follow-up type data
                        IF ibt_nvalues.count = 0
                        THEN
                            l_tbl_follow_up_in      := NULL;
                            l_tbl_id_follow_up_type := NULL;
                            l_flg_follow_up_type    := NULL;
                        ELSE
                            l_follow_up_in      := ibt_vvalues(1);
                            l_id_follow_up_type := ibt_nvalues(1);
                        
                            -- get follow-up type description if case of SOS follow-up type
                            IF l_id_follow_up_type = pk_discharge.g_follow_up_sos
                            THEN
                                IF NOT pk_discharge.get_follow_up_type_desc(i_lang                    => i_lang,
                                                                            i_prof                    => i_prof,
                                                                            i_follow_up_type          => l_id_follow_up_type,
                                                                            o_follow_up_type_desc     => l_follow_up_type_desc,
                                                                            o_follow_up_type_unit_mea => l_follow_up_type_unit_mea,
                                                                            o_error                   => o_error)
                                THEN
                                    RAISE error_unexpected;
                                END IF;
                            
                                l_follow_up_in := l_follow_up_type_desc;
                            END IF;
                        
                            l_tbl_follow_up_in      := table_varchar(l_follow_up_in);
                            l_tbl_id_follow_up_type := table_number(l_id_follow_up_type);
                            l_flg_follow_up_type    := pk_alert_constant.g_followupwith_o; -- Follow up with other (free text)
                        
                        END IF;
                    
                        -- Jos? Brito 07/04/2009 ALERT-10317 Disposition Management: Update call to SET_DISCHARGE_NOTES
                        -- Get the ID of the professional selected in "follow-up with"
                        l_prof_id := get_odst_proc_task_det_val(i_lang,
                                                                i_prof,
                                                                rec_tsk.id_order_set_process_task,
                                                                'F',
                                                                NULL,
                                                                NULL,
                                                                NULL);
                    
                        IF l_prof_id IS NOT NULL
                           AND l_prof_id <> -1
                        THEN
                            SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, l_prof_id)
                              INTO l_prof_name_free_text
                              FROM professional p
                             WHERE p.id_professional = l_prof_id;
                        ELSE
                            l_prof_name_free_text := NULL;
                        END IF;
                    
                        IF NOT pk_discharge.set_discharge_notes(i_lang                   => i_lang,
                                                                i_prof                   => i_prof,
                                                                i_prof_cat_type          => l_prof_cat,
                                                                i_epis                   => i_id_episode,
                                                                i_patient                => i_id_patient,
                                                                i_id_disch               => NULL,
                                                                i_epis_complaint         => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'E',
                                                                                                                       NULL,
                                                                                                                       NULL,
                                                                                                                       NULL),
                                                                i_epis_diagnosis         => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'W',
                                                                                                                       NULL,
                                                                                                                       NULL,
                                                                                                                       NULL),
                                                                i_discharge_instructions => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'D',
                                                                                                                       NULL,
                                                                                                                       NULL,
                                                                                                                       NULL),
                                                                i_release_from           => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'A',
                                                                                                                       NULL,
                                                                                                                       102,
                                                                                                                       NULL),
                                                                i_dt_from                => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'A',
                                                                                                                       NULL,
                                                                                                                       103,
                                                                                                                       NULL),
                                                                i_dt_until               => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'A',
                                                                                                                       NULL,
                                                                                                                       104,
                                                                                                                       NULL),
                                                                i_notes_release          => get_odst_proc_task_det_val(i_lang,
                                                                                                                       i_prof,
                                                                                                                       rec_tsk.id_order_set_process_task,
                                                                                                                       'V',
                                                                                                                       NULL,
                                                                                                                       NULL,
                                                                                                                       NULL),
                                                                i_instructions_discussed => table_varchar(get_odst_proc_task_det_val(i_lang,
                                                                                                                                     i_prof,
                                                                                                                                     rec_tsk.id_order_set_process_task,
                                                                                                                                     'I',
                                                                                                                                     NULL,
                                                                                                                                     NULL,
                                                                                                                                     NULL)),
                                                                -- THIS HAS TO BE FIXED
                                                                -- TO USE THE SAME LOGIC AS THE NEW DISCHARGE INSTRUCTIONS SCREEN
                                                                i_follow_up_with     => NULL, -- NULL, if free text
                                                                i_follow_up_in       => l_tbl_follow_up_in,
                                                                i_id_follow_up_type  => l_tbl_id_follow_up_type,
                                                                i_flg_follow_up_type => l_flg_follow_up_type,
                                                                i_follow_up_text     => l_prof_name_free_text, -- Free text
                                                                i_follow_up_notes    => NULL,
                                                                i_issue_assignee     => NULL, -- Do not create a
                                                                i_issue_title        => NULL, -- pending issue.
                                                                --
                                                                i_flg_printer       => NULL,
                                                                i_commit_data       => g_no,
                                                                i_flg_csg_patient   => NULL,
                                                                i_dt_csg_patient    => NULL,
                                                                o_id_discharge_note => l_id_discharge_note,
                                                                o_reports_pat       => l_reports_pat,
                                                                o_error             => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- a discharge instruction task does not generate request ID
                        ibt_req_det(l_counter) := NULL;
                    END LOOP;
                
            -- << Image exam >>
                WHEN g_odst_task_image_exam THEN
                    g_error := g_error || ' / ' || 'IMAGE EXAM';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                    l_clinical_question_id       := table_table_number();
                    l_clinical_question_answer   := table_table_varchar();
                    l_clinical_question_notes    := table_table_varchar();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_image_exam) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    ibt_task_dependency     := table_number();
                    ibt_flg_start_depending := table_varchar();
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        ibt_task_dependency.extend;
                        ibt_flg_start_depending.extend;
                    
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                        -- get clinical questions data
                        l_clinical_question_index := get_clinical_question_index(rec_tsk.id_order_set_process_task);
                        l_clinical_question_id.extend;
                        l_clinical_question_answer.extend;
                        l_clinical_question_notes.extend;
                    
                        IF l_clinical_question_index > 0
                        THEN
                        
                            l_clinical_question_id(l_clinical_question_id.count) := i_clinical_question_id(l_clinical_question_index);
                            l_clinical_question_answer(l_clinical_question_answer.count) := i_clinical_question_answer(l_clinical_question_index);
                            l_clinical_question_notes(l_clinical_question_notes.count) := i_clinical_question_notes(l_clinical_question_index);
                        ELSE
                        
                            l_clinical_question_id(l_clinical_question_id.count) := table_number(NULL);
                            l_clinical_question_answer(l_clinical_question_answer.count) := table_varchar(NULL);
                            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar(NULL);
                        END IF;
                    
                        -- set dependency information
                        set_task_dependency(i_odst_process_task   => rec_tsk.id_order_set_process_task,
                                            i_dtbl                => l_tskd,
                                            o_task_dependency     => ibt_task_dependency(l_counter),
                                            o_flg_start_depending => ibt_flg_start_depending(l_counter));
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_exams_external_api_db.set_exam_request_task(i_lang                    => i_lang,
                                                                          i_prof                    => i_prof,
                                                                          i_task_request            => ibt_presc_id,
                                                                          i_prof_order              => l_cosign_id_prof_order_array,
                                                                          i_dt_order                => l_cosign_dt_order_array,
                                                                          i_order_type              => l_cosign_id_order_type_array,
                                                                          i_clinical_question       => l_clinical_question_id,
                                                                          i_response                => l_clinical_question_answer,
                                                                          i_clinical_question_notes => l_clinical_question_notes,
                                                                          i_clinical_decision_rule  => i_cdr_call,
                                                                          i_task_dependency         => ibt_task_dependency,
                                                                          i_flg_task_dependency     => ibt_flg_start_depending,
                                                                          o_exam_req                => ibt_temp_req,
                                                                          o_exam_req_det            => ibt_temp_req_det_array,
                                                                          o_error                   => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- set diagnosis/clinical indication data    
                    IF NOT pk_exams_external_api_db.set_exam_diagnosis(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_episode      => i_id_episode,
                                                                       i_task_request => ibt_temp_req,
                                                                       i_diagnosis    => l_rec_diagnoses,
                                                                       o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_diagnosis function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
            -- << Other exams >>
                WHEN g_odst_task_other_exam THEN
                    g_error := g_error || ' / ' || 'OTHER EXAM';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                    l_clinical_question_id       := table_table_number();
                    l_clinical_question_answer   := table_table_varchar();
                    l_clinical_question_notes    := table_table_varchar();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_other_exam) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    ibt_task_dependency     := table_number();
                    ibt_flg_start_depending := table_varchar();
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        ibt_task_dependency.extend;
                        ibt_flg_start_depending.extend;
                    
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                        -- get clinical questions data
                        l_clinical_question_index := get_clinical_question_index(rec_tsk.id_order_set_process_task);
                        l_clinical_question_id.extend;
                        l_clinical_question_answer.extend;
                        l_clinical_question_notes.extend;
                    
                        IF l_clinical_question_index > 0
                        THEN
                        
                            l_clinical_question_id(l_clinical_question_id.count) := i_clinical_question_id(l_clinical_question_index);
                            l_clinical_question_answer(l_clinical_question_answer.count) := i_clinical_question_answer(l_clinical_question_index);
                            l_clinical_question_notes(l_clinical_question_notes.count) := i_clinical_question_notes(l_clinical_question_index);
                        ELSE
                        
                            l_clinical_question_id(l_clinical_question_id.count) := table_number(NULL);
                            l_clinical_question_answer(l_clinical_question_answer.count) := table_varchar(NULL);
                            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar(NULL);
                        END IF;
                    
                        -- set dependency information
                        set_task_dependency(i_odst_process_task   => rec_tsk.id_order_set_process_task,
                                            i_dtbl                => l_tskd,
                                            o_task_dependency     => ibt_task_dependency(l_counter),
                                            o_flg_start_depending => ibt_flg_start_depending(l_counter));
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_exams_external_api_db.set_exam_request_task(i_lang                    => i_lang,
                                                                          i_prof                    => i_prof,
                                                                          i_task_request            => ibt_presc_id,
                                                                          i_prof_order              => l_cosign_id_prof_order_array,
                                                                          i_dt_order                => l_cosign_dt_order_array,
                                                                          i_order_type              => l_cosign_id_order_type_array,
                                                                          i_clinical_question       => l_clinical_question_id,
                                                                          i_response                => l_clinical_question_answer,
                                                                          i_clinical_question_notes => l_clinical_question_notes,
                                                                          i_clinical_decision_rule  => i_cdr_call,
                                                                          i_task_dependency         => ibt_task_dependency,
                                                                          i_flg_task_dependency     => ibt_flg_start_depending,
                                                                          o_exam_req                => ibt_temp_req,
                                                                          o_exam_req_det            => ibt_temp_req_det_array,
                                                                          o_error                   => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- set diagnosis/clinical indication data    
                    IF NOT pk_exams_external_api_db.set_exam_diagnosis(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_episode      => i_id_episode,
                                                                       i_task_request => ibt_temp_req,
                                                                       i_diagnosis    => l_rec_diagnoses,
                                                                       o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_diagnosis function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
            -- << Monitoring >>
                WHEN g_odst_task_monitoring THEN
                    g_error := g_error || ' / ' || 'MONITORING';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_req_det           := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_monitoring) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each monitoring task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        l_flg_time := get_odst_proc_task_det_val(i_lang,
                                                                 i_prof,
                                                                 rec_tsk.id_order_set_process_task,
                                                                 'A',
                                                                 NULL,
                                                                 100,
                                                                 NULL);
                    
                        l_interval := get_odst_proc_task_det_val(i_lang,
                                                                 i_prof,
                                                                 rec_tsk.id_order_set_process_task,
                                                                 'A',
                                                                 NULL,
                                                                 98,
                                                                 NULL);
                    
                        -- force monitoring interval value format to seconds
                    
                        -- if monitoring task will be performed in the current episode,
                        -- convert hours format to seconds
                        IF l_flg_time = pk_alert_constant.g_flg_time_e
                        THEN
                            l_monit_unit_measure := get_odst_proc_task_det_unit(i_lang                        => i_lang,
                                                                                i_prof                        => i_prof,
                                                                                i_id_order_set_process_task   => rec_tsk.id_order_set_process_task,
                                                                                i_flg_detail_type             => 'A',
                                                                                i_id_advanced_input           => 62,
                                                                                i_id_advanced_input_field     => 98,
                                                                                i_id_advanced_input_field_det => NULL);
                        
                            IF l_monit_unit_measure IS NOT NULL
                            THEN
                                IF l_monit_unit_measure = 10374
                                THEN
                                    --MINUTES
                                    l_interval := l_interval * 60;
                                ELSIF l_monit_unit_measure = 1041
                                THEN
                                    --HOURS
                                    l_interval := l_interval * 60 * 60;
                                ELSE
                                    --DAYS
                                    l_interval := l_interval * 24 * 60 * 60;
                                END IF;
                            END IF;
                            -- if monitoring  task will be performed between episodes,
                            -- then convert days format to seconds
                        ELSIF l_flg_time = pk_alert_constant.g_flg_time_b
                        THEN
                            l_interval := to_char(to_number(l_interval) * 24 * 60 * 60);
                        END IF;
                    
                        l_request_result := pk_monitorization.create_monitor_req(i_lang              => i_lang,
                                                                                 i_episode           => i_id_episode,
                                                                                 i_prof              => i_prof,
                                                                                 i_dt_begin_str      => get_odst_proc_task_det_val(i_lang,
                                                                                                                                   i_prof,
                                                                                                                                   rec_tsk.id_order_set_process_task,
                                                                                                                                   'A',
                                                                                                                                   NULL,
                                                                                                                                   96,
                                                                                                                                   NULL),
                                                                                 i_interval          => l_interval,
                                                                                 i_dt_end_str        => get_odst_proc_task_det_val(i_lang,
                                                                                                                                   i_prof,
                                                                                                                                   rec_tsk.id_order_set_process_task,
                                                                                                                                   'A',
                                                                                                                                   NULL,
                                                                                                                                   97,
                                                                                                                                   NULL),
                                                                                 i_notes             => get_odst_proc_task_det_val(i_lang,
                                                                                                                                   i_prof,
                                                                                                                                   rec_tsk.id_order_set_process_task,
                                                                                                                                   'N',
                                                                                                                                   NULL,
                                                                                                                                   NULL,
                                                                                                                                   NULL),
                                                                                 i_flg_time          => l_flg_time,
                                                                                 i_id_vs             => get_odst_proc_task_multi_link(rec_tsk.id_order_set_process_task,
                                                                                                                                      g_task_link_null),
                                                                                 i_notes_detail      => NULL,
                                                                                 i_prof_cat_type     => l_prof_cat,
                                                                                 i_prof_order        => l_final_cosign_id_prof_order,
                                                                                 i_dt_order_str      => l_final_cosign_dt_order,
                                                                                 i_order_type        => l_final_cosign_id_order_type,
                                                                                 i_commit_data       => g_no,
                                                                                 o_id_monitorization => l_id_req,
                                                                                 o_error             => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- get request ID
                        ibt_req_det(l_counter) := l_id_req;
                    
                    END LOOP;
                
            -- << Procedure >>
                WHEN g_odst_task_procedure THEN
                
                    g_error := g_error || ' / ' || 'IMAGE EXAM';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                    l_clinical_question_id       := table_table_number();
                    l_clinical_question_answer   := table_table_varchar();
                    l_clinical_question_notes    := table_table_varchar();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_image_exam) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                        -- get clinical questions data
                        l_clinical_question_index := get_clinical_question_index(rec_tsk.id_order_set_process_task);
                        l_clinical_question_id.extend;
                        l_clinical_question_answer.extend;
                        l_clinical_question_notes.extend;
                    
                        IF l_clinical_question_index > 0
                        THEN
                        
                            l_clinical_question_id(l_clinical_question_id.count) := i_clinical_question_id(l_clinical_question_index);
                            l_clinical_question_answer(l_clinical_question_answer.count) := i_clinical_question_answer(l_clinical_question_index);
                            l_clinical_question_notes(l_clinical_question_notes.count) := i_clinical_question_notes(l_clinical_question_index);
                        ELSE
                        
                            l_clinical_question_id(l_clinical_question_id.count) := table_number(NULL);
                            l_clinical_question_answer(l_clinical_question_answer.count) := table_varchar(NULL);
                            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar(NULL);
                        END IF;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT
                        pk_procedures_external_api_db.set_procedure_request_task(i_lang                    => i_lang,
                                                                                 i_prof                    => i_prof,
                                                                                 i_task_request            => ibt_presc_id,
                                                                                 i_prof_order              => l_cosign_id_prof_order_array,
                                                                                 i_dt_order                => l_cosign_dt_order_array,
                                                                                 i_order_type              => l_cosign_id_order_type_array,
                                                                                 i_clinical_question       => l_clinical_question_id,
                                                                                 i_response                => l_clinical_question_answer,
                                                                                 i_clinical_question_notes => l_clinical_question_notes,
                                                                                 i_clinical_decision_rule  => i_cdr_call,
                                                                                 o_interv_presc            => ibt_temp_req,
                                                                                 o_interv_presc_det        => ibt_temp_req_det_array,
                                                                                 o_error                   => o_error)
                    THEN
                        g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- set diagnosis/clinical indication data    
                    IF NOT pk_procedures_external_api_db.set_procedure_diagnosis(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_episode      => i_id_episode,
                                                                                 i_task_request => ibt_temp_req,
                                                                                 i_diagnosis    => l_rec_diagnoses,
                                                                                 o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_diagnosis function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_bp THEN
                
                    g_error := g_error || ' / ' || 'IMAGE EXAM';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                    l_clinical_question_id       := table_table_number();
                    l_clinical_question_answer   := table_table_varchar();
                    l_clinical_question_notes    := table_table_varchar();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_bp) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                        -- get clinical questions data
                        l_clinical_question_index := get_clinical_question_index(rec_tsk.id_order_set_process_task);
                        l_clinical_question_id.extend;
                        l_clinical_question_answer.extend;
                        l_clinical_question_notes.extend;
                    
                        IF l_clinical_question_index > 0
                        THEN
                        
                            l_clinical_question_id(l_clinical_question_id.count) := i_clinical_question_id(l_clinical_question_index);
                            l_clinical_question_answer(l_clinical_question_answer.count) := i_clinical_question_answer(l_clinical_question_index);
                            l_clinical_question_notes(l_clinical_question_notes.count) := i_clinical_question_notes(l_clinical_question_index);
                        ELSE
                        
                            l_clinical_question_id(l_clinical_question_id.count) := table_number(NULL);
                            l_clinical_question_answer(l_clinical_question_answer.count) := table_varchar(NULL);
                            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar(NULL);
                        END IF;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_bp_external_api_db.set_bp_request_task(i_lang                    => i_lang,
                                                                     i_prof                    => i_prof,
                                                                     i_task_request            => ibt_presc_id,
                                                                     i_prof_order              => l_cosign_id_prof_order_array,
                                                                     i_dt_order                => l_cosign_dt_order_array,
                                                                     i_order_type              => l_cosign_id_order_type_array,
                                                                     i_clinical_question       => l_clinical_question_id,
                                                                     i_response                => l_clinical_question_answer,
                                                                     i_clinical_question_notes => l_clinical_question_notes,
                                                                     i_clinical_decision_rule  => i_cdr_call,
                                                                     o_bp_req                  => ibt_temp_req,
                                                                     o_bp_det                  => ibt_temp_req_det_array,
                                                                     o_error                   => o_error)
                    THEN
                        g_error := 'error found while calling pk_bp_external_api_db.set_bp_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- set diagnosis/clinical indication data    
                    IF NOT pk_bp_external_api_db.set_bp_diagnosis(i_lang         => i_lang,
                                                                  i_prof         => i_prof,
                                                                  i_episode      => i_id_episode,
                                                                  i_task_request => ibt_temp_req,
                                                                  i_diagnosis    => l_rec_diagnoses,
                                                                  o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_bp_external_api_db.set_bp_diagnosis function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_req.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       table_number(ibt_temp_req(i)),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
            -- << Patient education >>
                WHEN g_odst_task_patient_education THEN
                    g_error := g_error || ' / ' || 'PATIENT EDUCATION';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task     := table_number();
                    ibt_nurse_tea_req         := table_number();
                    ibtt_i_diagnosis          := table_table_number();
                    ibt_dt_begin              := table_varchar();
                    ibt_notes                 := table_varchar();
                    ibt_order_recurrence      := table_number();
                    ibt_description           := table_clob();
                    ibt_id_nurse_tea_req_sugg := table_number();
                    ibt_desc_topic_aux        := table_varchar();
                    ibt_i_flg_time            := table_varchar();
                
                    -- loop for each patient education task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_nurse_tea_req.extend;
                        ibtt_i_diagnosis.extend;
                        ibt_dt_begin.extend;
                        ibt_notes.extend;
                        ibt_order_recurrence.extend;
                        ibt_description.extend;
                        ibt_id_nurse_tea_req_sugg.extend;
                        ibt_desc_topic_aux.extend;
                        ibt_i_flg_time.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                    
                        ibt_nurse_tea_req(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                                g_task_link_predefined);
                    
                        -- get associated diagnosis and its descriptions
                        get_odst_prc_tsk_det_multi_val(i_lang,
                                                       i_prof,
                                                       i_id_order_set_process_task => rec_tsk.id_order_set_process_task,
                                                       i_flg_detail_type           => g_tsk_det_type_diag,
                                                       o_nvalues                   => ibt_nvalues, -- id_diagnosis
                                                       o_vvalues                   => ibt_vvalues, -- id_alert_diagnosis
                                                       o_dvalues                   => ibt_dvalues);
                    
                        ibtt_i_diagnosis(l_counter) := ibt_nvalues;
                    
                    END LOOP;
                
                    l_request_result := pk_patient_education_api_db.create_request_from_order_set(i_lang               => i_lang,
                                                                                                  i_prof               => i_prof,
                                                                                                  i_id_episode         => i_id_episode,
                                                                                                  i_nurse_tea_req      => ibt_nurse_tea_req,
                                                                                                  o_id_nurse_tea_req   => ibt_req_det,
                                                                                                  o_id_nurse_tea_topic => l_o_id_nurse_tea_topic,
                                                                                                  o_title_topic        => l_o_title_topic,
                                                                                                  o_desc_diagnosis     => l_o_desc_diagnosis,
                                                                                                  o_error              => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
            -- << Lab tests >>
                WHEN g_odst_task_analysis THEN
                    g_error := g_error || ' / ' || 'LAB TESTS';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                    l_clinical_question_id       := table_table_number();
                    l_clinical_question_answer   := table_table_varchar();
                    l_clinical_question_notes    := table_table_varchar();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_analysis) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    ibt_task_dependency     := table_number();
                    ibt_flg_start_depending := table_varchar();
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                    
                        ibt_task_dependency.extend;
                        ibt_flg_start_depending.extend;
                    
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                        -- get clinical questions data
                        l_clinical_question_index := get_clinical_question_index(rec_tsk.id_order_set_process_task);
                        l_clinical_question_id.extend;
                        l_clinical_question_answer.extend;
                        l_clinical_question_notes.extend;
                    
                        IF l_clinical_question_index > 0
                        THEN
                        
                            l_clinical_question_id(l_clinical_question_id.count) := i_clinical_question_id(l_clinical_question_index);
                            l_clinical_question_answer(l_clinical_question_answer.count) := i_clinical_question_answer(l_clinical_question_index);
                            l_clinical_question_notes(l_clinical_question_notes.count) := i_clinical_question_notes(l_clinical_question_index);
                        ELSE
                        
                            l_clinical_question_id(l_clinical_question_id.count) := table_number(NULL);
                            l_clinical_question_answer(l_clinical_question_answer.count) := table_varchar(NULL);
                            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar(NULL);
                        END IF;
                    
                        -- set dependency information
                        set_task_dependency(i_odst_process_task   => rec_tsk.id_order_set_process_task,
                                            i_dtbl                => l_tskd,
                                            o_task_dependency     => ibt_task_dependency(l_counter),
                                            o_flg_start_depending => ibt_flg_start_depending(l_counter));
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT
                        pk_lab_tests_external_api_db.set_lab_test_request_task(i_lang                    => i_lang,
                                                                               i_prof                    => i_prof,
                                                                               i_task_request            => ibt_presc_id,
                                                                               i_prof_order              => l_cosign_id_prof_order_array,
                                                                               i_dt_order                => l_cosign_dt_order_array,
                                                                               i_order_type              => l_cosign_id_order_type_array,
                                                                               i_clinical_question       => l_clinical_question_id,
                                                                               i_response                => l_clinical_question_answer,
                                                                               i_clinical_question_notes => l_clinical_question_notes,
                                                                               i_clinical_decision_rule  => i_cdr_call,
                                                                               i_task_dependency         => ibt_task_dependency,
                                                                               i_flg_task_dependency     => ibt_flg_start_depending,
                                                                               o_analysis_req            => ibt_temp_req,
                                                                               o_analysis_req_det        => ibt_temp_req_det_array,
                                                                               o_error                   => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- set diagnosis/clinical indication data     
                    IF NOT pk_lab_tests_external_api_db.set_lab_test_diagnosis(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_episode      => i_id_episode,
                                                                               i_task_request => ibt_temp_req,
                                                                               i_diagnosis    => l_rec_diagnoses,
                                                                               o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_diagnosis function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_intake_output THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_intake_output),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_intake THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_intake),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_urinary_output THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_urinary_output),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_drainage_records THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_drainage_records),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_all_output THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_all_output),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                WHEN g_odst_task_irrigation THEN
                
                    g_error := g_error || ' / ' || 'INTAKE AND OUTPUT';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task        := table_number();
                    ibt_req_det                  := table_number();
                    ibt_presc_id                 := table_number();
                    ibt_temp_req                 := table_number();
                    ibt_temp_req_det_array       := table_table_number();
                    ibt_temp_id_odst_proc_task   := table_number();
                    l_cosign_id_prof_order_array := table_number();
                    l_cosign_dt_order_array      := table_varchar();
                    l_cosign_id_order_type_array := table_number();
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_intake_output) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order      := l_cosign_dt_order;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order      := NULL;
                    END IF;
                
                    -- loop for each lab test task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        l_cosign_id_prof_order_array.extend;
                        l_cosign_dt_order_array.extend;
                        l_cosign_id_order_type_array.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                        l_cosign_id_prof_order_array(l_counter) := l_final_cosign_id_prof_order;
                        l_cosign_dt_order_array(l_counter) := l_final_cosign_dt_order;
                        l_cosign_id_order_type_array(l_counter) := l_final_cosign_id_order_type;
                    
                    END LOOP;
                
                    -- request prescriptions
                    IF NOT pk_inp_hidrics_pbl.set_hidrics_request_task(i_lang            => i_lang,
                                                                       i_prof            => i_prof,
                                                                       i_task_request    => ibt_presc_id,
                                                                       i_hd_task_type    => get_hdrcs_tsk_tp_by_tsk_ty(g_odst_task_irrigation),
                                                                       i_prof_order      => l_cosign_id_prof_order_array,
                                                                       i_dt_order        => l_cosign_dt_order_array,
                                                                       i_order_type      => l_cosign_id_order_type_array,
                                                                       o_hidrics_req     => ibt_temp_req,
                                                                       o_hidrics_req_det => ibt_temp_req_det_array,
                                                                       o_error           => o_error)
                    THEN
                        g_error := 'error found while calling pk_inp_hidrics_pbl.set.set_hidrics_request_task function';
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new req dets
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
            -- << new medication task>>
                WHEN g_odst_task_medication THEN
                    g_error := g_error || ' / ' || 'NEW MEDICATION';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_presc_id          := table_number();
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_null);
                    
                        -- check if this task type needs co-sign
                        IF check_order_task_needs_cosign(i_lang                      => i_lang,
                                                         i_prof_id                   => i_prof.id,
                                                         i_prof_inst                 => i_prof.institution,
                                                         i_prof_soft                 => i_prof.software,
                                                         i_episode                   => i_id_episode,
                                                         i_id_order_set_process_task => ibt_id_odst_proc_task(l_counter),
                                                         i_task_type                 => g_odst_task_medication) =
                           pk_alert_constant.g_yes
                        THEN
                            -- set co-sign info for each one prescription
                            IF NOT pk_api_pfh_ordertools_in.set_medication_co_sign(i_lang          => i_lang,
                                                                                   i_prof          => i_prof,
                                                                                   i_id_presc      => ibt_presc_id(l_counter),
                                                                                   i_prof_co_sign  => l_cosign_id_prof_order,
                                                                                   i_order_type    => l_cosign_id_order_type,
                                                                                   i_dt_co_sign    => l_cosign_dt_order_tstz,
                                                                                   i_co_sign_notes => NULL, -- this field does not exist on order sets co-sign
                                                                                   o_error         => o_error)
                            THEN
                                RAISE error_unexpected;
                            END IF;
                        END IF;
                    
                    END LOOP;
                
                    -- request prescriptions
                    l_request_result := pk_api_pfh_ordertools_in.set_request_medication(i_lang     => i_lang,
                                                                                        i_prof     => i_prof,
                                                                                        i_patient  => i_id_patient,
                                                                                        i_episode  => i_id_episode,
                                                                                        i_presc    => ibt_presc_id,
                                                                                        i_cdr_call => i_cdr_call,
                                                                                        o_presc    => ibt_req_det,
                                                                                        o_error    => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
            -- << institutionalized diet task>>
                WHEN g_odst_task_instit_diet THEN
                    g_error := g_error || ' / ' || 'INSITUTIONALIZED DIET';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_presc_id          := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each institutionalized diet task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_null);
                    
                        -- request predefined institutionalized diet task type
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_DIET.SET_PAT_DIET_TASK', g_package_name);
                        l_request_result := pk_diet.set_req_pat_diet_task(i_lang        => i_lang,
                                                                          i_prof        => i_prof,
                                                                          i_id_diet_req => ibt_presc_id(l_counter),
                                                                          i_flg_force   => g_flg_force_diet,
                                                                          o_error       => o_error);
                    
                        -- exit loop when an error occurs
                        IF (l_request_result = FALSE)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- process request ID
                        ibt_req_det(l_counter) := ibt_presc_id(l_counter);
                    
                    END LOOP;
                
            -- << Communication order task>>
                WHEN g_odst_task_comm_order THEN
                    g_error := g_error || ' / ' || 'COMMUNICATION ORDER';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_presc_id          := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        -- process request ID
                        ibt_req_det(l_counter) := ibt_presc_id(l_counter);
                    
                    END LOOP;
                
                    -- if the order set has clinical indications, overides clinical indication field value of the communication orders
                    IF l_clinical_indications IS NOT NULL
                    THEN
                    
                        IF NOT pk_comm_orders_order_sets.update_comm_order_clin_ind(i_lang                => i_lang,
                                                                                    i_prof                => i_prof,
                                                                                    i_id_comm_order_req   => ibt_presc_id,
                                                                                    i_clinical_indication => l_clinical_indications,
                                                                                    o_error               => o_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.update_comm_order_clin_ind function';
                            RAISE error_unexpected;
                        END IF;
                    
                    END IF;
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_comm_order) = pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order_tstz := l_cosign_dt_order_tstz;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order_tstz := NULL;
                    END IF;
                
                    -- request communication orders
                    l_request_result := pk_comm_orders_order_sets.set_action_order(i_lang              => i_lang,
                                                                                   i_prof              => i_prof,
                                                                                   i_id_episode        => i_id_episode,
                                                                                   i_id_comm_order_req => ibt_presc_id,
                                                                                   i_dt_order          => l_final_cosign_dt_order_tstz,
                                                                                   i_id_prof_order     => l_final_cosign_id_prof_order,
                                                                                   i_id_order_type     => l_final_cosign_id_order_type,
                                                                                   o_error             => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
                WHEN g_odst_task_medical_order THEN
                    g_error := g_error || ' / ' || 'COMMUNICATION ORDER';
                
                    -- initialize parameters
                    ibt_id_odst_proc_task := table_number();
                    ibt_presc_id          := table_number();
                    ibt_req_det           := table_number();
                
                    -- loop for each prescription task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_id_odst_proc_task.count + 1;
                    
                        ibt_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                        ibt_req_det.extend;
                    
                        ibt_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                        -- process request ID
                        ibt_req_det(l_counter) := ibt_presc_id(l_counter);
                    
                    END LOOP;
                
                    -- if the order set has clinical indications, overides clinical indication field value of the communication orders
                    IF l_clinical_indications IS NOT NULL
                    THEN
                    
                        IF NOT pk_comm_orders_order_sets.update_comm_order_clin_ind(i_lang                => i_lang,
                                                                                    i_prof                => i_prof,
                                                                                    i_id_comm_order_req   => ibt_presc_id,
                                                                                    i_clinical_indication => l_clinical_indications,
                                                                                    o_error               => o_error)
                        THEN
                            g_error := 'error found while calling pk_comm_orders_order_sets.update_comm_order_clin_ind function';
                            RAISE error_unexpected;
                        END IF;
                    
                    END IF;
                
                    -- check if this task type needs co-sign
                    IF check_order_task_needs_cosign(i_lang      => i_lang,
                                                     i_prof_id   => i_prof.id,
                                                     i_prof_inst => i_prof.institution,
                                                     i_prof_soft => i_prof.software,
                                                     i_episode   => i_id_episode,
                                                     i_task_type => g_odst_task_medical_order) =
                       pk_alert_constant.g_yes
                    THEN
                        l_final_cosign_id_prof_order := l_cosign_id_prof_order;
                        l_final_cosign_id_order_type := l_cosign_id_order_type;
                        l_final_cosign_dt_order_tstz := l_cosign_dt_order_tstz;
                    ELSE
                        l_final_cosign_id_prof_order := NULL;
                        l_final_cosign_id_order_type := NULL;
                        l_final_cosign_dt_order_tstz := NULL;
                    END IF;
                
                    -- request communication orders
                    l_request_result := pk_comm_orders_order_sets.set_action_order(i_lang              => i_lang,
                                                                                   i_prof              => i_prof,
                                                                                   i_id_episode        => i_id_episode,
                                                                                   i_id_comm_order_req => ibt_presc_id,
                                                                                   i_dt_order          => l_final_cosign_dt_order_tstz,
                                                                                   i_id_prof_order     => l_final_cosign_id_prof_order,
                                                                                   i_id_order_type     => l_final_cosign_id_order_type,
                                                                                   o_error             => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
            -- << Supplies order task>>
            
                WHEN g_odst_task_supplies THEN
                    g_error := g_error || ' / ' || 'SUPPLIES';
                
                    -- initialize parameters                   
                    ibt_id_odst_proc_task      := table_number();
                    ibt_presc_id               := table_number();
                    ibt_req_det                := table_number();
                    ibt_temp_id_odst_proc_task := table_number();
                    ibt_temp_req_det_array     := table_table_number();
                
                    -- loop for each supply task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    
                    END LOOP;
                
                    -- request supplies
                    l_request_result := pk_supplies_order_sets.set_action_order(i_lang            => i_lang,
                                                                                i_prof            => i_prof,
                                                                                i_id_episode      => i_id_episode,
                                                                                i_supply_workflow => ibt_presc_id,
                                                                                o_supply_workflow => ibt_temp_req_det_array,
                                                                                o_error           => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new supply_workflows created
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
            -- << Surgical supplies order task>>
                WHEN g_odst_task_surg_supplies THEN
                    g_error := g_error || ' / ' || 'SURGICAL SUPPLIES';
                
                    -- initialize parameters                   
                    ibt_id_odst_proc_task      := table_number();
                    ibt_presc_id               := table_number();
                    ibt_req_det                := table_number();
                    ibt_temp_id_odst_proc_task := table_number();
                    ibt_temp_req_det_array     := table_table_number();
                
                    -- loop for each surgical supply task
                    FOR rec_tsk IN c_proc_tasks(rec_tsk_type.id_task_type)
                    LOOP
                        l_counter := ibt_temp_id_odst_proc_task.count + 1;
                    
                        ibt_temp_id_odst_proc_task.extend;
                        ibt_presc_id.extend;
                    
                        ibt_temp_id_odst_proc_task(l_counter) := rec_tsk.id_order_set_process_task;
                        ibt_presc_id(l_counter) := get_odst_proc_task_link(rec_tsk.id_order_set_process_task,
                                                                           g_task_link_predefined);
                    END LOOP;
                
                    -- request surgical supplies
                    l_request_result := pk_supplies_order_sets.set_action_order(i_lang            => i_lang,
                                                                                i_prof            => i_prof,
                                                                                i_id_episode      => i_id_episode,
                                                                                i_supply_workflow => ibt_presc_id,
                                                                                o_supply_workflow => ibt_temp_req_det_array,
                                                                                o_error           => o_error);
                
                    -- exit loop when an error occurs
                    IF (l_request_result = FALSE)
                    THEN
                        RAISE error_unexpected;
                    END IF;
                
                    -- replicate order set process task records to the new supply_workflows created
                    FOR i IN 1 .. ibt_temp_id_odst_proc_task.count
                    LOOP
                    
                        replicate_order_set_proc_tasks(ibt_temp_id_odst_proc_task(i),
                                                       ibt_temp_req_det_array(i),
                                                       ibt_id_odst_proc_task,
                                                       ibt_req_det);
                    
                    END LOOP;
                
                ELSE
                    -- exit loop when an error occurs
                    g_error := 'UNKNOWN ORDER SET TASK TYPE';
                    RAISE error_unexpected;
            END CASE;
        
            -- Added exception handling when an id_request is found with a null value
            -- this validation runs in all task types except discharge instructions (no associated id_request)
            IF rec_tsk_type.id_task_type <> g_odst_task_discharge_instruct
            THEN
                FOR i IN ibt_id_odst_proc_task.first .. ibt_id_odst_proc_task.last
                LOOP
                    IF (ibt_req_det(i) IS NULL)
                    THEN
                        -- exit loop when an error occurs
                        g_error := 'id request cannot be null for ' || ibt_id_odst_proc_task(i);
                        RAISE error_unexpected;
                    ELSE
                        -- get dependency 
                        l_dependency := get_task_dependency(ibt_id_odst_proc_task(i), l_tskd);
                    
                        -- update task dependencies with created id_requests
                        IF l_dependency IS NOT NULL
                        THEN
                            IF NOT pk_tde_db.update_dependency(i_lang            => i_lang,
                                                               i_task_dependency => l_dependency,
                                                               i_task_type       => rec_tsk_type.id_task_type,
                                                               i_task_request    => ibt_req_det(i),
                                                               o_error           => o_error)
                            THEN
                                RAISE error_unexpected;
                            END IF;
                        END IF;
                    END IF;
                END LOOP;
            END IF;
        
            -- update order set process tasks request information
            FORALL i IN ibt_id_odst_proc_task.first .. ibt_id_odst_proc_task.last
                UPDATE order_set_process_task
                   SET id_request = ibt_req_det(i), dt_request_tstz = l_sysdate
                 WHERE id_order_set_process_task = ibt_id_odst_proc_task(i);
        
            -- update order set process tasks link with request information for workflow tasks
            FORALL i IN ibt_id_odst_proc_task.first .. ibt_id_odst_proc_task.last
                UPDATE order_set_process_task_link
                   SET id_task_link =
                       (SELECT ospt.id_request
                          FROM order_set_process_task ospt
                         WHERE ospt.id_order_set_process_task = ibt_id_odst_proc_task(i))
                 WHERE id_order_set_process_task = ibt_id_odst_proc_task(i)
                   AND flg_task_link_type = g_task_link_predefined;
        
        END LOOP;
    
        -- for each episode, set the associated dependency 
        FOR rec_epis IN c_proc_episodes
        LOOP
            IF NOT pk_episode.set_task_dependency(i_lang               => i_lang,
                                                  i_prof               => i_prof,
                                                  i_id_episode         => rec_epis.id_episode,
                                                  i_id_task_dependency => get_task_dependency(rec_epis.id_order_set_process_task,
                                                                                              l_tskd),
                                                  o_error              => o_error)
            THEN
                RAISE error_unexpected;
            END IF;
        END LOOP;
    
        -- update all order set process tasks status (including episode tasks)
        UPDATE order_set_process_task
           SET flg_status      = decode(flg_discard_type,
                                        g_task_not_discard,
                                        g_order_set_proc_tsk_running,
                                        g_order_set_proc_tsk_temp),
               dt_status_tstz  = l_sysdate,
               id_professional = i_prof.id
         WHERE flg_status = g_order_set_proc_tsk_temp
           AND id_order_set_process = i_id_order_set_process;
    
        RETURN TRUE;
    EXCEPTION
    
        -- dml error (forall instruction)
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'REQUEST_ORDER_SET_PROC_TASKS',
                                              o_error);
            RETURN FALSE;
        
        -- external unexpected error
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'REQUEST_ORDER_SET_PROC_TASKS',
                                              o_error);
            RETURN FALSE;
        
        -- internal unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'REQUEST_ORDER_SET_PROC_TASKS',
                                              o_error);
            RETURN FALSE;
        
    END request_order_set_proc_tasks;

    FUNCTION check_order_set_task_conflict
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_patient        IN patient.id_patient%TYPE,
        i_id_episode        IN episode.id_episode%TYPE,
        i_id_task           IN order_set_task.id_order_set_task%TYPE,
        i_id_task_type      IN order_set_task.id_task_type%TYPE,
        i_flg_task_schedule IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_flg_conflict     VARCHAR2(1 CHAR);
        l_tbl_flg_conflict table_table_varchar;
        l_result           BOOLEAN;
    
        l_available VARCHAR2(1 CHAR);
        l_area_code ehr_access_area_def.area%TYPE;
    
        l_vital_signs table_number;
    
        e_unexpected_exception EXCEPTION;
    
        l_error t_error_out;
    
        FUNCTION check_exam_group_conflict
        (
            i_lang         IN language.id_language%TYPE,
            i_prof         IN profissional,
            i_patient      IN patient.id_patient%TYPE,
            i_exam_group   IN exam_group.id_exam_group%TYPE,
            o_flg_conflict OUT VARCHAR2,
            o_error        OUT t_error_out
        ) RETURN BOOLEAN IS
        
            CURSOR c_pat IS
                SELECT gender, trunc(months_between(SYSDATE, dt_birth) / 12) age
                  FROM patient
                 WHERE id_patient = i_patient;
        
            l_pat   c_pat%ROWTYPE;
            l_count PLS_INTEGER;
        
        BEGIN
            g_error := 'OPEN C_PAT';
            OPEN c_pat;
            FETCH c_pat
                INTO l_pat;
            CLOSE c_pat;
        
            SELECT COUNT(1)
              INTO l_count
              FROM exam_group eg, exam_dep_clin_serv edcs
             WHERE eg.id_exam_group = i_exam_group
               AND eg.id_group_parent IS NOT NULL
               AND eg.id_exam_group = edcs.id_exam_group
               AND edcs.id_institution = i_prof.institution
               AND edcs.id_software = i_prof.software
               AND edcs.flg_type = pk_exam_constant.g_exam_can_req
               AND ((l_pat.gender IS NOT NULL AND nvl(eg.gender, 'I') IN ('I', l_pat.gender)) OR l_pat.gender IS NULL OR
                   l_pat.gender = 'I')
               AND (nvl(l_pat.age, 0) BETWEEN nvl(eg.age_min, 0) AND nvl(eg.age_max, nvl(l_pat.age, 0)) OR
                   nvl(l_pat.age, 0) = 0);
        
            IF (l_count > 0)
            THEN
                o_flg_conflict := pk_exam_constant.g_no;
            ELSE
                o_flg_conflict := pk_exam_constant.g_yes;
            END IF;
        
            RETURN TRUE;
        
        EXCEPTION
            WHEN OTHERS THEN
                pk_alert_exceptions.process_error(i_lang,
                                                  SQLCODE,
                                                  SQLERRM,
                                                  g_error,
                                                  g_package_owner,
                                                  g_package_name,
                                                  'CHECK_EXAM_GROUP_CONFLICT',
                                                  o_error);
                RETURN FALSE;
        END check_exam_group_conflict;
    
        -- function used to get task time value
        FUNCTION get_task_time_depend RETURN VARCHAR2 IS
        
            l_include_episode order_set_task_dependency.id_order_set_task_from%TYPE;
        
        BEGIN
        
            -- if the task is for schedule, flag time value is "to be defined"
            IF i_flg_task_schedule = pk_alert_constant.g_yes
            THEN
                RETURN pk_alert_constant.g_flg_time_b;
            END IF;
        
            -- get episode in which the task is included
            BEGIN
                SELECT odst_tsk_dep.id_order_set_task_from
                  INTO l_include_episode
                  FROM order_set_task_dependency odst_tsk_dep
                 WHERE odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start
                   AND odst_tsk_dep.id_order_set_task_to = i_id_task;
            EXCEPTION
                WHEN no_data_found THEN
                    l_include_episode := to_number(g_depend_current_epis);
            END;
        
            -- verify if the task will be executed in the current or in a future episode
            IF l_include_episode = to_number(g_depend_current_epis)
            THEN
                RETURN pk_alert_constant.g_flg_time_e;
            ELSE
                RETURN pk_alert_constant.g_flg_time_n;
            END IF;
        
        END get_task_time_depend;
    
    BEGIN
    
        -- check if task type is not available for this software and institution    
        IF (check_order_set_task_avail(i_lang, i_prof, i_id_task_type) = g_not_available)
        THEN
            RETURN g_yes;
        END IF;
    
        -- ALERT-18697
        -- check if task is available for execution if patient is inactive, or active but in scheduling or in an EHR event
        g_error := 'CALL CHECK_AREA_CREATE_PERMISSION';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        CASE i_id_task_type
            WHEN g_odst_task_analysis THEN
                l_area_code := 'LAB'; -- task type: lab test
            WHEN g_odst_task_procedure THEN
                l_area_code := 'PROC'; -- task type: procedure
            WHEN g_odst_task_patient_education THEN
                l_area_code := 'PROC'; -- task type: patient education                
            WHEN g_odst_task_image_exam THEN
                l_area_code := 'IMEXAM'; -- task type: imaging exam    
            WHEN g_odst_task_local_drug THEN
                l_area_code := 'MED'; -- task type: on-site medication
            WHEN g_odst_task_other_exam THEN
                l_area_code := 'OEXAM'; -- task type: other exam    
            WHEN g_odst_task_consult THEN
                l_area_code := 'CONSULT'; -- task type: consult    
            WHEN g_odst_task_inp_surg THEN
                l_area_code := 'INP_ORIS_ADMISSION_REQ'; -- task type: inpatient with surgical episode
            WHEN g_odst_task_inp_surg_ptbr THEN
                l_area_code := 'ORIS_EPIS'; -- task type: surgical episode (only pt/br markets)
            WHEN g_odst_task_monitoring THEN
                l_area_code := 'VS';
            WHEN g_odst_task_comm_order THEN
                l_area_code := 'COMMUNICATION_ORDERS';
            WHEN g_odst_task_medical_order THEN
                l_area_code := 'MEDICAL_ORDERS';
            WHEN g_odst_task_surg_supplies THEN
                l_area_code := 'ORIS_SR_SUPPLIES';
                /*WHEN g_odst_task_bp THEN
                l_area_code := 'BLOOD_PRODUCTS';*/
        
            ELSE
                l_area_code := NULL; -- not an elegible task to block, according to ALERT-18697 conditions
        END CASE;
    
        IF l_area_code IS NOT NULL -- check if task can be executed, according to ALERT-18697 conditions
        THEN
            IF NOT pk_ehr_access.check_area_create_permission(i_lang    => i_lang,
                                                              i_prof    => i_prof,
                                                              i_episode => i_id_episode,
                                                              i_area    => l_area_code,
                                                              o_val     => l_available,
                                                              o_error   => l_error)
            THEN
                RAISE e_unexpected_exception;
            END IF;
        
            IF l_available = g_no
            THEN
                RETURN g_yes;
            END IF;
        END IF;
    
        g_error := 'CHECK IF ORDER SET PROCESS TASK HAS CONFLICTS';
        CASE
            WHEN i_id_task_type = g_odst_task_followup_appoint THEN
                -- Follow-up appointment
                g_error        := g_error || ' / ' || 'FOLLOW-UP APPOINTMENT';
                l_flg_conflict := g_no;
            
            WHEN i_id_task_type = g_odst_task_specialty_appoint THEN
                -- Specialty appointment
                g_error  := g_error || ' / ' || 'SPECIALTY APPOINTMENT';
                l_result := pk_consult_req.check_consult_req_conflict(i_lang             => i_lang,
                                                                      i_prof             => i_prof,
                                                                      i_id_dep_clin_serv => get_odst_task_link(i_id_task,
                                                                                                               g_task_link_null),
                                                                      o_flg_conflict     => l_flg_conflict,
                                                                      o_error            => l_error);
            
            WHEN i_id_task_type = g_odst_task_consult THEN
                -- consult/opinion
                g_error        := g_error || ' / ' || 'CONSULT';
                l_flg_conflict := g_no;
            
            WHEN i_id_task_type = g_odst_task_discharge_instruct THEN
                -- discharge instructions
                g_error        := g_error || ' / ' || 'DISCHARGE INSTRUCTIONS';
                l_flg_conflict := g_no;
            
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                -- image or other exam
                g_error := g_error || ' / ' || 'IMAGE OR OTHER EXAM';
            
                -- get task time value
                l_result := pk_exams_external_api_db.check_exam_conflict(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_patient      => i_id_patient,
                                                                         i_task_request => get_odst_task_link(i_id_task,
                                                                                                              g_task_link_predefined),
                                                                         o_flg_conflict => l_flg_conflict,
                                                                         o_error        => l_error);
            
            WHEN i_id_task_type = g_odst_task_monitoring THEN
                -- Monitoring
                g_error := g_error || ' / ' || 'MONITORING';
            
                -- get list of vital signs if this monitoring task
                l_vital_signs := get_odst_task_multi_link(i_id_task, g_task_link_null);
            
                -- get conflict values of each vital sign
                l_result := pk_vital_sign_pbl.check_vital_signs_conflict(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_episode      => i_id_episode,
                                                                         i_vital_signs  => l_vital_signs,
                                                                         o_flg_conflict => l_tbl_flg_conflict,
                                                                         o_error        => l_error);
            
                -- initialize monitoring task with no conflicts
                l_flg_conflict := pk_alert_constant.g_no;
            
                -- loop conflict value of each vital sign
                FOR i IN 1 .. l_tbl_flg_conflict.count
                LOOP
                
                    -- check if at least one vital sign has conflicts
                    -- (first position of the array has the vital sign id and the second one has the conflict value)
                    IF (l_tbl_flg_conflict(i) (2) = pk_alert_constant.g_inactive)
                    THEN
                        l_flg_conflict := pk_alert_constant.g_yes;
                        EXIT;
                    END IF;
                
                END LOOP;
            
            WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
            
                g_error        := g_error || ' / ' || 'HIDRICS';
                l_flg_conflict := g_no;
            
            WHEN i_id_task_type = g_odst_task_procedure THEN
                -- procedimentos
                g_error := g_error || ' / ' || 'PROCEDURE';
            
                l_result := pk_procedures_external_api_db.check_procedure_conflict(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_patient      => i_id_patient,
                                                                                   i_task_request => get_odst_task_link(i_id_task,
                                                                                                                        g_task_link_null),
                                                                                   o_flg_conflict => l_flg_conflict,
                                                                                   o_error        => l_error);
            WHEN i_id_task_type = g_odst_task_bp THEN
                -- procedimentos
                g_error := g_error || ' / ' || 'PROCEDURE';
            
                l_result := pk_bp_external_api_db.check_bp_conflict(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_patient      => i_id_patient,
                                                                    i_task_request => get_odst_task_link(i_id_task,
                                                                                                         g_task_link_null),
                                                                    o_flg_conflict => l_flg_conflict,
                                                                    o_error        => l_error);
            
            WHEN i_id_task_type = g_odst_task_patient_education THEN
                -- patient education
                g_error := g_error || ' / ' || 'PATIENT EDUCATION';
            
                -- old patient education tasks (don't have task links) must be disabled and cannot be requested
                IF get_odst_task_link(i_id_task, g_task_link_predefined) IS NULL
                THEN
                    l_flg_conflict := pk_alert_constant.g_yes;
                ELSE
                    -- check conflicts for new patient education tasks
                    l_result := pk_patient_education_api_db.check_nurse_req_conflict(i_lang          => i_lang,
                                                                                     i_prof          => i_prof,
                                                                                     i_patient       => i_id_patient,
                                                                                     i_episode       => i_id_episode,
                                                                                     i_nurse_tea_req => get_odst_task_link(i_id_task,
                                                                                                                           g_task_link_predefined),
                                                                                     o_flg_conflict  => l_flg_conflict,
                                                                                     o_error         => l_error);
                END IF;
            
            WHEN i_id_task_type = g_odst_task_analysis THEN
                -- Analysis
                g_error := g_error || ' / ' || 'ANALYSIS';
                -- get task time value
                l_result := pk_lab_tests_external_api_db.check_lab_test_conflict(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_patient      => i_id_patient,
                                                                                 i_task_request => get_odst_task_link(i_id_task,
                                                                                                                      g_task_link_predefined),
                                                                                 o_flg_conflict => l_flg_conflict,
                                                                                 o_error        => l_error);
            
            WHEN i_id_task_type IN (g_odst_task_predef_diet, g_odst_task_instit_diet) THEN
                -- predefined or institutionalized diet
                g_error  := g_error || ' / ' || 'PREDEFINED OR INSTITUTIONALIZED DIET';
                l_result := pk_diet.check_diet_conflict(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_episode      => i_id_episode,
                                                        i_diet_type    => CASE i_id_task_type
                                                                              WHEN g_odst_task_predef_diet THEN
                                                                               pk_diet.g_diet_type_defi
                                                                              ELSE -- g_odst_task_instit_diet
                                                                               pk_diet.g_diet_type_inst
                                                                          END,
                                                        i_diet_ref     => get_odst_task_link(i_id_task, g_task_link_null),
                                                        o_flg_conflict => l_flg_conflict,
                                                        o_error        => l_error);
            
            WHEN i_id_task_type = g_odst_task_appoint_social THEN
                -- social assistance appointment 
                g_error := g_error || ' / ' || 'SOCIAL ASSISTANCE APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_social, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_appoint_nurse THEN
                -- nursing appointment
                g_error := g_error || ' / ' || 'NURSING APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_nurse, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_appoint_medical THEN
                -- medical appointment
                g_error := g_error || ' / ' || 'MEDICAL APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_medical, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_appoint_nutrition THEN
                -- nutrition appointment
                g_error := g_error || ' / ' || 'NUTRITION APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_nutrition, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_appoint_psychology THEN
                -- psychology appointment
                g_error := g_error || ' / ' || 'PSYCHOLOGY APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_psychology, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_appoint_rehabilit THEN
                -- rehabilitation appointment
                g_error := g_error || ' / ' || 'REHABILITATION APPOINTMENT';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_appoint_rehabilit, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_inpatient THEN
                -- inpatient episode
                g_error := g_error || ' / ' || 'INPATIENT EPISODE';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_inpatient, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_inp_surg THEN
                -- inpatient with surgery episode
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE';
            
                IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_inp_surg, i_prof => i_prof) =
                   pk_alert_constant.g_yes
                THEN
                    l_flg_conflict := pk_alert_constant.g_no;
                ELSE
                    l_flg_conflict := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_inpatient_ptbr THEN
                -- inpatient episode for pt/br makerts
                g_error := g_error || ' / ' || 'INPATIENT EPISODE FOR PT/BR MAKERTS';
            
                -- future events area does not support inpatient episodes for PT/BR markets
                -- IF pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_inpatient_ptbr, i_prof => i_prof) =
                --    pk_alert_constant.g_yes
                -- THEN
                --     l_flg_conflict := pk_alert_constant.g_no;
                -- ELSE
                --     l_flg_conflict := pk_alert_constant.g_yes;
                -- END IF;
            
                l_flg_conflict := pk_alert_constant.g_no;
            
            WHEN i_id_task_type = g_odst_task_inp_surg_ptbr THEN
                -- inpatient with surgery episode for pt/br makerts
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE FOR PT/BR MAKERTS';
            
                -- future events area does not support inpatient with surgery episodes for PT/BR markets
                -- l_flg_conflict := pk_events.is_fe_available_by_tk(i_task_type => g_odst_task_inp_surg_ptbr,
                --                                                  i_prof      => i_prof);
            
                l_flg_conflict := pk_alert_constant.g_no;
            
            WHEN i_id_task_type = g_odst_task_medication THEN
                -- new medication task
                g_error  := g_error || ' / ' || 'NEW MEDICATION';
                l_result := pk_api_pfh_ordertools_in.get_medication_conflicts(i_lang             => i_lang,
                                                                              i_prof             => i_prof,
                                                                              i_id_presc         => get_odst_task_link(i_id_task,
                                                                                                                       g_task_link_null),
                                                                              i_flg_check_cosign => pk_alert_constant.g_yes,
                                                                              o_flg_conflicts    => l_flg_conflict,
                                                                              o_error            => l_error);
            
            WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                -- communication order task
                g_error := g_error || ' / ' || 'COMMUNICATION ORDER';
            
                l_result := pk_comm_orders_order_sets.check_comm_order_conflict(i_lang              => i_lang,
                                                                                i_prof              => i_prof,
                                                                                i_episode           => i_id_episode,
                                                                                i_id_comm_order_req => get_odst_task_link(i_id_task,
                                                                                                                          g_task_link_predefined),
                                                                                o_flg_conflict      => l_flg_conflict,
                                                                                o_error             => l_error);
            
            WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                -- supplies or surgical supplies task
                g_error := g_error || ' / ' || 'SUPPLIES OR SURGICAL SUPPLIES';
            
                l_result := pk_supplies_order_sets.check_supply_wf_conflict(i_lang               => i_lang,
                                                                            i_prof               => i_prof,
                                                                            i_episode            => i_id_episode,
                                                                            i_id_supply_workflow => get_odst_task_link(i_id_task,
                                                                                                                       g_task_link_predefined),
                                                                            o_flg_conflict       => l_flg_conflict,
                                                                            o_error              => l_error);
            
            ELSE
                -- unknown order set task type
                g_error        := g_error || ' / ' || 'UNKNOWN ORDER SET TASK TYPE';
                l_flg_conflict := g_yes;
        END CASE;
    
        -- in case of error propagate exception
        IF NOT l_result
        THEN
            g_error := g_error || ' / ' || l_error.err_desc;
            pk_alertlog.log_debug(g_error, g_package_name);
        
            RETURN NULL;
        END IF;
    
        RETURN l_flg_conflict;
    
    END check_order_set_task_conflict;

    FUNCTION check_task_depend_conflict
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_task              IN order_set_task.id_order_set_task%TYPE,
        i_task_dependencies    IN table_number,
        i_task_conflicts       IN table_varchar,
        i_dependency_type      IN table_number,
        i_task_dependency_from IN table_number,
        i_task_dependency_to   IN table_number,
        i_task_type_from       IN table_number,
        i_task_type_to         IN table_number
    ) RETURN VARCHAR2 IS
    
        l_task_dependencies_list table_number;
    
        -- function used to get task conflicts
        FUNCTION get_task_conflicts(in_task order_set_task.id_order_set_task%TYPE) RETURN VARCHAR2 IS
        BEGIN
            -- search for task dependenncy
            FOR i IN 1 .. i_task_dependencies.count
            LOOP
            
                -- when found task dependency return its conflict value
                IF (i_task_dependencies(i) = in_task)
                THEN
                
                    RETURN i_task_conflicts(i);
                
                END IF;
            
            END LOOP;
        
            RETURN NULL;
        
        END get_task_conflicts;
    
    BEGIN
    
        g_error := 'CHECK TASK DEPENDENCY CONFLICT';
        -- verify if the task itself has conflicts
        IF get_task_conflicts(i_id_task) = pk_alert_constant.g_yes
        THEN
            RETURN pk_alert_constant.g_yes;
        END IF;
    
        -- verify if the task has conflicts because of its dependencies
        l_task_dependencies_list := pk_tde_db.get_predecessor_dependencies(i_dependency           => i_id_task,
                                                                           i_relationship_type    => i_dependency_type,
                                                                           i_task_dependency_from => i_task_dependency_from,
                                                                           i_task_dependency_to   => i_task_dependency_to,
                                                                           i_task_type_from       => i_task_type_from,
                                                                           i_task_type_to         => i_task_type_to);
    
        -- if at least one dependency has conflicts, 
        -- then task is also shown as having conflicts
        FOR i IN 1 .. l_task_dependencies_list.count
        LOOP
            IF get_task_conflicts(l_task_dependencies_list(i)) = pk_alert_constant.g_yes
            THEN
                RETURN pk_alert_constant.g_yes;
            END IF;
        END LOOP;
    
        RETURN pk_alert_constant.g_no;
    
    END check_task_depend_conflict;

    FUNCTION check_mandatory_fields
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_task           IN order_set_task.id_order_set_task%TYPE,
        i_id_task_type      IN order_set_task.id_task_type%TYPE,
        i_flg_process_tasks IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_result VARCHAR2(1 CHAR);
    
        l_id_presc                  NUMBER;
        l_flg_med_restriction       VARCHAR2(1 CHAR);
        l_flg_exists_co_sign        VARCHAR2(1 CHAR);
        l_flg_prod_weight_mandatory VARCHAR2(1 CHAR);
        l_flg_invalid_weighing      VARCHAR2(1 CHAR);
        l_id_patient                patient.id_patient%TYPE;
        l_vs_value                  VARCHAR2(1000 CHAR);
        l_vs_unit_measure           NUMBER(24);
        l_vs_um_desc                VARCHAR2(1000 CHAR);
    
        l_exception EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        g_error := 'CHECK IF ALL MANDATORY TASK FIELDS ARE FILLED';
        CASE
            WHEN i_id_task_type = g_odst_task_followup_appoint THEN
                -- Follow-up appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task_det
                    WHERE id_order_set_process_task = i_id_task
                      AND flg_detail_type = 'R'))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                 
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'R'));
            
            WHEN i_id_task_type = g_odst_task_specialty_appoint THEN
                -- Specialty appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task_det
                    WHERE id_order_set_process_task = i_id_task
                      AND flg_detail_type = 'P') AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task_det
                    WHERE id_order_set_process_task = i_id_task
                      AND flg_detail_type = 'R'))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'R'));
            
            WHEN i_id_task_type = g_odst_task_consult THEN
                -- Consult/opinion
                IF NOT pk_opinion.check_opinion_mandatory_field(i_lang              => i_lang,
                                                           i_prof              => i_prof,
                                                           i_task_request      => CASE
                                                                                      WHEN i_flg_process_tasks = pk_alert_constant.g_yes THEN
                                                                                      --Front office
                                                                                       get_odst_proc_task_link(i_id_task,
                                                                                                               g_task_link_predefined)
                                                                                      ELSE
                                                                                      --backoffice
                                                                                       get_odst_task_link(i_id_task, g_task_link_predefined)
                                                                                  END,
                                                           i_flg_process_tasks => i_flg_process_tasks,
                                                           o_check             => l_result,
                                                           o_error             => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            WHEN i_id_task_type = g_odst_task_discharge_instruct THEN
                -- Discharge instructions
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND
                 ((EXISTS (SELECT 1
                              FROM order_set_process_task_det
                             WHERE id_order_set_process_task = i_id_task
                               AND flg_detail_type = 'U') AND EXISTS
                  (SELECT 1
                       FROM order_set_process_task_det
                      WHERE id_order_set_process_task = i_id_task
                        AND flg_detail_type = 'F'))))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90));
            WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                -- Image and other exams
                -- front-office validations
                IF i_flg_process_tasks = g_yes
                THEN
                    -- ask to the exams module if all mandatory fields are filled
                    IF NOT pk_exams_external_api_db.check_exam_mandatory_field(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_task_request => get_odst_proc_task_link(i_id_task,
                                                                                                                         g_task_link_predefined),
                                                                               o_check        => l_result,
                                                                               o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- back-office doesn't need to be validated
                ELSE
                    l_result := g_yes;
                END IF;
            
                pk_alertlog.log_debug(g_error, g_package_name);
            
            WHEN i_id_task_type = g_odst_task_monitoring THEN
                -- Monitoring
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND
                 (EXISTS (SELECT 1
                             FROM order_set_process_task_det
                            WHERE id_order_set_process_task = i_id_task
                              AND flg_detail_type = 'A'
                              AND id_advanced_input_field = 100
                              AND vvalue = g_flg_time_next) OR
                  (EXISTS (SELECT 1
                                     FROM order_set_process_task_det
                                    WHERE id_order_set_process_task = i_id_task
                                      AND flg_detail_type = 'A'
                                      AND id_advanced_input_field = 100
                                      AND vvalue != g_flg_time_next) AND EXISTS
                   (SELECT 1
                              FROM order_set_process_task_det
                             WHERE id_order_set_process_task = i_id_task
                               AND flg_detail_type = 'A'
                               AND id_advanced_input_field = 96) AND EXISTS
                   (SELECT 1
                              FROM order_set_process_task_det
                             WHERE id_order_set_process_task = i_id_task
                               AND flg_detail_type = 'A'
                               AND id_advanced_input_field = 98))))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90));
            
            WHEN i_id_task_type = g_odst_task_procedure THEN
            
                -- front-office validations
                IF i_flg_process_tasks = g_yes
                THEN
                    -- ask to the lab tests module if all mandatory fields are filled
                    IF NOT pk_procedures_external_api_db.check_procedure_mandatory(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_task_request => get_odst_proc_task_link(i_id_task,
                                                                                                                             g_task_link_predefined),
                                                                                   o_check        => l_result,
                                                                                   o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- back-office doesn't need to be validated
                ELSE
                    l_result := g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_bp THEN
            
                -- front-office validations
                IF i_flg_process_tasks = g_yes
                THEN
                    -- ask to the lab tests module if all mandatory fields are filled
                    IF NOT pk_bp_external_api_db.check_bp_mandatory(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_task_request => get_odst_proc_task_link(i_id_task,
                                                                                                              g_task_link_predefined),
                                                                    o_check        => l_result,
                                                                    o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- back-office doesn't need to be validated
                ELSE
                    l_result := g_yes;
                END IF;
            
            WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
            
                l_result := g_yes;
            
            WHEN i_id_task_type = g_odst_task_patient_education THEN
            
                -- Patient education
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND
                 (EXISTS (SELECT 1
                             FROM order_set_process_task_det
                            WHERE id_order_set_process_task = i_id_task
                              AND flg_detail_type = 'A'
                              AND id_advanced_input_field = 138
                              AND vvalue = g_flg_time_next) OR
                  (EXISTS (SELECT 1
                                     FROM order_set_process_task_det
                                    WHERE id_order_set_process_task = i_id_task
                                      AND flg_detail_type = 'A'
                                      AND id_advanced_input_field = 95
                                      AND vvalue != g_flg_time_next) AND EXISTS
                   (SELECT 1
                              FROM order_set_process_task_det
                             WHERE id_order_set_process_task = i_id_task
                               AND flg_detail_type = 'A'
                               AND id_advanced_input_field = 138))))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90));
            
            WHEN i_id_task_type = g_odst_task_analysis THEN
                -- Lab tests
            
                -- front-office validations
                IF i_flg_process_tasks = g_yes
                THEN
                    -- ask to the lab tests module if all mandatory fields are filled
                    IF NOT pk_lab_tests_external_api_db.check_lab_test_mandatory_field(i_lang         => i_lang,
                                                                                       i_prof         => i_prof,
                                                                                       i_task_request => get_odst_proc_task_link(i_id_task,
                                                                                                                                 g_task_link_predefined),
                                                                                       o_check        => l_result,
                                                                                       o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                
                    -- back-office doesn't need to be validated
                ELSE
                    l_result := g_yes;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_predef_diet THEN
                -- predefined diets
                SELECT g_yes
                  INTO l_result
                  FROM dual
                -- front-office validations
                 WHERE (i_flg_process_tasks = g_yes AND EXISTS
                        (SELECT 1
                           FROM order_set_process_task_det
                          WHERE id_order_set_process_task = i_id_task
                            AND flg_detail_type = 'A'
                            AND id_advanced_input_field = 137) AND EXISTS
                        (SELECT 1
                           FROM order_set_process_task_det
                          WHERE id_order_set_process_task = i_id_task
                            AND flg_detail_type = 'A'
                            AND id_advanced_input_field = 136) AND EXISTS
                        (SELECT 1
                           FROM order_set_process_task_det
                          WHERE id_order_set_process_task = i_id_task
                            AND flg_detail_type = 'H') AND EXISTS
                        (SELECT 1
                           FROM order_set_process_task_det
                          WHERE id_order_set_process_task = i_id_task
                            AND flg_detail_type = 'X'))
                      -- back-office validations
                    OR (i_flg_process_tasks = g_no AND EXISTS
                        (SELECT 1
                           FROM order_set_task_detail
                          WHERE id_order_set_task = i_id_task
                            AND flg_detail_type = 'A'
                            AND id_advanced_input_field = 90) AND EXISTS
                        (SELECT 1
                           FROM order_set_task_detail
                          WHERE id_order_set_task = i_id_task
                            AND flg_detail_type = 'H') AND EXISTS
                        (SELECT 1
                           FROM order_set_task_detail
                          WHERE id_order_set_task = i_id_task
                            AND flg_detail_type = 'X'));
            
            WHEN i_id_task_type = g_odst_task_appoint_social THEN
                -- Social assistance appointment 
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task ospt
                    WHERE ospt.id_order_set_process_task = i_id_task
                      AND ospt.id_request IS NOT NULL))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_appoint_nurse THEN
                -- Nursing appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task ospt
                    WHERE ospt.id_order_set_process_task = i_id_task
                      AND ospt.id_request IS NOT NULL))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_appoint_medical THEN
                -- Medical appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task ospt
                    WHERE ospt.id_order_set_process_task = i_id_task
                      AND ospt.id_request IS NOT NULL))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_appoint_nutrition THEN
                -- Nutrition appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task ospt
                    WHERE ospt.id_order_set_process_task = i_id_task
                      AND ospt.id_request IS NOT NULL))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_appoint_psychology THEN
                -- Psychology appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes)
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_appoint_rehabilit THEN
                -- Rehabilitation appointment
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes AND EXISTS
                  (SELECT 1
                     FROM order_set_process_task ospt
                    WHERE ospt.id_order_set_process_task = i_id_task
                      AND ospt.id_request IS NOT NULL))
                -- back-office validations
                 OR (i_flg_process_tasks = g_no AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'A'
                      AND id_advanced_input_field = 90) AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'L') AND EXISTS
                  (SELECT 1
                     FROM order_set_task_detail
                    WHERE id_order_set_task = i_id_task
                      AND flg_detail_type = 'B'));
            
            WHEN i_id_task_type = g_odst_task_inpatient THEN
                -- Inpatient episode
                SELECT g_yes
                  INTO l_result
                  FROM dual;
            
            WHEN i_id_task_type = g_odst_task_inp_surg THEN
                -- Inpatient with surgery episode
                SELECT g_yes
                  INTO l_result
                  FROM dual;
            
            WHEN i_id_task_type = g_odst_task_inpatient_ptbr THEN
                -- Inpatient episode for pt/br markets
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes)
                -- back-office validations
                 OR (i_flg_process_tasks = g_no);
            
            WHEN i_id_task_type = g_odst_task_inp_surg_ptbr THEN
                -- Inpatient with surgery episode for pt/br markets
                SELECT g_yes
                  INTO l_result
                  FROM dual
                 WHERE
                -- front-office validations
                 (i_flg_process_tasks = g_yes)
                -- back-office validations
                 OR (i_flg_process_tasks = g_no);
            
            WHEN i_id_task_type = g_odst_task_instit_diet THEN
                -- institutionalized diet task type
                -- no API to institutionalized diet task type is not needed because all mandatory fields are always filled
                l_result := g_yes;
            
            WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                -- communication order task type
                -- no API to communication order task type is not needed because all mandatory fields are always filled
                l_result := g_yes;
            
            WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                -- supplies task type
            
                -- ask to the supplies module if all mandatory fields are filled
                -- front-office validations
                IF i_flg_process_tasks = g_yes
                THEN
                    IF NOT pk_supplies_order_sets.check_mandatory_field(i_lang         => i_lang,
                                                                        i_prof         => i_prof,
                                                                        i_task_request => get_odst_proc_task_link(i_id_task,
                                                                                                                  g_task_link_predefined),
                                                                        i_flg_context  => pk_supplies_order_sets.g_context_patient,
                                                                        o_check        => l_result,
                                                                        o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSE
                    -- personal settings
                    IF NOT pk_supplies_order_sets.check_mandatory_field(i_lang         => i_lang,
                                                                        i_prof         => i_prof,
                                                                        i_task_request => get_odst_task_link(i_id_task,
                                                                                                             g_task_link_predefined),
                                                                        i_flg_context  => pk_supplies_order_sets.g_context_settings,
                                                                        o_check        => l_result,
                                                                        o_error        => l_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                END IF;
            
            WHEN i_id_task_type = g_odst_task_medication THEN
                IF i_flg_process_tasks = g_yes
                THEN
                
                    l_id_presc := get_odst_proc_task_link(i_id_task, get_odst_proc_task_link_type(i_id_task));
                
                    l_flg_med_restriction := pk_api_pfh_in.get_presc_prod_restrictions(i_lang     => i_lang,
                                                                                       i_prof     => i_prof,
                                                                                       i_id_presc => l_id_presc);
                    l_flg_exists_co_sign  := pk_api_pfh_in.get_check_co_sign(i_lang     => i_lang,
                                                                             i_prof     => i_prof,
                                                                             i_id_presc => l_id_presc);
                
                    IF l_flg_med_restriction = g_allowed_with_cosign
                    THEN
                        IF l_flg_exists_co_sign = g_no
                        THEN
                            l_result := g_no;
                        ELSE
                            l_result := g_yes;
                        END IF;
                    ELSE
                        l_result := g_yes;
                    END IF;
                
                    IF l_result = g_yes
                    THEN
                        -- get weight validation flags 
                        IF NOT
                            pk_api_pfh_in.get_check_prod_pat_weight(i_lang                      => i_lang,
                                                                    i_prof                      => i_prof,
                                                                    i_id_presc                  => l_id_presc,
                                                                    o_id_patient                => l_id_patient,
                                                                    o_flg_prod_weight_mandatory => l_flg_prod_weight_mandatory,
                                                                    o_flg_invalid_weighing      => l_flg_invalid_weighing)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        -- get patient weight
                        IF NOT pk_vital_sign.get_pat_vs_value_unit(i_lang            => i_lang,
                                                                   i_prof            => i_prof,
                                                                   i_id_vital_sign   => pk_vital_sign.g_vs_weight,
                                                                   i_patient         => l_id_patient,
                                                                   o_vs_value        => l_vs_value,
                                                                   o_vs_unit_measure => l_vs_unit_measure,
                                                                   o_vs_um_desc      => l_vs_um_desc,
                                                                   o_error           => l_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        IF l_flg_invalid_weighing = g_yes
                           OR (l_flg_prod_weight_mandatory = g_yes AND l_vs_value IS NULL)
                        THEN
                            l_result := g_no;
                        END IF;
                    END IF;
                ELSE
                    l_result := g_yes;
                END IF;
            
            ELSE
                -- unknown order set task type
                l_result := g_yes;
        END CASE;
    
        RETURN l_result;
    
    EXCEPTION
        -- if no data found, all mandatory task fields are no filled
        WHEN no_data_found THEN
            RETURN g_no;
        WHEN OTHERS THEN
            RETURN g_no;
    END check_mandatory_fields;

    FUNCTION get_order_set_seq RETURN NUMBER IS
    
        l_seq_num NUMBER;
    
    BEGIN
    
        SELECT seq_order_set.nextval
          INTO l_seq_num
          FROM dual;
    
        RETURN l_seq_num;
    
    END get_order_set_seq;

    FUNCTION get_order_set_task_seq RETURN NUMBER IS
    
        l_seq_num NUMBER;
    
    BEGIN
    
        SELECT seq_order_set_task.nextval
          INTO l_seq_num
          FROM dual;
    
        RETURN l_seq_num;
    
    END get_order_set_task_seq;

    FUNCTION get_odst_permission_list
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_order_set    IN order_set.id_order_set%TYPE,
        i_permission_type IN VARCHAR2,
        o_error           OUT t_error_out
    ) RETURN t_tbl_core_domain IS
    
        l_ret t_tbl_core_domain;
    
    BEGIN
    
        g_error := 'OPEN L_RET';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => t.desc_val,
                                         domain_value  => t.val,
                                         order_rank    => t.rank,
                                         img_name      => t.img_name)
                  FROM (SELECT desc_val, val, img_name, rank
                          FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang,
                                                                              i_prof,
                                                                              i_permission_type /*g_odst_edit_perms_domain*/,
                                                                              NULL)) s
                         WHERE (EXISTS (SELECT 1
                                          FROM order_set_link odst_lnk
                                         WHERE odst_lnk.id_order_set = i_id_order_set
                                           AND odst_lnk.flg_link_type = g_order_set_link_spec) OR s.val != 'S')
                         ORDER BY rank) t);
    
        RETURN l_ret;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_EDIT_PERMISSION_LIST',
                                              o_error);
            RETURN t_tbl_core_domain();
    END get_odst_permission_list;

    FUNCTION create_order_set
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_order_set  IN order_set.id_order_set%TYPE,
        i_flg_duplicate IN VARCHAR2,
        o_id_order_set  OUT order_set.id_order_set%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_set order_set%ROWTYPE;
    
        TYPE t_order_set_link IS TABLE OF order_set_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_link t_order_set_link;
    
        TYPE t_order_set_task IS TABLE OF order_set_task%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task t_order_set_task;
    
        TYPE t_order_set_task_link IS TABLE OF order_set_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_link t_order_set_task_link;
    
        TYPE t_order_set_task_detail IS TABLE OF order_set_task_detail%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_detail t_order_set_task_detail;
    
        TYPE t_order_set_task_dependency IS TABLE OF order_set_task_dependency%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_dependency t_order_set_task_dependency;
    
        TYPE t_order_set_task_group IS TABLE OF order_set_task_group%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_group t_order_set_task_group;
    
        CURSOR c_order_set(in_id_order_set order_set.id_order_set%TYPE) IS
            SELECT *
              FROM order_set
             WHERE id_order_set = in_id_order_set;
    
        CURSOR c_order_set_link
        (
            in_id_order_set     order_set_link.id_order_set%TYPE,
            in_id_order_set_new order_set_link.id_order_set%TYPE
        ) IS
            SELECT in_id_order_set_new id_order_set, osl.id_link, osl.flg_link_type
              FROM order_set_link osl
             WHERE osl.id_order_set = in_id_order_set
                  -- does not copy the specialty link because it will be inserted later directly on table
               AND osl.flg_link_type != g_order_set_link_spec;
    
        CURSOR c_order_set_task
        (
            in_id_order_set     order_set.id_order_set%TYPE,
            in_id_order_set_new order_set.id_order_set%TYPE
        ) IS
            SELECT seq_order_set_task.nextval id_order_set_task_new,
                   ost.id_order_set_task      id_order_set_task_old,
                   in_id_order_set_new        id_order_set,
                   ost.id_task_type,
                   tt.flg_modular_workflow
              FROM order_set_task ost
              JOIN task_type tt
                ON tt.id_task_type = ost.id_task_type
             WHERE ost.id_order_set = in_id_order_set;
    
        CURSOR c_order_set_task_link
        (
            in_id_order_set_task     order_set_task_link.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_link.id_order_set_task%TYPE
        ) IS
            SELECT in_id_order_set_task_new id_order_set_task, id_task_link, flg_task_link_type
              FROM order_set_task_link
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_detail
        (
            in_id_order_set_task     order_set_task_detail.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_detail.id_order_set_task%TYPE
        ) IS
            SELECT seq_order_set_task_detail.nextval id_order_set_task_detail,
                   in_id_order_set_task_new          id_order_set_task,
                   flg_value_type,
                   nvalue,
                   dvalue,
                   vvalue,
                   flg_detail_type,
                   id_advanced_input,
                   id_advanced_input_field,
                   id_advanced_input_field_det,
                   id_unit_measure
              FROM order_set_task_detail
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_dependency
        (
            in_id_order_set     order_set.id_order_set%TYPE,
            in_id_order_set_new order_set.id_order_set%TYPE
        ) IS
            SELECT odst_tsk_depend.id_relationship_type,
                   odst_tsk_depend.id_order_set_task_from,
                   odst_tsk_depend.id_order_set_task_to,
                   odst_tsk_depend.lag_min,
                   odst_tsk_depend.lag_max,
                   odst_tsk_depend.id_unit_measure_lag,
                   in_id_order_set_new id_order_set
              FROM order_set_task_dependency odst_tsk_depend
             WHERE odst_tsk_depend.id_order_set = in_id_order_set;
    
        CURSOR c_order_set_task_group
        (
            in_id_order_set_task     order_set_task_group.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_group.id_order_set_task%TYPE
        ) IS
            SELECT in_id_order_set_task_new id_order_set_task, ostg.id_task_group
              FROM order_set_task_group ostg
             WHERE ostg.id_order_set_task = in_id_order_set_task;
    
        TYPE t_record_task_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200 CHAR);
        ibt_task_map t_record_task_map;
    
        flg_new            BOOLEAN := FALSE;
        l_seq_order_set_id NUMBER;
        l_task_counter     PLS_INTEGER;
        l_sysdate          TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        l_counter NUMBER;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'NEW OR EDITING';
        -- New or editing
        IF i_id_order_set IS NULL
        THEN
            flg_new := TRUE;
        ELSE
            flg_new := FALSE;
        END IF;
    
        g_error := 'GET IDS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- Get new order_set ID
        l_seq_order_set_id := get_order_set_seq;
    
        -- Output order set ID created
        o_id_order_set := l_seq_order_set_id;
    
        IF flg_new
        THEN
            g_error := 'NEW ORDER SET - SET VARIABLES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            l_order_set.id_order_set        := l_seq_order_set_id;
            l_order_set.flg_additional_info := g_order_set_add_info_yes;
            l_order_set.flg_status          := g_order_set_temp;
            l_order_set.dt_order_set_tstz   := l_sysdate;
            l_order_set.id_professional     := i_prof.id;
            l_order_set.id_institution      := i_prof.institution;
            l_order_set.id_software         := i_prof.software;
        ELSE
            g_error := 'EDIT ORDER SET - SET VARIABLES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- Fetches parent order set info
            OPEN c_order_set(i_id_order_set);
        
            FETCH c_order_set
                INTO l_order_set;
        
            CLOSE c_order_set;
        
            -- Set new child info
            l_order_set.id_order_set                  := l_seq_order_set_id;
            l_order_set.id_order_set_previous_version := i_id_order_set;
            l_order_set.flg_status                    := g_order_set_temp;
            l_order_set.dt_order_set_tstz             := l_sysdate;
            l_order_set.id_professional               := i_prof.id;
            l_order_set.id_institution                := i_prof.institution;
            l_order_set.id_software                   := i_prof.software;
            l_order_set.dt_cancel_tstz                := NULL;
            l_order_set.id_prof_cancel                := NULL;
        
            -- In case of duplication the link to the previous order set and id_content column value must be deleted            
            IF (i_flg_duplicate = g_yes)
            THEN
                l_order_set.id_order_set_previous_version := NULL;
                l_order_set.id_content                    := NULL;
            END IF;
        
            g_error := 'GET TASKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- order set task
            FOR rec_task IN c_order_set_task(i_id_order_set, l_seq_order_set_id)
            LOOP
            
                l_task_counter := ibt_order_set_task.count + 1;
                ibt_order_set_task(l_task_counter).id_order_set_task := rec_task.id_order_set_task_new;
                ibt_order_set_task(l_task_counter).id_order_set := rec_task.id_order_set;
                ibt_order_set_task(l_task_counter).id_task_type := rec_task.id_task_type;
            
                -- Order set task links
                FOR rec_task_link IN c_order_set_task_link(rec_task.id_order_set_task_old,
                                                           rec_task.id_order_set_task_new)
                LOOP
                    l_counter := ibt_order_set_task_link.count + 1;
                    ibt_order_set_task_link(l_counter).id_order_set_task := rec_task_link.id_order_set_task;
                    ibt_order_set_task_link(l_counter).flg_task_link_type := rec_task_link.flg_task_link_type;
                
                    -- check if modular workflow is supported                    
                    IF (rec_task.flg_modular_workflow = g_modular_workflow_support
                       -- TODO: the following two lines are temporary
                       -- They are necessary just because this function is used to migrate labs,
                       -- image and other exams tasks from old architecture to the predefined task architecture.
                       -- After the script is versioned and executed in the production environment, these two lines can be removed. 
                       AND (rec_task_link.flg_task_link_type = g_task_link_predefined OR
                       rec_task.id_task_type IN (g_odst_task_medication, g_odst_task_instit_diet)))
                    THEN
                        -- create copy of predefined tasks (check rec_task.flg_modular_workflow value)
                        CASE
                            WHEN rec_task.id_task_type = g_odst_task_medication THEN
                                -- duplicate predefined medication task
                                IF NOT pk_api_pfh_ordertools_in.copy_medication_task(i_lang     => i_lang,
                                                                                     i_prof     => i_prof,
                                                                                     i_id_presc => rec_task_link.id_task_link,
                                                                                     o_id_presc => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                     o_error    => o_error)
                                THEN
                                    g_error := 'error found while calling pk_api_pfh_ordertools_in.copy_medication_task function';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type = g_odst_task_instit_diet THEN
                                -- duplicate institutionalized diet task
                                IF NOT pk_diet.duplicate_diet_task(i_lang              => i_lang,
                                                                   i_prof              => i_prof,
                                                                   i_id_diet_prof_inst => rec_task_link.id_task_link,
                                                                   o_id_diet_prof_inst => ibt_order_set_task_link(l_counter).id_task_link,
                                                                   o_error             => o_error)
                                THEN
                                    g_error := 'error found while calling pk_diet.duplicate_diet_task function';
                                    RAISE l_exception;
                                END IF;
                            WHEN rec_task.id_task_type = g_odst_task_procedure THEN
                                -- copy procedure task and associate with patient/episode
                            
                                IF NOT
                                    pk_procedures_external_api_db.set_procedure_copy_task(i_lang         => i_lang,
                                                                                          i_prof         => i_prof,
                                                                                          i_patient      => NULL,
                                                                                          i_episode      => NULL,
                                                                                          i_task_request => rec_task_link.id_task_link,
                                                                                          o_interv_presc => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                          o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type = g_odst_task_bp THEN
                                -- copy procedure task and associate with patient/episode
                            
                                IF NOT pk_bp_external_api_db.set_bp_copy_task(i_lang         => i_lang,
                                                                              i_prof         => i_prof,
                                                                              i_patient      => NULL,
                                                                              i_episode      => NULL,
                                                                              i_task_request => rec_task_link.id_task_link,
                                                                              o_bp_req       => ibt_order_set_task_link(l_counter).id_task_link,
                                                                              o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                            
                                IF NOT pk_inp_hidrics_pbl.set_hidric_copy_task(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_patient      => NULL,
                                                                               i_episode      => NULL,
                                                                               i_task_request => rec_task_link.id_task_link,
                                                                               o_epis_hidrics => ibt_order_set_task_link(l_counter).id_task_link,
                                                                               o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_inp_hidrics_pbl.set_hidric_copy_task';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type = g_odst_task_analysis THEN
                                -- duplicate lab test task
                                IF NOT pk_lab_tests_external_api_db.set_lab_test_copy_task(i_lang         => i_lang,
                                                                                           i_prof         => i_prof,
                                                                                           i_patient      => NULL,
                                                                                           i_episode      => NULL,
                                                                                           i_task_request => rec_task_link.id_task_link,
                                                                                           o_task_request => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                           o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_copy_task function';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                                -- duplicate image or other exam task
                                IF NOT pk_exams_external_api_db.set_exam_copy_task(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_patient      => NULL,
                                                                                   i_episode      => NULL,
                                                                                   i_task_request => rec_task_link.id_task_link,
                                                                                   o_exam_req     => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                   o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_exams_external_api_db.set_exam_copy_task function';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                                -- duplicate communication order task
                                IF NOT pk_comm_orders_order_sets.copy_comm_order_req(i_lang              => i_lang,
                                                                                     i_prof              => i_prof,
                                                                                     i_id_comm_order_req => rec_task_link.id_task_link,
                                                                                     i_id_patient        => NULL,
                                                                                     i_id_episode        => NULL,
                                                                                     i_dt_begin          => NULL,
                                                                                     o_id_comm_order_req => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                     o_error             => o_error)
                                THEN
                                    g_error := 'error found while calling pk_comm_orders_order_sets.copy_comm_order_req function';
                                    RAISE l_exception;
                                END IF;
                            
                            WHEN rec_task.id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                                -- duplicate supplies or surgical supplies order task
                                IF NOT pk_supplies_order_sets.copy_supply_wf(i_lang               => i_lang,
                                                                             i_prof               => i_prof,
                                                                             i_id_supply_workflow => rec_task_link.id_task_link,
                                                                             i_id_episode         => NULL,
                                                                             i_dt_request         => NULL,
                                                                             o_id_supply_workflow => ibt_order_set_task_link(l_counter).id_task_link,
                                                                             o_error              => o_error)
                                THEN
                                    g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                    RAISE l_exception;
                                END IF;
                            WHEN rec_task.id_task_type = g_odst_task_inpatient THEN
                                IF NOT pk_admission_request.copy_adm_request_wf(i_lang           => i_lang,
                                                                                i_prof           => i_prof,
                                                                                i_id_adm_request => rec_task_link.id_task_link,
                                                                                i_id_episode     => NULL,
                                                                                i_dt_request     => NULL,
                                                                                i_sur_need       => pk_alert_constant.g_no,
                                                                                o_id_adm_request => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                o_error          => o_error)
                                THEN
                                    g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                    RAISE l_exception;
                                END IF;
                            WHEN rec_task.id_task_type = g_odst_task_inp_surg THEN
                                IF NOT pk_admission_request.copy_adm_request_wf(i_lang           => i_lang,
                                                                                i_prof           => i_prof,
                                                                                i_id_adm_request => rec_task_link.id_task_link,
                                                                                i_id_episode     => NULL,
                                                                                i_dt_request     => NULL,
                                                                                i_sur_need       => pk_alert_constant.g_yes,
                                                                                o_id_adm_request => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                o_error          => o_error)
                                THEN
                                    g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                    RAISE l_exception;
                                END IF;
                            WHEN rec_task.id_task_type = g_odst_task_consult THEN
                                -- copy consult task and associate with patient/episode                            
                                IF NOT pk_opinion.set_opinion_copy_task(i_lang         => i_lang,
                                                                        i_prof         => i_prof,
                                                                        i_patient      => NULL,
                                                                        i_episode      => NULL,
                                                                        i_task_request => rec_task_link.id_task_link,
                                                                        o_opinion      => ibt_order_set_task_link(l_counter).id_task_link,
                                                                        o_error        => o_error)
                                THEN
                                    g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                    RAISE l_exception;
                                END IF;
                            WHEN rec_task.id_task_type = g_odst_task_patient_education THEN
                                -- copy patient education with patient/episode                               
                                IF NOT pk_patient_education_api_db.set_ntr_copy_task(i_lang          => i_lang,
                                                                                     i_prof          => i_prof,
                                                                                     i_patient       => NULL,
                                                                                     i_episode       => NULL,
                                                                                     i_task_request  => rec_task_link.id_task_link,
                                                                                     o_nurse_tea_req => ibt_order_set_task_link(l_counter).id_task_link,
                                                                                     o_error         => o_error)
                                THEN
                                    g_error := 'error found while calling pk_patient_education_api_db.set_ntr_copy_task';
                                    RAISE l_exception;
                                END IF;
                            ELSE
                                g_error := 'predefined task is not supported for task type [' || rec_task.id_task_type || ']';
                                RAISE l_exception;
                            
                        END CASE;
                    ELSE
                        -- modular workflow not is supported (copy id_task to new order set)
                        ibt_order_set_task_link(l_counter).id_task_link := rec_task_link.id_task_link;
                    END IF;
                END LOOP;
            
                -- Order set task details
                FOR rec_task_detail IN c_order_set_task_detail(rec_task.id_order_set_task_old,
                                                               rec_task.id_order_set_task_new)
                LOOP
                    l_counter := ibt_order_set_task_detail.count + 1;
                    ibt_order_set_task_detail(l_counter).id_order_set_task_detail := rec_task_detail.id_order_set_task_detail;
                    ibt_order_set_task_detail(l_counter).id_order_set_task := rec_task_detail.id_order_set_task;
                    ibt_order_set_task_detail(l_counter).flg_value_type := rec_task_detail.flg_value_type;
                    ibt_order_set_task_detail(l_counter).nvalue := rec_task_detail.nvalue;
                    ibt_order_set_task_detail(l_counter).dvalue := rec_task_detail.dvalue;
                    ibt_order_set_task_detail(l_counter).vvalue := rec_task_detail.vvalue;
                    ibt_order_set_task_detail(l_counter).flg_detail_type := rec_task_detail.flg_detail_type;
                    ibt_order_set_task_detail(l_counter).id_advanced_input := rec_task_detail.id_advanced_input;
                    ibt_order_set_task_detail(l_counter).id_advanced_input_field := rec_task_detail.id_advanced_input_field;
                    ibt_order_set_task_detail(l_counter).id_advanced_input_field_det := rec_task_detail.id_advanced_input_field_det;
                    ibt_order_set_task_detail(l_counter).id_unit_measure := rec_task_detail.id_unit_measure;
                END LOOP;
            
                -- Order set task groups
                FOR rec IN c_order_set_task_group(rec_task.id_order_set_task_old, rec_task.id_order_set_task_new)
                LOOP
                    l_counter := ibt_order_set_task_group.count + 1;
                    ibt_order_set_task_group(l_counter).id_order_set_task := rec.id_order_set_task;
                    ibt_order_set_task_group(l_counter).id_task_group := rec.id_task_group;
                END LOOP;
            
                -- store the mapping between old and new task IDs
                -- this mapping will be necessary to copy order set task dependencies
                ibt_task_map(to_char(rec_task.id_order_set_task_old)) := rec_task.id_order_set_task_new;
            END LOOP;
        
            -- add to the task map the current episode and future episode dependencies
            ibt_task_map(g_depend_current_epis) := to_number(g_depend_current_epis);
            ibt_task_map(g_depend_future_epis) := to_number(g_depend_future_epis);
        
            g_error := 'GET TASK DEPENDENCIES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- Order set task dependencies
            FOR rec_task_depend IN c_order_set_task_dependency(i_id_order_set, l_seq_order_set_id)
            LOOP
                l_counter := ibt_order_set_task_dependency.count + 1;
                ibt_order_set_task_dependency(l_counter).id_relationship_type := rec_task_depend.id_relationship_type;
                ibt_order_set_task_dependency(l_counter).id_order_set_task_from := ibt_task_map(to_char(rec_task_depend.id_order_set_task_from));
                ibt_order_set_task_dependency(l_counter).id_order_set_task_to := ibt_task_map(to_char(rec_task_depend.id_order_set_task_to));
                ibt_order_set_task_dependency(l_counter).lag_min := rec_task_depend.lag_min;
                ibt_order_set_task_dependency(l_counter).lag_max := rec_task_depend.lag_max;
                ibt_order_set_task_dependency(l_counter).id_unit_measure_lag := rec_task_depend.id_unit_measure_lag;
                ibt_order_set_task_dependency(l_counter).id_order_set := rec_task_depend.id_order_set;
            
            END LOOP;
        
            g_error := 'GET LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- Order set links
            FOR rec IN c_order_set_link(i_id_order_set, l_seq_order_set_id)
            LOOP
                l_counter := ibt_order_set_link.count + 1;
                ibt_order_set_link(l_counter).id_order_set := rec.id_order_set;
                ibt_order_set_link(l_counter).id_link := rec.id_link;
                ibt_order_set_link(l_counter).flg_link_type := rec.flg_link_type;
            END LOOP;
        
        END IF;
    
        g_error := 'INSERT ORDER SET';
        -- Set order set
        INSERT INTO order_set
        VALUES l_order_set;
    
        -- automatically insert the specialty of the author as an order set link
        INSERT INTO order_set_link
            (id_order_set, id_link, flg_link_type)
            SELECT l_order_set.id_order_set id_order_set,
                   prof.id_speciality       id_link,
                   g_order_set_link_spec    flg_link_type
              FROM professional prof
             WHERE prof.id_professional = l_order_set.id_professional
               AND prof.id_speciality IS NOT NULL;
    
        IF NOT flg_new
        THEN
            -- Set Link
            g_error := 'INSERT LINK';
            IF ibt_order_set_link.count > 0
            THEN
            
                FORALL i IN ibt_order_set_link.first .. ibt_order_set_link.last
                    INSERT INTO order_set_link
                    VALUES ibt_order_set_link
                        (i);
            END IF;
        
            -- Set Tasks
            g_error := 'INSERT TASK';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            IF (ibt_order_set_task.count > 0)
            THEN
                FORALL i IN ibt_order_set_task.first .. ibt_order_set_task.last
                    INSERT INTO order_set_task
                    VALUES ibt_order_set_task
                        (i);
            END IF;
        
            -- Set Tasks links
            g_error := 'INSERT TASK LINK';
            IF ibt_order_set_task_link.count > 0
            THEN
                FORALL i IN ibt_order_set_task_link.first .. ibt_order_set_task_link.last
                    INSERT INTO order_set_task_link
                    VALUES ibt_order_set_task_link
                        (i);
            END IF;
        
            -- Set Tasks groups
            g_error := 'INSERT TASK GROUPS';
            IF ibt_order_set_task_group.count > 0
            THEN
                FORALL i IN ibt_order_set_task_group.first .. ibt_order_set_task_group.last
                    INSERT INTO order_set_task_group
                    VALUES ibt_order_set_task_group
                        (i);
            END IF;
        
            -- Set Tasks details
            g_error := 'INSERT TASK LINK DETAILS';
            IF ibt_order_set_task_detail.count > 0
            THEN
                FORALL i IN ibt_order_set_task_detail.first .. ibt_order_set_task_detail.last
                    INSERT INTO order_set_task_detail
                    VALUES ibt_order_set_task_detail
                        (i);
            END IF;
        
            -- Set Tasks dependencies
            g_error := 'INSERT TASK DEPENDENCIES';
            IF ibt_order_set_task_dependency.count > 0
            THEN
                FORALL i IN ibt_order_set_task_dependency.first .. ibt_order_set_task_dependency.last
                    INSERT INTO order_set_task_dependency
                    VALUES ibt_order_set_task_dependency
                        (i);
            END IF;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting DML
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_order_set;

    FUNCTION set_order_set
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_prev_order_set order_set.id_order_set%TYPE;
    
        l_sysdate TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
    BEGIN
        g_error := 'UPDATE ORDER SET STATUS';
        -- set the order set as finished
        UPDATE order_set
           SET flg_status = g_order_set_finished, dt_order_set_tstz = l_sysdate
         WHERE id_order_set = i_id_order_set
           AND flg_status = g_order_set_temp
        RETURNING id_order_set_previous_version INTO l_id_prev_order_set;
    
        g_error := 'UPDATE ORDER SET ID IN OTHER TABLES';
        -- update order set ID on order_set_frequent table
        UPDATE order_set_frequent
           SET id_order_set = i_id_order_set
         WHERE id_order_set = nvl(l_id_prev_order_set, -1);
    
        g_error := 'UPDATE STATUS OF THE PREVIOUS ORDER SET';
        -- update status of the previous order set
        UPDATE order_set
           SET flg_status = g_order_set_deprecated, id_prof_cancel = i_prof.id, dt_cancel_tstz = l_sysdate
         WHERE id_order_set = nvl(l_id_prev_order_set, -1)
           AND flg_status = g_order_set_finished;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set;

    FUNCTION cancel_order_set
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_order_set  IN order_set.id_order_set%TYPE,
        i_cancel_reason IN order_set.id_cancel_reason%TYPE,
        i_cancel_notes  IN order_set.notes_cancel%TYPE,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_order_set(in_id_order_set order_set.id_order_set%TYPE) IS
            SELECT id_order_set, flg_status
              FROM order_set
             WHERE id_order_set = in_id_order_set;
    
        -- cursor with all predefined tasks
        CURSOR c_modular_tasks(in_id_order_set IN order_set.id_order_set%TYPE) IS
            SELECT t_rec_odst_task_req(ost.id_order_set_task, ost.id_task_type, ostl.id_task_link)
              FROM order_set_task ost
              JOIN task_type tt
                ON tt.id_task_type = ost.id_task_type
               AND tt.flg_modular_workflow = g_modular_workflow_support
              JOIN order_set_task_link ostl
                ON ostl.id_order_set_task = ost.id_order_set_task
               AND ostl.flg_task_link_type = get_odst_task_link_type(ost.id_order_set_task) -- to return only the predefined requests
             WHERE ost.id_order_set = in_id_order_set;
    
        l_order_set     c_order_set%ROWTYPE;
        l_modular_tasks t_tbl_odst_task_req;
        l_task_types    table_number;
        l_sysdate       TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        error_undefined_status EXCEPTION;
        l_exception            EXCEPTION;
    
    BEGIN
        g_error := 'FETCH ORDER SET';
        -- Checks if the order set state is temporary or definitive.
        OPEN c_order_set(i_id_order_set);
    
        FETCH c_order_set
            INTO l_order_set;
    
        CLOSE c_order_set;
    
        g_error := 'VERIFY STATE OF ORDER SET / flg_status=' || l_order_set.flg_status || ' id_order_set=' ||
                   l_order_set.id_order_set || ' in_id_order_set=' || i_id_order_set;
        pk_alertlog.log_debug(g_error, g_package_name);
    
        IF l_order_set.flg_status = g_order_set_temp
        THEN
            -- handling for predefined tasks (for the task types that supports modular workflows)
            -- get all predefined tasks
            OPEN c_modular_tasks(i_id_order_set);
            FETCH c_modular_tasks BULK COLLECT
                INTO l_modular_tasks;
            CLOSE c_modular_tasks;
        
            -- get array of distinct task types
            l_task_types := get_task_types(l_modular_tasks);
            -- for each task type, call apis to delete predefined tasks
            FOR i IN 1 .. l_task_types.count
            LOOP
                CASE
                
                    WHEN l_task_types(i) = g_odst_task_medication THEN
                        -- delete predefined medication tasks
                        IF NOT pk_api_pfh_ordertools_in.delete_medication_task(i_lang     => i_lang,
                                                                               i_prof     => i_prof,
                                                                               i_id_presc => get_task_requests(i_task_type => g_odst_task_medication,
                                                                                                               i_reqs      => l_modular_tasks),
                                                                               o_error    => o_error)
                        THEN
                            g_error := 'error found while calling pk_api_pfh_ordertools_in.delete_medication_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) = g_odst_task_instit_diet THEN
                        -- delete institutionalized diet tasks
                        IF NOT pk_diet.cancel_diet_orderset(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_id_diet_prof_inst => get_task_requests(i_task_type => g_odst_task_instit_diet,
                                                                                                     i_reqs      => l_modular_tasks),
                                                            o_error             => o_error)
                        THEN
                            g_error := 'error found while calling pk_diet.cancel_diet_orderset function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) = g_odst_task_analysis THEN
                        -- delete predefined lab test tasks
                        IF NOT pk_lab_tests_external_api_db.set_lab_test_delete_task(i_lang         => i_lang,
                                                                                     i_prof         => i_prof,
                                                                                     i_task_request => get_task_requests(i_task_type => g_odst_task_analysis,
                                                                                                                         i_reqs      => l_modular_tasks),
                                                                                     o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                        -- delete predefined exam tasks
                        IF NOT pk_exams_external_api_db.set_exam_delete_task(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                 i_reqs      => l_modular_tasks),
                                                                             o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_procedure THEN
                        -- delete predefined exam tasks
                        IF NOT pk_procedures_external_api_db.set_procedure_delete_task(i_lang         => i_lang,
                                                                                       i_prof         => i_prof,
                                                                                       i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                           i_reqs      => l_modular_tasks),
                                                                                       o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_bp THEN
                        -- delete predefined exam tasks
                        IF NOT pk_bp_external_api_db.set_bp_delete_task(i_lang         => i_lang,
                                                                        i_prof         => i_prof,
                                                                        i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                            i_reqs      => l_modular_tasks),
                                                                        o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                        -- delete predefined hidris tasks
                        IF NOT pk_inp_hidrics_pbl.set_hidric_delete_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                        -- delete predefined communication orders tasks
                        IF NOT pk_comm_orders_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                                i_prof         => i_prof,
                                                                                i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                    i_reqs      => l_modular_tasks),
                                                                                o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_com_orders_order_sets.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                        -- delete predefined supplies or surgical supplies tasks
                        IF NOT pk_supplies_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                 i_reqs      => l_modular_tasks),
                                                                             o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_supplies_order_sets.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_inpatient, g_odst_task_inp_surg) THEN
                    
                        IF NOT pk_admission_request.cancel_predefined_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                               i_reqs      => l_modular_tasks),
                                                                           o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_admission_request.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    
                    ELSE
                        g_error := 'delete predefined task is not supported for task type [' || l_task_types(i) || ']';
                        RAISE l_exception;
                END CASE;
            END LOOP;
        
            g_error := 'DELETE TASKS GROUPS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_task_group ostg
             WHERE ostg.id_order_set_task IN (SELECT odst_tsk.id_order_set_task
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_order_set = i_id_order_set);
        
            g_error := 'DELETE TASKS DETAILS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_task_detail odst_td
             WHERE odst_td.id_order_set_task IN
                   (SELECT odst_tsk.id_order_set_task
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set = i_id_order_set);
        
            g_error := 'DELETE TASKS LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_task_link odst_tl
             WHERE odst_tl.id_order_set_task IN
                   (SELECT odst_tsk.id_order_set_task
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set = i_id_order_set);
        
            g_error := 'DELETE TASK DEPENDENCIES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_task_dependency odst_tsk_depend
             WHERE odst_tsk_depend.id_order_set = i_id_order_set;
        
            g_error := 'DELETE TASKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_task
             WHERE id_order_set = i_id_order_set;
        
            g_error := 'DELETE LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_link
             WHERE id_order_set = i_id_order_set;
        
            g_error := 'DELETE TEMPORARY ORDER SET';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set
             WHERE id_order_set = i_id_order_set
               AND flg_status = g_order_set_temp;
        
        ELSIF (l_order_set.flg_status = g_order_set_finished)
        THEN
            g_error := 'DELETE CLOSED ORDER SET';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            UPDATE order_set os
               SET os.flg_status       = g_order_set_deleted,
                   os.id_prof_cancel   = i_prof.id,
                   os.dt_cancel_tstz   = l_sysdate,
                   os.id_cancel_reason = i_cancel_reason,
                   os.notes_cancel     = i_cancel_reason
             WHERE id_order_set = i_id_order_set
               AND flg_status = g_order_set_finished;
        ELSE
            RAISE error_undefined_status;
        END IF;
    
        RETURN TRUE;
    EXCEPTION
        -- Error if order set state is not temporary or definitive
        WHEN error_undefined_status THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / UNDEFINED STATE FOR FLG_STATUS',
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_order_set;

    FUNCTION set_order_set_main_info
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_order_set             IN order_set.id_order_set%TYPE,
        i_title                    IN order_set.title%TYPE,
        i_author                   IN order_set.author_desc%TYPE,
        i_flg_target_professionals IN order_set.flg_target_professionals%TYPE,
        i_flg_edit_permissions     IN order_set.flg_edit_permissions%TYPE,
        i_link_environment         IN table_number,
        i_link_specialty           IN table_number,
        i_link_clinical_service    IN table_number,
        i_link_order_set_type      IN table_number,
        i_notes_global             IN order_set.notes_global%TYPE,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
        RETURN pk_order_sets.set_order_set_main_info(i_lang                     => i_lang,
                                                     i_prof                     => i_prof,
                                                     i_id_order_set             => i_id_order_set,
                                                     i_title                    => i_title,
                                                     i_author                   => i_author,
                                                     i_flg_target_professionals => i_flg_target_professionals,
                                                     i_flg_edit_permissions     => i_flg_edit_permissions,
                                                     i_link_environment         => i_link_environment,
                                                     i_link_specialty           => i_link_specialty,
                                                     i_link_clinical_service    => i_link_clinical_service,
                                                     i_link_order_set_type      => i_link_order_set_type,
                                                     i_notes_global             => i_notes_global,
                                                     i_link_institution         => table_number(),
                                                     o_error                    => o_error);
    END set_order_set_main_info;

    FUNCTION set_order_set_main_info
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_order_set             IN order_set.id_order_set%TYPE,
        i_title                    IN order_set.title%TYPE,
        i_author                   IN order_set.author_desc%TYPE,
        i_flg_target_professionals IN order_set.flg_target_professionals%TYPE,
        i_flg_edit_permissions     IN order_set.flg_edit_permissions%TYPE,
        i_link_environment         IN table_number,
        i_link_specialty           IN table_number,
        i_link_clinical_service    IN table_number,
        i_link_order_set_type      IN table_number,
        i_notes_global             IN order_set.notes_global%TYPE,
        i_link_institution         IN table_number DEFAULT NULL,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_link IS TABLE OF order_set_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_link t_order_set_link;
    
        counter    PLS_INTEGER;
        l_ins_link BOOLEAN := FALSE;
    
        error_undefined_status EXCEPTION;
    
    BEGIN
    
        g_error := 'UPDATE ORDER SET INFO';
        pk_alertlog.log_debug(g_error, g_package_name);
        UPDATE order_set
           SET title                    = i_title,
               author_desc              = i_author,
               flg_target_professionals = i_flg_target_professionals,
               flg_edit_permissions     = i_flg_edit_permissions,
               notes_global             = i_notes_global
         WHERE id_order_set = i_id_order_set
           AND flg_status = g_order_set_temp;
    
        IF (SQL%ROWCOUNT = 0)
        THEN
            RAISE error_undefined_status;
        END IF;
    
        counter := 0;
    
        g_error := 'CREATE RECORDS ENVIRONMENT';
        IF i_link_environment.count != 0
        THEN
            l_ins_link := TRUE;
            FOR i IN i_link_environment.first .. i_link_environment.last
            LOOP
                ibt_order_set_link(counter).id_order_set := i_id_order_set;
                ibt_order_set_link(counter).id_link := i_link_environment(i);
                ibt_order_set_link(counter).flg_link_type := g_order_set_link_envi;
                counter := counter + 1;
            END LOOP;
        END IF;
    
        g_error := 'CREATE RECORDS SPECIALTY';
        IF i_link_specialty.count != 0
        THEN
            l_ins_link := TRUE;
            FOR i IN i_link_specialty.first .. i_link_specialty.last
            LOOP
                ibt_order_set_link(counter).id_order_set := i_id_order_set;
                ibt_order_set_link(counter).id_link := i_link_specialty(i);
                ibt_order_set_link(counter).flg_link_type := g_order_set_link_spec;
                counter := counter + 1;
            END LOOP;
        END IF;
    
        g_error := 'CREATE RECORDS CLINICAL SERVICE';
        IF i_link_clinical_service.count != 0
        THEN
            l_ins_link := TRUE;
            FOR i IN i_link_clinical_service.first .. i_link_clinical_service.last
            LOOP
                ibt_order_set_link(counter).id_order_set := i_id_order_set;
                ibt_order_set_link(counter).id_link := i_link_clinical_service(i);
                ibt_order_set_link(counter).flg_link_type := g_order_set_link_clin_serv;
                counter := counter + 1;
            END LOOP;
        END IF;
    
        g_error := 'CREATE RECORDS ORDER SET TYPE';
        IF i_link_order_set_type.count != 0
        THEN
            l_ins_link := TRUE;
            FOR i IN i_link_order_set_type.first .. i_link_order_set_type.last
            LOOP
                ibt_order_set_link(counter).id_order_set := i_id_order_set;
                ibt_order_set_link(counter).id_link := i_link_order_set_type(i);
                ibt_order_set_link(counter).flg_link_type := g_order_set_link_odst_type;
                counter := counter + 1;
            END LOOP;
        END IF;
    
        g_error := 'CREATE RECORDS INSTITUTION';
        IF i_link_institution.count != 0
        THEN
            l_ins_link := TRUE;
            FOR i IN i_link_institution.first .. i_link_institution.last
            LOOP
                ibt_order_set_link(counter).id_order_set := i_id_order_set;
                ibt_order_set_link(counter).id_link := i_link_institution(i);
                ibt_order_set_link(counter).flg_link_type := g_order_set_link_institution;
                counter := counter + 1;
            END LOOP;
        END IF;
    
        g_error := 'DELETE ORDER SET LINK';
        -- chief complaints are being taken care of in another function
        DELETE FROM order_set_link
         WHERE id_order_set = i_id_order_set
           AND flg_link_type NOT IN (g_order_set_link_chief_compl, g_order_set_link_reason_visit);
    
        g_error := 'INSERT ORDER SET LINK';
        BEGIN
            IF l_ins_link
            THEN
                FORALL i IN ibt_order_set_link.first .. ibt_order_set_link.last
                    INSERT INTO order_set_link
                    VALUES ibt_order_set_link
                        (i);
            END IF;
        EXCEPTION
            -- Error on order set links insertion
            WHEN dml_errors THEN
                RAISE dml_errors;
        END;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting DML
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_MAIN_INFO',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
        -- Error on update order set info
        WHEN error_undefined_status THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / UNDEFINED STATE FOR ORDER SET',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_MAIN_INFO',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_MAIN_INFO',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
        
    END set_order_set_main_info;

    FUNCTION set_order_set_main_info
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_root_name            IN VARCHAR2,
        i_tbl_id_pk            IN table_number,
        i_tbl_data             IN table_varchar, ---
        i_tbl_ds_internal_name IN table_varchar,
        i_tbl_real_val         IN table_varchar, -- 
        i_tbl_val_clob         IN table_clob, --
        i_tbl_val_array        IN table_table_varchar DEFAULT NULL, --
        i_tbl_val_array_desc   IN table_table_varchar DEFAULT NULL, --
        o_id_order_set         OUT order_set.id_order_set%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_order_set             order_set.id_order_set%TYPE;
        l_title                    order_set.title%TYPE;
        l_author                   order_set.author_desc%TYPE;
        l_flg_target_professionals order_set.flg_target_professionals%TYPE;
        l_flg_edit_permissions     order_set.flg_edit_permissions%TYPE;
        l_tbl_link_environment     table_number := table_number();
        l_tbl_link_specialty       table_number := table_number();
        l_tbl_clinical_service     table_number := table_number();
        l_tbl_link_order_set_type  table_number := table_number();
        l_notes_global             order_set.notes_global%TYPE;
        l_tbl_link_reason_visit    table_number := table_number();
        l_tbl_diagnosis            table_clob := table_clob();
        l_tbl_id_diagnosis         table_number := table_number();
        l_tbl_id_alert_diagnosis   table_number := table_number();
        l_tbl_diagnosis_desc       table_varchar := table_varchar();
        l_tbl_link_institution     table_number := table_number();
    
    BEGIN
    
        g_error        := 'ERROR GETTING ID_ORDER_SET';
        l_id_order_set := i_tbl_id_pk(1);
    
        g_error := 'ERROR GETTING ORDER SET MAIN INFORMATION';
        FOR i IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
        LOOP
            IF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_title
            THEN
                l_title := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_author
            THEN
                l_author := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_user_permissions
            THEN
                l_flg_target_professionals := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_editing_permissions
            THEN
                l_flg_edit_permissions := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_notes
            THEN
                l_notes_global := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_type
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_link_order_set_type.extend();
                        l_tbl_link_order_set_type(l_tbl_link_order_set_type.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_institution_mm
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_link_institution.extend();
                        l_tbl_link_institution(l_tbl_link_institution.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_set_department
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_link_environment.extend();
                        l_tbl_link_environment(l_tbl_link_environment.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_place_service
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_link_specialty.extend();
                        l_tbl_link_specialty(l_tbl_link_specialty.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_service_mm
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_clinical_service.extend();
                        l_tbl_clinical_service(l_tbl_clinical_service.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_complaint_mw
            THEN
                FOR j IN i_tbl_val_array(i).first .. i_tbl_val_array(i).last
                LOOP
                    IF i_tbl_val_array(i) (j) IS NOT NULL
                    THEN
                        l_tbl_link_reason_visit.extend();
                        l_tbl_link_reason_visit(l_tbl_link_reason_visit.count) := to_number(i_tbl_val_array(i) (j));
                    END IF;
                END LOOP;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
            THEN
                l_tbl_diagnosis.extend();
                l_tbl_id_diagnosis       := table_number();
                l_tbl_id_alert_diagnosis := table_number();
                l_tbl_diagnosis_desc     := table_varchar();
            
                SELECT ad.id_diagnosis, ad.id_alert_diagnosis, t_value_desc.diagnosis_desc
                  BULK COLLECT
                  INTO l_tbl_id_diagnosis, l_tbl_id_alert_diagnosis, l_tbl_diagnosis_desc
                  FROM (SELECT /*+opt_estimate(table t rows=1)*/
                         to_number(t.column_value) id_alert_diagnosis, rownum rn
                          FROM TABLE(i_tbl_val_array(i)) t) t_value
                  JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                         t.column_value diagnosis_desc, rownum rn
                          FROM TABLE(i_tbl_val_array_desc(i)) t) t_value_desc
                    ON t_value_desc.rn = t_value.rn
                  JOIN alert_diagnosis ad
                    ON ad.id_alert_diagnosis = t_value.id_alert_diagnosis;
            
                IF l_tbl_id_diagnosis.count > 0
                THEN
                    l_tbl_diagnosis(l_tbl_diagnosis.count) := '<EPIS_DIAGNOSES ID_PATIENT="" ID_EPISODE="" PROF_CAT_TYPE="' ||
                                                              pk_prof_utils.get_category(i_lang, i_prof) ||
                                                              '" FLG_TYPE="P" FLG_EDIT_MODE="" ID_CDR_CALL="">
                            <EPIS_DIAGNOSIS ID_EPIS_DIAGNOSIS="" ID_EPIS_DIAGNOSIS_HIST="" FLG_TRANSF_FINAL="">
                              <CANCEL_REASON ID_CANCEL_REASON="" FLG_CANCEL_DIFF_DIAG="" /> ';
                
                    FOR k IN l_tbl_id_diagnosis.first .. l_tbl_id_diagnosis.last
                    LOOP
                        l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) ||
                                                                  ' <DIAGNOSIS ID_DIAGNOSIS="' || l_tbl_id_diagnosis(k) ||
                                                                  '" ID_ALERT_DIAG="' || l_tbl_id_alert_diagnosis(k) || '">
                                <DESC_DIAGNOSIS>' ||
                                                                  l_tbl_diagnosis_desc(k) ||
                                                                  '</DESC_DIAGNOSIS>
                                <DIAGNOSIS_WARNING_REPORT>Diagnosis with no form fields.</DIAGNOSIS_WARNING_REPORT>
                              </DIAGNOSIS> ';
                    END LOOP;
                
                    l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) ||
                                                              ' </EPIS_DIAGNOSIS>
                            <GENERAL_NOTES ID="" ID_CANCEL_REASON="" />
                          </EPIS_DIAGNOSES>';
                END IF;
            END IF;
        END LOOP;
    
        g_error := 'ERROR CALLING PK_ORDER_SETS.SET_ORDER_SET_MAIN_INFO';
        IF NOT pk_order_sets.set_order_set_main_info(i_lang                     => i_lang,
                                                     i_prof                     => i_prof,
                                                     i_id_order_set             => l_id_order_set,
                                                     i_title                    => l_title,
                                                     i_author                   => l_author,
                                                     i_flg_target_professionals => l_flg_target_professionals,
                                                     i_flg_edit_permissions     => l_flg_edit_permissions,
                                                     i_link_environment         => l_tbl_link_environment,
                                                     i_link_specialty           => l_tbl_link_specialty,
                                                     i_link_clinical_service    => l_tbl_clinical_service,
                                                     i_link_order_set_type      => l_tbl_link_order_set_type,
                                                     i_notes_global             => l_notes_global,
                                                     i_link_institution         => l_tbl_link_institution,
                                                     o_error                    => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'ERROR CALLING PK_ORDER_SETS.SET_ORDER_SET_REASON_FOR_VISIT';
        IF NOT pk_order_sets.set_order_set_reason_for_visit(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_id_order_set      => l_id_order_set,
                                                            i_link_reason_visit => l_tbl_link_reason_visit,
                                                            o_error             => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'PK_ORDER_SETS.SET_ORDER_SET_DIAGNOSES';
        IF NOT pk_order_sets.set_order_set_diagnoses(i_lang         => i_lang,
                                                i_prof         => i_prof,
                                                i_id_order_set => l_id_order_set,
                                                i_diagnoses    => CASE
                                                                      WHEN l_tbl_diagnosis.exists(1) THEN
                                                                       l_tbl_diagnosis(1)
                                                                      ELSE
                                                                       NULL
                                                                  END,
                                                o_error        => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        o_id_order_set := l_id_order_set;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_MAIN_INFO',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_main_info;

    FUNCTION set_odst_tasks_def_values
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_order_set       IN order_set.id_order_set%TYPE,
        i_id_order_set_tasks IN table_number,
        i_id_task_type       IN order_set_task.id_task_type%TYPE,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- task detail record
        TYPE t_task_detail IS RECORD(
            id_odst_proc_task         table_number := table_number(),
            flg_value_type            table_table_varchar := table_table_varchar(),
            dvalue                    table_table_varchar := table_table_varchar(),
            nvalue                    table_table_number := table_table_number(),
            vvalue                    table_table_varchar := table_table_varchar(),
            flg_detail_type           table_table_varchar := table_table_varchar(),
            id_advanced_input         table_table_number := table_table_number(),
            id_advanced_input_field   table_table_number := table_table_number(),
            id_advanced_input_field_d table_table_number := table_table_number(),
            id_unit_measure           table_table_number := table_table_number());
    
        -- local variables to store parameters of set_odst_proc_tasks_det_intern function
        l_updated_selected_tasks_info pk_types.cursor_type;
        l_updated_tasks_instructions  pk_types.cursor_type;
        --l_desc_union_task_instr       VARCHAR2(4000);
        l_task_details t_task_detail;
    
        -- cursor used to get default data 
        c_data pk_types.cursor_type;
    
        -- auxiliary local variables used to get default values
        l_data        institution.id_institution%TYPE;
        l_label       pk_translation.t_desc_translation;
        l_flg_select  VARCHAR2(1 CHAR);
        l_order_field NUMBER;
    
        error_unexpected EXCEPTION;
    
        -- function used to add a new task detail
        PROCEDURE add_new_task_detail
        (
            i_task_details              IN OUT NOCOPY t_task_detail,
            i_id_odst_proc_task         IN NUMBER,
            i_flg_value_type            IN VARCHAR2 DEFAULT NULL,
            i_dvalue                    IN VARCHAR2 DEFAULT NULL,
            i_nvalue                    IN NUMBER DEFAULT NULL,
            i_vvalue                    IN VARCHAR2 DEFAULT NULL,
            i_flg_detail_type           IN VARCHAR2 DEFAULT NULL,
            i_id_advanced_input         IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field   IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field_d IN NUMBER DEFAULT NULL,
            i_id_unit_measure           IN NUMBER DEFAULT NULL
        ) IS
            l_idx PLS_INTEGER;
        BEGIN
            -- extend table for the new task detail
            i_task_details.id_odst_proc_task.extend;
            i_task_details.flg_value_type.extend;
            i_task_details.dvalue.extend;
            i_task_details.nvalue.extend;
            i_task_details.vvalue.extend;
            i_task_details.flg_detail_type.extend;
            i_task_details.id_advanced_input.extend;
            i_task_details.id_advanced_input_field.extend;
            i_task_details.id_advanced_input_field_d.extend;
            i_task_details.id_unit_measure.extend;
        
            -- gets index of the new position
            l_idx := i_task_details.id_odst_proc_task.count;
        
            -- set task detail default values
            i_task_details.id_odst_proc_task(l_idx) := i_id_odst_proc_task;
            i_task_details.flg_value_type(l_idx) := table_varchar(i_flg_value_type);
            i_task_details.dvalue(l_idx) := table_varchar(i_dvalue);
            i_task_details.nvalue(l_idx) := table_number(i_nvalue);
            i_task_details.vvalue(l_idx) := table_varchar(i_vvalue);
            i_task_details.flg_detail_type(l_idx) := table_varchar(i_flg_detail_type);
            i_task_details.id_advanced_input(l_idx) := table_number(i_id_advanced_input);
            i_task_details.id_advanced_input_field(l_idx) := table_number(i_id_advanced_input_field);
            i_task_details.id_advanced_input_field_d(l_idx) := table_number(i_id_advanced_input_field_d);
            i_task_details.id_unit_measure(l_idx) := table_number(i_id_unit_measure);
        END;
    BEGIN
        g_error := 'INSERT DEFAULT VALUES ON ORDER SET TASKS DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- For each order set task insert default values on "SELECTED" advanced input field
        IF (i_id_order_set_tasks.count > 0)
        THEN
            -- Prepare input parameters for set_odst_tasks_details_intern function
            FOR i IN i_id_order_set_tasks.first .. i_id_order_set_tasks.last
            LOOP
            
                -- on case of local and outside medication tasks, set more default values
                CASE
                    WHEN i_id_task_type = g_odst_task_followup_appoint THEN
                        -- Follow-up appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET FOLLOW-UP APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 49,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_specialty_appoint THEN
                        -- Specialty appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET SPECIALTY APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 50,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type IN (g_odst_task_predef_diet, g_odst_task_instit_diet) THEN
                        -- predefined or institutionalized diet prescriptions
                        pk_alertlog.log_debug(g_error || ' / ' ||
                                              'GET PREDEFINED OR INSTITUTIONALIZED DIET PRESCRIPTION DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type = g_odst_task_consult THEN
                        -- Consult/opinion
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET CONSULT DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 51,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_discharge_instruct THEN
                        -- Discharge instructions
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET DISCHARGE INSTRUCTIONS DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 52,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                        -- image or other exam
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET IMAGE OR OTHER EXAM DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type = g_odst_task_monitoring THEN
                        -- Monitoring
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET MONITORING DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 55,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_procedure THEN
                        -- Procedure
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET PROCEDURE DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 56,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_bp THEN
                        -- Procedure
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET BLOOD PRODUCT DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 104,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_patient_education THEN
                        -- Patient education
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET PATIENT EDUCATION DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => 'V',
                                            i_vvalue                  => 'Y',
                                            i_flg_detail_type         => 'A',
                                            i_id_advanced_input       => 100,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_analysis THEN
                        -- Lab Test
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET LAB TEST DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_social THEN
                        -- Social assistance appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET SOCIAL ASSISTANCE APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 84,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_nurse THEN
                        -- Nursing appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET NURSING APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 85,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_medical THEN
                        -- Medical appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET MEDICAL APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 86,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_nutrition THEN
                        -- Nutrition appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET NUTRITION APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 87,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_psychology THEN
                        -- Psychology appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET PSYCHOLOGY APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 88,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_appoint_rehabilit THEN
                        -- Rehabilitation appointment
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET REHABILITATION APPOINTMENT DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 89,
                                            i_id_advanced_input_field => 90);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_SCHEDULE.GET_LOCATIONS', g_package_name);
                    
                        -- gets default value for "location" field
                        IF NOT pk_schedule.get_locations(i_lang        => i_lang,
                                                         i_prof        => i_prof,
                                                         i_institution => i_prof.institution,
                                                         o_list        => c_data,
                                                         o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_data, l_label, l_flg_select, l_order_field;
                        
                            EXIT WHEN l_flg_select = pk_alert_constant.g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "location" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_tasks(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_data,
                                            i_flg_detail_type   => g_tsk_det_type_appoint_locat);
                    
                    WHEN i_id_task_type = g_odst_task_inpatient THEN
                        -- Inpatient episode
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET INPATIENT EPISODE DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 90,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_inp_surg THEN
                        -- Inpatient with surgery episode
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET INPATIENT WITH SURGERY EPISODE DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 91,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_inpatient_ptbr THEN
                        -- Inpatient episode for pt/br markets
                        pk_alertlog.log_debug(g_error || ' / ' ||
                                              'GET INPATIENT EPISODE DEFAULT VALUES (FOR PT/BR MARKETS)',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 90,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_inp_surg_ptbr THEN
                        -- Inpatient with surgery episode for pt/br markets
                        pk_alertlog.log_debug(g_error || ' / ' ||
                                              'GET INPATIENT WITH SURGERY EPISODE DEFAULT VALUES (FOR PT/BR MARKETS)',
                                              g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 91,
                                            i_id_advanced_input_field => 90);
                    
                    WHEN i_id_task_type = g_odst_task_medication THEN
                        -- New medication task
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET NEW MEDICATION DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field                        
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                        -- Communication order task
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET COMMUNICATION ORDER DEFAULT VALUES',
                                              g_package_name);
                    
                        -- add default value for "selected" field                        
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                        -- Supplies order task
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET SUPPLIES ORDER DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field                        
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input_field => g_adv_input_field_selected);
                    
                    WHEN i_id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    
                        -- add default value for "selected" field                        
                        -- INTAKE % OUTPUT
                        pk_alertlog.log_debug(g_error || ' / ' || 'GET INTAKE % OUTPUT DEFAULT VALUES', g_package_name);
                    
                        -- add default value for "selected" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_tasks(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => pk_alert_constant.g_yes,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 102,
                                            i_id_advanced_input_field => 90);
                    
                    ELSE
                        -- Other order set task type
                        NULL;
                END CASE;
            
            END LOOP;
        
            g_error := 'CALL SET_ODST_TASKS_DETAILS_INTERN FUNCTION';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- verify if there are tasks with default values to set
            IF (l_task_details.id_odst_proc_task.count > 0)
            THEN
            
                -- call function that will insert default values
                IF NOT set_odst_tasks_details_intern(i_lang                        => i_lang,
                                                     i_prof                        => i_prof,
                                                     i_id_order_set                => i_id_order_set,
                                                     i_id_order_set_tasks          => l_task_details.id_odst_proc_task,
                                                     i_flg_value_type              => l_task_details.flg_value_type,
                                                     i_dvalue                      => l_task_details.dvalue,
                                                     i_nvalue                      => l_task_details.nvalue,
                                                     i_vvalue                      => l_task_details.vvalue,
                                                     i_flg_detail_type             => l_task_details.flg_detail_type,
                                                     i_id_advanced_input           => l_task_details.id_advanced_input,
                                                     i_id_advanced_input_field     => l_task_details.id_advanced_input_field,
                                                     i_id_advanced_input_field_det => l_task_details.id_advanced_input_field_d,
                                                     i_id_unit_measure             => l_task_details.id_unit_measure,
                                                     i_flg_process_dependencies    => pk_alert_constant.g_no,
                                                     i_commit                      => g_no,
                                                     o_updated_tasks_instructions  => l_updated_tasks_instructions,
                                                     o_updated_selected_tasks_info => l_updated_selected_tasks_info,
                                                     o_error                       => o_error)
                THEN
                    RAISE error_unexpected;
                END IF;
            END IF;
        
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting default values on order set task details
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_TASKS_DEF_VALUES',
                                              o_error);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_TASKS_DEF_VALUES',
                                              o_error);
            RETURN FALSE;
    END set_odst_tasks_def_values;

    FUNCTION set_predefined_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_order_set            IN order_set.id_order_set%TYPE,
        i_task_type            IN order_set_task.id_task_type%TYPE,
        i_predefined_tasks     IN table_number,
        o_order_set_tasks      OUT pk_types.cursor_type,
        o_new_predefined_tasks OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task IS TABLE OF order_set_task%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task t_order_set_task;
    
        TYPE t_order_set_task_link IS TABLE OF order_set_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_link t_order_set_task_link;
    
        ibt_order_set_task_id    table_number := table_number();
        l_id_order_set_task      order_set_task.id_order_set_task%TYPE;
        l_final_predefined_tasks table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'CONFIRM PREDEFINED TEMPORARY TASKS';
        -- confirm predefined tasks
        CASE i_task_type
        -- create medication predefined task
            WHEN g_odst_task_medication THEN
                -- medication prescriptions were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
                o_new_predefined_tasks := l_final_predefined_tasks;
            
        -- create institutionalized diet predefined task
            WHEN g_odst_task_instit_diet THEN
                -- institutionalized diet were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create lab test predefined task  
            WHEN g_odst_task_analysis THEN
                -- lab test task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create image exam predefined task  
            WHEN g_odst_task_image_exam THEN
                -- image exam task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create other exam predefined task  
            WHEN g_odst_task_other_exam THEN
                -- other exam task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create predefined communication order task  
            WHEN g_odst_task_comm_order THEN
                -- communication order task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
            WHEN g_odst_task_medical_order THEN
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create predefined supplies task  
            WHEN g_odst_task_supplies THEN
                -- supplies task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
        -- create predefined surgical supplies task  
            WHEN g_odst_task_surg_supplies THEN
                -- surgical supplies task types were already created before, so the same ids will be used here
                l_final_predefined_tasks := i_predefined_tasks;
            
            ELSE
                g_error := 'confirm predefined task is not supported for task type [' || i_task_type || ']';
                RAISE l_exception;
            
        END CASE;
    
        -- loop for each predefined task       
        FOR i IN 1 .. i_predefined_tasks.last
        LOOP
            -- get new order set task id
            l_id_order_set_task := get_order_set_task_seq;
        
            -- create order set task
            ibt_order_set_task_id.extend;
            ibt_order_set_task_id(i) := l_id_order_set_task;
        
            ibt_order_set_task(i).id_order_set_task := l_id_order_set_task;
            ibt_order_set_task(i).id_order_set := i_order_set;
            ibt_order_set_task(i).id_task_type := i_task_type;
        
            -- create order set task link with predefined task id
            ibt_order_set_task_link(i).id_order_set_task := l_id_order_set_task;
            ibt_order_set_task_link(i).flg_task_link_type := g_task_link_null;
            ibt_order_set_task_link(i).id_task_link := l_final_predefined_tasks(i);
        
        END LOOP;
    
        g_error := 'INSERT NEW ORDER SET TASKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- insert new order set tasks
        FORALL i IN 1 .. ibt_order_set_task.last
            INSERT INTO order_set_task
            VALUES ibt_order_set_task
                (i);
    
        g_error := 'INSERT NEW ORDER SET TASK LINKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- insert new order set task links
        FORALL i IN 1 .. ibt_order_set_task_link.last
            INSERT INTO order_set_task_link
            VALUES ibt_order_set_task_link
                (i);
    
        g_error := 'CALL FUNCTION TO INSERT DEFAULT VALUES ON ORDER SET TASKS DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- call function that will insert default values on task details
        IF NOT set_odst_tasks_def_values(i_lang, i_prof, i_order_set, ibt_order_set_task_id, i_task_type, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- return created order set tasks
        OPEN o_order_set_tasks FOR
            SELECT column_value id_order_set_task
              FROM TABLE(ibt_order_set_task_id);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_PREDEFINED_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_order_set_tasks);
            RETURN FALSE;
    END set_predefined_tasks;

    FUNCTION update_predefined_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_order_set            IN order_set.id_order_set%TYPE,
        i_task_type            IN order_set_task.id_task_type%TYPE,
        i_order_set_tasks      IN table_number,
        i_predefined_tasks     IN table_number,
        o_order_set_tasks      OUT pk_types.cursor_type,
        o_new_predefined_tasks OUT table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task_link IS TABLE OF order_set_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_link t_order_set_task_link;
    
        l_final_predefined_tasks table_number;
        l_update_is_needed       BOOLEAN;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'UPDATE PREDEFINED TEMPORARY TASKS';
        -- update predefined tasks
        CASE i_task_type
        
        -- update medication predefined task
            WHEN g_odst_task_medication THEN
                -- editing one existing medication task doesn't update the task link
                l_update_is_needed := FALSE;
            
        -- update institutionalized diet predefined task
            WHEN g_odst_task_instit_diet THEN
                -- editing one institutionalized diet doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update lab test predefined task
            WHEN g_odst_task_analysis THEN
                -- editing one lab test doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_intake_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_irrigation THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_intake_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_intake THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_all_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_drainage_records THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_urinary_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update image exam predefined task
            WHEN g_odst_task_image_exam THEN
                -- editing one image exam doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update other exam predefined task
            WHEN g_odst_task_other_exam THEN
                -- editing one other exam doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update communication order predefined task
            WHEN g_odst_task_comm_order THEN
                -- editing one communication order doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            WHEN g_odst_task_medical_order THEN
                l_update_is_needed := FALSE;
                -- update predefined supplies task  
            WHEN g_odst_task_supplies THEN
                -- editing one supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
                -- update predefined supplies task  
            WHEN g_odst_task_procedure THEN
                -- editing one supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
                -- update predefined surgical supplies task 
            WHEN g_odst_task_bp THEN
                -- editing one supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            WHEN g_odst_task_surg_supplies THEN
                -- editing one surgical doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
            ELSE
                g_error := 'confirm predefined task is not supported for task type [' || i_task_type || ']';
                RAISE l_exception;
        END CASE;
    
        -- update only if predefined task was changed and supports temporary states
        IF l_update_is_needed
        THEN
            g_error := 'DELETE OLD ORDER SET TASK LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- delete old order set task links
            DELETE FROM order_set_task_link ostl
             WHERE ostl.id_order_set_task IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                               column_value
                                                FROM TABLE(i_order_set_tasks) t);
        
            -- loop for each predefined task       
            FOR i IN 1 .. i_predefined_tasks.last
            LOOP
                -- create order set task link with new predefined task id
                ibt_order_set_task_link(i).id_order_set_task := i_order_set_tasks(i);
                ibt_order_set_task_link(i).flg_task_link_type := g_task_link_null;
                ibt_order_set_task_link(i).id_task_link := l_final_predefined_tasks(i);
            
            END LOOP;
        
            g_error := 'INSERT NEW ORDER SET TASK LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- insert new order set task links
            FORALL i IN 1 .. ibt_order_set_task_link.last
                INSERT INTO order_set_task_link
                VALUES ibt_order_set_task_link
                    (i);
        
            OPEN o_order_set_tasks FOR
                SELECT ost.column_value id_order_set_task
                  FROM TABLE(i_order_set_tasks) ost;
        
            COMMIT;
        ELSE
            -- open empty cursor
            pk_types.open_my_cursor(o_order_set_tasks);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_PREDEFINED_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_order_set_tasks);
            RETURN FALSE;
    END update_predefined_tasks;

    FUNCTION update_predefined_proc_tasks
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_order_set_process       IN order_set_process.id_order_set_process%TYPE,
        i_task_type               IN order_set_task.id_task_type%TYPE,
        i_order_set_process_tasks IN table_number,
        i_predefined_tasks        IN table_number,
        o_order_set_process_tasks OUT pk_types.cursor_type,
        o_new_predefined_tasks    OUT table_number,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_proc_task_link IS TABLE OF order_set_process_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task_link t_order_set_proc_task_link;
    
        l_final_predefined_tasks table_number;
        l_update_is_needed       BOOLEAN;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'CONFIRM PREDEFINED TEMPORARY TASKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- confirm predefined tasks
        CASE i_task_type
        
        -- update medication predefined process task
            WHEN g_odst_task_medication THEN
                -- editing one existing medication task doesn't update the task process link
                l_update_is_needed := FALSE;
            
        -- update institutionalized diet predefined process task
            WHEN g_odst_task_instit_diet THEN
                -- editing one institutionalized diet doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update lab test predefined process task
            WHEN g_odst_task_analysis THEN
                -- editing one process lab test doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update image exam predefined process task
            WHEN g_odst_task_image_exam THEN
                -- editing one process image exam doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update other exam predefined process task
            WHEN g_odst_task_other_exam THEN
                -- editing one process image exam doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update communication order predefined process task
            WHEN g_odst_task_comm_order THEN
                -- editing one process communication order doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            WHEN g_odst_task_medical_order THEN
                l_update_is_needed := FALSE;
                -- update supplies predefined process task
            WHEN g_odst_task_supplies THEN
                -- editing one process supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
                -- update procedures predefined process task
            WHEN g_odst_task_procedure THEN
                -- editing one process supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
                -- update surgical supplies predefined process task
            WHEN g_odst_task_surg_supplies THEN
                -- editing one process surgical supplies doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
                -- update hidrics predefined task
            WHEN g_odst_task_intake_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_irrigation THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_intake_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_intake THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_all_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_drainage_records THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update hidrics predefined task
            WHEN g_odst_task_urinary_output THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
        -- update blood products predefined task
            WHEN g_odst_task_bp THEN
                -- editing one hidrics task doesn't update the task link and doesn't need any api to confirm task editing
                --l_final_predefined_tasks := i_predefined_tasks; -- not needed
                l_update_is_needed := FALSE;
            
            ELSE
                g_error := 'confirm predefined task is not supported for task type [' || i_task_type || ']';
                RAISE l_exception;
        END CASE;
    
        -- update only if predefined task was changes and supports temporary states
        IF l_update_is_needed
        THEN
            g_error := 'DELETE OLD ORDER SET PROCESS TASK LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task_link osptl
             WHERE osptl.id_order_set_process_task IN
                   (SELECT /*+ opt_estimate(table t rows = 1) */
                     column_value
                      FROM TABLE(i_order_set_process_tasks) t);
        
            -- loop for each predefined task       
            FOR i IN 1 .. i_predefined_tasks.last
            LOOP
                -- create order set task link with new predefined task id
                ibt_order_set_proc_task_link(i).id_order_set_process_task := i_order_set_process_tasks(i);
                ibt_order_set_proc_task_link(i).flg_task_link_type := g_task_link_null;
                ibt_order_set_proc_task_link(i).id_task_link := l_final_predefined_tasks(i);
            
            END LOOP;
        
            g_error := 'INSERT NEW ORDER SET PROCESS TASK LINKS';
            -- insert new order set task links
            FORALL i IN 1 .. ibt_order_set_proc_task_link.last
                INSERT INTO order_set_process_task_link
                VALUES ibt_order_set_proc_task_link
                    (i);
        
            OPEN o_order_set_process_tasks FOR
                SELECT ospt.column_value id_order_set_process_tasks
                  FROM TABLE(i_order_set_process_tasks) ospt;
        
            COMMIT;
        ELSE
            -- open empty cursor
            pk_types.open_my_cursor(o_order_set_process_tasks);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_PREDEFINED_PROC_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_order_set_process_tasks);
            RETURN FALSE;
    END update_predefined_proc_tasks;

    FUNCTION set_order_set_tasks
    (
        i_lang                IN language.id_language%TYPE,
        i_prof                IN profissional,
        i_id_order_set        IN order_set.id_order_set%TYPE,
        i_id_task_links       IN table_table_varchar,
        i_flg_task_link_type  IN table_table_varchar,
        i_id_task_type        IN order_set_task.id_task_type%TYPE,
        o_new_order_set_tasks OUT pk_types.cursor_type,
        o_error               OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task IS TABLE OF order_set_task%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task t_order_set_task;
    
        TYPE t_order_set_task_link IS TABLE OF order_set_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_link t_order_set_task_link;
    
        ibt_id_order_set_tasks table_number := table_number();
    
        l_id_order_set_task order_set_task.id_order_set_task%TYPE;
        l_counter           PLS_INTEGER;
    
        error_unexpected EXCEPTION;
        l_exception      EXCEPTION;
    
    BEGIN
    
        g_error := 'SETUP NEW ORDER SET TASKS';
        -- Setup new tasks
        FOR i IN i_id_task_links.first .. i_id_task_links.last
        LOOP
            l_id_order_set_task := get_order_set_task_seq;
        
            ibt_id_order_set_tasks.extend;
            ibt_id_order_set_tasks(ibt_id_order_set_tasks.count) := l_id_order_set_task;
        
            l_counter := ibt_order_set_task.count + 1;
        
            ibt_order_set_task(l_counter).id_order_set_task := l_id_order_set_task;
            ibt_order_set_task(l_counter).id_order_set := i_id_order_set;
            ibt_order_set_task(l_counter).id_task_type := i_id_task_type;
        
            IF i_id_task_links(i).count > 0
            THEN
                FOR j IN i_id_task_links(i).first .. i_id_task_links(i).last
                LOOP
                    l_counter := ibt_order_set_task_link.count + 1;
                
                    ibt_order_set_task_link(l_counter).id_order_set_task := l_id_order_set_task;
                    ibt_order_set_task_link(l_counter).flg_task_link_type := nvl(i_flg_task_link_type(i) (j),
                                                                                 g_task_link_null);
                    ibt_order_set_task_link(l_counter).id_task_link := i_id_task_links(i) (j);
                END LOOP;
            END IF;
        END LOOP;
    
        g_error := 'INSERT NEW ORDER SET TASKS';
        -- Insert new order set tasks
        IF ibt_order_set_task.count > 0
        THEN
            FORALL i IN ibt_order_set_task.first .. ibt_order_set_task.last
                INSERT INTO order_set_task
                VALUES ibt_order_set_task
                    (i);
        END IF;
    
        g_error := 'INSERT NEW ORDER SET TASK LINKS';
        -- Insert new order set tasks links
        IF ibt_order_set_task_link.count > 0
        THEN
            FORALL i IN ibt_order_set_task_link.first .. ibt_order_set_task_link.last
                INSERT INTO order_set_task_link
                VALUES ibt_order_set_task_link
                    (i);
        END IF;
    
        g_error := 'CALL FUNCTION TO INSERT DEFAULT VALUES ON ORDER SET TASKS DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- call function that will insert default values on task details
        IF NOT
            set_odst_tasks_def_values(i_lang, i_prof, i_id_order_set, ibt_id_order_set_tasks, i_id_task_type, o_error)
        THEN
            RAISE error_unexpected;
        END IF;
    
        -- return new order set tasks
        OPEN o_new_order_set_tasks FOR
            SELECT ibt_id_odst_tsk.column_value id_order_set_task
              FROM TABLE(ibt_id_order_set_tasks) ibt_id_odst_tsk;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting default values on order set task details
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_new_order_set_tasks);
            RETURN FALSE;
            -- Error while inserting DML
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_new_order_set_tasks);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_new_order_set_tasks);
            RETURN FALSE;
    END set_order_set_tasks;

    FUNCTION delete_order_set_tasks
    (
        i_lang               IN language.id_language%TYPE,
        i_prof               IN profissional,
        i_id_order_set_tasks IN table_number,
        o_error              OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- cursor with all predefined tasks
        CURSOR c_modular_tasks IS
            SELECT t_rec_odst_task_req(ost.id_order_set_task, ost.id_task_type, ostl.id_task_link)
              FROM order_set_task ost
              JOIN task_type tt
                ON tt.id_task_type = ost.id_task_type
               AND tt.flg_modular_workflow = g_modular_workflow_support
              JOIN order_set_task_link ostl
                ON ostl.id_order_set_task = ost.id_order_set_task
               AND ostl.flg_task_link_type = get_odst_task_link_type(ost.id_order_set_task) -- to return only the predefined requests
             WHERE ost.id_order_set_task IN (SELECT /*+opt_estimate(table t rows=1)*/
                                              t.column_value
                                               FROM TABLE(i_id_order_set_tasks) t);
        l_modular_tasks t_tbl_odst_task_req;
        l_task_types    table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- handling for predefined tasks (for the task types that supports modular workflows)
        -- get all predefined tasks
        OPEN c_modular_tasks;
        FETCH c_modular_tasks BULK COLLECT
            INTO l_modular_tasks;
        CLOSE c_modular_tasks;
    
        -- get array of distinct task types
        l_task_types := get_task_types(l_modular_tasks);
        -- for each task type, call apis to delete predefined tasks
        FOR i IN 1 .. l_task_types.count
        LOOP
            CASE
            -- delete medication task
                WHEN l_task_types(i) = g_odst_task_medication THEN
                    -- delete predefined tasks
                    IF NOT pk_api_pfh_ordertools_in.delete_medication_task(i_lang     => i_lang,
                                                                           i_prof     => i_prof,
                                                                           i_id_presc => get_task_requests(i_task_type => g_odst_task_medication,
                                                                                                           i_reqs      => l_modular_tasks),
                                                                           o_error    => o_error)
                    THEN
                        g_error := 'error found while calling pk_api_pfh_ordertools_in.delete_medication_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete institutionalized diet task
                WHEN l_task_types(i) = g_odst_task_instit_diet THEN
                    -- delete predefined tasks
                    IF NOT pk_diet.cancel_diet_orderset(i_lang              => i_lang,
                                                        i_prof              => i_prof,
                                                        i_id_diet_prof_inst => get_task_requests(i_task_type => g_odst_task_instit_diet,
                                                                                                 i_reqs      => l_modular_tasks),
                                                        o_error             => o_error)
                    THEN
                        g_error := 'error found while calling pk_diet.cancel_diet_orderset function';
                        RAISE l_exception;
                    END IF;
                
            -- delete lab test task
                WHEN l_task_types(i) = g_odst_task_analysis THEN
                    -- delete predefined tasks
                    IF NOT pk_lab_tests_external_api_db.set_lab_test_delete_task(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_task_request => get_task_requests(i_task_type => g_odst_task_analysis,
                                                                                                                     i_reqs      => l_modular_tasks),
                                                                                 o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_delete_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete image or other exam task
                WHEN l_task_types(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                
                    -- delete predefined tasks
                    IF NOT pk_exams_external_api_db.set_exam_delete_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                    -- delete procedure task
                WHEN l_task_types(i) = g_odst_task_procedure THEN
                
                    -- delete predefined tasks
                    IF NOT pk_procedures_external_api_db.set_procedure_delete_task(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                       i_reqs      => l_modular_tasks),
                                                                                   o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_bp THEN
                
                    -- delete predefined tasks
                    IF NOT pk_bp_external_api_db.set_bp_delete_task(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                        i_reqs      => l_modular_tasks),
                                                                    o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    -- delete predefined hidris tasks
                    IF NOT pk_inp_hidrics_pbl.set_hidric_delete_task(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                         i_reqs      => l_modular_tasks),
                                                                     o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                
                WHEN l_task_types(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                    -- delete predefined communication orders tasks
                    IF NOT pk_comm_orders_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                            i_prof         => i_prof,
                                                                            i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                i_reqs      => l_modular_tasks),
                                                                            o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_com_orders_order_sets.cancel_predefined_task function';
                        RAISE l_exception;
                    END IF;
                
                WHEN l_task_types(i) IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                    -- delete predefined supplies or surgical supplies tasks
                    IF NOT pk_supplies_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_supplies_order_sets.cancel_predefined_task.cancel_predefined_task function';
                        RAISE l_exception;
                    END IF;
                
                WHEN l_task_types(i) IN (g_odst_task_inpatient, g_odst_task_inp_surg) THEN
                    IF NOT pk_admission_request.cancel_predefined_task(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                           i_reqs      => l_modular_tasks),
                                                                       o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_admission_request.cancel_predefined_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_consult THEN
                    -- delete predefined consult task
                    IF NOT pk_opinion.set_opinion_delete_task(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                  i_reqs      => l_modular_tasks),
                                                              o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_opinion.set_opinion_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_patient_education THEN
                    -- delete predefined patient education task
                    IF NOT pk_patient_education_api_db.set_ntr_delete_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                               i_reqs      => l_modular_tasks),
                                                                           o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_opinion.set_opinion_delete_task function';
                        RAISE l_exception;
                    END IF;
                ELSE
                    g_error := 'delete predefined task is not supported for task type [' || l_task_types(i) || ']';
                    RAISE l_exception;
            END CASE;
        END LOOP;
    
        g_error := 'DELETE ORDER SET TASK DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        DELETE FROM order_set_task_detail
         WHERE id_order_set_task IN (SELECT /*+opt_estimate(table tsk rows=1)*/
                                      tsk.column_value
                                       FROM TABLE(i_id_order_set_tasks) tsk);
    
        g_error := 'DELETE ORDER SET GROUP TASK LINKS';
        pk_alertlog.log_debug(g_error, g_package_name);
        DELETE FROM order_set_task_link ostl
         WHERE ostl.flg_task_link_type = g_task_link_group
           AND ostl.id_task_link IN (SELECT odst_tlg.id_task_link
                                       FROM order_set_task_link odst_tlg
                                      WHERE odst_tlg.flg_task_link_type = g_task_link_group
                                        AND odst_tlg.id_order_set_task IN
                                            (SELECT /*+opt_estimate(table tsk rows=1)*/
                                              tsk.column_value
                                               FROM TABLE(i_id_order_set_tasks) tsk));
    
        g_error := 'DELETE ORDER SET TASK LINKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        DELETE FROM order_set_task_link
         WHERE id_order_set_task IN (SELECT /*+opt_estimate(table tsk rows=1)*/
                                      tsk.column_value
                                       FROM TABLE(i_id_order_set_tasks) tsk);
    
        g_error := 'DELETE TASK DEPENDENCIES';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        DELETE FROM order_set_task_dependency odst_tsk_depend
         WHERE odst_tsk_depend.id_order_set_task_from IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_id_order_set_tasks) tsk)
            OR odst_tsk_depend.id_order_set_task_to IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_id_order_set_tasks) tsk);
    
        g_error := 'DELETE ORDER SET TASKS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        DELETE FROM order_set_task
         WHERE id_order_set_task IN (SELECT /*+opt_estimate(table tsk rows=1)*/
                                      tsk.column_value
                                       FROM TABLE(i_id_order_set_tasks) tsk);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'DELETE_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END delete_order_set_tasks;

    FUNCTION delete_order_set_proc_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_order_set_proc_tasks IN table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- cursor with all predefined tasks
        CURSOR c_modular_tasks IS
            SELECT t_rec_odst_task_req(ospt.id_order_set_process_task, ospt.id_task_type, osptl.id_task_link)
              FROM order_set_process_task ospt
              JOIN task_type tt
                ON tt.id_task_type = ospt.id_task_type
               AND tt.flg_modular_workflow = g_modular_workflow_support
              JOIN order_set_process_task_link osptl
                ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
               AND osptl.flg_task_link_type = get_odst_proc_task_link_type(ospt.id_order_set_process_task) -- to return only the predefined requests
             WHERE ospt.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table t rows=1)*/
                     t.column_value
                      FROM TABLE(i_order_set_proc_tasks) t);
        l_modular_tasks t_tbl_odst_task_req;
        l_task_types    table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- handling for predefined tasks (for the task types that supports modular workflows)
        -- get all predefined tasks
        OPEN c_modular_tasks;
        FETCH c_modular_tasks BULK COLLECT
            INTO l_modular_tasks;
        CLOSE c_modular_tasks;
        -- get array of distinct task types
        l_task_types := get_task_types(l_modular_tasks);
        -- for each task type, call apis to delete predefined tasks
        FOR i IN 1 .. l_task_types.count
        LOOP
            CASE
            
            -- delete medication task
                WHEN l_task_types(i) = g_odst_task_medication THEN
                    -- delete predefined tasks
                    IF NOT pk_api_pfh_ordertools_in.delete_medication_task(i_lang     => i_lang,
                                                                           i_prof     => i_prof,
                                                                           i_id_presc => get_task_requests(i_task_type => g_odst_task_medication,
                                                                                                           i_reqs      => l_modular_tasks),
                                                                           o_error    => o_error)
                    THEN
                        g_error := 'error found while calling pk_api_pfh_ordertools_in.delete_medication_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete institutionalized diet task
                WHEN l_task_types(i) = g_odst_task_instit_diet THEN
                    -- delete predefined tasks
                    IF NOT pk_diet.cancel_diet_orderset(i_lang              => i_lang,
                                                        i_prof              => i_prof,
                                                        i_id_diet_prof_inst => get_task_requests(i_task_type => g_odst_task_instit_diet,
                                                                                                 i_reqs      => l_modular_tasks),
                                                        o_error             => o_error)
                    THEN
                        g_error := 'error found while calling pk_diet.cancel_diet_orderset function';
                        RAISE l_exception;
                    END IF;
                
            -- delete lab test task
                WHEN l_task_types(i) = g_odst_task_analysis THEN
                    -- delete predefined tasks
                    IF NOT pk_lab_tests_external_api_db.set_lab_test_delete_task(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_task_request => get_task_requests(i_task_type => g_odst_task_analysis,
                                                                                                                     i_reqs      => l_modular_tasks),
                                                                                 o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_delete_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete procedure task                    
                WHEN l_task_types(i) = g_odst_task_procedure THEN
                
                    -- delete predefined tasks
                    IF NOT pk_procedures_external_api_db.set_procedure_delete_task(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                       i_reqs      => l_modular_tasks),
                                                                                   o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_bp THEN
                
                    -- delete predefined tasks
                    IF NOT pk_bp_external_api_db.set_bp_delete_task(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                        i_reqs      => l_modular_tasks),
                                                                    o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    -- delete predefined hidris tasks
                    IF NOT pk_inp_hidrics_pbl.set_hidric_delete_task(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                         i_reqs      => l_modular_tasks),
                                                                     o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete image or other exam task
                WHEN l_task_types(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                
                    -- delete predefined tasks
                    IF NOT pk_exams_external_api_db.set_exam_delete_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete predefined communication orders tasks
                WHEN l_task_types(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                
                    IF NOT pk_comm_orders_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                            i_prof         => i_prof,
                                                                            i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                i_reqs      => l_modular_tasks),
                                                                            o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_com_orders_order_sets.cancel_predefined_task function';
                        RAISE l_exception;
                    END IF;
                
            -- delete predefined supplies or surgical supplies tasks
                WHEN l_task_types(i) IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                
                    IF NOT pk_supplies_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_supplies_order_sets.cancel_predefined_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_consult THEN
                    -- delete predefined consult task
                    IF NOT pk_opinion.set_opinion_delete_task(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                  i_reqs      => l_modular_tasks),
                                                              o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_opinion.set_opinion_delete_task function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_patient_education THEN
                    -- delete predefined patient education task
                    IF NOT pk_patient_education_api_db.set_ntr_delete_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                               i_reqs      => l_modular_tasks),
                                                                           o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_opinion.set_opinion_delete_task function';
                        RAISE l_exception;
                    END IF;
                ELSE
                    g_error := 'delete predefined task is not supported for task type [' || l_task_types(i) || ']';
                    RAISE l_exception;
            END CASE;
        END LOOP;
    
        g_error := 'DELETE ORDER SET PROCESS TASK DETAILS';
        DELETE FROM order_set_process_task_det osptd
         WHERE osptd.id_order_set_process_task IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_order_set_proc_tasks) tsk);
    
        g_error := 'DELETE ORDER SET PROCESS GROUP TASK LINKS';
        DELETE FROM order_set_process_task_link ostptl
         WHERE ostptl.flg_task_link_type = g_task_link_group
           AND ostptl.id_task_link IN (SELECT odspt_tlg.id_task_link
                                         FROM order_set_process_task_link odspt_tlg
                                        WHERE odspt_tlg.flg_task_link_type = g_task_link_group
                                          AND odspt_tlg.id_order_set_process_task IN
                                              (SELECT /*+opt_estimate(table tsk rows=1)*/
                                                tsk.column_value
                                                 FROM TABLE(i_order_set_proc_tasks) tsk));
    
        g_error := 'DELETE ORDER SET PROCESS TASK LINKS';
        DELETE FROM order_set_process_task_link osptl
         WHERE osptl.id_order_set_process_task IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_order_set_proc_tasks) tsk);
    
        g_error := 'DELETE PROCESS TASK DEPENDENCIES';
        DELETE FROM order_set_process_task_depend odst_proc_tsk_depend
         WHERE odst_proc_tsk_depend.id_order_set_proc_task_from IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_order_set_proc_tasks) tsk)
            OR odst_proc_tsk_depend.id_order_set_proc_task_to IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_order_set_proc_tasks) tsk);
    
        g_error := 'DELETE ORDER SET TASKS';
        DELETE FROM order_set_process_task ospt
         WHERE ospt.id_order_set_process_task IN
               (SELECT /*+opt_estimate(table tsk rows=1)*/
                 tsk.column_value
                  FROM TABLE(i_order_set_proc_tasks) tsk);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'DELETE_ORDER_SET_PROC_TASKS',
                                              o_error);
            RETURN FALSE;
    END delete_order_set_proc_tasks;

    FUNCTION get_order_set_list
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_value      IN VARCHAR2,
        o_order_sets OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_institutions table_number;
    
    BEGIN
    
        g_error := 'GET ALL INSTITUTIONS FROM THE SAME GROUP';
        pk_alertlog.log_debug(g_error, g_package_name);
        l_institutions := table_number(i_prof.institution);
    
        g_error := 'GET CURSOR';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        OPEN o_order_sets FOR
            SELECT odst.id_order_set,
                   odst.title,
                   decode(odst.flg_status, g_order_set_deleted, g_yes, g_no) flg_cancel,
                   -- order set cannot be edited or duplicated when it was created in other than professional's institution
                   decode(odst.id_institution,
                           i_prof.institution,
                           -- professional grants
                           CASE
                                WHEN odst.id_content IS NULL THEN
                                 decode(nvl((SELECT g_available
                                              FROM professional prof_edit
                                             WHERE prof_edit.id_professional = i_prof.id
                                               AND (
                                                   -- verify if professional is the author
                                                    odst.id_professional = i_prof.id OR
                                                   -- verify if professional has the same specialty as the author 
                                                    (odst.flg_edit_permissions = g_order_set_edit_perm_spec AND
                                                    nvl(prof_edit.id_speciality, -1) IN
                                                    nvl((SELECT odst_lnk.id_link
                                                           FROM order_set_link odst_lnk
                                                          WHERE odst_lnk.id_order_set = odst.id_order_set
                                                            AND odst_lnk.flg_link_type = g_order_set_link_spec),
                                                         -1)) OR
                                                   -- verify if professional has the same category as the author
                                                    (odst.flg_edit_permissions = g_order_set_edit_perm_cat AND
                                                    pk_prof_utils.get_id_category(i_lang, i_prof) =
                                                    pk_prof_utils.get_id_category(i_lang,
                                                                                   profissional(odst.id_professional,
                                                                                                i_prof.institution,
                                                                                                i_prof.software))) OR
                                                   -- doesn't matter the specialty or category of the professional
                                                   odst.flg_edit_permissions = g_order_set_edit_perm_all)),
                                           g_not_available),
                                       g_available,
                                       decode(odst.flg_status, g_order_set_deleted, NULL, g_order_set_editable),
                                       NULL)
                               ELSE
                                NULL -- if this order set has an id_content, then edit option should not be possible
                           END || '|' || g_order_set_duplicable || '|' || g_order_set_viewable,
                           g_order_set_viewable) flg_edit_options,
                   -- if this order set has an ID_CONTENT, then there is no professional as its author
                   nvl(pk_prof_utils.get_name_signature(i_lang, i_prof, prof.id_professional),
                       pk_message.get_message(i_lang, g_message_na)) author_desc, -- signature
                   pk_date_utils.date_send_tsz(i_lang, odst.dt_order_set_tstz, i_prof) date_desc
              FROM order_set odst
              LEFT OUTER JOIN professional prof
                ON (odst.id_professional = prof.id_professional)
             WHERE odst.flg_status NOT IN (g_order_set_temp, g_order_set_deprecated)
               AND odst.id_institution IN (SELECT /*+opt_estimate(table inst rows=1)*/
                                            column_value
                                             FROM TABLE(l_institutions) inst)
                  -- ** search for value **
               AND (i_value IS NOT NULL AND
                   (translate(upper(odst.title), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%') OR
                   i_value IS NULL)
             ORDER BY flg_cancel, upper(odst.title);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_order_sets);
            RETURN FALSE;
    END get_order_set_list;

    FUNCTION get_order_set_main_info
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_id_order_set     IN order_set.id_order_set%TYPE,
        o_order_set_info   OUT pk_types.cursor_type,
        o_chief_complaints OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_department_desc       table_varchar;
        l_reason_for_visit_desc table_varchar;
        l_order_set_type_desc   table_varchar;
        l_diagnosis_desc        table_varchar;
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
        CURSOR c_departments IS
            SELECT pk_translation.get_translation(i_lang, d.code_dept) dept_desc
              FROM dept d
              JOIN order_set_link ost_lnk
                ON ost_lnk.id_link = d.id_dept
               AND ost_lnk.flg_link_type = g_order_set_link_envi
             WHERE ost_lnk.id_order_set = i_id_order_set
             ORDER BY dept_desc;
    
        CURSOR c_reasons_for_visit IS
            SELECT pk_translation.get_translation(i_lang, c.code_complaint) reason_for_visit_desc
              FROM complaint c
              JOIN order_set_link ost_lnk
                ON ost_lnk.id_link = c.id_complaint
               AND ost_lnk.flg_link_type = g_order_set_link_reason_visit
             WHERE ost_lnk.id_order_set = i_id_order_set
             ORDER BY reason_for_visit_desc;
    
        CURSOR c_order_set_types IS
            SELECT pk_sys_list.get_sys_list_value_desc(i_lang, i_prof, ost_lnk.id_link) order_set_type_desc
              FROM order_set_link ost_lnk
             WHERE ost_lnk.flg_link_type = g_order_set_link_odst_type
               AND ost_lnk.id_order_set = i_id_order_set
             ORDER BY order_set_type_desc;
    
    BEGIN
    
        g_error := 'GET TASK DESCRIPTIONS';
        -- get department descriptions
        OPEN c_departments;
        FETCH c_departments BULK COLLECT
            INTO l_department_desc;
        CLOSE c_departments;
    
        -- get reasons for visit descriptions
        OPEN c_reasons_for_visit;
        FETCH c_reasons_for_visit BULK COLLECT
            INTO l_reason_for_visit_desc;
        CLOSE c_reasons_for_visit;
    
        -- get order set types descriptions
        OPEN c_order_set_types;
        FETCH c_order_set_types BULK COLLECT
            INTO l_order_set_type_desc;
        CLOSE c_order_set_types;
    
        -- get order set clinical indications/diagnoses descriptions
        SELECT os.clinical_indications
          INTO l_clinical_indications
          FROM order_set os
         WHERE os.id_order_set = i_id_order_set;
    
        -- get diagnosis records
        IF l_clinical_indications IS NOT NULL
        THEN
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                         i_prof   => i_prof,
                                                         i_params => l_clinical_indications);
        
            l_diagnosis_desc := table_varchar();
            l_diagnosis_desc.extend(l_rec_diagnoses.tbl_diagnosis.count);
        
            -- get description of each diagnosis record
            FOR i IN 1 .. l_rec_diagnoses.tbl_diagnosis.count
            LOOP
                l_diagnosis_desc(i) := pk_diagnosis.get_diag_desc(i_lang, i_prof, l_rec_diagnoses.tbl_diagnosis(i));
            END LOOP;
        ELSE
            l_diagnosis_desc := table_varchar();
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET MAIN INFO';
        OPEN o_order_set_info FOR
            SELECT odst.id_order_set,
                   odst.title,
                   odst.author_desc,
                   prof.id_speciality,
                   nvl(pk_prof_utils.get_prof_speciality(i_lang,
                                                         profissional(prof.id_professional,
                                                                      odst.id_institution,
                                                                      odst.id_software)),
                       pk_message.get_message(i_lang, g_message_na)) speciality_desc,
                   odst.flg_target_professionals,
                   odst.flg_edit_permissions,
                   odst.notes_global,
                   trunc_clob_to_varchar2(pk_utils.concat_table_l(l_department_desc, g_separator),
                                          g_trunc_clob_max_size) department_desc,
                   trunc_clob_to_varchar2(pk_utils.concat_table_l(l_reason_for_visit_desc, g_separator),
                                          g_trunc_clob_max_size) reason_for_visit_desc,
                   trunc_clob_to_varchar2(pk_utils.concat_table_l(l_diagnosis_desc, g_separator), g_trunc_clob_max_size) AS diagnoses_desc,
                   trunc_clob_to_varchar2(pk_utils.concat_table_l(l_order_set_type_desc, g_separator),
                                          g_trunc_clob_max_size) order_set_type_desc,
                   pk_sysdomain.get_domain(g_odst_target_profs_domain, odst.flg_target_professionals, i_lang) flg_target_profs_desc,
                   pk_sysdomain.get_domain(g_odst_edit_perms_domain, odst.flg_edit_permissions, i_lang) flg_edit_perms_desc
              FROM order_set odst
              LEFT OUTER JOIN professional prof
                ON (odst.id_professional = prof.id_professional)
             WHERE odst.id_order_set = i_id_order_set;
    
        g_error := 'GET CURSOR WITH ORDER SET CHIEF COMPLAINTS';
        OPEN o_chief_complaints FOR
            SELECT c.id_complaint, pk_translation.get_translation(i_lang, c.code_complaint) chief_complaint_desc
              FROM complaint c
              JOIN order_set_link ost_lnk
                ON ost_lnk.id_link = c.id_complaint
               AND ost_lnk.flg_link_type = g_order_set_link_chief_compl
             WHERE ost_lnk.id_order_set = i_id_order_set
             ORDER BY chief_complaint_desc;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_MAIN_INFO',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_info);
            RETURN FALSE;
    END get_order_set_main_info;

    FUNCTION get_order_set_type_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        i_flg_select   IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_error        OUT t_error_out
    ) RETURN t_tbl_core_domain IS
    
        l_tbl_lst_values t_table_sys_list;
    
        -- order set type list group
        l_odst_type_list_group CONSTANT sys_list_group.id_sys_list_group%TYPE := 15503;
    
        l_ret t_tbl_core_domain;
    
    BEGIN
    
        -- get order set type list values
        l_tbl_lst_values := pk_sys_list.tf_sys_list_values(i_lang              => i_lang,
                                                           i_prof              => i_prof,
                                                           i_id_sys_list_group => l_odst_type_list_group);
    
        g_error := 'OPEN L_RET';
        SELECT *
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t_row_core_domain(internal_name => NULL,
                                         desc_domain   => t.desc_order_set_type,
                                         domain_value  => t.id_order_set_type,
                                         order_rank    => t.rank,
                                         img_name      => NULL)
                  FROM (SELECT id_order_set_type,
                               rank,
                               desc_order_set_type,
                               decode(id_order_set_type,
                                      -1,
                                      decode(COUNT(1)
                                             over(ORDER BY rank RANGE BETWEEN unbounded preceding AND unbounded following) -
                                             SUM(decode(flg_select, pk_alert_constant.g_yes, 1, 0))
                                             over(ORDER BY rank RANGE BETWEEN unbounded preceding AND unbounded following),
                                             1,
                                             pk_alert_constant.g_yes,
                                             flg_select),
                                      flg_select) flg_select
                          FROM (SELECT /*+ opt_estimate(table ost_type rows = 1) */
                                 ost_type.id_sys_list id_order_set_type,
                                 ost_type.rank rank,
                                 ost_type.desc_list desc_order_set_type,
                                 nvl2(osl.id_link, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_select
                                  FROM TABLE(l_tbl_lst_values) ost_type
                                  LEFT OUTER JOIN order_set_link osl
                                    ON (osl.id_link = ost_type.id_sys_list AND osl.id_order_set = i_id_order_set AND
                                       osl.flg_link_type = g_order_set_link_odst_type)
                                UNION ALL
                                SELECT -1 id_order_set_type,
                                       0 rank,
                                       pk_message.get_message(i_lang, 'COMMON_M014') desc_order_set_type,
                                       pk_alert_constant.g_no flg_select
                                  FROM dual)
                         ORDER BY rank, desc_order_set_type) t
                 WHERE t.flg_select = i_flg_select);
    
        RETURN l_ret;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TYPE_LIST',
                                              o_error);
            RETURN t_tbl_core_domain();
    END get_order_set_type_list;

    FUNCTION get_order_set_environment_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE DEFAULT NULL,
        i_institutions IN table_varchar,
        o_error        OUT t_error_out
    ) RETURN t_tbl_core_domain IS
    
        l_tbl_institution table_number := table_number();
        l_count_inst      PLS_INTEGER := 0;
        l_count_dept      PLS_INTEGER := 0;
    
        l_ret t_tbl_core_domain;
    
    BEGIN
    
        FOR i IN i_institutions.first .. i_institutions.last
        LOOP
            l_tbl_institution.extend();
            l_tbl_institution(l_tbl_institution.count) := i_institutions(i);
        END LOOP;
    
        l_count_inst := l_tbl_institution.count();
    
        IF l_count_inst > 0
        THEN
        
            SELECT COUNT(1)
              INTO l_count_dept
              FROM dept d
             WHERE d.id_institution IN (SELECT /*+opt_estimate (table t rows=1)*/
                                         t.*
                                          FROM TABLE(l_tbl_institution) t)
               AND d.id_dept IN (SELECT sd.id_dept
                                   FROM software_dept sd
                                  WHERE sd.id_software IN (pk_alert_constant.g_soft_outpatient,
                                                           pk_alert_constant.g_soft_oris,
                                                           pk_alert_constant.g_soft_primary_care,
                                                           pk_alert_constant.g_soft_edis,
                                                           pk_alert_constant.g_soft_inpatient,
                                                           pk_alert_constant.g_soft_private_practice,
                                                           pk_alert_constant.g_soft_ubu,
                                                           pk_alert_constant.g_soft_nutritionist,
                                                           pk_alert_constant.g_soft_home_care))
               AND d.flg_available = pk_alert_constant.g_yes;
        
            g_error := 'OPEN L_RET';
            SELECT *
              BULK COLLECT
              INTO l_ret
              FROM (SELECT t_row_core_domain(internal_name => NULL,
                                             desc_domain   => t.desc_dep,
                                             domain_value  => t.id_dept,
                                             order_rank    => t.rank,
                                             img_name      => NULL)
                      FROM (SELECT id_dept, rank, desc_dep, flg_select
                              FROM (SELECT t.id_dept,
                                           t.rank,
                                           pk_translation.get_translation(i_lang, t.code_dept) || CASE
                                                WHEN l_count_inst > 1 THEN
                                                 ' - ' || pk_translation.get_translation(i_lang, i.code_institution)
                                            END desc_dep,
                                           flg_select
                                      FROM (SELECT d.id_dept,
                                                   2 rank,
                                                   d.code_dept,
                                                   decode(ost_lnk.id_link, NULL, g_not_selected, g_selected) flg_select,
                                                   d.id_institution
                                              FROM dept d, order_set_link ost_lnk
                                             WHERE d.id_institution IN
                                                   (SELECT /*+opt_estimate (table t rows=1)*/
                                                     t.*
                                                      FROM TABLE(l_tbl_institution) t)
                                               AND d.id_dept IN (SELECT sd.id_dept
                                                                   FROM software_dept sd
                                                                  WHERE sd.id_software IN
                                                                        (pk_alert_constant.g_soft_outpatient,
                                                                         pk_alert_constant.g_soft_oris,
                                                                         pk_alert_constant.g_soft_primary_care,
                                                                         pk_alert_constant.g_soft_edis,
                                                                         pk_alert_constant.g_soft_inpatient,
                                                                         pk_alert_constant.g_soft_private_practice,
                                                                         pk_alert_constant.g_soft_ubu,
                                                                         pk_alert_constant.g_soft_nutritionist,
                                                                         pk_alert_constant.g_soft_home_care))
                                               AND d.flg_available = pk_alert_constant.g_yes
                                               AND ost_lnk.id_link(+) = d.id_dept
                                               AND ost_lnk.id_order_set(+) = i_id_order_set
                                               AND ost_lnk.flg_link_type(+) = g_order_set_link_envi) t
                                      JOIN institution i
                                        ON i.id_institution = t.id_institution
                                    UNION ALL
                                    SELECT -1 id_dept,
                                           1 rank,
                                           pk_message.get_message(i_lang, g_message_all) desc_dep,
                                           g_not_selected flg_select
                                      FROM dual
                                     WHERE l_count_dept > 1)
                             ORDER BY rank, desc_dep) t
                     WHERE (i_id_order_set IS NULL AND flg_select = pk_alert_constant.g_no)
                        OR (i_id_order_set IS NOT NULL AND flg_select = pk_alert_constant.g_yes));
        END IF;
    
        RETURN l_ret;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_ENVIRONMENT_LIST',
                                              o_error);
            RETURN t_tbl_core_domain();
    END get_order_set_environment_list;

    FUNCTION get_order_set_task_type_list
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set         IN order_set.id_order_set%TYPE,
        o_order_set_task_types OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'GET CURSOR WITH ORDER SET TASK TYPES';
        OPEN o_order_set_task_types FOR
            SELECT id_task_type,
                   id_task_type_parent,
                   upper(substr(task_type_desc, 1, 1)) || substr(task_type_desc, 2) task_type_desc,
                   icon,
                   flg_type,
                   id_target_task_type,
                   flg_active,
                   rank,
                   translate(upper(task_type_desc), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') task_type_desc_rank
              FROM (SELECT tsk_type.id_task_type,
                            get_task_type_parent(i_lang, i_prof, tsk_type.id_task_type) id_task_type_parent,
                            pk_translation.get_translation(i_lang, tsk_type.code_task_type) task_type_desc,
                            tsk_type.icon,
                            tsk_type.flg_type,
                            tsk_type.id_target_task_type,
                            -- the order set can't have more than one task of "discharge instruction" type
                           decode(tsk_type.id_task_type,
                                  g_odst_task_discharge_instruct,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_discharge_instruct
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_intake,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_intake
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_intake_output,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_intake_output
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_urinary_output,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_urinary_output
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_drainage_records,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_drainage_records
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_all_output,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_all_output
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_odst_task_irrigation,
                                  nvl((SELECT g_inactive
                                        FROM order_set_task odst_tsk
                                       WHERE odst_tsk.id_task_type = g_odst_task_irrigation
                                         AND odst_tsk.id_order_set = i_id_order_set),
                                      g_active),
                                  g_active) flg_active,
                           1 rank
                      FROM task_type tsk_type
                     WHERE check_order_set_task_avail(i_lang, i_prof, tsk_type.id_task_type) = g_available
                    UNION ALL
                    SELECT -1 id_task_type,
                           NULL id_task_type_parent,
                           pk_message.get_message(i_lang, g_message_order_set_tasks) task_type_desc,
                           NULL icon,
                           NULL flg_type,
                           NULL id_target_task_type,
                           g_active flg_active,
                           3 rank
                      FROM dual)
             ORDER BY rank, task_type_desc_rank;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASK_TYPE_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_task_types);
            RETURN FALSE;
    END get_order_set_task_type_list;

    FUNCTION get_dependency_types
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE,
        o_list           OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
        l_relationships pk_types.cursor_type;
    
        l_rec_dep        t_rec_odst_depend_type_list := t_rec_odst_depend_type_list(NULL, NULL, NULL);
        l_dep_types_list t_tbl_odst_depend_type_list := t_tbl_odst_depend_type_list();
        l_dep_index      PLS_INTEGER := 0;
    
        -- gets type of the order set task
        l_task_type task_type.id_task_type%TYPE := get_odst_task_type(i_lang, i_prof, i_order_set_task);
    
    BEGIN
    
        g_error := 'GET TDE RELATIONSHIP TYPES';
        IF NOT pk_tde_db.get_relationship_types(i_lang, i_prof, l_task_type, l_relationships, o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'FETCH ALL DEPENDENCY TYPE RECORDS';
        -- cursor l_relationships is already open
        LOOP
            FETCH l_relationships
                INTO l_rec_dep.id_relationship_type, l_rec_dep.relationship_type_desc, l_rec_dep.internal_name;
        
            EXIT WHEN l_relationships%NOTFOUND;
        
            -- extend dependecies type array and assign a new relationship type
            l_dep_types_list.extend;
            l_dep_index := l_dep_index + 1;
            l_dep_types_list(l_dep_index) := t_rec_odst_depend_type_list(l_rec_dep.id_relationship_type,
                                                                         l_rec_dep.relationship_type_desc,
                                                                         l_rec_dep.internal_name);
        
        END LOOP;
        CLOSE l_relationships;
    
        g_error := 'GET CURSOR WITH THE LIST OF DEPENDENCY TYPES';
        OPEN o_list FOR
            SELECT dep_types_list.id_relationship_type dependency_type_value,
                   pk_tde_db.get_relationship_type_desc(i_lang, dep_types_list.id_relationship_type) dependency_type_desc,
                   decode(dep_types_list.id_relationship_type,
                          pk_alert_constant.g_tde_rel_start2start,
                          pk_alert_constant.g_yes,
                          pk_alert_constant.g_no) flg_first_line
              FROM TABLE(CAST(l_dep_types_list AS t_tbl_odst_depend_type_list)) dep_types_list;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_DEPENDENCY_TYPES',
                                              o_error);
        
            pk_types.open_my_cursor(o_list);
            RETURN FALSE;
        
    END get_dependency_types;

    FUNCTION get_task_dependencies_list
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_order_set_task        IN order_set_task.id_order_set_task%TYPE,
        i_dependency_type       IN order_set_task_dependency.id_relationship_type%TYPE,
        i_popup_dependency_type IN table_number,
        i_popup_dependency      IN table_number,
        i_tasks_rank            IN table_number,
        o_dependencies_list     OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_popup_null_lags table_number := table_number();
    
    BEGIN
    
        -- fill lag array with empty values
        IF i_popup_dependency_type.count > 0
        THEN
            l_popup_null_lags.extend(i_popup_dependency_type.count);
        END IF;
    
        -- get task dependencies network
        IF NOT get_task_depends_network(i_lang                   => i_lang,
                                        i_prof                   => i_prof,
                                        i_order_set_task         => i_order_set_task,
                                        i_popup_dependency_type  => i_popup_dependency_type,
                                        i_popup_dependency       => i_popup_dependency,
                                        i_popup_lag_min          => l_popup_null_lags,
                                        i_popup_lag_max          => l_popup_null_lags,
                                        i_popup_lag_unit_measure => l_popup_null_lags,
                                        o_dependency_type        => l_dependency_type,
                                        o_task_dependency_from   => l_task_dependency_from,
                                        o_task_dependency_to     => l_task_dependency_to,
                                        o_task_type_from         => l_task_type_from,
                                        o_task_type_to           => l_task_type_to,
                                        o_task_schedule_from     => l_task_schedule_from,
                                        o_task_schedule_to       => l_task_schedule_to,
                                        o_lag_min                => l_lag_min,
                                        o_lag_max                => l_lag_max,
                                        o_lag_unit_measure       => l_lag_unit_measure,
                                        o_error                  => o_error)
        
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET CURSOR WITH THE DEPENDENCIES LIST OF THE ORDER SET TASK';
        OPEN o_dependencies_list FOR
            SELECT odst_tsk_depends.id_order_set_task dependency_value,
                   (CASE odst_tsk_depends.id_order_set_task
                       WHEN to_number(g_depend_current_epis) THEN
                        pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_current_epis, i_lang)
                       WHEN to_number(g_depend_future_epis) THEN
                        pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_future_epis, i_lang)
                       ELSE
                        get_task_rank(i_tasks_rank, odst_tsk_depends.id_order_set_task) || ' - ' ||
                        get_task_desc(i_lang,
                                      i_prof,
                                      odst_tsk_depends.id_order_set_task,
                                      odst_tsk_depends.id_task_type,
                                      pk_alert_constant.g_no,
                                      pk_alert_constant.g_no,
                                      g_task_desc_detail_format,
                                      pk_alert_constant.g_no)
                   END) dependency_desc,
                   pk_tde_db.validate_dependency_option(i_lang,
                                                        l_dependency_type,
                                                        l_task_dependency_from,
                                                        l_task_dependency_to,
                                                        l_task_type_from,
                                                        l_task_type_to,
                                                        l_task_schedule_from,
                                                        l_task_schedule_to,
                                                        i_dependency_type,
                                                        odst_tsk_depends.id_order_set_task,
                                                        odst_tsk_current.id_order_set_task,
                                                        odst_tsk_depends.id_task_type,
                                                        odst_tsk_current.id_task_type,
                                                        odst_tsk_depends.task_schedule,
                                                        odst_tsk_current.task_schedule) flg_enable,
                   -- if the task and its dependency are not episodes, then lag values must be equal
                   pk_tde_db.single_lag_enable(odst_tsk_depends.id_task_type,
                                               odst_tsk_current.id_task_type,
                                               odst_tsk_depends.task_schedule,
                                               odst_tsk_current.task_schedule) flg_single_lag_enable,
                   -- indicates if the lag fields should be enabled or not
                   pk_tde_db.lag_support_enable(i_dependency_type,
                                                odst_tsk_depends.id_task_type,
                                                odst_tsk_current.id_task_type) flg_lag_support_enable
              FROM -- current task
                   (SELECT odst_tsk.id_order_set,
                           odst_tsk.id_order_set_task,
                           odst_tsk.id_task_type,
                           check_episode_support_task(i_lang,
                                                      i_prof,
                                                      l_dependency_type,
                                                      l_task_dependency_from,
                                                      l_task_dependency_to,
                                                      odst_tsk.id_order_set_task,
                                                      odst_tsk.id_task_type) task_schedule
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set_task = i_order_set_task) odst_tsk_current
             INNER JOIN (
                         -- add order set tasks to dependencies list
                         SELECT odst_tsk.id_order_set,
                                 odst_tsk.id_order_set_task,
                                 odst_tsk.id_task_type,
                                 check_episode_support_task(i_lang,
                                                            i_prof,
                                                            l_dependency_type,
                                                            l_task_dependency_from,
                                                            l_task_dependency_to,
                                                            odst_tsk.id_order_set_task,
                                                            odst_tsk.id_task_type) task_schedule
                           FROM order_set_task odst_tsk
                          INNER JOIN order_set_task odst_tsk_current
                             ON odst_tsk.id_order_set = odst_tsk_current.id_order_set
                          WHERE odst_tsk_current.id_order_set_task = i_order_set_task
                         UNION ALL
                         -- add current episode option to dependencies list
                         SELECT NULL id_order_set,
                                 to_number(g_depend_current_epis) id_order_set_task,
                                 pk_alert_constant.g_task_current_epis id_task_type,
                                 pk_alert_constant.g_yes task_schedule
                           FROM dual
                         UNION ALL
                         -- add future episode option to dependencies list
                         SELECT NULL id_order_set,
                                 to_number(g_depend_future_epis) id_order_set_task,
                                 pk_alert_constant.g_task_future_epis id_task_type,
                                 pk_alert_constant.g_yes task_schedule
                           FROM dual) odst_tsk_depends
                ON odst_tsk_current.id_order_set = nvl(odst_tsk_depends.id_order_set, odst_tsk_current.id_order_set)
             WHERE
            -- the task itself is not shown on the list
             odst_tsk_depends.id_order_set_task != i_order_set_task
             ORDER BY get_task_rank(i_tasks_rank, odst_tsk_depends.id_order_set_task) NULLS FIRST, dependency_desc;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_TASK_DEPENDENCIES_LIST',
                                              o_error);
        
            pk_types.open_my_cursor(o_dependencies_list);
        
            RETURN FALSE;
    END get_task_dependencies_list;

    FUNCTION get_hdrcs_tsk_tp_by_tsk_ty(i_task_type task_type.id_task_type%TYPE) RETURN NUMBER IS
    
        l_hidrics_task_type task_type.id_target_task_type%TYPE;
    
    BEGIN
    
        SELECT id_target_task_type
          INTO l_hidrics_task_type
          FROM task_type
         WHERE id_task_type = i_task_type;
    
        RETURN l_hidrics_task_type;
    
    END get_hdrcs_tsk_tp_by_tsk_ty;

    FUNCTION get_odst_task_dependencies
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_order_set_task IN order_set_task.id_order_set_task%TYPE,
        i_tasks_rank     IN table_number,
        o_dependencies   OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
        -- gets type of the order set task 
        l_task_type     task_type.id_task_type%TYPE := get_odst_task_type(i_lang, i_prof, i_order_set_task);
        l_task_schedule VARCHAR2(1 CHAR);
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
        l_x1                   NUMBER := pk_alert_constant.g_tde_rel_start2start;
        l_x2                   VARCHAR2(4000) := pk_tde_db.get_relationship_type_desc(i_lang,
                                                                                      pk_alert_constant.g_tde_rel_start2start);
        l_x3                   NUMBER := to_number(g_depend_current_epis);
        l_x4                   VARCHAR2(4000) := pk_sysdomain.get_domain(g_dependency_episode_domain,
                                                                         g_depend_current_epis,
                                                                         i_lang);
    
    BEGIN
    
        g_error := 'GET ORDER SET TASK DEPENDENCIES';
        -- get task dependencies network
        IF NOT get_task_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_order_set_task       => i_order_set_task,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        
        THEN
            RAISE l_exception;
        END IF;
    
        -- get some order set task details    
        l_task_schedule := check_episode_support_task(i_lang,
                                                      i_prof,
                                                      l_dependency_type,
                                                      l_task_dependency_from,
                                                      l_task_dependency_to,
                                                      i_order_set_task,
                                                      l_task_type);
    
        g_error := 'GET CURSOR WITH ALL DEPENDENCIES OF THE ORDER SET TASK';
        OPEN o_dependencies FOR
        -- get all task dependencies
            SELECT dependency_type_value,
                   dependency_type_desc,
                   dependency_value,
                   dependency_desc,
                   lag_min_value,
                   lag_min_desc,
                   lag_max_value,
                   lag_max_desc,
                   lag_unit_measure,
                   flg_remove,
                   flg_single_lag_enable,
                   flg_lag_support_enable
              FROM (SELECT id_relationship_type dependency_type_value,
                            pk_tde_db.get_relationship_type_desc(i_lang, id_relationship_type) dependency_type_desc,
                            id_order_set_task_from dependency_value,
                            (CASE id_order_set_task_from
                                WHEN to_number(g_depend_current_epis) THEN
                                 pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_current_epis, i_lang)
                                WHEN to_number(g_depend_future_epis) THEN
                                 pk_sysdomain.get_domain(g_dependency_episode_domain, g_depend_future_epis, i_lang)
                                ELSE
                                 get_task_rank(i_tasks_rank, id_order_set_task_from) || ' - ' ||
                                 get_task_desc(i_lang,
                                               i_prof,
                                               id_order_set_task_from,
                                               id_task_type_from,
                                               pk_alert_constant.g_no,
                                               pk_alert_constant.g_no,
                                               g_task_desc_short_format,
                                               pk_alert_constant.g_no)
                            END) dependency_desc,
                            lag_min lag_min_value,
                            lag_min || ' ' ||
                            nvl2(lag_min,
                                 pk_unit_measure.get_unit_measure_description(i_lang, i_prof, id_unit_measure_lag),
                                 NULL) lag_min_desc,
                            lag_max lag_max_value,
                            lag_max || ' ' ||
                            nvl2(lag_max,
                                 pk_unit_measure.get_unit_measure_description(i_lang, i_prof, id_unit_measure_lag),
                                 NULL) lag_max_desc,
                            id_unit_measure_lag lag_unit_measure,
                            -- start-to-start dependencies cannot be removed
                            decode(id_relationship_type,
                                   pk_alert_constant.g_tde_rel_start2start,
                                   pk_alert_constant.g_no,
                                   pk_alert_constant.g_yes) flg_remove,
                            -- if the task and its dependency are not episodes, then lag values must be equal
                            pk_tde_db.single_lag_enable(id_task_type_from,
                                                        l_task_type,
                                                        check_episode_support_task(i_lang,
                                                                                   i_prof,
                                                                                   l_dependency_type,
                                                                                   l_task_dependency_from,
                                                                                   l_task_dependency_to,
                                                                                   id_order_set_task_from,
                                                                                   id_task_type_from),
                                                        l_task_schedule) flg_single_lag_enable,
                            -- indicates if the lag fields should be enabled or not
                            pk_tde_db.lag_support_enable(id_relationship_type, id_task_type_from, l_task_type) flg_lag_support_enable
                       FROM (SELECT odst_tsk_dep.id_relationship_type id_relationship_type,
                                    odst_tsk_dep.id_order_set_task_from id_order_set_task_from,
                                    odst_tsk_dep.id_order_set_task_to id_order_set_task_to,
                                    odst_tsk_dep.lag_min lag_min,
                                    odst_tsk_dep.lag_max lag_max,
                                    odst_tsk_dep.id_unit_measure_lag id_unit_measure_lag,
                                    nvl(odst_tsk_from.id_task_type,
                                        decode(odst_tsk_dep.id_order_set_task_from,
                                               to_number(g_depend_current_epis),
                                               pk_alert_constant.g_task_current_epis,
                                               to_number(g_depend_future_epis),
                                               pk_alert_constant.g_task_future_epis)) id_task_type_from
                               FROM order_set_task_dependency odst_tsk_dep
                               LEFT OUTER JOIN order_set_task odst_tsk_from
                                 ON odst_tsk_dep.id_order_set_task_from = odst_tsk_from.id_order_set_task
                              WHERE odst_tsk_dep.id_order_set_task_to = i_order_set_task)
                     UNION ALL
                     
                     -- show default start-to-start dependency if it not exists (current episode dependency)
                     SELECT l_x1 dependency_type_value,
                            l_x2 dependency_type_desc,
                            l_x3 dependency_value,
                            l_x4 dependency_desc,
                            NULL lag_min_value,
                            NULL lag_min_desc,
                            NULL lag_max_value,
                            NULL lag_max_desc,
                            NULL lag_unit_measure,
                            g_no flg_remove,
                            -- if the task and its dependency are not episodes, then lag values must be equal
                            pk_tde_db.single_lag_enable(pk_alert_constant.g_task_current_epis,
                                                        l_task_type,
                                                        check_episode_support_task(i_lang,
                                                                                   i_prof,
                                                                                   l_dependency_type,
                                                                                   l_task_dependency_from,
                                                                                   l_task_dependency_to,
                                                                                   to_number(g_depend_current_epis),
                                                                                   pk_alert_constant.g_task_current_epis),
                                                        l_task_schedule) flg_single_lag_enable,
                            -- indicates if the lag fields should be enabled or not
                            pk_tde_db.lag_support_enable(pk_alert_constant.g_tde_rel_start2start,
                                                         pk_alert_constant.g_task_current_epis,
                                                         l_task_type) flg_lag_support_enable
                       FROM dual
                      WHERE 0 = 0
                           -- this task doesn't have yet a start2start relationship
                       AND pk_alert_constant.g_tde_rel_start2start = 1
                       AND NOT EXISTS
                     (SELECT 1
                              FROM order_set_task_dependency odst_tsk_dep
                             WHERE odst_tsk_dep.id_order_set_task_to = i_order_set_task
                               AND odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start)
                          -- this task supports start2start relationships and is not an episode task
                       AND EXISTS
                     (SELECT 1
                              FROM task_type tsk_type
                             WHERE tsk_type.id_task_type = l_task_type
                               AND tsk_type.flg_dependency_support IN
                                   (pk_alert_constant.g_tt_tde_rel_all, pk_alert_constant.g_tt_tde_rel_start2start)
                               AND tsk_type.flg_episode_task != pk_alert_constant.g_tt_tde_support_epis))
             ORDER BY dependency_type_value, get_task_rank(i_tasks_rank, dependency_value) NULLS FIRST;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_TASK_DEPENDENCIES',
                                              o_error);
        
            pk_types.open_my_cursor(o_dependencies);
        
            RETURN FALSE;
        
    END get_odst_task_dependencies;

    FUNCTION check_task_dependencies
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_task         IN order_set_task.id_order_set_task%TYPE,
        i_popup_dependency_type  IN table_number,
        i_popup_dependency       IN table_number,
        i_popup_lag_min          IN table_number,
        i_popup_lag_max          IN table_number,
        i_popup_lag_unit_measure IN table_number,
        i_tasks_rank             IN table_number,
        o_flg_conflict           OUT VARCHAR,
        o_msg_title              OUT VARCHAR,
        o_msg_body               OUT VARCHAR,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_msg_body sys_message.desc_message%TYPE;
    
        l_exception EXCEPTION;
    
        -- function used to replace dependencies references
        -- existing in a message, by its description
        FUNCTION replace_dependencies_refs(i_msg sys_message.desc_message%TYPE) RETURN VARCHAR2 IS
        
            l_msg                  sys_message.desc_message%TYPE := i_msg;
            l_begin_ref_position   NUMBER;
            l_end_ref_position     NUMBER;
            l_dependency_reference order_set_task.id_order_set_task%TYPE;
            l_desc_reference       VARCHAR2(200 CHAR);
        BEGIN
        
            -- verify if the message is null        
            IF l_msg IS NULL
            THEN
                RETURN NULL;
            END IF;
        
            -- loop for each replace dependency reference
            LOOP
                -- search for next dependency reference
                l_begin_ref_position := instr(l_msg, '@');
            
                -- exit if no more references were found
                EXIT WHEN l_begin_ref_position = 0;
            
                -- get end position of the dependency reference
                l_end_ref_position := instr(l_msg, ']', l_begin_ref_position);
            
                -- get dependency reference
                l_dependency_reference := to_number(substr(l_msg,
                                                           l_begin_ref_position + 2,
                                                           l_end_ref_position - l_begin_ref_position - 2));
            
                -- get dependency reference description
                l_desc_reference := (CASE l_dependency_reference
                                        WHEN to_number(g_depend_current_epis) THEN
                                         pk_sysdomain.get_domain(g_dependency_episode_domain,
                                                                 g_depend_current_epis,
                                                                 i_lang)
                                        WHEN to_number(g_depend_future_epis) THEN
                                         pk_sysdomain.get_domain(g_dependency_episode_domain,
                                                                 g_depend_future_epis,
                                                                 i_lang)
                                        ELSE
                                         get_task_desc(i_lang,
                                                       i_prof,
                                                       l_dependency_reference,
                                                       get_odst_task_type(i_lang, i_prof, l_dependency_reference),
                                                       pk_alert_constant.g_no,
                                                       pk_alert_constant.g_no,
                                                       g_task_desc_short_format,
                                                       pk_alert_constant.g_no)
                                    END);
            
                -- replace dependency reference by its description
                l_msg := REPLACE(l_msg,
                                 '@[' || to_char(l_dependency_reference) || ']',
                                 '<b>' || get_task_rank(i_tasks_rank, l_dependency_reference) || ' - ' ||
                                 l_desc_reference || '</b>');
            END LOOP;
        
            RETURN l_msg;
        
        END replace_dependencies_refs;
    
    BEGIN
    
        g_error := 'CHECK TASK DEPENDENCIES';
        -- get task dependencies network
        IF NOT get_task_depends_network(i_lang                   => i_lang,
                                        i_prof                   => i_prof,
                                        i_order_set_task         => i_order_set_task,
                                        i_popup_dependency_type  => i_popup_dependency_type,
                                        i_popup_dependency       => i_popup_dependency,
                                        i_popup_lag_min          => i_popup_lag_min,
                                        i_popup_lag_max          => i_popup_lag_max,
                                        i_popup_lag_unit_measure => i_popup_lag_unit_measure,
                                        o_dependency_type        => l_dependency_type,
                                        o_task_dependency_from   => l_task_dependency_from,
                                        o_task_dependency_to     => l_task_dependency_to,
                                        o_task_type_from         => l_task_type_from,
                                        o_task_type_to           => l_task_type_to,
                                        o_task_schedule_from     => l_task_schedule_from,
                                        o_task_schedule_to       => l_task_schedule_to,
                                        o_lag_min                => l_lag_min,
                                        o_lag_max                => l_lag_max,
                                        o_lag_unit_measure       => l_lag_unit_measure,
                                        o_error                  => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- verify if the dependencies network is not empty
        IF l_dependency_type.count > 0
        THEN
            -- validate task dependencies according to TDE rules
            IF NOT pk_tde_db.validate_dependencies(i_lang                 => i_lang,
                                                   i_relationship_type    => l_dependency_type,
                                                   i_task_dependency_from => l_task_dependency_from,
                                                   i_task_dependency_to   => l_task_dependency_to,
                                                   i_task_type_from       => l_task_type_from,
                                                   i_task_type_to         => l_task_type_to,
                                                   i_task_schedule_from   => l_task_schedule_from,
                                                   i_task_schedule_to     => l_task_schedule_to,
                                                   i_lag_min              => l_lag_min,
                                                   i_lag_max              => l_lag_max,
                                                   i_unit_measure_lag     => l_lag_unit_measure,
                                                   o_flg_conflict         => o_flg_conflict,
                                                   o_msg_title            => o_msg_title,
                                                   o_msg_body             => l_msg_body,
                                                   o_error                => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        -- replace existing dependencies references by its description
        o_msg_body := replace_dependencies_refs(l_msg_body);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_TASK_DEPENDENCIES',
                                              o_error);
            RETURN FALSE;
    END check_task_dependencies;

    FUNCTION set_task_dependencies
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_order_set        IN order_set.id_order_set%TYPE,
        i_order_set_task   IN order_set_task.id_order_set_task%TYPE,
        i_dependency_type  IN table_number,
        i_dependency       IN table_number,
        i_lag_min          IN table_number,
        i_lag_max          IN table_number,
        i_lag_unit_measure IN table_number,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task_dependency IS TABLE OF order_set_task_dependency%ROWTYPE; -- INDEX BY PLS_INTEGER;
        ibt_order_set_task_dependency t_order_set_task_dependency := t_order_set_task_dependency();
        l_index                       PLS_INTEGER := 0;
    
        l_num_unselected_predecessors NUMBER;
    
    BEGIN
    
        g_error := 'DELETE OLD TASK DEPENDENCIES';
        DELETE FROM order_set_task_dependency
         WHERE id_order_set_task_to = i_order_set_task;
    
        IF i_dependency_type.count > 0
        THEN
            g_error := 'LOAD DEPENDENCIES COLLECTION';
            FOR i IN i_dependency_type.first .. i_dependency_type.last
            LOOP
                -- do not store s2s relations to the current episode, except if lags are defined
                IF NOT (i_dependency_type(i) = pk_alert_constant.g_tde_rel_start2start AND
                    i_dependency(i) = to_number(g_depend_current_epis) AND i_lag_min(i) IS NULL AND
                    i_lag_max(i) IS NULL)
                THEN
                    ibt_order_set_task_dependency.extend;
                    l_index := l_index + 1;
                
                    ibt_order_set_task_dependency(l_index).id_relationship_type := i_dependency_type(i);
                    ibt_order_set_task_dependency(l_index).id_order_set_task_from := i_dependency(i);
                    ibt_order_set_task_dependency(l_index).id_order_set_task_to := i_order_set_task;
                    ibt_order_set_task_dependency(l_index).lag_min := CASE i_lag_min(i)
                                                                          WHEN -1 THEN
                                                                           NULL
                                                                          ELSE
                                                                           i_lag_min(i)
                                                                      END;
                    ibt_order_set_task_dependency(l_index).lag_max := CASE i_lag_max(i)
                                                                          WHEN -1 THEN
                                                                           NULL
                                                                          ELSE
                                                                           i_lag_min(i)
                                                                      END;
                    ibt_order_set_task_dependency(l_index).id_unit_measure_lag := i_lag_unit_measure(i);
                    ibt_order_set_task_dependency(l_index).id_order_set := i_order_set;
                END IF;
            END LOOP;
        
        END IF;
    
        g_error := 'SET DEPENDENCIES';
        IF ibt_order_set_task_dependency.count > 0
        THEN
            FORALL i IN ibt_order_set_task_dependency.first .. ibt_order_set_task_dependency.last
                INSERT INTO order_set_task_dependency
                VALUES ibt_order_set_task_dependency
                    (i);
        END IF;
    
        -- verify if the order set task is selected
        IF get_task_presel(i_lang, i_prof, i_order_set_task) = pk_alert_constant.g_yes
        THEN
        
            -- get number of unselected predecessors
            SELECT COUNT(1)
              INTO l_num_unselected_predecessors
              FROM order_set_task_dependency odst_tsk_depend
             WHERE odst_tsk_depend.id_order_set_task_to = i_order_set_task
               AND odst_tsk_depend.id_order_set_task_from NOT IN
                   (to_number(g_depend_future_epis), to_number(g_depend_current_epis))
               AND get_task_presel(i_lang, i_prof, odst_tsk_depend.id_order_set_task_from) = pk_alert_constant.g_no;
        
            -- if at least one predecessor is unselected
            IF l_num_unselected_predecessors > 0
            THEN
            
                -- forces order set task as unselected
                UPDATE order_set_task_detail odst_tsk_det
                   SET odst_tsk_det.vvalue = pk_alert_constant.g_no
                 WHERE odst_tsk_det.id_advanced_input_field = g_adv_input_field_selected
                   AND odst_tsk_det.id_order_set_task = i_order_set_task;
            END IF;
        
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting DML
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_TASK_DEPENDENCIES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_TASK_DEPENDENCIES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_task_dependencies;

    FUNCTION get_order_set_tasks
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_order_set    IN order_set_task.id_order_set%TYPE,
        o_order_set_tasks OUT pk_types.cursor_type,
        o_tasks_rank      OUT table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tasks_rank table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ORDER SET TASKS RANK';
        -- get order set dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- copy tasks rank array to the output parameter
        o_tasks_rank := l_tasks_rank;
    
        g_error := 'GET CURSOR WITH ORDER SET TASKS';
        OPEN o_order_set_tasks FOR
            SELECT nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                   task_group_desc,
                   task_group_tooltip,
                   task_group_rank,
                   task_group_ids,
                   id_order_set_task,
                   id_task_type,
                   task_type_desc,
                   get_task_type_icon(i_lang,
                                      i_prof,
                                      id_task_type,
                                      id_order_set_task,
                                      pk_alert_constant.g_no,
                                      flg_episode_task) icon,
                   '<b>' || dependency_order || ' - </b>' ||
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_task,
                                 id_task_type,
                                 pk_alert_constant.g_no,
                                 pk_alert_constant.g_yes,
                                 g_task_desc_extended_format,
                                 pk_alert_constant.g_no) task_desc,
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_task,
                                 id_task_type,
                                 pk_alert_constant.g_no,
                                 pk_alert_constant.g_no,
                                 g_task_desc_short_format,
                                 pk_alert_constant.g_no) task_title,
                   task_instruct,
                   flg_ok,
                   task_link_type,
                   parent_task_id,
                   upper(substr(pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || parent_task_id),
                                1,
                                1)) ||
                   substr(pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || parent_task_id), 2) parent_task_desc,
                   dependency_order,
                   icon_dep_name,
                   dependency_desc,
                   flg_support_dependencies,
                   pk_alert_constant.g_yes flg_edit,
                   flg_task_selected,
                   pk_sysdomain.get_domain(g_odst_tsks_order_stat_domain, flg_task_selected, i_lang) order_status_desc,
                   id_task_link
              FROM (SELECT odst_tsk.id_order_set_task,
                           odst_tsk.id_task_type,
                           get_order_set_task_group_desc(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_desc,
                           get_order_set_tsk_grp_tooltip(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_tooltip,
                           get_order_set_task_group_rank(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_rank,
                           get_order_set_task_group_ids(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_ids,
                           upper(substr(pk_translation.get_translation(i_lang,
                                                                       'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                       odst_tsk.id_task_type),
                                        1,
                                        1)) ||
                           substr(pk_translation.get_translation(i_lang,
                                                                 'TASK_TYPE.CODE_TASK_TYPE.' || odst_tsk.id_task_type),
                                  2) task_type_desc,
                           check_episode_support_task(i_lang,
                                                      i_prof,
                                                      l_dependency_type,
                                                      l_task_dependency_from,
                                                      l_task_dependency_to,
                                                      odst_tsk.id_order_set_task,
                                                      odst_tsk.id_task_type) flg_episode_task,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_tsk.id_order_set_task),
                                                      pk_alert_constant.g_no) task_instruct,
                           check_mandatory_fields(i_lang,
                                                  i_prof,
                                                  odst_tsk.id_order_set_task,
                                                  odst_tsk.id_task_type,
                                                  pk_alert_constant.g_no) flg_ok,
                           decode(get_odst_task_link_type(odst_tsk.id_order_set_task),
                                  g_task_link_null,
                                  NULL,
                                  get_odst_task_link_type(odst_tsk.id_order_set_task)) task_link_type,
                           get_task_type_parent(i_lang, i_prof, odst_tsk.id_task_type) parent_task_id,
                           get_task_rank(l_tasks_rank, odst_tsk.id_order_set_task) dependency_order,
                           nvl2(odst_tsk_dep.id_order_set_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                           replace_dependencies_refs_rank(i_lang,
                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                           i_prof,
                                                                                           odst_tsk.id_order_set_task,
                                                                                           check_episode_support_task(i_lang,
                                                                                                                      i_prof,
                                                                                                                      l_dependency_type,
                                                                                                                      l_task_dependency_from,
                                                                                                                      l_task_dependency_to,
                                                                                                                      odst_tsk.id_order_set_task,
                                                                                                                      odst_tsk.id_task_type),
                                                                                           l_tasks_rank,
                                                                                           l_dependency_type,
                                                                                           l_task_dependency_from,
                                                                                           l_task_dependency_to,
                                                                                           l_task_type_from,
                                                                                           l_task_type_to,
                                                                                           l_task_schedule_from,
                                                                                           l_task_schedule_to,
                                                                                           l_lag_min,
                                                                                           l_lag_max,
                                                                                           l_lag_unit_measure),
                                                          l_tasks_rank) dependency_desc,
                           -- for tasks that does not support dependencies, edit dependencies option must be disabled
                           (CASE
                                WHEN tsk_type.flg_dependency_support = pk_alert_constant.g_tt_tde_rel_none THEN
                                 pk_alert_constant.g_no
                                ELSE
                                 pk_alert_constant.g_yes
                            END) flg_support_dependencies,
                           get_task_presel(i_lang, i_prof, odst_tsk.id_order_set_task) flg_task_selected,
                          -- CASE
                            --Consults, Health_education, Procedures, Hidrics, Blood products, etc.
                              --  WHEN odst_tsk.id_task_type IN (4, 7, 8, 11, 42, 43, 51, 105, 106, 107, 108, 109, 101, 111, 112, 131) THEN
                                 (SELECT ostl.id_task_link
                                    FROM order_set_task_link ostl
                                   WHERE ostl.id_order_set_task = odst_tsk.id_order_set_task
                                     AND rownum = 1) id_task_link--Existem registos antigos dos procedimentos no modelo dos order sets, 
                            --j no so suportados, mas para no dar erro, l.se apenas a primeira linha
                            --END id_task_link
                      FROM order_set_task odst_tsk
                     INNER JOIN task_type tsk_type
                        ON odst_tsk.id_task_type = tsk_type.id_task_type
                    -- verify if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_task_dependency odst_tsk_dep
                        ON (odst_tsk_dep.id_order_set_task_to = odst_tsk.id_order_set_task AND
                           odst_tsk_dep.id_order_set = i_id_order_set AND
                           odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_tsk_dep.id_order_set_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_tsk.id_order_set = i_id_order_set)
             ORDER BY group_type_id NULLS LAST, get_task_rank(l_tasks_rank, id_order_set_task);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASKS',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_tasks);
            RETURN FALSE;
    END get_order_set_tasks;

    FUNCTION get_order_set_tasks_details
    (
        i_lang                       IN language.id_language%TYPE,
        i_prof                       IN profissional,
        i_id_advanced_input          IN advanced_input.id_advanced_input%TYPE,
        i_id_order_set_tasks         IN table_number,
        i_flg_detail_type            IN table_varchar,
        o_fields                     OUT pk_types.cursor_type,
        o_multichoice_fields         OUT pk_types.cursor_type,
        o_fields_det                 OUT pk_types.cursor_type,
        o_fields_units               OUT pk_types.cursor_type,
        o_order_set_tasks_details    OUT pk_types.cursor_type,
        o_order_set_tasks_instr_desc OUT VARCHAR2,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_flg_detail_type table_varchar;
    
        error_adv_input_structure EXCEPTION;
    
    BEGIN
    
        g_error := 'GET CURSOR WITH ORDER SET TASKS DETAILS';
        -- force null of flg_detail_type parameter
        IF (i_flg_detail_type IS NULL OR i_flg_detail_type.count = 0)
        THEN
            l_flg_detail_type := NULL;
        ELSE
            l_flg_detail_type := i_flg_detail_type;
        END IF;
    
        -- get details data
        o_order_set_tasks_details := get_odst_tasks_det_data(i_lang, i_prof, i_id_order_set_tasks, l_flg_detail_type);
    
        -- get string with the selected tasks instructions 
        o_order_set_tasks_instr_desc := get_task_instructions_desc(i_lang, i_prof, i_id_order_set_tasks, g_no);
    
        -- verify if it is necessary to return the advanced input structure
        IF i_id_advanced_input IS NOT NULL
        THEN
            g_error := 'GET CURSORS WITH ADVANCED INPUT STRUCTURE';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- get general advanced input structure
            IF NOT (pk_advanced_input.get_advanced_input_data(i_lang,
                                                              i_prof,
                                                              i_id_advanced_input,
                                                              o_fields,
                                                              o_multichoice_fields,
                                                              o_fields_det,
                                                              o_fields_units,
                                                              o_error))
            THEN
                RAISE error_adv_input_structure;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error on get advanced input structure
        WHEN error_adv_input_structure THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASKS_DETAILS',
                                              o_error);
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
            pk_types.open_my_cursor(o_order_set_tasks_details);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASKS_DETAILS',
                                              o_error);
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
            pk_types.open_my_cursor(o_order_set_tasks_details);
            RETURN FALSE;
    END get_order_set_tasks_details;

    FUNCTION set_odst_tasks_details_intern
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set                IN order_set.id_order_set%TYPE,
        i_id_order_set_tasks          IN table_number,
        i_flg_value_type              IN table_table_varchar,
        i_dvalue                      IN table_table_varchar,
        i_nvalue                      IN table_table_number,
        i_vvalue                      IN table_table_varchar,
        i_flg_detail_type             IN table_table_varchar,
        i_id_advanced_input           IN table_table_number,
        i_id_advanced_input_field     IN table_table_number,
        i_id_advanced_input_field_det IN table_table_number,
        i_id_unit_measure             IN table_table_number,
        i_flg_process_dependencies    IN VARCHAR2,
        i_commit                      IN VARCHAR2,
        o_updated_tasks_instructions  OUT pk_types.cursor_type,
        o_updated_selected_tasks_info OUT pk_types.cursor_type,
        o_error                       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_changed_tasks table_number := table_number();
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'DELETE OLD ORDER SET TASKS DETAILS';
        FOR i IN i_id_order_set_tasks.first .. i_id_order_set_tasks.last
        LOOP
            FORALL j IN i_flg_detail_type(i).first .. i_flg_detail_type(i).last
                DELETE FROM order_set_task_detail odst_tsk_det
                 WHERE odst_tsk_det.id_order_set_task = i_id_order_set_tasks(i)
                   AND odst_tsk_det.flg_detail_type = i_flg_detail_type(i)
                 (j)
                      --AND nvl(odst_tsk_det.id_advanced_input, -1) = nvl(i_id_advanced_input(i) (j), -1)
                   AND nvl(odst_tsk_det.id_advanced_input_field, -1) = nvl(i_id_advanced_input_field(i) (j), -1)
                   AND nvl(odst_tsk_det.id_advanced_input_field_det, -1) =
                       nvl(i_id_advanced_input_field_det(i) (j), -1);
        END LOOP;
    
        g_error := 'INSERT ORDER SET TASKS DETAILS';
        FOR i IN i_id_order_set_tasks.first .. i_id_order_set_tasks.last
        LOOP
            FOR j IN i_flg_detail_type(i).first .. i_flg_detail_type(i).last
            LOOP
                IF (i_nvalue(i) (j) IS NOT NULL OR i_dvalue(i) (j) IS NOT NULL OR i_vvalue(i) (j) IS NOT NULL)
                THEN
                
                    INSERT INTO order_set_task_detail
                        (id_order_set_task_detail,
                         id_order_set_task,
                         flg_value_type,
                         nvalue,
                         dvalue,
                         vvalue,
                         flg_detail_type,
                         id_advanced_input,
                         id_advanced_input_field,
                         id_advanced_input_field_det,
                         id_unit_measure)
                    VALUES
                        (seq_order_set_task_detail.nextval,
                         i_id_order_set_tasks(i),
                         i_flg_value_type(i) (j),
                         i_nvalue(i) (j),
                         pk_date_utils.get_string_tstz(i_lang, i_prof, i_dvalue(i) (j), NULL),
                         i_vvalue(i) (j),
                         i_flg_detail_type(i) (j),
                         i_id_advanced_input(i) (j),
                         i_id_advanced_input_field(i) (j),
                         i_id_advanced_input_field_det(i) (j),
                         i_id_unit_measure(i) (j));
                
                    -- if a task pre-selection was updated, then update the pre-selection of its dependencies
                    IF i_flg_process_dependencies = pk_alert_constant.g_yes
                       AND i_id_advanced_input_field(i) (j) = g_adv_input_field_selected
                    THEN
                        IF NOT update_depends_preselection(i_lang,
                                                           i_prof,
                                                           i_id_order_set_tasks(i),
                                                           l_changed_tasks,
                                                           o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    END IF;
                END IF;
            END LOOP;
        END LOOP;
    
        g_error := 'GET UPDATED TASKS INSTRUCTIONS';
        -- collect all changed tasks IDs into a single collection 
        l_changed_tasks := l_changed_tasks MULTISET UNION DISTINCT i_id_order_set_tasks;
    
        OPEN o_updated_tasks_instructions FOR
            SELECT order_set_task.column_value id_order_set_task,
                   get_task_instructions_desc(i_lang, i_prof, table_number(order_set_task.column_value), g_no) instr_desc
              FROM TABLE(l_changed_tasks) order_set_task;
    
        g_error := 'GET UPDATED INFORMATION OF THE SELECTED TASKS';
        -- get order set dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        OPEN o_updated_selected_tasks_info FOR
            SELECT id_order_set_task,
                   flg_ok,
                   get_task_instructions_desc(i_lang, i_prof, table_number(id_order_set_task), g_no) instr_desc
              FROM (SELECT odst_tsk.id_order_set_task,
                           check_mandatory_fields(i_lang,
                                                  i_prof,
                                                  odst_tsk.id_order_set_task,
                                                  odst_tsk.id_task_type,
                                                  pk_alert_constant.g_no) flg_ok,
                           odst_tsk.id_task_type
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set_task IN
                           (SELECT /*+opt_estimate(table tsk rows=1)*/
                             column_value
                              FROM TABLE(i_id_order_set_tasks) tsk));
    
        -- transaction control
        IF i_commit = g_yes
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- DML Error
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_TASKS_DETAILS_INTERN',
                                              o_error);
            -- transaction control
            IF i_commit = g_yes
            THEN
                pk_utils.undo_changes;
            END IF;
        
            pk_types.open_my_cursor(o_updated_tasks_instructions);
            pk_types.open_my_cursor(o_updated_selected_tasks_info);
        
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_TASKS_DETAILS_INTERN',
                                              o_error);
            -- transaction control
            IF i_commit = g_yes
            THEN
                pk_utils.undo_changes;
            END IF;
        
            pk_types.open_my_cursor(o_updated_tasks_instructions);
            pk_types.open_my_cursor(o_updated_selected_tasks_info);
        
            RETURN FALSE;
    END set_odst_tasks_details_intern;

    FUNCTION set_order_set_tasks_details
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set                IN order_set.id_order_set%TYPE,
        i_id_order_set_tasks          IN table_number,
        i_flg_value_type              IN table_table_varchar,
        i_dvalue                      IN table_table_varchar,
        i_nvalue                      IN table_table_number,
        i_vvalue                      IN table_table_varchar,
        i_flg_detail_type             IN table_table_varchar,
        i_id_advanced_input           IN table_table_number,
        i_id_advanced_input_field     IN table_table_number,
        i_id_advanced_input_field_det IN table_table_number,
        i_id_unit_measure             IN table_table_number,
        o_desc_union_task_instr       OUT VARCHAR2,
        o_updated_tasks_instructions  OUT pk_types.cursor_type,
        o_updated_selected_tasks_info OUT pk_types.cursor_type,
        o_error                       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'SET ORDER SET TASKS DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- call the same function but with transaction control parameter 
        IF NOT set_odst_tasks_details_intern(i_lang                        => i_lang,
                                             i_prof                        => i_prof,
                                             i_id_order_set                => i_id_order_set,
                                             i_id_order_set_tasks          => i_id_order_set_tasks,
                                             i_flg_value_type              => i_flg_value_type,
                                             i_dvalue                      => i_dvalue,
                                             i_nvalue                      => i_nvalue,
                                             i_vvalue                      => i_vvalue,
                                             i_flg_detail_type             => i_flg_detail_type,
                                             i_id_advanced_input           => i_id_advanced_input,
                                             i_id_advanced_input_field     => i_id_advanced_input_field,
                                             i_id_advanced_input_field_det => i_id_advanced_input_field_det,
                                             i_id_unit_measure             => i_id_unit_measure,
                                             i_flg_process_dependencies    => pk_alert_constant.g_yes,
                                             i_commit                      => g_yes,
                                             o_updated_tasks_instructions  => o_updated_tasks_instructions,
                                             o_updated_selected_tasks_info => o_updated_selected_tasks_info,
                                             o_error                       => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get selected tasks instructions
        o_desc_union_task_instr := get_task_instructions_desc(i_lang, i_prof, i_id_order_set_tasks, g_no);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_TASKS_DETAILS',
                                              o_error);
            RETURN FALSE;
    END set_order_set_tasks_details;

    FUNCTION set_order_set_tasks_instructions
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_root_name            IN VARCHAR2,
        i_tbl_id_pk            IN table_number,
        i_tbl_data             IN table_varchar,
        i_tbl_ds_internal_name IN table_varchar,
        i_tbl_real_val         IN table_table_varchar,
        i_tbl_val_clob         IN table_clob,
        i_tbl_value_mea        IN table_varchar,
        i_flg_origin           IN VARCHAR,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
        l_id_episode_to_associate episode.id_episode%TYPE;
    
        l_tbl_tbl_flg_value_type              table_table_varchar := table_table_varchar();
        l_tbl_tbl_dvalue                      table_table_varchar := table_table_varchar();
        l_tbl_tbl_nvalue                      table_table_number := table_table_number();
        l_tbl_tbl_vvalue                      table_table_varchar := table_table_varchar();
        l_tbl_tbl_flg_detail_type             table_table_varchar := table_table_varchar();
        l_tbl_tbl_id_advanced_input           table_table_number := table_table_number();
        l_tbl_tbl_id_advanced_input_field     table_table_number := table_table_number();
        l_tbl_tbl_id_advanced_input_field_det table_table_number := table_table_number();
        l_tbl_tbl_id_unit_measure             table_table_number := table_table_number();
    
        l_tbl_flg_value_type              table_varchar := table_varchar();
        l_tbl_dvalue                      table_varchar := table_varchar();
        l_tbl_nvalue                      table_number := table_number();
        l_tbl_vvalue                      table_varchar := table_varchar();
        l_tbl_flg_detail_type             table_varchar := table_varchar();
        l_tbl_id_advanced_input           table_number := table_number();
        l_tbl_id_advanced_input_field     table_number := table_number();
        l_tbl_id_advanced_input_field_det table_number := table_number();
        l_tbl_id_unit_measure             table_number := table_number();
    
        c_updated_tasks_instructions  pk_types.cursor_type;
        c_updated_selected_tasks_info pk_types.cursor_type;
    BEGIN
    
        g_error := 'ERROR EXTENDING TABLES';
        l_tbl_tbl_flg_value_type.extend();
        l_tbl_tbl_dvalue.extend();
        l_tbl_tbl_nvalue.extend();
        l_tbl_tbl_vvalue.extend();
        l_tbl_tbl_flg_detail_type.extend();
        l_tbl_tbl_id_advanced_input.extend();
        l_tbl_tbl_id_advanced_input_field.extend();
        l_tbl_tbl_id_advanced_input_field_det.extend();
        l_tbl_tbl_id_unit_measure.extend();
    
        FOR i IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
        LOOP
            IF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_frequency_n
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                IF i_root_name = pk_orders_constant.g_ds_order_set_monitoring
                THEN
                    l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 55;
                END IF;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := 98;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_notes
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'N';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_priority
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                IF i_root_name = pk_orders_constant.g_ds_order_set_monitoring
                THEN
                    l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 55;
                ELSIF i_root_name IN (pk_orders_constant.g_ds_order_set_medical_appointment,
                                      pk_orders_constant.g_ds_order_set_nursing_appointment,
                                      pk_orders_constant.g_ds_order_set_rehab_appointment,
                                      pk_orders_constant.g_ds_order_set_social_appointment,
                                      pk_orders_constant.g_ds_order_set_diet_appointment)
                THEN
                    l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 84;
                ELSIF i_root_name = pk_orders_constant.g_ds_order_set_discharge_instructions
                THEN
                    l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 52;
                END IF;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := 91;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_care_instructions
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'I';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_release_from
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 52;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := 102;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) IN (pk_orders_constant.g_ds_location, pk_orders_constant.g_ds_specialty)
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'N';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := to_number(i_tbl_real_val(i) (1));
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := CASE i_tbl_ds_internal_name(i)
                                                                          WHEN pk_orders_constant.g_ds_location THEN
                                                                           'L'
                                                                          WHEN pk_orders_constant.g_ds_specialty THEN
                                                                           'B'
                                                                      END;
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_follow_up_on
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := to_number(i_tbl_real_val(i) (1));
            
                l_tbl_vvalue.extend();
                IF l_tbl_nvalue(l_tbl_dvalue.count) = 3
                THEN
                    l_tbl_vvalue(l_tbl_vvalue.count) := 'null';
                ELSE
                    FOR j IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
                    LOOP
                        IF l_tbl_nvalue(l_tbl_dvalue.count) = 1
                           AND i_tbl_ds_internal_name(j) = pk_orders_constant.g_ds_follow_up_date
                        THEN
                            l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(j) (1);
                            EXIT;
                        ELSIF l_tbl_nvalue(l_tbl_dvalue.count) = 2
                              AND i_tbl_ds_internal_name(j) = pk_orders_constant.g_ds_follow_up_n
                        THEN
                            l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(j) (1);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'U';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) IN
                  (pk_orders_constant.g_ds_episode_due,
                   pk_orders_constant.g_ds_patient_diagnosed,
                   pk_orders_constant.g_ds_restrict_activity,
                   pk_orders_constant.g_ds_patient_instructions)
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := CASE i_tbl_ds_internal_name(i)
                                                                          WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                           'E'
                                                                          WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                           'W'
                                                                          WHEN pk_orders_constant.g_ds_restrict_activity THEN
                                                                           'V'
                                                                          WHEN pk_orders_constant.g_ds_patient_instructions THEN
                                                                           'D'
                                                                      END;
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := to_number(i_tbl_value_mea(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_patient_assistance
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'H';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_diet_after_discharge
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'V';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'X';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_from_date
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'D';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 70;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := 103;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_to_date
                  AND i_root_name <> pk_orders_constant.g_ds_order_set_personalised_diets
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'D';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 70;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := 104;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_follow_up_by
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'N';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'F';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := NULL;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := NULL;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF (i_tbl_ds_internal_name(i) IN (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_end_date))
                  AND i_root_name = pk_orders_constant.g_ds_order_set_monitoring
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'D';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 62;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := CASE i_tbl_ds_internal_name(i)
                                                                                          WHEN
                                                                                           pk_orders_constant.g_ds_start_date THEN
                                                                                           96
                                                                                          WHEN
                                                                                           pk_orders_constant.g_ds_end_date THEN
                                                                                           97
                                                                                      END;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF (i_tbl_ds_internal_name(i) IN (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_to_date))
                  AND i_root_name = pk_orders_constant.g_ds_order_set_personalised_diets
            THEN
                l_tbl_flg_value_type.extend();
                l_tbl_flg_value_type(l_tbl_flg_value_type.count) := 'D';
            
                l_tbl_dvalue.extend();
                l_tbl_dvalue(l_tbl_dvalue.count) := i_tbl_real_val(i) (1);
            
                l_tbl_nvalue.extend();
                l_tbl_nvalue(l_tbl_dvalue.count) := NULL;
            
                l_tbl_vvalue.extend();
                l_tbl_vvalue(l_tbl_vvalue.count) := NULL;
            
                l_tbl_flg_detail_type.extend();
                l_tbl_flg_detail_type(l_tbl_flg_detail_type.count) := 'A';
            
                l_tbl_id_advanced_input.extend();
                l_tbl_id_advanced_input(l_tbl_id_advanced_input.count) := 82;
            
                l_tbl_id_advanced_input_field.extend();
                l_tbl_id_advanced_input_field(l_tbl_id_advanced_input_field.count) := CASE i_tbl_ds_internal_name(i)
                                                                                          WHEN
                                                                                           pk_orders_constant.g_ds_start_date THEN
                                                                                           136
                                                                                          WHEN
                                                                                           pk_orders_constant.g_ds_to_date THEN
                                                                                           137
                                                                                      END;
            
                l_tbl_id_advanced_input_field_det.extend();
                l_tbl_id_advanced_input_field_det(l_tbl_id_advanced_input_field_det.count) := NULL;
            
                l_tbl_id_unit_measure.extend();
                l_tbl_id_unit_measure(l_tbl_id_unit_measure.count) := NULL;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_episode
            THEN
                l_id_episode_to_associate := to_number(i_tbl_real_val(i) (1));
            END IF;
        END LOOP;
    
        l_tbl_tbl_flg_value_type(1) := l_tbl_flg_value_type;
        l_tbl_tbl_dvalue(1) := l_tbl_dvalue;
        l_tbl_tbl_nvalue(1) := l_tbl_nvalue;
        l_tbl_tbl_vvalue(1) := l_tbl_vvalue;
        l_tbl_tbl_flg_detail_type(1) := l_tbl_flg_detail_type;
        l_tbl_tbl_id_advanced_input(1) := l_tbl_id_advanced_input;
        l_tbl_tbl_id_advanced_input_field(1) := l_tbl_id_advanced_input_field;
        l_tbl_tbl_id_advanced_input_field_det(1) := l_tbl_id_advanced_input_field_det;
        l_tbl_tbl_id_unit_measure(1) := l_tbl_id_unit_measure;
    
        g_error := 'SET ORDER SET TASKS DETAILS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        IF i_flg_origin = pk_order_sets.g_backoffice_origin
        THEN
            -- call the same function but with transaction control parameter 
            IF NOT set_odst_tasks_details_intern(i_lang                        => i_lang,
                                                 i_prof                        => i_prof,
                                                 i_id_order_set                => i_tbl_id_pk(3),
                                                 i_id_order_set_tasks          => table_number(i_tbl_id_pk(2)),
                                                 i_flg_value_type              => l_tbl_tbl_flg_value_type,
                                                 i_dvalue                      => l_tbl_tbl_dvalue,
                                                 i_nvalue                      => l_tbl_tbl_nvalue,
                                                 i_vvalue                      => l_tbl_tbl_vvalue,
                                                 i_flg_detail_type             => l_tbl_tbl_flg_detail_type,
                                                 i_id_advanced_input           => l_tbl_tbl_id_advanced_input,
                                                 i_id_advanced_input_field     => l_tbl_tbl_id_advanced_input_field,
                                                 i_id_advanced_input_field_det => l_tbl_tbl_id_advanced_input_field_det,
                                                 i_id_unit_measure             => l_tbl_tbl_id_unit_measure,
                                                 i_flg_process_dependencies    => pk_alert_constant.g_yes,
                                                 i_commit                      => g_yes,
                                                 o_updated_tasks_instructions  => c_updated_tasks_instructions,
                                                 o_updated_selected_tasks_info => c_updated_selected_tasks_info,
                                                 o_error                       => o_error)
            THEN
                RAISE l_exception;
            END IF;
        ELSE
            IF NOT set_odst_proc_tasks_det_intern(i_lang                        => i_lang,
                                                  i_prof                        => i_prof,
                                                  i_id_order_set_process        => i_tbl_id_pk(3),
                                                  i_id_order_set_proc_tasks     => table_number(i_tbl_id_pk(2)),
                                                  i_flg_value_type              => l_tbl_tbl_flg_value_type,
                                                  i_dvalue                      => l_tbl_tbl_dvalue,
                                                  i_nvalue                      => l_tbl_tbl_nvalue,
                                                  i_vvalue                      => l_tbl_tbl_vvalue,
                                                  i_flg_detail_type             => l_tbl_tbl_flg_detail_type,
                                                  i_id_advanced_input           => l_tbl_tbl_id_advanced_input,
                                                  i_id_advanced_input_field     => l_tbl_tbl_id_advanced_input_field,
                                                  i_id_advanced_input_field_det => l_tbl_tbl_id_advanced_input_field_det,
                                                  i_id_unit_measure             => l_tbl_tbl_id_unit_measure,
                                                  i_commit                      => pk_alert_constant.g_yes,
                                                  o_updated_tasks_instructions  => c_updated_tasks_instructions,
                                                  o_updated_selected_tasks_info => c_updated_selected_tasks_info,
                                                  o_error                       => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            IF i_root_name IN (pk_orders_constant.g_ds_order_set_medical_appointment,
                               pk_orders_constant.g_ds_order_set_nursing_appointment,
                               pk_orders_constant.g_ds_order_set_rehab_appointment,
                               pk_orders_constant.g_ds_order_set_social_appointment,
                               pk_orders_constant.g_ds_order_set_diet_appointment)
            THEN
                IF NOT pk_order_sets.set_order_set_proc_episode(i_lang                   => i_lang,
                                                                i_prof                   => i_prof,
                                                                i_order_set_process_task => i_tbl_id_pk(2),
                                                                i_episode_task           => l_id_episode_to_associate,
                                                                i_flg_new_epis_req       => pk_alert_constant.g_no,
                                                                o_error                  => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_TASKS_INSTRUCTIONS',
                                              o_error);
            RETURN FALSE;
    END set_order_set_tasks_instructions;

    FUNCTION set_order_set_request
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_id_patient                IN patient.id_patient%TYPE,
        i_id_episode                IN episode.id_episode%TYPE,
        i_id_order_set_process      IN order_set_process.id_order_set_process%TYPE,
        i_clinical_question_pk      IN table_number,
        i_clinical_question         IN table_varchar,
        i_response                  IN table_table_varchar,
        i_order_set_proc_tasks      IN table_number,
        i_order_set_proc_tasks_type IN table_number,
        i_cdr_call                  IN cdr_call.id_cdr_call%TYPE,
        i_flg_force                 IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_msg_warning               OUT VARCHAR2,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
        --Clinical questions
        l_tbl_cq_type             table_varchar := table_varchar();
        l_tbl_id_task             table_number := table_number();
        l_tbl_questionnaire       table_number := table_number();
        l_tbl_sample_type         table_number := table_number();
        l_tbl_cq                  tbl_question_response := tbl_question_response();
        l_tbl_cq_response         tbl_cq_response := tbl_cq_response();
        l_clinical_question       table_table_number := table_table_number();
        l_response                table_table_varchar := table_table_varchar();
        l_clinical_question_notes table_table_varchar := table_table_varchar();
    BEGIN
    
        g_error := 'ERROR EXTENDING CLINICAL QUESTIONS';
        --Clinical questions
        IF i_clinical_question_pk.count > 0
        THEN
            FOR i IN i_response.first .. i_response.last
            LOOP
                FOR j IN i_response(i).first .. i_response(i).last
                LOOP
                    l_tbl_cq_response.extend();
                    l_tbl_cq_response(l_tbl_cq_response.count) := t_cq_response(response => i_response(i) (j), rn => i);
                END LOOP;
            END LOOP;
        
            FOR i IN i_clinical_question.first .. i_clinical_question.last
            LOOP
                l_tbl_cq_type.extend();
                l_tbl_cq_type(l_tbl_cq_type.count) := pk_orders_utils.get_cq_task_type(i_lang                   => i_lang,
                                                                                       i_prof                   => i_prof,
                                                                                       i_clinical_question_info => i_clinical_question(i));
            
                l_tbl_id_task.extend();
                l_tbl_id_task(l_tbl_id_task.count) := pk_orders_utils.get_cq_id(i_lang                   => i_lang,
                                                                                i_prof                   => i_prof,
                                                                                i_clinical_question_info => i_clinical_question(i),
                                                                                i_index                  => 1);
            
                l_tbl_questionnaire.extend();
                l_tbl_questionnaire(l_tbl_questionnaire.count) := pk_orders_utils.get_cq_id(i_lang                   => i_lang,
                                                                                            i_prof                   => i_prof,
                                                                                            i_clinical_question_info => i_clinical_question(i),
                                                                                            i_index                  => 2);
            
                l_tbl_sample_type.extend();
                l_tbl_sample_type(l_tbl_sample_type.count) := pk_orders_utils.get_cq_id(i_lang                   => i_lang,
                                                                                        i_prof                   => i_prof,
                                                                                        i_clinical_question_info => i_clinical_question(i),
                                                                                        i_index                  => 3);
            END LOOP;
        
            SELECT t_question_response(id_task                   => t.id_task,
                                        id_order_set_process_task => coalesce(t_procedure.id_order_set_process_task,
                                                                              t_exam.id_order_set_process_task,
                                                                              t_lab_test.id_order_set_process_task,
                                                                              t_blood_products.id_order_set_process_task),
                                        id_task_type              => coalesce(t_procedure.id_task_type,
                                                                              t_exam.id_task_type,
                                                                              t_lab_test.id_task_type,
                                                                              t_blood_products.id_task_type),
                                        id_questionnaire          => t.id_questionnaire,
                                        id_response               => CASE
                                                                         WHEN (t_procedure.flg_type IS NOT NULL AND t_procedure.flg_type NOT IN ('T', 'D'))
                                                                              OR (t_exam.flg_type IS NOT NULL AND t_exam.flg_type NOT IN ('T', 'D'))
                                                                              OR (t_lab_test.flg_type IS NOT NULL AND t_lab_test.flg_type NOT IN ('T', 'D'))
                                                                              OR (t_blood_products.flg_type IS NOT NULL AND t_blood_products.flg_type NOT IN ('T', 'D')) THEN
                                                                          to_number(t.response)
                                                                     END,
                                        notes                     => CASE
                                                                         WHEN (t_procedure.flg_type IS NOT NULL AND t_procedure.flg_type IN ('T', 'D'))
                                                                              OR (t_exam.flg_type IS NOT NULL AND t_exam.flg_type IN ('T', 'D'))
                                                                              OR (t_lab_test.flg_type IS NOT NULL AND t_lab_test.flg_type IN ('T', 'D'))
                                                                              OR (t_blood_products.flg_type IS NOT NULL AND t_blood_products.flg_type IN ('T', 'D')) THEN
                                                                          t.response
                                                                     END,
                                        rank                      => coalesce(t_procedure.rank,
                                                                              t_exam.rank,
                                                                              t_lab_test.rank,
                                                                              t_blood_products.rank))
              BULK COLLECT
              INTO l_tbl_cq
              FROM (SELECT t_questionnaire.id_questionnaire id_questionnaire,
                           t_task_id.id_task                id_task,
                           t_response.response,
                           t_task_type.task_type,
                           t_sample_type.id_sample_type
                      FROM (SELECT /*+opt_estimate (table t rows=1)*/
                             t.column_value AS id_questionnaire, rownum AS rn
                              FROM TABLE(l_tbl_questionnaire) t) t_questionnaire
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            t.column_value AS task_type, rownum AS rn
                             FROM TABLE(l_tbl_cq_type) t) t_task_type
                        ON t_task_type.rn = t_questionnaire.rn
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            t.column_value AS id_task, rownum AS rn
                             FROM TABLE(l_tbl_id_task) t) t_task_id
                        ON t_task_id.rn = t_questionnaire.rn
                      JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                            t.response, t.rn
                             FROM TABLE(l_tbl_cq_response) t) t_response
                        ON t_response.rn = t_questionnaire.rn
                      LEFT JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                                 t.column_value AS id_sample_type, rownum AS rn
                                  FROM TABLE(l_tbl_sample_type) t) t_sample_type
                        ON t_sample_type.rn = t_questionnaire.rn) t
              LEFT JOIN (SELECT DISTINCT ost.id_order_set_process_task,
                                         ost.id_task_type,
                                         iq.flg_type,
                                         iq.id_intervention,
                                         iq.id_questionnaire,
                                         iq.id_response,
                                         iq.rank
                           FROM order_set_process_task ost
                           JOIN order_set_process_task_link ostl
                             ON ostl.id_order_set_process_task = ost.id_order_set_process_task
                           JOIN interv_prescription ip
                             ON ip.id_interv_prescription = to_number(ostl.id_task_link)
                           JOIN interv_presc_det ipd
                             ON ipd.id_interv_prescription = ip.id_interv_prescription
                           JOIN interv_questionnaire iq
                             ON iq.id_intervention = ipd.id_intervention
                            AND iq.flg_time = 'O'
                            AND iq.flg_available = pk_alert_constant.g_yes
                            AND iq.id_institution = i_prof.institution
                          WHERE ost.id_order_set_process_task IN
                                (SELECT /*+opt_estimate (table it rows=1)*/
                                  it.column_value
                                   FROM TABLE(i_order_set_proc_tasks) it)
                            AND ost.id_task_type = g_odst_task_procedure
                            AND ipd.id_intervention = iq.id_intervention) t_procedure
                ON t_procedure.id_intervention = t.id_task
               AND t_procedure.id_questionnaire = t.id_questionnaire
               AND t.task_type = 'P'
               AND (t_procedure.flg_type IN ('T', 'D') OR
                   (t_procedure.flg_type NOT IN ('T', 'D') AND to_char(t_procedure.id_response) = to_char(t.response)) OR
                   --Make sure that all unanswered questions are also saved
                   (t_procedure.flg_type NOT IN ('T', 'D') AND
                   t_procedure.id_questionnaire NOT IN
                   (SELECT DISTINCT iq2.id_questionnaire
                        FROM interv_questionnaire iq2
                       WHERE iq2.id_intervention = t.id_task
                         AND iq2.id_questionnaire = t.id_questionnaire
                         AND to_char(iq2.id_response) = t.response
                         AND iq2.flg_time = 'O'
                         AND iq2.flg_available = pk_alert_constant.g_yes
                         AND iq2.id_institution = i_prof.institution)))
            --Exams 
              LEFT JOIN (SELECT DISTINCT ost.id_order_set_process_task,
                                         ost.id_task_type,
                                         eq.flg_type,
                                         eq.id_exam,
                                         eq.id_questionnaire,
                                         eq.id_response,
                                         eq.rank
                           FROM order_set_process_task ost
                           JOIN order_set_process_task_link ostl
                             ON ostl.id_order_set_process_task = ost.id_order_set_process_task
                           JOIN exam_req_det erd
                             ON erd.id_exam_req = to_number(ostl.id_task_link)
                           JOIN exam_questionnaire eq
                             ON eq.id_exam = erd.id_exam
                            AND eq.flg_time = 'O'
                            AND eq.flg_available = pk_alert_constant.g_yes
                            AND eq.id_institution = i_prof.institution
                          WHERE ost.id_order_set_process_task IN
                                (SELECT /*+opt_estimate (table it rows=1)*/
                                  it.column_value
                                   FROM TABLE(i_order_set_proc_tasks) it)
                            AND ost.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam)) t_exam
                ON t_exam.id_exam = t.id_task
               AND t_exam.id_questionnaire = t.id_questionnaire
               AND t.task_type IN ('E', 'I')
               AND (t_exam.flg_type IN ('T', 'D') OR
                   (t_exam.flg_type NOT IN ('T', 'D') AND to_char(t_exam.id_response) = to_char(t.response)) OR
                   --Make sure that all unanswered questions are also saved
                   (t_exam.flg_type NOT IN ('T', 'D') AND
                   t_exam.id_questionnaire NOT IN
                   (SELECT DISTINCT eq2.id_questionnaire
                        FROM exam_questionnaire eq2
                       WHERE eq2.id_exam = t.id_task
                         AND eq2.id_questionnaire = t.id_questionnaire
                         AND to_char(eq2.id_response) = t.response
                         AND eq2.flg_time = 'O'
                         AND eq2.flg_available = pk_alert_constant.g_yes
                         AND eq2.id_institution = i_prof.institution)))
            --Lab tests
              LEFT JOIN (SELECT DISTINCT ost.id_order_set_process_task,
                                         ost.id_task_type,
                                         aq.flg_type,
                                         aq.id_analysis,
                                         aq.id_sample_type,
                                         aq.id_questionnaire,
                                         aq.id_response,
                                         aq.rank
                           FROM order_set_process_task ost
                           JOIN order_set_process_task_link ostl
                             ON ostl.id_order_set_process_task = ost.id_order_set_process_task
                           JOIN analysis_req_det ard
                             ON ard.id_analysis_req = to_number(ostl.id_task_link)
                           JOIN analysis_questionnaire aq
                             ON aq.id_analysis = ard.id_analysis
                            AND aq.id_sample_type = ard.id_sample_type
                            AND aq.flg_time = 'O'
                            AND aq.flg_available = pk_alert_constant.g_yes
                            AND aq.id_institution = i_prof.institution
                          WHERE ost.id_order_set_process_task IN
                                (SELECT /*+opt_estimate (table it rows=1)*/
                                  it.column_value
                                   FROM TABLE(i_order_set_proc_tasks) it)
                            AND ost.id_task_type = g_odst_task_analysis) t_lab_test
                ON t_lab_test.id_analysis = t.id_task
               AND t_lab_test.id_sample_type = t.id_sample_type
               AND t_lab_test.id_questionnaire = t.id_questionnaire
               AND t.task_type = 'A'
               AND (t_lab_test.flg_type IN ('T', 'D') OR
                   (t_lab_test.flg_type NOT IN ('T', 'D') AND to_char(t_lab_test.id_response) = to_char(t.response)) OR
                   --Make sure that all unanswered questions are also saved
                   (t_lab_test.flg_type NOT IN ('T', 'D') AND
                   t_lab_test.id_questionnaire NOT IN
                   (SELECT DISTINCT aq2.id_questionnaire
                        FROM analysis_questionnaire aq2
                       WHERE aq2.id_analysis = t.id_task
                         AND aq2.id_sample_type = t.id_sample_type
                         AND aq2.id_questionnaire = t.id_questionnaire
                         AND to_char(aq2.id_response) = t.response
                         AND aq2.flg_time = 'O'
                         AND aq2.flg_available = pk_alert_constant.g_yes
                         AND aq2.id_institution = i_prof.institution)))
            --Blood products
              LEFT JOIN (SELECT DISTINCT ost.id_order_set_process_task,
                                         ost.id_task_type,
                                         bq.flg_type,
                                         bq.id_hemo_type,
                                         bq.id_questionnaire,
                                         bq.id_response,
                                         bq.rank
                           FROM order_set_process_task ost
                           JOIN order_set_process_task_link ostl
                             ON ostl.id_order_set_process_task = ost.id_order_set_process_task
                           JOIN blood_product_det bpd
                             ON bpd.id_blood_product_req = to_number(ostl.id_task_link)
                           JOIN bp_questionnaire bq
                             ON bq.id_hemo_type = bpd.id_hemo_type
                            AND bq.flg_time = 'O'
                            AND bq.flg_available = pk_alert_constant.g_yes
                            AND bq.id_institution = i_prof.institution
                          WHERE ost.id_order_set_process_task IN
                                (SELECT /*+opt_estimate (table it rows=1)*/
                                  it.column_value
                                   FROM TABLE(i_order_set_proc_tasks) it)
                            AND ost.id_task_type = g_odst_task_bp) t_blood_products
                ON t_blood_products.id_hemo_type = t.id_task
               AND t_blood_products.id_questionnaire = t.id_questionnaire
               AND t.task_type = 'P'
               AND (t_blood_products.flg_type IN ('T', 'D') OR
                   (t_blood_products.flg_type NOT IN ('T', 'D') AND
                   to_char(t_blood_products.id_response) = to_char(t.response)) OR
                   --Make sure that all unanswered questions are also saved
                   (t_lab_test.flg_type NOT IN ('T', 'D') AND
                   t_lab_test.id_questionnaire NOT IN
                   (SELECT DISTINCT bq2.id_questionnaire
                        FROM bp_questionnaire bq2
                       WHERE bq2.id_hemo_type = t.id_task
                         AND bq2.id_questionnaire = t.id_questionnaire
                         AND to_char(bq2.id_response) = t.response
                         AND bq2.flg_time = 'O'
                         AND bq2.flg_available = pk_alert_constant.g_yes
                         AND bq2.id_institution = i_prof.institution)));
        
            FOR i IN i_order_set_proc_tasks.first .. i_order_set_proc_tasks.last
            LOOP
                l_clinical_question.extend();
                l_response.extend();
                l_clinical_question_notes.extend();
            
                SELECT /*+opt_estimate (table t rows=1)*/
                 t.id_questionnaire, to_char(t.id_response), t.notes
                  BULK COLLECT
                  INTO l_clinical_question(i), l_response(i), l_clinical_question_notes(i)
                  FROM TABLE(l_tbl_cq) t
                 WHERE t.id_order_set_process_task = i_order_set_proc_tasks(i);
            END LOOP;
        ELSE
            l_clinical_question.extend();
            l_clinical_question(l_clinical_question.count) := table_number();
        
            l_response.extend();
            l_response(l_response.count) := table_varchar();
        
            l_clinical_question_notes.extend();
            l_clinical_question_notes(l_clinical_question_notes.count) := table_varchar();
        END IF;
    
        g_error := 'ERROR CALLING SET_ORDER_SET_PROCESS';
        pk_alertlog.log_debug(g_error, g_package_name);
        IF NOT pk_order_sets.set_order_set_process(i_lang                     => i_lang,
                                                   i_prof                     => i_prof,
                                                   i_id_patient               => i_id_patient,
                                                   i_id_episode               => i_id_episode,
                                                   i_id_order_set_process     => i_id_order_set_process,
                                                   i_clinical_question_ospt   => i_order_set_proc_tasks,
                                                   i_clinical_question_id     => l_clinical_question,
                                                   i_clinical_question_answer => l_response,
                                                   i_clinical_question_notes  => l_clinical_question_notes,
                                                   i_cdr_call                 => i_cdr_call,
                                                   i_flg_force                => i_flg_force,
                                                   o_msg_warning              => o_msg_warning,
                                                   o_error                    => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_REQUEST',
                                              o_error);
            RETURN FALSE;
    END set_order_set_request;

    FUNCTION set_odst_proc_tasks_def_values
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_id_episode             IN order_set_process.id_episode%TYPE,
        i_id_patient             IN order_set_process.id_patient%TYPE,
        i_id_order_set_process   IN order_set_process.id_order_set_process%TYPE,
        i_id_order_set_proc_task IN table_number,
        i_id_task_type           IN table_number,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- task detail record
        TYPE t_task_detail IS RECORD(
            id_odst_proc_task         table_number := table_number(),
            flg_value_type            table_table_varchar := table_table_varchar(),
            dvalue                    table_table_varchar := table_table_varchar(),
            nvalue                    table_table_number := table_table_number(),
            vvalue                    table_table_varchar := table_table_varchar(),
            flg_detail_type           table_table_varchar := table_table_varchar(),
            id_advanced_input         table_table_number := table_table_number(),
            id_advanced_input_field   table_table_number := table_table_number(),
            id_advanced_input_field_d table_table_number := table_table_number(),
            id_unit_measure           table_table_number := table_table_number());
    
        -- select all order set process tasks that have clinical indication/diagnoses field
        CURSOR c_diag_tasks IS
            SELECT ospt.id_order_set_process_task,
                   check_modular_task_type(ospt.id_task_type) flg_modular_workflow,
                   ospt.id_task_type
              FROM order_set_process_task ospt
             WHERE ospt.id_order_set_process = i_id_order_set_process
               AND ospt.id_task_type IN (g_odst_task_analysis,
                                         g_odst_task_image_exam,
                                         g_odst_task_other_exam,
                                         g_odst_task_procedure,
                                         g_odst_task_bp,
                                         g_odst_task_patient_education);
    
        -- local variables to get clinical indications/diagnoses data
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
        l_tbl_diagnoses        t_table_diagnoses;
    
        error_unexpected EXCEPTION;
    
        -- local variables to store parameters of set_odst_proc_tasks_det_intern function
        l_updated_selected_tasks_info pk_types.cursor_type;
        l_updated_tasks_instructions  pk_types.cursor_type;
    
        l_task_details t_task_detail;
    
        -- cursor used to get default data 
        c_data pk_types.cursor_type;
    
        -- auxiliary local variables used to get/set task details
        l_id_professional         professional.id_professional%TYPE;
        l_nick_name               professional.name%TYPE;
        l_dt_begin                VARCHAR2(30);
        l_dt_begin_send           VARCHAR2(30);
        l_flg_edit_dt_begin       VARCHAR2(1 CHAR);
        l_dt_end                  VARCHAR2(30);
        l_dt_end_send             VARCHAR2(30);
        l_flg_edit_dt_end         VARCHAR2(1 CHAR);
        l_interval                VARCHAR2(30);
        l_interval_value          NUMBER;
        l_interval_days           NUMBER;
        l_interval_hours          NUMBER;
        l_interval_minutes        NUMBER;
        l_interval_unit_measure   order_set_process_task_det.id_unit_measure%TYPE;
        l_interval_send           VARCHAR2(30);
        l_flg_edit_interval       VARCHAR2(1 CHAR);
        l_flg_edit_realizacao     VARCHAR2(1 CHAR);
        l_min_date                VARCHAR2(30);
        l_o_sysdate_str           VARCHAR2(30);
        l_val                     sys_domain.val%TYPE;
        l_rank                    NUMBER;
        l_desc_val                sys_domain.desc_val%TYPE;
        l_flg_default             VARCHAR2(1 CHAR);
        l_id_task_link            order_set_process_task_link.id_task_link%TYPE;
        l_flg_time                VARCHAR2(1 CHAR);
        l_predefined_unit_measure order_set_process_task_det.id_unit_measure%TYPE;
        l_default_unit_measure    order_set_process_task_det.id_unit_measure%TYPE;
        l_default_to_be_performed order_set_process_task_det.vvalue%TYPE;
        l_tbl_id_epis_diagnosis   table_number;
        l_tbl_id_diagnosis        table_number;
        l_tbl_id_alert_diagnosis  table_number;
        l_tbl_code_icd            table_varchar;
        l_tbl_desc_diagnosis      table_varchar;
        l_tbl_rank                table_number;
        l_tbl_flg_other           table_varchar;
    
        -- function used to add a new task detail
        PROCEDURE add_new_task_detail
        (
            i_task_details              IN OUT NOCOPY t_task_detail,
            i_id_odst_proc_task         IN NUMBER,
            i_flg_value_type            IN VARCHAR2 DEFAULT NULL,
            i_dvalue                    IN VARCHAR2 DEFAULT NULL,
            i_nvalue                    IN NUMBER DEFAULT NULL,
            i_vvalue                    IN VARCHAR2 DEFAULT NULL,
            i_flg_detail_type           IN VARCHAR2 DEFAULT NULL,
            i_id_advanced_input         IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field   IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field_d IN NUMBER DEFAULT NULL,
            i_id_unit_measure           IN NUMBER DEFAULT NULL
        ) IS
        
            l_idx PLS_INTEGER;
        
        BEGIN
        
            -- extend table for the new task detail
            i_task_details.id_odst_proc_task.extend;
            i_task_details.flg_value_type.extend;
            i_task_details.dvalue.extend;
            i_task_details.nvalue.extend;
            i_task_details.vvalue.extend;
            i_task_details.flg_detail_type.extend;
            i_task_details.id_advanced_input.extend;
            i_task_details.id_advanced_input_field.extend;
            i_task_details.id_advanced_input_field_d.extend;
            i_task_details.id_unit_measure.extend;
        
            -- gets index of the new position
            l_idx := i_task_details.id_odst_proc_task.count;
        
            -- set task detail default values
            i_task_details.id_odst_proc_task(l_idx) := i_id_odst_proc_task;
            i_task_details.flg_value_type(l_idx) := table_varchar(i_flg_value_type);
            i_task_details.dvalue(l_idx) := table_varchar(i_dvalue);
            i_task_details.nvalue(l_idx) := table_number(i_nvalue);
            i_task_details.vvalue(l_idx) := table_varchar(i_vvalue);
            i_task_details.flg_detail_type(l_idx) := table_varchar(i_flg_detail_type);
            i_task_details.id_advanced_input(l_idx) := table_number(i_id_advanced_input);
            i_task_details.id_advanced_input_field(l_idx) := table_number(i_id_advanced_input_field);
            i_task_details.id_advanced_input_field_d(l_idx) := table_number(i_id_advanced_input_field_d);
            i_task_details.id_unit_measure(l_idx) := table_number(i_id_unit_measure);
        END;
    
        -- function used to get default task time value
        FUNCTION get_default_task_time_depend(i_id_odst_proc_task IN order_set_process_task.id_order_set_process_task%TYPE)
            RETURN VARCHAR2 IS
        
            l_include_episode order_set_process_task_depend.id_order_set_proc_task_from%TYPE;
            l_flg_schedule    order_set_process_task.flg_schedule%TYPE;
        
        BEGIN
        
            -- get flag schedule 
            SELECT odst_proc_tsk.flg_schedule
              INTO l_flg_schedule
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.id_order_set_process_task = i_id_odst_proc_task;
        
            -- if the task is for schedule, flag time value is "to be defined"
            IF l_flg_schedule = pk_alert_constant.g_yes
            THEN
                RETURN pk_alert_constant.g_flg_time_b;
            END IF;
        
            -- get episode in which the task is included
            BEGIN
                SELECT odst_proc_tsk_dep.id_order_set_proc_task_from
                  INTO l_include_episode
                  FROM order_set_process_task_depend odst_proc_tsk_dep
                 WHERE odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start
                   AND odst_proc_tsk_dep.id_order_set_proc_task_to = i_id_odst_proc_task;
            EXCEPTION
                WHEN no_data_found THEN
                    l_include_episode := to_number(g_depend_current_epis);
            END;
        
            -- verify if the task will be executed in the current or in a future episode
            IF l_include_episode = to_number(g_depend_current_epis)
            THEN
                RETURN pk_alert_constant.g_flg_time_e;
            ELSE
                RETURN pk_alert_constant.g_flg_time_n;
            END IF;
        
        END get_default_task_time_depend;
    
        -- set diagnoses/clinical indications of modular workflow tasks
        PROCEDURE set_diag_modular_worflow_tasks
        (
            i_task_type     IN task_type.id_task_type%TYPE,
            i_task_request  IN table_number,
            i_rec_diagnoses IN pk_edis_types.rec_in_epis_diagnosis
        ) IS
        
        BEGIN
        
            CASE
            -- get task intructions/directions for lab test task types
                WHEN i_task_type = g_odst_task_procedure THEN
                    NULL;
                WHEN i_task_type = g_odst_task_bp THEN
                    NULL;
                WHEN i_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    NULL;
                WHEN i_task_type = g_odst_task_analysis THEN
                    NULL;
                    -- get task intructions/directions for imaging or other exam task types
                WHEN i_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    NULL;
                WHEN i_task_type IN (g_odst_task_patient_education) THEN
                    NULL;
                ELSE
                    g_error := 'modular workflow is not supported for task type [' || i_task_type || ']';
                    RAISE error_unexpected;
            END CASE;
        END set_diag_modular_worflow_tasks;
    
    BEGIN
    
        g_error := 'INSERT DEFAULT VALUES ON ORDER SET PROCESS TASKS DETAILS';
        -- For each order set process task insert default values on advanced input fields
        IF i_id_order_set_proc_task.count > 0
        THEN
            -- Prepare input parameters for set_odst_proc_tasks_det_intern function
            FOR i IN i_id_order_set_proc_task.first .. i_id_order_set_proc_task.last
            LOOP
                CASE
                    WHEN i_id_task_type(i) = g_odst_task_followup_appoint THEN
                        -- Follow-up appointment
                        g_error := g_error || ' / ' || 'FOLLOW-UP APPOINTMENT';
                    
                        -- add default value for "schedule date" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                            i_flg_value_type          => g_task_det_value_type_date,
                                            i_dvalue                  => pk_date_utils.date_send_tsz(i_lang,
                                                                                                     current_timestamp,
                                                                                                     i_prof),
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 66,
                                            i_id_advanced_input_field => 101);
                    
                    WHEN i_id_task_type(i) = g_odst_task_specialty_appoint THEN
                        -- Specialty appointment
                        g_error := g_error || ' / ' || 'SPECIALTY APPOINTMENT';
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_OPINION.GET_PROF_SPEC_LIST', g_package_name);
                    
                        -- gets default value for "professional" field
                        IF NOT pk_consult_req.get_prof_dep_clin_serv(i_lang          => i_lang,
                                                                     i_prof          => i_prof,
                                                                     i_dep_clin_serv => get_odst_proc_task_link(i_id_order_set_proc_task(i),
                                                                                                                g_task_link_null),
                                                                     o_prof          => c_data,
                                                                     o_error         => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        FETCH c_data
                            INTO l_id_professional, l_rank, l_nick_name;
                        CLOSE c_data;
                    
                        -- add default value for "professional" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_proc_task(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_id_professional,
                                            i_flg_detail_type   => 'P');
                    
                -- << predefined diet prescriptions >>
                    WHEN i_id_task_type(i) = g_odst_task_predef_diet THEN
                        g_error := g_error || ' / ' || 'PREDEFINED DIET PRESCRIPTIONS';
                    
                        -- add default value for "begin date" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                            i_flg_value_type          => g_task_det_value_type_date,
                                            i_dvalue                  => pk_date_utils.date_send_tsz(i_lang,
                                                                                                     current_timestamp,
                                                                                                     i_prof),
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 82,
                                            i_id_advanced_input_field => 136);
                    
                        -- add default value for "end date" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                            i_flg_value_type          => g_task_det_value_type_date,
                                            i_dvalue                  => pk_date_utils.date_send_tsz(i_lang,
                                                                                                     current_timestamp,
                                                                                                     i_prof),
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 82,
                                            i_id_advanced_input_field => 137);
                    
                    WHEN i_id_task_type(i) = g_odst_task_consult THEN
                        -- Consult/opinion
                        g_error := g_error || ' / ' || 'CONSULT';
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_OPINION.GET_PROF_SPEC_LIST', g_package_name);
                    
                        -- check if the opinion link is  a clinical service or a speciality
                        IF get_odst_proc_task_link_type(i_id_order_set_proc_task(i)) = g_task_link_clin_serv
                        THEN
                        
                            -- gets default value for "professional" field
                            IF NOT pk_opinion.get_prof_clin_serv_list(i_lang         => i_lang,
                                                                      i_prof         => i_prof,
                                                                      i_clin_serv_id => get_odst_proc_task_link(i_id_order_set_proc_task(i),
                                                                                                                g_task_link_clin_serv),
                                                                      o_prof         => c_data,
                                                                      o_error        => o_error)
                            THEN
                                RAISE error_unexpected;
                            END IF;
                        
                        ELSE
                            -- gets default value for "professional" field
                            IF NOT pk_opinion.get_prof_spec_list(i_lang       => i_lang,
                                                                 i_prof       => i_prof,
                                                                 i_speciality => get_odst_proc_task_link(i_id_order_set_proc_task(i),
                                                                                                         g_task_link_null),
                                                                 o_prof       => c_data,
                                                                 o_error      => o_error)
                            THEN
                                RAISE error_unexpected;
                            END IF;
                        
                        END IF;
                    
                        FETCH c_data
                            INTO l_id_professional, l_rank, l_nick_name;
                        CLOSE c_data;
                    
                        -- add default value for "professional" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => i_id_order_set_proc_task(i),
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_id_professional,
                                            i_flg_detail_type   => 'P');
                    
                    WHEN i_id_task_type(i) = g_odst_task_discharge_instruct THEN
                        -- Discharge instructions
                        g_error := g_error || ' / ' || 'DISCHARGE INSTRUCTIONS';
                    
                    WHEN i_id_task_type(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                        -- TODO: new image and other exam
                        -- Image and other exam
                        g_error := g_error || ' / ' || 'IMAGE AND OTHER EXAM';
                    
                        -- gets value for "to be performed" field according to task dependencies
                        l_flg_time := get_default_task_time_depend(i_id_order_set_proc_task(i));
                    
                        -- gets prescription id                    
                        l_id_task_link := get_odst_proc_task_link(i_id_order_set_proc_task(i), g_task_link_predefined);
                    
                    WHEN i_id_task_type(i) = g_odst_task_monitoring THEN
                        -- Monitoring
                        g_error := g_error || ' / ' || 'MONITORING';
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_MONITORIZATION.GET_MONIT_TIME',
                                              g_package_name);
                    
                        -- gets default value for "to be performed" field
                        IF NOT pk_monitorization.get_monit_time(i_lang  => i_lang,
                                                                i_prof  => i_prof,
                                                                o_time  => c_data,
                                                                o_error => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_val, l_desc_val, l_flg_default;
                        
                            EXIT WHEN l_flg_default = g_yes OR c_data%NOTFOUND;
                        END LOOP;
                        CLOSE c_data;
                    
                        -- save default value of "to be performed" field to be used below
                        l_default_to_be_performed := l_val;
                    
                        -- add default value for "to be performed" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => l_val,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 62,
                                            i_id_advanced_input_field => 100);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_LIST.CHECK_PARAM', g_package_name);
                    
                        -- gets default value for "begin date" field
                        IF NOT pk_list.check_param(i_lang        => i_lang,
                                                   i_flg_time    => l_val,
                                                   i_flg_tp      => 'M',
                                                   i_prof        => i_prof,
                                                   i_episode     => i_id_episode,
                                                   o_param       => c_data,
                                                   o_sysdate_str => l_o_sysdate_str,
                                                   o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        FETCH c_data
                            INTO l_dt_begin,
                                 l_dt_begin_send,
                                 l_flg_edit_dt_begin,
                                 l_dt_end,
                                 l_dt_end_send,
                                 l_flg_edit_dt_end,
                                 l_interval,
                                 l_interval_send,
                                 l_flg_edit_interval,
                                 l_flg_edit_realizacao,
                                 l_min_date;
                        CLOSE c_data;
                    
                        -- add default value for "begin date" field
                        -- if the previous function confirm that it is necessary
                        IF l_flg_edit_dt_begin = g_yes
                        THEN
                            add_new_task_detail(i_task_details            => l_task_details,
                                                i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                                i_flg_value_type          => g_task_det_value_type_date,
                                                i_dvalue                  => l_o_sysdate_str,
                                                i_flg_detail_type         => g_task_det_adv_input,
                                                i_id_advanced_input       => 62,
                                                i_id_advanced_input_field => 96);
                        END IF;
                    
                        -- gets predefined "interval" field value
                        l_interval_value := get_odst_proc_task_det_val(i_lang                        => i_lang,
                                                                       i_prof                        => i_prof,
                                                                       i_id_order_set_process_task   => i_id_order_set_proc_task(i),
                                                                       i_flg_detail_type             => 'A',
                                                                       i_id_advanced_input           => 55,
                                                                       i_id_advanced_input_field     => 98,
                                                                       i_id_advanced_input_field_det => NULL);
                    
                        -- check if interval field value is null or not
                        -- if not null, process interval field value
                        IF l_interval_value IS NOT NULL
                        THEN
                        
                            -- gets predefined "interval" field unit measure
                            l_interval_unit_measure := get_odst_proc_task_det_unit(i_lang                        => i_lang,
                                                                                   i_prof                        => i_prof,
                                                                                   i_id_order_set_process_task   => i_id_order_set_proc_task(i),
                                                                                   i_flg_detail_type             => 'A',
                                                                                   i_id_advanced_input           => 55,
                                                                                   i_id_advanced_input_field     => 98,
                                                                                   i_id_advanced_input_field_det => NULL);
                        
                            -- clear predefined "interval" field value if its unit measure 
                            -- doesn't make sense on the requisition context/environment
                            --  IF (l_default_unit_measure IS NULL OR (l_predefined_unit_measure IS NOT NULL AND
                            --      l_predefined_unit_measure != l_default_unit_measure))
                            IF (l_interval_value IS NULL OR l_interval_unit_measure IS NULL)
                            THEN
                                add_new_task_detail(i_task_details            => l_task_details,
                                                    i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                                    i_flg_value_type          => 'V',
                                                    i_vvalue                  => NULL,
                                                    i_nvalue                  => NULL,
                                                    i_dvalue                  => NULL,
                                                    i_flg_detail_type         => 'A',
                                                    i_id_advanced_input       => 62,
                                                    i_id_advanced_input_field => 98);
                            
                                -- set default interval field value
                            ELSE
                                add_new_task_detail(i_task_details            => l_task_details,
                                                    i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                                    i_flg_value_type          => 'V',
                                                    i_vvalue                  => l_interval_value,
                                                    i_nvalue                  => NULL,
                                                    i_dvalue                  => NULL,
                                                    i_flg_detail_type         => 'A',
                                                    i_id_advanced_input       => 62,
                                                    i_id_advanced_input_field => 98,
                                                    i_id_unit_measure         => l_interval_unit_measure);
                            END IF;
                        END IF;
                    
                    WHEN i_id_task_type(i) = g_odst_task_procedure THEN
                        /*PH - 12-04-2016 - Change Procedures to Procedures DB Model*/
                    
                        g_error := g_error || ' / ' || 'PROCEDURE';
                    
                        -- gets value for "to be performed" field according to task dependencies
                        l_flg_time := get_default_task_time_depend(i_id_order_set_proc_task(i));
                    
                        -- gets prescription id                    
                        l_id_task_link := get_odst_proc_task_link(i_id_order_set_proc_task(i), g_task_link_predefined);
                    
                    WHEN i_id_task_type(i) = g_odst_task_bp THEN
                        /*PH - 12-04-2016 - Change Procedures to Procedures DB Model*/
                    
                        g_error := g_error || ' / ' || 'PROCEDURE';
                    
                        -- gets value for "to be performed" field according to task dependencies
                        l_flg_time := get_default_task_time_depend(i_id_order_set_proc_task(i));
                    
                        -- gets prescription id                    
                        l_id_task_link := get_odst_proc_task_link(i_id_order_set_proc_task(i), g_task_link_predefined);
                    
                    WHEN i_id_task_type(i) = g_odst_task_patient_education THEN
                        -- Patient education
                        g_error := g_error || ' / ' || 'PATIENT EDUCATION';
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_LIST.GET_EXAM_TIME', g_package_name);
                    
                        -- gets default value for "to be performed" field
                        IF NOT pk_list.get_exam_time(i_lang  => i_lang,
                                                     i_prof  => i_prof,
                                                     i_type  => 'P',
                                                     o_time  => c_data,
                                                     o_error => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        -- loop until fetch default value
                        LOOP
                            FETCH c_data
                                INTO l_val, l_rank, l_desc_val, l_flg_default;
                        
                            EXIT WHEN l_flg_default = g_yes OR c_data%NOTFOUND;
                        
                        END LOOP;
                        CLOSE c_data;
                    
                        -- add default value for "to be performed" field
                        add_new_task_detail(i_task_details            => l_task_details,
                                            i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                            i_flg_value_type          => g_task_det_value_type_varchar,
                                            i_vvalue                  => l_val,
                                            i_flg_detail_type         => g_task_det_adv_input,
                                            i_id_advanced_input       => 101,
                                            i_id_advanced_input_field => 95);
                    
                        pk_alertlog.log_debug(g_error || ' / ' || 'CALL PK_LIST.CHECK_PARAM', g_package_name);
                    
                        -- gets default value for "begin date" field
                        IF NOT pk_list.check_param(i_lang        => i_lang,
                                                   i_flg_time    => l_val,
                                                   i_flg_tp      => 'M',
                                                   i_prof        => i_prof,
                                                   o_param       => c_data,
                                                   o_sysdate_str => l_o_sysdate_str,
                                                   o_error       => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                        FETCH c_data
                            INTO l_dt_begin,
                                 l_dt_begin_send,
                                 l_flg_edit_dt_begin,
                                 l_dt_end,
                                 l_dt_end_send,
                                 l_flg_edit_dt_end,
                                 l_interval,
                                 l_interval_send,
                                 l_flg_edit_interval,
                                 l_flg_edit_realizacao,
                                 l_min_date;
                        CLOSE c_data;
                    
                        -- add default value for "begin date" field
                        -- if the previous function confirm that it is necessary
                        IF l_flg_edit_dt_begin = g_yes
                        THEN
                            add_new_task_detail(i_task_details            => l_task_details,
                                                i_id_odst_proc_task       => i_id_order_set_proc_task(i),
                                                i_flg_value_type          => g_task_det_value_type_date,
                                                i_dvalue                  => l_o_sysdate_str,
                                                i_flg_detail_type         => g_task_det_adv_input,
                                                i_id_advanced_input       => 101,
                                                i_id_advanced_input_field => 138);
                        END IF;
                    
                    WHEN i_id_task_type(i) = g_odst_task_analysis THEN
                        -- TODO: new lab test
                        -- lab tests
                        g_error := g_error || ' / ' || 'LAB TEST';
                    
                        -- gets value for "to be performed" field according to task dependencies
                        l_flg_time := get_default_task_time_depend(i_id_order_set_proc_task(i));
                    
                        -- gets prescription id                    
                        l_id_task_link := get_odst_proc_task_link(i_id_order_set_proc_task(i), g_task_link_predefined);
                    
                    WHEN i_id_task_type(i) = g_odst_task_medication THEN
                        -- New medication task
                        g_error := g_error || ' / ' || 'NEW MEDICATION TASK';
                    
                        -- gets value for "to be performed" field according to task dependencies
                        l_flg_time := get_default_task_time_depend(i_id_order_set_proc_task(i));
                    
                        -- gets prescription id                    
                        l_id_task_link := get_odst_proc_task_link(i_id_order_set_proc_task(i), g_task_link_null);
                    
                        -- call function to set 'to be performed' field value
                        IF NOT pk_api_pfh_ordertools_in.set_medication_execution_time(i_lang          => i_lang,
                                                                                      i_prof          => i_prof,
                                                                                      i_id_presc      => l_id_task_link,
                                                                                      i_flg_execution => l_flg_time,
                                                                                      o_error         => o_error)
                        THEN
                            RAISE error_unexpected;
                        END IF;
                    
                    WHEN i_id_task_type(i) = g_odst_task_instit_diet THEN
                        -- institutionalized diets
                        g_error := g_error || ' / ' || 'INSTITUTIONALIZED DIET TASK';
                        -- nothing to do here
                
                    WHEN i_id_task_type(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                        -- communication order
                        g_error := g_error || ' / ' || 'COMMUNICATION ORDER TASK';
                        -- nothing to do here                        
                
                    WHEN i_id_task_type(i) = g_odst_task_supplies THEN
                        -- supplies
                        g_error := g_error || ' / ' || 'SUPPLIES TASK';
                        -- nothing to do here       
                
                    WHEN i_id_task_type(i) = g_odst_task_surg_supplies THEN
                        -- surgical supplies
                        g_error := g_error || ' / ' || 'SURGICAL SUPPLIES TASK';
                        -- nothing to do here                          
                
                    ELSE
                        -- Unknown order set task type
                        g_error := g_error || ' / ' || 'UNKNOWN ORDER SET TASK TYPE';
                END CASE;
            
            END LOOP;
        END IF;
    
        g_error := 'update order set process tasks with clinical indications/diagnoses';
        -- get order set process clinical indications/diagnoses descriptions
        SELECT osp.clinical_indications
          INTO l_clinical_indications
          FROM order_set_process osp
         WHERE osp.id_order_set_process = i_id_order_set_process;
    
        -- if the order set already has diagnoses defined on order set editing area
        IF l_clinical_indications IS NOT NULL
        THEN
            -- get diagnosis records
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                         i_prof   => i_prof,
                                                         i_params => l_clinical_indications);
        
            -- convert 'pk_edis_types.rec_in_epis_diagnosis' type to 't_table_diagnoses'
            l_tbl_diagnoses := pk_diagnosis.tf_diagnosis(l_rec_diagnoses);
        
            -- all tasks with clinical indications field will be updated
            -- Prepare input parameters for set_odst_proc_tasks_det_intern function
            FOR rec IN c_diag_tasks
            LOOP
                -- if modular workflow is not supported     
                IF rec.flg_modular_workflow = g_modular_workflow_no_support
                THEN
                    -- loop all diagnoses/clinical indications
                    IF l_tbl_diagnoses IS NOT NULL
                    THEN
                        FOR i IN 1 .. l_tbl_diagnoses.count
                        LOOP
                        
                            -- add value for "clinical indications/diagnoses" field
                            add_new_task_detail(i_task_details      => l_task_details,
                                                i_id_odst_proc_task => rec.id_order_set_process_task,
                                                i_flg_value_type    => g_task_det_value_type_number,
                                                i_nvalue            => l_tbl_diagnoses(i).id_diagnosis, -- id_diagnosis
                                                i_vvalue            => to_char(l_tbl_diagnoses(i).id_alert_diagnosis), -- id_alert_diagnosis
                                                i_flg_detail_type   => g_tsk_det_type_diag);
                        END LOOP;
                    END IF;
                    -- modular workflow is supported
                ELSE
                
                    set_diag_modular_worflow_tasks(i_task_type     => rec.id_task_type,
                                                   i_task_request  => table_number(get_odst_proc_task_link(i_id_order_set_process_task => rec.id_order_set_process_task,
                                                                                                           i_id_flg_task_link_type     => g_task_link_predefined)),
                                                   i_rec_diagnoses => l_rec_diagnoses);
                
                END IF;
            
            END LOOP;
        
            -- if the order set don't have diagnoses defined on order set editing area            
        ELSIF pk_sysconfig.get_config(g_config_auto_fill_diag, i_prof) = pk_alert_constant.g_yes
        THEN
            -- get episode diagnoses
            IF NOT get_order_set_epis_diagnoses(i_lang       => i_lang,
                                                i_prof       => i_prof,
                                                i_id_patient => i_id_patient,
                                                i_id_episode => i_id_episode,
                                                o_epis_diags => c_data,
                                                o_error      => o_error)
            THEN
                RAISE error_unexpected;
            END IF;
        
            FETCH c_data BULK COLLECT
                INTO l_tbl_id_epis_diagnosis,
                     l_tbl_id_diagnosis,
                     l_tbl_id_alert_diagnosis,
                     l_tbl_code_icd,
                     l_tbl_desc_diagnosis,
                     l_tbl_rank,
                     l_tbl_flg_other;
        
            CLOSE c_data;
        
            -- get diagnoses records
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang            => i_lang,
                                                         i_prof            => i_prof,
                                                         i_patient         => i_id_patient,
                                                         i_episode         => i_id_episode,
                                                         i_diagnosis       => l_tbl_id_diagnosis,
                                                         i_alert_diagnosis => l_tbl_id_alert_diagnosis,
                                                         i_desc_diag       => l_tbl_desc_diagnosis);
        
            -- all tasks with clinical indications field will be updated
            -- Prepare input parameters for set_odst_proc_tasks_det_intern function
            FOR rec IN c_diag_tasks
            LOOP
                -- if modular workflow is not supported     
                IF rec.flg_modular_workflow = g_modular_workflow_no_support
                THEN
                    IF l_tbl_id_epis_diagnosis IS NOT NULL
                    THEN
                        FOR i IN 1 .. l_tbl_id_epis_diagnosis.count
                        LOOP
                            IF l_tbl_id_diagnosis(i) IS NOT NULL
                               AND l_tbl_id_alert_diagnosis(i) IS NOT NULL
                            THEN
                            
                                -- add value for "clinical indications/diagnoses" field
                                add_new_task_detail(i_task_details      => l_task_details,
                                                    i_id_odst_proc_task => rec.id_order_set_process_task,
                                                    i_flg_value_type    => g_task_det_value_type_number,
                                                    i_nvalue            => l_tbl_id_diagnosis(i), -- id_diagnosis
                                                    i_vvalue            => to_char(l_tbl_id_alert_diagnosis(i)), -- id_alert_diagnosis
                                                    i_flg_detail_type   => g_tsk_det_type_diag);
                            
                            END IF;
                        END LOOP;
                    END IF;
                
                    -- modular workflow is supported
                ELSE
                
                    set_diag_modular_worflow_tasks(i_task_type     => rec.id_task_type,
                                                   i_task_request  => table_number(get_odst_proc_task_link(i_id_order_set_process_task => rec.id_order_set_process_task,
                                                                                                           i_id_flg_task_link_type     => g_task_link_predefined)),
                                                   i_rec_diagnoses => l_rec_diagnoses);
                
                END IF;
            END LOOP;
        END IF;
    
        g_error := 'CALL SET_ODST_PROC_TASKS_DET_INTERN FUNCTION';
        -- verify if there are tasks with default values to set
        IF l_task_details.id_odst_proc_task.count > 0
        THEN
            -- call function that will insert default values
            IF NOT set_odst_proc_tasks_det_intern(i_lang                        => i_lang,
                                                  i_prof                        => i_prof,
                                                  i_id_order_set_process        => i_id_order_set_process,
                                                  i_id_order_set_proc_tasks     => l_task_details.id_odst_proc_task,
                                                  i_flg_value_type              => l_task_details.flg_value_type,
                                                  i_dvalue                      => l_task_details.dvalue,
                                                  i_nvalue                      => l_task_details.nvalue,
                                                  i_vvalue                      => l_task_details.vvalue,
                                                  i_flg_detail_type             => l_task_details.flg_detail_type,
                                                  i_id_advanced_input           => l_task_details.id_advanced_input,
                                                  i_id_advanced_input_field     => l_task_details.id_advanced_input_field,
                                                  i_id_advanced_input_field_det => l_task_details.id_advanced_input_field_d,
                                                  i_id_unit_measure             => l_task_details.id_unit_measure,
                                                  i_commit                      => g_no,
                                                  o_updated_tasks_instructions  => l_updated_tasks_instructions,
                                                  o_updated_selected_tasks_info => l_updated_selected_tasks_info,
                                                  o_error                       => o_error)
            THEN
                RAISE error_unexpected;
            END IF;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while inserting default values on order set process task details
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_PROC_TASKS_DEF_VALUES',
                                              o_error);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_PROC_TASKS_DEF_VALUES',
                                              o_error);
            RETURN FALSE;
    END set_odst_proc_tasks_def_values;

    FUNCTION create_order_set_process
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_order_set             IN order_set_process.id_order_set%TYPE,
        i_id_order_set_tasks       IN table_number,
        i_id_episode               IN order_set_process.id_episode%TYPE,
        i_id_patient               IN order_set_process.id_patient%TYPE,
        o_id_order_set_process     OUT order_set_process.id_order_set_process%TYPE,
        o_flg_episodes_association OUT VARCHAR2,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_set_process order_set_process%ROWTYPE;
    
        TYPE t_order_set_proc_task IS TABLE OF order_set_process_task%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task t_order_set_proc_task;
    
        TYPE t_order_set_proc_task_link IS TABLE OF order_set_process_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task_link t_order_set_proc_task_link;
    
        TYPE t_order_set_proc_task_detail IS TABLE OF order_set_process_task_det%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task_detail t_order_set_proc_task_detail;
    
        TYPE t_order_set_proc_task_depend IS TABLE OF order_set_process_task_depend%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task_depend t_order_set_proc_task_depend;
    
        TYPE t_order_set_proc_task_group IS TABLE OF order_set_process_task_group%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_proc_task_group t_order_set_proc_task_group;
    
        CURSOR c_tasks IS
            SELECT ost.id_order_set_task, ost.id_task_type, tt.flg_modular_workflow
              FROM order_set_task ost
             INNER JOIN task_type tt
                ON ost.id_task_type = tt.id_task_type
             WHERE ost.id_order_set = i_id_order_set
               AND ost.id_order_set_task IN (SELECT /*+opt_estimate(table odst_tsk rows=1)*/
                                              odst_tsk.column_value
                                               FROM TABLE(i_id_order_set_tasks) odst_tsk);
    
        CURSOR c_task_links(in_id_order_set_task order_set_task_detail.id_order_set_task%TYPE) IS
            SELECT id_task_link, flg_task_link_type
              FROM order_set_task_link
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_task_groups(in_id_order_set_task order_set_task_group.id_order_set_task%TYPE) IS
            SELECT ostg.id_task_group
              FROM order_set_task_group ostg
             WHERE ostg.id_order_set_task = in_id_order_set_task;
    
        CURSOR c_task_details(in_id_order_set_task order_set_task_detail.id_order_set_task%TYPE) IS
            SELECT flg_value_type,
                   nvalue,
                   dvalue,
                   vvalue,
                   flg_detail_type,
                   id_advanced_input,
                   id_advanced_input_field,
                   id_advanced_input_field_det,
                   id_unit_measure
              FROM order_set_task_detail
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_dependency IS
            SELECT odst_tsk_depend.id_relationship_type,
                   odst_tsk_depend.id_order_set_task_from,
                   odst_tsk_depend.id_order_set_task_to,
                   odst_tsk_depend.lag_min,
                   odst_tsk_depend.lag_max,
                   odst_tsk_depend.id_unit_measure_lag
              FROM order_set_task_dependency odst_tsk_depend
             WHERE odst_tsk_depend.id_order_set = i_id_order_set
               AND odst_tsk_depend.id_order_set_task_to IN
                   (SELECT /*+opt_estimate(table odst_tsk_to rows=1)*/
                     odst_tsk_to.column_value
                      FROM TABLE(i_id_order_set_tasks) odst_tsk_to)
               AND odst_tsk_depend.id_order_set_task_from != to_number(g_depend_future_epis);
    
        l_id_order_set_process      order_set_process.id_order_set_process%TYPE;
        l_id_order_set_process_task order_set_process_task.id_order_set_process_task%TYPE;
        l_id_task_type              order_set_process_task.id_task_type%TYPE;
        l_sysdate                   TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
        l_task_counter              NUMBER;
        l_task_link_counter         NUMBER;
        l_task_group_counter        NUMBER;
        l_task_det_counter          NUMBER;
        l_task_depend_counter       NUMBER;
        l_global_notes              order_set.notes_global%TYPE;
        l_clinical_indications      CLOB;
    
        ibt_all_proc_tasks table_number := table_number();
        ibt_task_type      table_number := table_number();
    
        l_flg_episode_association VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_flg_task_episode        VARCHAR2(1 CHAR);
        l_flg_task_schedule       VARCHAR2(1 CHAR);
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        TYPE t_record_task_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200 CHAR);
        ibt_task_map t_record_task_map;
    
        error_unexpected EXCEPTION;
        l_exception      EXCEPTION;
    
        -- check if an order set task is an episode or not
        FUNCTION check_episode_task(in_task_type order_set_task.id_task_type%TYPE) RETURN VARCHAR2 IS
            l_flg_episode_task task_type.flg_episode_task%TYPE;
        BEGIN
            -- get task type episode support flag value
            SELECT tsk_type.flg_episode_task
              INTO l_flg_episode_task
              FROM task_type tsk_type
             WHERE tsk_type.id_task_type = in_task_type;
        
            -- task type represents an episode            
            IF l_flg_episode_task = pk_alert_constant.g_tt_tde_support_epis
            THEN
                RETURN pk_alert_constant.g_yes;
            ELSE
                RETURN pk_alert_constant.g_no;
            END IF;
        
        END check_episode_task;
    
    BEGIN
    
        g_error := 'GET ORDER SET GLOBAL NOTES';
        -- get order set global notes
        SELECT notes_global, clinical_indications
          INTO l_global_notes, l_clinical_indications
          FROM order_set
         WHERE id_order_set = i_id_order_set;
    
        g_error                                       := 'GET ORDER SET PROCESS - SET VARIABLES';
        l_order_set_process.id_order_set_process      := seq_order_set_process.nextval;
        l_order_set_process.id_order_set              := i_id_order_set;
        l_order_set_process.notes_global              := l_global_notes;
        l_order_set_process.additional_info           := NULL;
        l_order_set_process.id_episode                := i_id_episode;
        l_order_set_process.id_patient                := i_id_patient;
        l_order_set_process.flg_status                := g_order_set_proc_temp;
        l_order_set_process.dt_status_tstz            := l_sysdate;
        l_order_set_process.id_professional           := i_prof.id;
        l_order_set_process.dt_order_set_process_tstz := l_sysdate;
        l_order_set_process.id_prof_request           := i_prof.id;
        l_order_set_process.dt_order                  := current_timestamp;
        l_order_set_process.clinical_indications      := l_clinical_indications;
    
        -- get new order set process id
        l_id_order_set_process := l_order_set_process.id_order_set_process;
    
        g_error := 'GET ORDER SET DEPENDENCIES NETWORK';
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET PROCESS TASKS, RELATED LINKS AND DETAILS - SET VARIABLES';
        -- loop for each order set task
        FOR rec_task IN c_tasks
        LOOP
        
            -- verify if this task is an episode (and not if it is schedulable)
            l_flg_task_episode := check_episode_task(rec_task.id_task_type);
        
            -- verify if this task is schedulable
            l_flg_task_schedule := check_episode_support_task(i_lang                 => i_lang,
                                                              i_prof                 => i_prof,
                                                              i_dependency_type      => l_dependency_type,
                                                              i_task_dependency_from => l_task_dependency_from,
                                                              i_task_dependency_to   => l_task_dependency_to,
                                                              i_order_set_task       => rec_task.id_order_set_task,
                                                              i_task_type            => rec_task.id_task_type);
        
            -- update episode association flag if necessary
            -- this flag indicates if this order set process contains episode tasks or not
            IF l_flg_episode_association = pk_alert_constant.g_no
            THEN
                l_flg_episode_association := l_flg_task_episode;
            END IF;
        
            l_task_counter := ibt_order_set_proc_task.count + 1;
            ibt_order_set_proc_task(l_task_counter).id_order_set_process_task := seq_order_set_process_task.nextval;
            ibt_order_set_proc_task(l_task_counter).id_order_set_process := l_id_order_set_process;
            ibt_order_set_proc_task(l_task_counter).id_task_type := rec_task.id_task_type;
            ibt_order_set_proc_task(l_task_counter).flg_status := g_order_set_proc_tsk_temp;
            ibt_order_set_proc_task(l_task_counter).dt_status_tstz := l_sysdate;
            ibt_order_set_proc_task(l_task_counter).id_request := NULL;
            ibt_order_set_proc_task(l_task_counter).dt_request_tstz := NULL;
            ibt_order_set_proc_task(l_task_counter).id_professional := i_prof.id;
            ibt_order_set_proc_task(l_task_counter).flg_schedule := l_flg_task_schedule;
            ibt_order_set_proc_task(l_task_counter).flg_order_set_task := pk_alert_constant.g_yes;
            ibt_order_set_proc_task(l_task_counter).flg_discard_type := pk_alert_constant.g_no;
        
            -- get new order set process task and task type ids
            l_id_order_set_process_task := ibt_order_set_proc_task(l_task_counter).id_order_set_process_task;
            l_id_task_type              := rec_task.id_task_type;
        
            -- store the mapping between id_order_set_task and id_order_set_process_task
            -- this mapping will be necessary to copy order set task dependencies to the process
            ibt_task_map(to_char(rec_task.id_order_set_task)) := l_id_order_set_process_task;
        
            -- collect all process task IDs
            ibt_all_proc_tasks.extend;
            ibt_all_proc_tasks(ibt_all_proc_tasks.count) := l_id_order_set_process_task;
            ibt_task_type.extend;
            ibt_task_type(ibt_task_type.count) := l_id_task_type;
        
            -- insert all task links 
            FOR rec_task_link IN c_task_links(rec_task.id_order_set_task)
            LOOP
                l_task_link_counter := ibt_order_set_proc_task_link.count + 1;
                ibt_order_set_proc_task_link(l_task_link_counter).id_order_set_process_task := l_id_order_set_process_task;
                ibt_order_set_proc_task_link(l_task_link_counter).flg_task_link_type := rec_task_link.flg_task_link_type;
            
                -- check if modular workflow is supported                    
                IF (rec_task.flg_modular_workflow = g_modular_workflow_support
                   -- TODO: the following two lines are temporary
                   -- They are necessary just because this function is used to migrate labs,
                   -- image and other exams tasks from old architecture to the predefined task architecture.
                   -- After the script is versioned and executed in the production environment, these two lines can be removed. 
                   AND (rec_task_link.flg_task_link_type = g_task_link_predefined OR
                   rec_task.id_task_type IN (g_odst_task_medication, g_odst_task_instit_diet)))
                THEN
                    -- create copy of predefined tasks (check rec_task.flg_modular_workflow value)
                    CASE
                        WHEN rec_task.id_task_type = g_odst_task_medication THEN
                            -- duplicate predefined medication task
                            IF NOT pk_api_pfh_ordertools_in.copy_medication_task(i_lang       => i_lang,
                                                                                 i_prof       => i_prof,
                                                                                 i_id_presc   => rec_task_link.id_task_link,
                                                                                 i_id_patient => i_id_patient,
                                                                                 i_id_episode => i_id_episode,
                                                                                 o_id_presc   => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                                 o_error      => o_error)
                            THEN
                                g_error := 'error found while calling pk_api_pfh_ordertools_in.copy_medication_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_instit_diet THEN
                            -- copy institutionalized diet task and associate with patient/episode
                            IF NOT pk_diet.set_pat_diet_task(i_lang       => i_lang,
                                                             i_prof       => i_prof,
                                                             i_id_episode => i_id_episode,
                                                             i_id_patient => i_id_patient,
                                                             i_id_task    => rec_task_link.id_task_link,
                                                             o_id_task    => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                             o_error      => o_error)
                            THEN
                                g_error := 'error found while calling pk_diet.set_pat_diet_task function';
                                RAISE error_unexpected;
                            END IF;
                        
                            IF ibt_order_set_proc_task_link(l_task_link_counter).id_task_link IS NULL
                            THEN
                                g_error := 'error found while calling pk_diet.set_pat_diet_task function';
                                RAISE error_unexpected;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_analysis THEN
                            -- copy lab test task and associate with patient/episode
                            IF NOT pk_lab_tests_external_api_db.set_lab_test_copy_task(i_lang         => i_lang,
                                                                                       i_prof         => i_prof,
                                                                                       i_patient      => i_id_patient,
                                                                                       i_episode      => i_id_episode,
                                                                                       i_task_request => rec_task_link.id_task_link,
                                                                                       o_task_request => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                                       o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_procedure THEN
                            -- copy procedure task and associate with patient/episode
                        
                            IF NOT pk_procedures_external_api_db.set_procedure_copy_task(i_lang         => i_lang,
                                                                                         i_prof         => i_prof,
                                                                                         i_patient      => i_id_patient,
                                                                                         i_episode      => i_id_episode,
                                                                                         i_task_request => rec_task_link.id_task_link,
                                                                                         o_interv_presc => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                                         o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_bp THEN
                            -- copy procedure task and associate with patient/episode
                        
                            IF NOT pk_bp_external_api_db.set_bp_copy_task(i_lang         => i_lang,
                                                                          i_prof         => i_prof,
                                                                          i_patient      => i_id_patient,
                                                                          i_episode      => i_id_episode,
                                                                          i_task_request => rec_task_link.id_task_link,
                                                                          o_bp_req       => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                          o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                            --raise_application_error(-20001,'TesteOS');
                        
                            IF NOT pk_inp_hidrics_pbl.set_hidric_copy_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_patient      => i_id_patient,
                                                                           i_episode      => i_id_episode,
                                                                           i_task_request => rec_task_link.id_task_link,
                                                                           o_epis_hidrics => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                           o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_inp_hidrics_pbl.set_hidric_copy_task';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                            -- copy image or other exam task and associate with patient/episode
                            IF NOT pk_exams_external_api_db.set_exam_copy_task(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_patient      => i_id_patient,
                                                                               i_episode      => i_id_episode,
                                                                               i_task_request => rec_task_link.id_task_link,
                                                                               o_exam_req     => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                               o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_exams_external_api_db.set_exam_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                            -- duplicate communication order task
                        
                            IF NOT pk_comm_orders_order_sets.copy_comm_order_req(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_id_comm_order_req => rec_task_link.id_task_link,
                                                                                 i_id_patient        => i_id_patient,
                                                                                 i_id_episode        => i_id_episode,
                                                                                 i_dt_begin          => l_sysdate,
                                                                                 o_id_comm_order_req => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                                 o_error             => o_error)
                            THEN
                                g_error := 'error found while calling pk_comm_orders_order_sets.copy_comm_order_req function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                            -- duplicate supply or surgical supply task
                        
                            IF NOT pk_supplies_order_sets.copy_supply_wf(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_id_supply_workflow => rec_task_link.id_task_link,
                                                                         i_id_episode         => i_id_episode,
                                                                         i_dt_request         => l_sysdate,
                                                                         o_id_supply_workflow => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                         o_error              => o_error)
                            THEN
                                g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN l_id_task_type = g_odst_task_inpatient THEN
                            IF NOT pk_admission_request.copy_adm_request_wf(i_lang           => i_lang,
                                                                            i_prof           => i_prof,
                                                                            i_id_adm_request => rec_task_link.id_task_link,
                                                                            i_id_episode     => i_id_episode,
                                                                            i_dt_request     => l_sysdate,
                                                                            i_sur_need       => pk_alert_constant.g_no,
                                                                            o_id_adm_request => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                            o_error          => o_error)
                            THEN
                                g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN l_id_task_type = g_odst_task_inp_surg THEN
                            IF NOT pk_admission_request.copy_adm_request_wf(i_lang           => i_lang,
                                                                            i_prof           => i_prof,
                                                                            i_id_adm_request => rec_task_link.id_task_link,
                                                                            i_id_episode     => i_id_episode,
                                                                            i_dt_request     => l_sysdate,
                                                                            i_sur_need       => pk_alert_constant.g_yes,
                                                                            o_id_adm_request => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                            o_error          => o_error)
                            THEN
                                g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                RAISE l_exception;
                            END IF;
                        WHEN rec_task.id_task_type = g_odst_task_consult THEN
                            -- copy procedure task and associate with patient/episode                            
                            IF NOT pk_opinion.set_opinion_copy_task(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_patient      => i_id_patient,
                                                                    i_episode      => i_id_episode,
                                                                    i_task_request => rec_task_link.id_task_link,
                                                                    o_opinion      => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                    o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_copy_task';
                                RAISE l_exception;
                            END IF;
                        WHEN rec_task.id_task_type = g_odst_task_patient_education THEN
                            -- copy patient education with patient/episode                               
                            IF NOT pk_patient_education_api_db.set_ntr_copy_task(i_lang          => i_lang,
                                                                                 i_prof          => i_prof,
                                                                                 i_patient       => i_id_patient,
                                                                                 i_episode       => i_id_episode,
                                                                                 i_task_request  => rec_task_link.id_task_link,
                                                                                 o_nurse_tea_req => ibt_order_set_proc_task_link(l_task_link_counter).id_task_link,
                                                                                 o_error         => o_error)
                            THEN
                                g_error := 'error found while calling pk_patient_education_api_db.set_ntr_copy_task';
                                RAISE l_exception;
                            END IF;
                        ELSE
                            g_error := 'predefined task is not supported for task type [' || rec_task.id_task_type || ']';
                            RAISE l_exception;
                        
                    END CASE;
                ELSE
                    -- modular workflow not is supported (copy id_task to new order set)
                    ibt_order_set_proc_task_link(l_task_link_counter).id_task_link := rec_task_link.id_task_link;
                END IF;
            END LOOP;
        
            -- insert all task details
            FOR rec_task_det IN c_task_details(rec_task.id_order_set_task)
            LOOP
                l_task_det_counter := ibt_order_set_proc_task_detail.count + 1;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_order_set_process_task_det := seq_order_set_process_task_det.nextval;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_order_set_process_task := l_id_order_set_process_task;
                ibt_order_set_proc_task_detail(l_task_det_counter).flg_value_type := rec_task_det.flg_value_type;
                ibt_order_set_proc_task_detail(l_task_det_counter).nvalue := rec_task_det.nvalue;
                ibt_order_set_proc_task_detail(l_task_det_counter).dvalue := rec_task_det.dvalue;
                ibt_order_set_proc_task_detail(l_task_det_counter).vvalue := rec_task_det.vvalue;
                ibt_order_set_proc_task_detail(l_task_det_counter).flg_detail_type := rec_task_det.flg_detail_type;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_advanced_input := rec_task_det.id_advanced_input;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_advanced_input_field := rec_task_det.id_advanced_input_field;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_advanced_input_field_det := rec_task_det.id_advanced_input_field_det;
                ibt_order_set_proc_task_detail(l_task_det_counter).id_unit_measure := rec_task_det.id_unit_measure;
            
            END LOOP;
        
            -- insert all task groups
            FOR rec_task_group IN c_task_groups(rec_task.id_order_set_task)
            LOOP
                l_task_group_counter := ibt_order_set_proc_task_group.count + 1;
                ibt_order_set_proc_task_group(l_task_group_counter).id_order_set_process_task := l_id_order_set_process_task;
                ibt_order_set_proc_task_group(l_task_group_counter).id_task_group := rec_task_group.id_task_group;
            END LOOP;
        
        END LOOP;
    
        -- add to the task map the current episode and future episode dependencies
        ibt_task_map(g_depend_current_epis) := to_number(g_depend_current_epis);
        ibt_task_map(g_depend_future_epis) := to_number(g_depend_future_epis);
    
        g_error := 'INSERT PROCESS TASKS DEPENDENCIES';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- insert all task dependencies
        FOR rec_task_depend IN c_order_set_task_dependency
        LOOP
        
            l_task_depend_counter := ibt_order_set_proc_task_depend.count + 1;
            ibt_order_set_proc_task_depend(l_task_depend_counter).id_relationship_type := rec_task_depend.id_relationship_type;
            ibt_order_set_proc_task_depend(l_task_depend_counter).id_order_set_proc_task_from := ibt_task_map(to_char(rec_task_depend.id_order_set_task_from));
            ibt_order_set_proc_task_depend(l_task_depend_counter).id_order_set_proc_task_to := ibt_task_map(to_char(rec_task_depend.id_order_set_task_to));
            ibt_order_set_proc_task_depend(l_task_depend_counter).lag_min := rec_task_depend.lag_min;
            ibt_order_set_proc_task_depend(l_task_depend_counter).lag_max := rec_task_depend.lag_max;
            ibt_order_set_proc_task_depend(l_task_depend_counter).id_unit_measure_lag := rec_task_depend.id_unit_measure_lag;
            ibt_order_set_proc_task_depend(l_task_depend_counter).id_order_set_process := l_id_order_set_process;
        
        END LOOP;
    
        g_error := 'INSERT ORDER SET PROCESS';
        INSERT INTO order_set_process
        VALUES l_order_set_process;
    
        g_error := 'INSERT ORDER SET PROCESS TASKS';
        IF ibt_order_set_proc_task.count > 0
        THEN
            pk_alertlog.log_debug('PASSOU INSERT ORDER SET PROCESS TASKS', g_package_name);
        
            FORALL i IN ibt_order_set_proc_task.first .. ibt_order_set_proc_task.last
                INSERT INTO order_set_process_task
                VALUES ibt_order_set_proc_task
                    (i);
        END IF;
    
        g_error := 'INSERT ORDER SET PROCESS TASK LINKS';
        IF ibt_order_set_proc_task_link.count > 0
        THEN
        
            FORALL i IN ibt_order_set_proc_task_link.first .. ibt_order_set_proc_task_link.last
                INSERT INTO order_set_process_task_link
                VALUES ibt_order_set_proc_task_link
                    (i);
        END IF;
    
        g_error := 'INSERT ORDER SET PROCESS TASK GROUPS';
        IF ibt_order_set_proc_task_group.count > 0
        THEN
        
            FORALL i IN ibt_order_set_proc_task_group.first .. ibt_order_set_proc_task_group.last
                INSERT INTO order_set_process_task_group
                VALUES ibt_order_set_proc_task_group
                    (i);
        END IF;
    
        g_error := 'INSERT ORDER SET PROCESS TASK DETAILS';
        IF ibt_order_set_proc_task_detail.count > 0
        THEN
        
            FORALL i IN ibt_order_set_proc_task_detail.first .. ibt_order_set_proc_task_detail.last
                INSERT INTO order_set_process_task_det
                VALUES ibt_order_set_proc_task_detail
                    (i);
        END IF;
    
        g_error := 'INSERT ORDER SET PROCESS TASK DEPENDENCIES';
        IF ibt_order_set_proc_task_depend.count > 0
        THEN
        
            FORALL i IN ibt_order_set_proc_task_depend.first .. ibt_order_set_proc_task_depend.last
                INSERT INTO order_set_process_task_depend
                VALUES ibt_order_set_proc_task_depend
                    (i);
        END IF;
    
        g_error := 'CALL FUNCTION TO INSERT DEFAULT VALUES ON ORDER SET PROCESS TASKS DETAILS';
        -- call function that will insert default values on process task details
        IF NOT set_odst_proc_tasks_def_values(i_lang,
                                              i_prof,
                                              i_id_episode,
                                              i_id_patient,
                                              l_id_order_set_process,
                                              ibt_all_proc_tasks,
                                              ibt_task_type,
                                              o_error)
        THEN
            RAISE error_unexpected;
        END IF;
    
        o_id_order_set_process     := l_id_order_set_process;
        o_flg_episodes_association := l_flg_episode_association;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN error_unexpected THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              g_error,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_ORDER_SET_PROCESS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CREATE_ORDER_SET_PROCESS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END create_order_set_process;

    FUNCTION get_episode_desc
    (
        i_lang    IN language.id_language%TYPE,
        i_prof    IN profissional,
        i_patient IN patient.id_patient%TYPE,
        i_episode IN episode.id_episode%TYPE
    ) RETURN VARCHAR2 IS
    
        l_description VARCHAR2(1000 CHAR);
    
        l_future_event pk_types.cursor_type;
    
        l_id_consult_req              NUMBER(24);
        l_id_episode                  NUMBER(24);
        l_id_schedule                 NUMBER(24);
        l_event_type                  VARCHAR2(1000 CHAR);
        l_event_type_name_title       pk_translation.t_desc_translation;
        l_event_type_clinical_service pk_translation.t_desc_translation;
        l_sch_type_desc               pk_translation.t_desc_translation;
        l_desc_prof                   VARCHAR2(1000 CHAR);
        l_request_status_desc         VARCHAR2(1000 CHAR);
        l_event_date                  VARCHAR2(1000 CHAR);
        l_event_date_ux               VARCHAR2(1000 CHAR);
        l_event_date_str              VARCHAR2(30 CHAR);
    
        l_error t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        -- call future events function to get 
        -- appointment episode details
        IF NOT pk_events.get_epis_short_detail(i_lang, i_prof, i_patient, i_episode, l_future_event, l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- fetch data (episode details)
        FETCH l_future_event
            INTO l_id_consult_req,
                 l_id_episode,
                 l_id_schedule,
                 l_event_type,
                 l_event_type_name_title,
                 l_event_type_clinical_service,
                 l_sch_type_desc,
                 l_desc_prof,
                 l_request_status_desc,
                 l_event_date,
                 l_event_date_ux;
    
        CLOSE l_future_event;
    
        -- build appointment episode description
        l_description := '<b>' || l_event_type_name_title || '</b>' || chr(10);
        l_description := l_description || l_event_type_clinical_service || (CASE
                             WHEN l_sch_type_desc IS NOT NULL THEN
                              '; ' || l_sch_type_desc
                         END) || (CASE
                             WHEN l_desc_prof IS NOT NULL THEN
                              '; ' || l_desc_prof
                         END);
    
        -- append event suggested date
        IF l_event_date_ux IS NOT NULL
        THEN
        
            -- get event date string
            l_event_date_str := pk_date_utils.date_chr_short_read_tsz(i_lang,
                                                                      pk_date_utils.get_string_tstz(i_lang,
                                                                                                    i_prof,
                                                                                                    l_event_date_ux,
                                                                                                    NULL),
                                                                      i_prof.institution,
                                                                      i_prof.software);
        
            l_description := l_description || chr(10) || l_event_date_str || ' ' || l_request_status_desc;
        END IF;
    
        RETURN l_description;
    
    END get_episode_desc;

    FUNCTION get_odst_proc_association_epis
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_patient                IN patient.id_patient%TYPE,
        i_episode                IN episode.id_episode%TYPE,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE,
        o_episodes_list          OUT pk_types.cursor_type,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_odst_proc_task_type order_set_process_task.id_order_set_process_task%TYPE := get_odst_proc_task_type(i_lang,
                                                                                                               i_prof,
                                                                                                               i_order_set_process_task);
    
        l_data                pk_types.cursor_type;
        l_surgical_procedures table_number;
        l_dummy_table_varchar table_varchar;
        l_dummy_table_number  table_number;
    
        l_episodes table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ASSOCIATION EPISODES';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        CASE l_odst_proc_task_type
            WHEN g_odst_task_appoint_social THEN
                -- Social Assistance Appointment
                g_error := g_error || ' / ' || 'SOCIAL ASSISTANCE APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_social,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_appoint_nurse THEN
                -- Nursing Appointment
                g_error := g_error || ' / ' || 'NURSING APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_nurse,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_appoint_medical THEN
                -- Medical Appointment
                g_error := g_error || ' / ' || 'MEDICAL APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_medical,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_appoint_nutrition THEN
                -- Nutrition Appointment
                g_error := g_error || ' / ' || 'NUTRITION APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_nutrition,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_appoint_psychology THEN
                -- Psychology Appointment
                g_error := g_error || ' / ' || 'PSYCHOLOGY APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_psychology,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_appoint_rehabilit THEN
                -- Rehabilitation Appointment
                g_error := g_error || ' / ' || 'REHABILITATION APPOINTMENT';
            
                -- get episodes list data
                IF NOT pk_events.get_episode_list(i_lang           => i_lang,
                                                  i_prof           => i_prof,
                                                  i_patient        => i_patient,
                                                  i_task_type      => g_odst_task_appoint_rehabilit,
                                                  i_dep_clin_serv  => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_type,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  i_inst_requested => get_odst_proc_task_det_val(i_lang,
                                                                                                 i_prof,
                                                                                                 i_order_set_process_task,
                                                                                                 g_tsk_det_type_appoint_locat,
                                                                                                 NULL,
                                                                                                 NULL,
                                                                                                 NULL),
                                                  o_list           => l_data,
                                                  o_error          => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes;
                CLOSE l_data;
            
            WHEN g_odst_task_inpatient THEN
                -- inpatient episode
                g_error := g_error || ' / ' || 'INPATIENT EPISODE';
            
                IF NOT pk_wtl_pbl_core.get_episode_like_inp(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_id_patient        => i_patient,
                                                            i_id_adm_indication => get_odst_proc_task_det_val(i_lang,
                                                                                                              i_prof,
                                                                                                              i_order_set_process_task,
                                                                                                              g_tsk_det_type_inp_adm,
                                                                                                              NULL,
                                                                                                              NULL,
                                                                                                              NULL),
                                                            i_flg_schedule      => pk_alert_constant.g_yes,
                                                            o_epis_data         => l_data,
                                                            o_error             => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes, l_dummy_table_number, l_dummy_table_varchar, l_dummy_table_varchar;
                CLOSE l_data;
            
            WHEN g_odst_task_inp_surg THEN
                -- inpatient with surgery episode
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE';
            
                -- get surgery procedures arrays          
                get_odst_prc_tsk_det_multi_val(i_lang                      => i_lang,
                                               i_prof                      => i_prof,
                                               i_id_order_set_process_task => i_order_set_process_task,
                                               i_flg_detail_type           => g_tsk_det_type_surg_proc,
                                               o_nvalues                   => l_surgical_procedures,
                                               o_vvalues                   => l_dummy_table_varchar,
                                               o_dvalues                   => l_dummy_table_varchar);
            
                IF NOT pk_wtl_pbl_core.get_episode_like_inp_oris(i_lang               => i_lang,
                                                                 i_prof               => i_prof,
                                                                 i_id_patient         => i_patient,
                                                                 i_id_adm_indication  => get_odst_proc_task_det_val(i_lang,
                                                                                                                    i_prof,
                                                                                                                    i_order_set_process_task,
                                                                                                                    g_tsk_det_type_inp_adm,
                                                                                                                    NULL,
                                                                                                                    NULL,
                                                                                                                    NULL),
                                                                 i_id_sr_intervention => l_surgical_procedures,
                                                                 i_flg_schedule       => pk_alert_constant.g_yes,
                                                                 o_epis_data          => l_data,
                                                                 o_error              => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes,
                         l_dummy_table_number,
                         l_dummy_table_number,
                         l_dummy_table_varchar,
                         l_dummy_table_varchar;
                CLOSE l_data;
            
            WHEN g_odst_task_inpatient_ptbr THEN
                -- inpatient episode for pt/br makerts
                g_error := g_error || ' / ' || 'INPATIENT EPISODE FOR PT/BR MAKERTS';
            
                IF NOT pk_wtl_pbl_core.get_episode_like_inp(i_lang              => i_lang,
                                                            i_prof              => i_prof,
                                                            i_id_patient        => i_patient,
                                                            i_id_adm_indication => NULL,
                                                            i_flg_schedule      => pk_alert_constant.g_yes,
                                                            o_epis_data         => l_data,
                                                            o_error             => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                -- fetch data               
                FETCH l_data BULK COLLECT
                    INTO l_episodes, l_dummy_table_number, l_dummy_table_varchar, l_dummy_table_varchar;
                CLOSE l_data;
            
            WHEN g_odst_task_inp_surg_ptbr THEN
                -- inpatient with surgery episode for pt/br markets
                g_error := g_error || ' / ' || 'INPATIENT WITH SURGERY EPISODE FOR PT/BR MAKERTS';
            
                -- TODO: future improvement
                NULL;
            
            ELSE
                -- unknown episode type
                g_error := g_error || ' / ' || 'UNKNOWN EPISODE TYPE';
                RAISE l_exception;
        END CASE;
    
        g_error := 'OPEN EPISODES LIST CURSOR';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        OPEN o_episodes_list FOR
            SELECT epis_list.column_value id_episode,
                   get_episode_desc(i_lang, i_prof, i_patient, epis_list.column_value) episode_desc
              FROM TABLE(l_episodes) epis_list;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_PROC_ASSOCIATION_EPIS',
                                              o_error);
        
            pk_types.open_my_cursor(o_episodes_list);
            RETURN FALSE;
    END get_odst_proc_association_epis;

    FUNCTION get_order_set_proc_episodes
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_patient           IN patient.id_patient%TYPE,
        i_episode           IN episode.id_episode%TYPE,
        i_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_episodes_list     OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET ORDER SET PROCESS EPISODE TASKS';
        OPEN o_episodes_list FOR
            SELECT odst_proc_task.id_task_type id_task_type,
                   odst_proc_task.id_order_set_process_task id_odst_episode,
                   get_task_desc(i_lang,
                                 i_prof,
                                 odst_proc_task.id_order_set_process_task,
                                 odst_proc_task.id_task_type,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_yes,
                                 g_task_desc_extended_format,
                                 pk_alert_constant.g_no) odst_episode_desc,
                   odst_proc_task.id_request id_requested_episode,
                   nvl2(odst_proc_task.id_request,
                        get_episode_desc(i_lang, i_prof, i_patient, odst_proc_task.id_request),
                        NULL) requested_episode_desc,
                   nvl2(odst_proc_task.id_request, odst_proc_task.flg_order_set_task, NULL) flg_new_epis_req,
                   osptl.id_task_link waiting_list
              FROM order_set_process_task odst_proc_task
             INNER JOIN task_type tsk_type
                ON (odst_proc_task.id_task_type = tsk_type.id_task_type)
              LEFT JOIN order_set_process_task_link osptl
                ON osptl.id_order_set_process_task = odst_proc_task.id_order_set_process_task
             WHERE tsk_type.flg_episode_task = pk_alert_constant.g_tt_tde_support_epis
               AND odst_proc_task.id_order_set_process = i_order_set_process
             ORDER BY odst_episode_desc;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_EPISODES',
                                              o_error);
        
            pk_types.open_my_cursor(o_episodes_list);
            RETURN FALSE;
        
    END get_order_set_proc_episodes;

    FUNCTION set_order_set_proc_episode
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE,
        i_episode_task           IN order_set_process_task.id_request%TYPE,
        i_flg_new_epis_req       IN VARCHAR2,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_sysdate TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
    BEGIN
    
        g_error := 'SET AN ORDER SET PROCESS EPISODE';
        UPDATE order_set_process_task
           SET id_request = i_episode_task, dt_request_tstz = l_sysdate, flg_order_set_task = i_flg_new_epis_req
         WHERE id_order_set_process_task = i_order_set_process_task
           AND flg_status = g_order_set_proc_tsk_temp;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_EPISODE',
                                              o_error);
        
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_proc_episode;

    FUNCTION del_order_set_proc_episode
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof                   IN profissional,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE,
        o_error                  OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        -- cancel episode if its requisition was created for this order set process
        IF NOT cancel_odst_proc_task_episode(i_lang                   => i_lang,
                                             i_prof                   => i_prof,
                                             i_order_set_process_task => i_order_set_process_task,
                                             i_transaction_id         => l_transaction_id,
                                             o_error                  => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- remove requisition data from this order set task process 
        UPDATE order_set_process_task
           SET id_request = NULL, dt_request_tstz = NULL
         WHERE id_order_set_process_task = i_order_set_process_task
           AND flg_status = g_order_set_proc_tsk_temp;
    
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'DEL_ORDER_SET_PROC_EPISODE',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END del_order_set_proc_episode;
    FUNCTION check_cancel_order_set_proc
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE
    ) RETURN VARCHAR2 IS
    
        CURSOR c_odst_proc_tsk IS
            SELECT odst_proc_tsk.id_order_set_process_task
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
               AND odst_proc_tsk.flg_status = g_order_set_proc_tsk_running;
    
    BEGIN
    
        g_error := 'CHECK CANCEL ORDER SET PROCESS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- verify if this order set has tasks that cannot be canceled by this user
        FOR rec IN c_odst_proc_tsk
        LOOP
        
            IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                           i_prof_id                => i_prof.id,
                                           i_prof_inst              => i_prof.institution,
                                           i_prof_soft              => i_prof.software,
                                           i_episode                => i_id_episode,
                                           i_order_set_process_task => rec.id_order_set_process_task) =
               pk_alert_constant.g_no
            THEN
            
                RETURN g_not_available;
            
            END IF;
        END LOOP;
    
        RETURN g_available;
    
    END check_cancel_order_set_proc;

    FUNCTION check_cancel_odst_proc_cosign
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_flg_needs_cosign     OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_odst_proc_tsk IS
            SELECT odst_proc_tsk.id_order_set_process_task, odst_proc_tsk.id_task_type
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
               AND odst_proc_tsk.flg_status = g_order_set_proc_tsk_running;
    
    BEGIN
    
        g_error := 'CHECK CANCEL ORDER SET PROCESS NEEDS CO-SIGN';
        -- verify if this order set has tasks that needs co-sign to be canceled
        FOR rec IN c_odst_proc_tsk
        LOOP
            IF check_cancel_odst_proc_task(i_lang                   => i_lang,
                                           i_prof_id                => i_prof.id,
                                           i_prof_inst              => i_prof.institution,
                                           i_prof_soft              => i_prof.software,
                                           i_episode                => i_id_episode,
                                           i_order_set_process_task => rec.id_order_set_process_task) =
               pk_alert_constant.g_yes
               AND check_cancel_task_needs_cosign(i_lang                      => i_lang,
                                                  i_prof_id                   => i_prof.id,
                                                  i_prof_inst                 => i_prof.institution,
                                                  i_prof_soft                 => i_prof.software,
                                                  i_episode                   => i_id_episode,
                                                  i_id_order_set_process_task => (CASE rec.id_task_type
                                                                                     WHEN g_odst_task_medication THEN
                                                                                     -- this parameter is needed, because only the medication module knows what is the type of each prescription contained in the order set
                                                                                      rec.id_order_set_process_task
                                                                                     ELSE
                                                                                     -- for the other types of tasks this parameter is passed with null value, in order to take advantage of the result cache by task type
                                                                                      NULL
                                                                                 END),
                                                  i_task_type                 => rec.id_task_type) =
               pk_alert_constant.g_yes
            THEN
                o_flg_needs_cosign := g_available;
                RETURN TRUE;
            END IF;
        
        END LOOP;
    
        o_flg_needs_cosign := g_not_available;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_CANCEL_ODST_PROC_COSIGN',
                                              o_error);
            RETURN FALSE;
    END check_cancel_odst_proc_cosign;

    FUNCTION check_canc_odst_prc_tsk_cosign
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_episode              IN episode.id_episode%TYPE,
        i_id_order_set_proc_tasks IN table_number,
        o_flg_needs_cosign        OUT VARCHAR2,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_odst_proc_tsk IS
            SELECT odst_proc_tsk.id_order_set_process_task, odst_proc_tsk.id_task_type
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.flg_status = g_order_set_proc_tsk_running
               AND odst_proc_tsk.id_order_set_process_task IN
                   (SELECT /*+ opt_estimate(table t rows = 1) */
                     column_value
                      FROM TABLE(i_id_order_set_proc_tasks) t);
    
    BEGIN
    
        g_error := 'CHECK CANCEL ORDER SET PROCESS';
        -- verify if there are tasks that need co-sign to be canceled
        FOR rec IN c_odst_proc_tsk
        LOOP
            IF check_cancel_task_needs_cosign(i_lang                      => i_lang,
                                              i_prof_id                   => i_prof.id,
                                              i_prof_inst                 => i_prof.institution,
                                              i_prof_soft                 => i_prof.software,
                                              i_episode                   => i_id_episode,
                                              i_id_order_set_process_task => (CASE rec.id_task_type
                                                                                 WHEN g_odst_task_medication THEN
                                                                                 -- this parameter is needed, because only the medication module knows what is the type of each prescription contained in the order set
                                                                                  rec.id_order_set_process_task
                                                                                 ELSE
                                                                                 -- for the other types of tasks this parameter is passed with null value, in order to take advantage of the result cache by task type
                                                                                  NULL
                                                                             END),
                                              i_task_type                 => rec.id_task_type) =
               pk_alert_constant.g_yes
            THEN
                o_flg_needs_cosign := g_available;
                RETURN TRUE;
            END IF;
        
        END LOOP;
    
        o_flg_needs_cosign := g_not_available;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_CANC_ODST_PRC_TSK_COSIGN',
                                              o_error);
            RETURN FALSE;
    END check_canc_odst_prc_tsk_cosign;

    FUNCTION check_cancel_odst_proc_task
    (
        i_lang                   IN language.id_language%TYPE,
        i_prof_id                IN professional.id_professional%TYPE,
        i_prof_inst              IN institution.id_institution%TYPE,
        i_prof_soft              IN software.id_software%TYPE,
        i_episode                IN episode.id_episode%TYPE,
        i_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 result_cache IS
    
        l_prof profissional;
    
        l_task_type    order_set_process_task.id_task_type%TYPE;
        l_task_status  order_set_process_task.flg_status%TYPE;
        l_request_id   order_set_process_task.id_request%TYPE;
        l_episode_task task_type.flg_episode_task%TYPE;
    
        l_flg_available VARCHAR2(1 CHAR);
    
        l_error t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        -- initialization
        l_prof := profissional(id => i_prof_id, institution => i_prof_inst, software => i_prof_soft);
    
        g_error := 'CHECK CANCEL ORDER SET PROCESS TASK';
        -- get data needed to check if task can be cancelled or not
        SELECT ospt.id_task_type, ospt.flg_status, ospt.id_request, tt.flg_episode_task
          INTO l_task_type, l_task_status, l_request_id, l_episode_task
          FROM order_set_process_task ospt
         INNER JOIN task_type tt
            ON (ospt.id_task_type = tt.id_task_type)
         WHERE ospt.id_order_set_process_task = i_order_set_process_task;
    
        -- episode tasks cannot be canceled
        IF l_episode_task = pk_alert_constant.g_tt_tde_support_epis
        THEN
            RETURN pk_alert_constant.g_no;
        
            -- check if task can be canceled according to its state and permissions 
        ELSIF l_task_status = g_order_set_proc_tsk_running
              AND check_order_set_task_avail(i_lang, l_prof, l_task_type) = pk_alert_constant.g_yes
        THEN
            -- check if it's possible to cancel the medication task or not
            IF l_task_type = g_odst_task_medication
            THEN
                IF NOT pk_api_pfh_ordertools_in.check_cancel_medication(i_lang          => i_lang,
                                                                        i_prof          => l_prof,
                                                                        i_presc         => l_request_id,
                                                                        o_flg_available => l_flg_available,
                                                                        o_error         => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
                -- check if it's possible to cancel the institutionalized/predefined diet task or not
            ELSIF l_task_type IN (g_odst_task_instit_diet, g_odst_task_predef_diet)
            THEN
                RETURN pk_diet.check_cancel_diet(i_lang             => i_lang,
                                                 i_prof             => l_prof,
                                                 i_id_epis_diet_req => l_request_id);
            
                -- check if it's possible to cancel the lab test task or not
            ELSIF l_task_type = g_odst_task_analysis
            THEN
                IF NOT pk_lab_tests_external_api_db.check_lab_test_cancel(i_lang         => i_lang,
                                                                          i_prof         => l_prof,
                                                                          i_episode      => i_episode,
                                                                          i_task_request => l_request_id,
                                                                          o_flg_cancel   => l_flg_available,
                                                                          o_error        => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
                -- check if it's possible to cancel the image or other exam task or not
            ELSIF l_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam)
            THEN
                IF NOT pk_exams_external_api_db.check_exam_cancel(i_lang         => i_lang,
                                                                  i_prof         => l_prof,
                                                                  i_episode      => i_episode,
                                                                  i_task_request => l_request_id,
                                                                  o_flg_cancel   => l_flg_available,
                                                                  o_error        => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
                -- check if it's possible to cancel the communication order or not
            ELSIF l_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order)
            THEN
            
                IF NOT pk_comm_orders_order_sets.check_comm_order_cancel(i_lang              => i_lang,
                                                                         i_prof              => l_prof,
                                                                         i_episode           => i_episode,
                                                                         i_id_comm_order_req => l_request_id,
                                                                         o_flg_cancel        => l_flg_available,
                                                                         o_error             => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
                -- check if it's possible to cancel the supply / surgical supply or not
            ELSIF l_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies)
            THEN
            
                IF NOT pk_supplies_order_sets.check_supply_wf_cancel(i_lang               => i_lang,
                                                                     i_prof               => l_prof,
                                                                     i_id_supply_workflow => l_request_id,
                                                                     o_flg_cancel         => l_flg_available,
                                                                     o_error              => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
            ELSIF l_task_type = g_odst_task_procedure
            THEN
                IF NOT pk_procedures_external_api_db.check_procedure_cancel(i_lang         => i_lang,
                                                                            i_prof         => l_prof,
                                                                            i_episode      => i_episode,
                                                                            i_task_request => l_request_id,
                                                                            o_flg_cancel   => l_flg_available,
                                                                            o_error        => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
            ELSIF l_task_type = g_odst_task_bp
            THEN
                IF NOT pk_bp_external_api_db.check_bp_cancel(i_lang         => i_lang,
                                                             i_prof         => l_prof,
                                                             i_episode      => i_episode,
                                                             i_task_request => l_request_id,
                                                             o_flg_cancel   => l_flg_available,
                                                             o_error        => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            
            ELSIF l_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation
            THEN
                IF NOT pk_inp_hidrics_pbl.check_hidrics_cancel(i_lang         => i_lang,
                                                               i_prof         => l_prof,
                                                               i_episode      => i_episode,
                                                               i_task_request => l_request_id,
                                                               o_flg_cancel   => l_flg_available,
                                                               o_error        => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
                RETURN l_flg_available;
            ELSE
                RETURN pk_alert_constant.g_yes;
            END IF;
        END IF;
    
        RETURN pk_alert_constant.g_no;
    
    END check_cancel_odst_proc_task;

    FUNCTION cancel_order_set_process
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_patient           IN patient.id_patient%TYPE,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        i_id_cancel_reason     IN cancel_reason.id_cancel_reason%TYPE,
        i_cancel_notes         IN order_set_process.cancel_notes%TYPE,
        i_prof_order           IN order_set_process.id_prof_order%TYPE,
        i_dt_order             IN VARCHAR2,
        i_order_type           IN order_set_process.id_order_type%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_order_set_process IS
            SELECT id_order_set_process, flg_status
              FROM order_set_process
             WHERE id_order_set_process = i_id_order_set_process;
    
        CURSOR c_order_set_process_tasks IS
            SELECT odst_proc_tsk.id_order_set_process_task
              FROM order_set_process_task odst_proc_tsk
             INNER JOIN task_type tt
                ON odst_proc_tsk.id_task_type = tt.id_task_type
             WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
               AND odst_proc_tsk.flg_status = g_order_set_proc_tsk_running
               AND tt.flg_episode_task != pk_alert_constant.g_tt_tde_support_epis;
    
        CURSOR c_odst_proc_epis_tasks IS
            SELECT id_order_set_process_task
              FROM order_set_process_task odst_proc_tsk
             INNER JOIN task_type tt
                ON odst_proc_tsk.id_task_type = tt.id_task_type
             WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
               AND odst_proc_tsk.flg_status = g_order_set_proc_tsk_running
               AND tt.flg_episode_task = pk_alert_constant.g_tt_tde_support_epis
                  -- only episodes created within this order set process
               AND odst_proc_tsk.flg_order_set_task = pk_alert_constant.g_yes;
    
        -- cursor with all predefined tasks
        CURSOR c_modular_tasks(in_id_order_set_process IN order_set_process.id_order_set_process%TYPE) IS
            SELECT t_rec_odst_task_req(ospt.id_order_set_process_task, ospt.id_task_type, osptl.id_task_link)
              FROM order_set_process_task ospt
              JOIN task_type tt
                ON tt.id_task_type = ospt.id_task_type
               AND tt.flg_modular_workflow = g_modular_workflow_support
              JOIN order_set_process_task_link osptl
                ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
               AND osptl.flg_task_link_type = get_odst_proc_task_link_type(ospt.id_order_set_process_task) -- to return only the predefined requests
             WHERE ospt.id_order_set_process = in_id_order_set_process;
    
        CURSOR c_act_order_set_process_tasks(in_id_order_set_process NUMBER) IS
            SELECT id_order_set_process_task
              FROM order_set_process_task
             WHERE id_order_set_process = in_id_order_set_process
               AND flg_status IN (g_order_set_proc_tsk_running, g_order_set_proc_tsk_finished);
    
        rec_id_order_set_process_tasks table_number;
        l_order_set_process            c_order_set_process%ROWTYPE;
        l_modular_tasks                t_tbl_odst_task_req;
        l_task_types                   table_number;
        --l_id_requests                  table_number;
    
        l_osp_episode episode.id_episode%TYPE;
    
        l_sysdate TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        --Scheduler 3.0 variables
        l_transaction_id VARCHAR2(4000);
    
        l_flg_status order_set_process.flg_status%TYPE;
    
        error_undefined_status EXCEPTION;
        error_cancel_tasks     EXCEPTION;
        error_remove_cosign    EXCEPTION;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        --raise_application_error(-20001,'Teste');
        g_error := 'FETCH ORDER SET PROCESS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- gets a new transaction ID and begins the transaction (for the Scheduler 3.0 transactions)
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(l_transaction_id, i_prof);
    
        -- Checks if the order set process state is temporary or running.
        OPEN c_order_set_process;
    
        FETCH c_order_set_process
            INTO l_order_set_process;
    
        CLOSE c_order_set_process;
    
        g_error := 'VERIFY STATE OF ORDER SET PROCESS';
        IF l_order_set_process.flg_status = g_order_set_proc_temp
        THEN
        
            -- handling for predefined tasks (for the task types that supports modular workflows)
            -- get all predefined tasks
            OPEN c_modular_tasks(i_id_order_set_process);
            FETCH c_modular_tasks BULK COLLECT
                INTO l_modular_tasks;
            CLOSE c_modular_tasks;
        
            -- get array of distinct task types
            l_task_types := get_task_types(l_modular_tasks);
        
            -- for each task type, call apis to delete predefined tasks
            FOR i IN 1 .. l_task_types.count
            LOOP
                CASE
                
                    WHEN l_task_types(i) = g_odst_task_medication THEN
                        -- delete predefined tasks
                        IF NOT pk_api_pfh_ordertools_in.delete_medication_task(i_lang     => i_lang,
                                                                               i_prof     => i_prof,
                                                                               i_id_presc => get_task_requests(i_task_type => g_odst_task_medication,
                                                                                                               i_reqs      => l_modular_tasks),
                                                                               o_error    => o_error)
                        THEN
                            g_error := 'error found while calling pk_api_pfh_ordertools_in.delete_medication_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) = g_odst_task_instit_diet THEN
                        -- delete institutionalized diet tasks
                        IF NOT pk_diet.cancel_draft(i_lang    => i_lang,
                                                    i_prof    => i_prof,
                                                    i_episode => i_id_episode,
                                                    i_draft   => get_task_requests(i_task_type => g_odst_task_instit_diet,
                                                                                   i_reqs      => l_modular_tasks),
                                                    o_error   => o_error)
                        THEN
                            g_error := 'error found while calling pk_diet.cancel_diet_orderset function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) = g_odst_task_analysis THEN
                    
                        -- delete predefined lab test tasks
                        IF NOT pk_lab_tests_external_api_db.set_lab_test_delete_task(i_lang         => i_lang,
                                                                                     i_prof         => i_prof,
                                                                                     i_task_request => get_task_requests(i_task_type => g_odst_task_analysis,
                                                                                                                         i_reqs      => l_modular_tasks),
                                                                                     o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_procedure THEN
                    
                        -- delete predefined procedure taskd
                        IF NOT pk_procedures_external_api_db.set_procedure_delete_task(i_lang         => i_lang,
                                                                                       i_prof         => i_prof,
                                                                                       i_task_request => get_task_requests(i_task_type => g_odst_task_procedure,
                                                                                                                           i_reqs      => l_modular_tasks),
                                                                                       o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_bp THEN
                    
                        -- delete predefined procedure taskd
                        IF NOT pk_bp_external_api_db.set_bp_delete_task(i_lang         => i_lang,
                                                                        i_prof         => i_prof,
                                                                        i_task_request => get_task_requests(i_task_type => g_odst_task_procedure,
                                                                                                            i_reqs      => l_modular_tasks),
                                                                        o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_procedures_external_api_db.set_procedure_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                        -- delete predefined hidris tasks
                        IF NOT pk_inp_hidrics_pbl.set_hidric_delete_task(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_tasks),
                                                                         o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    
                        -- delete predefined exam tasks
                        IF NOT pk_exams_external_api_db.set_exam_delete_task(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                 i_reqs      => l_modular_tasks),
                                                                             o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_exams_external_api_db.set_exam_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                        -- delete predefined communication orders tasks
                        IF NOT pk_comm_orders_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                                i_prof         => i_prof,
                                                                                i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                    i_reqs      => l_modular_tasks),
                                                                                o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_com_orders_order_sets.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                        -- delete predefined supplies or surgical supplies tasks
                        IF NOT pk_supplies_order_sets.cancel_predefined_task(i_lang         => i_lang,
                                                                             i_prof         => i_prof,
                                                                             i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                                 i_reqs      => l_modular_tasks),
                                                                             o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_supplies_order_sets.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    
                    WHEN l_task_types(i) IN (g_odst_task_inpatient, g_odst_task_inp_surg) THEN
                    
                        IF NOT pk_admission_request.cancel_predefined_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                               i_reqs      => l_modular_tasks),
                                                                           o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_admission_request.cancel_predefined_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_consult THEN
                        -- delete predefined consult task
                        IF NOT pk_opinion.set_opinion_delete_task(i_lang         => i_lang,
                                                                  i_prof         => i_prof,
                                                                  i_task_request => get_task_requests(i_task_type => g_odst_task_consult,
                                                                                                      i_reqs      => l_modular_tasks),
                                                                  o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_opinion.set_opinion_delete_task function';
                            RAISE l_exception;
                        END IF;
                    WHEN l_task_types(i) = g_odst_task_patient_education THEN
                        -- delete predefined patient education task
                        IF NOT pk_patient_education_api_db.set_ntr_delete_task(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_task_request => get_task_requests(i_task_type => g_odst_task_patient_education,
                                                                                                                   i_reqs      => l_modular_tasks),
                                                                               o_error        => o_error)
                        THEN
                            g_error := 'error found while calling pk_opinion.set_ntr_delete_task function';
                            RAISE l_exception;
                        END IF;
                    
                    ELSE
                        g_error := 'delete predefined task is not supported for task type [' || l_task_types(i) || ']';
                        RAISE l_exception;
                    
                END CASE;
            END LOOP;
        
            -- cancel episode tasks if its requisition was created within this order set process
            FOR rec IN c_odst_proc_epis_tasks
            LOOP
                IF NOT cancel_odst_proc_task_episode(i_lang                   => i_lang,
                                                     i_prof                   => i_prof,
                                                     i_order_set_process_task => rec.id_order_set_process_task,
                                                     i_transaction_id         => l_transaction_id,
                                                     o_error                  => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        
            g_error := 'DELETE PROCESS TASKS GROUPS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task_group osptg
             WHERE osptg.id_order_set_process_task IN
                   (SELECT odst_proc_tsk.id_order_set_process_task
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process);
        
            g_error := 'DELETE PROCESS TASKS DETAILS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task_det odst_proc_td
             WHERE odst_proc_td.id_order_set_process_task IN
                   (SELECT odst_proc_tsk.id_order_set_process_task
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process);
        
            g_error := 'DELETE PROCESS TASKS LINKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task_link odst_proc_tl
             WHERE odst_proc_tl.id_order_set_process_task IN
                   (SELECT odst_proc_tsk.id_order_set_process_task
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process);
        
            g_error := 'DELETE TASK DEPENDENCIES';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task_depend
             WHERE id_order_set_process = i_id_order_set_process;
        
            g_error := 'DELETE PROCESS TASKS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process_task
             WHERE id_order_set_process = i_id_order_set_process;
        
            g_error := 'DELETE TEMPORARY ORDER SET PROCESS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            DELETE FROM order_set_process
             WHERE id_order_set_process = i_id_order_set_process
               AND flg_status = g_order_set_proc_temp;
        
        ELSIF l_order_set_process.flg_status = g_order_set_proc_running
        THEN
            g_error := 'CANCEL ORDER SET PROCESS';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- cancel episode tasks if its requisition was created within this order set process
            FOR rec IN c_odst_proc_epis_tasks
            LOOP
                IF NOT cancel_odst_proc_task_episode(i_lang                   => i_lang,
                                                     i_prof                   => i_prof,
                                                     i_order_set_process_task => rec.id_order_set_process_task,
                                                     i_transaction_id         => l_transaction_id,
                                                     o_error                  => o_error)
                THEN
                    RAISE l_exception;
                END IF;
            END LOOP;
        
            -- get order set process task IDs (except episode tasks)
            OPEN c_order_set_process_tasks;
            FETCH c_order_set_process_tasks BULK COLLECT
                INTO rec_id_order_set_process_tasks;
            CLOSE c_order_set_process_tasks;
        
            -- cancel order set process tasks (except episode tasks)
            IF NOT cancel_odst_proc_tasks_intern(i_lang,
                                                 i_prof,
                                                 i_id_patient,
                                                 i_id_episode,
                                                 rec_id_order_set_process_tasks,
                                                 i_id_cancel_reason,
                                                 i_cancel_notes,
                                                 i_prof_order,
                                                 i_dt_order,
                                                 i_order_type,
                                                 l_transaction_id,
                                                 o_error)
            THEN
                RAISE error_cancel_tasks;
            END IF;
        
            -- if any task of this order set was finished or is still running (because was not allowed be cancelled), 
            -- the order-set is considered as "interrupted" instead of cancelled.
            g_error := 'CHECK FOR TASKS THAT ITS STATUS IS FINISHED OR STILL RUNNING';
            pk_alertlog.log_debug(g_error, g_package_name);
            OPEN c_act_order_set_process_tasks(i_id_order_set_process);
            FETCH c_act_order_set_process_tasks BULK COLLECT
                INTO rec_id_order_set_process_tasks;
            CLOSE c_act_order_set_process_tasks;
        
            IF rec_id_order_set_process_tasks.count > 0
            THEN
                l_flg_status := g_order_set_proc_interrupted;
            ELSE
                l_flg_status := g_order_set_proc_canceled;
            END IF;
        
            -- cancel order set process
            UPDATE order_set_process
               SET flg_status       = l_flg_status,
                   dt_status_tstz   = l_sysdate,
                   id_professional  = i_prof.id,
                   cancel_notes     = i_cancel_notes,
                   id_cancel_reason = i_id_cancel_reason
             WHERE id_order_set_process = i_id_order_set_process
               AND flg_status = g_order_set_proc_running
            RETURNING id_episode INTO l_osp_episode;
        
        ELSE
            RAISE error_undefined_status;
        END IF;
    
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while canceling order set process tasks
        WHEN error_cancel_tasks THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET_PROCESS',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Error if order set process state is not temporary or running
        WHEN error_undefined_status THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / UNDEFINED STATE FOR FLG_STATUS',
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET_PROCESS',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CANCEL_ORDER_SET_PROCESS',
                                              o_error);
        
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END cancel_order_set_process;

    FUNCTION get_cpoe_task_type(i_order_set_task_type IN task_type.id_task_type%TYPE)
        RETURN cpoe_task_type.id_task_type%TYPE IS
    
    BEGIN
    
        CASE
            WHEN i_order_set_task_type = g_odst_task_image_exam THEN
                RETURN pk_alert_constant.g_task_type_image_exam;
            WHEN i_order_set_task_type = g_odst_task_other_exam THEN
                RETURN pk_alert_constant.g_task_type_other_exam;
            WHEN i_order_set_task_type = g_odst_task_monitoring THEN
                RETURN pk_alert_constant.g_task_type_monitorization;
            WHEN i_order_set_task_type = g_odst_task_procedure THEN
                RETURN pk_alert_constant.g_task_type_procedure;
            WHEN i_order_set_task_type = g_odst_task_bp THEN
                RETURN pk_blood_products_constant.g_task_type_cpoe_bp;
            WHEN i_order_set_task_type = g_odst_task_analysis THEN
                RETURN pk_alert_constant.g_task_type_analysis;
            WHEN i_order_set_task_type = g_odst_task_predef_diet THEN
                RETURN pk_alert_constant.g_task_type_diet_predefined;
            WHEN i_order_set_task_type = g_odst_task_instit_diet THEN
                RETURN pk_alert_constant.g_task_type_diet_inst;
            WHEN i_order_set_task_type = g_odst_task_medication THEN
                RETURN pk_alert_constant.g_task_type_medication;
            WHEN i_order_set_task_type = g_odst_task_patient_education THEN
                RETURN pk_alert_constant.g_task_type_nursing;
            WHEN i_order_set_task_type = g_odst_task_intake_output THEN
                RETURN pk_alert_constant.g_task_type_hidric_in_out;
            WHEN i_order_set_task_type = g_odst_task_intake THEN
                RETURN pk_alert_constant.g_task_type_hidric_in;
            WHEN i_order_set_task_type = g_odst_task_urinary_output THEN
                RETURN pk_alert_constant.g_task_type_hidric_out;
            WHEN i_order_set_task_type = g_odst_task_drainage_records THEN
                RETURN pk_alert_constant.g_task_type_hidric_drain;
            WHEN i_order_set_task_type = g_odst_task_all_output THEN
                RETURN pk_alert_constant.g_task_type_hidric_out_all;
            WHEN i_order_set_task_type = g_odst_task_irrigation THEN
                RETURN pk_alert_constant.g_task_type_hidric_irrigations;
            ELSE
                RETURN NULL; -- task type that doesn't affect cpoe
        END CASE;
    
    END get_cpoe_task_type;

    FUNCTION get_proc_task_detail_value
    (
        i_id_order_set_process_task IN order_set_process_task_det.id_order_set_process_task%TYPE,
        i_flg_detail_type           IN order_set_process_task_det.flg_detail_type%TYPE,
        i_id_advanced_input_field   IN order_set_process_task_det.id_advanced_input_field%TYPE
    ) RETURN VARCHAR2 IS
    
        l_return_val VARCHAR2(4000);
    
    BEGIN
        -- get task link
        SELECT decode(flg_value_type,
                      g_task_det_value_type_number,
                      to_char(nvalue), -- number
                      g_task_det_value_type_varchar,
                      vvalue, -- varchar2
                      g_task_det_value_type_date,
                      dvalue, -- timestamp with local time zone
                      NULL)
          INTO l_return_val
          FROM order_set_process_task_det
         WHERE id_order_set_process_task = i_id_order_set_process_task
           AND flg_detail_type = i_flg_detail_type
           AND nvl(id_advanced_input_field, -1) = nvl(i_id_advanced_input_field, nvl(id_advanced_input_field, -1));
    
        RETURN l_return_val;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN NULL;
    END get_proc_task_detail_value;

    FUNCTION check_cpoe_task_creation
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_task_list            OUT pk_types.cursor_type,
        o_flg_warning_type     OUT VARCHAR2,
        o_msg_title            OUT VARCHAR2,
        o_msg_body             OUT VARCHAR2,
        o_proc_start           OUT VARCHAR2,
        o_proc_end             OUT VARCHAR2,
        o_proc_refresh         OUT VARCHAR2,
        o_proc_next_start      OUT VARCHAR2,
        o_proc_next_end        OUT VARCHAR2,
        o_proc_next_refresh    OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_order_set_process_tasks(in_id_order_set_process NUMBER) IS
            SELECT to_char(odst_proc_task.id_order_set_process_task) id_order_set_process_task,
                   -- convert order set task type id to a cpoe task type id
                   get_cpoe_task_type(odst_proc_task.id_task_type) cpoe_task_type,
                   -- get start date from advanced input fields
                   CASE
                        WHEN odst_proc_task.id_task_type IN (g_odst_task_monitoring) THEN
                         get_proc_task_detail_value(odst_proc_task.id_order_set_process_task, g_task_det_adv_input, 96)
                        WHEN odst_proc_task.id_task_type = g_odst_task_predef_diet THEN
                         get_proc_task_detail_value(odst_proc_task.id_order_set_process_task, g_task_det_adv_input, 136)
                        WHEN odst_proc_task.id_task_type = g_odst_task_patient_education THEN
                         get_proc_task_detail_value(odst_proc_task.id_order_set_process_task, g_task_det_adv_input, 138)
                        ELSE
                         NULL
                    END dt_start,
                   -- get end date from advanced input fields
                   CASE
                        WHEN odst_proc_task.id_task_type = g_odst_task_monitoring THEN
                         get_proc_task_detail_value(odst_proc_task.id_order_set_process_task, g_task_det_adv_input, 97)
                        WHEN odst_proc_task.id_task_type = g_odst_task_predef_diet THEN
                         get_proc_task_detail_value(odst_proc_task.id_order_set_process_task, g_task_det_adv_input, 137)
                        ELSE
                         NULL
                    END dt_end
              FROM order_set_process_task odst_proc_task
             WHERE odst_proc_task.flg_status = g_order_set_proc_tsk_temp
               AND odst_proc_task.id_order_set_process = in_id_order_set_process
               AND odst_proc_task.flg_discard_type = g_task_not_discard
               AND odst_proc_task.id_order_set_process_task IN
                   (SELECT id_order_set_process_task
                      FROM order_set_process_task_det ttt1
                     WHERE ttt1.id_order_set_process_task = odst_proc_task.id_order_set_process_task
                       AND ttt1.flg_detail_type = g_task_det_adv_input
                       AND ttt1.id_advanced_input_field = g_adv_input_field_selected
                       AND ttt1.vvalue = pk_alert_constant.g_yes)
                  -- the AI data is only extracted in tasks types that doesn't support modular workflow
               AND check_modular_task_type(odst_proc_task.id_task_type) = g_modular_workflow_no_support;
    
        -- cursor with all predefined tasks
        CURSOR c_modular_proc_tasks(in_id_order_set_process IN order_set_process.id_order_set_process%TYPE) IS
            SELECT t_rec_odst_task_req(ospt.id_order_set_process_task, ospt.id_task_type, osptl.id_task_link)
              FROM order_set_process_task ospt
              JOIN task_type tt
                ON tt.id_task_type = ospt.id_task_type
               AND tt.flg_modular_workflow = g_modular_workflow_support
              JOIN order_set_process_task_link osptl
                ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
               AND osptl.flg_task_link_type = get_odst_proc_task_link_type(ospt.id_order_set_process_task) -- to return only the predefined requests
             WHERE ospt.id_order_set_process = in_id_order_set_process
               AND ospt.id_order_set_process_task IN
                   (SELECT id_order_set_process_task
                      FROM order_set_process_task_det ttt1
                     WHERE ttt1.id_order_set_process_task = ospt.id_order_set_process_task
                       AND ttt1.flg_detail_type = g_task_det_adv_input
                       AND ttt1.id_advanced_input_field = g_adv_input_field_selected
                       AND ttt1.vvalue = pk_alert_constant.g_yes);
    
        l_modular_proc_tasks t_tbl_odst_task_req;
        l_task_types         table_number;
        l_task_reference     table_number;
        l_task_dates         pk_types.cursor_type;
    
        l_exception EXCEPTION;
    
        l_tab_odst_proc_task     table_varchar;
        l_tab_cpoe_task_type     table_number;
        l_tab_dt_start           table_timestamp_tstz;
        l_tab_dt_end             table_timestamp_tstz;
        l_tab_odst_proc_task_aux table_varchar;
        l_tab_cpoe_task_type_aux table_number;
        l_tab_dt_start_aux       table_timestamp_tstz;
        l_tab_dt_end_aux         table_timestamp_tstz;
        l_cpoe_task_type_aux     cpoe_task_type.id_task_type%TYPE;
        l_ts_cpoe_start          cpoe_process.dt_cpoe_proc_start%TYPE;
        l_ts_cpoe_end            cpoe_process.dt_cpoe_proc_end%TYPE;
        l_ts_cpoe_refresh        cpoe_process.dt_cpoe_proc_auto_refresh%TYPE;
    
        l_ts_cpoe_next_start   cpoe_process.dt_cpoe_proc_start%TYPE;
        l_ts_cpoe_next_end     cpoe_process.dt_cpoe_proc_end%TYPE;
        l_ts_cpoe_next_refresh cpoe_process.dt_cpoe_proc_auto_refresh%TYPE;
    
    BEGIN
    
        g_error := 'GET PARAMETERS TO CHECK CPOE TASK CREATION';
        -- get parameters needed to check CPOE task creation (except predefined tasks)
        OPEN c_order_set_process_tasks(i_id_order_set_process);
        FETCH c_order_set_process_tasks BULK COLLECT
            INTO l_tab_odst_proc_task, l_tab_cpoe_task_type, l_tab_dt_start, l_tab_dt_end;
        CLOSE c_order_set_process_tasks;
    
        -- process predefined task types
        OPEN c_modular_proc_tasks(i_id_order_set_process);
        FETCH c_modular_proc_tasks BULK COLLECT
            INTO l_modular_proc_tasks;
        CLOSE c_modular_proc_tasks;
    
        -- get array of distinct task types
        l_task_types := get_task_types(l_modular_proc_tasks);
    
        -- for each task type, call apis to get timestamp interval of predefined tasks
        FOR i IN 1 .. l_task_types.count
        LOOP
            CASE
            -- get start/end dates from medication tasks
                WHEN l_task_types(i) = g_odst_task_medication THEN
                    -- get timestamps from medication tasks
                    IF NOT pk_api_pfh_ordertools_in.get_medication_date_limits(i_lang        => i_lang,
                                                                               i_prof        => i_prof,
                                                                               i_presc       => get_task_requests(i_task_type => g_odst_task_medication,
                                                                                                                  i_reqs      => l_modular_proc_tasks),
                                                                               o_date_limits => l_task_dates,
                                                                               o_error       => o_error)
                    THEN
                        g_error := 'error found while calling pk_api_pfh_ordertools_in.get_medication_date_limits function';
                        RAISE l_exception;
                    END IF;
                
            -- get start/end dates from lab test tasks
                WHEN l_task_types(i) = g_odst_task_analysis THEN
                
                    -- get timestamps from lab test tasks
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_date_limits(i_lang         => i_lang,
                                                                                 i_prof         => i_prof,
                                                                                 i_task_request => get_task_requests(i_task_type => g_odst_task_analysis,
                                                                                                                     i_reqs      => l_modular_proc_tasks),
                                                                                 o_list         => l_task_dates,
                                                                                 o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_procedure THEN
                
                    -- get timestamps from procedures tasks
                    IF NOT pk_procedures_external_api_db.get_procedure_date_limits(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_task_request => get_task_requests(i_task_type => g_odst_task_procedure,
                                                                                                                       i_reqs      => l_modular_proc_tasks),
                                                                                   o_list         => l_task_dates,
                                                                                   o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                
                WHEN l_task_types(i) = g_odst_task_bp THEN
                
                    -- get timestamps from procedures tasks
                    IF NOT pk_bp_external_api_db.get_bp_date_limits(i_lang         => i_lang,
                                                                    i_prof         => i_prof,
                                                                    i_task_request => get_task_requests(i_task_type => g_odst_task_bp,
                                                                                                        i_reqs      => l_modular_proc_tasks),
                                                                    o_list         => l_task_dates,
                                                                    o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                
                WHEN l_task_types(i) BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                
                    IF NOT pk_inp_hidrics_pbl.get_hidric_date_limits(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                         i_reqs      => l_modular_proc_tasks),
                                                                     o_list         => l_task_dates,
                                                                     o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                
            -- get start/end dates from image and other exam tasks
                WHEN l_task_types(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                
                    -- get timestamps from image and other exam tasks
                    IF NOT pk_exams_external_api_db.get_exam_date_limits(i_lang         => i_lang,
                                                                         i_prof         => i_prof,
                                                                         i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                             i_reqs      => l_modular_proc_tasks),
                                                                         o_list         => l_task_dates,
                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                
            -- get start/end dates from institutionalized diet tasks
                WHEN l_task_types(i) = g_odst_task_instit_diet THEN
                    -- get timestamp from institutionalized diet tasks
                    IF NOT pk_diet.get_date_limits(i_lang        => i_lang,
                                                   i_prof        => i_prof,
                                                   i_diet_type   => pk_diet.g_diet_type_inst, -- institutionalized diet task type
                                                   i_id_req      => get_task_requests(i_task_type => g_odst_task_instit_diet,
                                                                                      i_reqs      => l_modular_proc_tasks),
                                                   o_date_limits => l_task_dates,
                                                   o_error       => o_error)
                    THEN
                        g_error := 'error found while calling pk_diet.get_date_limits function';
                        RAISE l_exception;
                    END IF;
                
            -- get start/end dates from communication order tasks
                WHEN l_task_types(i) IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                
                    -- get timestamp from communication order tasks
                    IF NOT pk_comm_orders_order_sets.get_date_limits(i_lang         => i_lang,
                                                                     i_prof         => i_prof,
                                                                     i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                         i_reqs      => l_modular_proc_tasks),
                                                                     o_date_limits  => l_task_dates,
                                                                     o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_comm_orders_order_sets.get_date_limits function';
                        RAISE l_exception;
                    END IF;
                
            -- get start/end dates from supplies or surgical supplies tasks
                WHEN l_task_types(i) IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                
                    -- get timestamp from supply or surgical supply  tasks
                    IF NOT pk_supplies_order_sets.get_date_limits(i_lang         => i_lang,
                                                                  i_prof         => i_prof,
                                                                  i_task_request => get_task_requests(i_task_type => l_task_types(i),
                                                                                                      i_reqs      => l_modular_proc_tasks),
                                                                  o_date_limits  => l_task_dates,
                                                                  o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_supplies_order_sets.get_date_limits function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) IN (g_odst_task_inpatient, g_odst_task_inp_surg) THEN
                
                    CONTINUE;
                    --
                WHEN l_task_types(i) = g_odst_task_patient_education THEN
                    -- get timestamps from patient education tasks
                    IF NOT pk_patient_education_api_db.get_patient_education_date_limits(i_lang         => i_lang,
                                                                                         i_prof         => i_prof,
                                                                                         i_task_request => get_task_requests(i_task_type => g_odst_task_patient_education,
                                                                                                                             i_reqs      => l_modular_proc_tasks),
                                                                                         o_list         => l_task_dates,
                                                                                         o_error        => o_error)
                    THEN
                        g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_date_limits function';
                        RAISE l_exception;
                    END IF;
                WHEN l_task_types(i) = g_odst_task_consult THEN
                
                    CONTINUE;
                ELSE
                    g_error := 'get date limits function for predefined tasks is not supported for task type [' ||
                               l_task_types(i) || ']';
                    RAISE l_exception;
            END CASE;
        
            -- translate order set task type into cpoe task type
            l_cpoe_task_type_aux := get_cpoe_task_type(l_task_types(i));
        
            -- join fetched timestamps with main collections
            -- open l_task_dates; (cursor l_task_dates is already open)
            g_error := 'fetch records from l_task_dates cursor';
            pk_alertlog.log_debug(g_error, g_package_name);
            FETCH l_task_dates BULK COLLECT
                INTO l_task_reference, l_tab_dt_start_aux, l_tab_dt_end_aux;
            -- close cursor
            CLOSE l_task_dates;
        
            -- init arrays
            l_tab_odst_proc_task_aux := table_varchar();
            l_tab_cpoe_task_type_aux := table_number();
        
            -- process remain arrays
            FOR j IN 1 .. l_task_reference.count()
            LOOP
                -- get order set process task by request
                l_tab_odst_proc_task_aux.extend;
                l_tab_odst_proc_task_aux(j) := to_char(get_order_set_task_by_req(l_task_reference(j),
                                                                                 l_modular_proc_tasks));
                -- convert order set task type into cpoe task type                    
                l_tab_cpoe_task_type_aux.extend;
                l_tab_cpoe_task_type_aux(j) := l_cpoe_task_type_aux;
            END LOOP;
        
            -- the order is preserved with the following unions
            l_tab_odst_proc_task := l_tab_odst_proc_task MULTISET UNION ALL l_tab_odst_proc_task_aux;
            l_tab_cpoe_task_type := l_tab_cpoe_task_type MULTISET UNION ALL l_tab_cpoe_task_type_aux;
            l_tab_dt_start       := concat_table_timestamp_tstz(l_tab_dt_start, l_tab_dt_start_aux);
            l_tab_dt_end         := concat_table_timestamp_tstz(l_tab_dt_end, l_tab_dt_end_aux);
        END LOOP;
    
        g_error := 'CHECK CPOE TASK CREATION';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- call cpoe function to check task creation
        IF NOT pk_cpoe_db.check_tasks_creation(i_lang              => i_lang,
                                               i_prof              => i_prof,
                                               i_episode           => i_id_episode,
                                               i_task_type         => l_tab_cpoe_task_type,
                                               i_dt_start          => l_tab_dt_start,
                                               i_dt_end            => l_tab_dt_end,
                                               i_task_id           => l_tab_odst_proc_task,
                                               i_tab_type          => NULL,
                                               o_task_list         => o_task_list,
                                               o_flg_warning_type  => o_flg_warning_type,
                                               o_msg_title         => o_msg_title,
                                               o_msg_body          => o_msg_body,
                                               o_proc_start        => l_ts_cpoe_start,
                                               o_proc_end          => l_ts_cpoe_end,
                                               o_proc_refresh      => l_ts_cpoe_refresh,
                                               o_proc_next_start   => l_ts_cpoe_next_start,
                                               o_proc_next_end     => l_ts_cpoe_next_end,
                                               o_proc_next_refresh => l_ts_cpoe_next_refresh,
                                               o_error             => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- the valid cpoe period (actual or new)
        o_proc_start   := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_start, i_prof);
        o_proc_end     := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_end, i_prof);
        o_proc_refresh := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_refresh, i_prof);
    
        o_proc_next_start   := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_next_start, i_prof);
        o_proc_next_end     := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_next_end, i_prof);
        o_proc_next_refresh := pk_date_utils.date_send_tsz(i_lang, l_ts_cpoe_next_refresh, i_prof);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'CHECK_CPOE_TASK_CREATION',
                                              o_error);
            pk_types.open_my_cursor(o_task_list);
            RETURN FALSE;
    END check_cpoe_task_creation;

    FUNCTION check_discard_task_depend
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_task              IN order_set_task.id_order_set_task%TYPE,
        i_task_dependencies    IN table_number,
        i_task_flg_discard     IN table_varchar,
        i_dependency_type      IN table_number,
        i_task_dependency_from IN table_number,
        i_task_dependency_to   IN table_number,
        i_task_type_from       IN table_number,
        i_task_type_to         IN table_number
    ) RETURN VARCHAR2 IS
    
        l_task_dependencies_list table_number;
    
        -- function used to get task flag discard value
        FUNCTION get_task_flg_discard(in_task order_set_task.id_order_set_task%TYPE) RETURN VARCHAR2 IS
        BEGIN
            -- search for task dependency
            FOR i IN 1 .. i_task_dependencies.count
            LOOP
            
                -- when found task dependency return its discard value
                IF (i_task_dependencies(i) = in_task)
                THEN
                
                    RETURN i_task_flg_discard(i);
                
                END IF;
            
            END LOOP;
        
            RETURN NULL;
        
        END get_task_flg_discard;
    
    BEGIN
    
        g_error := 'CHECK TASK DEPENDENCY CONFLICT';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- check if the task itself has conflicts
        IF get_task_flg_discard(i_id_task) = pk_alert_constant.g_yes
        THEN
            RETURN pk_alert_constant.g_yes;
        END IF;
    
        -- check if the task has conflicts because of its dependencies
        l_task_dependencies_list := pk_tde_db.get_predecessor_dependencies(i_dependency           => i_id_task,
                                                                           i_relationship_type    => i_dependency_type,
                                                                           i_task_dependency_from => i_task_dependency_from,
                                                                           i_task_dependency_to   => i_task_dependency_to,
                                                                           i_task_type_from       => i_task_type_from,
                                                                           i_task_type_to         => i_task_type_to);
    
        -- if at least one dependency was discarded, 
        -- then task must be also discarded
        FOR i IN 1 .. l_task_dependencies_list.count
        LOOP
            IF get_task_flg_discard(l_task_dependencies_list(i)) = pk_alert_constant.g_yes
            THEN
                RETURN pk_alert_constant.g_yes;
            END IF;
        END LOOP;
    
        RETURN pk_alert_constant.g_no;
    
    END check_discard_task_depend;

    FUNCTION set_cdr_discarded_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        i_discarded_tasks      IN table_number,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'set order set process tasks as discarded';
        UPDATE order_set_process_task ospt
           SET ospt.flg_discard_type = g_task_discard_cdr
         WHERE ospt.id_order_set_process = i_id_order_set_process
           AND ospt.id_order_set_process_task IN (SELECT /*+opt_estimate (table dt rows=1)*/
                                                   column_value
                                                    FROM TABLE(i_discarded_tasks) dt);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_CDR_DISCARDED_TASKS',
                                              o_error);
            RETURN FALSE;
    END set_cdr_discarded_tasks;

    FUNCTION reset_discarded_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    BEGIN
    
        g_error := 'reset discarded order set process tasks';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        UPDATE order_set_process_task ospt
           SET ospt.flg_discard_type = g_task_not_discard
         WHERE ospt.id_order_set_process = i_id_order_set_process;
    
        RETURN TRUE;
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'RESET_DISCARDED_TASKS',
                                              o_error);
            RETURN FALSE;
    END reset_discarded_tasks;

    FUNCTION get_accept_and_discard_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_accepted_tasks       OUT pk_types.cursor_type,
        o_discarded_tasks      OUT pk_types.cursor_type,
        o_flg_prompt           OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
        l_tasks_rank         table_number;
        l_task_dependencies  table_number := table_number();
        l_task_flg_discard   table_varchar := table_varchar();
        l_task_discard_value VARCHAR2(1 CHAR);
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
    BEGIN
    
        -- initialize flag prompt value
        o_flg_prompt := pk_alert_constant.g_no;
    
        g_error := 'get order set process tasks rank';
        -- get order set process dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_process),
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_process),
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'get order set tasks discard values';
        SELECT odst_proc_tsk.id_order_set_process_task,
               decode(odst_proc_tsk.flg_discard_type,
                      g_task_not_discard,
                      pk_alert_constant.g_no,
                      pk_alert_constant.g_yes) flg_discard
          BULK COLLECT
          INTO l_task_dependencies, l_task_flg_discard
          FROM order_set_process_task odst_proc_tsk
         WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process;
    
        g_error := 'process discard values of each task according to each dependencies';
        FOR rec IN (SELECT odst_proc_tsk.id_order_set_process_task,
                           odst_proc_tsk.id_task_type,
                           decode(odst_proc_tsk.flg_discard_type,
                                  g_task_not_discard,
                                  pk_alert_constant.g_no,
                                  pk_alert_constant.g_yes) flg_discard
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process)
        LOOP
        
            -- get task discard value according to its dependencies            
            l_task_discard_value := check_discard_task_depend(i_lang,
                                                              i_prof,
                                                              rec.id_order_set_process_task,
                                                              l_task_dependencies,
                                                              l_task_flg_discard,
                                                              l_dependency_type,
                                                              l_task_dependency_from,
                                                              l_task_dependency_to,
                                                              l_task_type_from,
                                                              l_task_type_to);
        
            -- use this loop also to check if any task was discarded due to its dependencies or not
            -- if so, then a prompt should be shown
            IF l_task_discard_value = pk_alert_constant.g_yes
               AND rec.flg_discard = pk_alert_constant.g_no
            THEN
                o_flg_prompt := pk_alert_constant.g_yes;
            
                -- update order set task discard value
                UPDATE order_set_process_task odst_proc_tsk
                   SET odst_proc_tsk.flg_discard_type = g_task_discard_depends
                 WHERE odst_proc_tsk.id_order_set_process_task = rec.id_order_set_process_task;
            
            END IF;
        END LOOP;
    
        g_error := 'open accepted tasks cursor';
        OPEN o_accepted_tasks FOR
            SELECT id_order_set_process_task,
                   id_task_type,
                   icon,
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_process_task,
                                 id_task_type,
                                 pk_alert_constant.g_yes,
                                 flg_schedule,
                                 g_task_desc_extended_format,
                                 pk_alert_constant.g_no) task_desc,
                   task_instruct,
                   dependency_order,
                   icon_dep_name,
                   dependency_desc
              FROM (SELECT odst_proc_tsk.id_order_set_process_task,
                           odst_proc_tsk.id_task_type,
                           get_task_type_icon(i_lang,
                                              i_prof,
                                              odst_proc_tsk.id_task_type,
                                              odst_proc_tsk.id_order_set_process_task,
                                              pk_alert_constant.g_yes,
                                              odst_proc_tsk.flg_schedule) icon,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_proc_tsk.id_order_set_process_task),
                                                      pk_alert_constant.g_yes) task_instruct,
                           get_task_rank(l_tasks_rank, odst_proc_tsk.id_order_set_process_task) dependency_order,
                           nvl2(odst_proc_tsk_dep.id_order_set_proc_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                           replace_dependencies_refs_rank(i_lang,
                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                           i_prof,
                                                                                           odst_proc_tsk.id_order_set_process_task,
                                                                                           odst_proc_tsk.flg_schedule,
                                                                                           l_tasks_rank,
                                                                                           l_dependency_type,
                                                                                           l_task_dependency_from,
                                                                                           l_task_dependency_to,
                                                                                           l_task_type_from,
                                                                                           l_task_type_to,
                                                                                           l_task_schedule_from,
                                                                                           l_task_schedule_to,
                                                                                           l_lag_min,
                                                                                           l_lag_max,
                                                                                           l_lag_unit_measure),
                                                          l_tasks_rank) dependency_desc,
                           odst_proc_tsk.flg_schedule
                      FROM order_set_process_task odst_proc_tsk
                    -- check if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_process_task_depend odst_proc_tsk_dep
                        ON (odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk.id_order_set_process_task AND
                           odst_proc_tsk_dep.id_order_set_process = i_id_order_set_process AND
                           odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_proc_tsk_dep.id_order_set_proc_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
                       AND odst_proc_tsk.flg_discard_type = g_task_not_discard)
             ORDER BY get_task_rank(l_tasks_rank, id_order_set_process_task);
    
        g_error := 'open discarded tasks cursor';
        OPEN o_discarded_tasks FOR
            SELECT id_order_set_process_task,
                   id_task_type,
                   icon,
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_process_task,
                                 id_task_type,
                                 pk_alert_constant.g_yes,
                                 flg_schedule,
                                 g_task_desc_extended_format,
                                 pk_alert_constant.g_no) task_desc,
                   task_instruct,
                   dependency_order,
                   icon_dep_name,
                   dependency_desc
              FROM (SELECT odst_proc_tsk.id_order_set_process_task,
                           odst_proc_tsk.id_task_type,
                           get_task_type_icon(i_lang,
                                              i_prof,
                                              odst_proc_tsk.id_task_type,
                                              odst_proc_tsk.id_order_set_process_task,
                                              pk_alert_constant.g_yes,
                                              odst_proc_tsk.flg_schedule) icon,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_proc_tsk.id_order_set_process_task),
                                                      pk_alert_constant.g_yes) task_instruct,
                           get_task_rank(l_tasks_rank, odst_proc_tsk.id_order_set_process_task) dependency_order,
                           nvl2(odst_proc_tsk_dep.id_order_set_proc_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                           replace_dependencies_refs_rank(i_lang,
                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                           i_prof,
                                                                                           odst_proc_tsk.id_order_set_process_task,
                                                                                           odst_proc_tsk.flg_schedule,
                                                                                           l_tasks_rank,
                                                                                           l_dependency_type,
                                                                                           l_task_dependency_from,
                                                                                           l_task_dependency_to,
                                                                                           l_task_type_from,
                                                                                           l_task_type_to,
                                                                                           l_task_schedule_from,
                                                                                           l_task_schedule_to,
                                                                                           l_lag_min,
                                                                                           l_lag_max,
                                                                                           l_lag_unit_measure),
                                                          l_tasks_rank) dependency_desc,
                           odst_proc_tsk.flg_schedule
                      FROM order_set_process_task odst_proc_tsk
                    -- check if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_process_task_depend odst_proc_tsk_dep
                        ON (odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk.id_order_set_process_task AND
                           odst_proc_tsk_dep.id_order_set_process = i_id_order_set_process AND
                           odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_proc_tsk_dep.id_order_set_proc_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
                       AND odst_proc_tsk.flg_discard_type IN (g_task_discard_cdr, g_task_discard_depends))
             ORDER BY get_task_rank(l_tasks_rank, id_order_set_process_task);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ACCEPT_AND_DISCARD_TASKS',
                                              o_error);
            pk_types.open_my_cursor(o_accepted_tasks);
            pk_types.open_my_cursor(o_discarded_tasks);
            RETURN FALSE;
    END get_accept_and_discard_tasks;

    FUNCTION set_order_set_process
    (
        i_lang                     IN language.id_language%TYPE,
        i_prof                     IN profissional,
        i_id_patient               IN patient.id_patient%TYPE,
        i_id_episode               IN episode.id_episode%TYPE,
        i_id_order_set_process     IN order_set_process.id_order_set_process%TYPE,
        i_clinical_question_ospt   IN table_number,
        i_clinical_question_id     IN table_table_number,
        i_clinical_question_answer IN table_table_varchar,
        i_clinical_question_notes  IN table_table_varchar,
        i_cdr_call                 IN cdr_call.id_cdr_call%TYPE,
        i_flg_force                IN VARCHAR2 DEFAULT pk_alert_constant.g_no,
        o_msg_warning              OUT VARCHAR2,
        o_error                    OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_sysdate TIMESTAMP WITH LOCAL TIME ZONE := current_timestamp;
    
        CURSOR c_proc_tasks_to_not_order(in_id_order_set_process NUMBER) IS
            SELECT ospt.id_order_set_process_task
              FROM order_set_process_task ospt
             WHERE ospt.flg_status = g_order_set_proc_tsk_temp
               AND ospt.id_order_set_process = in_id_order_set_process
               AND ospt.flg_discard_type = g_task_not_discard
               AND get_proc_task_presel(i_lang, i_prof, ospt.id_order_set_process_task) = pk_alert_constant.g_no;
    
        CURSOR c_proc_tasks_to_order(in_id_order_set_process NUMBER) IS
            SELECT ospt.id_order_set_process_task
              FROM order_set_process_task ospt
             WHERE ospt.flg_status = g_order_set_proc_tsk_temp
               AND ospt.id_order_set_process = in_id_order_set_process
               AND ospt.flg_discard_type = g_task_not_discard
               AND get_proc_task_presel(i_lang, i_prof, ospt.id_order_set_process_task) = pk_alert_constant.g_yes;
    
        rec_proc_tasks_to_order     table_number;
        rec_proc_tasks_to_not_order table_number;
        error_request_tasks EXCEPTION;
        error_set_cosign    EXCEPTION;
        l_exception         EXCEPTION;
    
        l_combination_name  order_set.title%TYPE;
        l_task_type_list    table_number;
        l_event_list        table_number;
        l_dependencies_from table_number;
        l_dependencies_to   table_number;
        l_lag_min           table_number;
        l_lag_max           table_number;
        l_lag_unit_measure  table_number;
    
        -- scheduler 3.0 variable
        l_transaction_id VARCHAR2(4000);
    
        -- get data to create future events combination
        FUNCTION get_odst_combination_data
        (
            o_combination_name  OUT order_set.title%TYPE,
            o_task_type_list    OUT table_number,
            o_event_list        OUT table_number,
            o_dependencies_from OUT table_number,
            o_dependencies_to   OUT table_number,
            o_lag_min           OUT table_number,
            o_lag_max           OUT table_number,
            o_lag_unit_measure  OUT table_number
        ) RETURN BOOLEAN IS
        
            l_event_tasks      table_number := table_number();
            l_event_tasks_to   table_number := table_number();
            l_event_tasks_from table_number := table_number();
        
        BEGIN
        
            -- get combination name
            SELECT odst.title
              INTO o_combination_name
              FROM order_set_process odst_proc
             INNER JOIN order_set odst
                ON odst_proc.id_order_set = odst.id_order_set
             WHERE odst_proc.id_order_set_process = i_id_order_set_process;
        
            -- get event tasks (schedulable and available tasks)
            SELECT odst_proc_tsk.id_order_set_process_task
              BULK COLLECT
              INTO l_event_tasks
              FROM order_set_process_task odst_proc_tsk
             WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
                  -- check if task type is available on future events area
               AND pk_events.is_fe_available_by_tk(odst_proc_tsk.id_task_type, i_prof) = pk_alert_constant.g_yes
               AND odst_proc_tsk.flg_schedule = pk_alert_constant.g_yes;
        
            -- get event dependencies
            SELECT /*+ opt_estimate(table event_task_from rows = 1) opt_estimate(table event_task_to rows = 1)*/
             odst_proc_tsk_dep.id_order_set_proc_task_from,
             odst_proc_tsk_dep.id_order_set_proc_task_to,
             odst_proc_tsk_dep.lag_min,
             odst_proc_tsk_dep.lag_max,
             odst_proc_tsk_dep.id_unit_measure_lag
              BULK COLLECT
              INTO l_event_tasks_from, l_event_tasks_to, o_lag_min, o_lag_max, o_lag_unit_measure
              FROM order_set_process_task_depend odst_proc_tsk_dep
             INNER JOIN TABLE(l_event_tasks) event_task_from
                ON event_task_from.column_value = odst_proc_tsk_dep.id_order_set_proc_task_from
             INNER JOIN TABLE(l_event_tasks) event_task_to
                ON event_task_to.column_value = odst_proc_tsk_dep.id_order_set_proc_task_to
             WHERE odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_finish2start
               AND odst_proc_tsk_dep.id_order_set_process = i_id_order_set_process;
        
            -- get event task list according to dependencies
            l_event_tasks := l_event_tasks_from MULTISET UNION DISTINCT l_event_tasks_to;
        
            -- get event list data (type, ID and order number of each event)
            SELECT /*+ opt_estimate(table event_list rows = 1)*/
             odst_proc_tsk.id_request, odst_proc_tsk.id_task_type
              BULK COLLECT
              INTO o_event_list, o_task_type_list
              FROM order_set_process_task odst_proc_tsk
             INNER JOIN TABLE(l_event_tasks) event_tasks
                ON event_tasks.column_value = odst_proc_tsk.id_order_set_process_task
            -- order by event order number
             ORDER BY get_task_rank(l_event_tasks, odst_proc_tsk.id_order_set_process_task);
        
            -- get dependencies data
            o_dependencies_from := table_number();
            o_dependencies_to   := table_number();
        
            FOR i IN 1 .. l_event_tasks_from.count
            LOOP
                o_dependencies_from.extend;
                o_dependencies_to.extend;
                o_dependencies_from(i) := get_task_rank(l_event_tasks, l_event_tasks_from(i));
                o_dependencies_to(i) := get_task_rank(l_event_tasks, l_event_tasks_to(i));
            END LOOP;
        
            -- check if this combination has at least two events and a dependency between them (more than zero relations)
            IF o_dependencies_from.count > 0
            THEN
                RETURN TRUE;
            ELSE
                RETURN FALSE;
            END IF;
        
        END get_odst_combination_data;
    
    BEGIN
    
        -- gets a new transaction id and begins the transaction (for the scheduler 3.0 transactions)
    
        g_flg_force_diet := i_flg_force;
    
        g_error          := 'CALL PK_SCHEDULE_API_UPSTREAM.BEGIN_NEW_TRANSACTION';
        l_transaction_id := pk_schedule_api_upstream.begin_new_transaction(NULL, i_prof);
    
        g_error := 'UPDATE ORDER SET PROCESS STATUS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- get order set process task IDs 
        OPEN c_proc_tasks_to_not_order(i_id_order_set_process);
        FETCH c_proc_tasks_to_not_order BULK COLLECT
            INTO rec_proc_tasks_to_not_order;
        CLOSE c_proc_tasks_to_not_order;
    
        -- delete order set process tasks that were marked to not ordered
        IF NOT delete_order_set_proc_tasks(i_lang                 => i_lang,
                                           i_prof                 => i_prof,
                                           i_order_set_proc_tasks => rec_proc_tasks_to_not_order,
                                           o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get order set process task IDs 
        OPEN c_proc_tasks_to_order(i_id_order_set_process);
        FETCH c_proc_tasks_to_order BULK COLLECT
            INTO rec_proc_tasks_to_order;
        CLOSE c_proc_tasks_to_order;
    
        -- check if there are tasks to request. If not, order set process won't be created.
        IF rec_proc_tasks_to_order.count = 0
        THEN
            -- cancel temporary order set process
            IF NOT pk_order_sets.cancel_order_set_process(i_lang                 => i_lang,
                                                          i_prof                 => i_prof,
                                                          i_id_patient           => i_id_patient,
                                                          i_id_episode           => i_id_episode,
                                                          i_id_order_set_process => i_id_order_set_process,
                                                          i_id_cancel_reason     => NULL,
                                                          i_cancel_notes         => NULL,
                                                          i_prof_order           => NULL,
                                                          i_dt_order             => NULL,
                                                          i_order_type           => NULL,
                                                          o_error                => o_error)
            THEN
                RAISE l_exception;
            END IF;
        
            -- rollback order set requisition
            pk_utils.undo_changes;
        
            RETURN TRUE;
        END IF;
    
        -- set the order set process as definitive
        UPDATE order_set_process
           SET flg_status                = g_order_set_proc_tsk_running,
               dt_status_tstz            = l_sysdate,
               dt_order_set_process_tstz = l_sysdate,
               id_professional           = i_prof.id,
               id_prof_request           = i_prof.id
         WHERE id_order_set_process = i_id_order_set_process
           AND flg_status = g_order_set_proc_temp;
    
        -- request tasks
        IF NOT request_order_set_proc_tasks(i_lang                     => i_lang,
                                            i_prof                     => i_prof,
                                            i_id_patient               => i_id_patient,
                                            i_id_episode               => i_id_episode,
                                            i_id_order_set_process     => i_id_order_set_process,
                                            i_id_proc_tasks            => rec_proc_tasks_to_order,
                                            i_clinical_question_ospt   => i_clinical_question_ospt,
                                            i_clinical_question_id     => i_clinical_question_id,
                                            i_clinical_question_answer => i_clinical_question_answer,
                                            i_clinical_question_notes  => i_clinical_question_notes,
                                            i_cdr_call                 => i_cdr_call,
                                            i_transaction_id           => l_transaction_id,
                                            o_error                    => o_error)
        THEN
            IF o_error.ora_sqlerrm = 'DIET_ERR001'
            THEN
                o_msg_warning := pk_message.get_message(i_lang, 'DIET_T141');
            
                ROLLBACK;
            
                RETURN TRUE;
            ELSE
                RAISE error_request_tasks;
            END IF;
        END IF;
    
        -- get data necessary to create the order set combination
        -- check if this order set has data to create a future events combination
        IF get_odst_combination_data(o_combination_name  => l_combination_name,
                                     o_task_type_list    => l_task_type_list,
                                     o_event_list        => l_event_list,
                                     o_dependencies_from => l_dependencies_from,
                                     o_dependencies_to   => l_dependencies_to,
                                     o_lag_min           => l_lag_min,
                                     o_lag_max           => l_lag_max,
                                     o_lag_unit_measure  => l_lag_unit_measure)
        THEN
            -- create order set future events combination       
            IF NOT pk_events.insert_order_set_combination(i_lang                   => i_lang,
                                                          i_prof                   => i_prof,
                                                          i_patient                => i_id_patient,
                                                          i_comb_name              => l_combination_name,
                                                          i_dt_suggest_begin       => pk_date_utils.date_send_tsz(i_lang,
                                                                                                                  l_sysdate,
                                                                                                                  i_prof),
                                                          i_dt_suggest_end         => NULL,
                                                          i_single_visit           => pk_alert_constant.g_no,
                                                          i_flg_freq_origin_module => pk_alert_constant.g_task_origin_order_set,
                                                          i_task_type_list         => l_task_type_list,
                                                          i_event_list             => l_event_list,
                                                          i_dependencies_from      => l_dependencies_from,
                                                          i_dependencies_to        => l_dependencies_to,
                                                          i_lag_min                => l_lag_min,
                                                          i_lag_max                => l_lag_max,
                                                          i_lag_unit_meas          => l_lag_unit_measure,
                                                          i_episode                => i_id_episode,
                                                          o_error                  => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        g_error := 'CALL ORDER SET REQUEST TRIGGER EVENT FOR INTER-ALERT';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- call order set request trigger event for INTER-ALERT
        pk_ia_event_order_mngmt.order_set_requested(i_id_institution       => i_prof.institution,
                                                    i_id_order_set_process => i_id_order_set_process);
    
        pk_schedule_api_upstream.do_commit(l_transaction_id, i_prof);
    
        o_msg_warning := '';
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error while requesting order set process tasks
        WHEN error_request_tasks THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              o_error.ora_sqlerrm,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROCESS',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
        
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROCESS',
                                              o_error);
            pk_schedule_api_upstream.do_rollback(l_transaction_id, i_prof);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_process;

    FUNCTION get_order_set_diagnosis
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_episode   IN episode.id_episode%TYPE,
        i_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_diag VARCHAR2(1 CHAR) := g_no;
    
    BEGIN
    
        SELECT g_no
          INTO l_diag
          FROM order_set os
         WHERE os.id_order_set = i_order_set
           AND os.clinical_indications IS NOT NULL;
    
        SELECT g_yes
          INTO l_diag
          FROM (SELECT id_diagnosis, id_alert_diag
                  FROM (SELECT VALUE(ed) diag_records
                          FROM TABLE(xmlsequence(extract(xmltype((SELECT os.clinical_indications
                                                                   FROM order_set os
                                                                  WHERE os.id_order_set = i_order_set)),
                                                         '/EPIS_DIAGNOSES'))) ed) dr,
                       xmltable('/EPIS_DIAGNOSES/EPIS_DIAGNOSIS/DIAGNOSIS' passing dr.diag_records columns --
                                "ID_DIAGNOSIS" NUMBER(24) path '@ID_DIAGNOSIS',
                                "ID_ALERT_DIAG" NUMBER(24) path '@ID_ALERT_DIAG')) d,
               (SELECT /*+opt_estimate (table t rows=1)*/
                 t.id_diagnosis, t.id_alert_diagnosis
                  FROM TABLE(pk_diagnosis.get_associated_diagnosis_tf(i_lang, i_prof, i_episode)) t) ed
         WHERE ed.id_diagnosis = d.id_diagnosis
           AND ed.id_alert_diagnosis = d.id_alert_diag;
    
        RETURN l_diag;
    
    EXCEPTION
        WHEN no_data_found THEN
            l_diag := g_no;
        
            RETURN l_diag;
    END get_order_set_diagnosis;

    FUNCTION get_odst_frequent_search_int
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        i_flg_filter IN VARCHAR2,
        i_value      IN VARCHAR2
    ) RETURN t_tbl_odst_frequent IS
    
        l_institutions table_number;
        l_id_complaint table_number;
        l_filter       VARCHAR2(1 CHAR);
    
        l_id_category category.id_category%TYPE;
        l_order_sets  t_tbl_odst_frequent;
    
        l_exception EXCEPTION;
        l_error_out t_error_out;
    
    BEGIN
    
        g_error        := 'GET ALL INSTITUTIONS FROM THE SAME GROUP';
        l_institutions := table_number(i_prof.institution);
        l_id_category  := pk_prof_utils.get_id_category(i_lang, i_prof);
    
        g_error  := 'GET CHIEF COMPLAINT FOR EPISODE';
        l_filter := i_flg_filter; -- staring mode for l_filter condition
    
        IF i_flg_filter = g_order_set_filter_chief_compl
        THEN
            IF NOT pk_complaint.get_epis_act_complaint(i_lang         => i_lang,
                                                       i_prof         => i_prof,
                                                       i_episode      => i_id_episode,
                                                       o_id_complaint => l_id_complaint,
                                                       o_error        => l_error_out)
            THEN
                RAISE l_exception;
            END IF;
            -- if no complaint was associated with the patient, then show all order sets
            IF l_id_complaint IS NULL
            THEN
                l_filter := g_order_set_filter_frequent;
            END IF;
        END IF;
    
        g_error := 'GET MOST FREQUENT ORDER SETS';
        SELECT t_rec_odst_frequent(id_order_set, title || ' (' || num_tasks || ')', title)
          BULK COLLECT
          INTO l_order_sets
          FROM (SELECT odst.id_order_set,
                        odst.title,
                        (SELECT COUNT(*)
                           FROM order_set_task ost
                          WHERE ost.id_order_set = odst.id_order_set
                            AND (SELECT check_order_set_task_conflict(i_lang,
                                                                      i_prof,
                                                                      i_id_patient,
                                                                      i_id_episode,
                                                                      ost.id_order_set_task,
                                                                      ost.id_task_type,
                                                                      NULL)
                                   FROM dual) = pk_alert_constant.g_no
                            AND ((ost.id_task_type = g_odst_task_analysis AND
                                (SELECT get_lab_test_access_permission(i_lang, i_prof, ost.id_order_set_task)
                                     FROM dual) = pk_alert_constant.g_yes) OR (ost.id_task_type <> g_odst_task_analysis))) num_tasks
                   FROM order_set odst
                  WHERE odst.id_institution IN (SELECT /*+opt_estimate(table inst rows=1)*/
                                                 column_value
                                                  FROM TABLE(l_institutions) inst)
                    AND odst.flg_status = g_order_set_finished
                       -- verify professional use grants
                    AND nvl((SELECT g_available
                              FROM professional prof_edit
                             WHERE prof_edit.id_professional = i_prof.id
                               AND (
                                   -- verify if professional is the author
                                    odst.id_professional = i_prof.id OR
                                   -- verify if professional has the same specialty as the author
                                    (odst.flg_target_professionals = g_order_set_target_profs_spec AND
                                    nvl(prof_edit.id_speciality, -1) IN
                                    nvl((SELECT odst_lnk.id_link
                                           FROM order_set_link odst_lnk
                                          WHERE odst_lnk.id_order_set = odst.id_order_set
                                            AND odst_lnk.flg_link_type = g_order_set_link_spec),
                                         -1)) OR
                                   -- verify if professional has the same category as the author
                                    (odst.flg_target_professionals = g_order_set_target_profs_cat AND
                                    l_id_category = (SELECT pk_prof_utils.get_id_category(i_lang,
                                                                                           profissional(odst.id_professional,
                                                                                                        i_prof.institution,
                                                                                                        i_prof.software))
                                                        FROM dual)) OR
                                   -- doesn't matter the specialty or category of the professional
                                   odst.flg_target_professionals = g_order_set_target_profs_all)),
                           g_not_available) = g_available
                      -- verify order set department/environment
                   AND i_prof.software IN (SELECT sd.id_software
                                             FROM software_dept sd, order_set_link odst_link
                                            WHERE odst_link.id_order_set = odst.id_order_set
                                              AND odst_link.flg_link_type = g_order_set_link_envi
                                              AND odst_link.id_link = sd.id_dept)
                      -- all filter processing                 
                   AND (l_filter = g_order_set_filter_frequent
                       -- chief complaint filter processing
                       OR (l_filter = g_order_set_filter_chief_compl AND EXISTS
                        (SELECT 1
                               FROM order_set_link osl
                              WHERE osl.id_order_set = odst.id_order_set
                                AND ((i_prof.software NOT IN
                                    (pk_alert_constant.g_soft_outpatient, pk_alert_constant.g_soft_primary_care) AND
                                    osl.flg_link_type = g_order_set_link_chief_compl) OR
                                    (i_prof.software IN
                                    (pk_alert_constant.g_soft_outpatient, pk_alert_constant.g_soft_primary_care) AND
                                    osl.flg_link_type = g_order_set_link_reason_visit))
                                AND osl.id_link IN (SELECT /*+opt_estimate(table t rows=1)*/
                                                     *
                                                      FROM TABLE(l_id_complaint) t))) OR
                       -- diagnosis filter processing
                       (l_filter = g_order_set_filter_diagnosis AND
                       (SELECT pk_order_sets.get_order_set_diagnosis(i_lang, i_prof, i_id_episode, odst.id_order_set)
                            FROM dual) = g_yes)
                       -- management order set type filter processing
                       OR (l_filter = g_order_set_filter_odst_mng AND EXISTS
                        (SELECT 1
                               FROM order_set_link osl
                              WHERE osl.id_order_set = odst.id_order_set
                                AND osl.flg_link_type = g_order_set_link_odst_type
                                AND osl.id_link = g_order_set_type_mng))
                       -- prevention order set type filter processing
                       OR (l_filter = g_order_set_filter_odst_prv AND EXISTS
                        (SELECT 1
                               FROM order_set_link osl
                              WHERE osl.id_order_set = odst.id_order_set
                                AND osl.flg_link_type = g_order_set_link_odst_type
                                AND osl.id_link = g_order_set_type_prv))
                       -- screening order set type filter processing
                       OR (l_filter = g_order_set_filter_odst_scr AND EXISTS
                        (SELECT 1
                               FROM order_set_link osl
                              WHERE osl.id_order_set = odst.id_order_set
                                AND osl.flg_link_type = g_order_set_link_odst_type
                                AND osl.id_link = g_order_set_type_scr))
                       -- treatment order set type filter processing
                       OR (l_filter = g_order_set_filter_odst_trt AND EXISTS
                        (SELECT 1
                               FROM order_set_link osl
                              WHERE osl.id_order_set = odst.id_order_set
                                AND osl.flg_link_type = g_order_set_link_odst_type
                                AND osl.id_link = g_order_set_type_trt)))
                      -- search for value
                   AND (i_value IS NULL OR
                       (translate(upper(odst.title), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                       '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%' AND
                       i_value IS NOT NULL)))
         WHERE num_tasks != 0;
    
        RETURN l_order_sets;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_FREQUENT_SEARCH_INT',
                                              l_error_out);
            RETURN NULL;
    END get_odst_frequent_search_int;

    FUNCTION get_order_set_frequent_search
    (
        i_lang          IN language.id_language%TYPE,
        i_prof          IN profissional,
        i_id_patient    IN patient.id_patient%TYPE,
        i_id_episode    IN episode.id_episode%TYPE,
        i_flg_filter    IN VARCHAR2,
        i_value         IN VARCHAR2,
        o_order_sets    OUT pk_types.cursor_type,
        o_change_filter OUT VARCHAR2,
        o_error         OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
    BEGIN
    
        o_change_filter := pk_order_sets.g_no;
    
        g_error := 'GET MOST FREQUENT ORDER SETS';
        OPEN o_order_sets FOR
            SELECT /*+opt_estimate(table t rows=1)*/
             t.id_order_set, t.order_set_desc description, t.order_set_title title
              FROM TABLE(CAST(get_odst_frequent_search_int(i_lang       => i_lang,
                                                           i_prof       => i_prof,
                                                           i_id_patient => i_id_patient,
                                                           i_id_episode => i_id_episode,
                                                           i_flg_filter => i_flg_filter,
                                                           i_value      => i_value) AS t_tbl_odst_frequent)) t
             ORDER BY upper(t.order_set_title);
    
        IF o_order_sets%ROWCOUNT = 0
           AND i_flg_filter != g_order_set_filter_frequent
           AND i_value IS NOT NULL
        THEN
            o_change_filter := pk_order_sets.g_yes;
            OPEN o_order_sets FOR
                SELECT /*+opt_estimate(table t rows=1)*/
                 t.id_order_set, t.order_set_desc description, t.order_set_title title
                  FROM TABLE(CAST(get_odst_frequent_search_int(i_lang       => i_lang,
                                                               i_prof       => i_prof,
                                                               i_id_patient => i_id_patient,
                                                               i_id_episode => i_id_episode,
                                                               i_flg_filter => g_order_set_filter_frequent,
                                                               i_value      => i_value) AS t_tbl_odst_frequent)) t
                 ORDER BY upper(t.order_set_title);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_FREQUENT_SEARCH',
                                              o_error);
        
            pk_types.open_my_cursor(o_order_sets);
            RETURN FALSE;
    END get_order_set_frequent_search;

    FUNCTION get_order_set_search
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        i_value      IN VARCHAR2,
        o_order_sets OUT pk_types.cursor_type,
        o_flg_show   OUT VARCHAR2,
        o_msg        OUT VARCHAR2,
        o_msg_title  OUT VARCHAR2,
        o_button     OUT VARCHAR2,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_count        PLS_INTEGER;
        l_institutions table_number;
    
    BEGIN
    
        o_flg_show := g_no;
    
        DELETE FROM tbl_temp;
    
        g_error := 'GET ALL INSTITUTIONS FROM THE SAME GROUP';
        pk_alertlog.log_debug(g_error, g_package_name);
        l_institutions := table_number(i_prof.institution);
    
        g_error := 'GET ORDER SETS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        INSERT INTO tbl_temp
            (num_1, vc_1, vc_2)
            SELECT odst.id_order_set,
                   odst.title || ' (' || (SELECT COUNT(*)
                                            FROM order_set_task ost
                                           WHERE ost.id_order_set = odst.id_order_set) || ')' description,
                   odst.title title
              FROM order_set odst
             WHERE odst.id_institution IN (SELECT /*+opt_estimate(table inst rows=1)*/
                                            column_value
                                             FROM TABLE(l_institutions) inst)
               AND odst.flg_status = g_order_set_finished
                  -- verify professional use grants
               AND nvl((SELECT g_available
                         FROM professional prof_edit
                        WHERE prof_edit.id_professional = i_prof.id
                          AND (
                              -- verify if professional is the author
                               odst.id_professional = i_prof.id OR
                              -- verify if professional has the same specialty as the author
                               (odst.flg_target_professionals = g_order_set_target_profs_spec AND
                               nvl(prof_edit.id_speciality, -1) IN
                               nvl((SELECT odst_lnk.id_link
                                      FROM order_set_link odst_lnk
                                     WHERE odst_lnk.id_order_set = odst.id_order_set
                                       AND odst_lnk.flg_link_type = g_order_set_link_spec),
                                    -1)) OR
                              -- verify if professional has the same category as the author
                               (odst.flg_target_professionals = g_order_set_target_profs_cat AND
                               pk_prof_utils.get_id_category(i_lang, i_prof) =
                               pk_prof_utils.get_id_category(i_lang,
                                                              profissional(odst.id_professional,
                                                                           i_prof.institution,
                                                                           i_prof.software))) OR
                              -- doesn't matter the specialty or category of the professional
                               odst.flg_target_professionals = g_order_set_target_profs_all)),
                       g_not_available) = g_available
                  -- verify order set department/environment
               AND i_prof.software IN (SELECT sd.id_software
                                         FROM software_dept sd, order_set_link odst_link
                                        WHERE odst_link.id_order_set = odst.id_order_set
                                          AND odst_link.flg_link_type = g_order_set_link_envi
                                          AND odst_link.id_link = sd.id_dept)
                  -- ** search for value **
               AND (i_value IS NOT NULL AND
                   (translate(upper(odst.title), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%') OR
                   i_value IS NULL);
    
        g_error := 'COUNT NUMBER OF RESULTS';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        SELECT COUNT(1)
          INTO l_count
          FROM tbl_temp;
    
        IF l_count = 0
        THEN
            o_flg_show  := g_yes;
            o_msg       := pk_message.get_message(i_lang, 'COMMON_M015');
            o_msg_title := pk_message.get_message(i_lang, 'SEARCH_CRITERIA_T011');
            o_button    := 'R';
        
            pk_types.open_my_cursor(o_order_sets);
        ELSE
            g_error := 'OPEN CURSOR';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            OPEN o_order_sets FOR
                SELECT num_1 id_order_set, vc_1 description, vc_2 title
                  FROM tbl_temp
                 ORDER BY upper(title);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_SEARCH',
                                              o_error);
            pk_types.open_my_cursor(o_order_sets);
            RETURN FALSE;
    END get_order_set_search;

    FUNCTION get_order_set_tasks_search
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_id_order_set    IN order_set.id_order_set%TYPE,
        i_id_patient      IN patient.id_patient%TYPE,
        i_id_episode      IN episode.id_episode%TYPE,
        i_value           IN VARCHAR2,
        o_order_set_tasks OUT pk_types.cursor_type,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tasks_rank        table_number;
        l_task_dependencies table_number := table_number();
        l_task_conflicts    table_varchar := table_varchar();
    
        l_task_index PLS_INTEGER := 1;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
        l_flg_task_schedule    VARCHAR2(1 CHAR);
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ORDER SET TASKS RANK';
        -- get order set dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET ORDER SET TASKS CONFLICTS';
        -- calculate conflicts for each order set task
        FOR rec IN (SELECT odst_tsk.id_order_set_task, odst_tsk.id_task_type
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set = i_id_order_set)
        LOOP
        
            l_task_dependencies.extend;
            l_task_conflicts.extend;
        
            l_task_dependencies(l_task_index) := rec.id_order_set_task;
        
            -- verify if this task is schedulable
            l_flg_task_schedule := check_episode_support_task(i_lang                 => i_lang,
                                                              i_prof                 => i_prof,
                                                              i_dependency_type      => l_dependency_type,
                                                              i_task_dependency_from => l_task_dependency_from,
                                                              i_task_dependency_to   => l_task_dependency_to,
                                                              i_order_set_task       => rec.id_order_set_task,
                                                              i_task_type            => rec.id_task_type);
        
            l_task_conflicts(l_task_index) := check_order_set_task_conflict(i_lang,
                                                                            i_prof,
                                                                            i_id_patient,
                                                                            i_id_episode,
                                                                            rec.id_order_set_task,
                                                                            rec.id_task_type,
                                                                            l_flg_task_schedule);
            l_task_index := l_task_index + 1;
        END LOOP;
    
        g_error := 'GET ORDER SET TASKS CURSOR';
        OPEN o_order_set_tasks FOR
            SELECT nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                   task_group_desc,
                   task_group_rank,
                   id_order_set_task,
                   id_task_type,
                   (CASE
                        WHEN flg_conflict = pk_alert_constant.g_no THEN
                         pk_alert_constant.g_active
                        ELSE
                         pk_alert_constant.g_inactive
                    END) flg_select,
                   get_task_rank(l_tasks_rank, id_order_set_task) dependency_order,
                   nvl2(id_order_set_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                   task_desc || chr(10) || replace_dependencies_refs_rank(i_lang,
                                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                                           i_prof,
                                                                                                           id_order_set_task,
                                                                                                           check_episode_support_task(i_lang,
                                                                                                                                      i_prof,
                                                                                                                                      l_dependency_type,
                                                                                                                                      l_task_dependency_from,
                                                                                                                                      l_task_dependency_to,
                                                                                                                                      id_order_set_task,
                                                                                                                                      id_task_type),
                                                                                                           l_tasks_rank,
                                                                                                           l_dependency_type,
                                                                                                           l_task_dependency_from,
                                                                                                           l_task_dependency_to,
                                                                                                           l_task_type_from,
                                                                                                           l_task_type_to,
                                                                                                           l_task_schedule_from,
                                                                                                           l_task_schedule_to,
                                                                                                           l_lag_min,
                                                                                                           l_lag_max,
                                                                                                           l_lag_unit_measure),
                                                                          l_tasks_rank) task_desc,
                   -- list of tasks that must be selected if this tasks is also selected
                   pk_tde_db.get_predecessor_dependencies(id_order_set_task,
                                                          l_dependency_type,
                                                          l_task_dependency_from,
                                                          l_task_dependency_to,
                                                          l_task_type_from,
                                                          l_task_type_to) depend_select_list,
                   -- list of tasks that must be unselected if this tasks is also unselected
                   pk_tde_db.get_sucessor_dependencies(id_order_set_task,
                                                       l_dependency_type,
                                                       l_task_dependency_from,
                                                       l_task_dependency_to,
                                                       l_task_type_from,
                                                       l_task_type_to) depend_unselect_list
              FROM (SELECT odst_tsk.id_order_set_task,
                           odst_tsk.id_task_type,
                           get_order_set_task_group_desc(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_desc,
                           get_order_set_task_group_rank(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_rank,
                           odst_tsk_dep.id_order_set_task_to,
                           check_order_set_task_conflict(i_lang,
                                                         i_prof,
                                                         i_id_patient,
                                                         i_id_episode,
                                                         odst_tsk.id_order_set_task,
                                                         odst_tsk.id_task_type,
                                                         NULL) flg_conflict,
                           get_task_desc(i_lang,
                                         i_prof,
                                         odst_tsk.id_order_set_task,
                                         odst_tsk.id_task_type,
                                         pk_alert_constant.g_no,
                                         check_episode_support_task(i_lang,
                                                                    i_prof,
                                                                    l_dependency_type,
                                                                    l_task_dependency_from,
                                                                    l_task_dependency_to,
                                                                    odst_tsk.id_order_set_task,
                                                                    odst_tsk.id_task_type),
                                         g_task_desc_extended_format,
                                         pk_alert_constant.g_no) task_desc
                      FROM order_set_task odst_tsk
                    -- verify if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_task_dependency odst_tsk_dep
                        ON (odst_tsk_dep.id_order_set_task_to = odst_tsk.id_order_set_task AND
                           odst_tsk_dep.id_order_set = i_id_order_set AND
                           odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_tsk_dep.id_order_set_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_tsk.id_order_set = i_id_order_set
                       AND ((odst_tsk.id_task_type <> g_odst_task_analysis) OR
                           (odst_tsk.id_task_type = g_odst_task_analysis AND
                           (SELECT get_lab_test_access_permission(i_lang, i_prof, odst_tsk.id_order_set_task)
                                FROM dual) = g_yes)))
            -- ** search for value **
             WHERE flg_conflict = pk_alert_constant.g_no
               AND (i_value IS NOT NULL AND
                   (translate(upper(task_desc), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%') OR
                   i_value IS NULL)
             ORDER BY group_type_id NULLS LAST, get_task_rank(l_tasks_rank, id_order_set_task);
    
        RETURN TRUE;
    
    EXCEPTION
        -- unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASKS_SEARCH',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_tasks);
            RETURN FALSE;
    END get_order_set_tasks_search;

    FUNCTION get_order_set_epis_diagnoses
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_id_patient IN patient.id_patient%TYPE,
        i_id_episode IN episode.id_episode%TYPE,
        o_epis_diags OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_search_diagnosis sys_config.value%TYPE := pk_sysconfig.get_config('PERMISSION_FOR_SEARCH_DIAGNOSIS', i_prof);
    
        l_profile_template profile_template.id_profile_template%TYPE := pk_prof_utils.get_prof_profile_template(i_prof);
    
        l_coll_diagnosis_config t_coll_diagnosis_config;
    
    BEGIN
    
        -- important: this instruction must be done outside of the SELECT statement
        g_error                 := 'Call pk_diagnosis.get_associated_diagnosis_tf / ';
        l_coll_diagnosis_config := pk_diagnosis.get_associated_diagnosis_tf(i_lang, i_prof, i_id_episode);
    
        g_error := 'OPEN CURSOR WITH EPIS DIAGNOSIS / ';
        OPEN o_epis_diags FOR
            SELECT id_epis_diagnosis, id_diagnosis, id_alert_diagnosis, code_icd, desc_diagnosis, rank, flg_other
              FROM (SELECT NULL id_diagnosis,
                           pk_message.get_message(i_lang, i_prof, g_message_search_diags) desc_diagnosis,
                           NULL code_icd,
                           NULL flg_other,
                           1 rank,
                           NULL id_alert_diagnosis,
                           NULL id_epis_diagnosis
                      FROM dual
                     WHERE instr(nvl(l_search_diagnosis, '#'), l_profile_template) != 0
                    UNION ALL
                    SELECT /*+opt_estimate (table t rows=1)*/
                     t.id_diagnosis,
                     t.desc_diagnosis,
                     t.code_icd,
                     t.flg_other,
                     0 rank,
                     t.id_alert_diagnosis,
                     t.id_epis_diagnosis
                      FROM TABLE(l_coll_diagnosis_config) t)
             ORDER BY rank ASC, desc_diagnosis ASC;
    
        RETURN TRUE;
    
    EXCEPTION
        -- unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_EPIS_DIAGNOSES',
                                              o_error);
            pk_types.open_my_cursor(o_epis_diags);
            RETURN FALSE;
    END get_order_set_epis_diagnoses;

    FUNCTION get_order_set_proc_info_notes
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_order_set_info       OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_diagnosis_desc       table_varchar;
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
    BEGIN
    
        -- get order set process clinical indications/diagnoses descriptions
        SELECT osp.clinical_indications
          INTO l_clinical_indications
          FROM order_set_process osp
         WHERE osp.id_order_set_process = i_id_order_set_process;
    
        -- get diagnosis records
        IF (l_clinical_indications IS NOT NULL)
        THEN
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                         i_prof   => i_prof,
                                                         i_params => l_clinical_indications);
        
            l_diagnosis_desc := table_varchar();
            l_diagnosis_desc.extend(l_rec_diagnoses.tbl_diagnosis.count);
        
            -- get description of each diagnosis record
            FOR i IN 1 .. l_rec_diagnoses.tbl_diagnosis.count
            LOOP
                l_diagnosis_desc(i) := pk_diagnosis.get_diag_desc(i_lang, i_prof, l_rec_diagnoses.tbl_diagnosis(i));
            END LOOP;
        ELSE
            l_diagnosis_desc := table_varchar();
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS INFO';
        OPEN o_order_set_info FOR
            SELECT odst_proc.notes_global,
                   pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_order, i_prof) dt_order,
                   odst_proc.id_prof_order,
                   odst_proc.id_order_type,
                   trunc_clob_to_varchar2(pk_utils.concat_table_l(l_diagnosis_desc, g_separator), g_trunc_clob_max_size) diagnoses_desc
              FROM order_set_process odst_proc, order_set odst
             WHERE odst_proc.id_order_set = odst.id_order_set
               AND odst_proc.id_order_set_process = i_id_order_set_process;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_INFO_NOTES',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_info);
            RETURN FALSE;
    END get_order_set_proc_info_notes;

    FUNCTION set_order_set_proc_info_notes
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        i_notes_global         IN order_set_process.notes_global%TYPE,
        i_prof_order           IN order_set_process.id_prof_order%TYPE,
        i_dt_order             IN VARCHAR2,
        i_order_type           IN order_set_process.id_order_type%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        error_undefined_status EXCEPTION;
    
    BEGIN
        g_error := 'UPDATE ORDER SET PROCESS NOTES AND INFO';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        UPDATE order_set_process
           SET notes_global  = i_notes_global,
               dt_order      = pk_date_utils.get_string_tstz(i_lang, i_prof, i_dt_order, NULL),
               id_prof_order = i_prof_order,
               id_order_type = i_order_type
         WHERE id_order_set_process = i_id_order_set_process
           AND flg_status = g_order_set_proc_temp;
    
        IF (SQL%ROWCOUNT = 0)
        THEN
            RAISE error_undefined_status;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error on update order set process notes and info
        WHEN error_undefined_status THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / UNDEFINED STATE FOR ORDER SET PROCESS',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_INFO_NOTES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_INFO_NOTES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_proc_info_notes;

    FUNCTION check_cancel_task_needs_cosign
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof_id                   IN professional.id_professional%TYPE,
        i_prof_inst                 IN institution.id_institution%TYPE,
        i_prof_soft                 IN software.id_software%TYPE,
        i_episode                   IN episode.id_episode%TYPE,
        i_id_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE DEFAULT NULL,
        i_task_type                 IN task_type.id_task_type%TYPE
    ) RETURN VARCHAR2 result_cache IS
    
        l_prof             profissional;
        l_flg_needs_cosign VARCHAR2(1 CHAR);
    
        l_exception EXCEPTION;
    
        l_error t_error_out;
    
    BEGIN
    
        -- initialization
        l_prof := profissional(id => i_prof_id, institution => i_prof_inst, software => i_prof_soft);
    
        CASE i_task_type
            WHEN g_odst_task_medication THEN
                g_error := 'CALL FUNCTION PK_API_PFH_ORDERTOOLS_IN.CHECK_PROF_NEEDS_COSIGN_CANCEL';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_api_pfh_ordertools_in.check_prof_needs_cosign_cancel(i_lang                 => i_lang,
                                                                               i_prof                 => l_prof,
                                                                               i_id_presc             => get_odst_proc_task_link(i_id_order_set_process_task,
                                                                                                                                 g_task_link_null),
                                                                               i_id_episode           => i_episode,
                                                                               o_flg_prof_need_cosign => l_flg_needs_cosign,
                                                                               o_error                => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            WHEN g_odst_task_comm_order THEN
                g_error := 'CALL FUNCTION PK_COMM_ORDERS_ORDER_SETS.CHECK_PROF_NEEDS_COSIGN2CANCEL';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_comm_orders_order_sets.check_prof_needs_cosign2cancel(i_lang                  => i_lang,
                                                                                i_prof                  => l_prof,
                                                                                i_episode               => i_episode,
                                                                                o_flg_prof_needs_cosign => l_flg_needs_cosign,
                                                                                o_error                 => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            WHEN g_odst_task_medical_order THEN
                g_error := 'CALL FUNCTION PK_COMM_ORDERS_ORDER_SETS.CHECK_PROF_NEEDS_COSIGN2CANCEL';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_comm_orders_order_sets.check_prof_needs_cosign2cancel(i_lang                  => i_lang,
                                                                                i_prof                  => l_prof,
                                                                                i_episode               => i_episode,
                                                                                o_flg_prof_needs_cosign => l_flg_needs_cosign,
                                                                                o_error                 => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            ELSE
                -- image exams, other exams, lab tests, procedures, monitoring
                g_error := 'CALL FUNCTION PK_CO_SIGN_API.CHECK_PROF_NEEDS_COSIGN';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                              i_prof                   => l_prof,
                                                              i_episode                => i_episode,
                                                              i_task_type              => i_task_type,
                                                              i_cosign_def_action_type => pk_co_sign.g_cosign_action_def_cancel,
                                                              o_flg_prof_need_cosign   => l_flg_needs_cosign,
                                                              o_error                  => l_error)
                THEN
                    RAISE l_exception;
                END IF;
        END CASE;
    
        RETURN l_flg_needs_cosign;
    
    END check_cancel_task_needs_cosign;

    FUNCTION check_order_task_needs_cosign
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof_id                   IN professional.id_professional%TYPE,
        i_prof_inst                 IN institution.id_institution%TYPE,
        i_prof_soft                 IN software.id_software%TYPE,
        i_episode                   IN episode.id_episode%TYPE,
        i_id_order_set_process_task IN order_set_process_task.id_order_set_process_task%TYPE DEFAULT NULL,
        i_task_type                 IN task_type.id_task_type%TYPE
    ) RETURN VARCHAR2 result_cache IS
    
        l_prof             profissional;
        l_flg_needs_cosign VARCHAR2(1 CHAR);
    
        l_exception EXCEPTION;
        l_error t_error_out;
    
    BEGIN
    
        -- initialization
        l_prof := profissional(id => i_prof_id, institution => i_prof_inst, software => i_prof_soft);
    
        CASE i_task_type
            WHEN g_odst_task_medication THEN
                g_error := 'CALL FUNCTION PK_API_PFH_ORDERTOOLS_IN.CHECK_PROF_NEEDS_COSIGN_CREATE';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_api_pfh_ordertools_in.check_prof_needs_cosign_create(i_lang                 => i_lang,
                                                                               i_prof                 => l_prof,
                                                                               i_id_presc             => get_odst_proc_task_link(i_id_order_set_process_task,
                                                                                                                                 g_task_link_null),
                                                                               i_id_episode           => i_episode,
                                                                               o_flg_prof_need_cosign => l_flg_needs_cosign,
                                                                               o_error                => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            WHEN g_odst_task_comm_order THEN
                g_error := 'CALL FUNCTION PK_COMM_ORDERS_ORDER_SETS.CHECK_PROF_NEEDS_COSIGN2ORDER';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_comm_orders_order_sets.check_prof_needs_cosign2order(i_lang                  => i_lang,
                                                                               i_prof                  => l_prof,
                                                                               i_episode               => i_episode,
                                                                               o_flg_prof_needs_cosign => l_flg_needs_cosign,
                                                                               o_error                 => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            WHEN g_odst_task_medical_order THEN
                g_error := 'CALL FUNCTION PK_COMM_ORDERS_ORDER_SETS.CHECK_PROF_NEEDS_COSIGN2ORDER';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_comm_orders_order_sets.check_prof_needs_cosign2order(i_lang                  => i_lang,
                                                                               i_prof                  => l_prof,
                                                                               i_episode               => i_episode,
                                                                               o_flg_prof_needs_cosign => l_flg_needs_cosign,
                                                                               o_error                 => l_error)
                THEN
                    RAISE l_exception;
                END IF;
            
            ELSE
                -- image exams, other exams, lab tests, procedures, monitoring
                g_error := 'CALL FUNCTION PK_CO_SIGN_API.CHECK_PROF_NEEDS_COSIGN';
                pk_alertlog.log_debug(g_error, g_package_name);
                IF NOT pk_co_sign_api.check_prof_needs_cosign(i_lang                   => i_lang,
                                                              i_prof                   => l_prof,
                                                              i_episode                => i_episode,
                                                              i_task_type              => i_task_type,
                                                              i_cosign_def_action_type => pk_co_sign.g_cosign_action_def_add,
                                                              o_flg_prof_need_cosign   => l_flg_needs_cosign,
                                                              o_error                  => l_error)
                THEN
                    RAISE l_exception;
                END IF;
        END CASE;
    
        RETURN l_flg_needs_cosign;
    
    END check_order_task_needs_cosign;

    FUNCTION get_order_set_proc_tasks
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_episode                   IN episode.id_episode%TYPE,
        i_id_order_set_process      IN order_set_process_task.id_order_set_process%TYPE,
        o_order_set_proc_tasks      OUT pk_types.cursor_type,
        o_order_set_proc_tasks_rank OUT table_number,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tasks_rank table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ORDER SET PROCESS TASKS RANK';
        -- get order set process dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_process),
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_process),
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS TASKS';
        OPEN o_order_set_proc_tasks FOR
            SELECT nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                   task_group_desc,
                   task_group_tooltip,
                   task_group_rank,
                   id_order_set_process_task,
                   get_odst_proc_task_link(id_order_set_process_task, flg_task_link_type) id_task_link,
                   id_task_type,
                   id_task_type_source,
                   flg_task_link_type,
                   icon,
                   '<b>' || dependency_order || ' - </b>' ||
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_process_task,
                                 id_task_type,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_yes,
                                 g_task_desc_extended_format,
                                 pk_alert_constant.g_no) task_desc,
                   get_task_desc(i_lang,
                                 i_prof,
                                 id_order_set_process_task,
                                 id_task_type,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_no,
                                 g_task_desc_short_format,
                                 pk_alert_constant.g_no) task_title,
                   task_instruct,
                   flg_ok,
                   dependency_order,
                   icon_dep_name,
                   dependency_desc,
                   pk_alert_constant.g_yes flg_edit,
                   -- for order sets, if supported, task type reference will be directly 
                   -- mapped to cds task types. Otherwise, it will be null
                   decode(pk_cdr_fo_core.check_cdr_support(id_task_type), pk_alert_constant.g_yes, id_task_type, NULL) cds_id_task_type,
                   flg_task_selected,
                   pk_sysdomain.get_domain(g_odst_tsks_order_stat_domain, flg_task_selected, i_lang) order_ongoing_status_desc,
                   check_order_task_needs_cosign(i_lang                      => i_lang,
                                                 i_prof_id                   => i_prof.id,
                                                 i_prof_inst                 => i_prof.institution,
                                                 i_prof_soft                 => i_prof.software,
                                                 i_episode                   => i_episode,
                                                 i_id_order_set_process_task => (CASE id_task_type
                                                                                    WHEN g_odst_task_medication THEN
                                                                                    -- this parameter is needed, because only the medication module knows what is the type of each prescription contained in the order set
                                                                                     id_order_set_process_task
                                                                                    ELSE
                                                                                    -- for the other types of tasks this parameter is passed with null value, in order to take advantage of the result cache by task type
                                                                                     NULL
                                                                                END),
                                                 i_task_type                 => id_task_type) flg_task_needs_co_sign,
                   pk_api_pfh_in.get_presc_prod_restrictions(i_lang     => i_lang,
                                                             i_prof     => i_prof,
                                                             i_id_presc => get_odst_proc_task_link(id_order_set_process_task,
                                                                                                   flg_task_link_type)) flg_med_restriction,
                   flg_clinical_question
              FROM (SELECT odst_proc_tsk.id_order_set_process_task,
                           get_odst_proc_task_link_type(odst_proc_tsk.id_order_set_process_task) flg_task_link_type,
                           odst_proc_tsk.id_task_type,
                           get_odst_proc_task_group_desc(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task) task_group_desc,
                           get_odst_proc_tsk_grp_tooltip(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task) task_group_tooltip,
                           get_odst_proc_task_group_rank(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task) task_group_rank,
                           get_task_type_icon(i_lang,
                                              i_prof,
                                              odst_proc_tsk.id_task_type,
                                              odst_proc_tsk.id_order_set_process_task,
                                              pk_alert_constant.g_yes,
                                              odst_proc_tsk.flg_schedule) icon,
                           get_task_type_source(i_lang,
                                                i_prof,
                                                odst_proc_tsk.id_task_type,
                                                odst_proc_tsk.id_order_set_process_task,
                                                pk_alert_constant.g_yes,
                                                odst_proc_tsk.flg_schedule) id_task_type_source,
                           get_task_instructions_desc(i_lang,
                                                      i_prof,
                                                      table_number(odst_proc_tsk.id_order_set_process_task),
                                                      pk_alert_constant.g_yes) task_instruct,
                           CASE
                                WHEN check_order_task_needs_cosign(i_lang                      => i_lang,
                                                                   i_prof_id                   => i_prof.id,
                                                                   i_prof_inst                 => i_prof.institution,
                                                                   i_prof_soft                 => i_prof.software,
                                                                   i_episode                   => i_episode,
                                                                   i_id_order_set_process_task => (CASE
                                                                                                   odst_proc_tsk.id_task_type
                                                                                                      WHEN
                                                                                                       g_odst_task_medication THEN
                                                                                                      -- this parameter is needed, because only the medication module knows what is the type of each prescription contained in the order set
                                                                                                       odst_proc_tsk.id_order_set_process_task
                                                                                                      ELSE
                                                                                                      -- for the other types of tasks this parameter is passed with null value, in order to take advantage of the result cache by task type
                                                                                                       NULL
                                                                                                  END),
                                                                   i_task_type                 => odst_proc_tsk.id_task_type) =
                                     pk_alert_constant.g_yes
                                     AND odst_proc_tsk.id_task_type = g_odst_task_medication THEN
                                 pk_alert_constant.g_yes
                                ELSE
                                 check_mandatory_fields(i_lang,
                                                        i_prof,
                                                        odst_proc_tsk.id_order_set_process_task,
                                                        odst_proc_tsk.id_task_type,
                                                        pk_alert_constant.g_yes)
                            END flg_ok,
                           get_task_rank(l_tasks_rank, odst_proc_tsk.id_order_set_process_task) dependency_order,
                           nvl2(odst_proc_tsk_dep.id_order_set_proc_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                           replace_dependencies_refs_rank(i_lang,
                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                           i_prof,
                                                                                           odst_proc_tsk.id_order_set_process_task,
                                                                                           odst_proc_tsk.flg_schedule,
                                                                                           l_tasks_rank,
                                                                                           l_dependency_type,
                                                                                           l_task_dependency_from,
                                                                                           l_task_dependency_to,
                                                                                           l_task_type_from,
                                                                                           l_task_type_to,
                                                                                           l_task_schedule_from,
                                                                                           l_task_schedule_to,
                                                                                           l_lag_min,
                                                                                           l_lag_max,
                                                                                           l_lag_unit_measure),
                                                          l_tasks_rank) dependency_desc,
                           odst_proc_tsk.flg_schedule,
                           get_proc_task_presel(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task) flg_task_selected,
                           get_flg_has_clin_quest(i_lang,
                                                  i_prof,
                                                  odst_proc_tsk.id_task_type,
                                                  odst_proc_tsk.id_order_set_process_task) flg_clinical_question
                      FROM order_set_process_task odst_proc_tsk
                     INNER JOIN task_type tsk_type
                        ON odst_proc_tsk.id_task_type = tsk_type.id_task_type
                    -- verify if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_process_task_depend odst_proc_tsk_dep
                        ON (odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk.id_order_set_process_task AND
                           odst_proc_tsk_dep.id_order_set_process = i_id_order_set_process AND
                           odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_proc_tsk_dep.id_order_set_proc_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process)
             ORDER BY group_type_id NULLS LAST, get_task_rank(l_tasks_rank, id_order_set_process_task);
    
        -- copy tasks rank to output array
        o_order_set_proc_tasks_rank := l_tasks_rank;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASKS',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_proc_tasks);
            RETURN FALSE;
    END get_order_set_proc_tasks;

    FUNCTION get_order_set_proc_tasks_det
    (
        i_lang                       IN language.id_language%TYPE,
        i_prof                       IN profissional,
        i_episode                    IN episode.id_episode%TYPE,
        i_id_advanced_input          IN advanced_input.id_advanced_input%TYPE,
        i_id_order_set_proc_tasks    IN table_number,
        i_flg_detail_type            IN table_varchar,
        o_fields                     OUT pk_types.cursor_type,
        o_multichoice_fields         OUT pk_types.cursor_type,
        o_fields_det                 OUT pk_types.cursor_type,
        o_fields_units               OUT pk_types.cursor_type,
        o_odst_proc_tasks_details    OUT pk_types.cursor_type,
        o_odst_proc_tasks_instr_desc OUT VARCHAR2,
        o_error                      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        error_adv_input_structure EXCEPTION;
    
        l_flg_detail_type table_varchar;
    
    BEGIN
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS TASKS DETAILS';
        -- force null of flg_detail_type parameter
        IF i_flg_detail_type IS NULL
           OR i_flg_detail_type.count = 0
        THEN
            l_flg_detail_type := NULL;
        ELSE
            l_flg_detail_type := i_flg_detail_type;
        END IF;
    
        -- get details data
        o_odst_proc_tasks_details := get_odst_proc_tasks_det_data(i_lang,
                                                                  i_prof,
                                                                  i_episode,
                                                                  i_id_order_set_proc_tasks,
                                                                  l_flg_detail_type);
    
        -- get string with the selected tasks instructions 
        o_odst_proc_tasks_instr_desc := get_task_instructions_desc(i_lang, i_prof, i_id_order_set_proc_tasks, g_yes);
    
        -- verify if it is necessary to return the advanced input structure
        IF (i_id_advanced_input IS NOT NULL)
        THEN
            g_error := 'GET CURSORS WITH ADVANCED INPUT STRUCTURE';
            pk_alertlog.log_debug(g_error, g_package_name);
        
            -- get general advanced input structure
            IF NOT (pk_advanced_input.get_all_advanced_input_data(i_lang,
                                                                  i_prof,
                                                                  i_id_advanced_input,
                                                                  o_fields,
                                                                  o_multichoice_fields,
                                                                  o_fields_det,
                                                                  o_fields_units,
                                                                  o_error))
            THEN
                RAISE error_adv_input_structure;
            END IF;
        ELSE
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error on get advanced input structure
        WHEN error_adv_input_structure THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASKS_DET',
                                              o_error);
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
            pk_types.open_my_cursor(o_odst_proc_tasks_details);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASKS_DET',
                                              o_error);
            pk_types.open_my_cursor(o_fields);
            pk_types.open_my_cursor(o_multichoice_fields);
            pk_types.open_my_cursor(o_fields_det);
            pk_types.open_my_cursor(o_fields_units);
            pk_types.open_my_cursor(o_odst_proc_tasks_details);
            RETURN FALSE;
    END get_order_set_proc_tasks_det;

    FUNCTION set_odst_proc_tasks_det_intern
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set_process        IN order_set_process.id_order_set_process%TYPE,
        i_id_order_set_proc_tasks     IN table_number,
        i_flg_value_type              IN table_table_varchar,
        i_dvalue                      IN table_table_varchar,
        i_nvalue                      IN table_table_number,
        i_vvalue                      IN table_table_varchar,
        i_flg_detail_type             IN table_table_varchar,
        i_id_advanced_input           IN table_table_number,
        i_id_advanced_input_field     IN table_table_number,
        i_id_advanced_input_field_det IN table_table_number,
        i_id_unit_measure             IN table_table_number,
        i_commit                      IN VARCHAR2,
        o_updated_tasks_instructions  OUT pk_types.cursor_type,
        o_updated_selected_tasks_info OUT pk_types.cursor_type,
        o_error                       OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'DELETE OLD ORDER SET PROCESS TASKS DETAILS';
        FOR i IN 1 .. i_id_order_set_proc_tasks.last
        LOOP
            FORALL j IN 1 .. i_flg_detail_type(i).last
                DELETE FROM order_set_process_task_det odst_proc_tsk_det
                 WHERE odst_proc_tsk_det.id_order_set_process_task = i_id_order_set_proc_tasks(i)
                   AND odst_proc_tsk_det.flg_detail_type = i_flg_detail_type(i)
                 (j)
                   AND nvl(odst_proc_tsk_det.id_advanced_input_field, -1) = nvl(i_id_advanced_input_field(i) (j), -1);
        END LOOP;
    
        g_error := 'INSERT ORDER SET PROCESS TASKS DETAILS';
        FOR i IN 1 .. i_id_order_set_proc_tasks.last
        LOOP
            FOR j IN 1 .. i_flg_detail_type(i).last
            LOOP
                IF (i_nvalue(i) (j) IS NOT NULL OR i_dvalue(i) (j) IS NOT NULL OR i_vvalue(i) (j) IS NOT NULL)
                THEN
                
                    INSERT INTO order_set_process_task_det
                        (id_order_set_process_task_det,
                         id_order_set_process_task,
                         flg_value_type,
                         nvalue,
                         dvalue,
                         vvalue,
                         flg_detail_type,
                         id_advanced_input,
                         id_advanced_input_field,
                         id_advanced_input_field_det,
                         id_unit_measure)
                    VALUES
                        (seq_order_set_process_task_det.nextval,
                         i_id_order_set_proc_tasks(i),
                         i_flg_value_type(i) (j),
                         i_nvalue(i) (j),
                         -- the following substr will truncate the timestamp to the minutes field (timestamps will always have zero seconds)
                         pk_date_utils.get_string_tstz(i_lang,
                                                       i_prof,
                                                       nvl2(i_dvalue(i) (j),
                                                            substr(i_dvalue(i) (j), 1, 12) || '00',
                                                            NULL),
                                                       NULL),
                         i_vvalue(i) (j),
                         i_flg_detail_type(i) (j),
                         i_id_advanced_input(i) (j),
                         i_id_advanced_input_field(i) (j),
                         i_id_advanced_input_field_det(i) (j),
                         i_id_unit_measure(i) (j));
                END IF;
            END LOOP;
        END LOOP;
    
        g_error := 'GET UPDATED TASKS INSTRUCTIONS';
        OPEN o_updated_tasks_instructions FOR
            SELECT order_set_proc_task.column_value id_order_set_process_task,
                   get_task_instructions_desc(i_lang, i_prof, table_number(order_set_proc_task.column_value), g_yes) instr_desc
              FROM TABLE(i_id_order_set_proc_tasks) order_set_proc_task;
    
        g_error := 'GET UPDATED INFORMATION OF THE SELECTED TASKS';
        OPEN o_updated_selected_tasks_info FOR
            SELECT id_order_set_process_task, flg_ok
              FROM (SELECT odst_proc_tsk.id_order_set_process_task,
                           check_mandatory_fields(i_lang,
                                                  i_prof,
                                                  odst_proc_tsk.id_order_set_process_task,
                                                  odst_proc_tsk.id_task_type,
                                                  g_yes) flg_ok,
                           odst_proc_tsk.id_task_type,
                           odst_proc_tsk.flg_schedule
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process_task IN
                           (SELECT /*+opt_estimate(table tsk rows=1)*/
                             column_value
                              FROM TABLE(i_id_order_set_proc_tasks) tsk));
    
        -- transaction control
        IF (i_commit = g_yes)
        THEN
            COMMIT;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        -- DML Error
        WHEN dml_errors THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / DML ERROR',
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_PROC_TASKS_DET_INTERN',
                                              o_error);
            -- transaction control
            IF (i_commit = g_yes)
            THEN
                pk_utils.undo_changes;
            END IF;
        
            pk_types.open_my_cursor(o_updated_tasks_instructions);
            pk_types.open_my_cursor(o_updated_selected_tasks_info);
        
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ODST_PROC_TASKS_DET_INTERN',
                                              o_error);
            -- transaction control
            IF (i_commit = g_yes)
            THEN
                pk_utils.undo_changes;
            END IF;
        
            pk_types.open_my_cursor(o_updated_tasks_instructions);
            pk_types.open_my_cursor(o_updated_selected_tasks_info);
        
            RETURN FALSE;
    END set_odst_proc_tasks_det_intern;

    FUNCTION set_order_set_proc_tasks_det
    (
        i_lang                        IN language.id_language%TYPE,
        i_prof                        IN profissional,
        i_id_order_set_process        IN order_set_process.id_order_set_process%TYPE,
        i_id_order_set_proc_tasks     IN table_number,
        i_flg_value_type              IN table_table_varchar,
        i_dvalue                      IN table_table_varchar,
        i_nvalue                      IN table_table_number,
        i_vvalue                      IN table_table_varchar,
        i_flg_detail_type             IN table_table_varchar,
        i_id_advanced_input           IN table_table_number,
        i_id_advanced_input_field     IN table_table_number,
        i_id_advanced_input_field_det IN table_table_number,
        i_id_unit_measure             IN table_table_number,
        o_desc_union_task_instr       OUT VARCHAR2,
        o_updated_tasks_instructions  OUT pk_types.cursor_type,
        o_updated_selected_tasks_info OUT pk_types.cursor_type,
        o_error                       OUT t_error_out
    ) RETURN BOOLEAN IS
    
        error_unexpected EXCEPTION;
    
    BEGIN
    
        g_error := 'SET ORDER SET PROCESS TASKS DETAILS';
        -- call the same function but with transaction control parameter 
        IF NOT set_odst_proc_tasks_det_intern(i_lang                        => i_lang,
                                              i_prof                        => i_prof,
                                              i_id_order_set_process        => i_id_order_set_process,
                                              i_id_order_set_proc_tasks     => i_id_order_set_proc_tasks,
                                              i_flg_value_type              => i_flg_value_type,
                                              i_dvalue                      => i_dvalue,
                                              i_nvalue                      => i_nvalue,
                                              i_vvalue                      => i_vvalue,
                                              i_flg_detail_type             => i_flg_detail_type,
                                              i_id_advanced_input           => i_id_advanced_input,
                                              i_id_advanced_input_field     => i_id_advanced_input_field,
                                              i_id_advanced_input_field_det => i_id_advanced_input_field_det,
                                              i_id_unit_measure             => i_id_unit_measure,
                                              i_commit                      => g_yes,
                                              o_updated_tasks_instructions  => o_updated_tasks_instructions,
                                              o_updated_selected_tasks_info => o_updated_selected_tasks_info,
                                              o_error                       => o_error)
        THEN
            RAISE error_unexpected;
        END IF;
    
        -- get selected tasks instructions
        o_desc_union_task_instr := get_task_instructions_desc(i_lang, i_prof, i_id_order_set_proc_tasks, g_yes);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_TASKS_DET',
                                              o_error);
            RETURN FALSE;
    END set_order_set_proc_tasks_det;

    FUNCTION set_order_set_proc_main_info
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_root_name            IN VARCHAR2,
        i_tbl_id_pk            IN table_number,
        i_tbl_data             IN table_varchar, ---
        i_tbl_ds_internal_name IN table_varchar,
        i_tbl_real_val         IN table_varchar, -- 
        i_tbl_val_clob         IN table_clob, --
        i_tbl_val_array        IN table_table_varchar DEFAULT NULL,
        i_tbl_val_array_desc   IN table_table_varchar DEFAULT NULL,
        o_id_order_set_process OUT order_set_process.id_order_set_process%TYPE,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_order_set_process order_set_process.id_order_set_process%TYPE;
    
        l_notes                  order_set_process.notes_global%TYPE;
        l_tbl_diagnosis          table_clob := table_clob();
        l_tbl_id_diagnosis       table_number := table_number();
        l_tbl_id_alert_diagnosis table_number := table_number();
        l_tbl_diagnosis_desc     table_varchar := table_varchar();
        l_diagnosis              CLOB;
        l_prof_order             order_set_process.id_prof_order%TYPE;
        l_dt_order               VARCHAR2(100 CHAR);
        l_order_type             order_set_process.id_order_type%TYPE;
    
    BEGIN
    
        g_error                := 'ERROR GETTING ID_ORDER_SET';
        l_id_order_set_process := i_tbl_id_pk(1);
    
        g_error := 'ERROR GETTING ORDER SET MAIN INFORMATION';
        FOR i IN i_tbl_ds_internal_name.first .. i_tbl_ds_internal_name.last
        LOOP
            IF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_notes
            THEN
                l_notes := i_tbl_real_val(i);
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
            THEN
                -- l_tbl_diagnosis.extend();
                l_tbl_id_diagnosis       := table_number();
                l_tbl_id_alert_diagnosis := table_number();
                l_tbl_diagnosis_desc     := table_varchar();
            
                SELECT ad.id_diagnosis, ad.id_alert_diagnosis, t_value_desc.diagnosis_desc
                  BULK COLLECT
                  INTO l_tbl_id_diagnosis, l_tbl_id_alert_diagnosis, l_tbl_diagnosis_desc
                  FROM (SELECT /*+opt_estimate(table t rows=1)*/
                         to_number(t.column_value) id_alert_diagnosis, rownum rn
                          FROM TABLE(i_tbl_val_array(i)) t) t_value
                  JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                         t.column_value diagnosis_desc, rownum rn
                          FROM TABLE(i_tbl_val_array_desc(i)) t) t_value_desc
                    ON t_value_desc.rn = t_value.rn
                  JOIN alert_diagnosis ad
                    ON ad.id_alert_diagnosis = t_value.id_alert_diagnosis;
            
                IF l_tbl_id_diagnosis.count > 0
                THEN
                    -- l_tbl_diagnosis(l_tbl_diagnosis.count) 
                    l_diagnosis := '<EPIS_DIAGNOSES ID_PATIENT="" ID_EPISODE="" PROF_CAT_TYPE="' ||
                                   pk_prof_utils.get_category(i_lang, i_prof) ||
                                   '" FLG_TYPE="P" FLG_EDIT_MODE="" ID_CDR_CALL="">
                            <EPIS_DIAGNOSIS ID_EPIS_DIAGNOSIS="" ID_EPIS_DIAGNOSIS_HIST="" FLG_TRANSF_FINAL="">
                              <CANCEL_REASON ID_CANCEL_REASON="" FLG_CANCEL_DIFF_DIAG="" /> ';
                
                    FOR k IN l_tbl_id_diagnosis.first .. l_tbl_id_diagnosis.last
                    LOOP
                        --  l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) 
                        l_diagnosis := l_diagnosis || ' <DIAGNOSIS ID_DIAGNOSIS="' || l_tbl_id_diagnosis(k) ||
                                       '" ID_ALERT_DIAG="' || l_tbl_id_alert_diagnosis(k) || '">
                                <DESC_DIAGNOSIS>' || l_tbl_diagnosis_desc(k) ||
                                       '</DESC_DIAGNOSIS>
                                <DIAGNOSIS_WARNING_REPORT>Diagnosis with no form fields.</DIAGNOSIS_WARNING_REPORT>
                              </DIAGNOSIS> ';
                    END LOOP;
                
                    --  l_tbl_diagnosis(l_tbl_diagnosis.count) := l_tbl_diagnosis(l_tbl_diagnosis.count) 
                    l_diagnosis := l_diagnosis || ' </EPIS_DIAGNOSIS>
                            <GENERAL_NOTES ID="" ID_CANCEL_REASON="" />
                          </EPIS_DIAGNOSES>';
                END IF;
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_order_type
            THEN
                l_order_type := to_number(i_tbl_real_val(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_ordered_by
            THEN
                l_prof_order := to_number(i_tbl_real_val(i));
            ELSIF i_tbl_ds_internal_name(i) = pk_orders_constant.g_ds_ordered_at
            THEN
                l_dt_order := i_tbl_real_val(i);
            END IF;
        END LOOP;
    
        g_error := 'PK_ORDER_SETS.SET_ORDER_SET_PROC_DIAGNOSES';
        IF NOT pk_order_sets.set_order_set_proc_diagnoses(i_lang                 => i_lang,
                                                          i_prof                 => i_prof,
                                                          i_patient              => i_patient,
                                                          i_episode              => i_episode,
                                                          i_id_order_set_process => l_id_order_set_process,
                                                          i_diagnoses            => l_diagnosis,
                                                          o_error                => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        g_error := 'PK_ORDER_SETS.SET_ORDER_SET_PROC_INFO_NOTES';
        IF NOT pk_order_sets.set_order_set_proc_info_notes(i_lang                 => i_lang,
                                                           i_prof                 => i_prof,
                                                           i_id_order_set_process => l_id_order_set_process,
                                                           i_notes_global         => l_notes,
                                                           i_prof_order           => l_prof_order,
                                                           i_dt_order             => l_dt_order,
                                                           i_order_type           => l_order_type,
                                                           o_error                => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        o_id_order_set_process := l_id_order_set_process;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_MAIN_INFO',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_proc_main_info;

    FUNCTION get_applied_order_set_tasks
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_patient           IN order_set_process.id_patient%TYPE,
        i_id_episode           IN order_set_process.id_episode%TYPE,
        i_search_value         IN VARCHAR2,
        o_order_set_proc_tasks OUT pk_types.cursor_type,
        dt_server              OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_set_process    table_number;
        l_tasks_rank           table_number;
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        error_refresh_status EXCEPTION;
        l_exception          EXCEPTION;
        l_error t_error_out;
    
    BEGIN
        g_error := 'REFRESH ORDER SET PROCESSES STATUS';
        -- refresh order set processes status
        IF NOT refresh_odst_procs_status(i_lang, i_prof, i_id_patient, i_id_episode, g_yes, l_error)
        THEN
            RAISE error_refresh_status;
        END IF;
    
        g_error := 'GET ORDER SET PROCESS TASKS RANK';
        -- get all order set processes for this patient
        SELECT odst_proc.id_order_set_process
          BULK COLLECT
          INTO l_order_set_process
          FROM order_set_process odst_proc
         WHERE odst_proc.id_patient = i_id_patient
           AND odst_proc.flg_status != g_order_set_proc_temp;
    
        -- get order set process dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => l_order_set_process,
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => l_order_set_process,
                                        i_flg_process          => pk_alert_constant.g_yes,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS TASKS';
        OPEN o_order_set_proc_tasks FOR
            SELECT nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                   task_group_desc,
                   task_group_tooltip,
                   task_group_rank,
                   id_order_set_process,
                   id_order_set_process_task,
                   id_task_type,
                   id_task_type_source,
                   id_task_request,
                   task_type_desc,
                   icon,
                   '<b>' || rank || ' - </b>' || task_desc task_desc,
                   '<b>' || rank || ' - </b>' || task_desc || chr(10) || task_instruct task_desc_ongoing,
                   task_title,
                   task_instruct,
                   order_set_title,
                   status,
                   flg_canceled,
                   flg_cancel,
                   dependency_order,
                   icon_dep_name,
                   id_task_dependency,
                   (SELECT get_proc_tsk_instr_bg_color(i_lang, i_prof, id_task_type, id_order_set_process_task)
                      FROM dual) instr_bg_color,
                   (SELECT get_proc_tsk_instr_bg_alpha(i_lang, i_prof, id_task_type, id_order_set_process_task)
                      FROM dual) instr_bg_alpha
              FROM (SELECT odst_proc.id_order_set_process,
                           odst_proc_tsk.id_order_set_process_task,
                           odst_proc_tsk.id_task_type,
                           (SELECT get_task_type_source(i_lang,
                                                        i_prof,
                                                        odst_proc_tsk.id_task_type,
                                                        odst_proc_tsk.id_order_set_process_task,
                                                        pk_alert_constant.g_yes,
                                                        odst_proc_tsk.flg_schedule)
                              FROM dual) id_task_type_source,
                           odst_proc_tsk.id_request id_task_request,
                           (SELECT get_odst_proc_task_group_desc(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task)
                              FROM dual) task_group_desc,
                           (SELECT get_odst_proc_tsk_grp_tooltip(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task)
                              FROM dual) task_group_tooltip,
                           (SELECT get_odst_proc_task_group_rank(i_lang, i_prof, odst_proc_tsk.id_order_set_process_task)
                              FROM dual) task_group_rank,
                           CASE
                                WHEN odst_proc_tsk.id_task_type BETWEEN 105 AND 112 THEN
                                 upper(substr((SELECT pk_translation.get_translation(i_lang,
                                                                                    'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                                    tsk_type.id_task_type_parent)
                                                FROM dual),
                                              1,
                                              1)) || substr((SELECT pk_translation.get_translation(i_lang,
                                                                                                  'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                                                  tsk_type.id_task_type_parent)
                                                              FROM dual),
                                                            2)
                                ELSE
                                 upper(substr((SELECT pk_translation.get_translation(i_lang,
                                                                                    'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                                    odst_proc_tsk.id_task_type)
                                                FROM dual),
                                              1,
                                              1)) || substr((SELECT pk_translation.get_translation(i_lang,
                                                                                                  'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                                                  odst_proc_tsk.id_task_type)
                                                              FROM dual),
                                                            2)
                            END task_type_desc,
                           (SELECT get_task_type_icon(i_lang,
                                                      i_prof,
                                                      odst_proc_tsk.id_task_type,
                                                      odst_proc_tsk.id_order_set_process_task,
                                                      pk_alert_constant.g_yes,
                                                      odst_proc_tsk.flg_schedule)
                              FROM dual) icon,
                           (SELECT get_task_desc(i_lang,
                                                 i_prof,
                                                 odst_proc_tsk.id_order_set_process_task,
                                                 odst_proc_tsk.id_task_type,
                                                 pk_alert_constant.g_yes,
                                                 pk_alert_constant.g_yes,
                                                 g_task_desc_extended_format,
                                                 pk_alert_constant.g_no,
                                                 pk_alert_constant.g_yes)
                              FROM dual) || chr(10) ||
                           replace_dependencies_refs_rank(i_lang,
                                                          (SELECT pk_tde_db.get_depend_description(i_lang,
                                                                                                   i_prof,
                                                                                                   odst_proc_tsk.id_order_set_process_task,
                                                                                                   odst_proc_tsk.flg_schedule,
                                                                                                   l_tasks_rank,
                                                                                                   l_dependency_type,
                                                                                                   l_task_dependency_from,
                                                                                                   l_task_dependency_to,
                                                                                                   l_task_type_from,
                                                                                                   l_task_type_to,
                                                                                                   l_task_schedule_from,
                                                                                                   l_task_schedule_to,
                                                                                                   l_lag_min,
                                                                                                   l_lag_max,
                                                                                                   l_lag_unit_measure)
                                                             FROM dual),
                                                          l_tasks_rank) task_desc,
                           (SELECT get_task_desc(i_lang,
                                                 i_prof,
                                                 odst_proc_tsk.id_order_set_process_task,
                                                 odst_proc_tsk.id_task_type,
                                                 pk_alert_constant.g_yes,
                                                 pk_alert_constant.g_no,
                                                 g_task_desc_short_format,
                                                 pk_alert_constant.g_no)
                              FROM dual) task_title,
                           (SELECT get_task_instructions_desc(i_lang,
                                                              i_prof,
                                                              table_number(odst_proc_tsk.id_order_set_process_task),
                                                              g_yes)
                              FROM dual) task_instruct,
                           odst.title order_set_title,
                           (SELECT get_odst_proc_task_status_str(i_lang,
                                                                 i_prof,
                                                                 i_id_patient,
                                                                 i_id_episode,
                                                                 odst_proc_tsk.id_request,
                                                                 odst_proc_tsk.id_task_type,
                                                                 odst_proc_tsk.flg_status)
                              FROM dual) status,
                           g_no flg_canceled,
                           (SELECT check_cancel_odst_proc_task(i_lang,
                                                               i_prof.id,
                                                               i_prof.institution,
                                                               i_prof.software,
                                                               i_id_episode,
                                                               odst_proc_tsk.id_order_set_process_task)
                              FROM dual) flg_cancel,
                           get_task_rank(l_tasks_rank, odst_proc_tsk.id_order_set_process_task) dependency_order,
                           nvl2(odst_proc_tsk_dep.id_order_set_proc_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                           (SELECT pk_tde_db.get_task_dependency(i_lang,
                                                                 i_prof,
                                                                 odst_proc_tsk.id_task_type,
                                                                 odst_proc_tsk.id_request)
                              FROM dual) id_task_dependency,
                           -- this code is disabled because the dependency engine functionality is not available
                           get_task_rank(l_tasks_rank, odst_proc_tsk.id_order_set_process_task) rank
                    --row_number() over(PARTITION BY odst_proc_tsk.id_order_set_process ORDER BY odst_proc_tsk.id_order_set_process_task) rank
                      FROM order_set odst
                     INNER JOIN order_set_process odst_proc
                        ON (odst.id_order_set = odst_proc.id_order_set)
                     INNER JOIN order_set_process_task odst_proc_tsk
                        ON (odst_proc.id_order_set_process = odst_proc_tsk.id_order_set_process)
                     INNER JOIN task_type tsk_type
                        ON (odst_proc_tsk.id_task_type = tsk_type.id_task_type)
                      LEFT JOIN analysis_req_det ard
                        ON ard.id_analysis_req_det = odst_proc_tsk.id_request
                       AND odst_proc_tsk.id_task_type = 11
                    -- verify if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_process_task_depend odst_proc_tsk_dep
                        ON (odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk.id_order_set_process_task AND
                           odst_proc_tsk_dep.id_order_set_process = odst_proc.id_order_set_process AND
                           odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_proc_tsk_dep.id_order_set_proc_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_proc.id_patient = i_id_patient
                       AND pk_episode.get_id_visit(i_id_episode) = pk_episode.get_id_visit(odst_proc.id_episode)
                       AND odst_proc.flg_status != g_order_set_proc_temp
                       AND odst_proc_tsk.flg_status != g_order_set_proc_tsk_temp
                       AND odst_proc_tsk.flg_discard_type = g_task_not_discard
                       AND ((odst_proc_tsk.id_task_type = pk_alert_constant.g_task_lab_tests AND
                           (SELECT pk_lab_tests_api_db.get_lab_test_access_permission(i_lang, i_prof, ard.id_analysis)
                                FROM dual) = pk_alert_constant.g_yes) OR
                           (odst_proc_tsk.id_task_type <> pk_alert_constant.g_task_lab_tests)))
             WHERE
            -- search for value
             (i_search_value IS NULL OR
             (translate(upper(task_desc || ' ' || task_instruct || ' ' || task_group_desc || ' ' || order_set_title),
                         '',
                         'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
             '%' || translate(upper(i_search_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%' AND
             i_search_value IS NOT NULL))
             ORDER BY group_type_id NULLS LAST, rank, task_desc;
    
        -- return server time as close as possible to the end of function
        dt_server := pk_date_utils.date_send_tsz(i_lang, current_timestamp, i_prof);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Error on refresh order set processes status
        WHEN error_refresh_status THEN
            pk_alert_exceptions.process_error(i_lang,
                                              NULL,
                                              NULL,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_APPLIED_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_order_set_proc_tasks);
            RETURN FALSE;
            -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error || ' / ' || l_error.err_desc,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_APPLIED_ORDER_SET_TASKS',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_order_set_proc_tasks);
            RETURN FALSE;
    END get_applied_order_set_tasks;

    FUNCTION get_applied_order_sets
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_patient            IN order_set_process.id_patient%TYPE,
        i_id_episode            IN order_set_process.id_episode%TYPE,
        i_search_value          IN VARCHAR2,
        o_order_set_procs       OUT pk_types.cursor_type,
        o_order_set_procs_tasks OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESSES';
        OPEN o_order_set_procs FOR
            SELECT id_order_set_process,
                   order_set_title,
                   request_author_desc,
                   request_date,
                   status,
                   flg_canceled,
                   flg_cancel,
                   flg_status
              FROM (SELECT odst_proc.id_order_set_process,
                           odst.title order_set_title,
                           pk_prof_utils.get_name_signature(i_lang,
                                                            i_prof,
                                                            nvl(odst_proc.id_prof_order, prof.id_professional)) request_author_desc, -- signature
                           pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_order_set_process_tstz, i_prof) request_date,
                           pk_utils.get_status_string_immediate(i_lang,
                                                                i_prof,
                                                                pk_alert_constant.g_display_type_icon,
                                                                odst_proc.flg_status,
                                                                NULL,
                                                                NULL,
                                                                g_odst_tsk_flg_status_domain) status,
                           decode(odst_proc.flg_status, g_order_set_proc_canceled, g_yes, g_no) flg_canceled,
                           decode(odst_proc.flg_status,
                                  g_order_set_proc_running,
                                  decode(check_cancel_order_set_proc(i_lang,
                                                                     i_prof,
                                                                     i_id_episode,
                                                                     odst_proc.id_order_set_process),
                                         g_available,
                                         g_yes,
                                         g_no),
                                  g_no) flg_cancel,
                           odst_proc.flg_status flg_status
                      FROM order_set odst, order_set_process odst_proc, professional prof
                     WHERE odst_proc.id_patient = i_id_patient
                       AND pk_episode.get_id_visit(i_id_episode) = pk_episode.get_id_visit(odst_proc.id_episode)
                       AND odst.id_order_set = odst_proc.id_order_set
                       AND odst_proc.id_prof_request = prof.id_professional
                       AND odst_proc.flg_status != g_order_set_proc_temp)
             WHERE
            -- search for value
             (i_search_value IS NULL OR
             (translate(upper(order_set_title || ' ' || request_author_desc),
                         '',
                         'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
             '%' || translate(upper(i_search_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%' AND
             i_search_value IS NOT NULL))
             ORDER BY pk_sysdomain.get_rank(i_lang, g_odst_tsk_flg_status_domain, flg_status),
                      request_date,
                      upper(order_set_title),
                      request_author_desc;
    
        g_error := 'get cursor with all tasks from all order set processes';
        OPEN o_order_set_procs_tasks FOR
            SELECT odst_proc.id_order_set_process,
                   odst_proc_tsk.id_order_set_process_task,
                   odst_proc_tsk.id_task_type,
                   odst_proc_tsk.id_request id_task_request,
                   upper(substr(pk_translation.get_translation(i_lang,
                                                               'TASK_TYPE.CODE_TASK_TYPE.' || odst_proc_tsk.id_task_type),
                                1,
                                1)) ||
                   substr(pk_translation.get_translation(i_lang,
                                                         'TASK_TYPE.CODE_TASK_TYPE.' || odst_proc_tsk.id_task_type),
                          2) task_type_desc,
                   get_task_desc(i_lang,
                                 i_prof,
                                 odst_proc_tsk.id_order_set_process_task,
                                 odst_proc_tsk.id_task_type,
                                 pk_alert_constant.g_yes,
                                 odst_proc_tsk.flg_schedule,
                                 g_task_desc_detail_format,
                                 pk_alert_constant.g_no) task_desc
              FROM order_set_process odst_proc
             INNER JOIN order_set_process_task odst_proc_tsk
                ON (odst_proc.id_order_set_process = odst_proc_tsk.id_order_set_process)
             WHERE odst_proc.id_patient = i_id_patient
               AND pk_episode.get_id_visit(i_id_episode) = pk_episode.get_id_visit(odst_proc.id_episode)
               AND odst_proc.flg_status != g_order_set_proc_temp
               AND odst_proc_tsk.flg_status != g_order_set_proc_tsk_temp
               AND odst_proc_tsk.flg_discard_type = g_task_not_discard
             ORDER BY upper(task_type_desc), upper(task_desc);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_APPLIED_ORDER_SETS',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_procs);
            pk_types.open_my_cursor(o_order_set_procs_tasks);
            RETURN FALSE;
    END get_applied_order_sets;

    FUNCTION get_order_set_details
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        o_order_set_proc_info  OUT pk_types.cursor_type,
        o_order_set_proc_tasks OUT pk_types.cursor_type,
        o_order_set_orig_info  OUT pk_types.cursor_type,
        o_order_set_orig_tasks OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        CURSOR c_odst_environment(in_id_order_set order_set_link.id_order_set%TYPE) IS
            SELECT pk_translation.get_translation(i_lang, 'DEPT.CODE_DEPT.' || odst_lnk.id_link) environment_desc
              FROM order_set_link odst_lnk
             WHERE odst_lnk.id_order_set = in_id_order_set
               AND odst_lnk.flg_link_type = g_order_set_link_envi
             ORDER BY environment_desc;
    
        CURSOR c_chief_complaints(in_id_order_set order_set_link.id_order_set%TYPE) IS
            SELECT pk_translation.get_translation(i_lang, 'COMPLAINT.CODE_COMPLAINT.' || ost_lnk.id_link) chief_complaint_desc
              FROM order_set_link ost_lnk
             WHERE ost_lnk.id_order_set = in_id_order_set
               AND ost_lnk.flg_link_type = g_order_set_link_chief_compl
             ORDER BY chief_complaint_desc;
    
        CURSOR c_reason_visit(in_id_order_set order_set_link.id_order_set%TYPE) IS
            SELECT pk_translation.get_translation(i_lang, 'COMPLAINT.CODE_COMPLAINT.' || ost_lnk.id_link) reason_for_visit_desc
              FROM order_set_link ost_lnk
             WHERE ost_lnk.id_order_set = in_id_order_set
               AND ost_lnk.flg_link_type = g_order_set_link_reason_visit
             ORDER BY reason_for_visit_desc;
    
        CURSOR c_order_set_types(in_id_order_set order_set_link.id_order_set%TYPE) IS
            SELECT pk_sys_list.get_sys_list_value_desc(i_lang, i_prof, ost_lnk.id_link) order_set_type_desc
              FROM order_set_link ost_lnk
             WHERE ost_lnk.flg_link_type = g_order_set_link_odst_type
               AND ost_lnk.id_order_set = in_id_order_set
             ORDER BY order_set_type_desc;
    
        ibt_environment_desc  table_varchar;
        ibt_chief_compl_desc  table_varchar;
        ibt_reason_visit_desc table_varchar;
        l_order_set_type_desc table_varchar;
        l_count_order_types   NUMBER;
        l_orig_diagnosis_desc table_varchar;
        l_proc_diagnosis_desc table_varchar;
    
        l_id_order_set              order_set.id_order_set%TYPE;
        l_proc_clinical_indications CLOB;
        l_clinical_indications      CLOB;
        l_rec_orig_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
        l_rec_proc_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
    BEGIN
    
        g_error := 'GET ORDER SET ID';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- get ID of the order set associated to the order set process and its clinical indications
        SELECT id_order_set, clinical_indications
          INTO l_id_order_set, l_proc_clinical_indications
          FROM order_set_process
         WHERE id_order_set_process = i_id_order_set_process;
    
        -- get order set clinical indications/diagnoses
        SELECT os.clinical_indications
          INTO l_clinical_indications
          FROM order_set os
         WHERE os.id_order_set = l_id_order_set;
    
        -- get all clinical indications/diagnoses descriptions of the process order set
        IF (l_proc_clinical_indications IS NOT NULL)
        THEN
            -- get diagnosis records
            l_rec_proc_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                              i_prof   => i_prof,
                                                              i_params => l_proc_clinical_indications);
        
            l_proc_diagnosis_desc := table_varchar();
            l_proc_diagnosis_desc.extend(l_rec_proc_diagnoses.tbl_diagnosis.count);
        
            -- get description of each diagnosis record
            FOR i IN 1 .. l_rec_proc_diagnoses.tbl_diagnosis.count
            LOOP
                l_proc_diagnosis_desc(i) := pk_diagnosis.get_diag_desc(i_lang,
                                                                       i_prof,
                                                                       l_rec_proc_diagnoses.tbl_diagnosis(i));
            END LOOP;
        ELSE
            l_proc_diagnosis_desc := table_varchar();
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS INFORMATION';
        OPEN o_order_set_proc_info FOR
            SELECT request_author_desc,
                   request_date,
                   notes_global,
                   nvl2(request_author_spec, '(' || request_author_spec || ')', NULL) request_author_spec,
                   prof_cancel,
                   cancel_notes,
                   cancel_date,
                   nvl2(cancel_prof_spec, '(' || cancel_prof_spec || ')', NULL) cancel_prof_spec,
                   nvl2(id_cancel_reason,
                        pk_translation.get_translation(i_lang, 'CANCEL_REASON.CODE_CANCEL_REASON.' || id_cancel_reason),
                        NULL) cancel_reason,
                   pk_utils.concat_table(l_proc_diagnosis_desc, g_separator) diagnoses_desc
              FROM (SELECT pk_prof_utils.get_name_signature(i_lang, i_prof, prof.id_professional) request_author_desc,
                           pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_order_set_process_tstz, i_prof) request_date,
                           odst_proc.notes_global,
                           pk_prof_utils.get_prof_speciality(i_lang,
                                                             profissional(odst_proc.id_prof_request,
                                                                          i_prof.institution,
                                                                          i_prof.software)) request_author_spec,
                           decode(odst_proc.flg_status,
                                  g_order_set_proc_canceled,
                                  pk_prof_utils.get_name_signature(i_lang, i_prof, odst_proc.id_professional),
                                  g_order_set_proc_interrupted,
                                  pk_prof_utils.get_name_signature(i_lang, i_prof, odst_proc.id_professional),
                                  NULL) prof_cancel,
                           odst_proc.cancel_notes,
                           decode(odst_proc.flg_status,
                                  g_order_set_proc_canceled,
                                  pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_status_tstz, i_prof),
                                  g_order_set_proc_interrupted,
                                  pk_date_utils.date_send_tsz(i_lang, odst_proc.dt_status_tstz, i_prof),
                                  NULL) cancel_date,
                           decode(odst_proc.flg_status,
                                  g_order_set_proc_canceled,
                                  pk_prof_utils.get_prof_speciality(i_lang,
                                                                    profissional(odst_proc.id_professional,
                                                                                 i_prof.institution,
                                                                                 i_prof.software)),
                                  NULL) cancel_prof_spec,
                           odst_proc.id_cancel_reason
                      FROM order_set odst
                     INNER JOIN order_set_process odst_proc
                        ON (odst.id_order_set = odst_proc.id_order_set)
                     INNER JOIN professional prof
                        ON (odst_proc.id_prof_request = prof.id_professional)
                      LEFT OUTER JOIN order_type ot
                        ON (odst_proc.id_order_type = ot.id_order_type)
                     WHERE odst_proc.id_order_set_process = i_id_order_set_process);
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS TASKS';
        OPEN o_order_set_proc_tasks FOR
            SELECT id_task_type,
                   get_proc_tasks_desc_by_type(i_lang, i_prof, i_id_order_set_process, id_task_type) tasks_desc
              FROM (SELECT (CASE
                                WHEN odst_proc_tsk.id_task_type IN
                                     (g_odst_task_appoint_social,
                                      g_odst_task_appoint_nurse,
                                      g_odst_task_appoint_medical,
                                      g_odst_task_appoint_nutrition,
                                      g_odst_task_appoint_psychology,
                                      g_odst_task_appoint_rehabilit,
                                      g_odst_task_inpatient,
                                      g_odst_task_inp_surg,
                                      g_odst_task_inpatient_ptbr,
                                      g_odst_task_inp_surg_ptbr) THEN
                                 g_odst_task_group_episodes
                                ELSE
                                 odst_proc_tsk.id_task_type
                            END) id_task_type
                      FROM order_set_process_task odst_proc_tsk
                     WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process
                       AND odst_proc_tsk.flg_discard_type = g_task_not_discard)
             GROUP BY id_task_type
             ORDER BY get_task_type_rank(i_lang, i_prof, id_task_type), id_task_type;
    
        g_error := 'GET CURSOR WITH ORIGINAL ORDER SET INFORMATION';
        -- get all environments descriptions of the original order set
        OPEN c_odst_environment(l_id_order_set);
        FETCH c_odst_environment BULK COLLECT
            INTO ibt_environment_desc;
        CLOSE c_odst_environment;
    
        -- get all chief complaint descriptions of the original order set
        OPEN c_chief_complaints(l_id_order_set);
        FETCH c_chief_complaints BULK COLLECT
            INTO ibt_chief_compl_desc;
        CLOSE c_chief_complaints;
    
        -- get all reasons for visit descriptions of the original order set
        OPEN c_reason_visit(l_id_order_set);
        FETCH c_reason_visit BULK COLLECT
            INTO ibt_reason_visit_desc;
        CLOSE c_reason_visit;
    
        -- get all order set types descriptions of the original order set
        OPEN c_order_set_types(l_id_order_set);
        FETCH c_order_set_types BULK COLLECT
            INTO l_order_set_type_desc;
        CLOSE c_order_set_types;
    
        -- count order set types
        l_count_order_types := l_order_set_type_desc.count;
    
        -- get all clinical indications/diagnoses descriptions of the original order set
        IF l_clinical_indications IS NOT NULL
        THEN
            -- get diagnosis records
            l_rec_orig_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                              i_prof   => i_prof,
                                                              i_params => l_clinical_indications);
        
            l_orig_diagnosis_desc := table_varchar();
            l_orig_diagnosis_desc.extend(l_rec_orig_diagnoses.tbl_diagnosis.count);
        
            -- get description of each diagnosis record
            FOR i IN 1 .. l_rec_orig_diagnoses.tbl_diagnosis.count
            LOOP
                l_orig_diagnosis_desc(i) := pk_diagnosis.get_diag_desc(i_lang,
                                                                       i_prof,
                                                                       l_rec_orig_diagnoses.tbl_diagnosis(i));
            END LOOP;
        ELSE
            l_orig_diagnosis_desc := table_varchar();
        END IF;
    
        OPEN o_order_set_orig_info FOR
            SELECT odst.title order_set_title,
                   nvl(pk_prof_utils.get_name_signature(i_lang, i_prof, prof.id_professional),
                       pk_message.get_message(i_lang, g_message_na)) author,
                   pk_utils.concat_table(ibt_environment_desc, g_separator) environment_desc,
                   nvl(pk_prof_utils.get_prof_speciality(i_lang,
                                                         profissional(prof.id_professional,
                                                                      odst.id_institution,
                                                                      odst.id_software)),
                       pk_message.get_message(i_lang, g_message_na)) speciality_desc,
                   pk_sysdomain.get_domain(g_odst_target_profs_domain, odst.flg_target_professionals, i_lang) target_professionals,
                   pk_sysdomain.get_domain(g_odst_edit_perms_domain, odst.flg_edit_permissions, i_lang) edit_permissions,
                   pk_date_utils.date_send_tsz(i_lang, odst.dt_order_set_tstz, i_prof) creation_date,
                   odst.notes_global,
                   pk_utils.concat_table(ibt_chief_compl_desc, g_separator) chief_complaint_desc,
                   pk_utils.concat_table(ibt_reason_visit_desc, g_separator) reason_for_visit_desc,
                   pk_utils.concat_table(l_orig_diagnosis_desc, g_separator) diagnoses_desc,
                   decode(l_count_order_types, 0, '---', pk_utils.concat_table(l_order_set_type_desc, g_separator)) order_set_type_desc
              FROM ((order_set odst LEFT OUTER JOIN professional prof ON odst.id_professional = prof.id_professional) LEFT
                    OUTER JOIN order_set_link odst_lnk_spec ON odst_lnk_spec.id_order_set = odst.id_order_set AND
                    odst_lnk_spec.flg_link_type = g_order_set_link_spec)
             WHERE odst.id_order_set = l_id_order_set;
    
        g_error := 'GET CURSOR WITH ORDER SET PROCESS TASKS';
        OPEN o_order_set_orig_tasks FOR
            SELECT id_task_type, get_tasks_desc_by_type(i_lang, i_prof, l_id_order_set, id_task_type) tasks_desc
              FROM (SELECT (CASE
                                WHEN odst_tsk.id_task_type IN (g_odst_task_appoint_social,
                                                               g_odst_task_appoint_nurse,
                                                               g_odst_task_appoint_medical,
                                                               g_odst_task_appoint_nutrition,
                                                               g_odst_task_appoint_psychology,
                                                               g_odst_task_appoint_rehabilit,
                                                               g_odst_task_inpatient,
                                                               g_odst_task_inp_surg,
                                                               g_odst_task_inpatient_ptbr,
                                                               g_odst_task_inp_surg_ptbr) THEN
                                 g_odst_task_group_episodes
                                ELSE
                                 odst_tsk.id_task_type
                            END) id_task_type
                      FROM order_set_task odst_tsk
                     WHERE odst_tsk.id_order_set = l_id_order_set)
             GROUP BY id_task_type
             ORDER BY get_task_type_rank(i_lang, i_prof, id_task_type), id_task_type;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_DETAILS',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_proc_info);
            pk_types.open_my_cursor(o_order_set_proc_tasks);
            pk_types.open_my_cursor(o_order_set_orig_info);
            pk_types.open_my_cursor(o_order_set_orig_tasks);
            RETURN FALSE;
    END get_order_set_details;

    FUNCTION get_task_type_parent
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_task_type IN order_set_task_soft_inst.id_task_type%TYPE
    ) RETURN order_set_task_soft_inst.id_task_type_parent%TYPE IS
    
        l_market              market.id_market%TYPE := pk_utils.get_institution_market(i_lang, i_prof.institution);
        l_id_task_type_parent order_set_task_soft_inst.id_task_type_parent%TYPE;
    
    BEGIN
    
        g_error := 'get task type parent id';
        BEGIN
            SELECT id_task_type_parent
              INTO l_id_task_type_parent
              FROM (SELECT id_task_type_parent
                      FROM (SELECT ost_task_si.id_task_type_parent,
                                   first_value(ost_task_si.flg_available) over(PARTITION BY ost_task_si.id_task_type_parent ORDER BY id_market DESC, id_institution DESC, id_software DESC) flg_available
                              FROM order_set_task_soft_inst ost_task_si
                             WHERE ost_task_si.id_software IN (g_all_software, i_prof.software)
                               AND ost_task_si.id_institution IN (g_all_institution, i_prof.institution)
                               AND ost_task_si.id_market IN (g_all_markets, l_market)
                               AND ost_task_si.id_task_type = i_id_task_type)
                     WHERE flg_available = pk_alert_constant.g_yes)
             WHERE rownum = 1;
        
        EXCEPTION
            -- if no data found, then assume that task doesn't have any parent
            WHEN no_data_found THEN
                RETURN NULL;
        END;
    
        RETURN l_id_task_type_parent;
    
    END get_task_type_parent;

    FUNCTION get_complaint_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        i_value        IN VARCHAR2,
        o_complaints   OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_id_complaints   table_number;
        l_desc_complaints table_varchar;
        l_tbl             t_tbl_order_set_complaints := t_tbl_order_set_complaints();
        l_complaints      pk_types.cursor_type;
    
        l_exception EXCEPTION;
    
    BEGIN
        -- get all complaints that can be used in this (i_prof) hospital group
        IF NOT pk_complaint.get_all_complaints_list(i_lang       => i_lang,
                                                    i_prof       => i_prof,
                                                    o_complaints => l_complaints,
                                                    o_error      => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- o_complaints already open
        FETCH l_complaints BULK COLLECT
            INTO l_id_complaints, l_desc_complaints;
        CLOSE l_complaints;
    
        -- loop for all complaints to build t_tbl_guideline_complaints array
        FOR i IN 1 .. l_id_complaints.count
        LOOP
            l_tbl.extend;
            l_tbl(l_tbl.count) := t_rec_order_set_complaints(l_id_complaints(i), l_desc_complaints(i));
        END LOOP;
    
        -- open cursor o_complaints
        OPEN o_complaints FOR
            SELECT /*+opt_estimate(table c rows=1)*/
             c.id_complaint, c.desc_complaint, nvl2(osl.id_link, g_active, g_inactive) flg_select
              FROM TABLE(CAST(l_tbl AS t_tbl_order_set_complaints)) c
              LEFT JOIN order_set_link osl
                ON c.id_complaint = osl.id_link
               AND osl.flg_link_type = g_order_set_link_chief_compl
               AND osl.id_order_set = i_id_order_set
             WHERE i_value IS NULL
                OR (i_value IS NOT NULL AND
                   (translate(upper(c.desc_complaint), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%'))
             ORDER BY upper(c.desc_complaint);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_COMPLAINT_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_complaints);
            RETURN FALSE;
        
    END get_complaint_list;

    FUNCTION get_reasons_for_visit
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_reasons      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        -- open cursor o_reasons              
        OPEN o_reasons FOR
            SELECT c.id_complaint id_reason_for_visit,
                   pk_translation.get_translation(i_lang, c.code_complaint) reason_for_visit_desc
              FROM complaint c
              JOIN order_set_link osl
                ON osl.id_link = c.id_complaint
             WHERE osl.flg_link_type = g_order_set_link_reason_visit
               AND osl.id_order_set = i_id_order_set
             ORDER BY upper(reason_for_visit_desc);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_REASONS_FOR_VISIT',
                                              o_error);
            pk_types.open_my_cursor(o_reasons);
            RETURN FALSE;
        
    END get_reasons_for_visit;

    FUNCTION get_diagnoses_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_diagnoses    OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
        l_tbl_diagnoses        t_table_diagnoses;
    
    BEGIN
    
        -- get order set clinical indications/diagnoses descriptions
        SELECT os.clinical_indications
          INTO l_clinical_indications
          FROM order_set os
         WHERE os.id_order_set = i_id_order_set;
    
        -- get diagnosis records
        l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                     i_prof   => i_prof,
                                                     i_params => l_clinical_indications);
    
        -- convert 'pk_edis_types.rec_in_epis_diagnosis' type to 't_table_diagnoses'
        l_tbl_diagnoses := pk_diagnosis.tf_diagnosis(l_rec_diagnoses);
    
        -- open cursor o_diagnoses
        OPEN o_diagnoses FOR
            SELECT rec_diag.id_diagnosis,
                   rec_diag.id_alert_diagnosis,
                   pk_diagnosis.get_diag_desc(i_lang, i_prof, rec_diag.id_diagnosis, rec_diag.id_alert_diagnosis) desc_diagnosis
              FROM TABLE(l_tbl_diagnoses) rec_diag
             ORDER BY desc_diagnosis;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_DIAGNOSES_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_diagnoses);
            RETURN FALSE;
        
    END get_diagnoses_list;

    FUNCTION get_proc_diagnoses_list
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_id_patient           IN patient.id_patient%TYPE,
        i_id_episode           IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set%TYPE,
        o_diagnoses            OUT pk_types.cursor_type,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
        l_tbl_diagnoses        t_table_diagnoses;
        l_tbl_epis_diagnoses   t_coll_episode_diagnosis := t_coll_episode_diagnosis();
    
        l_id_epis_diagnosis  epis_diagnosis.id_epis_diagnosis%TYPE;
        l_id_diagnosis       diagnosis.id_diagnosis%TYPE;
        l_id_alert_diagnosis alert_diagnosis.id_alert_diagnosis%TYPE;
        l_code_icd           diagnosis.code_icd%TYPE;
        l_desc_diagnosis     pk_translation.t_desc_translation;
        l_rank               NUMBER;
        l_epis_diag_count    NUMBER;
        l_flg_other          VARCHAR2(1 CHAR);
    
        c_data pk_types.cursor_type;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- get order set process clinical indications/diagnoses descriptions
        BEGIN
            SELECT osp.clinical_indications
              INTO l_clinical_indications
              FROM order_set_process osp
             WHERE osp.id_order_set_process = i_id_order_set_process;
        EXCEPTION
            WHEN no_data_found THEN
                RETURN NULL;
        END;
    
        -- get diagnosis records
        l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                     i_prof   => i_prof,
                                                     i_params => l_clinical_indications);
    
        -- convert 'pk_edis_types.rec_in_epis_diagnosis' type to 't_table_diagnoses'
        l_tbl_diagnoses := pk_diagnosis.tf_diagnosis(l_rec_diagnoses);
    
        -- get episode diagnoses
        IF NOT get_order_set_epis_diagnoses(i_lang       => i_lang,
                                            i_prof       => i_prof,
                                            i_id_patient => i_id_patient,
                                            i_id_episode => i_id_episode,
                                            o_epis_diags => c_data,
                                            o_error      => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get episode diagnoses
        l_epis_diag_count := 0;
    
        LOOP
            FETCH c_data
                INTO l_id_epis_diagnosis,
                     l_id_diagnosis,
                     l_id_alert_diagnosis,
                     l_code_icd,
                     l_desc_diagnosis,
                     l_rank,
                     l_flg_other;
        
            EXIT WHEN c_data%NOTFOUND;
        
            l_tbl_epis_diagnoses.extend;
            l_epis_diag_count := l_epis_diag_count + 1;
            l_tbl_epis_diagnoses(l_epis_diag_count) := t_rec_episode_diagnosis(id_epis_diagnosis     => l_id_epis_diagnosis,
                                                                               id_diagnosis          => l_id_diagnosis,
                                                                               id_alert_diagnosis    => l_id_alert_diagnosis,
                                                                               desc_diagnosis        => l_desc_diagnosis,
                                                                               dt_initial_diag       => NULL,
                                                                               dt_initial_diag_chr   => NULL,
                                                                               flg_status            => NULL,
                                                                               desc_status           => NULL,
                                                                               dt_epis_diagnosis     => NULL,
                                                                               dt_epis_diagnosis_chr => NULL,
                                                                               id_prof_diagnosis     => NULL,
                                                                               name_prof_diag        => NULL,
                                                                               spec_prof_diag        => NULL,
                                                                               flg_type              => NULL,
                                                                               flg_previous          => NULL,
                                                                               notes                 => NULL,
                                                                               flg_other             => l_flg_other,
                                                                               id_content            => NULL,
                                                                               rank                  => l_rank,
                                                                               id_episode            => NULL);
        
        END LOOP;
        CLOSE c_data;
    
        -- open cursor o_diagnoses
        OPEN o_diagnoses FOR
            SELECT nvl(rec_epis_diag.id_diagnosis, rec_diag.id_diagnosis) id_diagnosis,
                   nvl(rec_epis_diag.id_alert_diagnosis, rec_diag.id_alert_diagnosis) id_alert_diagnosis,
                   nvl(rec_epis_diag.desc_diagnosis,
                       pk_diagnosis.get_diag_desc(i_lang, i_prof, rec_diag.id_diagnosis, rec_diag.id_alert_diagnosis)) desc_diagnosis,
                   nvl2(rec_diag.id_diagnosis, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_select
              FROM TABLE(l_tbl_epis_diagnoses) rec_epis_diag
              FULL OUTER JOIN TABLE(l_tbl_diagnoses) rec_diag
                ON (rec_epis_diag.id_diagnosis = rec_diag.id_diagnosis AND
                   rec_epis_diag.id_alert_diagnosis = rec_diag.id_alert_diagnosis)
             ORDER BY nvl(rec_epis_diag.rank, 0), desc_diagnosis;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROC_DIAGNOSES_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_diagnoses);
            RETURN FALSE;
        
    END get_proc_diagnoses_list;

    FUNCTION get_order_set_filters
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_patient    IN patient.id_patient%TYPE,
        i_episode    IN episode.id_episode%TYPE,
        o_filters    OUT pk_types.cursor_type,
        o_order_sets OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_sets_tab      t_tbl_odst_frequent := t_tbl_odst_frequent();
        l_order_sets_tab_diag t_tbl_odst_frequent := t_tbl_odst_frequent();
    
        l_id_complaint          table_number;
        l_has_complaint_results VARCHAR2(1 CHAR);
        l_has_diagnosis_results VARCHAR2(1 CHAR);
        l_has_results           VARCHAR2(1 CHAR);
    
        l_exception EXCEPTION;
    
    BEGIN
    
        -- chief complaints filter is only active if patient has an associated active chief complaint
        g_error := 'CALL PK_COMPLAINT.GET_EPIS_ACT_COMPLAINT';
        IF NOT pk_complaint.get_epis_act_complaint(i_lang         => i_lang,
                                                   i_prof         => i_prof,
                                                   i_episode      => i_episode,
                                                   o_id_complaint => l_id_complaint,
                                                   o_error        => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- check if there are order sets for this chief complaint
        IF l_id_complaint IS NOT NULL
           AND l_id_complaint.count > 0
        THEN
        
            g_error          := 'Call get_odst_frequent_search_int / ' || g_order_set_filter_chief_compl;
            l_order_sets_tab := get_odst_frequent_search_int(i_lang       => i_lang,
                                                             i_prof       => i_prof,
                                                             i_id_patient => i_patient,
                                                             i_id_episode => i_episode,
                                                             i_flg_filter => g_order_set_filter_chief_compl,
                                                             i_value      => NULL);
        
            IF l_order_sets_tab IS NOT NULL
               AND l_order_sets_tab.count > 0
            THEN
                l_has_complaint_results := pk_alert_constant.g_yes;
            ELSE
                l_has_complaint_results := pk_alert_constant.g_no;
            END IF;
        
        ELSE
            l_has_complaint_results := pk_alert_constant.g_no;
        END IF;
    
        g_error := 'GET DIAGNOSES FOR EPISODE';
        BEGIN
            SELECT /*+opt_estimate (table t rows=1)*/
             g_yes
              INTO l_has_diagnosis_results
              FROM TABLE(pk_diagnosis.get_associated_diagnosis_tf(i_lang, i_prof, i_episode)) t
             WHERE rownum = 1;
        
            g_error               := 'Call get_odst_frequent_search_int / ' || g_order_set_filter_chief_compl;
            l_order_sets_tab_diag := get_odst_frequent_search_int(i_lang       => i_lang,
                                                                  i_prof       => i_prof,
                                                                  i_id_patient => i_patient,
                                                                  i_id_episode => i_episode,
                                                                  i_flg_filter => g_order_set_filter_diagnosis,
                                                                  i_value      => NULL);
        
            IF l_order_sets_tab_diag IS NOT NULL
               AND l_order_sets_tab_diag.count > 0
            THEN
                l_has_diagnosis_results := pk_alert_constant.g_yes;
            ELSE
                l_has_diagnosis_results := pk_alert_constant.g_no;
            END IF;
        EXCEPTION
            WHEN no_data_found THEN
                l_has_diagnosis_results := g_no;
        END;
    
        -- if there are no results for this chief complaint or diagnoses,
        -- check if there are order sets for this software and institution
        IF l_has_complaint_results = pk_alert_constant.g_no
           AND l_has_diagnosis_results = pk_alert_constant.g_no
        THEN
        
            g_error          := 'Call get_odst_frequent_search_int / ' || g_order_set_filter_frequent;
            l_order_sets_tab := get_odst_frequent_search_int(i_lang       => i_lang,
                                                             i_prof       => i_prof,
                                                             i_id_patient => i_patient,
                                                             i_id_episode => i_episode,
                                                             i_flg_filter => g_order_set_filter_frequent,
                                                             i_value      => NULL);
            IF l_order_sets_tab IS NOT NULL
            THEN
                IF l_order_sets_tab.count = 0
                THEN
                    l_has_results := pk_alert_constant.g_no;
                ELSE
                    l_has_results := pk_alert_constant.g_yes;
                END IF;
            END IF;
        ELSE
            l_has_results := pk_alert_constant.g_yes;
        END IF;
    
        g_error := 'GET O_FILTERS CURSOR';
        OPEN o_filters FOR
            SELECT sd.val id_action,
                   (CASE
                        WHEN sd.val IN (g_order_set_filter_odst_mng,
                                        g_order_set_filter_odst_prv,
                                        g_order_set_filter_odst_scr,
                                        g_order_set_filter_odst_trt) THEN
                         g_order_set_filter_odst_type
                        ELSE
                         NULL
                    END) id_parent,
                   1 "LEVEL",
                   NULL to_state,
                   (CASE
                        WHEN i_prof.software IN
                             (pk_alert_constant.g_soft_outpatient, pk_alert_constant.g_soft_primary_care)
                             AND sd.val = g_order_set_filter_chief_compl THEN
                         pk_message.get_message(i_lang, g_message_reason_for_visit)
                        ELSE
                         sd.desc_val
                    END) desc_action,
                   sd.img_name icon,
                   decode(sd.val,
                           g_order_set_filter_chief_compl,
                           (CASE
                               WHEN l_has_complaint_results = pk_alert_constant.g_yes THEN
                                pk_alert_constant.g_yes
                               ELSE
                                pk_alert_constant.g_no
                           END),
                           g_order_set_filter_diagnosis,
                           (CASE
                               WHEN l_has_complaint_results = pk_alert_constant.g_no
                                    AND l_has_diagnosis_results = pk_alert_constant.g_yes THEN
                                pk_alert_constant.g_yes
                               ELSE
                                pk_alert_constant.g_no
                           END),
                           g_order_set_filter_frequent,
                           (CASE
                               WHEN l_has_complaint_results = pk_alert_constant.g_no
                                    AND l_has_diagnosis_results = pk_alert_constant.g_no
                                    AND l_has_results = pk_alert_constant.g_yes THEN
                                pk_alert_constant.g_yes
                               ELSE
                                pk_alert_constant.g_no
                           END),
                           pk_alert_constant.g_no) flg_default,
                   decode(sd.val,
                          g_order_set_filter_chief_compl,
                          decode(l_has_complaint_results,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_active,
                                 pk_alert_constant.g_inactive),
                          g_order_set_filter_diagnosis,
                          decode(l_has_diagnosis_results,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_active,
                                 pk_alert_constant.g_inactive),
                          g_order_set_filter_frequent,
                          decode(l_has_results,
                                 pk_alert_constant.g_yes,
                                 pk_alert_constant.g_active,
                                 pk_alert_constant.g_inactive),
                          pk_alert_constant.g_active) flg_active
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, 'ORDER_SET_FREQUENT_FILTER', NULL)) sd
             ORDER BY sd.rank, sd.desc_val;
    
        g_error := 'get o_order_sets cursor / count=' || l_order_sets_tab.count;
    
        IF l_has_complaint_results = pk_alert_constant.get_yes
        THEN
            OPEN o_order_sets FOR
                SELECT /*+opt_estimate(table t rows=1)*/
                 t.id_order_set, t.order_set_desc description, t.order_set_title title
                  FROM TABLE(CAST(l_order_sets_tab AS t_tbl_odst_frequent)) t
                 ORDER BY upper(t.order_set_title);
        ELSIF l_has_diagnosis_results = pk_alert_constant.get_yes
        THEN
            OPEN o_order_sets FOR
                SELECT /*+opt_estimate(table t rows=1)*/
                 t.id_order_set, t.order_set_desc description, t.order_set_title title
                  FROM TABLE(CAST(l_order_sets_tab_diag AS t_tbl_odst_frequent)) t
                 ORDER BY upper(t.order_set_title);
        ELSE
            OPEN o_order_sets FOR
                SELECT /*+opt_estimate(table t rows=1)*/
                 t.id_order_set, t.order_set_desc description, t.order_set_title title
                  FROM TABLE(CAST(l_order_sets_tab AS t_tbl_odst_frequent)) t
                 ORDER BY upper(t.order_set_title);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_FILTERS',
                                              o_error);
            pk_types.open_my_cursor(o_filters);
            pk_types.open_my_cursor(o_order_sets);
            RETURN FALSE;
    END get_order_set_filters;

    FUNCTION set_order_set_chief_complaint
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_order_set   IN order_set.id_order_set%TYPE,
        i_link_complaint IN table_number,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'delete existing order set chief complaint links';
        DELETE FROM order_set_link
         WHERE id_order_set = i_id_order_set
           AND flg_link_type = g_order_set_link_chief_compl;
    
        g_error := 'insert new order set chief complaint links';
        INSERT INTO order_set_link
            (id_order_set, id_link, flg_link_type)
            SELECT i_id_order_set, column_value, g_order_set_link_chief_compl
              FROM TABLE(i_link_complaint);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_CHIEF_COMPLAINT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_chief_complaint;

    FUNCTION set_order_set_reason_for_visit
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_order_set      IN order_set.id_order_set%TYPE,
        i_link_reason_visit IN table_number,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
        g_error := 'delete existing order set reason for visit links';
        DELETE FROM order_set_link
         WHERE id_order_set = i_id_order_set
           AND flg_link_type = g_order_set_link_reason_visit;
    
        g_error := 'insert new order set reason for visit links';
        INSERT INTO order_set_link
            (id_order_set, id_link, flg_link_type)
            SELECT i_id_order_set, column_value, g_order_set_link_reason_visit
              FROM TABLE(i_link_reason_visit);
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_REASON_FOR_VISIT',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_reason_for_visit;

    FUNCTION set_order_set_diagnoses
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        i_diagnoses    IN CLOB,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        error_undefined_status EXCEPTION;
    
    BEGIN
    
        g_error := 'update order set clinical indications/diagnoses';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        UPDATE order_set
           SET clinical_indications = i_diagnoses
         WHERE id_order_set = i_id_order_set
           AND flg_status = g_order_set_temp;
    
        IF (SQL%ROWCOUNT = 0)
        THEN
            RAISE error_undefined_status;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_DIAGNOSES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_diagnoses;

    FUNCTION set_order_set_proc_diagnoses
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_patient              IN patient.id_patient%TYPE,
        i_episode              IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process.id_order_set_process%TYPE,
        i_diagnoses            IN CLOB,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- select all order set process tasks that have clinical indication/diagnoses field
        CURSOR c_diag_tasks IS
            SELECT ospt.id_order_set_process_task,
                   check_modular_task_type(ospt.id_task_type) flg_modular_workflow,
                   ospt.id_task_type
              FROM order_set_process_task ospt
             WHERE ospt.id_order_set_process = i_id_order_set_process
               AND ospt.id_task_type IN (g_odst_task_analysis,
                                         g_odst_task_image_exam,
                                         g_odst_task_other_exam,
                                         g_odst_task_procedure,
                                         g_odst_task_bp,
                                         g_odst_task_patient_education);
    
        -- task detail record
        TYPE t_task_detail IS RECORD(
            id_odst_proc_task         table_number := table_number(),
            flg_value_type            table_table_varchar := table_table_varchar(),
            dvalue                    table_table_varchar := table_table_varchar(),
            nvalue                    table_table_number := table_table_number(),
            vvalue                    table_table_varchar := table_table_varchar(),
            flg_detail_type           table_table_varchar := table_table_varchar(),
            id_advanced_input         table_table_number := table_table_number(),
            id_advanced_input_field   table_table_number := table_table_number(),
            id_advanced_input_field_d table_table_number := table_table_number(),
            id_unit_measure           table_table_number := table_table_number());
    
        -- local variables to store parameters of set_odst_proc_tasks_det_intern function
        l_updated_selected_tasks_info pk_types.cursor_type;
        l_updated_tasks_instructions  pk_types.cursor_type;
        --l_desc_union_task_instr       VARCHAR2(4000);
        l_task_details t_task_detail;
    
        l_rec_diagnoses pk_edis_types.rec_in_epis_diagnosis;
        l_tbl_diagnoses t_table_diagnoses;
        l_exception EXCEPTION;
    
        -- function used to add a new task detail
        PROCEDURE add_new_task_detail
        (
            i_task_details              IN OUT NOCOPY t_task_detail,
            i_id_odst_proc_task         IN NUMBER,
            i_flg_value_type            IN VARCHAR2 DEFAULT NULL,
            i_dvalue                    IN VARCHAR2 DEFAULT NULL,
            i_nvalue                    IN NUMBER DEFAULT NULL,
            i_vvalue                    IN VARCHAR2 DEFAULT NULL,
            i_flg_detail_type           IN VARCHAR2 DEFAULT NULL,
            i_id_advanced_input         IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field   IN NUMBER DEFAULT NULL,
            i_id_advanced_input_field_d IN NUMBER DEFAULT NULL,
            i_id_unit_measure           IN NUMBER DEFAULT NULL
        ) IS
            l_idx PLS_INTEGER;
        BEGIN
            -- extend table for the new task detail
            i_task_details.id_odst_proc_task.extend;
            i_task_details.flg_value_type.extend;
            i_task_details.dvalue.extend;
            i_task_details.nvalue.extend;
            i_task_details.vvalue.extend;
            i_task_details.flg_detail_type.extend;
            i_task_details.id_advanced_input.extend;
            i_task_details.id_advanced_input_field.extend;
            i_task_details.id_advanced_input_field_d.extend;
            i_task_details.id_unit_measure.extend;
        
            -- gets index of the new position
            l_idx := i_task_details.id_odst_proc_task.count;
        
            -- set task detail default values
            i_task_details.id_odst_proc_task(l_idx) := i_id_odst_proc_task;
            i_task_details.flg_value_type(l_idx) := table_varchar(i_flg_value_type);
            i_task_details.dvalue(l_idx) := table_varchar(i_dvalue);
            i_task_details.nvalue(l_idx) := table_number(i_nvalue);
            i_task_details.vvalue(l_idx) := table_varchar(i_vvalue);
            i_task_details.flg_detail_type(l_idx) := table_varchar(i_flg_detail_type);
            i_task_details.id_advanced_input(l_idx) := table_number(i_id_advanced_input);
            i_task_details.id_advanced_input_field(l_idx) := table_number(i_id_advanced_input_field);
            i_task_details.id_advanced_input_field_d(l_idx) := table_number(i_id_advanced_input_field_d);
            i_task_details.id_unit_measure(l_idx) := table_number(i_id_unit_measure);
        END;
    
        -- set diagnoses/clinical indications of modular workflow tasks
        PROCEDURE set_diag_modular_worflow_tasks
        (
            i_task_type     IN task_type.id_task_type%TYPE,
            i_task_request  IN table_number,
            i_rec_diagnoses IN pk_edis_types.rec_in_epis_diagnosis
        ) IS
        BEGIN
            CASE
            -- set diagnoses/clinical indications for lab test task types
                WHEN i_task_type = g_odst_task_procedure THEN
                    NULL;
                
                WHEN i_task_type = g_odst_task_bp THEN
                    NULL;
                
                WHEN i_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                    NULL;
                
                WHEN i_task_type = g_odst_task_analysis THEN
                    NULL;
                
            -- set diagnoses/clinical indications for imaging or other exam task types
                WHEN i_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    NULL;
                
                WHEN i_task_type = g_odst_task_patient_education THEN
                    NULL;
                
            -- set diagnoses/clinical indications for communication orders task types
                WHEN i_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                
                    IF NOT pk_comm_orders_order_sets.update_comm_order_clin_ind(i_lang                => i_lang,
                                                                                i_prof                => i_prof,
                                                                                i_id_comm_order_req   => i_task_request,
                                                                                i_clinical_indication => i_diagnoses,
                                                                                o_error               => o_error)
                    THEN
                        g_error := 'error found while calling pk_comm_orders_order_sets.update_comm_order_clin_ind function';
                        RAISE l_exception;
                    END IF;
                
                ELSE
                    g_error := 'modular workflow is not supported for task type [' || i_task_type || ']';
                    RAISE l_exception;
            END CASE;
        END set_diag_modular_worflow_tasks;
    
    BEGIN
    
        g_error := 'update order set process clinical indications/diagnoses';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        UPDATE order_set_process osp
           SET osp.clinical_indications = i_diagnoses
         WHERE osp.id_order_set_process = i_id_order_set_process
           AND osp.flg_status = g_order_set_proc_temp;
    
        IF (SQL%ROWCOUNT = 0)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'update order set process tasks with clinical indications/diagnoses';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- get diagnosis records
        l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang => i_lang, i_prof => i_prof, i_params => i_diagnoses);
    
        -- convert 'pk_edis_types.rec_in_epis_diagnosis' type to 't_table_diagnoses'
        l_tbl_diagnoses := pk_diagnosis.tf_diagnosis(l_rec_diagnoses);
    
        -- all tasks with clinical indications field will be updated
        -- Prepare input parameters for set_odst_proc_tasks_det_intern function
        FOR rec IN c_diag_tasks
        LOOP
        
            -- if modular workflow is not supported
            IF rec.flg_modular_workflow = g_modular_workflow_no_support
            THEN
                IF (l_tbl_diagnoses IS NOT NULL AND l_tbl_diagnoses.count > 0)
                THEN
                
                    FOR i IN 1 .. l_tbl_diagnoses.count
                    LOOP
                    
                        -- add value for "clinical indications/diagnoses" field
                        add_new_task_detail(i_task_details      => l_task_details,
                                            i_id_odst_proc_task => rec.id_order_set_process_task,
                                            i_flg_value_type    => g_task_det_value_type_number,
                                            i_nvalue            => l_tbl_diagnoses(i).id_diagnosis, -- id_diagnosis
                                            i_vvalue            => to_char(l_tbl_diagnoses(i).id_alert_diagnosis), -- id_alert_diagnosis
                                            i_flg_detail_type   => g_tsk_det_type_diag);
                    END LOOP;
                
                ELSE
                
                    -- clean all diagnoses for this task
                    add_new_task_detail(i_task_details      => l_task_details,
                                        i_id_odst_proc_task => rec.id_order_set_process_task,
                                        i_flg_value_type    => g_task_det_value_type_number,
                                        i_dvalue            => NULL,
                                        i_nvalue            => NULL,
                                        i_vvalue            => NULL,
                                        i_flg_detail_type   => g_tsk_det_type_diag);
                
                END IF;
            
                -- modular workflow is supported
            ELSE
                set_diag_modular_worflow_tasks(i_task_type     => rec.id_task_type,
                                               i_task_request  => table_number(get_odst_proc_task_link(i_id_order_set_process_task => rec.id_order_set_process_task,
                                                                                                       i_id_flg_task_link_type     => g_task_link_predefined)),
                                               i_rec_diagnoses => l_rec_diagnoses);
            END IF;
        END LOOP;
    
        g_error := 'CALL SET_ODST_PROC_TASKS_DET_INTERN FUNCTION';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- verify if there are tasks with default values to set
        IF (l_task_details.id_odst_proc_task.count > 0)
        THEN
            -- call function that will insert default values
            IF NOT set_odst_proc_tasks_det_intern(i_lang                        => i_lang,
                                                  i_prof                        => i_prof,
                                                  i_id_order_set_process        => i_id_order_set_process,
                                                  i_id_order_set_proc_tasks     => l_task_details.id_odst_proc_task,
                                                  i_flg_value_type              => l_task_details.flg_value_type,
                                                  i_dvalue                      => l_task_details.dvalue,
                                                  i_nvalue                      => l_task_details.nvalue,
                                                  i_vvalue                      => l_task_details.vvalue,
                                                  i_flg_detail_type             => l_task_details.flg_detail_type,
                                                  i_id_advanced_input           => l_task_details.id_advanced_input,
                                                  i_id_advanced_input_field     => l_task_details.id_advanced_input_field,
                                                  i_id_advanced_input_field_det => l_task_details.id_advanced_input_field_d,
                                                  i_id_unit_measure             => l_task_details.id_unit_measure,
                                                  i_commit                      => g_no,
                                                  o_updated_tasks_instructions  => l_updated_tasks_instructions,
                                                  o_updated_selected_tasks_info => l_updated_selected_tasks_info,
                                                  o_error                       => o_error)
            THEN
                RAISE l_exception;
            END IF;
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_ORDER_SET_PROC_DIAGNOSES',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_order_set_proc_diagnoses;

    FUNCTION get_clinical_questions
    (
        i_lang                      IN language.id_language%TYPE,
        i_prof                      IN profissional,
        i_id_patient                IN patient.id_patient%TYPE,
        i_id_episode                IN episode.id_episode%TYPE,
        i_id_order_set_process      IN order_set_process.id_order_set_process%TYPE,
        i_order_set_proc_tasks_rank IN table_number,
        o_order_set_proc_tasks      OUT pk_types.cursor_type,
        o_clinical_questions        OUT pk_types.cursor_type,
        o_error                     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        -- cursor with all process task links to check if they may have clinical questions
        CURSOR c_order_set_proc_tasks IS
            SELECT ospt.id_order_set_process_task,
                   ospt.id_task_type,
                   get_odst_proc_task_link(i_id_order_set_process_task => ospt.id_order_set_process_task,
                                           i_id_flg_task_link_type     => g_task_link_predefined) id_task_link
              FROM order_set_process_task ospt
             WHERE ospt.flg_status = g_order_set_proc_temp
               AND ospt.id_order_set_process = i_id_order_set_process
               AND ospt.flg_discard_type = g_task_not_discard
               AND get_proc_task_presel(i_lang, i_prof, ospt.id_order_set_process_task) = pk_alert_constant.g_yes;
    
        -- collections and records for clinical questions handling
        l_rec                 t_rec_ost_clinical_questions := t_rec_ost_clinical_questions(NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL,
                                                                                           NULL);
        l_tbl                 t_tbl_ost_clinical_questions := t_tbl_ost_clinical_questions();
        l_clinical_questions  pk_types.cursor_type;
        l_ospt_with_questions table_number := table_number();
        l_dummy               NUMBER(24);
    
        l_exception EXCEPTION;
    
    BEGIN
        -- get clinical questions for each order set process task
        FOR rec_proc_task IN c_order_set_proc_tasks
        LOOP
            -- prepare clinical questions cursor
            CASE
            -- for image or other exams
                WHEN rec_proc_task.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    g_error := 'calling pk_exams_external_api_db.get_exam_questionnaire function';
                    pk_alertlog.log_debug(g_error, g_package_name);
                    IF NOT pk_exams_external_api_db.get_exam_questionnaire(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_patient      => i_id_patient,
                                                                           i_episode      => i_id_episode,
                                                                           i_task_request => rec_proc_task.id_task_link,
                                                                           o_list         => l_clinical_questions,
                                                                           o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                    -- for lab tests
                WHEN rec_proc_task.id_task_type = g_odst_task_analysis THEN
                    -- if we are considering executing the lab tests internally, get clinical questions
                    g_error := 'calling pk_lab_tests_external_api_db.get_lab_test_questionnaire function';
                    pk_alertlog.log_debug(g_error, g_package_name);
                    IF NOT pk_lab_tests_external_api_db.get_lab_test_questionnaire(i_lang         => i_lang,
                                                                                   i_prof         => i_prof,
                                                                                   i_patient      => i_id_patient,
                                                                                   i_episode      => i_id_episode,
                                                                                   i_task_request => rec_proc_task.id_task_link,
                                                                                   o_list         => l_clinical_questions,
                                                                                   o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                    -- for procedures
                WHEN rec_proc_task.id_task_type = g_odst_task_procedure THEN
                    g_error := 'calling pk_procedures_external_api_db.get_procedure_questionnaire function';
                    pk_alertlog.log_debug(g_error, g_package_name);
                    IF NOT pk_procedures_external_api_db.get_procedure_questionnaire(i_lang         => i_lang,
                                                                                     i_prof         => i_prof,
                                                                                     i_patient      => i_id_patient,
                                                                                     i_episode      => i_id_episode,
                                                                                     i_task_request => rec_proc_task.id_task_link,
                                                                                     o_list         => l_clinical_questions,
                                                                                     o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                WHEN rec_proc_task.id_task_type = g_odst_task_bp THEN
                    g_error := 'calling pk_procedures_external_api_db.get_procedure_questionnaire function';
                    pk_alertlog.log_debug(g_error, g_package_name);
                    IF NOT pk_bp_external_api_db.get_bp_questionnaire(i_lang         => i_lang,
                                                                      i_prof         => i_prof,
                                                                      i_patient      => i_id_patient,
                                                                      i_episode      => i_id_episode,
                                                                      i_task_request => rec_proc_task.id_task_link,
                                                                      o_list         => l_clinical_questions,
                                                                      o_error        => o_error)
                    THEN
                        RAISE l_exception;
                    END IF;
                ELSE
                    -- for other task types, clinical questions aren't supported
                    l_clinical_questions := NULL;
            END CASE;
        
            -- l_clinical_questions cursor can only be fetched when the clinical questions APIs are called
            IF l_clinical_questions IS NOT NULL
            THEN
                -- open l_clinical_questions; (cursor l_clinical_questions is already open)
                LOOP
                    g_error := 'fetch record from l_clinical_questions cursor';
                    pk_alertlog.log_debug(g_error, g_package_name);
                
                    CASE
                    -- for image or other exams
                        WHEN rec_proc_task.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                            FETCH l_clinical_questions
                                INTO l_rec.id_task,
                                     l_rec.id_questionnaire,
                                     l_rec.id_questionnaire_parent,
                                     l_rec.id_response_parent,
                                     l_rec.desc_questionnaire,
                                     l_rec.flg_type,
                                     l_rec.flg_mandatory,
                                     l_rec.flg_apply_to_all,
                                     l_rec.id_unit_measure,
                                     l_rec.desc_response,
                                     l_rec.episode_id_response,
                                     l_rec.episode_desc_response;
                            -- for lab tests
                        WHEN rec_proc_task.id_task_type = g_odst_task_analysis THEN
                            FETCH l_clinical_questions
                                INTO l_rec.id_task,
                                     l_dummy,
                                     l_rec.id_questionnaire,
                                     l_rec.id_questionnaire_parent,
                                     l_rec.id_response_parent,
                                     l_rec.desc_questionnaire,
                                     l_rec.flg_type,
                                     l_rec.flg_mandatory,
                                     l_rec.flg_apply_to_all,
                                     l_rec.id_unit_measure,
                                     l_rec.desc_response,
                                     l_rec.episode_id_response,
                                     l_rec.episode_desc_response;
                            -- for procedures
                        WHEN rec_proc_task.id_task_type = g_odst_task_procedure THEN
                            FETCH l_clinical_questions
                                INTO l_rec.id_task,
                                     l_rec.id_questionnaire,
                                     l_rec.id_questionnaire_parent,
                                     l_rec.id_response_parent,
                                     l_rec.desc_questionnaire,
                                     l_rec.flg_type,
                                     l_rec.flg_mandatory,
                                     l_rec.flg_apply_to_all,
                                     l_rec.id_unit_measure,
                                     l_rec.desc_response,
                                     l_rec.episode_id_response,
                                     l_rec.episode_desc_response;
                        WHEN rec_proc_task.id_task_type = g_odst_task_bp THEN
                            FETCH l_clinical_questions
                                INTO l_rec.id_task,
                                     l_rec.id_questionnaire,
                                     l_rec.id_questionnaire_parent,
                                     l_rec.id_response_parent,
                                     l_rec.desc_questionnaire,
                                     l_rec.flg_type,
                                     l_rec.flg_mandatory,
                                     l_rec.flg_apply_to_all,
                                     l_rec.id_unit_measure,
                                     l_rec.desc_response,
                                     l_rec.episode_id_response,
                                     l_rec.episode_desc_response;
                    END CASE;
                
                    EXIT WHEN l_clinical_questions%NOTFOUND;
                    l_rec.id_order_set_process_task := rec_proc_task.id_order_set_process_task;
                    l_rec.id_task_type              := rec_proc_task.id_task_type;
                    -- insert new fetched record into collection
                    l_tbl.extend;
                    l_tbl(l_tbl.count) := l_rec;
                    -- this id_order_set_process_task has clinical questions
                    l_ospt_with_questions.extend;
                    l_ospt_with_questions(l_ospt_with_questions.count) := rec_proc_task.id_order_set_process_task;
                END LOOP;
                CLOSE l_clinical_questions;
            END IF;
        END LOOP;
    
        g_error := 'get o_clinical_questions cursor';
        pk_types.open_my_cursor(o_clinical_questions);
        OPEN o_clinical_questions FOR
            SELECT id_order_set_process_task,
                   id_task,
                   id_task_type,
                   id_task_questionnaire,
                   id_questionnaire,
                   id_questionnaire_parent,
                   id_response_parent,
                   desc_questionnaire,
                   flg_type,
                   flg_mandatory,
                   flg_apply_to_all,
                   id_unit_measure,
                   desc_response,
                   episode_id_response,
                   episode_desc_response
              FROM TABLE(CAST(l_tbl AS t_tbl_ost_clinical_questions));
    
        g_error := 'get o_order_set_proc_tasks cursor';
        OPEN o_order_set_proc_tasks FOR
            SELECT ospt.id_order_set_process_task,
                   ospt.id_task_type,
                   pk_order_sets.get_task_desc(i_lang,
                                               i_prof,
                                               ospt.id_order_set_process_task,
                                               ospt.id_task_type,
                                               pk_alert_constant.g_yes,
                                               pk_alert_constant.g_no,
                                               g_task_desc_short_format,
                                               pk_alert_constant.g_no) || ' (' ||
                   pk_translation.get_translation(i_lang, 'TASK_TYPE.CODE_TASK_TYPE.' || ospt.id_task_type) || ')' task_desc
              FROM order_set_process_task ospt
             WHERE ospt.flg_status = g_order_set_proc_temp
               AND ospt.id_order_set_process = i_id_order_set_process
               AND ospt.flg_discard_type = g_task_not_discard
               AND ospt.id_order_set_process_task IN
                   (SELECT /*+opt_estimate(table tasks rows=1)*/
                     column_value
                      FROM TABLE(l_ospt_with_questions) tasks)
             ORDER BY get_task_rank(i_order_set_proc_tasks_rank, ospt.id_order_set_process_task);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_CLINICAL_QUESTIONS',
                                              o_error);
            pk_types.open_my_cursor(o_clinical_questions);
            pk_types.open_my_cursor(o_order_set_proc_tasks);
            RETURN FALSE;
    END get_clinical_questions;

    FUNCTION get_flg_has_clin_quest
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task_type IN task_type.id_task_type%TYPE,
        i_id_task   IN order_set_task.id_order_set_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_clinical_questions VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_count              NUMBER;
    
    BEGIN
    
        CASE
        -- for image or other exams
            WHEN i_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM order_set_process_task ospt
                  JOIN order_set_process_task_link osptl
                    ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
                 INNER JOIN exam_req_det erd
                    ON erd.id_exam_req = to_number(osptl.id_task_link)
                  JOIN exam_questionnaire eq
                    ON erd.id_exam = eq.id_exam
                 WHERE ospt.id_order_set_process_task = i_id_task
                   AND eq.flg_time = pk_exam_constant.g_exam_cq_on_order
                   AND eq.id_institution = i_prof.institution
                   AND eq.flg_available = pk_exam_constant.g_available;
            
                IF l_count > 0
                THEN
                    l_clinical_questions := pk_alert_constant.g_yes;
                END IF;
            
        -- for lab tests
            WHEN i_task_type = g_odst_task_analysis THEN
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM order_set_process_task ospt
                  JOIN order_set_process_task_link osptl
                    ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
                 INNER JOIN analysis_req_det erd
                    ON erd.id_analysis_req = to_number(osptl.id_task_link)
                  JOIN analysis_questionnaire eq
                    ON erd.id_analysis = eq.id_analysis
                 WHERE ospt.id_order_set_process_task = i_id_task
                   AND eq.flg_time = pk_exam_constant.g_exam_cq_on_order
                   AND eq.id_institution = i_prof.institution
                   AND eq.flg_available = pk_exam_constant.g_available;
            
                IF l_count > 0
                THEN
                    l_clinical_questions := pk_alert_constant.g_yes;
                END IF;
                -- for procedures
            WHEN i_task_type = g_odst_task_procedure THEN
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM order_set_process_task ospt
                  JOIN order_set_process_task_link osptl
                    ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
                  JOIN interv_presc_det ipd
                    ON ipd.id_interv_prescription = to_number(osptl.id_task_link)
                  JOIN interv_questionnaire iq
                    ON ipd.id_intervention = iq.id_intervention
                 WHERE ospt.id_order_set_process_task = i_id_task
                   AND iq.flg_time = pk_exam_constant.g_exam_cq_on_order
                   AND iq.id_institution = i_prof.institution
                   AND iq.flg_available = pk_exam_constant.g_available;
            
                IF l_count > 0
                THEN
                    l_clinical_questions := pk_alert_constant.g_yes;
                END IF;
            
            WHEN i_task_type = g_odst_task_bp THEN
            
                SELECT COUNT(*)
                  INTO l_count
                  FROM order_set_process_task ospt
                  JOIN order_set_process_task_link osptl
                    ON osptl.id_order_set_process_task = ospt.id_order_set_process_task
                  JOIN blood_product_det ipd
                    ON ipd.id_blood_product_req = to_number(osptl.id_task_link)
                  JOIN bp_questionnaire iq
                    ON ipd.id_hemo_type = iq.id_hemo_type
                 WHERE ospt.id_order_set_process_task = i_id_task
                   AND iq.flg_time = pk_exam_constant.g_exam_cq_on_order
                   AND iq.id_institution = i_prof.institution
                   AND iq.flg_available = pk_exam_constant.g_available;
            
                IF l_count > 0
                THEN
                    l_clinical_questions := pk_alert_constant.g_yes;
                END IF;
            
            ELSE
                -- for other task types, clinical questions aren't supported
                l_clinical_questions := 'N';
        END CASE;
    
        -- get task type icon name
        RETURN l_clinical_questions;
    
    END get_flg_has_clin_quest;

    FUNCTION get_task_type_icon
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_task_type        IN task_type.id_task_type%TYPE,
        i_id_task          IN order_set_task.id_order_set_task%TYPE,
        i_flg_process_task IN VARCHAR2,
        i_flg_episode      IN VARCHAR2
    ) RETURN VARCHAR2 IS
    
        l_task_icon VARCHAR2(200 CHAR);
    
    BEGIN
    
        CASE
            WHEN i_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam)
                 AND i_flg_episode = pk_alert_constant.g_yes THEN
            
                l_task_icon := 'ExamsEpisodeIcon';
            
            WHEN i_task_type = g_odst_task_analysis
                 AND i_flg_episode = pk_alert_constant.g_yes THEN
            
                l_task_icon := 'LabEpisodeIcon';
            
            WHEN i_task_type = g_odst_task_medication THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                THEN
                    l_task_icon := pk_api_pfh_ordertools_in.get_medication_type_icon(i_lang     => i_lang,
                                                                                     i_prof     => i_prof,
                                                                                     i_id_presc => get_odst_proc_task_link(i_id_task,
                                                                                                                           get_odst_proc_task_link_type(i_id_task)));
                ELSE
                    l_task_icon := pk_api_pfh_ordertools_in.get_medication_type_icon(i_lang     => i_lang,
                                                                                     i_prof     => i_prof,
                                                                                     i_id_presc => get_odst_task_link(i_id_task,
                                                                                                                      get_odst_task_link_type(i_id_task)));
                END IF;
            
            WHEN i_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                THEN
                    l_task_icon := pk_comm_orders_order_sets.get_comm_order_icon(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_id_comm_order_req => get_odst_proc_task_link(i_id_task,
                                                                                                                                get_odst_proc_task_link_type(i_id_task)));
                ELSE
                    l_task_icon := pk_comm_orders_order_sets.get_comm_order_icon(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_id_comm_order_req => get_odst_task_link(i_id_task,
                                                                                                                           get_odst_task_link_type(i_id_task)));
                END IF;
            ELSE
                l_task_icon := pk_task_type.get_task_type_icon(i_lang, i_task_type);
            
        END CASE;
    
        -- get task type icon name
        RETURN l_task_icon;
    
    END get_task_type_icon;

    FUNCTION get_task_type_source
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_task_type        IN task_type.id_task_type%TYPE,
        i_id_task          IN order_set_task.id_order_set_task%TYPE,
        i_flg_process_task IN VARCHAR2,
        i_flg_episode      IN VARCHAR2
    ) RETURN NUMBER IS
    
        l_task_type task_type.id_task_type%TYPE;
    
    BEGIN
    
        CASE
        
            WHEN i_task_type = g_odst_task_medication THEN
            
                IF i_flg_process_task = pk_alert_constant.g_yes
                THEN
                    l_task_type := pk_api_pfh_ordertools_in.get_medication_task_type(i_lang     => i_lang,
                                                                                     i_prof     => i_prof,
                                                                                     i_id_presc => get_odst_proc_task_link(i_id_task,
                                                                                                                           get_odst_proc_task_link_type(i_id_task)));
                ELSE
                    l_task_type := pk_api_pfh_ordertools_in.get_medication_task_type(i_lang     => i_lang,
                                                                                     i_prof     => i_prof,
                                                                                     i_id_presc => get_odst_task_link(i_id_task,
                                                                                                                      get_odst_task_link_type(i_id_task)));
                END IF;
            
        -- Add here other cases where original task type is not the same than used by order-set and call respective API...
            ELSE
                -- By default is returning the same task type used by the order-set             
                l_task_type := i_task_type;
        END CASE;
    
        RETURN l_task_type;
    
    END get_task_type_source;

    FUNCTION get_proc_tsk_instr_bg_color
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task_type IN task_type.id_task_type%TYPE,
        i_id_task   IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_background_color VARCHAR2(200 CHAR);
    
    BEGIN
    
        CASE
            WHEN i_task_type = g_odst_task_medication THEN
            
                l_background_color := pk_api_pfh_in.get_instr_bg_color_by_presc(i_lang,
                                                                                i_prof,
                                                                                get_odst_proc_task_link(i_id_task,
                                                                                                        g_task_link_null));
            
            ELSE
                l_background_color := NULL;
            
        END CASE;
    
        -- get task type icon name
        RETURN l_background_color;
    
    END get_proc_tsk_instr_bg_color;

    FUNCTION get_proc_tsk_instr_bg_alpha
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_task_type IN task_type.id_task_type%TYPE,
        i_id_task   IN order_set_process_task.id_order_set_process_task%TYPE
    ) RETURN VARCHAR2 IS
    
        l_background_alpha VARCHAR2(200 CHAR);
    
    BEGIN
    
        CASE
            WHEN i_task_type = g_odst_task_medication THEN
            
                l_background_alpha := pk_api_pfh_in.get_instr_bg_alpha_by_presc(i_lang,
                                                                                i_prof,
                                                                                get_odst_proc_task_link(i_id_task,
                                                                                                        g_task_link_null));
            
            ELSE
                l_background_alpha := NULL;
            
        END CASE;
    
        -- get task type icon name
        RETURN l_background_alpha;
    
    END get_proc_tsk_instr_bg_alpha;

    FUNCTION update_task_reference
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_type    IN task_type.id_task_type%TYPE,
        i_task_ref_old IN order_set_task_link.id_task_link%TYPE,
        i_task_ref_new IN order_set_task_link.id_task_link%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_set_task     order_set_task.id_order_set_task%TYPE;
        l_flg_task_link_type order_set_task_link.flg_task_link_type%TYPE;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        IF i_task_type = g_odst_task_predef_diet
        THEN
            g_error := 'get order set task to update task reference';
            SELECT ost.id_order_set_task
              INTO l_order_set_task
              FROM order_set_task ost
              JOIN order_set_task_link ostl
                ON ostl.id_order_set_task = ost.id_order_set_task
              JOIN order_set os
                ON os.id_order_set = ost.id_order_set
             WHERE ost.id_task_type = i_task_type
               AND ostl.flg_task_link_type = get_odst_task_link_type(ost.id_order_set_task)
               AND ostl.id_task_link = i_task_ref_old
               AND os.flg_status IN (g_order_set_finished, g_order_set_temp);
            -- no_data_found exception handled without error - check the exception block below
            -- (no update is needed because the task is bot being used in order sets)
        
            -- if previous block doesn't fail, then l_order_set_task variable is not null
        
            -- get task link type
            l_flg_task_link_type := get_odst_task_link_type(l_order_set_task);
        
            -- update id_task_link for existing link in all orders sets that are finished or in edition (temporary)
            g_error := 'update reference link from [' || i_task_ref_old || '] to [' || i_task_ref_new ||
                       '], for task type [' || i_task_type || '], for flag task link type [' || l_flg_task_link_type ||
                       '] and order set task [' || l_order_set_task || ']';
            UPDATE order_set_task_link
               SET id_task_link = i_task_ref_new
             WHERE id_task_link = i_task_ref_old
               AND flg_task_link_type = l_flg_task_link_type
               AND id_order_set_task = l_order_set_task;
        ELSE
            g_error := 'task type [' || i_task_type || '] is not supported in update_task_reference method';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN no_data_found THEN
            -- if l_order_set_task wasn't found, that means the task_type/id_task_link values are not being used by any order set
            -- nothing needed to be done here
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_TASK_REFERENCE',
                                              o_error);
            RETURN FALSE;
    END update_task_reference;

    FUNCTION update_task_proc_reference
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_task_type    IN task_type.id_task_type%TYPE,
        i_task_ref_old IN order_set_task_link.id_task_link%TYPE,
        i_task_ref_new IN order_set_task_link.id_task_link%TYPE,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_order_set_process_task order_set_process_task.id_order_set_process_task%TYPE;
        l_flg_task_link_type     order_set_process_task_link.flg_task_link_type%TYPE;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        IF i_task_type IN (g_odst_task_predef_diet, g_odst_task_instit_diet)
        THEN
            g_error := 'update process task request from [' || i_task_ref_old || '] to [' || i_task_ref_new ||
                       '], for task type [' || i_task_type || ']';
            pk_alertlog.log_debug(g_error, g_package_name);
            UPDATE order_set_process_task ospt
               SET ospt.id_request = i_task_ref_new
             WHERE ospt.id_request = i_task_ref_old
               AND ospt.id_task_type = i_task_type
            RETURNING ospt.id_order_set_process_task INTO l_order_set_process_task;
        
            -- if l_order_set_process_task is null, that means the task_type/id_request values weren't used by order sets (requested elsewhere)
            -- if task type belongs to a predefined task type, then the link should be updated also (link=request)
            IF l_order_set_process_task IS NOT NULL
               AND check_modular_task_type(i_task_type) = g_modular_workflow_support
            THEN
                -- get task link type
                l_flg_task_link_type := get_odst_proc_task_link_type(l_order_set_process_task);
                -- build debug message
                g_error := 'update reference link from [' || i_task_ref_old || '] to [' || i_task_ref_new ||
                           '], for task type [' || i_task_type || '], for flag task link type [' ||
                           l_flg_task_link_type || '] and order set process task [' || l_order_set_process_task || ']';
                pk_alertlog.log_debug(g_error, g_package_name);
                UPDATE order_set_process_task_link
                   SET id_task_link = i_task_ref_new
                 WHERE id_task_link = i_task_ref_old
                   AND flg_task_link_type = l_flg_task_link_type
                   AND id_order_set_process_task = l_order_set_process_task;
            END IF;
        ELSE
            g_error := 'task type [' || i_task_type || '] is not supported in update_task_proc_reference method';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN no_data_found THEN
            RETURN TRUE;
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'UPDATE_TASK_PROC_REFERENCE',
                                              o_error);
            RETURN FALSE;
    END update_task_proc_reference;

    FUNCTION get_lab_test_req_det
    (
        i_lang             IN language.id_language%TYPE,
        i_prof             IN profissional,
        i_lab_test_req     IN table_number,
        o_lab_test_req_det OUT pk_types.cursor_type,
        o_error            OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT pk_lab_tests_external_api_db.get_lab_test_req_det(i_lang             => i_lang,
                                                                 i_prof             => i_prof,
                                                                 i_task_request     => i_lab_test_req,
                                                                 o_analysis_req_det => o_lab_test_req_det,
                                                                 o_error            => o_error)
        THEN
            g_error := 'error found while calling pk_lab_tests_external_api_db.get_lab_test_req_det function';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_LAB_TEST_REQ_DET',
                                              o_error);
            RETURN FALSE;
    END get_lab_test_req_det;

    FUNCTION get_epis_hidrics
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_epis_hidrics IN epis_hidrics.id_epis_hidrics%TYPE,
        o_epis_hid     OUT NOCOPY pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        RETURN pk_inp_hidrics_pbl.get_epis_hidrics_task(i_lang         => i_lang,
                                                        i_prof         => i_prof,
                                                        i_epis_hidrics => i_epis_hidrics,
                                                        o_epis_hid     => o_epis_hid,
                                                        o_error        => o_error);
    END get_epis_hidrics;

    FUNCTION get_lab_test_access_permission
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_order_set_task IN order_set_task.id_order_set_task%TYPE,
        i_flg_type          IN group_access.flg_type%TYPE DEFAULT pk_lab_tests_constant.g_infectious_diseases_orders
    ) RETURN VARCHAR2 IS
    
        l_tbl_analysis_req table_number := table_number();
        l_tbl_analysis     table_number := table_number();
        l_count_records    NUMBER := 0;
        l_count_permission NUMBER := 0;
    
    BEGIN
    
        SELECT pk_order_sets.get_odst_task_link(i_id_order_set_task     => i_id_order_set_task,
                                                i_id_flg_task_link_type => g_task_link_predefined)
          BULK COLLECT
          INTO l_tbl_analysis_req
          FROM dual;
    
        SELECT d.id_analysis
          BULK COLLECT
          INTO l_tbl_analysis
          FROM analysis_req_det d
         WHERE d.flg_status != pk_alert_constant.g_flg_status_c
           AND d.id_analysis_req IN (SELECT *
                                       FROM TABLE(l_tbl_analysis_req));
    
        SELECT COUNT(*)
          INTO l_count_records
          FROM TABLE(l_tbl_analysis);
    
        IF l_count_records = 1
        THEN
            RETURN pk_lab_tests_api_db.get_lab_test_access_permission(i_lang, i_prof, l_tbl_analysis(1), i_flg_type);
        ELSE
            IF l_count_records > 1
            THEN
                FOR i IN l_tbl_analysis.first .. l_tbl_analysis.last
                LOOP
                    IF pk_lab_tests_api_db.get_lab_test_access_permission(i_lang, i_prof, l_tbl_analysis(i), i_flg_type) =
                       pk_alert_constant.g_yes
                    THEN
                        l_count_permission := l_count_permission + 1;
                    END IF;
                END LOOP;
            
                IF l_count_permission > 0
                THEN
                    RETURN pk_alert_constant.g_yes;
                ELSE
                    RETURN pk_alert_constant.g_no;
                END IF;
            ELSE
                RETURN pk_alert_constant.g_no;
            END IF;
        END IF;
    
    END get_lab_test_access_permission;

    FUNCTION get_exam_req_det
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_exam_req     IN table_number,
        o_exam_req_det OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT pk_exams_external_api_db.get_exam_req_det(i_lang         => i_lang,
                                                         i_prof         => i_prof,
                                                         i_task_request => i_exam_req,
                                                         o_exam_req_det => o_exam_req_det,
                                                         o_error        => o_error)
        THEN
            g_error := 'error found while calling pk_exams_external_api_db.get_exam_req_det function';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_EXAM_REQ_DET',
                                              o_error);
            RETURN FALSE;
    END get_exam_req_det;

    FUNCTION set_tasks_groups
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_order_set_tasks IN table_number,
        i_task_groups     IN table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task_group IS TABLE OF order_set_task_group%ROWTYPE INDEX BY PLS_INTEGER;
    
        ibt_order_set_task_group t_order_set_task_group;
    
        CURSOR c_order_set_tasks_groups IS
            SELECT tasks.column_value id_order_set_task, groups.column_value id_task_group
              FROM TABLE(i_order_set_tasks) tasks, TABLE(i_task_groups) groups;
    
        l_counter PLS_INTEGER;
    
    BEGIN
    
        -- remove all existing groups of the order set tasks
        DELETE FROM order_set_task_group ostg
         WHERE ostg.id_order_set_task IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                           column_value
                                            FROM TABLE(i_order_set_tasks) t);
    
        -- establish a cross join relation between order set tasks and task groups 
        FOR rec IN c_order_set_tasks_groups
        LOOP
        
            l_counter := ibt_order_set_task_group.count + 1;
            ibt_order_set_task_group(l_counter).id_order_set_task := rec.id_order_set_task;
            ibt_order_set_task_group(l_counter).id_task_group := rec.id_task_group;
        
        END LOOP;
    
        --- set task groups for the order set tasks
        IF (ibt_order_set_task_group.count > 0)
        THEN
            FORALL i IN ibt_order_set_task_group.first .. ibt_order_set_task_group.last
                INSERT INTO order_set_task_group
                VALUES ibt_order_set_task_group
                    (i);
        END IF;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'SET_TASKS_GROUPS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END set_tasks_groups;

    FUNCTION get_procedure_req_det
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_procedure_req     IN table_number,
        o_procedure_req_det OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_exception EXCEPTION;
    
    BEGIN
    
        IF NOT pk_procedures_external_api_db.get_procedure_req_det(i_lang             => i_lang,
                                                                   i_prof             => i_prof,
                                                                   i_task_request     => i_procedure_req,
                                                                   o_interv_presc_det => o_procedure_req_det,
                                                                   o_error            => o_error)
        THEN
            g_error := 'error found while calling pk_procedures_external_api_db.get_procedure_req_det function';
            RAISE l_exception;
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_PROCEDURE_REQ_DET',
                                              o_error);
            RETURN FALSE;
    END get_procedure_req_det;

    FUNCTION remove_tasks_groups
    (
        i_lang            IN language.id_language%TYPE,
        i_prof            IN profissional,
        i_order_set_tasks IN table_number,
        o_error           OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        DELETE FROM order_set_task_group ostg
         WHERE ostg.id_order_set_task IN (SELECT /*+ opt_estimate(table t rows = 1) */
                                           column_value
                                            FROM TABLE(i_order_set_tasks) t);
    
        COMMIT;
    
        RETURN TRUE;
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'REMOVE_TASKS_GROUPS',
                                              o_error);
            pk_utils.undo_changes;
            RETURN FALSE;
    END remove_tasks_groups;

    FUNCTION get_order_sets_to_copy
    (
        i_lang       IN language.id_language%TYPE,
        i_prof       IN profissional,
        i_value      IN VARCHAR2,
        o_order_sets OUT pk_types.cursor_type,
        o_error      OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_institutions table_number;
    
    BEGIN
    
        g_error        := 'GET ALL INSTITUTIONS FROM THE SAME GROUP';
        l_institutions := table_number(i_prof.institution);
    
        g_error := 'GET CURSOR';
        OPEN o_order_sets FOR
            SELECT odst.id_order_set,
                   odst.title || ' (' || (SELECT COUNT(*)
                                            FROM order_set_task ost
                                           WHERE ost.id_order_set = odst.id_order_set) || ')' description,
                   odst.title title
              FROM order_set odst
              LEFT OUTER JOIN professional prof
                ON (odst.id_professional = prof.id_professional)
             WHERE odst.flg_status = g_order_set_finished
               AND odst.id_institution IN (SELECT /*+opt_estimate(table inst rows=1)*/
                                            column_value
                                             FROM TABLE(l_institutions) inst)
                  -- ** search for value **
               AND (i_value IS NOT NULL AND
                   (translate(upper(odst.title), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%') OR
                   i_value IS NULL)
             ORDER BY upper(odst.title);
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SETS_TO_COPY',
                                              o_error);
            pk_types.open_my_cursor(o_order_sets);
            RETURN FALSE;
    END get_order_sets_to_copy;

    FUNCTION get_order_set_tasks_to_copy
    (
        i_lang              IN language.id_language%TYPE,
        i_prof              IN profissional,
        i_id_order_set_orig IN order_set.id_order_set%TYPE,
        i_id_order_set_dest IN order_set.id_order_set%TYPE,
        i_value             IN VARCHAR2,
        o_order_set_tasks   OUT pk_types.cursor_type,
        o_error             OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tasks_rank table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ORDER SET TASKS RANK';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- get order set dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_orig),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set_orig),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => o_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET ORDER SET TASKS CURSOR';
        OPEN o_order_set_tasks FOR
            SELECT nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                   task_group_desc || ' (' || COUNT(*) over(PARTITION BY task_group_desc) || ')' task_group_desc,
                   task_group_rank,
                   id_order_set_task,
                   id_task_type,
                   -- the order set can't have more than one task of "discharge instruction" type
                   decode(id_task_type,
                          g_odst_task_discharge_instruct,
                          nvl((SELECT pk_alert_constant.g_yes
                                FROM order_set_task odst_tsk
                               WHERE odst_tsk.id_task_type = g_odst_task_discharge_instruct
                                 AND odst_tsk.id_order_set = i_id_order_set_dest),
                              pk_alert_constant.g_no),
                          pk_alert_constant.g_no) flg_conflict,
                   get_task_rank(l_tasks_rank, id_order_set_task) dependency_order,
                   nvl2(id_order_set_task_to, pk_alert_constant.g_dependency_icon, NULL) icon_dep_name,
                   task_desc || chr(10) || replace_dependencies_refs_rank(i_lang,
                                                                          pk_tde_db.get_depend_description(i_lang,
                                                                                                           i_prof,
                                                                                                           id_order_set_task,
                                                                                                           check_episode_support_task(i_lang,
                                                                                                                                      i_prof,
                                                                                                                                      l_dependency_type,
                                                                                                                                      l_task_dependency_from,
                                                                                                                                      l_task_dependency_to,
                                                                                                                                      id_order_set_task,
                                                                                                                                      id_task_type),
                                                                                                           l_tasks_rank,
                                                                                                           l_dependency_type,
                                                                                                           l_task_dependency_from,
                                                                                                           l_task_dependency_to,
                                                                                                           l_task_type_from,
                                                                                                           l_task_type_to,
                                                                                                           l_task_schedule_from,
                                                                                                           l_task_schedule_to,
                                                                                                           l_lag_min,
                                                                                                           l_lag_max,
                                                                                                           l_lag_unit_measure),
                                                                          l_tasks_rank) task_desc,
                   -- list of tasks that must be selected if this tasks is also selected
                   pk_tde_db.get_predecessor_dependencies(id_order_set_task,
                                                          l_dependency_type,
                                                          l_task_dependency_from,
                                                          l_task_dependency_to,
                                                          l_task_type_from,
                                                          l_task_type_to) depend_select_list,
                   -- list of tasks that must be unselected if this tasks is also unselected
                   pk_tde_db.get_sucessor_dependencies(id_order_set_task,
                                                       l_dependency_type,
                                                       l_task_dependency_from,
                                                       l_task_dependency_to,
                                                       l_task_type_from,
                                                       l_task_type_to) depend_unselect_list
              FROM (SELECT odst_tsk.id_order_set_task,
                           odst_tsk.id_task_type,
                           get_order_set_task_group_desc(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_desc,
                           get_order_set_task_group_rank(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_rank,
                           odst_tsk_dep.id_order_set_task_to,
                           get_task_desc(i_lang,
                                         i_prof,
                                         odst_tsk.id_order_set_task,
                                         odst_tsk.id_task_type,
                                         pk_alert_constant.g_no,
                                         check_episode_support_task(i_lang,
                                                                    i_prof,
                                                                    l_dependency_type,
                                                                    l_task_dependency_from,
                                                                    l_task_dependency_to,
                                                                    odst_tsk.id_order_set_task,
                                                                    odst_tsk.id_task_type),
                                         g_task_desc_extended_format,
                                         pk_alert_constant.g_no) task_desc
                      FROM order_set_task odst_tsk
                    -- verify if the task is not included in the current episode or future episode
                      LEFT OUTER JOIN order_set_task_dependency odst_tsk_dep
                        ON (odst_tsk_dep.id_order_set_task_to = odst_tsk.id_order_set_task AND
                           odst_tsk_dep.id_order_set = i_id_order_set_orig AND
                           odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                           odst_tsk_dep.id_order_set_task_from NOT IN
                           (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                     WHERE odst_tsk.id_order_set = i_id_order_set_orig)
            -- ** search for value **
             WHERE (i_value IS NOT NULL AND
                   (translate(upper(task_desc), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') LIKE
                   '%' || translate(upper(i_value), ' ', 'AEIOUAEIOUAEIOUAOCAEIOUN%') || '%') OR
                   i_value IS NULL)
             ORDER BY group_type_id NULLS LAST, get_task_rank(l_tasks_rank, id_order_set_task);
    
        RETURN TRUE;
    
    EXCEPTION
        -- unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TASKS_TO_COPY',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_tasks);
            RETURN FALSE;
    END get_order_set_tasks_to_copy;

    FUNCTION copy_tasks_to_order_set
    (
        i_lang                    IN language.id_language%TYPE,
        i_prof                    IN profissional,
        i_id_order_set_dest       IN order_set.id_order_set%TYPE,
        i_order_set_tasks_to_copy IN table_number,
        o_new_order_set_tasks     OUT pk_types.cursor_type,
        o_error                   OUT t_error_out
    ) RETURN BOOLEAN IS
    
        TYPE t_order_set_task IS TABLE OF order_set_task%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task t_order_set_task;
    
        TYPE t_order_set_task_link IS TABLE OF order_set_task_link%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_link t_order_set_task_link;
    
        TYPE t_order_set_task_detail IS TABLE OF order_set_task_detail%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_detail t_order_set_task_detail;
    
        TYPE t_order_set_task_dependency IS TABLE OF order_set_task_dependency%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_dependency t_order_set_task_dependency;
    
        TYPE t_order_set_task_group IS TABLE OF order_set_task_group%ROWTYPE INDEX BY PLS_INTEGER;
        ibt_order_set_task_group t_order_set_task_group;
    
        ----------------    
    
        CURSOR c_order_set_task(in_id_order_set_new order_set.id_order_set%TYPE) IS
            SELECT seq_order_set_task.nextval id_order_set_task_new,
                   ost.id_order_set_task      id_order_set_task_old,
                   in_id_order_set_new        id_order_set,
                   ost.id_task_type,
                   tt.flg_modular_workflow
              FROM order_set_task ost
              JOIN task_type tt
                ON tt.id_task_type = ost.id_task_type
             WHERE ost.id_order_set_task IN (SELECT /*+opt_estimate(table odst_tsk rows=1)*/
                                              odst_tsk.column_value
                                               FROM TABLE(i_order_set_tasks_to_copy) odst_tsk);
    
        CURSOR c_order_set_task_link
        (
            in_id_order_set_task     order_set_task_link.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_link.id_order_set_task%TYPE
        ) IS
            SELECT in_id_order_set_task_new id_order_set_task, id_task_link, flg_task_link_type
              FROM order_set_task_link
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_detail
        (
            in_id_order_set_task     order_set_task_detail.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_detail.id_order_set_task%TYPE
        ) IS
            SELECT seq_order_set_task_detail.nextval id_order_set_task_detail,
                   in_id_order_set_task_new          id_order_set_task,
                   flg_value_type,
                   nvalue,
                   dvalue,
                   vvalue,
                   flg_detail_type,
                   id_advanced_input,
                   id_advanced_input_field,
                   id_advanced_input_field_det,
                   id_unit_measure
              FROM order_set_task_detail
             WHERE id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_group
        (
            in_id_order_set_task     order_set_task_group.id_order_set_task%TYPE,
            in_id_order_set_task_new order_set_task_group.id_order_set_task%TYPE
        ) IS
            SELECT in_id_order_set_task_new id_order_set_task, ostg.id_task_group
              FROM order_set_task_group ostg
             WHERE ostg.id_order_set_task = in_id_order_set_task;
    
        CURSOR c_order_set_task_dependency(in_id_order_set_new order_set.id_order_set%TYPE) IS
            SELECT odst_tsk_depend.id_relationship_type,
                   odst_tsk_depend.id_order_set_task_from,
                   odst_tsk_depend.id_order_set_task_to,
                   odst_tsk_depend.lag_min,
                   odst_tsk_depend.lag_max,
                   odst_tsk_depend.id_unit_measure_lag,
                   in_id_order_set_new id_order_set
              FROM order_set_task_dependency odst_tsk_depend
             WHERE odst_tsk_depend.id_order_set_task_to IN
                   (SELECT /*+opt_estimate(table odst_tsk_to rows=1)*/
                     odst_tsk_to.column_value
                      FROM TABLE(i_order_set_tasks_to_copy) odst_tsk_to);
    
        l_task_counter        NUMBER;
        l_task_link_counter   NUMBER;
        l_task_det_counter    NUMBER;
        l_task_group_counter  NUMBER;
        l_task_depend_counter NUMBER;
    
        ibt_all_new_tasks table_number := table_number();
    
        TYPE t_record_task_map IS TABLE OF NUMBER INDEX BY VARCHAR2(200 CHAR);
        ibt_task_map t_record_task_map;
    
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET PROCESS TASKS, RELATED LINKS AND DETAILS - SET VARIABLES';
        -- loop for each order set task
        FOR rec_task IN c_order_set_task(i_id_order_set_dest)
        LOOP
        
            l_task_counter := ibt_order_set_task.count + 1;
            ibt_order_set_task(l_task_counter).id_order_set_task := rec_task.id_order_set_task_new;
            ibt_order_set_task(l_task_counter).id_order_set := rec_task.id_order_set;
            ibt_order_set_task(l_task_counter).id_task_type := rec_task.id_task_type;
        
            -- store the mapping between old id_order_set_task and the new id_order_set_task
            -- this mapping will be necessary to copy order set task dependencies
            ibt_task_map(to_char(rec_task.id_order_set_task_old)) := rec_task.id_order_set_task_new;
        
            -- collect all new task IDs
            ibt_all_new_tasks.extend;
            ibt_all_new_tasks(ibt_all_new_tasks.count) := rec_task.id_order_set_task_new;
        
            -- Order set task links
            FOR rec_task_link IN c_order_set_task_link(rec_task.id_order_set_task_old, rec_task.id_order_set_task_new)
            LOOP
                l_task_link_counter := ibt_order_set_task_link.count + 1;
                ibt_order_set_task_link(l_task_link_counter).id_order_set_task := rec_task_link.id_order_set_task;
                ibt_order_set_task_link(l_task_link_counter).flg_task_link_type := rec_task_link.flg_task_link_type;
            
                -- check if modular workflow is supported                    
                IF (rec_task.flg_modular_workflow = g_modular_workflow_support
                   -- TODO: the following two lines are temporary
                   -- They are necessary just because this function is used to migrate labs,
                   -- image and other exams tasks from old architecture to the predefined task architecture.
                   -- After the script is versioned and executed in the production environment, these two lines can be removed. 
                   AND (rec_task_link.flg_task_link_type = g_task_link_predefined OR
                   rec_task.id_task_type IN (g_odst_task_medication, g_odst_task_instit_diet)))
                THEN
                    -- create copy of predefined tasks (check rec_task.flg_modular_workflow value)
                    CASE
                        WHEN rec_task.id_task_type = g_odst_task_medication THEN
                            -- duplicate predefined medication task
                            IF NOT pk_api_pfh_ordertools_in.copy_medication_task(i_lang     => i_lang,
                                                                                 i_prof     => i_prof,
                                                                                 i_id_presc => rec_task_link.id_task_link,
                                                                                 o_id_presc => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                                 o_error    => o_error)
                            THEN
                                g_error := 'error found while calling pk_api_pfh_ordertools_in.copy_medication_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_instit_diet THEN
                            -- duplicate institutionalized diet task
                            IF NOT pk_diet.duplicate_diet_task(i_lang              => i_lang,
                                                               i_prof              => i_prof,
                                                               i_id_diet_prof_inst => rec_task_link.id_task_link,
                                                               o_id_diet_prof_inst => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                               o_error             => o_error)
                            THEN
                                g_error := 'error found while calling pk_diet.duplicate_diet_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_analysis THEN
                            -- duplicate lab test task
                            IF NOT pk_lab_tests_external_api_db.set_lab_test_copy_task(i_lang         => i_lang,
                                                                                       i_prof         => i_prof,
                                                                                       i_patient      => NULL,
                                                                                       i_episode      => NULL,
                                                                                       i_task_request => rec_task_link.id_task_link,
                                                                                       o_task_request => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                                       o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_procedure THEN
                            -- duplicate lab test task
                            IF NOT pk_procedures_external_api_db.set_procedure_copy_task(i_lang         => i_lang,
                                                                                         i_prof         => i_prof,
                                                                                         i_patient      => NULL,
                                                                                         i_episode      => NULL,
                                                                                         i_task_request => rec_task_link.id_task_link,
                                                                                         o_interv_presc => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                                         o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type = g_odst_task_bp THEN
                            -- duplicate lab test task
                            IF NOT pk_bp_external_api_db.set_bp_copy_task(i_lang         => i_lang,
                                                                          i_prof         => i_prof,
                                                                          i_patient      => NULL,
                                                                          i_episode      => NULL,
                                                                          i_task_request => rec_task_link.id_task_link,
                                                                          o_bp_req       => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                          o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_lab_tests_external_api_db.set_lab_test_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type BETWEEN g_odst_task_intake_output AND g_odst_task_irrigation THEN
                            IF NOT pk_inp_hidrics_pbl.set_hidric_copy_task(i_lang         => i_lang,
                                                                           i_prof         => i_prof,
                                                                           i_patient      => NULL,
                                                                           i_episode      => NULL,
                                                                           i_task_request => rec_task_link.id_task_link,
                                                                           o_epis_hidrics => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                           o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_inp_hidrics_pbl.set_hidric_copy_task';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                            -- duplicate image or other exam task
                            IF NOT pk_exams_external_api_db.set_exam_copy_task(i_lang         => i_lang,
                                                                               i_prof         => i_prof,
                                                                               i_patient      => NULL,
                                                                               i_episode      => NULL,
                                                                               i_task_request => rec_task_link.id_task_link,
                                                                               o_exam_req     => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                               o_error        => o_error)
                            THEN
                                g_error := 'error found while calling pk_exams_external_api_db.set_exam_copy_task function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_comm_order, g_odst_task_medical_order) THEN
                            -- duplicate communication order task
                        
                            IF NOT pk_comm_orders_order_sets.copy_comm_order_req(i_lang              => i_lang,
                                                                                 i_prof              => i_prof,
                                                                                 i_id_comm_order_req => rec_task_link.id_task_link,
                                                                                 i_id_patient        => NULL,
                                                                                 i_id_episode        => NULL,
                                                                                 i_dt_begin          => NULL,
                                                                                 o_id_comm_order_req => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                                 o_error             => o_error)
                            THEN
                                g_error := 'error found while calling pk_comm_orders_order_sets.copy_comm_order_req function';
                                RAISE l_exception;
                            END IF;
                        
                        WHEN rec_task.id_task_type IN (g_odst_task_supplies, g_odst_task_surg_supplies) THEN
                            -- duplicate supply or surgical supply task
                            IF NOT pk_supplies_order_sets.copy_supply_wf(i_lang               => i_lang,
                                                                         i_prof               => i_prof,
                                                                         i_id_supply_workflow => rec_task_link.id_task_link,
                                                                         i_id_episode         => NULL,
                                                                         i_dt_request         => NULL,
                                                                         o_id_supply_workflow => ibt_order_set_task_link(l_task_link_counter).id_task_link,
                                                                         o_error              => o_error)
                            THEN
                                g_error := 'error found while calling pk_supplies_order_sets.copy_supply_wf function';
                                RAISE l_exception;
                            END IF;
                        
                        ELSE
                            g_error := 'predefined task is not supported for task type [' || rec_task.id_task_type || ']';
                            RAISE l_exception;
                        
                    END CASE;
                ELSE
                    -- modular workflow not is supported (copy id_task to new order set)
                    ibt_order_set_task_link(l_task_link_counter).id_task_link := rec_task_link.id_task_link;
                END IF;
            END LOOP;
        
            -- Order set task details
            FOR rec_task_detail IN c_order_set_task_detail(rec_task.id_order_set_task_old,
                                                           rec_task.id_order_set_task_new)
            LOOP
                l_task_det_counter := ibt_order_set_task_detail.count + 1;
                ibt_order_set_task_detail(l_task_det_counter).id_order_set_task_detail := rec_task_detail.id_order_set_task_detail;
                ibt_order_set_task_detail(l_task_det_counter).id_order_set_task := rec_task_detail.id_order_set_task;
                ibt_order_set_task_detail(l_task_det_counter).flg_value_type := rec_task_detail.flg_value_type;
                ibt_order_set_task_detail(l_task_det_counter).nvalue := rec_task_detail.nvalue;
                ibt_order_set_task_detail(l_task_det_counter).dvalue := rec_task_detail.dvalue;
                ibt_order_set_task_detail(l_task_det_counter).vvalue := rec_task_detail.vvalue;
                ibt_order_set_task_detail(l_task_det_counter).flg_detail_type := rec_task_detail.flg_detail_type;
                ibt_order_set_task_detail(l_task_det_counter).id_advanced_input := rec_task_detail.id_advanced_input;
                ibt_order_set_task_detail(l_task_det_counter).id_advanced_input_field := rec_task_detail.id_advanced_input_field;
                ibt_order_set_task_detail(l_task_det_counter).id_advanced_input_field_det := rec_task_detail.id_advanced_input_field_det;
                ibt_order_set_task_detail(l_task_det_counter).id_unit_measure := rec_task_detail.id_unit_measure;
            END LOOP;
        
            -- Order set task groups
            FOR rec IN c_order_set_task_group(rec_task.id_order_set_task_old, rec_task.id_order_set_task_new)
            LOOP
                l_task_group_counter := ibt_order_set_task_group.count + 1;
                ibt_order_set_task_group(l_task_group_counter).id_order_set_task := rec.id_order_set_task;
                ibt_order_set_task_group(l_task_group_counter).id_task_group := rec.id_task_group;
            END LOOP;
        
        END LOOP;
    
        -- add to the task map the current episode and future episode dependencies
        ibt_task_map(g_depend_current_epis) := to_number(g_depend_current_epis);
        ibt_task_map(g_depend_future_epis) := to_number(g_depend_future_epis);
    
        g_error := 'INSERT PROCESS TASKS DEPENDENCIES';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        -- Order set task dependencies
        FOR rec_task_depend IN c_order_set_task_dependency(i_id_order_set_dest)
        LOOP
            l_task_depend_counter := ibt_order_set_task_dependency.count + 1;
            ibt_order_set_task_dependency(l_task_depend_counter).id_relationship_type := rec_task_depend.id_relationship_type;
            ibt_order_set_task_dependency(l_task_depend_counter).id_order_set_task_from := ibt_task_map(to_char(rec_task_depend.id_order_set_task_from));
            ibt_order_set_task_dependency(l_task_depend_counter).id_order_set_task_to := ibt_task_map(to_char(rec_task_depend.id_order_set_task_to));
            ibt_order_set_task_dependency(l_task_depend_counter).lag_min := rec_task_depend.lag_min;
            ibt_order_set_task_dependency(l_task_depend_counter).lag_max := rec_task_depend.lag_max;
            ibt_order_set_task_dependency(l_task_depend_counter).id_unit_measure_lag := rec_task_depend.id_unit_measure_lag;
            ibt_order_set_task_dependency(l_task_depend_counter).id_order_set := rec_task_depend.id_order_set;
        
        END LOOP;
    
        -- Set Tasks
        g_error := 'INSERT TASK';
        IF ibt_order_set_task.count > 0
        THEN
            FORALL i IN ibt_order_set_task.first .. ibt_order_set_task.last
                INSERT INTO order_set_task
                VALUES ibt_order_set_task
                    (i);
        END IF;
    
        -- Set Tasks links
        g_error := 'INSERT TASK LINK';
        IF ibt_order_set_task_link.count > 0
        THEN
            FORALL i IN ibt_order_set_task_link.first .. ibt_order_set_task_link.last
                INSERT INTO order_set_task_link
                VALUES ibt_order_set_task_link
                    (i);
        END IF;
    
        -- Set Tasks groups
        g_error := 'INSERT TASK GROUPS';
        IF ibt_order_set_task_group.count > 0
        THEN
            FORALL i IN ibt_order_set_task_group.first .. ibt_order_set_task_group.last
                INSERT INTO order_set_task_group
                VALUES ibt_order_set_task_group
                    (i);
        END IF;
    
        -- Set Tasks details
        g_error := 'INSERT TASK LINK DETAILS';
        IF ibt_order_set_task_detail.count > 0
        THEN
            FORALL i IN ibt_order_set_task_detail.first .. ibt_order_set_task_detail.last
                INSERT INTO order_set_task_detail
                VALUES ibt_order_set_task_detail
                    (i);
        END IF;
    
        -- Set Tasks dependencies
        g_error := 'INSERT TASK DEPENDENCIES';
        IF ibt_order_set_task_dependency.count > 0
        THEN
            FORALL i IN ibt_order_set_task_dependency.first .. ibt_order_set_task_dependency.last
                INSERT INTO order_set_task_dependency
                VALUES ibt_order_set_task_dependency
                    (i);
        END IF;
    
        -- return new order set tasks
        OPEN o_new_order_set_tasks FOR
            SELECT ibt_id_odst_tsk.column_value id_order_set_task
              FROM TABLE(ibt_all_new_tasks) ibt_id_odst_tsk;
    
        COMMIT;
    
        RETURN TRUE;
    
    EXCEPTION
        -- unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              g_package_name,
                                              'COPY_TASKS_TO_ORDER_SET',
                                              o_error);
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_new_order_set_tasks);
            RETURN FALSE;
    END copy_tasks_to_order_set;

    FUNCTION get_ok_button_control
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        i_tbl_result     IN OUT t_tbl_ds_get_value,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_ok_status VARCHAR2(1) := pk_orders_constant.g_component_valid;
    
        l_id_ds_cmpt_mkt_rel_ok ds_cmpt_mkt_rel.id_ds_cmpt_mkt_rel%TYPE;
        l_id_ds_component_ok    ds_component.id_ds_component%TYPE;
        l_ds_internal_name_ok   ds_component.internal_name%TYPE;
    
        l_tbl_configured_items   table_varchar := table_varchar();
        l_tbl_id_ds_cmpt_mkt_rel table_number;
    
        l_value_aux VARCHAR2(4000 CHAR);
    
        l_sys_config_value sys_config.value%TYPE;
    
        --List of components that may be mandatory (i.e. depending of a configuration, of values of the form, etc.)
        l_tbl_possible_mandatory_items table_varchar;
    
    BEGIN
        IF i_episode IS NOT NULL
        THEN
            --Front office
            l_tbl_possible_mandatory_items := table_varchar(pk_orders_constant.g_ds_clinical_purpose,
                                                            pk_orders_constant.g_ds_clinical_purpose_ft,
                                                            pk_orders_constant.g_ds_laterality,
                                                            pk_orders_constant.g_ds_to_execute_list,
                                                            pk_orders_constant.g_ds_other_frequency,
                                                            pk_orders_constant.g_ds_start_date,
                                                            pk_orders_constant.g_ds_place_service,
                                                            pk_orders_constant.g_ds_order_type,
                                                            pk_orders_constant.g_ds_ordered_by,
                                                            pk_orders_constant.g_ds_ordered_at);
        ELSE
            --Backoffice
            l_tbl_possible_mandatory_items := table_varchar(pk_orders_constant.g_ds_laterality,
                                                            pk_orders_constant.g_ds_other_frequency,
                                                            pk_orders_constant.g_ds_place_service);
        END IF;
    
        --Verifiy if the component 'DS_OK_BUTTON_CONTROL' is configured in the form
        --If it isn't, the verification of the form integrity will not be performed.
        g_error := 'VERIFYING DS_OK_BUTTON_CONTROL PRESENCE IN THE FORM';
        FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
        LOOP
            IF i_tbl_int_name(i) = pk_orders_constant.g_ds_ok_button_control
            THEN
                l_ds_internal_name_ok   := i_tbl_int_name(i);
                l_id_ds_component_ok    := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                l_id_ds_cmpt_mkt_rel_ok := i_tbl_mkt_rel(i);
                EXIT;
            END IF;
        END LOOP;
    
        --Component 'DS_OK_BUTTON_CONTROL' has been found, therefore, we will verify if there are mandatory fields,
        --and, for those fields, we will verify if they are null.    
        IF l_ds_internal_name_ok IS NOT NULL
        THEN
            --First we verify if the form is loaded from an edition
            --When editing, if the user has not yet perform any change, the OK button cannot be available
            IF i_action IN (pk_orders_constant.g_action_edition)
            THEN
                l_ok_status := pk_orders_constant.g_component_error;
            END IF;
        
            --Then we analyse the structure i_tbl_result that was sent to us when calling the current function.
            --This structure already indicates if a component is mandatory, and it also indicates its possible value.
            --If there is a mandatory element with no value, we can assure that the form is invalid, and no further
            --verification is needed, so we can stop the verification.
            --Note: i_tbl_result may not present all the elements of a given form, therefore, if no empty mandatory field has been found,
            --it may still be necessary to analyze the remaining fields of the form.
            IF l_ok_status = pk_orders_constant.g_component_valid
            THEN
                g_error := 'ANALYZING I_TBL_RESULT FOR MANDATORY COMPONENTS';
                IF i_tbl_result.count > 0
                THEN
                    FOR i IN i_tbl_result.first .. i_tbl_result.last
                    LOOP
                        IF (i_tbl_result(i).flg_event_type = pk_orders_constant.g_component_mandatory AND i_tbl_result(i).value IS NULL)
                           OR i_tbl_result(i).flg_validation = pk_orders_constant.g_component_error
                        THEN
                            l_ok_status := pk_orders_constant.g_component_error;
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            --No integrity problem has yet been found, but it may still be necessary to analyze the remaining fields.
            IF l_ok_status = pk_orders_constant.g_component_valid
            THEN
                --Check which possible mandatory items (defined in l_tbl_possible_mandatory_items) are available on the form
                --We perform a left join with i_tbl_result to assure that we will not again analyze the components
                --that were analyzed in the previous step.
                g_error := 'FETCHING L_TBL_CONFIGURED_ITEMS';
                SELECT dc.internal_name_child, dc.id_ds_cmpt_mkt_rel
                  BULK COLLECT
                  INTO l_tbl_configured_items, l_tbl_id_ds_cmpt_mkt_rel
                  FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                     i_prof           => i_prof,
                                                     i_patient        => NULL,
                                                     i_component_name => i_root_name,
                                                     i_action         => NULL)) dc
                  JOIN (SELECT /*+opt_estimate(table m rows=1)*/
                         m.*
                          FROM TABLE(l_tbl_possible_mandatory_items) m) t
                    ON t.column_value = dc.internal_name_child
                  LEFT JOIN (SELECT /*+opt_estimate(table t rows=1)*/
                              t.*
                               FROM TABLE(i_tbl_result) t) tt
                    ON tt.id_ds_cmpt_mkt_rel = dc.id_ds_cmpt_mkt_rel
                 WHERE tt.id_ds_cmpt_mkt_rel IS NULL;
            
                --If one of the mandatory fields is empty, there is no need to continue the cicle.
                g_error := 'CYCLING THROUGH L_TBL_CONFIGURED_ITEMS';
                IF l_tbl_configured_items.exists(1)
                THEN
                    FOR i IN l_tbl_configured_items.first .. l_tbl_configured_items.last
                    LOOP
                        IF l_tbl_configured_items(i) IN
                           (pk_orders_constant.g_ds_to_execute_list,
                            pk_orders_constant.g_ds_start_date,
                            pk_orders_constant.g_ds_place_service)
                        THEN
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                IF l_tbl_id_ds_cmpt_mkt_rel(i) = i_tbl_mkt_rel(j)
                                THEN
                                    IF i_value(j) (1) IS NULL
                                    THEN
                                        l_ok_status := pk_orders_constant.g_component_error;
                                        EXIT;
                                    END IF;
                                END IF;
                            END LOOP;
                        ELSIF l_tbl_configured_items(i) IN
                              (pk_orders_constant.g_ds_clinical_purpose, pk_orders_constant.g_ds_laterality)
                        THEN
                            IF i_root_name = pk_orders_constant.g_ds_procedure_request
                            THEN
                                l_sys_config_value := CASE l_tbl_configured_items(i)
                                                          WHEN pk_orders_constant.g_ds_clinical_purpose THEN
                                                           pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_P',
                                                                                   i_prof)
                                                          WHEN pk_orders_constant.g_ds_laterality THEN
                                                           pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY',
                                                                                   i_prof)
                                                      END;
                            
                                IF l_sys_config_value = pk_alert_constant.g_yes
                                THEN
                                    FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                                    LOOP
                                        IF l_tbl_id_ds_cmpt_mkt_rel(i) = i_tbl_mkt_rel(j)
                                        THEN
                                            IF i_value(j) (1) IS NULL
                                            THEN
                                                l_ok_status := pk_orders_constant.g_component_error;
                                                EXIT;
                                            END IF;
                                        END IF;
                                    END LOOP;
                                END IF;
                            END IF;
                        ELSIF l_tbl_configured_items(i) = pk_orders_constant.g_ds_clinical_purpose_ft
                        THEN
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                IF pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j)) =
                                   pk_orders_constant.g_ds_clinical_purpose
                                THEN
                                    l_value_aux := i_value(j) (1);
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            --Other clinical purpose  
                            IF l_value_aux = '0'
                            THEN
                                FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                                LOOP
                                    IF l_tbl_id_ds_cmpt_mkt_rel(i) = i_tbl_mkt_rel(j)
                                    THEN
                                        IF i_value(j) (1) IS NULL
                                        THEN
                                            l_ok_status := pk_orders_constant.g_component_error;
                                            EXIT;
                                        END IF;
                                    END IF;
                                END LOOP;
                            END IF;
                        ELSIF l_tbl_configured_items(i) = pk_orders_constant.g_ds_other_frequency
                        THEN
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                IF pk_orders_utils.get_ds_internal_name(i_tbl_mkt_rel(j)) =
                                   pk_orders_constant.g_ds_frequency
                                THEN
                                    l_value_aux := i_value(j) (1);
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            --OTHER FREQUENCY
                            IF l_value_aux = '-1'
                            THEN
                                FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                                LOOP
                                    IF l_tbl_id_ds_cmpt_mkt_rel(i) = i_tbl_mkt_rel(j)
                                    THEN
                                        IF i_value(j) (1) IS NULL
                                        THEN
                                            l_ok_status := pk_orders_constant.g_component_error;
                                            EXIT;
                                        END IF;
                                    END IF;
                                END LOOP;
                            END IF;
                        END IF;
                    
                        IF l_ok_status = pk_orders_constant.g_component_error
                        THEN
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        
            --Push the DS_OK_BUTTON_CONTROL element to the i_tbl_result structure, stating if the form is or isn't valid (l_ok_status)
            g_error := 'PUSHING I_TBL_RESULT';
            i_tbl_result.extend();
            i_tbl_result(i_tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => l_id_ds_cmpt_mkt_rel_ok,
                                                                   id_ds_component    => l_id_ds_component_ok,
                                                                   internal_name      => l_ds_internal_name_ok,
                                                                   VALUE              => NULL,
                                                                   value_clob         => NULL,
                                                                   min_value          => NULL,
                                                                   max_value          => NULL,
                                                                   desc_value         => NULL,
                                                                   desc_clob          => NULL,
                                                                   id_unit_measure    => NULL,
                                                                   desc_unit_measure  => NULL,
                                                                   flg_validation     => l_ok_status,
                                                                   err_msg            => NULL,
                                                                   flg_event_type     => pk_orders_constant.g_component_active,
                                                                   flg_multi_status   => NULL,
                                                                   idx                => i_idx);
        END IF;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_OK_BUTTON_CONTROL',
                                              o_error);
            RETURN FALSE;
    END get_ok_button_control;

    FUNCTION get_os_generic_task_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_OS_GENERIC_TASK_FORM_VALUES';
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    
        --Control variables to cycle through the input parameters
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_ds_internal_name   ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        --Variable to indicate if we are dealing with a new request or an edition
        l_flg_edition VARCHAR2(1) := pk_alert_constant.g_no;
    
        --Variables for the Clinical indication block
        l_clinical_indication_mandatory sys_config.value%TYPE := pk_alert_constant.g_no;
        l_clinical_purpose_mandatory    sys_config.value%TYPE := pk_alert_constant.g_no;
        l_laterality_mandatory          sys_config.value%TYPE := pk_alert_constant.g_no;
        l_flg_laterality                VARCHAR2(1 CHAR);
        l_flg_laterality_default        VARCHAR2(1 CHAR);
        l_laterality_desc               VARCHAR2(200 CHAR);
    
        --Variables for the Instructions block
        l_flg_prn                 VARCHAR2(1) := pk_alert_constant.g_no;
        l_flg_time                VARCHAR2(1 CHAR);
        l_time_desc               VARCHAR2(1000 CHAR);
        l_tbl_flg_time            table_varchar := table_varchar();
        l_tbl_next_episode        table_varchar := table_varchar();
        l_tbl_no_later_than       table_varchar := table_varchar();
        l_id_epis_to_execute      episode.id_episode%TYPE;
        l_epis_to_execute_desc    VARCHAR2(1000 CHAR);
        l_order_frequency_default sys_config.value%TYPE;
        l_dt_epis_begin           episode.dt_begin_tstz%TYPE;
        l_epis_begin_verification VARCHAR2(1 CHAR);
    
        --Recurrence variables
        l_order_recurr_desc          VARCHAR2(4000);
        l_order_recurr_option        order_recurr_plan.id_order_recurr_option%TYPE;
        l_start_date                 order_recurr_plan.start_date%TYPE;
        l_occurrences                order_recurr_plan.occurrences%TYPE;
        l_duration                   order_recurr_plan.duration%TYPE;
        l_unit_meas_duration         order_recurr_plan.id_unit_meas_duration%TYPE;
        l_end_date                   order_recurr_plan.end_date%TYPE;
        l_flg_end_by_editable        VARCHAR2(1);
        l_order_recurr_plan          order_recurr_plan.id_order_recurr_plan%TYPE;
        l_order_recurr_plan_original order_recurr_plan.id_order_recurr_plan%TYPE;
    
        l_tbl_order_recurr_plan   table_number := table_number();
        l_tbl_order_recurr_option table_number := table_number();
        l_tbl_order_recurr_desc   table_varchar := table_varchar();
        l_tbl_start_date          table_varchar := table_varchar();
        l_start_date_str          VARCHAR2(500);
        l_tbl_flg_end_by_editable table_varchar := table_varchar();
        l_end_date_str            VARCHAR2(500);
        l_tbl_occurrences         table_number := table_number();
        l_tbl_duration            table_number := table_number();
        l_tbl_duration_desc       table_varchar := table_varchar();
        l_tbl_unit_meas_duration  table_number := table_number();
        l_tbl_end_date            table_varchar := table_varchar();
    
        --Variables for the Execution block
        l_id_intervention           VARCHAR2(100 CHAR); --Dummy to fetch the lab test results for the procedures
        l_weight                    VARCHAR2(100 CHAR);
        l_analysis_result           VARCHAR2(4000 CHAR);
        l_dummy_cursor              pk_types.cursor_type;
        l_notes_tech_mandatory      sys_config.value%TYPE;
        l_notes_execution_mandatory sys_config.value%TYPE;
    
        --Supplies
        l_tbl_supply      table_varchar := table_varchar();
        l_tbl_supply_desc table_varchar := table_varchar();
        l_supply_desc     VARCHAR2(4000 CHAR) := NULL;
        l_tbl_set         table_varchar := table_varchar();
        l_tbl_quantity    table_varchar := table_varchar();
        l_tbl_dt_return   table_varchar := table_varchar();
        l_tbl_supply_loc  table_varchar := table_varchar();
    
        --Variables for the CO_SIGN block
        l_co_sign_available   VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_external_ordered_by sys_config.value%TYPE := nvl(pk_sysconfig.get_config(i_code_cf => 'EXTERNAL_ORDERED_BY_MANDATORY',
                                                                                   i_prof    => i_prof),
                                                           pk_alert_constant.g_yes);
        l_default_prof        t_tbl_core_domain;
        l_id_order_type       order_type.id_order_type%TYPE;
        l_id_default_prof     professional.id_professional%TYPE;
        l_default_prof_name   professional.name%TYPE;
        l_has_cosign_info     VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        --Variables for the Not_Ordering block
        l_flg_show_reason_not_order sys_config.value%TYPE := pk_sysconfig.get_config(i_code_cf => 'SHOW_REASON_NOT_ORDERING',
                                                                                     i_prof    => i_prof);
    
        --Variables for the Healthcare insurance block    
        l_show_healthcare_insurance sys_config.id_sys_config%TYPE := pk_sysconfig.get_config(i_code_cf => 'MCDT_HEALTH_INSURANCE',
                                                                                             i_prof    => i_prof);
        l_has_catalogue             VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
    
        l_id_market market.id_market%TYPE := pk_utils.get_institution_market(i_lang           => i_lang,
                                                                             i_id_institution => i_prof.institution);
    
        l_tbl_catalogue          t_tbl_core_domain := t_tbl_core_domain();
        l_id_catalogue_default   codification.id_codification%TYPE;
        l_desc_catalogue_default translation.desc_lang_1%TYPE;
    
        l_id_financial_entity     NUMBER(24);
        l_id_health_coverage_plan NUMBER(24);
        l_beneficiary_number      VARCHAR2(1000 CHAR);
        l_exemption_desc          VARCHAR2(1000 CHAR);
        l_id_pat_exemption        NUMBER(24);
        l_id_exemption            NUMBER(24);
        l_id_pat_health_plan      NUMBER(24);
    
        --Auxiliar variables
        l_tbl_varchar_aux table_varchar := table_varchar();
        l_varchar_aux     VARCHAR2(4000 CHAR);
        l_date_comparison VARCHAR2(1 CHAR);
    
        /*###########################################*/
        --PROCEDURES (NEW REQUEST)
        --i_tbl_data(i_idx)(1) => id_intervention
        --i_tbl_data(i_idx)(2) => id_codification
        --i_tbl_data(i_idx)(3) => flg_laterality_mcdt
    
        --IMAGING EXAMS / OTHER EXAMS (NEW REQUEST)
        --i_tbl_data(i_idx)(1) => id_exam
        --i_tbl_data(i_idx)(2) => id_codification
        --i_tbl_data(i_idx)(3) => flg_laterality_mcdt    
        --i_tbl_data(i_idx)(4) => flg_type     
    
        --LAB TESTS (NEW REQUEST)
        --i_tbl_data(i_idx)(1) => id_analysis
        --i_tbl_data(i_idx)(2) => id_sample_type
        --i_tbl_data(i_idx)(3) => flg_type (A-Analysis/G-Group)  
        --i_tbl_data(i_idx)(4) => id_group
        /*###########################################*/
    
    BEGIN
        --An nvl is performed for the sysdate in order to assure the same current date for every i_idx iteration
        g_sysdate_tstz := nvl(g_sysdate_tstz, current_timestamp);
    
        --A context variable must be created for the modal windows, called from the current form, to know the root name of the form that made the call
        --This variable should only be set for a new form or when editing (there is no need to generate it for the other submit actions)
        IF i_idx = 1
           AND (i_action <> pk_dyn_form_constant.get_submit_action OR i_action IS NULL)
        THEN
            pk_context_api.set_parameter(p_name => 'root_origin', p_value => i_root_name);
        END IF;
    
        IF i_action IS NULL
           OR i_action = -1 --NEW FORM (default values)
        THEN
            IF i_root_name = pk_orders_constant.g_ds_order_set_procedure
            THEN
                --Verify if the Healthcare insurance block should be displayed
                IF l_show_healthcare_insurance = pk_alert_constant.g_yes
                THEN
                    g_error         := 'ERROR CALLING PK_PROCEDURES_CORE.GET_PROCEDURE_CODIFICATION_LIST';
                    l_tbl_catalogue := pk_procedures_core.get_procedure_codification_list(i_lang         => i_lang,
                                                                                          i_prof         => i_prof,
                                                                                          i_intervention => i_tbl_data(i_idx) (1),
                                                                                          i_flg_default  => pk_alert_constant.g_yes);
                
                    IF l_tbl_catalogue.count > 0
                    THEN
                        l_id_catalogue_default   := to_number(l_tbl_catalogue(1).domain_value);
                        l_desc_catalogue_default := l_tbl_catalogue(1).desc_domain;
                        l_has_catalogue          := pk_alert_constant.g_yes;
                    END IF;
                END IF;
            
                --Get the default laterality
                IF i_tbl_data(i_idx) (3) NOT IN ('O', 'A')
                THEN
                    l_flg_laterality := i_tbl_data(i_idx) (3);
                
                    l_laterality_desc := pk_sysdomain.get_domain(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_code_dom      => 'INTERV_PRESC_DET.FLG_LATERALITY',
                                                                 i_val           => l_flg_laterality,
                                                                 i_dep_clin_serv => NULL);
                END IF;
            
                l_flg_laterality_default := i_tbl_data(i_idx) (3);
            ELSIF i_root_name IN
                  (pk_orders_constant.g_ds_imaging_exam_request, pk_orders_constant.g_ds_other_exam_request)
            THEN
                --Verify if the Healthcare insurance block should be displayed
                IF l_show_healthcare_insurance = pk_alert_constant.g_yes
                THEN
                    g_error         := 'ERROR CALLING PK_EXAM_CORE.GET_EXAM_CODIFICATION_LIST';
                    l_tbl_catalogue := pk_exam_core.get_exam_codification_list(i_lang        => i_lang,
                                                                               i_prof        => i_prof,
                                                                               i_exams       => i_tbl_data(i_idx) (1),
                                                                               i_flg_default => pk_alert_constant.g_yes);
                
                    IF l_tbl_catalogue.count > 0
                    THEN
                        l_id_catalogue_default   := to_number(l_tbl_catalogue(1).domain_value);
                        l_desc_catalogue_default := l_tbl_catalogue(1).desc_domain;
                        l_has_catalogue          := pk_alert_constant.g_yes;
                    END IF;
                END IF;
            
                --Get the default laterality
                IF i_tbl_data(i_idx) (3) NOT IN ('O', 'A')
                THEN
                    l_flg_laterality  := i_tbl_data(i_idx) (3);
                    l_laterality_desc := pk_sysdomain.get_domain(i_lang          => i_lang,
                                                                 i_prof          => i_prof,
                                                                 i_code_dom      => 'EXAM_REQ_DET.FLG_LATERALITY',
                                                                 i_val           => l_flg_laterality,
                                                                 i_dep_clin_serv => NULL);
                END IF;
            
                l_flg_laterality_default := i_tbl_data(i_idx) (3);
            END IF;
        
            --Obtain the SYS_CONFIGS
            IF i_root_name = pk_orders_constant.g_ds_lab_test_request
            THEN
                l_clinical_indication_mandatory := pk_sysconfig.get_config('LAB_TESTS_CLINICAL_INDICATION_MANDATORY',
                                                                           i_prof);
                l_clinical_purpose_mandatory    := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_A', i_prof);
                l_order_frequency_default       := pk_sysconfig.get_config('LAB_TESTS_ORDER_FREQUENCY_DEFAULT', i_prof);
                l_notes_execution_mandatory     := pk_sysconfig.get_config('LAB_TESTS_NOTES_TECH_MANDATORY', i_prof);
            ELSIF i_root_name = 'DS_BLOOD_PRODUCTS'
            THEN
                l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_BP', i_prof);
            ELSIF i_root_name = pk_orders_constant.g_ds_order_set_procedure
            THEN
                l_laterality_mandatory := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY', i_prof);
            ELSIF i_root_name = pk_orders_constant.g_ds_imaging_exam_request
            THEN
                l_clinical_indication_mandatory := pk_sysconfig.get_config('IMG_CLINICAL_INDICATION_MANDATORY', i_prof);
                l_clinical_purpose_mandatory    := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_I', i_prof);
                l_laterality_mandatory          := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY', i_prof);
                l_order_frequency_default       := pk_sysconfig.get_config('IMG_ORDER_FREQUENCY_DEFAULT', i_prof);
                l_notes_tech_mandatory          := pk_sysconfig.get_config('IMG_NOTES_TECH_MANDATORY', i_prof);
            ELSIF i_root_name = pk_orders_constant.g_ds_other_exam_request
            THEN
                l_clinical_indication_mandatory := pk_sysconfig.get_config('EXM_CLINICAL_INDICATION_MANDATORY', i_prof);
                l_clinical_purpose_mandatory    := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_E', i_prof);
                l_laterality_mandatory          := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY', i_prof);
                l_order_frequency_default       := pk_sysconfig.get_config('EXM_ORDER_FREQUENCY_DEFAULT', i_prof);
                l_notes_tech_mandatory          := pk_sysconfig.get_config('EXM_NOTES_TECH_MANDATORY', i_prof);
            END IF;
        
            --Obtaining the recurrence and the default values for the following fields:
            --FREQUENCY/START DATE/EXECUTIONS/DURATION/UNIT MEASURE/END DATE
            --This should only be called for the first iteration (i_idx=1)   
            IF i_action IS NULL
               AND i_idx = 1
            THEN
                g_error := 'ERROR CALLING PK_ORDER_RECURRENCE_CORE.CREATE_ORDER_RECURR_PLAN';
                IF NOT pk_order_recurrence_core.create_order_recurr_plan(i_lang                => i_lang,
                                                                         i_prof                => i_prof,
                                                                         i_order_recurr_area   => CASE i_root_name
                                                                                                      WHEN 'DS_BLOOD_PRODUCTS' THEN
                                                                                                       'BLOOD_PRODUCTS'
                                                                                                      WHEN
                                                                                                       pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                       'LAB_TEST'
                                                                                                      WHEN
                                                                                                       pk_orders_constant.g_ds_imaging_exam_request THEN
                                                                                                       'IMAGE_EXAM'
                                                                                                      WHEN
                                                                                                       pk_orders_constant.g_ds_other_exam_request THEN
                                                                                                       'OTHER_EXAM'
                                                                                                      WHEN
                                                                                                       pk_orders_constant.g_ds_order_set_procedure THEN
                                                                                                       'PROCEDURE'
                                                                                                  END,
                                                                         o_order_recurr_desc   => l_order_recurr_desc,
                                                                         o_order_recurr_option => l_order_recurr_option,
                                                                         o_start_date          => l_start_date,
                                                                         o_occurrences         => l_occurrences,
                                                                         o_duration            => l_duration,
                                                                         o_unit_meas_duration  => l_unit_meas_duration,
                                                                         o_end_date            => l_end_date,
                                                                         o_flg_end_by_editable => l_flg_end_by_editable,
                                                                         o_order_recurr_plan   => l_order_recurr_plan,
                                                                         o_error               => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                l_order_recurr_plan_original := l_order_recurr_plan;
            
                --The recurrence id is only generated for the 1st record, therefore,
                --it is necessary to store this variable in a context variable,
                --this way, the subsequent records (i_idx > 1) will have access to this variable
                pk_context_api.set_parameter(p_name  => 'l_order_recurr_plan_original',
                                             p_value => l_order_recurr_plan_original);
            
                --Verify if the user needs co_sign to perform the request
                --The verification is only performed for the first record, the remaining records use the context variable
                --If there is no need for co_sign, the block will remain hidden
                g_error := 'ERROR CALLING PK_CO_SIGN_UX.CHECK_PROF_NEEDS_COSIGN_ORDER';
                IF NOT pk_co_sign_ux.check_prof_needs_cosign_order(i_lang                 => i_lang,
                                                                   i_prof                 => i_prof,
                                                                   i_episode              => i_episode,
                                                                   i_task_type            => CASE i_root_name
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                  11
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_order_set_procedure THEN
                                                                                                  43
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_imaging_exam_request THEN
                                                                                                  7
                                                                                                 WHEN
                                                                                                  pk_orders_constant.g_ds_other_exam_request THEN
                                                                                                  8
                                                                                             END,
                                                                   o_flg_prof_need_cosign => l_co_sign_available,
                                                                   o_error                => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            
                pk_context_api.set_parameter(p_name => 'l_co_sign_available', p_value => l_co_sign_available);
            ELSIF i_idx > 1
            THEN
                --For the subsequent iterations (i_idx > 1) it is necessary to obtain the id_order_recurrence from the first iteration
                l_order_recurr_plan_original := alert_context('l_order_recurr_plan_original');
            
                IF l_order_recurr_plan_original IS NOT NULL
                THEN
                    g_error := 'ERROR CALLING PK_ORDER_RECURRENCE_CORE.COPY_ORDER_RECURR_PLAN';
                    IF NOT pk_order_recurrence_core.copy_order_recurr_plan(i_lang                   => i_lang,
                                                                           i_prof                   => i_prof,
                                                                           i_order_recurr_plan_from => l_order_recurr_plan_original,
                                                                           o_order_recurr_desc      => l_order_recurr_desc,
                                                                           o_order_recurr_option    => l_order_recurr_option,
                                                                           o_start_date             => l_start_date,
                                                                           o_occurrences            => l_occurrences,
                                                                           o_duration               => l_duration,
                                                                           o_unit_meas_duration     => l_unit_meas_duration,
                                                                           o_end_date               => l_end_date,
                                                                           o_flg_end_by_editable    => l_flg_end_by_editable,
                                                                           o_order_recurr_plan      => l_order_recurr_plan,
                                                                           o_error                  => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                --Verify if the user needs co_sign to perform the request (value calculated for i_idx = 1)
                l_co_sign_available := alert_context('l_co_sign_available');
            END IF;
        
            --Get the default option for the 'To execute' list 
            --The id_order_recurr_plan will indicate the area to where the form belongs (procedures, lab tests, etc.)
            g_error := 'CALLING  - i_id_order_recurr_plan: ' || l_order_recurr_plan_original;
            BEGIN
                SELECT /*+opt_estimate (table t rows=1)*/
                 t.domain_value, t.desc_domain
                  INTO l_flg_time, l_time_desc
                  FROM TABLE(pk_orders_utils.get_time_list(i_lang                 => i_lang,
                                                           i_prof                 => i_prof,
                                                           i_id_episode           => i_episode,
                                                           i_id_order_recurr_plan => l_order_recurr_plan_original,
                                                           i_flg_default          => pk_alert_constant.g_yes)) t;
            EXCEPTION
                WHEN OTHERS THEN
                    l_flg_time  := NULL;
                    l_time_desc := NULL;
            END;
        
            --Data for the tbl_records field
            --It's considered that the first value of each subarray are the ones to be stored.
            --Its purpose it's to be used for the Place and Catalog            
            --Procedures => id_intervention
            --Imaging/Other exams => id_exam            
            --Lab tests => id_analysis
            FOR i IN i_tbl_data.first .. i_tbl_data.last
            LOOP
                l_tbl_varchar_aux.extend;
                l_tbl_varchar_aux(l_tbl_varchar_aux.count) := i_tbl_data(i) (1);
            END LOOP;
        
            --Insert the default values in the return variable (tbl_result)
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE
                                                                  WHEN t.internal_name_child IN (pk_orders_constant.g_ds_laterality) THEN
                                                                  --Default value to be shown on the form. (It should only be displayed if
                                                                  --the value is different than 'O' or 'A')
                                                                   l_flg_laterality
                                                                  WHEN t.internal_name_child IN (pk_orders_constant.g_ds_default_laterality) THEN
                                                                  --Auxiliar variable to list the options from the laterality multichoice (pk_mcdt.get_laterality_all)
                                                                  --When the value is 'O' all options should be listed, when it's 'R' only the 'Right' option
                                                                 --should be listed, etc.
                                                                 --For multiple records, the list is be an intersection of all values.
                                                                  l_flg_laterality_default
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                                  l_flg_time
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                                  decode(l_order_frequency_default, pk_alert_constant.g_no, NULL, to_char(l_order_recurr_option))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_executions THEN
                                                                  to_char(l_occurrences)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_duration THEN
                                                                  CASE
                                                                      WHEN l_duration IS NOT NULL THEN
                                                                       to_char(l_duration)
                                                                      ELSE
                                                                       NULL
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_end_date THEN
                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_end_date, i_prof => i_prof)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                                  to_char(l_id_catalogue_default)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                                  to_char(l_id_financial_entity)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                                  to_char(l_id_pat_health_plan)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                                  to_char(l_beneficiary_number)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                                  to_char(l_id_exemption)
                                                             --DUMMY FIELDS
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_dummy_number THEN
                                                                  to_char(l_order_recurr_plan)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_flg_edition THEN
                                                                  l_flg_edition
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_root_name THEN
                                                                  i_root_name
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_co_sign_control THEN
                                                                  l_co_sign_available
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_healthcare_insurance_cat_control THEN
                                                                  l_show_healthcare_insurance
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_tbl_records THEN
                                                                  (SELECT listagg(t.column_value, '|') /*+opt_estimate(table t rows=1)*/
                                                                     FROM TABLE(l_tbl_varchar_aux) t)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_flg_time THEN
                                                                  l_flg_time
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_has_catalogue THEN
                                                                  l_has_catalogue
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_laterality THEN
                                                                  l_laterality_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                                  l_time_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                                  decode(l_order_frequency_default, pk_alert_constant.g_no, NULL, to_char(l_order_recurr_desc))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_executions THEN
                                                                  to_char(l_occurrences)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_duration THEN
                                                                  CASE
                                                                      WHEN l_duration IS NOT NULL THEN
                                                                       to_char(l_duration) ||
                                                                       pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                    i_prof         => i_prof,
                                                                                                                    i_unit_measure => l_unit_meas_duration)
                                                                      ELSE
                                                                       NULL
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_end_date THEN
                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_end_date, i_prof => i_prof)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                                  l_desc_catalogue_default
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_financial_entity THEN
                                                                  decode(l_id_pat_health_plan,
                                                                         NULL,
                                                                         NULL,
                                                                         pk_adt.get_pat_health_plan_info(i_lang, i_prof, l_id_pat_health_plan, 'F'))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_coverage_plan THEN
                                                                  decode(l_id_pat_health_plan,
                                                                         NULL,
                                                                         NULL,
                                                                         pk_adt.get_pat_health_plan_info(i_lang, i_prof, l_id_pat_health_plan, 'H'))
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_health_plan_number THEN
                                                                  to_char(l_beneficiary_number)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_exemption THEN
                                                                  l_exemption_desc
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE
                                                             --Clinical indication
                                                                 WHEN t.internal_name_child IN
                                                                      (pk_orders_constant.g_ds_clinical_indication_ft,
                                                                       pk_orders_constant.g_ds_clinical_indication_mw) THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child IN (pk_orders_constant.g_ds_clinical_purpose) THEN
                                                                  CASE l_clinical_purpose_mandatory
                                                                      WHEN pk_alert_constant.g_yes THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      ELSE
                                                                       pk_orders_constant.g_component_active
                                                                  END
                                                                 WHEN t.internal_name_child IN (pk_orders_constant.g_ds_laterality) THEN
                                                                  CASE l_laterality_mandatory
                                                                      WHEN pk_alert_constant.g_yes THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      ELSE
                                                                       CASE i_root_name
                                                                           WHEN pk_orders_constant.g_ds_lab_test_request THEN
                                                                            pk_orders_constant.g_component_hidden
                                                                           ELSE
                                                                            pk_orders_constant.g_component_active
                                                                       END
                                                                  END
                                                             --Instructions
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_to_execute_list THEN
                                                                  pk_orders_constant.g_component_read_only
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_frequency THEN
                                                                  pk_orders_constant.g_component_mandatory
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_start_date THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child IN
                                                                      (pk_orders_constant.g_ds_duration, pk_orders_constant.g_ds_end_date) THEN
                                                                 --If l_flg_end_by_editable = 'N', fields duration and end date must be inactive
                                                                  decode(l_flg_end_by_editable,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_active,
                                                                         pk_orders_constant.g_component_inactive)
                                                                 WHEN t.internal_name_child IN (pk_orders_constant.g_ds_executions) THEN
                                                                 --If l_flg_end_by_editable = 'N', field 'Exections' must be Read Only and present the value given by l_occurrences
                                                                  decode(l_flg_end_by_editable,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_active,
                                                                         pk_orders_constant.g_component_read_only)
                                                             --Execution                                                                          
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_execution_ordered_at THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_lab_test_result THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_weight_kg THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_scheduling_notes THEN
                                                                  CASE
                                                                      WHEN l_flg_time = pk_alert_constant.g_flg_time_e THEN
                                                                       pk_orders_constant.g_component_inactive
                                                                      ELSE
                                                                       pk_orders_constant.g_component_active
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes_technician THEN
                                                                  decode(l_notes_tech_mandatory,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_mandatory,
                                                                         pk_orders_constant.g_component_active)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes_execution THEN
                                                                  decode(l_notes_execution_mandatory,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_mandatory,
                                                                         pk_orders_constant.g_component_active)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_catalogue THEN
                                                                  decode(l_has_catalogue,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_active,
                                                                         pk_orders_constant.g_component_hidden)
                                                                 WHEN t.internal_name_child IN (pk_orders_constant.g_ds_health_plan_number,
                                                                                                pk_orders_constant.g_ds_financial_entity,
                                                                                                pk_orders_constant.g_ds_health_coverage_plan,
                                                                                                pk_orders_constant.g_ds_exemption) THEN
                                                                  pk_orders_constant.g_component_inactive
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_start_date THEN
                                                                  CASE
                                                                      WHEN l_flg_time IN (pk_alert_constant.g_flg_time_b, pk_alert_constant.g_flg_time_n) THEN
                                                                       pk_orders_constant.g_component_active
                                                                      ELSE
                                                                       pk_orders_constant.g_component_mandatory
                                                                  END
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_reason_not_ordering THEN
                                                                  decode(l_flg_show_reason_not_order,
                                                                         pk_alert_constant.g_yes,
                                                                         pk_orders_constant.g_component_active,
                                                                         pk_orders_constant.g_component_hidden)
                                                                 ELSE
                                                                  pk_orders_constant.g_component_active
                                                             END,
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN ( --Clinical indication block
                                       pk_orders_constant.g_ds_clinical_indication_ft,
                                       pk_orders_constant.g_ds_clinical_indication_mw,
                                       pk_orders_constant.g_ds_clinical_purpose,
                                       pk_orders_constant.g_ds_laterality,
                                       pk_orders_constant.g_ds_default_laterality,
                                       --Instructions block
                                       pk_orders_constant.g_ds_to_execute_list,
                                       pk_orders_constant.g_ds_frequency,
                                       pk_orders_constant.g_ds_start_date,
                                       pk_orders_constant.g_ds_executions,
                                       pk_orders_constant.g_ds_duration,
                                       pk_orders_constant.g_ds_end_date,
                                       --Execution block
                                       pk_orders_constant.g_ds_execution_ordered_at,
                                       pk_orders_constant.g_ds_lab_test_result,
                                       pk_orders_constant.g_ds_weight_kg,
                                       pk_orders_constant.g_ds_scheduling_notes,
                                       pk_orders_constant.g_ds_reason_not_ordering,
                                       pk_orders_constant.g_ds_notes_technician,
                                       pk_orders_constant.g_ds_notes_execution,
                                       --Health care insurrance block
                                       pk_orders_constant.g_ds_catalogue,
                                       pk_orders_constant.g_ds_health_plan_number,
                                       pk_orders_constant.g_ds_financial_entity,
                                       pk_orders_constant.g_ds_health_coverage_plan,
                                       pk_orders_constant.g_ds_exemption,
                                       --Hidden fields (Memory)
                                       pk_orders_constant.g_ds_root_name,
                                       pk_orders_constant.g_ds_dummy_number, -- this field holds the id_order_recurr_plan
                                       pk_orders_constant.g_ds_flg_edition, --Indicates if it is a new record or an edition
                                       pk_orders_constant.g_ds_tbl_records,
                                       pk_orders_constant.g_ds_flg_time,
                                       pk_orders_constant.g_ds_date_dummy,
                                       pk_orders_constant.g_ds_no_later_than,
                                       pk_orders_constant.g_ds_next_episode_id,
                                       pk_orders_constant.g_ds_has_catalogue)
                  --HIDDEN SECTIONS (HEALTHCARE)
                OR (d.internal_name IN (pk_orders_constant.g_ds_healthcare_insurance_cat_control,
                                        pk_orders_constant.g_ds_healthcare_insurance_control) AND i_idx = 1)
             ORDER BY t.rn;
        
            --GETTING DEFAULT VALUES FOR ELEMENTS THAT ARE SPECIFIC TO THE ROOT
            IF i_root_name IN (pk_orders_constant.g_ds_lab_test_request)
            THEN
                g_error := 'ERROR CALLING PK_LAB_TESTS_CORE.GET_LAB_TEST_DEFAULT_VALUES';
                IF NOT pk_lab_tests_core.get_lab_test_default_values(i_lang           => i_lang,
                                                                     i_prof           => i_prof,
                                                                     i_episode        => i_episode,
                                                                     i_patient        => i_patient,
                                                                     i_action         => i_action,
                                                                     i_root_name      => i_root_name,
                                                                     i_curr_component => i_curr_component,
                                                                     i_idx            => i_idx,
                                                                     i_tbl_id_pk      => i_tbl_id_pk,
                                                                     i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                                     i_tbl_int_name   => i_tbl_int_name,
                                                                     i_value          => i_value,
                                                                     i_value_desc     => i_value_desc,
                                                                     i_tbl_data       => i_tbl_data,
                                                                     i_value_clob     => i_value_clob,
                                                                     i_tbl_result     => tbl_result,
                                                                     o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            ELSIF i_root_name IN
                  (pk_orders_constant.g_ds_imaging_exam_request, pk_orders_constant.g_ds_other_exam_request)
            THEN
                g_error := 'ERROR CALLING PK_EXAM_CORE.GET_EXAM_DEFAULT_VALUES';
                IF NOT pk_exam_core.get_exam_default_values(i_lang           => i_lang,
                                                            i_prof           => i_prof,
                                                            i_episode        => i_episode,
                                                            i_patient        => i_patient,
                                                            i_action         => i_action,
                                                            i_root_name      => i_root_name,
                                                            i_curr_component => i_curr_component,
                                                            i_idx            => i_idx,
                                                            i_tbl_id_pk      => i_tbl_id_pk,
                                                            i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                            i_tbl_int_name   => i_tbl_int_name,
                                                            i_value          => i_value,
                                                            i_value_desc     => i_value_desc,
                                                            i_tbl_data       => i_tbl_data,
                                                            i_value_clob     => i_value_clob,
                                                            i_tbl_result     => tbl_result,
                                                            o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            ELSIF i_root_name = pk_orders_constant.g_ds_order_set_procedure
            THEN
                g_error := 'ERROR CALLING PK_PROCEDURES_CORE.GET_PROCEDURE_DEFAULT_VALUES';
                IF NOT pk_procedures_core.get_procedure_default_values(i_lang           => i_lang,
                                                                       i_prof           => i_prof,
                                                                       i_episode        => i_episode,
                                                                       i_patient        => i_patient,
                                                                       i_action         => i_action,
                                                                       i_root_name      => i_root_name,
                                                                       i_curr_component => i_curr_component,
                                                                       i_idx            => i_idx,
                                                                       i_tbl_id_pk      => i_tbl_id_pk,
                                                                       i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                                       i_tbl_int_name   => i_tbl_int_name,
                                                                       i_value          => i_value,
                                                                       i_value_desc     => i_value_desc,
                                                                       i_tbl_data       => i_tbl_data,
                                                                       i_value_clob     => i_value_clob,
                                                                       i_tbl_result     => tbl_result,
                                                                       o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            --Action of submiting a value on any given element of the form
            --IMPORTANT: In order for this action to be executed, a submit action must be configured in ds_event for the given field,
            --otherwise, the i_curr_component is null.
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_prn
                THEN
                    --When changing the PRN value, the fields Frequency, Start date, Executions, Duration 
                    --and End date may change their status (active/inactive)
                    --Also, for each change, the function pk_order_recurrence_api_ux.set_order_recurr_option (for new requests)                    
                    --or pk_order_recurrence_api_ux.edit_order_recurr_plan(for editions) must be called                  
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        l_ds_internal_name := i_tbl_int_name(i);
                    
                        IF l_ds_internal_name = pk_orders_constant.g_ds_dummy_number
                        THEN
                            l_tbl_order_recurr_plan.extend();
                            l_tbl_order_recurr_plan(l_tbl_order_recurr_plan.count) := to_number(i_value(i) (1));
                        
                            l_tbl_order_recurr_option.extend();
                            l_tbl_order_recurr_option(l_tbl_order_recurr_option.count) := 0;
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                l_ds_internal_name := i_tbl_int_name(j);
                            
                                IF l_ds_internal_name = pk_orders_constant.g_ds_flg_edition
                                THEN
                                    l_flg_edition := i_value(j) (1);
                                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_start_date
                                THEN
                                    l_start_date_str := to_char(i_value(j) (1));
                                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_executions
                                THEN
                                    l_occurrences := to_char(i_value(j) (1));
                                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_duration
                                THEN
                                    l_duration           := to_char(i_value(j) (1));
                                    l_unit_meas_duration := to_number(i_value_mea(j) (1));
                                ELSIF l_ds_internal_name = pk_orders_constant.g_ds_end_date
                                THEN
                                    l_end_date_str := to_char(i_value(j) (1));
                                END IF;
                            END LOOP;
                        
                            IF l_flg_edition = pk_alert_constant.g_no
                            THEN
                                IF NOT
                                    pk_order_recurrence_api_ux.set_order_recurr_option(i_lang                => i_lang,
                                                                                       i_prof                => i_prof,
                                                                                       i_order_recurr_plan   => l_tbl_order_recurr_plan,
                                                                                       i_order_recurr_option => l_tbl_order_recurr_option,
                                                                                       o_order_recurr_desc   => l_tbl_order_recurr_desc,
                                                                                       o_order_recurr_option => l_tbl_order_recurr_option,
                                                                                       o_start_date          => l_tbl_start_date,
                                                                                       o_occurrences         => l_tbl_occurrences,
                                                                                       o_duration            => l_tbl_duration,
                                                                                       o_unit_meas_duration  => l_tbl_unit_meas_duration,
                                                                                       o_duration_desc       => l_tbl_duration_desc,
                                                                                       o_end_date            => l_tbl_end_date,
                                                                                       o_flg_end_by_editable => l_tbl_flg_end_by_editable,
                                                                                       o_order_recurr_plan   => l_tbl_order_recurr_plan,
                                                                                       o_error               => o_error)
                                THEN
                                    RAISE g_other_exception;
                                END IF;
                            ELSE
                                l_tbl_order_recurr_desc.extend();
                                l_tbl_order_recurr_option.extend();
                                l_tbl_start_date.extend();
                                l_tbl_occurrences.extend();
                                l_tbl_duration.extend();
                                l_tbl_unit_meas_duration.extend();
                                l_tbl_duration_desc.extend();
                                l_tbl_end_date.extend();
                                l_tbl_flg_end_by_editable.extend();
                            
                                IF NOT
                                    pk_order_recurrence_api_ux.edit_order_recurr_plan(i_lang                   => i_lang,
                                                                                      i_prof                   => i_prof,
                                                                                      i_order_recurr_area      => CASE
                                                                                                                   i_root_name
                                                                                                                      WHEN
                                                                                                                       'DS_BLOOD_PRODUCTS' THEN
                                                                                                                       'BLOOD_PRODUCTS'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_health_education_order THEN
                                                                                                                       'PATIENT_EDUCATION'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                                       'LAB_TEST'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_imaging_exam_request THEN
                                                                                                                       'IMAGE_EXAM'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_other_exam_request THEN
                                                                                                                       'OTHER_EXAM'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_order_set_procedure THEN
                                                                                                                       'PROCEDURE'
                                                                                                                  END,
                                                                                      i_order_recurr_option    => l_tbl_order_recurr_option(1),
                                                                                      i_start_date             => l_start_date_str,
                                                                                      i_occurrences            => l_occurrences,
                                                                                      i_duration               => l_duration,
                                                                                      i_unit_meas_duration     => l_unit_meas_duration,
                                                                                      i_end_date               => l_end_date_str,
                                                                                      i_order_recurr_plan_from => l_tbl_order_recurr_plan(1),
                                                                                      o_order_recurr_desc      => l_tbl_order_recurr_desc(1),
                                                                                      o_order_recurr_option    => l_tbl_order_recurr_option(1),
                                                                                      o_start_date             => l_tbl_start_date(1),
                                                                                      o_occurrences            => l_tbl_occurrences(1),
                                                                                      o_duration               => l_tbl_duration(1),
                                                                                      o_unit_meas_duration     => l_tbl_unit_meas_duration(1),
                                                                                      o_duration_desc          => l_tbl_duration_desc(1),
                                                                                      o_end_date               => l_tbl_end_date(1),
                                                                                      o_flg_end_by_editable    => l_tbl_flg_end_by_editable(1),
                                                                                      o_order_recurr_plan      => l_tbl_order_recurr_plan(1),
                                                                                      o_error                  => o_error)
                                THEN
                                    RAISE g_other_exception;
                                END IF;
                            END IF;
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_prn
                        THEN
                            l_flg_prn := i_value(i) (1);
                        END IF;
                    END LOOP;
                
                    --After obtaining the data from the recurrence apis, it is necessary to fill the related fields
                    --(Frequency/Start date/Execution/Duration/End date)                
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        l_ds_internal_name := i_tbl_int_name(i);
                    
                        IF l_ds_internal_name = pk_orders_constant.g_ds_frequency
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_order_recurr_option(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_order_recurr_desc(1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_flg_prn
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_read_only
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name IN
                              (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_date_dummy)
                              AND i_episode IS NOT NULL
                        THEN
                            FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                            LOOP
                                IF i_tbl_int_name(j) = pk_orders_constant.g_ds_to_execute_list
                                THEN
                                    l_flg_time := i_value(j) (1);
                                    EXIT;
                                END IF;
                            END LOOP;
                        
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => CASE
                                                                                                         WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                          NULL
                                                                                                         ELSE
                                                                                                          pk_date_utils.trunc_insttimezone_str(i_prof,
                                                                                                                                               pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                             i_prof,
                                                                                                                                                                             l_tbl_start_date(1),
                                                                                                                                                                             NULL),
                                                                                                                                               'MI')
                                                                                                     END,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_ds_internal_name
                                                                                                         WHEN pk_orders_constant.g_ds_date_dummy THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          CASE l_flg_prn
                                                                                                              WHEN pk_alert_constant.g_yes THEN
                                                                                                               pk_orders_constant.g_component_read_only
                                                                                                              ELSE
                                                                                                               CASE
                                                                                                                   WHEN l_flg_time = pk_alert_constant.g_flg_time_b THEN
                                                                                                                    pk_orders_constant.g_component_active
                                                                                                                   WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                                    pk_orders_constant.g_component_inactive
                                                                                                                   ELSE
                                                                                                                    pk_orders_constant.g_component_mandatory
                                                                                                               END
                                                                                                          END
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_executions
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_occurrences(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_occurrences(1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_flg_prn
                                                                                                         WHEN pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_read_only
                                                                                                         ELSE
                                                                                                          CASE
                                                                                                              WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                               pk_orders_constant.g_component_active
                                                                                                              ELSE
                                                                                                               pk_orders_constant.g_component_read_only
                                                                                                          END
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_duration
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_duration(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => CASE
                                                                                                         WHEN l_tbl_duration_desc(1) IS NOT NULL THEN
                                                                                                          l_tbl_duration_desc(1) || ' ' ||
                                                                                                          pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                       i_prof,
                                                                                                                                                       l_tbl_unit_meas_duration(1))
                                                                                                     END,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => l_tbl_unit_meas_duration(1),
                                                                               desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                  i_prof,
                                                                                                                                                  l_tbl_unit_meas_duration(1)),
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_end_date
                              AND i_episode IS NOT NULL
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_end_date(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_dummy_number
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_order_recurr_plan(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name IN (pk_orders_constant.g_ds_frequency,
                                               pk_orders_constant.g_ds_other_frequency,
                                               pk_orders_constant.g_ds_executions,
                                               pk_orders_constant.g_ds_duration,
                                               pk_orders_constant.g_ds_to_execute_list)
                      OR
                      (l_curr_comp_int_name IN (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_end_date) AND
                      i_episode IS NOT NULL)
                THEN
                    --Obtain the id order recurr plan which is stored in DS_DUMMY_NUMBER element
                    --DS_DUMMY_NUMBER is an hidden field of the form. The reccurence id is stored in this element
                    --when the form is initialized
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_dummy_number
                        THEN
                            l_tbl_order_recurr_plan.extend();
                            l_tbl_order_recurr_plan(l_tbl_order_recurr_plan.count) := to_number(i_value(i) (1));
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                IF i_tbl_int_name(j) = pk_orders_constant.g_ds_flg_edition
                                THEN
                                    l_flg_edition := i_value(j) (1);
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_frequency
                                THEN
                                    l_order_recurr_option := to_number(i_value(j) (1));
                                
                                    l_tbl_order_recurr_option.extend();
                                    l_tbl_order_recurr_option(l_tbl_order_recurr_option.count) := to_number(i_value(j) (1));
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_start_date
                                      AND l_curr_comp_int_name <> pk_orders_constant.g_ds_to_execute_list
                                THEN
                                    l_start_date_str := to_char(i_value(j) (1));
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_start_date
                                      AND l_curr_comp_int_name = pk_orders_constant.g_ds_to_execute_list
                                THEN
                                    SELECT pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                       i_date => orp.start_date,
                                                                       i_inst => i_prof.institution,
                                                                       i_soft => i_prof.software)
                                      INTO l_start_date_str
                                      FROM order_recurr_plan orp
                                     WHERE orp.id_order_recurr_plan =
                                           l_tbl_order_recurr_plan(l_tbl_order_recurr_plan.count);
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_executions
                                THEN
                                    l_occurrences := to_char(i_value(j) (1));
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_duration
                                THEN
                                    l_duration           := to_char(i_value(j) (1));
                                    l_unit_meas_duration := to_number(i_value_mea(j) (1));
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_end_date
                                THEN
                                    l_end_date_str := to_char(i_value(j) (1));
                                END IF;
                            END LOOP;
                        
                            IF l_flg_edition = pk_alert_constant.g_no
                            THEN
                                IF l_curr_comp_int_name IN
                                   (pk_orders_constant.g_ds_frequency, pk_orders_constant.g_ds_other_frequency)
                                THEN
                                    IF l_order_recurr_option <> -1 --When frequency is not set as 'Other frequency'
                                    THEN
                                        IF NOT
                                            pk_order_recurrence_api_ux.set_order_recurr_option(i_lang                => i_lang,
                                                                                               i_prof                => i_prof,
                                                                                               i_order_recurr_plan   => l_tbl_order_recurr_plan,
                                                                                               i_order_recurr_option => l_tbl_order_recurr_option,
                                                                                               o_order_recurr_desc   => l_tbl_order_recurr_desc,
                                                                                               o_order_recurr_option => l_tbl_order_recurr_option,
                                                                                               o_start_date          => l_tbl_start_date,
                                                                                               o_occurrences         => l_tbl_occurrences,
                                                                                               o_duration            => l_tbl_duration,
                                                                                               o_unit_meas_duration  => l_tbl_unit_meas_duration,
                                                                                               o_duration_desc       => l_tbl_duration_desc,
                                                                                               o_end_date            => l_tbl_end_date,
                                                                                               o_flg_end_by_editable => l_tbl_flg_end_by_editable,
                                                                                               o_order_recurr_plan   => l_tbl_order_recurr_plan,
                                                                                               o_error               => o_error)
                                        THEN
                                            RAISE g_other_exception;
                                        END IF;
                                    ELSE
                                        --Frequency set as 'Other frequency'
                                        l_tbl_order_recurr_desc.extend();
                                        l_tbl_order_recurr_option.extend();
                                        l_tbl_start_date.extend();
                                        l_tbl_occurrences.extend();
                                        l_tbl_duration.extend();
                                        l_tbl_unit_meas_duration.extend();
                                        l_tbl_duration_desc.extend();
                                        l_tbl_end_date.extend();
                                        l_tbl_flg_end_by_editable.extend();
                                    
                                        IF NOT
                                            pk_order_recurrence_core.get_order_recurr_instructions(i_lang                => i_lang,
                                                                                                   i_prof                => i_prof,
                                                                                                   i_order_plan          => l_tbl_order_recurr_plan(1),
                                                                                                   o_order_recurr_desc   => l_tbl_order_recurr_desc(1),
                                                                                                   o_order_recurr_option => l_tbl_order_recurr_option(1),
                                                                                                   o_start_date          => l_start_date,
                                                                                                   o_occurrences         => l_tbl_occurrences(1),
                                                                                                   o_duration            => l_tbl_duration(1),
                                                                                                   o_unit_meas_duration  => l_tbl_unit_meas_duration(1),
                                                                                                   o_end_date            => l_end_date,
                                                                                                   o_flg_end_by_editable => l_tbl_flg_end_by_editable(1),
                                                                                                   o_error               => o_error)
                                        THEN
                                            g_error := 'error while calling get_order_recurr_instructions function';
                                            RAISE g_other_exception;
                                        END IF;
                                    
                                        --Function pk_order_recurrence_core.get_order_recurr_instructions returns the dates as timestamp
                                        --It is necessary to convert them as string
                                        l_tbl_start_date(1) := pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                           i_date => l_start_date,
                                                                                           i_prof => i_prof);
                                        l_tbl_end_date(1) := pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                         i_date => l_end_date,
                                                                                         i_prof => i_prof);
                                    
                                        FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                                        LOOP
                                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_frequency
                                            THEN
                                                l_order_recurr_option := to_number(i_value(j) (1));
                                                l_order_recurr_desc   := i_value_desc(j) (1);
                                            END IF;
                                        END LOOP;
                                    END IF;
                                ELSE
                                    l_tbl_order_recurr_desc.extend();
                                    l_tbl_order_recurr_option.extend();
                                    l_tbl_start_date.extend();
                                    l_tbl_occurrences.extend();
                                    l_tbl_duration.extend();
                                    l_tbl_unit_meas_duration.extend();
                                    l_tbl_duration_desc.extend();
                                    l_tbl_end_date.extend();
                                    l_tbl_flg_end_by_editable.extend();
                                    l_tbl_order_recurr_plan.extend();
                                
                                    IF NOT
                                        pk_order_recurrence_api_ux.set_order_recurr_instructions(i_lang                => i_lang,
                                                                                                 i_prof                => i_prof,
                                                                                                 i_order_recurr_plan   => l_tbl_order_recurr_plan(1),
                                                                                                 i_start_date          => l_start_date_str,
                                                                                                 i_occurrences         => CASE
                                                                                                                           l_curr_comp_int_name
                                                                                                                              WHEN
                                                                                                                               pk_orders_constant.g_ds_executions THEN
                                                                                                                               l_occurrences
                                                                                                                          END,
                                                                                                 i_duration            => CASE
                                                                                                                           l_curr_comp_int_name
                                                                                                                              WHEN
                                                                                                                               pk_orders_constant.g_ds_duration THEN
                                                                                                                               l_duration
                                                                                                                          END,
                                                                                                 i_unit_meas_duration  => CASE
                                                                                                                           l_curr_comp_int_name
                                                                                                                              WHEN
                                                                                                                               pk_orders_constant.g_ds_duration THEN
                                                                                                                               l_unit_meas_duration
                                                                                                                          END,
                                                                                                 i_end_date            => CASE
                                                                                                                           l_curr_comp_int_name
                                                                                                                              WHEN
                                                                                                                               pk_orders_constant.g_ds_end_date THEN
                                                                                                                               l_end_date_str
                                                                                                                          END,
                                                                                                 o_order_recurr_desc   => l_tbl_order_recurr_desc(1),
                                                                                                 o_order_recurr_option => l_tbl_order_recurr_option(1),
                                                                                                 o_start_date          => l_tbl_start_date(1),
                                                                                                 o_occurrences         => l_tbl_occurrences(1),
                                                                                                 o_duration            => l_tbl_duration(1),
                                                                                                 o_unit_meas_duration  => l_tbl_unit_meas_duration(1),
                                                                                                 o_duration_desc       => l_tbl_duration_desc(1),
                                                                                                 o_end_date            => l_tbl_end_date(1),
                                                                                                 o_flg_end_by_editable => l_tbl_flg_end_by_editable(1),
                                                                                                 o_order_recurr_plan   => l_tbl_order_recurr_plan(1),
                                                                                                 o_error               => o_error)
                                    THEN
                                        RAISE g_other_exception;
                                    END IF;
                                END IF;
                            ELSE
                                l_tbl_order_recurr_desc.extend();
                                l_tbl_order_recurr_option.extend();
                                l_tbl_start_date.extend();
                                l_tbl_occurrences.extend();
                                l_tbl_duration.extend();
                                l_tbl_unit_meas_duration.extend();
                                l_tbl_duration_desc.extend();
                                l_tbl_end_date.extend();
                                l_tbl_flg_end_by_editable.extend();
                            
                                IF NOT
                                    pk_order_recurrence_api_ux.edit_order_recurr_plan(i_lang                   => i_lang,
                                                                                      i_prof                   => i_prof,
                                                                                      i_order_recurr_area      => CASE
                                                                                                                   i_root_name
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                                       'LAB_TEST'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_imaging_exam_request THEN
                                                                                                                       'IMAGE_EXAM'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_other_exam_request THEN
                                                                                                                       'OTHER_EXAM'
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_order_set_procedure THEN
                                                                                                                       'PROCEDURE'
                                                                                                                  END,
                                                                                      i_order_recurr_option    => l_tbl_order_recurr_option(1),
                                                                                      i_start_date             => l_start_date_str,
                                                                                      i_occurrences            => CASE
                                                                                                                   l_curr_comp_int_name
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_executions THEN
                                                                                                                       l_occurrences
                                                                                                                      ELSE
                                                                                                                       NULL
                                                                                                                  END,
                                                                                      i_duration               => CASE
                                                                                                                   l_curr_comp_int_name
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_duration THEN
                                                                                                                       l_duration
                                                                                                                      ELSE
                                                                                                                       NULL
                                                                                                                  END,
                                                                                      i_unit_meas_duration     => CASE
                                                                                                                   l_curr_comp_int_name
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_duration THEN
                                                                                                                       l_unit_meas_duration
                                                                                                                      ELSE
                                                                                                                       NULL
                                                                                                                  END,
                                                                                      i_end_date               => CASE
                                                                                                                   l_curr_comp_int_name
                                                                                                                      WHEN
                                                                                                                       pk_orders_constant.g_ds_end_date THEN
                                                                                                                       l_end_date_str
                                                                                                                      ELSE
                                                                                                                       NULL
                                                                                                                  END,
                                                                                      i_order_recurr_plan_from => l_tbl_order_recurr_plan(1),
                                                                                      o_order_recurr_desc      => l_tbl_order_recurr_desc(1),
                                                                                      o_order_recurr_option    => l_tbl_order_recurr_option(1),
                                                                                      o_start_date             => l_tbl_start_date(1),
                                                                                      o_occurrences            => l_tbl_occurrences(1),
                                                                                      o_duration               => l_tbl_duration(1),
                                                                                      o_unit_meas_duration     => l_tbl_unit_meas_duration(1),
                                                                                      o_duration_desc          => l_tbl_duration_desc(1),
                                                                                      o_end_date               => l_tbl_end_date(1),
                                                                                      o_flg_end_by_editable    => l_tbl_flg_end_by_editable(1),
                                                                                      o_order_recurr_plan      => l_tbl_order_recurr_plan(1),
                                                                                      o_error                  => o_error)
                                THEN
                                    RAISE g_other_exception;
                                END IF;
                            END IF;
                        END IF;
                    END LOOP;
                
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        l_ds_internal_name := i_tbl_int_name(i);
                    
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_other_frequency
                           AND l_order_recurr_option = -1
                           AND l_curr_comp_int_name <> pk_orders_constant.g_ds_frequency
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_tbl_order_recurr_option(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_order_recurr_desc(1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_other_frequency
                              AND l_curr_comp_int_name = pk_orders_constant.g_ds_frequency
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_order_recurr_option = -1 THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) IN
                              (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_date_dummy)
                              AND i_episode IS NOT NULL
                        THEN
                            --If the current_component is the 'To_execute' field, the value receiveid in i_value will be piped (flg_time,id_next_episode,no_later_than)
                            --because it wil be comming from the Episode modal window
                            --In that case, it is not possible to read directly from the i_value, it is rather necessary
                            --to parse its value using pk_string_utils.str_split
                            IF l_curr_comp_int_name <> pk_orders_constant.g_ds_to_execute_list
                            THEN
                                FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                                LOOP
                                    IF i_tbl_int_name(j) = pk_orders_constant.g_ds_to_execute_list
                                    THEN
                                        l_flg_time := i_value(j) (1);
                                        EXIT;
                                    END IF;
                                END LOOP;
                            ELSE
                                FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                                LOOP
                                    IF i_tbl_int_name(j) = pk_orders_constant.g_ds_to_execute_list
                                    THEN
                                        l_tbl_flg_time := table_varchar();
                                        IF i_value(j) (1) IS NOT NULL
                                        THEN
                                            l_tbl_flg_time := pk_string_utils.str_split(i_list  => i_value(j) (1),
                                                                                        i_delim => '|');
                                        ELSE
                                            l_tbl_flg_time := table_varchar(NULL);
                                        END IF;
                                    
                                        l_flg_time := l_tbl_flg_time(i_idx);
                                        EXIT;
                                    END IF;
                                END LOOP;
                            END IF;
                        
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            IF l_curr_comp_int_name <> pk_orders_constant.g_ds_start_date
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => CASE
                                                                                                             WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                              NULL
                                                                                                             ELSE
                                                                                                              pk_date_utils.trunc_insttimezone_str(i_prof,
                                                                                                                                                   pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                                 i_prof,
                                                                                                                                                                                 l_tbl_start_date(1),
                                                                                                                                                                                 NULL),
                                                                                                                                                   'MI')
                                                                                                         END,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_alert_constant.g_yes,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE l_ds_internal_name
                                                                                                             WHEN pk_orders_constant.g_ds_date_dummy THEN
                                                                                                              pk_orders_constant.g_component_active
                                                                                                             ELSE
                                                                                                              CASE l_flg_prn
                                                                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                                                                   pk_orders_constant.g_component_read_only
                                                                                                                  ELSE
                                                                                                                   CASE
                                                                                                                       WHEN l_flg_time = pk_alert_constant.g_flg_time_b THEN
                                                                                                                        pk_orders_constant.g_component_active
                                                                                                                       WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                                        pk_orders_constant.g_component_inactive
                                                                                                                       ELSE
                                                                                                                        pk_orders_constant.g_component_mandatory
                                                                                                                   END
                                                                                                              END
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            ELSE
                                SELECT e.dt_begin_tstz
                                  INTO l_dt_epis_begin
                                  FROM episode e
                                 WHERE e.id_episode = i_episode;
                            
                                l_epis_begin_verification := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                                             i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                                         i_timestamp => l_dt_epis_begin,
                                                                                                                                         i_format    => 'MI'),
                                                                                             i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                                         i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                                      i_prof,
                                                                                                                                                                                      l_tbl_start_date(1),
                                                                                                                                                                                      NULL),
                                                                                                                                         i_format    => 'MI'));
                            
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => CASE l_epis_begin_verification
                                                                                                             WHEN 'G' THEN
                                                                                                              NULL
                                                                                                             ELSE
                                                                                                              pk_date_utils.trunc_insttimezone_str(i_prof,
                                                                                                                                                   pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                                 i_prof,
                                                                                                                                                                                 l_tbl_start_date(1),
                                                                                                                                                                                 NULL),
                                                                                                                                                   'MI')
                                                                                                         END,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => CASE l_epis_begin_verification
                                                                                                             WHEN 'G' THEN
                                                                                                              pk_orders_constant.g_component_error
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_valid
                                                                                                         END,
                                                                                   err_msg            => CASE l_epis_begin_verification
                                                                                                             WHEN 'G' THEN
                                                                                                              pk_message.get_message(i_lang,
                                                                                                                                     'COMMON_M166')
                                                                                                         END,
                                                                                   flg_event_type     => CASE l_ds_internal_name
                                                                                                             WHEN pk_orders_constant.g_ds_date_dummy THEN
                                                                                                              pk_orders_constant.g_component_active
                                                                                                             ELSE
                                                                                                              CASE l_flg_prn
                                                                                                                  WHEN pk_alert_constant.g_yes THEN
                                                                                                                   pk_orders_constant.g_component_read_only
                                                                                                                  ELSE
                                                                                                                   CASE
                                                                                                                       WHEN l_flg_time = pk_alert_constant.g_flg_time_b THEN
                                                                                                                        pk_orders_constant.g_component_active
                                                                                                                       WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                                        pk_orders_constant.g_component_inactive
                                                                                                                       ELSE
                                                                                                                        pk_orders_constant.g_component_mandatory
                                                                                                                   END
                                                                                                              END
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_executions
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_tbl_occurrences(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => l_tbl_occurrences(1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_flg_prn
                                                                                                         WHEN pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_read_only
                                                                                                         ELSE
                                                                                                          CASE
                                                                                                              WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                               pk_orders_constant.g_component_active
                                                                                                              ELSE
                                                                                                               pk_orders_constant.g_component_read_only
                                                                                                          END
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_duration
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_tbl_duration(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => CASE
                                                                                                         WHEN l_tbl_duration(1) IS NOT NULL THEN
                                                                                                          l_tbl_duration(1) || ' ' ||
                                                                                                          pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                       i_prof,
                                                                                                                                                       l_tbl_unit_meas_duration(1))
                                                                                                     END,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => l_tbl_unit_meas_duration(1),
                                                                               desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                  i_prof,
                                                                                                                                                  l_tbl_unit_meas_duration(1)),
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_end_date
                              AND i_episode IS NOT NULL
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => pk_date_utils.trunc_insttimezone_str(i_prof,
                                                                                                                                          pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                        i_prof,
                                                                                                                                                                        l_tbl_end_date(1),
                                                                                                                                                                        NULL),
                                                                                                                                          'MI'),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_tbl_flg_end_by_editable(1) = pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_to_execute_list
                              AND l_curr_comp_int_name = pk_orders_constant.g_ds_to_execute_list
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            l_tbl_flg_time := table_varchar();
                            IF i_value(i) (1) IS NOT NULL
                            THEN
                                l_tbl_flg_time := pk_string_utils.str_split(i_list => i_value(i) (1), i_delim => '|');
                            ELSE
                                l_tbl_flg_time := table_varchar(NULL);
                            END IF;
                        
                            IF l_tbl_flg_time(i_idx) <> pk_alert_constant.g_flg_time_n
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => l_tbl_flg_time(i_idx),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => pk_sysdomain.get_domain(i_code_dom => CASE
                                                                                                                                                i_root_name
                                                                                                                                                   WHEN
                                                                                                                                                    pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                                                                    'ANALYSIS_REQ_DET.FLG_TIME_HARVEST'
                                                                                                                                                   WHEN
                                                                                                                                                    pk_orders_constant.g_ds_imaging_exam_request THEN
                                                                                                                                                    'EXAM_REQ.FLG_TIME'
                                                                                                                                                   WHEN
                                                                                                                                                    pk_orders_constant.g_ds_other_exam_request THEN
                                                                                                                                                    'EXAM_REQ.FLG_TIME'
                                                                                                                                                   WHEN
                                                                                                                                                    pk_orders_constant.g_ds_order_set_procedure THEN
                                                                                                                                                    'INTERV_PRESCRIPTION.FLG_TIME'
                                                                                                                                               END,
                                                                                                                                 i_val      => l_tbl_flg_time(i_idx),
                                                                                                                                 i_lang     => i_lang),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_alert_constant.g_yes,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                             WHEN i_episode IS NULL THEN
                                                                                                              pk_orders_constant.g_component_read_only
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_mandatory
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        
                            FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                            LOOP
                                l_ds_internal_name := i_tbl_int_name(j);
                            
                                IF i_tbl_int_name(j) = pk_orders_constant.g_ds_flg_time
                                THEN
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j));
                                
                                    tbl_result.extend();
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => i_tbl_int_name(j),
                                                                                       VALUE              => l_tbl_flg_time(i_idx),
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => NULL,
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                                       flg_multi_status   => NULL,
                                                                                       idx                => i_idx);
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_no_later_than
                                THEN
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j));
                                
                                    l_tbl_no_later_than := table_varchar();
                                    IF i_value(i) (3) IS NOT NULL
                                    THEN
                                        l_tbl_no_later_than := pk_string_utils.str_split(i_list  => i_value(i) (3),
                                                                                         i_delim => '|');
                                    ELSE
                                        l_tbl_no_later_than := table_varchar(NULL);
                                    END IF;
                                
                                    tbl_result.extend();
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => i_tbl_int_name(j),
                                                                                       VALUE              => l_tbl_no_later_than(i_idx),
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => NULL,
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                                       flg_multi_status   => NULL,
                                                                                       idx                => i_idx);
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_scheduling_notes
                                THEN
                                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j));
                                
                                    tbl_result.extend();
                                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                       id_ds_component    => l_id_ds_component,
                                                                                       internal_name      => i_tbl_int_name(j),
                                                                                       VALUE              => i_value(j) (1),
                                                                                       value_clob         => NULL,
                                                                                       min_value          => NULL,
                                                                                       max_value          => NULL,
                                                                                       desc_value         => i_value_desc(j) (1),
                                                                                       desc_clob          => NULL,
                                                                                       id_unit_measure    => NULL,
                                                                                       desc_unit_measure  => NULL,
                                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                                       err_msg            => NULL,
                                                                                       flg_event_type     => CASE
                                                                                                              l_tbl_flg_time(i_idx)
                                                                                                                 WHEN
                                                                                                                  pk_alert_constant.g_flg_time_e THEN
                                                                                                                  pk_orders_constant.g_component_inactive
                                                                                                                 ELSE
                                                                                                                  pk_orders_constant.g_component_active
                                                                                                             END,
                                                                                       flg_multi_status   => NULL,
                                                                                       idx                => i_idx);
                                END IF;
                            END LOOP;
                        ELSIF l_ds_internal_name = pk_orders_constant.g_ds_dummy_number
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => l_ds_internal_name,
                                                                               VALUE              => l_tbl_order_recurr_plan(1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_health_coverage_plan
                      AND i_episode IS NOT NULL
                THEN
                    FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        IF i_tbl_int_name(j) IN (pk_orders_constant.g_ds_health_coverage_plan)
                        THEN
                            l_id_health_coverage_plan := i_value(j) (1);
                        END IF;
                    END LOOP;
                
                    FOR j IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        IF i_tbl_int_name(j) IN (pk_orders_constant.g_ds_financial_entity)
                        THEN
                            l_id_financial_entity := i_value(j) (1);
                            IF l_id_financial_entity IS NULL
                               AND l_id_health_coverage_plan IS NOT NULL
                            THEN
                                SELECT hpe.id_health_plan_entity
                                  INTO l_id_financial_entity
                                  FROM pat_health_plan php
                                  JOIN health_plan hp
                                    ON php.id_health_plan = hp.id_health_plan
                                  LEFT JOIN health_plan_entity hpe
                                    ON hp.id_health_plan_entity = hpe.id_health_plan_entity
                                 WHERE php.id_pat_health_plan = l_id_health_coverage_plan;
                            END IF;
                        END IF;
                    END LOOP;
                
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        IF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_health_plan_number)
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            l_beneficiary_number := pk_orders_utils.get_patient_beneficiary_number(i_lang               => i_lang,
                                                                                                   i_prof               => i_prof,
                                                                                                   i_patient            => i_patient,
                                                                                                   i_health_plan_entity => l_id_financial_entity,
                                                                                                   i_health_plan        => l_id_health_coverage_plan);
                            IF l_beneficiary_number IS NOT NULL
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => l_beneficiary_number,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => l_beneficiary_number,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_read_only,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            ELSE
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => NULL,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_financial_entity
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => to_char(l_id_financial_entity),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => pk_adt.get_pat_health_plan_info(i_lang,
                                                                                                                                     i_prof,
                                                                                                                                     l_id_health_coverage_plan,
                                                                                                                                     'F'),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_id_market
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_id_market_pt THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_financial_entity
                      AND i_episode IS NOT NULL
                THEN
                    FOR i IN i_tbl_mkt_rel.first .. i_tbl_mkt_rel.last
                    LOOP
                        IF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_health_coverage_plan)
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE l_id_market
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_id_market_pt THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_health_plan_number)
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_supply_order_mw
                THEN
                    /*The UX will send all the information necessary for the supplies in this field
                    The info is sent in an array and will have the following structure:
                    [0]: ID_SUPPLY 
                    [1]: ID_SET
                    [2]: QUANTITY
                    [3]: DT_RETURN
                    [4]: SUPPLY_LOCATION
                    
                    Each element will carry the info for all the supplies selected on the supplies modal, and are separated by a pipe.
                    For instances, the array will be something like this:
                      [ID_SUPPLY_1|ID_SUPPLY_2, ID_SET_1|ID_SET_2, QUANTITY_1|QUANTITY_2, DT_RETURN_1|DT_RETURN_2, SUPPLY_LOCATION_1|SUPPLY_LOCATION2]
                    
                    This submit action has to fetch all that information and inject it in the respective memory fields.
                    
                    The value of pk_orders_constant.g_ds_supply_order_mw should not be changed, because it will be used by the supplies modal
                    if the user wants to access the grid again.
                    */
                    FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_supply_order_mw
                        THEN
                            --When clearing the field, the array will not have all elements, and in this case, we should erase the memory fields
                            IF i_value(i).count = 5
                            THEN
                                l_tbl_supply     := pk_string_utils.str_split(i_list => i_value(i) (1), i_delim => '|');
                                l_tbl_set        := pk_string_utils.str_split(i_list => i_value(i) (2), i_delim => '|');
                                l_tbl_quantity   := pk_string_utils.str_split(i_list => i_value(i) (3), i_delim => '|');
                                l_tbl_dt_return  := pk_string_utils.str_split(i_list => i_value(i) (4), i_delim => '|');
                                l_tbl_supply_loc := pk_string_utils.str_split(i_list => i_value(i) (5), i_delim => '|');
                            END IF;
                        
                            IF l_tbl_supply.exists(1)
                            THEN
                                SELECT pk_translation.get_translation(i_lang, s.code_supply) || '(' || tbl_qty.quantity || ')'
                                  BULK COLLECT
                                  INTO l_tbl_supply_desc
                                  FROM supply s
                                  JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                                         to_number(t.column_value) id_supply, rownum AS rn
                                          FROM TABLE(l_tbl_supply) t) tbl_sup
                                    ON tbl_sup.id_supply = s.id_supply
                                  LEFT JOIN (SELECT /*+opt_estimate (table t rows=1)*/
                                              to_number(t.column_value) quantity, rownum AS rn
                                               FROM TABLE(l_tbl_quantity) t) tbl_qty
                                    ON tbl_qty.rn = tbl_sup.rn;
                            
                                FOR j IN l_tbl_supply_desc.first .. l_tbl_supply_desc.last
                                LOOP
                                    l_supply_desc := l_supply_desc || l_tbl_supply_desc(j) || CASE
                                                         WHEN l_tbl_supply_desc.first = l_tbl_supply_desc.last
                                                              OR j = l_tbl_supply_desc.last THEN
                                                          '.'
                                                         ELSE
                                                          '; '
                                                     END;
                                END LOOP;
                            
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i)
                                                                                                         (1) || ',' ||
                                                                                                         i_value(i)
                                                                                                         (2) || ',' ||
                                                                                                         i_value(i)
                                                                                                         (3) || ',' ||
                                                                                                         i_value(i)
                                                                                                         (4) || ',' ||
                                                                                                         i_value(i) (5),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => l_supply_desc,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_unique,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            ELSE
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i)),
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => NULL,
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_unique,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        
                            --Set the Memory fields                                          
                            FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                            LOOP
                                IF i_tbl_int_name(j) = pk_orders_constant.g_ds_id_supply
                                THEN
                                    IF l_tbl_supply.exists(1)
                                    THEN
                                        FOR k IN l_tbl_supply.first .. l_tbl_supply.last
                                        LOOP
                                            tbl_result.extend();
                                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                               internal_name      => i_tbl_int_name(j),
                                                                                               VALUE              => l_tbl_supply(k),
                                                                                               value_clob         => NULL,
                                                                                               min_value          => NULL,
                                                                                               max_value          => NULL,
                                                                                               desc_value         => NULL,
                                                                                               desc_clob          => NULL,
                                                                                               id_unit_measure    => NULL,
                                                                                               desc_unit_measure  => NULL,
                                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                                               err_msg            => NULL,
                                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                                               flg_multi_status   => NULL,
                                                                                               idx                => i_idx);
                                        END LOOP;
                                    ELSE
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                           internal_name      => i_tbl_int_name(j),
                                                                                           VALUE              => NULL,
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => NULL,
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => NULL,
                                                                                           idx                => i_idx);
                                    END IF;
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_set
                                THEN
                                    IF l_tbl_set.exists(1)
                                    THEN
                                        FOR k IN l_tbl_set.first .. l_tbl_set.last
                                        LOOP
                                            tbl_result.extend();
                                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                               internal_name      => i_tbl_int_name(j),
                                                                                               VALUE              => to_char(coalesce(l_tbl_set(k),
                                                                                                                                      -1)),
                                                                                               value_clob         => NULL,
                                                                                               min_value          => NULL,
                                                                                               max_value          => NULL,
                                                                                               desc_value         => NULL,
                                                                                               desc_clob          => NULL,
                                                                                               id_unit_measure    => NULL,
                                                                                               desc_unit_measure  => NULL,
                                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                                               err_msg            => NULL,
                                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                                               flg_multi_status   => NULL,
                                                                                               idx                => i_idx);
                                        END LOOP;
                                    ELSE
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                           internal_name      => i_tbl_int_name(j),
                                                                                           VALUE              => '-1',
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => NULL,
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => NULL,
                                                                                           idx                => i_idx);
                                    END IF;
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_quantity
                                THEN
                                    IF l_tbl_quantity.exists(1)
                                    THEN
                                        FOR k IN l_tbl_quantity.first .. l_tbl_quantity.last
                                        LOOP
                                            tbl_result.extend();
                                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                               internal_name      => i_tbl_int_name(j),
                                                                                               VALUE              => to_char(coalesce(l_tbl_quantity(k),
                                                                                                                                      -1)),
                                                                                               value_clob         => NULL,
                                                                                               min_value          => NULL,
                                                                                               max_value          => NULL,
                                                                                               desc_value         => NULL,
                                                                                               desc_clob          => NULL,
                                                                                               id_unit_measure    => NULL,
                                                                                               desc_unit_measure  => NULL,
                                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                                               err_msg            => NULL,
                                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                                               flg_multi_status   => NULL,
                                                                                               idx                => i_idx);
                                        END LOOP;
                                    ELSE
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                           internal_name      => i_tbl_int_name(j),
                                                                                           VALUE              => '-1',
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => NULL,
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => NULL,
                                                                                           idx                => i_idx);
                                    END IF;
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_dt_return
                                THEN
                                    IF l_tbl_dt_return.exists(1)
                                    THEN
                                        FOR k IN l_tbl_dt_return.first .. l_tbl_dt_return.last
                                        LOOP
                                            tbl_result.extend();
                                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                               internal_name      => i_tbl_int_name(j),
                                                                                               VALUE              => to_char(coalesce(l_tbl_dt_return(k),
                                                                                                                                      '-1')),
                                                                                               value_clob         => NULL,
                                                                                               min_value          => NULL,
                                                                                               max_value          => NULL,
                                                                                               desc_value         => NULL,
                                                                                               desc_clob          => NULL,
                                                                                               id_unit_measure    => NULL,
                                                                                               desc_unit_measure  => NULL,
                                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                                               err_msg            => NULL,
                                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                                               flg_multi_status   => NULL,
                                                                                               idx                => i_idx);
                                        END LOOP;
                                    ELSE
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                           internal_name      => i_tbl_int_name(j),
                                                                                           VALUE              => '-1',
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => NULL,
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => NULL,
                                                                                           idx                => i_idx);
                                    END IF;
                                ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_supply_location
                                THEN
                                    IF l_tbl_supply_loc.exists(1)
                                    THEN
                                        FOR k IN l_tbl_supply_loc.first .. l_tbl_supply_loc.last
                                        LOOP
                                            tbl_result.extend();
                                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                               id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                               internal_name      => i_tbl_int_name(j),
                                                                                               VALUE              => coalesce(l_tbl_supply_loc(k),
                                                                                                                              '-1'),
                                                                                               value_clob         => NULL,
                                                                                               min_value          => NULL,
                                                                                               max_value          => NULL,
                                                                                               desc_value         => NULL,
                                                                                               desc_clob          => NULL,
                                                                                               id_unit_measure    => NULL,
                                                                                               desc_unit_measure  => NULL,
                                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                                               err_msg            => NULL,
                                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                                               flg_multi_status   => NULL,
                                                                                               idx                => i_idx);
                                        END LOOP;
                                    ELSE
                                        tbl_result.extend();
                                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(j),
                                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(j)),
                                                                                           internal_name      => i_tbl_int_name(j),
                                                                                           VALUE              => '-1',
                                                                                           value_clob         => NULL,
                                                                                           min_value          => NULL,
                                                                                           max_value          => NULL,
                                                                                           desc_value         => NULL,
                                                                                           desc_clob          => NULL,
                                                                                           id_unit_measure    => NULL,
                                                                                           desc_unit_measure  => NULL,
                                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                                           err_msg            => NULL,
                                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                                           flg_multi_status   => NULL,
                                                                                           idx                => i_idx);
                                    END IF;
                                END IF;
                            END LOOP;
                        
                            --Exit the cicle, it isn't necessary to continue.
                            EXIT;
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_execution_ordered_at
                THEN
                    --Check if it is a valid date
                    l_varchar_aux := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                               i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                               i_value               => i_value);
                
                    IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                             i_prof          => i_prof,
                                                             i_id_episode    => i_episode,
                                                             o_dt_begin_tstz => l_dt_epis_begin,
                                                             o_error         => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => l_dt_epis_begin,
                                                                                                                     i_format    => 'MI'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_varchar_aux,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'MI'));
                
                    IF l_date_comparison = 'G'
                    THEN
                        tbl_result.extend();
                        SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                                  id_ds_component    => d.id_ds_component_child,
                                                  internal_name      => d.internal_name_child,
                                                  VALUE              => l_varchar_aux,
                                                  value_clob         => NULL,
                                                  min_value          => NULL,
                                                  max_value          => NULL,
                                                  desc_value         => NULL,
                                                  desc_clob          => NULL,
                                                  id_unit_measure    => d.id_unit_measure,
                                                  desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                     i_prof         => i_prof,
                                                                                                                     i_unit_measure => d.id_unit_measure),
                                                  flg_validation     => pk_orders_constant.g_component_error,
                                                  err_msg            => pk_message.get_message(i_lang, 'POSITIONING_T024'),
                                                  flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                  flg_multi_status   => NULL,
                                                  idx                => i_idx)
                          INTO tbl_result(tbl_result.count)
                          FROM ds_cmpt_mkt_rel d
                         WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                    END IF;
                END IF;
            ELSE
                --Selecting/Deselecting elements in the viewer
                --IMPORTANT: For this action, it is necessary to send the information of ALL visible components (values and statuses)
                --(MEM components do not need to be sent, unless its values should be updated)
                --This is how the UX layer will now if the multiple elements selected in the viewer have multiple values for each field,
                --adding the tags 'Multiple'.
            
                --Obtain memory information
                FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                LOOP
                    IF i_tbl_int_name(i) = pk_orders_constant.g_ds_dummy_number
                    THEN
                        l_order_recurr_plan := to_number(i_value(i) (1));
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_flg_edition
                    THEN
                        l_flg_edition := i_value(i) (1);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_order_type
                    THEN
                        l_has_cosign_info := pk_alert_constant.g_yes;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_has_catalogue
                    THEN
                        l_has_catalogue := coalesce(i_value(i) (1), pk_alert_constant.g_no);
                    END IF;
                END LOOP;
            
                IF l_order_recurr_plan IS NOT NULL
                THEN
                    --Determine the values for the recurrence fields
                    IF NOT pk_order_recurrence_core.get_order_recurr_instructions(i_lang                => i_lang,
                                                                                  i_prof                => i_prof,
                                                                                  i_order_plan          => l_order_recurr_plan,
                                                                                  o_order_recurr_desc   => l_order_recurr_desc,
                                                                                  o_order_recurr_option => l_order_recurr_option,
                                                                                  o_start_date          => l_start_date,
                                                                                  o_occurrences         => l_occurrences,
                                                                                  o_duration            => l_duration,
                                                                                  o_unit_meas_duration  => l_unit_meas_duration,
                                                                                  o_end_date            => l_end_date,
                                                                                  o_flg_end_by_editable => l_flg_end_by_editable,
                                                                                  o_error               => o_error)
                    THEN
                        g_error := 'error while calling get_order_recurr_instructions function';
                        RAISE g_other_exception;
                    END IF;
                END IF;
            
                FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                LOOP
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    --Set of fields that are always active, regardless of configurations
                    IF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_priority,
                                             pk_orders_constant.g_ds_reason_not_ordering,
                                             pk_orders_constant.g_ds_fasting,
                                             pk_orders_constant.g_ds_patient_notes,
                                             pk_orders_constant.g_ds_location,
                                             pk_orders_constant.g_ds_additional_notes,
                                             pk_orders_constant.g_ds_collection_place)
                       OR (i_tbl_int_name(i) IN (pk_orders_constant.g_ds_financial_entity,
                                                 pk_orders_constant.g_ds_health_coverage_plan,
                                                 pk_orders_constant.g_ds_exemption) AND i_episode IS NOT NULL)
                       OR (i_tbl_int_name(i) = pk_orders_constant.g_ds_place_service AND
                           i_root_name = pk_orders_constant.g_ds_lab_test_request)
                       OR (i_tbl_int_name(i) = pk_orders_constant.g_ds_notes_execution AND
                           i_root_name <> pk_orders_constant.g_ds_lab_test_request)
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE i_tbl_int_name(i)
                                                                                                     WHEN
                                                                                                      pk_orders_constant.g_ds_reason_not_ordering THEN
                                                                                                      CASE
                                                                                                       l_flg_show_reason_not_order
                                                                                                          WHEN
                                                                                                           pk_alert_constant.g_yes THEN
                                                                                                           pk_orders_constant.g_component_active
                                                                                                          ELSE
                                                                                                           pk_orders_constant.g_component_hidden
                                                                                                      END
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_active
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_prn)
                          OR (i_tbl_int_name(i) = pk_orders_constant.g_ds_place_service AND
                              i_root_name = pk_orders_constant.g_ds_order_set_procedure)
                          OR (i_tbl_int_name(i) IN (pk_orders_constant.g_ds_to_execute_list) AND i_episode IS NOT NULL)
                    THEN
                        --These are fields that are always mandatory regardless of configurations
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_to_execute_list)
                    THEN
                        --These are fields that are always mandatory regardless of configurations
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_read_only,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_execution_ordered_at
                    THEN
                        IF (l_flg_edition = pk_alert_constant.g_no AND l_co_sign_available = pk_alert_constant.g_no)
                           OR (l_flg_edition = pk_alert_constant.g_yes AND l_has_cosign_info = pk_alert_constant.g_no)
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => i_value(i) (1),
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN i_episode IS NOT NULL THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_purpose
                    THEN
                        IF i_root_name = pk_orders_constant.g_ds_lab_test_request
                        THEN
                            l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_A',
                                                                                    i_prof);
                        ELSIF i_root_name = 'DS_BLOOD_PRODUCTS'
                        THEN
                            l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_BP',
                                                                                    i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_order_set_procedure
                        THEN
                            l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_P',
                                                                                    i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_imaging_exam_request
                        THEN
                            l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_I',
                                                                                    i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_other_exam_request
                        THEN
                            l_clinical_purpose_mandatory := pk_sysconfig.get_config('CLINICAL_PURPOSE_MANDATORY_E',
                                                                                    i_prof);
                        END IF;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE
                                                                                                  l_clinical_purpose_mandatory
                                                                                                     WHEN
                                                                                                      pk_alert_constant.g_yes THEN
                                                                                                      pk_orders_constant.g_component_mandatory
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_active
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_purpose_ft
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_clinical_purpose
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                          i_value(j) (1)
                                                                                                             WHEN '0' THEN
                                                                                                              pk_orders_constant.g_component_mandatory
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_inactive
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                                EXIT;
                            END IF;
                        END LOOP;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_laterality
                    THEN
                        IF i_root_name = pk_orders_constant.g_ds_order_set_procedure
                        THEN
                            l_laterality_mandatory := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY',
                                                                              i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_imaging_exam_request
                        THEN
                            l_laterality_mandatory := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY',
                                                                              i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_other_exam_request
                        THEN
                            l_laterality_mandatory := pk_sysconfig.get_config('EXAMS_ORDER_LATERALITY_MANDATORY',
                                                                              i_prof);
                        END IF;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE i_root_name
                                                                                                     WHEN
                                                                                                      pk_orders_constant.g_ds_lab_test_request THEN
                                                                                                      pk_orders_constant.g_component_hidden
                                                                                                     ELSE
                                                                                                      CASE l_flg_edition
                                                                                                          WHEN
                                                                                                           pk_alert_constant.g_no THEN
                                                                                                           pk_orders_utils.get_laterality_event_type(i_lang                 => i_lang,
                                                                                                                                                     i_prof                 => i_prof,
                                                                                                                                                     i_root_name            => i_root_name,
                                                                                                                                                     i_laterality_mandatory => l_laterality_mandatory,
                                                                                                                                                     i_idx                  => i_idx,
                                                                                                                                                     i_value_laterality     => i_value(i) (1),
                                                                                                                                                     i_tbl_data             => i_tbl_data)
                                                                                                          ELSE
                                                                                                           CASE
                                                                                                            l_laterality_mandatory
                                                                                                               WHEN
                                                                                                                pk_alert_constant.g_yes THEN
                                                                                                                pk_orders_constant.g_component_mandatory
                                                                                                               ELSE
                                                                                                                pk_orders_constant.g_component_active
                                                                                                           END
                                                                                                      END
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_prn_specify
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_prn
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                          i_value(j) (1)
                                                                                                             WHEN
                                                                                                              pk_alert_constant.g_yes THEN
                                                                                                              pk_orders_constant.g_component_active
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_inactive
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                                EXIT;
                            END IF;
                        END LOOP;
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_frequency)
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_prn
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                          i_value(j) (1)
                                                                                                             WHEN
                                                                                                              pk_alert_constant.g_yes THEN
                                                                                                              pk_orders_constant.g_component_read_only
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_mandatory
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                                EXIT;
                            END IF;
                        END LOOP;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_start_date
                          AND i_episode IS NOT NULL
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_prn
                            THEN
                                l_flg_prn := i_value(j) (1);
                            ELSIF i_tbl_int_name(j) = pk_orders_constant.g_ds_flg_time
                            THEN
                                l_flg_time := i_value(j) (1);
                            END IF;
                        END LOOP;
                    
                        g_error := 'ERROR GETTING DT_EPIS_BEGIN';
                        SELECT e.dt_begin_tstz
                          INTO l_dt_epis_begin
                          FROM episode e
                         WHERE e.id_episode = i_episode;
                    
                        g_error                   := 'ERROR VALIDATING START DATE';
                        l_epis_begin_verification := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                                     i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                                 i_timestamp => l_dt_epis_begin,
                                                                                                                                 i_format    => 'MI'),
                                                                                     i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                                 i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                              i_prof,
                                                                                                                                                                              i_value(i) (1),
                                                                                                                                                                              NULL),
                                                                                                                                 i_format    => 'MI'));
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => CASE l_epis_begin_verification
                                                                                                     WHEN 'G' THEN
                                                                                                      pk_orders_constant.g_component_error
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_valid
                                                                                                 END,
                                                                           err_msg            => CASE l_epis_begin_verification
                                                                                                     WHEN 'G' THEN
                                                                                                      pk_message.get_message(i_lang,
                                                                                                                             'COMMON_M166')
                                                                                                 END,
                                                                           flg_event_type     => CASE i_tbl_int_name(i)
                                                                                                     WHEN pk_orders_constant.g_ds_date_dummy THEN
                                                                                                      pk_orders_constant.g_component_active
                                                                                                     ELSE
                                                                                                      CASE l_flg_prn
                                                                                                          WHEN pk_alert_constant.g_yes THEN
                                                                                                           pk_orders_constant.g_component_read_only
                                                                                                          ELSE
                                                                                                           CASE
                                                                                                               WHEN l_flg_time = pk_alert_constant.g_flg_time_b THEN
                                                                                                                pk_orders_constant.g_component_active
                                                                                                               WHEN l_flg_time = pk_alert_constant.g_flg_time_n THEN
                                                                                                                pk_orders_constant.g_component_inactive
                                                                                                               ELSE
                                                                                                                pk_orders_constant.g_component_mandatory
                                                                                                           END
                                                                                                      END
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_other_frequency
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_frequency
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i) (1),
                                                                                   value_clob         => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                          i_value(j) (1)
                                                                                                             WHEN -1 THEN
                                                                                                              pk_orders_constant.g_component_mandatory
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_inactive
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                                EXIT;
                            END IF;
                        END LOOP;
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_executions, pk_orders_constant.g_ds_duration)
                          OR (i_tbl_int_name(i) = pk_orders_constant.g_ds_end_date AND i_episode IS NOT NULL)
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => CASE
                                                                                                     WHEN i_tbl_int_name(i) = pk_orders_constant.g_ds_duration THEN
                                                                                                      to_number(i_value_mea(i) (1))
                                                                                                     ELSE
                                                                                                      NULL
                                                                                                 END,
                                                                           desc_unit_measure  => CASE
                                                                                                     WHEN i_tbl_int_name(i) = pk_orders_constant.g_ds_duration THEN
                                                                                                      pk_unit_measure.get_unit_measure_description(i_lang,
                                                                                                                                                   i_prof,
                                                                                                                                                   to_number(i_value_mea(i) (1)))
                                                                                                     ELSE
                                                                                                      NULL
                                                                                                 END,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE l_flg_end_by_editable
                                                                                                     WHEN pk_alert_constant.g_yes THEN
                                                                                                      pk_orders_constant.g_component_active
                                                                                                     ELSE
                                                                                                      CASE
                                                                                                          WHEN i_value(i) (1) IS NULL THEN
                                                                                                           pk_orders_constant.g_component_inactive
                                                                                                          ELSE
                                                                                                           pk_orders_constant.g_component_read_only
                                                                                                      END
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) IN
                          (pk_orders_constant.g_ds_lab_test_result, pk_orders_constant.g_ds_weight_kg)
                          OR (i_tbl_int_name(i) = pk_orders_constant.g_ds_health_plan_number AND i_episode IS NOT NULL)
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE
                                                                                                     WHEN i_value(i) (1) IS NULL THEN
                                                                                                      pk_orders_constant.g_component_inactive
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_read_only
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_scheduling_notes
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_flg_time
                            THEN
                                l_flg_time := i_value(j) (1);
                                EXIT;
                            END IF;
                        END LOOP;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE l_flg_time
                                                                                                     WHEN
                                                                                                      pk_alert_constant.g_flg_time_e THEN
                                                                                                      pk_orders_constant.g_component_inactive
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_active
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_notes_technician
                    THEN
                        IF i_root_name = pk_orders_constant.g_ds_imaging_exam_request
                        THEN
                            l_notes_tech_mandatory := pk_sysconfig.get_config('IMG_NOTES_TECH_MANDATORY', i_prof);
                        ELSIF i_root_name = pk_orders_constant.g_ds_other_exam_request
                        THEN
                            l_notes_tech_mandatory := pk_sysconfig.get_config('EXM_NOTES_TECH_MANDATORY', i_prof);
                        END IF;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE
                                                                                                  l_notes_tech_mandatory
                                                                                                     WHEN
                                                                                                      pk_alert_constant.g_yes THEN
                                                                                                      pk_orders_constant.g_component_mandatory
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_active
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_supply_order_mw,
                                                pk_orders_constant.g_ds_id_supply,
                                                pk_orders_constant.g_ds_supply_location,
                                                pk_orders_constant.g_ds_supply_dt_return,
                                                pk_orders_constant.g_ds_supply_quantity,
                                                pk_orders_constant.g_ds_supply_set)
                    THEN
                        FOR j IN i_value(i).first .. i_value(i).last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => CASE
                                                                                                      i_tbl_int_name(i)
                                                                                                         WHEN
                                                                                                          pk_orders_constant.g_ds_supply_order_mw THEN
                                                                                                          to_char(i_value(i) (j))
                                                                                                         ELSE
                                                                                                          to_char(coalesce(i_value(i) (j),
                                                                                                                           '-1'))
                                                                                                     END,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => i_value_desc(i) (j),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                      i_tbl_int_name(i)
                                                                                                         WHEN
                                                                                                          pk_orders_constant.g_ds_supply_order_mw THEN
                                                                                                          pk_orders_constant.g_component_unique
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_specimen
                    THEN
                        IF l_flg_edition = pk_alert_constant.g_no
                        THEN
                            --If the record is a Group, field 'Specimen' and 'Body location' must be inactive
                            --If there are more than one selected record, this field should be Read-only
                            IF i_tbl_data(i_idx) (3) = 'G'
                            THEN
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => NULL,
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   value_clob         => NULL,
                                                                                   desc_value         => NULL,
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            ELSE
                                tbl_result.extend();
                                tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                                   id_ds_component    => l_id_ds_component,
                                                                                   internal_name      => i_tbl_int_name(i),
                                                                                   VALUE              => i_value(i) (1),
                                                                                   min_value          => NULL,
                                                                                   max_value          => NULL,
                                                                                   value_clob         => NULL,
                                                                                   desc_value         => i_value_desc(i) (1),
                                                                                   desc_clob          => NULL,
                                                                                   id_unit_measure    => NULL,
                                                                                   desc_unit_measure  => NULL,
                                                                                   flg_validation     => pk_orders_constant.g_component_valid,
                                                                                   err_msg            => NULL,
                                                                                   flg_event_type     => CASE
                                                                                                             WHEN i_tbl_data.count = 1 THEN
                                                                                                              pk_orders_constant.g_component_mandatory
                                                                                                             ELSE
                                                                                                              pk_orders_constant.g_component_read_only
                                                                                                         END,
                                                                                   flg_multi_status   => NULL,
                                                                                   idx                => i_idx);
                            END IF;
                        ELSE
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => i_value(i) (1),
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN i_tbl_id_pk.count = 1 THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_read_only
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_body_location
                    THEN
                        --If the record is a Group, field 'Body location' must be inactive
                        IF l_flg_edition = pk_alert_constant.g_no
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => i_value(i) (1),
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                      i_tbl_data(i_idx) (3)
                                                                                                         WHEN 'G' THEN
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSE
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => i_value(i) (1),
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_notes_execution
                          AND i_root_name = pk_orders_constant.g_ds_lab_test_request
                    THEN
                        l_notes_execution_mandatory := pk_sysconfig.get_config('LAB_TESTS_NOTES_TECH_MANDATORY', i_prof);
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => i_value_desc(i) (1),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => CASE
                                                                                                  l_notes_execution_mandatory
                                                                                                     WHEN
                                                                                                      pk_alert_constant.g_yes THEN
                                                                                                      pk_orders_constant.g_component_mandatory
                                                                                                     ELSE
                                                                                                      pk_orders_constant.g_component_active
                                                                                                 END,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    
                        --
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_catalogue
                    THEN
                        IF l_has_catalogue = pk_alert_constant.g_yes
                        THEN
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => i_value(i) (1),
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => i_value_desc(i) (1),
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSE
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                        --MEMORY FIELDS
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_default_laterality
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => CASE l_flg_edition
                                                                                                     WHEN
                                                                                                      pk_alert_constant.g_no THEN
                                                                                                      i_tbl_data(i_idx) (3)
                                                                                                     ELSE
                                                                                                      i_value(i) (1)
                                                                                                 END,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_dummy_number
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => l_order_recurr_plan,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_tbl_records
                    THEN
                        FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(j) = pk_orders_constant.g_ds_flg_edition
                            THEN
                                l_flg_edition := i_value(j) (1);
                                EXIT;
                            END IF;
                        END LOOP;
                    
                        l_tbl_varchar_aux := table_varchar();
                    
                        IF l_flg_edition = pk_alert_constant.g_no
                        THEN
                            FOR j IN i_tbl_data.first .. i_tbl_data.last
                            LOOP
                                l_tbl_varchar_aux.extend;
                                l_tbl_varchar_aux(l_tbl_varchar_aux.count) := i_tbl_data(j) (1);
                            END LOOP;
                        ELSE
                            FOR j IN i_tbl_id_pk.first .. i_tbl_id_pk.last
                            LOOP
                                l_tbl_varchar_aux.extend;
                                l_tbl_varchar_aux(l_tbl_varchar_aux.count) := i_tbl_id_pk(j);
                            END LOOP;
                        END IF;
                    
                        SELECT listagg(t.column_value, '|') /*+opt_estimate(table t rows=1)*/
                          INTO l_varchar_aux
                          FROM TABLE(l_tbl_varchar_aux) t;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => l_varchar_aux,
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    
                    ELSIF i_tbl_int_name(i) IN (pk_orders_constant.g_ds_next_episode_id,
                                                pk_orders_constant.g_ds_no_later_than,
                                                pk_orders_constant.g_ds_date_dummy,
                                                pk_orders_constant.g_ds_flg_time)
                    THEN
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => i_value(i) (1),
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => NULL,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_active,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    END IF;
                END LOOP;
            END IF;
        ELSE
            --EDITION            
            IF i_root_name = pk_orders_constant.g_ds_order_set_procedure
            THEN
                g_error := 'ERROR CALLING PK_PROCEDURES_CORE.GET_PROCEDURE_TO_EDIT';
                IF NOT pk_procedures_core.get_procedure_to_edit(i_lang           => i_lang,
                                                                i_prof           => i_prof,
                                                                i_episode        => i_episode,
                                                                i_patient        => i_patient,
                                                                i_action         => i_action,
                                                                i_root_name      => i_root_name,
                                                                i_curr_component => i_curr_component,
                                                                i_idx            => i_idx,
                                                                i_tbl_id_pk      => i_tbl_id_pk,
                                                                i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                                i_tbl_int_name   => i_tbl_int_name,
                                                                i_value          => i_value,
                                                                i_value_desc     => i_value_desc,
                                                                i_tbl_data       => i_tbl_data,
                                                                i_value_clob     => i_value_clob,
                                                                i_tbl_result     => tbl_result,
                                                                o_error          => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            END IF;
        END IF;
    
        --For each action (New form, Component submit, Selecting/Deselecting in the viewer, Edition)
        --it is necessary to tell the UX layer if the form is valid. This will allow the UX to activete/inactivate the OK button,
        --and also to activate/inactivate the pencil from the viewer for each record.
        --For this function to perform the verification, the hidden component DS_OK_CONTROL_BUTTON must be configured in the form.
        g_error := 'ERROR CALLING PK_ORDERS_UTILS.GET_OK_BUTTON_CONTROL';
        IF NOT pk_order_sets.get_ok_button_control(i_lang           => i_lang,
                                                   i_prof           => i_prof,
                                                   i_episode        => i_episode,
                                                   i_patient        => i_patient,
                                                   i_action         => i_action,
                                                   i_root_name      => i_root_name,
                                                   i_curr_component => i_curr_component,
                                                   i_idx            => i_idx,
                                                   i_tbl_id_pk      => i_tbl_id_pk,
                                                   i_tbl_mkt_rel    => i_tbl_mkt_rel,
                                                   i_tbl_int_name   => i_tbl_int_name,
                                                   i_value          => i_value,
                                                   i_value_desc     => i_value_desc,
                                                   i_tbl_data       => i_tbl_data,
                                                   i_value_clob     => i_value_clob,
                                                   i_tbl_result     => tbl_result,
                                                   o_error          => o_error)
        THEN
            RAISE g_other_exception;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_os_generic_task_form_values;

    FUNCTION get_order_set_bo_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_ORDER_SET_BO_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_institutions_selected BOOLEAN := TRUE;
    
        l_id_order_set         order_set.id_order_set%TYPE;
        l_tbl_dept             table_varchar := table_varchar();
        l_tbl_dept_desc        table_varchar := table_varchar();
        l_tbl_id_institution   table_varchar := table_varchar();
        l_tbl_institution_desc table_varchar := table_varchar();
    
        l_aux_tab t_tbl_core_domain := t_tbl_core_domain();
        l_aux_val VARCHAR2(4000 CHAR);
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
        --o_order_set_info parameters   
        c_order_set_info           pk_types.cursor_type;
        l_title                    VARCHAR2(4000 CHAR);
        l_author_desc              VARCHAR2(4000 CHAR);
        l_id_speciality            speciality.id_speciality%TYPE;
        l_speciality_desc          VARCHAR2(4000 CHAR);
        l_flg_target_professionals VARCHAR2(1 CHAR);
        l_flg_edit_permissions     VARCHAR2(1 CHAR);
        l_notes_global             VARCHAR2(4000 CHAR);
        l_institutions_desc        VARCHAR2(4000 CHAR);
        l_department_desc          VARCHAR2(4000 CHAR);
        l_reason_for_visit_desc    VARCHAR2(4000 CHAR);
        l_diagnoses_desc           VARCHAR2(4000 CHAR);
        l_order_set_type_desc      VARCHAR2(4000 CHAR);
        l_flg_target_profs_desc    VARCHAR2(4000 CHAR);
        l_flg_edit_perms_desc      VARCHAR2(4000 CHAR);
    
        --o_chief_complaints
        c_chief_complaints     pk_types.cursor_type;
        l_id_complaint         complaint.id_complaint%TYPE;
        l_chief_complaint_desc VARCHAR2(4000 CHAR);
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    BEGIN
    
        IF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            --Action of submiting a value on any given element of the form
            --IMPORTANT: In order for this action to be executed, a submit action must be configured in ds_event for the given field,
            --otherwise, the i_curr_component is null.
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_institution_mm
                THEN
                    FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_institution_mm
                        THEN
                            l_institutions_selected := FALSE;
                            IF i_value(i).exists(1)
                            THEN
                                IF i_value(i) (1) IS NOT NULL
                                THEN
                                    l_institutions_selected := TRUE;
                                END IF;
                            END IF;
                            EXIT;
                        END IF;
                    END LOOP;
                
                    FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_order_set_department
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_institutions_selected = FALSE THEN
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_service_mm
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_inactive,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_order_set_department
                THEN
                
                    l_aux_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                           i_value               => i_value);
                
                    FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_service_mm
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                         WHEN l_aux_val IS NOT NULL THEN
                                                                                                          pk_orders_constant.g_component_active
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                            EXIT;
                        END IF;
                    END LOOP;
                END IF;
            END IF;
        ELSIF i_action IN (pk_order_sets.g_order_set_edit, pk_order_sets.g_order_set_duplicate)
              OR i_action IS NULL
        THEN
        
            l_id_order_set := i_tbl_id_pk(1);
        
            g_error := 'ERROR CALLING PK_ORDER_SETS.GET_ORDER_SET_MAIN_INFO';
            IF NOT pk_order_sets.get_order_set_main_info(i_lang             => i_lang,
                                                         i_prof             => i_prof,
                                                         i_id_order_set     => l_id_order_set,
                                                         o_order_set_info   => c_order_set_info,
                                                         o_chief_complaints => c_chief_complaints,
                                                         o_error            => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'ERROR OPENING C_ORDER_SET_INFO';
            LOOP
                FETCH c_order_set_info
                    INTO l_id_order_set,
                         l_title,
                         l_author_desc,
                         l_id_speciality,
                         l_speciality_desc,
                         l_flg_target_professionals,
                         l_flg_edit_permissions,
                         l_notes_global,
                         l_department_desc,
                         l_reason_for_visit_desc,
                         l_diagnoses_desc,
                         l_order_set_type_desc,
                         l_flg_target_profs_desc,
                         l_flg_edit_perms_desc;
                EXIT WHEN c_order_set_info%NOTFOUND;
            END LOOP;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_title THEN
                                                                  l_title
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_author THEN
                                                                  l_author_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                                  to_char(l_id_speciality)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_user_permissions THEN
                                                                  l_flg_target_professionals
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_editing_permissions THEN
                                                                  l_flg_edit_permissions
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes THEN
                                                                  l_notes_global
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_dummy_number THEN
                                                                  to_char(l_id_order_set)
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_title THEN
                                                                  l_title
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_author THEN
                                                                  l_author_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_place_service THEN
                                                                  l_speciality_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_user_permissions THEN
                                                                  l_flg_target_profs_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_editing_permissions THEN
                                                                  l_flg_edit_perms_desc
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes THEN
                                                                  l_notes_global
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => def.flg_event_type,
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_order_set_title,
                                       pk_orders_constant.g_ds_order_set_author,
                                       pk_orders_constant.g_ds_place_service,
                                       --pk_orders_constant.g_ds_clinical_service_mm,
                                       pk_orders_constant.g_ds_order_set_user_permissions,
                                       pk_orders_constant.g_ds_order_set_editing_permissions,
                                       pk_orders_constant.g_ds_notes,
                                       --Hidden fields (Memory)
                                       pk_orders_constant.g_ds_dummy_number)
             ORDER BY t.rn;
        
            g_error := 'ERROR OBTAINING INSTITUTION DATA';
            SELECT to_char(id_institution), inst_desc
              BULK COLLECT
              INTO l_tbl_id_institution, l_tbl_institution_desc
              FROM (SELECT it.id_institution, pk_translation.get_translation(i_lang, it.code_institution) inst_desc
                      FROM institution it
                      JOIN order_set_link ost_lnk
                        ON ost_lnk.id_link = it.id_institution
                       AND ost_lnk.flg_link_type = g_order_set_link_institution
                     WHERE ost_lnk.id_order_set = l_id_order_set
                     ORDER BY inst_desc);
        
            IF NOT l_tbl_id_institution.exists(1)
            THEN
                SELECT it.id_institution, pk_translation.get_translation(i_lang, it.code_institution)
                  BULK COLLECT
                  INTO l_tbl_id_institution, l_tbl_institution_desc
                  FROM institution it
                 WHERE it.id_institution = i_prof.institution;
            END IF;
        
            FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
            LOOP
                IF i_tbl_int_name(i) = pk_orders_constant.g_ds_order_set_department
                THEN
                    g_error   := 'ERROR CALLING PK_ORDER_SETS.GET_ORDER_SET_ENVIRONMENT_LIST';
                    l_aux_tab := pk_order_sets.get_order_set_environment_list(i_lang         => i_lang,
                                                                              i_prof         => i_prof,
                                                                              i_id_order_set => l_id_order_set,
                                                                              i_institutions => l_tbl_id_institution,
                                                                              o_error        => o_error);
                
                    IF l_aux_tab.exists(1)
                    THEN
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        FOR j IN l_aux_tab.first .. l_aux_tab.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_aux_tab(j).domain_value,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_aux_tab(j).desc_domain,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        
                            l_tbl_dept.extend();
                            l_tbl_dept(l_tbl_dept.count) := l_aux_tab(j).domain_value;
                        END LOOP;
                    END IF;
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_order_set_type
                THEN
                    l_aux_tab := pk_order_sets.get_order_set_type_list(i_lang         => i_lang,
                                                                       i_prof         => i_prof,
                                                                       i_id_order_set => l_id_order_set,
                                                                       i_flg_select   => pk_alert_constant.g_yes,
                                                                       o_error        => o_error);
                
                    IF l_aux_tab.exists(1)
                    THEN
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        FOR j IN l_aux_tab.first .. l_aux_tab.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_aux_tab(j).domain_value,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_aux_tab(j).desc_domain,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_institution_mm
                THEN
                    g_error           := 'ERROR BUILDING INSTITUTION STRUCT';
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    FOR j IN l_tbl_id_institution.first .. l_tbl_id_institution.last
                    LOOP
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                           id_ds_component    => l_id_ds_component,
                                                                           internal_name      => i_tbl_int_name(i),
                                                                           VALUE              => l_tbl_id_institution(j),
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           value_clob         => NULL,
                                                                           desc_value         => l_tbl_institution_desc(j),
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    END LOOP;
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
                THEN
                    -- get order set clinical indications/diagnoses descriptions        
                    SELECT os.clinical_indications
                      INTO l_clinical_indications
                      FROM order_set os
                     WHERE os.id_order_set = l_id_order_set;
                
                    -- get diagnosis records
                    IF l_clinical_indications IS NOT NULL
                    THEN
                        l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                     i_prof   => i_prof,
                                                                     i_params => l_clinical_indications);
                    
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    
                        FOR j IN 1 .. l_rec_diagnoses.tbl_diagnosis.count
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_rec_diagnoses.tbl_diagnosis(j).id_alert_diagnosis,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_rec_diagnoses.tbl_diagnosis(j).desc_diagnosis,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_complaint_mw
                THEN
                    SELECT t_row_core_domain(internal_name => NULL,
                                             desc_domain   => t.reason_for_visit_desc,
                                             domain_value  => t.id_complaint,
                                             order_rank    => NULL,
                                             img_name      => NULL)
                      BULK COLLECT
                      INTO l_aux_tab
                      FROM (SELECT c.id_complaint,
                                   pk_translation.get_translation(i_lang, c.code_complaint) reason_for_visit_desc
                              FROM complaint c
                              JOIN order_set_link ost_lnk
                                ON ost_lnk.id_link = c.id_complaint
                               AND ost_lnk.flg_link_type IN
                                   (pk_order_sets.g_order_set_link_reason_visit,
                                    pk_order_sets.g_order_set_link_chief_compl)
                             WHERE ost_lnk.id_order_set = l_id_order_set
                             ORDER BY reason_for_visit_desc) t;
                
                    IF l_aux_tab.exists(1)
                    THEN
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        FOR j IN l_aux_tab.first .. l_aux_tab.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_aux_tab(j).domain_value,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_aux_tab(j).desc_domain,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                END IF;
            END LOOP;
        
            FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
            LOOP
                IF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_service_mm
                THEN
                
                    SELECT t_row_core_domain(internal_name => NULL,
                                             desc_domain   => t.desc_domain,
                                             domain_value  => t.domain_value,
                                             order_rank    => NULL,
                                             img_name      => NULL)
                      BULK COLLECT
                      INTO l_aux_tab
                      FROM (SELECT t.domain_value, t.desc_domain
                              FROM TABLE(pk_order_sets.get_services_list(i_lang     => i_lang,
                                                                         i_prof     => i_prof,
                                                                         i_tbl_dept => l_tbl_dept)) t
                              JOIN order_set_link ost_lnk
                                ON ost_lnk.id_link = to_number(t.domain_value)
                               AND ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_clin_serv
                             WHERE ost_lnk.id_order_set = l_id_order_set
                             ORDER BY t.order_rank, t.desc_domain) t;
                
                    IF l_aux_tab.exists(1)
                    THEN
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    
                        FOR j IN l_aux_tab.first .. l_aux_tab.last
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_aux_tab(j).domain_value,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_aux_tab(j).desc_domain,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => pk_orders_constant.g_component_active,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                    EXIT;
                END IF;
            END LOOP;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_order_set_bo_form_values;

    FUNCTION get_order_set_fo_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_ORDER_SET_FO_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_institutions_selected BOOLEAN := TRUE;
    
        l_id_order_set         order_set.id_order_set%TYPE;
        l_tbl_dept             table_varchar := table_varchar();
        l_tbl_dept_desc        table_varchar := table_varchar();
        l_tbl_id_institution   table_varchar := table_varchar();
        l_tbl_institution_desc table_varchar := table_varchar();
    
        l_aux_tab t_tbl_core_domain := t_tbl_core_domain();
        l_aux_val VARCHAR2(4000 CHAR);
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
    
        --o_order_set_info parameters   
        c_order_set_info           pk_types.cursor_type;
        l_title                    VARCHAR2(4000 CHAR);
        l_author_desc              VARCHAR2(4000 CHAR);
        l_id_speciality            speciality.id_speciality%TYPE;
        l_speciality_desc          VARCHAR2(4000 CHAR);
        l_flg_target_professionals VARCHAR2(1 CHAR);
        l_flg_edit_permissions     VARCHAR2(1 CHAR);
        l_notes_global             VARCHAR2(4000 CHAR);
        l_institutions_desc        VARCHAR2(4000 CHAR);
        l_department_desc          VARCHAR2(4000 CHAR);
        l_reason_for_visit_desc    VARCHAR2(4000 CHAR);
        l_diagnoses_desc           VARCHAR2(4000 CHAR);
        l_order_set_type_desc      VARCHAR2(4000 CHAR);
        l_flg_target_profs_desc    VARCHAR2(4000 CHAR);
        l_flg_edit_perms_desc      VARCHAR2(4000 CHAR);
    
        --o_chief_complaints
        c_chief_complaints     pk_types.cursor_type;
        l_id_complaint         complaint.id_complaint%TYPE;
        l_chief_complaint_desc VARCHAR2(4000 CHAR);
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    
        l_co_sign_available             VARCHAR2(1 CHAR) := pk_alert_constant.g_no;
        l_tbl_order_set_tasks           table_number := table_number();
        l_id_order_set_process          order_set_process.id_order_set_process%TYPE;
        l_flg_episodes_association      VARCHAR2(4000 CHAR);
        l_clinical_indication_mandatory sys_config.value%TYPE := pk_sysconfig.get_config('ORDER_SETS_FO_CLINICAL_INDICATION_MANDATORY',
                                                                                         i_prof);
    BEGIN
    
        IF i_action IS NULL
        THEN
        
            l_id_order_set := i_tbl_id_pk(1);
        
            --Create the order set process with the order set tasks sent in i_tbl_data
            FOR i IN i_tbl_data(1).first .. i_tbl_data(1).last
            LOOP
                l_tbl_order_set_tasks.extend();
                l_tbl_order_set_tasks(l_tbl_order_set_tasks.count) := to_number(i_tbl_data(1) (i));
            END LOOP;
        
            IF i_tbl_id_pk(2) = -1
            THEN
                g_error := 'ERROR CALLING PK_ORDER_SETS.CREATE_ORDER_SET_PROCESS';
                IF NOT pk_order_sets.create_order_set_process(i_lang                     => i_lang,
                                                              i_prof                     => i_prof,
                                                              i_id_order_set             => i_tbl_id_pk(1),
                                                              i_id_order_set_tasks       => l_tbl_order_set_tasks,
                                                              i_id_episode               => i_episode,
                                                              i_id_patient               => i_patient,
                                                              o_id_order_set_process     => l_id_order_set_process,
                                                              o_flg_episodes_association => l_flg_episodes_association,
                                                              o_error                    => o_error)
                THEN
                    RAISE g_other_exception;
                END IF;
            ELSE
                l_id_order_set_process := i_tbl_id_pk(2);
            END IF;
        
            --Obtain the order set info
            g_error := 'ERROR CALLING PK_ORDER_SETS.GET_ORDER_SET_MAIN_INFO';
            IF NOT pk_order_sets.get_order_set_main_info(i_lang             => i_lang,
                                                         i_prof             => i_prof,
                                                         i_id_order_set     => l_id_order_set,
                                                         o_order_set_info   => c_order_set_info,
                                                         o_chief_complaints => c_chief_complaints,
                                                         o_error            => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'ERROR OPENING C_ORDER_SET_INFO';
            LOOP
                FETCH c_order_set_info
                    INTO l_id_order_set,
                         l_title,
                         l_author_desc,
                         l_id_speciality,
                         l_speciality_desc,
                         l_flg_target_professionals,
                         l_flg_edit_permissions,
                         l_notes_global,
                         l_department_desc,
                         l_reason_for_visit_desc,
                         l_diagnoses_desc,
                         l_order_set_type_desc,
                         l_flg_target_profs_desc,
                         l_flg_edit_perms_desc;
                EXIT WHEN c_order_set_info%NOTFOUND;
            END LOOP;
        
            --Check if co-sign is needed
            g_error := 'ERROR CALLING PK_ORDER_SETS.CHECK_ORDER_SET_CO_SIGN';
            IF NOT pk_order_sets.check_order_set_co_sign(i_lang                 => i_lang,
                                                         i_prof                 => i_prof,
                                                         i_episode              => i_episode,
                                                         i_id_order_set_process => l_id_order_set_process,
                                                         o_co_sign_needed       => l_co_sign_available,
                                                         o_error                => o_error)
            THEN
                RAISE g_other_exception;
            END IF;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_title THEN
                                                                  l_title
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes THEN
                                                                  l_notes_global
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_dummy_number THEN
                                                                  to_char(l_id_order_set_process)
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_co_sign_control THEN
                                                                  l_co_sign_available
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_order_set_title THEN
                                                                  l_title
                                                                 WHEN t.internal_name_child = pk_orders_constant.g_ds_notes THEN
                                                                  l_notes_global
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => nvl(def.flg_event_type, pk_orders_constant.g_component_active),
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_order_set_title,
                                       pk_orders_constant.g_ds_notes,
                                       --Hidden fields (Memory)
                                       pk_orders_constant.g_ds_dummy_number)
                  --HIDDEN SECTIONS (CO-SIGN)
                OR (d.internal_name IN (pk_orders_constant.g_ds_co_sign_control) AND i_idx = 1)
             ORDER BY t.rn;
        
            FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
            LOOP
                IF i_tbl_int_name(i) = pk_orders_constant.g_ds_clinical_indication_mw
                THEN
                    -- get order set clinical indications/diagnoses descriptions        
                    SELECT os.clinical_indications
                      INTO l_clinical_indications
                      FROM order_set os
                     WHERE os.id_order_set = l_id_order_set;
                
                    -- get diagnosis records
                    IF l_clinical_indications IS NOT NULL
                    THEN
                        l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                                     i_prof   => i_prof,
                                                                     i_params => l_clinical_indications);
                    
                        l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                    
                        FOR j IN 1 .. l_rec_diagnoses.tbl_diagnosis.count
                        LOOP
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => l_rec_diagnoses.tbl_diagnosis(j).id_alert_diagnosis,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               value_clob         => NULL,
                                                                               desc_value         => l_rec_diagnoses.tbl_diagnosis(j).desc_diagnosis,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_orders_constant.g_component_valid,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                      l_clinical_indication_mandatory
                                                                                                         WHEN
                                                                                                          pk_alert_constant.g_yes THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_active
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        END LOOP;
                    END IF;
                END IF;
            END LOOP;
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            --Action of submiting a value on any given element of the form
            --IMPORTANT: In order for this action to be executed, a submit action must be configured in ds_event for the given field,
            --otherwise, the i_curr_component is null.
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_order_type
                THEN
                    IF NOT pk_orders_utils.get_co_sign_values(i_lang         => i_lang,
                                                              i_prof         => i_prof,
                                                              i_episode      => i_episode,
                                                              i_patient      => i_patient,
                                                              i_root_name    => i_root_name,
                                                              i_idx          => i_idx,
                                                              i_tbl_id_pk    => i_tbl_id_pk,
                                                              i_tbl_mkt_rel  => i_tbl_mkt_rel,
                                                              i_tbl_int_name => i_tbl_int_name,
                                                              i_value        => i_value,
                                                              i_value_mea    => i_value_mea,
                                                              i_value_desc   => i_value_desc,
                                                              i_tbl_data     => i_tbl_data,
                                                              i_value_clob   => i_value_clob,
                                                              i_tbl_result   => tbl_result,
                                                              o_error        => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_order_set_fo_form_values;

    FUNCTION get_os_monitoring_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_OS_MONITORING_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_aux_val          VARCHAR2(4000 CHAR);
        l_aux_val_desc     VARCHAR2(4000 CHAR);
        l_aux_unit_measure NUMBER(24);
    
        --Front office variables
        l_dt_begin          VARCHAR2(100 CHAR);
        l_flg_edit_dt_begin VARCHAR2(1 CHAR);
        l_interval          VARCHAR2(100 CHAR);
        l_interval_send     VARCHAR2(100 CHAR);
        l_flg_edit_interval VARCHAR2(1 CHAR);
        l_dt_end            VARCHAR2(100 CHAR);
        l_dt_end_send       VARCHAR2(100 CHAR);
        l_dt_begin_send     VARCHAR2(100 CHAR);
        l_flg_edit_dt_end   VARCHAR2(1 CHAR);
        l_flg_min_date      VARCHAR2(1 CHAR);
        l_dt_begin_tstz     order_set_process_task_det.dvalue%TYPE;
        l_dt_end_tstz       order_set_process_task_det.dvalue%TYPE;
        l_date_comparison   VARCHAR2(1 CHAR);
        l_dt_epis_begin     episode.dt_begin_tstz%TYPE;
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    
        l_exception EXCEPTION;
    BEGIN
        IF i_action IS NULL
           OR i_action IN (pk_order_sets.g_order_set_bo_edit_task, pk_order_sets.g_order_set_fo_request)
        THEN
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_order_set_task THEN
                                                                  to_char(i_tbl_id_pk(2))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  to_char(55)
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => NULL,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => nvl(def.flg_event_type,
                                                                 CASE
                                                                     WHEN t.internal_name_child IN (pk_orders_constant.g_ds_to_be_executed,
                                                                                                    pk_orders_constant.g_ds_start_date,
                                                                                                    pk_orders_constant.g_ds_end_date) THEN
                                                                      pk_orders_constant.g_component_inactive
                                                                 END),
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE (d.internal_name IN (pk_orders_constant.g_ds_to_be_executed,
                                        pk_orders_constant.g_ds_start_date,
                                        pk_orders_constant.g_ds_end_date) AND
                   (i_action = pk_order_sets.g_order_set_bo_edit_task OR i_action IS NULL))
                OR d.internal_name IN (pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_order_set_task,
                                       pk_orders_constant.g_ds_id_advanced_input)
             ORDER BY t.rn;
        
            IF i_action = pk_order_sets.g_order_set_fo_request
            THEN
                g_error := 'Error calling pk_list.monit_dates_manage';
                IF NOT pk_list.monit_dates_manage(i_lang              => i_lang,
                                                  i_flg_time          => 'E',
                                                  i_flg_tp            => 'M',
                                                  i_prof              => i_prof,
                                                  i_episode           => i_episode,
                                                  o_dt_begin          => l_dt_begin,
                                                  o_flg_edit_dt_begin => l_flg_edit_dt_begin,
                                                  o_interval          => l_interval,
                                                  o_interval_send     => l_interval_send,
                                                  o_flg_edit_interval => l_flg_edit_interval,
                                                  o_dt_end            => l_dt_end,
                                                  o_dt_end_send       => l_dt_end_send,
                                                  o_dt_begin_send     => l_dt_begin_send,
                                                  o_flg_edit_dt_end   => l_flg_edit_dt_end,
                                                  o_flg_min_date      => l_flg_min_date,
                                                  o_error             => o_error)
                
                THEN
                    l_dt_begin      := NULL;
                    l_dt_begin_send := NULL;
                    l_dt_end        := NULL;
                    l_dt_end_send   := NULL;
                END IF;
            END IF;
        
            FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
            LOOP
                IF i_tbl_int_name(i) = pk_orders_constant.g_ds_vital_sign_list
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    IF i_action <> pk_order_sets.g_order_set_fo_request
                       OR i_action IS NULL
                    THEN
                        BEGIN
                            SELECT listagg(pk_translation.get_translation(i_lang, vs.code_vital_sign), '; ') within GROUP(ORDER BY vs.id_vital_sign)
                              INTO l_aux_val
                              FROM order_set_task_link ostl
                              JOIN vital_sign vs
                                ON vs.id_vital_sign = to_number(ostl.id_task_link)
                             WHERE ostl.id_order_set_task = i_tbl_id_pk(2);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val := NULL;
                        END;
                    ELSE
                        BEGIN
                            SELECT listagg(pk_translation.get_translation(i_lang, vs.code_vital_sign), '; ') within GROUP(ORDER BY vs.id_vital_sign)
                              INTO l_aux_val
                              FROM order_set_process_task_link ostl
                              JOIN vital_sign vs
                                ON vs.id_vital_sign = to_number(ostl.id_task_link)
                             WHERE ostl.id_order_set_process_task = i_tbl_id_pk(2);
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val := NULL;
                        END;
                    END IF;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_aux_val,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_aux_val,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_read_only,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_priority
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    IF i_action <> pk_order_sets.g_order_set_fo_request
                       OR i_action IS NULL
                    THEN
                        BEGIN
                            SELECT ost.vvalue,
                                   pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain,
                                                           i_val      => ost.vvalue,
                                                           i_lang     => i_lang)
                              INTO l_aux_val, l_aux_val_desc
                              FROM order_set_task_detail ost
                              JOIN advanced_input_multi_field ai
                                ON ai.id_advanced_input_field = ost.id_advanced_input_field
                               AND ai.multi_field_val = ost.vvalue
                             WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field = 91;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val      := NULL;
                                l_aux_val_desc := NULL;
                        END;
                    ELSE
                        BEGIN
                            SELECT ost.vvalue,
                                   pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain,
                                                           i_val      => ost.vvalue,
                                                           i_lang     => i_lang)
                              INTO l_aux_val, l_aux_val_desc
                              FROM order_set_process_task_det ost
                              JOIN advanced_input_multi_field ai
                                ON ai.id_advanced_input_field = ost.id_advanced_input_field
                               AND ai.multi_field_val = ost.vvalue
                             WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field = 91;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val      := NULL;
                                l_aux_val_desc := NULL;
                        END;
                    END IF;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_aux_val,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_aux_val_desc,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_to_be_executed
                      AND i_action = pk_order_sets.g_order_set_fo_request
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    BEGIN
                        SELECT a.multi_field_val,
                               pk_sysdomain.get_domain(i_code_dom => a.code_sys_domain,
                                                       i_val      => a.multi_field_val,
                                                       i_lang     => i_lang)
                          INTO l_aux_val, l_aux_val_desc
                          FROM advanced_input_multi_field a
                         WHERE a.id_advanced_input_field = 100
                           AND a.multi_field_val = 'E';
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_aux_val      := NULL;
                            l_aux_val_desc := NULL;
                    END;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_aux_val,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_aux_val_desc,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_read_only,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_frequency_n
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    IF i_action <> pk_order_sets.g_order_set_fo_request
                       OR i_action IS NULL
                    THEN
                        BEGIN
                            SELECT ost.vvalue, ost.id_unit_measure
                              INTO l_aux_val, l_aux_unit_measure
                              FROM order_set_task_detail ost
                             WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field = 98;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val          := NULL;
                                l_aux_unit_measure := NULL;
                        END;
                    ELSE
                        BEGIN
                            SELECT ost.vvalue, ost.id_unit_measure
                              INTO l_aux_val, l_aux_unit_measure
                              FROM order_set_process_task_det ost
                             WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field = 98;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val          := NULL;
                                l_aux_unit_measure := NULL;
                        END;
                    END IF;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_aux_val,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => CASE
                                                                                                 WHEN l_aux_val IS NOT NULL THEN
                                                                                                  l_aux_val || ' ' ||
                                                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                                               i_prof         => i_prof,
                                                                                                                                               i_unit_measure => l_aux_unit_measure)
                                                                                             END,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => l_aux_unit_measure,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => CASE i_action
                                                                                                 WHEN pk_order_sets.g_order_set_fo_request THEN
                                                                                                  pk_orders_constant.g_component_mandatory
                                                                                                 ELSE
                                                                                                  pk_orders_constant.g_component_active
                                                                                             END,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_start_date
                      AND i_action = pk_order_sets.g_order_set_fo_request
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    BEGIN
                        SELECT ost.dvalue
                          INTO l_dt_begin_tstz
                          FROM order_set_process_task_det ost
                         WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                           AND ost.id_advanced_input = 62
                           AND ost.id_advanced_input_field = 96;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_dt_begin_tstz := NULL;
                    END;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => CASE
                                                                                                 WHEN l_dt_begin_tstz IS NOT NULL THEN
                                                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                              i_date => l_dt_begin_tstz,
                                                                                                                              i_prof => i_prof)
                                                                                                 ELSE
                                                                                                  coalesce(l_dt_begin_send,
                                                                                                           pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                                       i_date => current_timestamp,
                                                                                                                                       i_prof => i_prof))
                                                                                             END,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_end_date
                      AND i_action = pk_order_sets.g_order_set_fo_request
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    BEGIN
                        SELECT ost.dvalue
                          INTO l_dt_end_tstz
                          FROM order_set_process_task_det ost
                         WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                           AND ost.id_advanced_input = 62
                           AND ost.id_advanced_input_field = 97;
                    EXCEPTION
                        WHEN no_data_found THEN
                            l_dt_end_tstz := NULL;
                    END;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => CASE
                                                                                                 WHEN l_dt_end_tstz IS NOT NULL THEN
                                                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                                              i_date => l_dt_end_tstz,
                                                                                                                              i_prof => i_prof)
                                                                                                 ELSE
                                                                                                  l_dt_end_send
                                                                                             END,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => NULL,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_notes
                THEN
                    l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                
                    IF i_action <> pk_order_sets.g_order_set_fo_request
                       OR i_action IS NULL
                    THEN
                        BEGIN
                            SELECT ost.vvalue
                              INTO l_aux_val
                              FROM order_set_task_detail ost
                             WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field IS NULL;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val := NULL;
                        END;
                    ELSE
                        BEGIN
                            SELECT ost.vvalue
                              INTO l_aux_val
                              FROM order_set_process_task_det ost
                             WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                               AND ost.id_advanced_input_field IS NULL;
                        EXCEPTION
                            WHEN no_data_found THEN
                                l_aux_val := NULL;
                        END;
                    END IF;
                
                    tbl_result.extend();
                    tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                       id_ds_component    => l_id_ds_component,
                                                                       internal_name      => i_tbl_int_name(i),
                                                                       VALUE              => l_aux_val,
                                                                       value_clob         => NULL,
                                                                       min_value          => NULL,
                                                                       max_value          => NULL,
                                                                       desc_value         => l_aux_val,
                                                                       desc_clob          => NULL,
                                                                       id_unit_measure    => NULL,
                                                                       desc_unit_measure  => NULL,
                                                                       flg_validation     => pk_alert_constant.g_yes,
                                                                       err_msg            => NULL,
                                                                       flg_event_type     => pk_orders_constant.g_component_active,
                                                                       flg_multi_status   => NULL,
                                                                       idx                => i_idx);
                
                END IF;
            END LOOP;
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_start_date
                THEN
                    l_aux_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                           i_value               => i_value);
                
                    IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                             i_prof          => i_prof,
                                                             i_id_episode    => i_episode,
                                                             o_dt_begin_tstz => l_dt_epis_begin,
                                                             o_error         => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => l_dt_epis_begin,
                                                                                                                     i_format    => 'MI'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_aux_val,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'MI'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_aux_val,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_alert_constant.g_yes
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'POSITIONING_T024')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_mandatory,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                
                    --Clear end date
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => NULL,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => pk_orders_constant.g_component_valid,
                                              err_msg            => NULL,
                                              flg_event_type     => coalesce(dd.flg_event_type,
                                                                             pk_orders_constant.g_component_active),
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                      LEFT JOIN ds_def_event dd
                        ON dd.id_ds_cmpt_mkt_rel = d.id_ds_cmpt_mkt_rel
                     WHERE d.internal_name_child = pk_orders_constant.g_ds_end_date
                       AND d.id_ds_cmpt_mkt_rel IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                     t.*
                                                      FROM TABLE(i_tbl_mkt_rel) t);
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_end_date
                THEN
                    l_aux_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                           i_value               => i_value);
                
                    l_dt_begin := pk_orders_utils.get_value(i_internal_name_child => pk_orders_constant.g_ds_start_date,
                                                            i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                            i_value               => i_value);
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_dt_begin,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'MI'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_aux_val,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'MI'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_aux_val,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_alert_constant.g_yes
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'COMMON_T067')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_active,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                END IF;
            END IF;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_os_monitoring_form_values;

    FUNCTION get_os_appointment_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_OS_APPOINTMENT_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_prioriy_val   VARCHAR2(4000 CHAR);
        l_priority_desc VARCHAR2(4000 CHAR);
    
        l_clinical_service_val  VARCHAR2(4000 CHAR);
        l_clinical_service_desc VARCHAR2(4000 CHAR);
    
        l_location_val  VARCHAR2(4000 CHAR);
        l_location_desc VARCHAR2(4000 CHAR);
    
        l_id_episode   episode.id_episode%TYPE;
        l_episode_desc VARCHAR2(4000 CHAR);
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    BEGIN
    
        IF (i_action IS NULL AND i_episode IS NULL)
           OR i_action IN (pk_order_sets.g_order_set_bo_edit_task)
        THEN
            --Priority
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_prioriy_val, l_priority_desc
                  FROM order_set_task_detail ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 91;
            EXCEPTION
                WHEN no_data_found THEN
                    l_prioriy_val   := NULL;
                    l_priority_desc := NULL;
            END;
        
            --Location
            BEGIN
                SELECT i.id_institution, pk_translation.get_translation(i_lang, i.code_institution)
                  INTO l_location_val, l_location_desc
                  FROM order_set_task_detail ost
                  LEFT JOIN institution i
                    ON i.id_institution = to_number(ost.nvalue)
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field IS NULL
                   AND ost.flg_detail_type = 'L'
                   AND ost.flg_value_type = 'N';
            EXCEPTION
                WHEN no_data_found THEN
                    l_location_val  := NULL;
                    l_location_desc := NULL;
            END;
        
            --Clinical service
            BEGIN
                SELECT dcs.id_dep_clin_serv, pk_translation.get_translation(i_lang, cs.code_clinical_service)
                  INTO l_clinical_service_val, l_clinical_service_desc
                  FROM order_set_task_detail ost
                  JOIN dep_clin_serv dcs
                    ON dcs.id_dep_clin_serv = to_number(ost.nvalue)
                  JOIN clinical_service cs
                    ON cs.id_clinical_service = dcs.id_clinical_service
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field IS NULL
                   AND ost.flg_detail_type = 'B'
                   AND ost.flg_value_type = 'N';
            EXCEPTION
                WHEN no_data_found THEN
                    l_clinical_service_val  := NULL;
                    l_clinical_service_desc := NULL;
            END;
        ELSIF i_action IN (pk_order_sets.g_order_set_fo_request)
              OR i_episode IS NOT NULL
        THEN
            --Priority
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_prioriy_val, l_priority_desc
                  FROM order_set_process_task_det ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 91;
            EXCEPTION
                WHEN no_data_found THEN
                    l_prioriy_val   := NULL;
                    l_priority_desc := NULL;
            END;
        
            --Location
            BEGIN
                SELECT i.id_institution, pk_translation.get_translation(i_lang, i.code_institution)
                  INTO l_location_val, l_location_desc
                  FROM order_set_process_task_det ost
                  LEFT JOIN institution i
                    ON i.id_institution = to_number(ost.nvalue)
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field IS NULL
                   AND ost.flg_detail_type = 'L'
                   AND ost.flg_value_type = 'N';
            EXCEPTION
                WHEN no_data_found THEN
                    l_location_val  := NULL;
                    l_location_desc := NULL;
            END;
        
            --Clinical service
            BEGIN
                SELECT dcs.id_dep_clin_serv, pk_translation.get_translation(i_lang, cs.code_clinical_service)
                  INTO l_clinical_service_val, l_clinical_service_desc
                  FROM order_set_process_task_det ost
                  JOIN dep_clin_serv dcs
                    ON dcs.id_dep_clin_serv = to_number(ost.nvalue)
                  JOIN clinical_service cs
                    ON cs.id_clinical_service = dcs.id_clinical_service
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field IS NULL
                   AND ost.flg_detail_type = 'B'
                   AND ost.flg_value_type = 'N';
            EXCEPTION
                WHEN no_data_found THEN
                    l_clinical_service_val  := NULL;
                    l_clinical_service_desc := NULL;
            END;
        
            --Episode
            BEGIN
                SELECT ospt.id_request
                  INTO l_id_episode
                  FROM order_set_process_task ospt
                 WHERE ospt.id_order_set_process_task = i_tbl_id_pk(2);
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_episode := NULL;
            END;
        
            IF l_id_episode IS NOT NULL
            THEN
                g_error := 'GETTING EPISODE TO EXECUTE DESC';
                SELECT /*+opt_estimate (table t rows=1)*/
                 t.event_type_name_title || ': ' || t.event_type_clinical_service || '; ' ||
                 (SELECT pk_translation.get_translation(i_lang, se.code_sch_event_abrv)
                    FROM sch_event se
                   WHERE se.id_sch_event = t.sch_event) || '; ' || t.professional
                  INTO l_episode_desc
                  FROM TABLE(pk_events.get_patient_future_events_pl(i_lang, i_prof, i_patient)) t
                 WHERE t.id_episode = l_id_episode;
            END IF;
        
        END IF;
    
        IF i_action IS NULL
           OR i_action IN (pk_order_sets.g_order_set_bo_edit_task, pk_order_sets.g_order_set_fo_request)
        THEN
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_order_set_task THEN
                                                                  to_char(i_tbl_id_pk(2))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  CASE i_root_name
                                                                  --O Flash est a utilizar sempre o 84, mas supostamente as reas tm ids distintos
                                                                      WHEN pk_orders_constant.g_ds_order_set_medical_appointment THEN
                                                                       to_char(84)
                                                                      WHEN pk_orders_constant.g_ds_order_set_nursing_appointment THEN
                                                                       to_char(84)
                                                                      WHEN pk_orders_constant.g_ds_order_set_rehab_appointment THEN
                                                                       to_char(84)
                                                                      WHEN pk_orders_constant.g_ds_order_set_social_appointment THEN
                                                                       to_char(84)
                                                                      WHEN pk_orders_constant.g_ds_order_set_diet_appointment THEN
                                                                       to_char(84)
                                                                  END
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_prioriy_val
                                                                 WHEN pk_orders_constant.g_ds_location THEN
                                                                  l_location_val
                                                                 WHEN pk_orders_constant.g_ds_specialty THEN
                                                                  l_clinical_service_val
                                                                 WHEN pk_orders_constant.g_ds_episode THEN
                                                                  to_char(l_id_episode)
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_priority_desc
                                                                 WHEN pk_orders_constant.g_ds_location THEN
                                                                  l_location_desc
                                                                 WHEN pk_orders_constant.g_ds_specialty THEN
                                                                  l_clinical_service_desc
                                                                 WHEN pk_orders_constant.g_ds_episode THEN
                                                                  l_episode_desc
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE
                                                                 WHEN i_action = pk_order_sets.g_order_set_fo_request
                                                                      OR i_episode IS NOT NULL THEN
                                                                  CASE
                                                                      WHEN d.internal_name IN (pk_orders_constant.g_ds_location, pk_orders_constant.g_ds_specialty) THEN
                                                                       pk_orders_constant.g_component_read_only
                                                                      WHEN d.internal_name = pk_orders_constant.g_ds_episode THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      ELSE
                                                                       coalesce(def.flg_event_type, pk_orders_constant.g_component_active)
                                                                  END
                                                                 ELSE
                                                                  coalesce(def.flg_event_type, pk_orders_constant.g_component_active)
                                                             END,
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_order_set_task,
                                       pk_orders_constant.g_ds_id_advanced_input,
                                       pk_orders_constant.g_ds_priority,
                                       pk_orders_constant.g_ds_location,
                                       pk_orders_constant.g_ds_specialty,
                                       pk_orders_constant.g_ds_episode)
             ORDER BY t.rn;
        
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_location
                THEN
                    g_error := 'SELECT INTO TBL_RESULT';
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => t.id_ds_component_child,
                                              internal_name      => t.internal_name_child,
                                              VALUE              => NULL,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => t.id_unit_measure,
                                              desc_unit_measure  => NULL,
                                              flg_validation     => pk_orders_constant.g_component_valid,
                                              err_msg            => NULL,
                                              flg_event_type     => def.flg_event_type,
                                              flg_multi_status   => pk_alert_constant.g_no,
                                              idx                => i_idx)
                      BULK COLLECT
                      INTO tbl_result
                      FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                                   dc.id_ds_component_child,
                                   dc.internal_name_child,
                                   dc.flg_event_type,
                                   dc.rn,
                                   dc.flg_component_type_child,
                                   dc.id_unit_measure
                              FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                                 i_prof           => i_prof,
                                                                 i_patient        => NULL,
                                                                 i_component_name => i_root_name,
                                                                 i_action         => NULL)) dc) t
                      JOIN ds_component d
                        ON d.id_ds_component = t.id_ds_component_child
                      LEFT JOIN ds_def_event def
                        ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
                     WHERE d.internal_name IN (pk_orders_constant.g_ds_specialty)
                     ORDER BY t.rn;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_episode
                THEN
                    l_id_episode := to_number(pk_orders_utils.get_value(l_curr_comp_int_name, i_tbl_mkt_rel, i_value));
                
                    IF l_id_episode IS NOT NULL
                    THEN
                        g_error := 'GETTING EPISODE TO EXECUTE DESC';
                        SELECT /*+opt_estimate (table t rows=1)*/
                         t.event_type_name_title || ': ' || t.event_type_clinical_service || '; ' ||
                         (SELECT pk_translation.get_translation(i_lang, se.code_sch_event_abrv)
                            FROM sch_event se
                           WHERE se.id_sch_event = t.sch_event) || '; ' || t.professional
                          INTO l_episode_desc
                          FROM TABLE(pk_events.get_patient_future_events_pl(i_lang, i_prof, i_patient)) t
                         WHERE t.id_episode = l_id_episode;
                    
                        tbl_result.extend();
                        tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_curr_component,
                                                                           id_ds_component    => pk_orders_utils.get_id_ds_component(i_curr_component),
                                                                           internal_name      => l_curr_comp_int_name,
                                                                           VALUE              => to_char(l_id_episode),
                                                                           value_clob         => NULL,
                                                                           min_value          => NULL,
                                                                           max_value          => NULL,
                                                                           desc_value         => l_episode_desc,
                                                                           desc_clob          => NULL,
                                                                           id_unit_measure    => NULL,
                                                                           desc_unit_measure  => NULL,
                                                                           flg_validation     => pk_orders_constant.g_component_valid,
                                                                           err_msg            => NULL,
                                                                           flg_event_type     => pk_orders_constant.g_component_mandatory,
                                                                           flg_multi_status   => NULL,
                                                                           idx                => i_idx);
                    END IF;
                END IF;
            END IF;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_os_appointment_form_values;

    FUNCTION get_os_discharge_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_OS_DISCHARGE_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_prioriy_val   VARCHAR2(4000 CHAR);
        l_priority_desc VARCHAR2(4000 CHAR);
    
        l_release_from_val  VARCHAR2(4000 CHAR);
        l_release_from_desc VARCHAR2(4000 CHAR);
    
        l_instructions_discussed_val  VARCHAR2(2 CHAR);
        l_instructions_discussed_desc VARCHAR2(4000 CHAR);
    
        l_id_follow_up_type  follow_up_type.id_follow_up_type%TYPE;
        l_follow_up_type_dec VARCHAR2(4000 CHAR);
    
        l_episode_due_to_desc    VARCHAR2(4000 CHAR);
        l_patient_diagnosed_with VARCHAR2(4000 CHAR);
        l_restrict_activity      VARCHAR2(4000 CHAR);
        l_patient_instructions   VARCHAR2(4000 CHAR);
    
        l_follow_up_val VARCHAR2(4000 CHAR);
    
        l_follow_up_prof      NUMBER(24);
        l_follow_up_prof_desc VARCHAR2(4000 CHAR);
    
        l_from_date       order_set_process_task_det.dvalue%TYPE;
        l_from_date_str   VARCHAR2(50 CHAR);
        l_to_date         order_set_process_task_det.dvalue%TYPE;
        l_to_date_str     VARCHAR2(50 CHAR);
        l_date_comparison VARCHAR2(1 CHAR);
    
        l_err_code_message sys_message.code_message%TYPE;
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    BEGIN
    
        IF (i_action IS NULL OR i_action IN (pk_order_sets.g_order_set_bo_edit_task))
           AND i_episode IS NULL
        THEN
            --Priority
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_prioriy_val, l_priority_desc
                  FROM order_set_task_detail ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 91;
            EXCEPTION
                WHEN no_data_found THEN
                    l_prioriy_val   := NULL;
                    l_priority_desc := NULL;
            END;
        
            --Release from
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_release_from_val, l_release_from_desc
                  FROM order_set_task_detail ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 102;
            EXCEPTION
                WHEN no_data_found THEN
                    l_release_from_val  := NULL;
                    l_release_from_desc := NULL;
            END;
        
            --Instructions discussed with 
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'DISCHARGE_NOTES.INSTRUCTIONS_DISCUSSED',
                                               i_val      => ost.vvalue,
                                               i_lang     => i_lang)
                  INTO l_instructions_discussed_val, l_instructions_discussed_desc
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'I';
            EXCEPTION
                WHEN no_data_found THEN
                    l_instructions_discussed_val  := NULL;
                    l_instructions_discussed_desc := NULL;
            END;
        
            --Follow up
            BEGIN
                SELECT ost.nvalue, pk_translation.get_translation(i_lang, fwt.code_follow_up_type), ost.vvalue
                  INTO l_id_follow_up_type, l_follow_up_type_dec, l_follow_up_val
                  FROM order_set_task_detail ost
                  JOIN follow_up_type fwt
                    ON fwt.id_follow_up_type = ost.nvalue
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'U';
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_follow_up_type  := NULL;
                    l_follow_up_type_dec := NULL;
                    l_follow_up_val      := NULL;
            END;
        
            --Episode due to
            BEGIN
                SELECT ost.vvalue
                  INTO l_episode_due_to_desc
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'E';
            EXCEPTION
                WHEN no_data_found THEN
                    l_episode_due_to_desc := NULL;
            END;
        
            --Patient diagnosed with
            BEGIN
                SELECT ost.vvalue
                  INTO l_patient_diagnosed_with
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'W';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_diagnosed_with := NULL;
            END;
        
            --Restrict activity for
            BEGIN
                SELECT ost.vvalue
                  INTO l_restrict_activity
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'V';
            EXCEPTION
                WHEN no_data_found THEN
                    l_restrict_activity := NULL;
            END;
        
            --Patient instructions
            BEGIN
                SELECT ost.vvalue
                  INTO l_patient_instructions
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'D';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_instructions := NULL;
            END;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_order_set_task THEN
                                                                  to_char(i_tbl_id_pk(2))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  to_char(52)
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_prioriy_val
                                                                 WHEN pk_orders_constant.g_ds_release_from THEN
                                                                  l_release_from_val
                                                                 WHEN pk_orders_constant.g_ds_care_instructions THEN
                                                                  l_instructions_discussed_val
                                                                 WHEN pk_orders_constant.g_ds_follow_up_on THEN
                                                                  to_char(l_id_follow_up_type)
                                                                 WHEN pk_orders_constant.g_ds_follow_up_date THEN
                                                                  l_follow_up_val
                                                                 WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                  l_follow_up_val
                                                                 WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                  l_episode_due_to_desc
                                                                 WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                  l_patient_diagnosed_with
                                                                 WHEN pk_orders_constant.g_ds_restrict_activity THEN
                                                                  l_restrict_activity
                                                                 WHEN pk_orders_constant.g_ds_patient_instructions THEN
                                                                  l_patient_instructions
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_priority_desc
                                                                 WHEN pk_orders_constant.g_ds_release_from THEN
                                                                  l_release_from_desc
                                                                 WHEN pk_orders_constant.g_ds_care_instructions THEN
                                                                  l_instructions_discussed_desc
                                                                 WHEN pk_orders_constant.g_ds_follow_up_on THEN
                                                                  l_follow_up_type_dec
                                                                 WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                  l_follow_up_val || ' ' ||
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                  l_episode_due_to_desc
                                                                 WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                  l_patient_diagnosed_with
                                                                 WHEN pk_orders_constant.g_ds_restrict_activity THEN
                                                                  l_restrict_activity
                                                                 WHEN pk_orders_constant.g_ds_patient_instructions THEN
                                                                  l_patient_instructions
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => coalesce(def.flg_event_type,
                                                                      CASE t.internal_name_child
                                                                          WHEN pk_orders_constant.g_ds_follow_up_date THEN
                                                                           CASE l_id_follow_up_type
                                                                               WHEN 1 THEN
                                                                                pk_orders_constant.g_component_mandatory
                                                                               WHEN 2 THEN
                                                                                pk_orders_constant.g_component_hidden
                                                                               ELSE
                                                                                pk_orders_constant.g_component_inactive
                                                                           END
                                                                          WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                           CASE l_id_follow_up_type
                                                                               WHEN 2 THEN
                                                                                pk_orders_constant.g_component_mandatory
                                                                               ELSE
                                                                                pk_orders_constant.g_component_hidden
                                                                           END
                                                                          ELSE
                                                                           pk_orders_constant.g_component_active
                                                                      END),
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_order_set_task,
                                       pk_orders_constant.g_ds_id_advanced_input,
                                       pk_orders_constant.g_ds_priority,
                                       pk_orders_constant.g_ds_release_from,
                                       pk_orders_constant.g_ds_care_instructions,
                                       pk_orders_constant.g_ds_follow_up_on,
                                       pk_orders_constant.g_ds_follow_up_date,
                                       pk_orders_constant.g_ds_follow_up_n,
                                       pk_orders_constant.g_ds_episode_due,
                                       pk_orders_constant.g_ds_patient_diagnosed,
                                       pk_orders_constant.g_ds_restrict_activity,
                                       pk_orders_constant.g_ds_patient_instructions)
             ORDER BY t.rn;
        ELSIF (i_action IS NULL OR i_action = pk_order_sets.g_order_set_fo_request)
              AND i_episode IS NOT NULL
        THEN
            --Priority
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_prioriy_val, l_priority_desc
                  FROM order_set_process_task_det ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 91;
            EXCEPTION
                WHEN no_data_found THEN
                    l_prioriy_val   := NULL;
                    l_priority_desc := NULL;
            END;
        
            --Release from
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => ai.code_sys_domain, i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_release_from_val, l_release_from_desc
                  FROM order_set_process_task_det ost
                  JOIN advanced_input_multi_field ai
                    ON ai.id_advanced_input_field = ost.id_advanced_input_field
                   AND ai.multi_field_val = ost.vvalue
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input_field = 102;
            EXCEPTION
                WHEN no_data_found THEN
                    l_release_from_val  := NULL;
                    l_release_from_desc := NULL;
            END;
        
            --Instructions discussed with 
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'DISCHARGE_NOTES.INSTRUCTIONS_DISCUSSED',
                                               i_val      => ost.vvalue,
                                               i_lang     => i_lang)
                  INTO l_instructions_discussed_val, l_instructions_discussed_desc
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'I';
            EXCEPTION
                WHEN no_data_found THEN
                    l_instructions_discussed_val  := NULL;
                    l_instructions_discussed_desc := NULL;
            END;
        
            --Follow up
            BEGIN
                SELECT ost.nvalue, pk_translation.get_translation(i_lang, fwt.code_follow_up_type), ost.vvalue
                  INTO l_id_follow_up_type, l_follow_up_type_dec, l_follow_up_val
                  FROM order_set_process_task_det ost
                  JOIN follow_up_type fwt
                    ON fwt.id_follow_up_type = ost.nvalue
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'U';
            EXCEPTION
                WHEN no_data_found THEN
                    l_id_follow_up_type  := NULL;
                    l_follow_up_type_dec := NULL;
                    l_follow_up_val      := NULL;
            END;
        
            --Episode due to
            BEGIN
                SELECT ost.vvalue
                  INTO l_episode_due_to_desc
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'E';
            EXCEPTION
                WHEN no_data_found THEN
                    l_episode_due_to_desc := NULL;
            END;
        
            --Patient diagnosed with
            BEGIN
                SELECT ost.vvalue
                  INTO l_patient_diagnosed_with
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'W';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_diagnosed_with := NULL;
            END;
        
            --Restrict activity for
            BEGIN
                SELECT ost.vvalue
                  INTO l_restrict_activity
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'V';
            EXCEPTION
                WHEN no_data_found THEN
                    l_restrict_activity := NULL;
            END;
        
            --Patient instructions
            BEGIN
                SELECT ost.vvalue
                  INTO l_patient_instructions
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'D';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_instructions := NULL;
            END;
        
            --Follow up by
            BEGIN
                SELECT /*+opt_estimate (table t rows=1)*/
                 t.domain_value, t.desc_domain
                  INTO l_follow_up_prof, l_follow_up_prof_desc
                  FROM TABLE(pk_discharge.tf_get_followup_with_wofreetext(i_lang => i_lang, i_prof => i_prof)) t
                  JOIN (SELECT to_number(ost.nvalue) id_prof
                          FROM order_set_process_task_det ost
                         WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                           AND ost.flg_detail_type = 'F') det
                    ON det.id_prof = to_number(t.domain_value);
            EXCEPTION
                WHEN no_data_found THEN
                    l_follow_up_prof      := NULL;
                    l_follow_up_prof_desc := l_follow_up_prof_desc;
            END;
        
            --From date
            BEGIN
                SELECT ost.dvalue
                  INTO l_from_date
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'A'
                   AND ost.id_advanced_input = 70
                   AND ost.id_advanced_input_field = 103;
            EXCEPTION
                WHEN no_data_found THEN
                    l_from_date := NULL;
            END;
        
            --To date
            BEGIN
                SELECT ost.dvalue
                  INTO l_to_date
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'A'
                   AND ost.id_advanced_input = 70
                   AND ost.id_advanced_input_field = 104;
            EXCEPTION
                WHEN no_data_found THEN
                    l_to_date := NULL;
            END;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  to_char(52)
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_prioriy_val
                                                                 WHEN pk_orders_constant.g_ds_release_from THEN
                                                                  l_release_from_val
                                                                 WHEN pk_orders_constant.g_ds_care_instructions THEN
                                                                  l_instructions_discussed_val
                                                                 WHEN pk_orders_constant.g_ds_follow_up_on THEN
                                                                  to_char(l_id_follow_up_type)
                                                                 WHEN pk_orders_constant.g_ds_follow_up_date THEN
                                                                  l_follow_up_val
                                                                 WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                  l_follow_up_val
                                                                 WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                  l_episode_due_to_desc
                                                                 WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                  l_patient_diagnosed_with
                                                                 WHEN pk_orders_constant.g_ds_restrict_activity THEN
                                                                  l_restrict_activity
                                                                 WHEN pk_orders_constant.g_ds_patient_instructions THEN
                                                                  l_patient_instructions
                                                                 WHEN pk_orders_constant.g_ds_follow_up_by THEN
                                                                  to_char(l_follow_up_prof)
                                                                 WHEN pk_orders_constant.g_ds_from_date THEN
                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                              i_date => l_from_date,
                                                                                              i_prof => i_prof)
                                                                 WHEN pk_orders_constant.g_ds_to_date THEN
                                                                  pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                              i_date => l_to_date,
                                                                                              i_prof => i_prof)
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_priority THEN
                                                                  l_priority_desc
                                                                 WHEN pk_orders_constant.g_ds_release_from THEN
                                                                  l_release_from_desc
                                                                 WHEN pk_orders_constant.g_ds_care_instructions THEN
                                                                  l_instructions_discussed_desc
                                                                 WHEN pk_orders_constant.g_ds_follow_up_on THEN
                                                                  l_follow_up_type_dec
                                                                 WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                  l_follow_up_val || ' ' ||
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                  l_episode_due_to_desc
                                                                 WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                  l_patient_diagnosed_with
                                                                 WHEN pk_orders_constant.g_ds_restrict_activity THEN
                                                                  l_restrict_activity
                                                                 WHEN pk_orders_constant.g_ds_patient_instructions THEN
                                                                  l_patient_instructions
                                                                 WHEN pk_orders_constant.g_ds_follow_up_by THEN
                                                                  l_follow_up_prof_desc
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_follow_up_date THEN
                                                                  CASE l_id_follow_up_type
                                                                      WHEN 1 THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      WHEN 2 THEN
                                                                       pk_orders_constant.g_component_hidden
                                                                      ELSE
                                                                       pk_orders_constant.g_component_inactive
                                                                  END
                                                                 WHEN pk_orders_constant.g_ds_follow_up_n THEN
                                                                  CASE l_id_follow_up_type
                                                                      WHEN 2 THEN
                                                                       pk_orders_constant.g_component_mandatory
                                                                      ELSE
                                                                       pk_orders_constant.g_component_hidden
                                                                  END
                                                                 WHEN pk_orders_constant.g_ds_episode_due THEN
                                                                  pk_orders_constant.g_component_active
                                                                 WHEN pk_orders_constant.g_ds_patient_diagnosed THEN
                                                                  pk_orders_constant.g_component_active
                                                                 WHEN pk_orders_constant.g_ds_from_date THEN
                                                                  pk_orders_constant.g_component_active
                                                                 WHEN pk_orders_constant.g_ds_to_date THEN
                                                                  pk_orders_constant.g_component_active
                                                                 WHEN pk_orders_constant.g_ds_follow_up_by THEN
                                                                  pk_orders_constant.g_component_mandatory
                                                                 WHEN pk_orders_constant.g_ds_follow_up_on THEN
                                                                  pk_orders_constant.g_component_mandatory
                                                                 ELSE
                                                                  coalesce(def.flg_event_type,
                                                                           pk_orders_constant.g_component_active)
                                                             END,
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_advanced_input,
                                       pk_orders_constant.g_ds_priority,
                                       pk_orders_constant.g_ds_release_from,
                                       pk_orders_constant.g_ds_care_instructions,
                                       pk_orders_constant.g_ds_follow_up_on,
                                       pk_orders_constant.g_ds_follow_up_date,
                                       pk_orders_constant.g_ds_follow_up_n,
                                       pk_orders_constant.g_ds_episode_due,
                                       pk_orders_constant.g_ds_patient_diagnosed,
                                       pk_orders_constant.g_ds_restrict_activity,
                                       pk_orders_constant.g_ds_patient_instructions,
                                       pk_orders_constant.g_ds_from_date,
                                       pk_orders_constant.g_ds_to_date,
                                       pk_orders_constant.g_ds_follow_up_by)
             ORDER BY t.rn;
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_follow_up_on
                THEN
                    l_id_follow_up_type := to_number(pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                                               i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                               i_value               => i_value));
                
                    FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(i) = pk_orders_constant.g_ds_follow_up_date
                        THEN
                            l_id_ds_component := pk_orders_utils.get_id_ds_component(i_tbl_mkt_rel(i));
                        
                            tbl_result.extend();
                            tbl_result(tbl_result.count) := t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                                               id_ds_component    => l_id_ds_component,
                                                                               internal_name      => i_tbl_int_name(i),
                                                                               VALUE              => NULL,
                                                                               value_clob         => NULL,
                                                                               min_value          => NULL,
                                                                               max_value          => NULL,
                                                                               desc_value         => NULL,
                                                                               desc_clob          => NULL,
                                                                               id_unit_measure    => NULL,
                                                                               desc_unit_measure  => NULL,
                                                                               flg_validation     => pk_alert_constant.g_yes,
                                                                               err_msg            => NULL,
                                                                               flg_event_type     => CASE
                                                                                                      l_id_follow_up_type
                                                                                                         WHEN 1 THEN
                                                                                                          pk_orders_constant.g_component_mandatory
                                                                                                         WHEN 2 THEN
                                                                                                          pk_orders_constant.g_component_hidden
                                                                                                         ELSE
                                                                                                          pk_orders_constant.g_component_inactive
                                                                                                     END,
                                                                               flg_multi_status   => NULL,
                                                                               idx                => i_idx);
                        ELSIF i_tbl_int_name(i) = pk_orders_constant.g_ds_follow_up_n
                        THEN
                            tbl_result.extend();
                            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_tbl_mkt_rel(i),
                                                      id_ds_component    => d.id_ds_component_child,
                                                      internal_name      => i_tbl_int_name(i),
                                                      VALUE              => NULL,
                                                      value_clob         => NULL,
                                                      min_value          => NULL,
                                                      max_value          => NULL,
                                                      desc_value         => NULL,
                                                      desc_clob          => NULL,
                                                      id_unit_measure    => d.id_unit_measure,
                                                      desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                         i_prof         => i_prof,
                                                                                                                         i_unit_measure => d.id_unit_measure),
                                                      flg_validation     => pk_alert_constant.g_yes,
                                                      err_msg            => NULL,
                                                      flg_event_type     => CASE l_id_follow_up_type
                                                                                WHEN 2 THEN
                                                                                 pk_orders_constant.g_component_mandatory
                                                                                ELSE
                                                                                 pk_orders_constant.g_component_hidden
                                                                            END,
                                                      flg_multi_status   => NULL,
                                                      idx                => i_idx)
                              INTO tbl_result(tbl_result.count)
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(i);
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_follow_up_n
                THEN
                    l_follow_up_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                                 i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                 i_value               => i_value);
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => i_curr_component,
                                               id_ds_component    => d.id_ds_component_child,
                                               internal_name      => l_curr_comp_int_name,
                                               VALUE              => l_follow_up_val,
                                               value_clob         => NULL,
                                               min_value          => NULL,
                                               max_value          => NULL,
                                               desc_value         => CASE
                                                                         WHEN l_follow_up_val IS NOT NULL THEN
                                                                          l_follow_up_val || ' ' ||
                                                                          pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                       i_prof         => i_prof,
                                                                                                                       i_unit_measure => d.id_unit_measure)
                                                                     END,
                                               desc_clob          => NULL,
                                               id_unit_measure    => d.id_unit_measure,
                                               desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                  i_prof         => i_prof,
                                                                                                                  i_unit_measure => d.id_unit_measure),
                                               flg_validation     => pk_alert_constant.g_yes,
                                               err_msg            => NULL,
                                               flg_event_type     => pk_orders_constant.g_component_mandatory,
                                               flg_multi_status   => NULL,
                                               idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_from_date
                THEN
                    l_from_date_str := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                                 i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                 i_value               => i_value);
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => current_timestamp,
                                                                                                                     i_format    => 'DD'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_from_date_str,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'DD'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_from_date_str,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_orders_constant.g_component_valid
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'COMMON_T066')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_active,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                
                    FOR j IN i_tbl_int_name.first .. i_tbl_int_name.last
                    LOOP
                        IF i_tbl_int_name(j) = pk_orders_constant.g_ds_to_date
                        THEN
                            tbl_result.extend();
                            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                                      id_ds_component    => d.id_ds_component_child,
                                                      internal_name      => d.internal_name_child,
                                                      VALUE              => NULL,
                                                      value_clob         => NULL,
                                                      min_value          => NULL,
                                                      max_value          => NULL,
                                                      desc_value         => NULL,
                                                      desc_clob          => NULL,
                                                      id_unit_measure    => d.id_unit_measure,
                                                      desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                         i_prof         => i_prof,
                                                                                                                         i_unit_measure => d.id_unit_measure),
                                                      flg_validation     => pk_orders_constant.g_component_valid,
                                                      err_msg            => NULL,
                                                      flg_event_type     => pk_orders_constant.g_component_active,
                                                      flg_multi_status   => NULL,
                                                      idx                => i_idx)
                              INTO tbl_result(tbl_result.count)
                              FROM ds_cmpt_mkt_rel d
                             WHERE d.id_ds_cmpt_mkt_rel = i_tbl_mkt_rel(j);
                            EXIT;
                        END IF;
                    END LOOP;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_to_date
                THEN
                    l_to_date_str := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                               i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                               i_value               => i_value);
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => current_timestamp,
                                                                                                                     i_format    => 'DD'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_to_date_str,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'DD'));
                
                    IF l_date_comparison <> 'G'
                    THEN
                        FOR i IN i_tbl_int_name.first .. i_tbl_int_name.last
                        LOOP
                            IF i_tbl_int_name(i) = pk_orders_constant.g_ds_from_date
                            THEN
                                l_from_date_str := i_value(i) (1);
                                EXIT;
                            END IF;
                        END LOOP;
                    
                        IF l_from_date_str IS NOT NULL
                        THEN
                            l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                                 i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                             i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                          i_prof,
                                                                                                                                                                          l_from_date_str,
                                                                                                                                                                          NULL),
                                                                                                                             i_format    => 'DD'),
                                                                                 i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                             i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                          i_prof,
                                                                                                                                                                          l_to_date_str,
                                                                                                                                                                          NULL),
                                                                                                                             i_format    => 'DD'));
                        END IF;
                    
                        IF l_date_comparison = 'G'
                        THEN
                            l_err_code_message := 'COMMON_T067';
                        END IF;
                    ELSE
                        l_err_code_message := 'COMMON_T066';
                    END IF;
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_to_date_str,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_alert_constant.g_yes
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, l_err_code_message)
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_active,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_follow_up_date
                THEN
                    l_from_date_str := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                                 i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                                 i_value               => i_value);
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => current_timestamp,
                                                                                                                     i_format    => 'DD'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_from_date_str,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'DD'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_from_date_str,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_orders_constant.g_component_valid
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'COMMON_T066')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_active,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                END IF;
            END IF;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_os_discharge_form_values;

    FUNCTION get_os_personalised_diet_form_values
    (
        i_lang           IN NUMBER,
        i_prof           IN profissional,
        i_episode        IN NUMBER,
        i_patient        IN NUMBER,
        i_action         IN NUMBER,
        i_root_name      IN VARCHAR2,
        i_curr_component IN NUMBER,
        i_idx            IN NUMBER DEFAULT 1,
        i_tbl_id_pk      IN table_number,
        i_tbl_mkt_rel    IN table_number,
        i_tbl_int_name   IN table_varchar,
        i_value          IN table_table_varchar,
        i_value_mea      IN table_table_varchar,
        i_value_desc     IN table_table_varchar,
        i_tbl_data       IN table_table_varchar,
        i_value_clob     IN table_clob,
        o_error          OUT t_error_out
    ) RETURN t_tbl_ds_get_value IS
    
        l_db_object_name CONSTANT user_objects.object_name%TYPE := 'GET_OS_PERSONALISED_DIET_FORM_VALUES';
    
        l_curr_comp_int_name ds_component.internal_name%TYPE;
        l_id_ds_component    ds_component.id_ds_component%TYPE;
    
        l_aux_val          VARCHAR2(4000 CHAR);
        l_aux_val_desc     VARCHAR2(4000 CHAR);
        l_aux_unit_measure NUMBER(24);
    
        l_patient_assistance            VARCHAR2(1 CHAR);
        l_patient_assistance_desc       VARCHAR2(20 CHAR) := NULL;
        l_continue_after_discharge      VARCHAR2(1 CHAR);
        l_continue_after_discharge_desc VARCHAR2(20 CHAR) := NULL;
    
        l_dt_begin      VARCHAR2(100 CHAR);
        l_dt_end        VARCHAR2(100 CHAR);
        l_dt_end_send   VARCHAR2(100 CHAR);
        l_dt_begin_send VARCHAR2(100 CHAR);
    
        --Front office variables
        l_flg_edit_dt_begin VARCHAR2(1 CHAR);
        l_interval          VARCHAR2(100 CHAR);
        l_interval_send     VARCHAR2(100 CHAR);
        l_flg_edit_interval VARCHAR2(1 CHAR);
        l_flg_edit_dt_end   VARCHAR2(1 CHAR);
        l_flg_min_date      VARCHAR2(1 CHAR);
        l_dt_begin_tstz     order_set_process_task_det.dvalue%TYPE;
        l_dt_end_tstz       order_set_process_task_det.dvalue%TYPE;
        l_date_comparison   VARCHAR2(1 CHAR);
        l_dt_epis_begin     episode.dt_begin_tstz%TYPE;
    
        --Return variable
        tbl_result t_tbl_ds_get_value := t_tbl_ds_get_value();
    
        l_exception EXCEPTION;
    BEGIN
        IF i_action IS NULL
           OR i_action = pk_order_sets.g_order_set_bo_edit_task
        THEN
            BEGIN
                --Patient assistance           
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'YES_NO', i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_patient_assistance, l_patient_assistance_desc
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'H';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_assistance      := NULL;
                    l_patient_assistance_desc := NULL;
            END;
        
            --Continue diet after discharge
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'YES_NO', i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_continue_after_discharge, l_continue_after_discharge_desc
                  FROM order_set_task_detail ost
                 WHERE ost.id_order_set_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'X';
            EXCEPTION
                WHEN no_data_found THEN
                    l_continue_after_discharge      := NULL;
                    l_continue_after_discharge_desc := NULL;
            END;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_patient_assistance THEN
                                                                  l_patient_assistance
                                                                 WHEN pk_orders_constant.g_ds_diet_after_discharge THEN
                                                                  l_continue_after_discharge
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_order_set_task THEN
                                                                  to_char(i_tbl_id_pk(2))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  NULL
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_patient_assistance THEN
                                                                  l_patient_assistance_desc
                                                                 WHEN pk_orders_constant.g_ds_diet_after_discharge THEN
                                                                  l_continue_after_discharge_desc
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => nvl(def.flg_event_type,
                                                                 CASE
                                                                     WHEN t.internal_name_child IN
                                                                          (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_to_date) THEN
                                                                      pk_orders_constant.g_component_inactive
                                                                 END),
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_start_date,
                                       pk_orders_constant.g_ds_to_date,
                                       pk_orders_constant.g_ds_patient_assistance,
                                       pk_orders_constant.g_ds_diet_after_discharge,
                                       pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_order_set_task,
                                       pk_orders_constant.g_ds_id_advanced_input)
             ORDER BY t.rn;
        ELSIF i_action = pk_order_sets.g_order_set_fo_request
        THEN
            BEGIN
                --Patient assistance           
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'YES_NO', i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_patient_assistance, l_patient_assistance_desc
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'H';
            EXCEPTION
                WHEN no_data_found THEN
                    l_patient_assistance      := NULL;
                    l_patient_assistance_desc := NULL;
            END;
        
            --Continue diet after discharge
            BEGIN
                SELECT ost.vvalue,
                       pk_sysdomain.get_domain(i_code_dom => 'YES_NO', i_val => ost.vvalue, i_lang => i_lang)
                  INTO l_continue_after_discharge, l_continue_after_discharge_desc
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.flg_detail_type = 'X';
            EXCEPTION
                WHEN no_data_found THEN
                    l_continue_after_discharge      := NULL;
                    l_continue_after_discharge_desc := NULL;
            END;
        
            --START DATE
            BEGIN
                SELECT ost.dvalue
                  INTO l_dt_begin_tstz
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input = 82
                   AND ost.id_advanced_input_field = 136;
            EXCEPTION
                WHEN no_data_found THEN
                    l_dt_begin_tstz := NULL;
            END;
        
            --END DATE
            BEGIN
                SELECT ost.dvalue
                  INTO l_dt_end_tstz
                  FROM order_set_process_task_det ost
                 WHERE ost.id_order_set_process_task = i_tbl_id_pk(2)
                   AND ost.id_advanced_input = 82
                   AND ost.id_advanced_input_field = 137;
            EXCEPTION
                WHEN no_data_found THEN
                    l_dt_end_tstz := NULL;
            END;
        
            g_error := 'Error calling pk_list.monit_dates_manage';
            IF NOT pk_list.monit_dates_manage(i_lang              => i_lang,
                                              i_flg_time          => 'E',
                                              i_flg_tp            => 'M',
                                              i_prof              => i_prof,
                                              i_episode           => i_episode,
                                              o_dt_begin          => l_dt_begin,
                                              o_flg_edit_dt_begin => l_flg_edit_dt_begin,
                                              o_interval          => l_interval,
                                              o_interval_send     => l_interval_send,
                                              o_flg_edit_interval => l_flg_edit_interval,
                                              o_dt_end            => l_dt_end,
                                              o_dt_end_send       => l_dt_end_send,
                                              o_dt_begin_send     => l_dt_begin_send,
                                              o_flg_edit_dt_end   => l_flg_edit_dt_end,
                                              o_flg_min_date      => l_flg_min_date,
                                              o_error             => o_error)
            
            THEN
                l_dt_begin      := NULL;
                l_dt_begin_send := NULL;
                l_dt_end        := NULL;
                l_dt_end_send   := NULL;
            END IF;
        
            g_error := 'SELECT INTO TBL_RESULT';
            SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => t.id_ds_cmpt_mkt_rel,
                                       id_ds_component    => t.id_ds_component_child,
                                       internal_name      => t.internal_name_child,
                                       VALUE              => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_patient_assistance THEN
                                                                  l_patient_assistance
                                                                 WHEN pk_orders_constant.g_ds_diet_after_discharge THEN
                                                                  l_continue_after_discharge
                                                                 WHEN pk_orders_constant.g_ds_id_task_type THEN
                                                                  to_char(i_tbl_id_pk(1))
                                                                 WHEN pk_orders_constant.g_ds_id_advanced_input THEN
                                                                  NULL
                                                                 WHEN pk_orders_constant.g_ds_start_date THEN
                                                                  CASE
                                                                      WHEN l_dt_begin_tstz IS NOT NULL THEN
                                                                       pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_dt_begin_tstz, i_prof => i_prof)
                                                                      ELSE
                                                                       coalesce(l_dt_begin_send,
                                                                                pk_date_utils.date_send_tsz(i_lang => i_lang,
                                                                                                            i_date => current_timestamp,
                                                                                                            i_prof => i_prof))
                                                                  END
                                                                 WHEN pk_orders_constant.g_ds_to_date THEN
                                                                  CASE
                                                                      WHEN l_dt_end_tstz IS NOT NULL THEN
                                                                       pk_date_utils.date_send_tsz(i_lang => i_lang, i_date => l_dt_end_tstz, i_prof => i_prof)
                                                                      ELSE
                                                                       l_dt_end_send
                                                                  END
                                                             END,
                                       value_clob         => NULL,
                                       min_value          => NULL,
                                       max_value          => NULL,
                                       desc_value         => CASE t.internal_name_child
                                                                 WHEN pk_orders_constant.g_ds_patient_assistance THEN
                                                                  l_patient_assistance_desc
                                                                 WHEN pk_orders_constant.g_ds_diet_after_discharge THEN
                                                                  l_continue_after_discharge_desc
                                                             END,
                                       desc_clob          => NULL,
                                       id_unit_measure    => t.id_unit_measure,
                                       desc_unit_measure  => CASE
                                                                 WHEN t.id_unit_measure IS NOT NULL THEN
                                                                  pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                               i_prof         => i_prof,
                                                                                                               i_unit_measure => t.id_unit_measure)
                                                                 ELSE
                                                                  NULL
                                                             END,
                                       flg_validation     => pk_orders_constant.g_component_valid,
                                       err_msg            => NULL,
                                       flg_event_type     => nvl(def.flg_event_type,
                                                                 CASE
                                                                     WHEN t.internal_name_child IN
                                                                          (pk_orders_constant.g_ds_start_date, pk_orders_constant.g_ds_to_date) THEN
                                                                      pk_orders_constant.g_component_mandatory
                                                                 END),
                                       flg_multi_status   => pk_alert_constant.g_no,
                                       idx                => i_idx)
              BULK COLLECT
              INTO tbl_result
              FROM (SELECT dc.id_ds_cmpt_mkt_rel,
                           dc.id_ds_component_child,
                           dc.internal_name_child,
                           dc.flg_event_type,
                           dc.rn,
                           dc.flg_component_type_child,
                           dc.id_unit_measure
                      FROM TABLE(pk_dyn_form.get_dyn_cfg(i_lang           => i_lang,
                                                         i_prof           => i_prof,
                                                         i_patient        => NULL,
                                                         i_component_name => i_root_name,
                                                         i_action         => NULL)) dc) t
              JOIN ds_component d
                ON d.id_ds_component = t.id_ds_component_child
              LEFT JOIN ds_def_event def
                ON def.id_ds_cmpt_mkt_rel = t.id_ds_cmpt_mkt_rel
             WHERE d.internal_name IN (pk_orders_constant.g_ds_start_date,
                                       pk_orders_constant.g_ds_to_date,
                                       pk_orders_constant.g_ds_patient_assistance,
                                       pk_orders_constant.g_ds_diet_after_discharge,
                                       pk_orders_constant.g_ds_id_task_type,
                                       pk_orders_constant.g_ds_id_advanced_input)
             ORDER BY t.rn;
        ELSIF i_action = pk_dyn_form_constant.get_submit_action
        THEN
            IF i_curr_component IS NOT NULL
            THEN
                --Check which element has been changed
                SELECT d.internal_name_child
                  INTO l_curr_comp_int_name
                  FROM ds_cmpt_mkt_rel d
                 WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
            
                IF l_curr_comp_int_name = pk_orders_constant.g_ds_start_date
                THEN
                    l_aux_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                           i_value               => i_value);
                
                    IF NOT pk_episode.get_epis_dt_begin_tstz(i_lang          => i_lang,
                                                             i_prof          => i_prof,
                                                             i_id_episode    => i_episode,
                                                             o_dt_begin_tstz => l_dt_epis_begin,
                                                             o_error         => o_error)
                    THEN
                        RAISE g_other_exception;
                    END IF;
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => l_dt_epis_begin,
                                                                                                                     i_format    => 'MI'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_aux_val,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'MI'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_aux_val,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_alert_constant.g_yes
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'POSITIONING_T024')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_mandatory,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                
                    --Clear end date
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => NULL,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => pk_orders_constant.g_component_valid,
                                              err_msg            => NULL,
                                              flg_event_type     => pk_orders_constant.g_component_mandatory,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.internal_name_child = pk_orders_constant.g_ds_to_date
                       AND d.id_ds_cmpt_mkt_rel IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                     t.*
                                                      FROM TABLE(i_tbl_mkt_rel) t);
                ELSIF l_curr_comp_int_name = pk_orders_constant.g_ds_to_date
                THEN
                    l_aux_val := pk_orders_utils.get_value(i_internal_name_child => l_curr_comp_int_name,
                                                           i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                           i_value               => i_value);
                
                    l_dt_begin := pk_orders_utils.get_value(i_internal_name_child => pk_orders_constant.g_ds_start_date,
                                                            i_tbl_mkt_rel         => i_tbl_mkt_rel,
                                                            i_value               => i_value);
                
                    l_date_comparison := pk_date_utils.compare_dates_tsz(i_prof  => i_prof,
                                                                         i_date1 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_dt_begin,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'DD'),
                                                                         i_date2 => pk_date_utils.trunc_insttimezone(i_prof      => i_prof,
                                                                                                                     i_timestamp => pk_date_utils.get_string_tstz(i_lang,
                                                                                                                                                                  i_prof,
                                                                                                                                                                  l_aux_val,
                                                                                                                                                                  NULL),
                                                                                                                     i_format    => 'DD'));
                
                    tbl_result.extend();
                    SELECT t_rec_ds_get_value(id_ds_cmpt_mkt_rel => d.id_ds_cmpt_mkt_rel,
                                              id_ds_component    => d.id_ds_component_child,
                                              internal_name      => d.internal_name_child,
                                              VALUE              => l_aux_val,
                                              value_clob         => NULL,
                                              min_value          => NULL,
                                              max_value          => NULL,
                                              desc_value         => NULL,
                                              desc_clob          => NULL,
                                              id_unit_measure    => d.id_unit_measure,
                                              desc_unit_measure  => pk_unit_measure.get_unit_measure_description(i_lang         => i_lang,
                                                                                                                 i_prof         => i_prof,
                                                                                                                 i_unit_measure => d.id_unit_measure),
                                              flg_validation     => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_orders_constant.g_component_error
                                                                        ELSE
                                                                         pk_alert_constant.g_yes
                                                                    END,
                                              err_msg            => CASE l_date_comparison
                                                                        WHEN 'G' THEN
                                                                         pk_message.get_message(i_lang, 'COMMON_T067')
                                                                    END,
                                              flg_event_type     => pk_orders_constant.g_component_mandatory,
                                              flg_multi_status   => NULL,
                                              idx                => i_idx)
                      INTO tbl_result(tbl_result.count)
                      FROM ds_cmpt_mkt_rel d
                     WHERE d.id_ds_cmpt_mkt_rel = i_curr_component;
                END IF;
            END IF;
        END IF;
    
        RETURN tbl_result;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              l_db_object_name,
                                              o_error);
            RETURN NULL;
    END get_os_personalised_diet_form_values;

    FUNCTION get_odst_diagnosis_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_clinical_indications CLOB;
        l_rec_diagnoses        pk_edis_types.rec_in_epis_diagnosis;
        l_diagnosis_desc       table_varchar;
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_error t_error_out;
    BEGIN
    
        -- get order set clinical indications/diagnoses descriptions
        SELECT os.clinical_indications
          INTO l_clinical_indications
          FROM order_set os
         WHERE os.id_order_set = i_id_order_set;
    
        -- get diagnosis records
        IF l_clinical_indications IS NOT NULL
        THEN
            l_rec_diagnoses := pk_diagnosis.get_diag_rec(i_lang   => i_lang,
                                                         i_prof   => i_prof,
                                                         i_params => l_clinical_indications);
        
            l_diagnosis_desc := table_varchar();
            l_diagnosis_desc.extend(l_rec_diagnoses.tbl_diagnosis.count);
        
            -- get description of each diagnosis record
            FOR i IN 1 .. l_rec_diagnoses.tbl_diagnosis.count
            LOOP
                l_diagnosis_desc(i) := pk_diagnosis.get_diag_desc(i_lang, i_prof, l_rec_diagnoses.tbl_diagnosis(i));
            END LOOP;
        ELSE
            l_diagnosis_desc := table_varchar();
        END IF;
    
        SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_diagnosis_desc, pk_order_sets.g_separator),
                                                    pk_order_sets.g_trunc_clob_max_size)
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_DIAGNOSIS_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_diagnosis_desc;

    FUNCTION get_odst_reason_for_visit_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_tbl_reason_for_visit_desc table_varchar := table_varchar();
    
        l_error t_error_out;
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, c.code_complaint) chief_complaint_desc
          BULK COLLECT
          INTO l_tbl_reason_for_visit_desc
          FROM complaint c
          JOIN order_set_link ost_lnk
            ON ost_lnk.id_link = c.id_complaint
           AND ost_lnk.flg_link_type IN
               (pk_order_sets.g_order_set_link_chief_compl, pk_order_sets.g_order_set_link_reason_visit)
         WHERE ost_lnk.id_order_set = i_id_order_set
         ORDER BY chief_complaint_desc;
    
        SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_tbl_reason_for_visit_desc,
                                                                            pk_order_sets.g_separator),
                                                    pk_order_sets.g_trunc_clob_max_size)
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_REASON_FOR_VISIT_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_reason_for_visit_desc;

    FUNCTION get_odst_order_set_type_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_tbl_order_set_type_desc table_varchar := table_varchar();
    
        l_error t_error_out;
    BEGIN
    
        SELECT pk_sys_list.get_sys_list_value_desc(i_lang, i_prof, ost_lnk.id_link) order_set_type_desc
          BULK COLLECT
          INTO l_tbl_order_set_type_desc
          FROM order_set_link ost_lnk
         WHERE ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_odst_type
           AND ost_lnk.id_order_set = i_id_order_set
         ORDER BY order_set_type_desc;
    
        SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_tbl_order_set_type_desc,
                                                                            pk_order_sets.g_separator),
                                                    pk_order_sets.g_trunc_clob_max_size)
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_ORDER_SET_TYPE_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_order_set_type_desc;

    FUNCTION get_odst_institution_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_tbl_inst_desc table_varchar := table_varchar();
    
        l_error t_error_out;
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, i.code_institution) inst_desc
          BULK COLLECT
          INTO l_tbl_inst_desc
          FROM institution i
          JOIN order_set_link ost_lnk
            ON ost_lnk.id_link = i.id_institution
           AND ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_institution
         WHERE ost_lnk.id_order_set = i_id_order_set
         ORDER BY inst_desc;
    
        SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_tbl_inst_desc, pk_order_sets.g_separator),
                                                    pk_order_sets.g_trunc_clob_max_size)
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_INSTITUTION_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_institution_desc;

    FUNCTION get_odst_department_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_tbl_dept_desc table_varchar := table_varchar();
    
        l_error t_error_out;
    BEGIN
    
        SELECT pk_translation.get_translation(i_lang, d.code_dept) dept_desc
          BULK COLLECT
          INTO l_tbl_dept_desc
          FROM dept d
          JOIN order_set_link ost_lnk
            ON ost_lnk.id_link = d.id_dept
           AND ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_envi
         WHERE ost_lnk.id_order_set = i_id_order_set
         ORDER BY dept_desc;
    
        SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_tbl_dept_desc, pk_order_sets.g_separator),
                                                    pk_order_sets.g_trunc_clob_max_size)
          INTO l_ret
          FROM dual;
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_DEPARTMENT_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_department_desc;

    FUNCTION get_odst_clin_serv_desc
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE
    ) RETURN VARCHAR2 IS
    
        l_ret VARCHAR2(4000 CHAR);
    
        l_tbl_dept           table_varchar := table_varchar();
        l_tbl_clin_serv_desc table_varchar := table_varchar();
    
        l_error t_error_out;
    BEGIN
    
        SELECT to_char(ost_lnk.id_link)
          BULK COLLECT
          INTO l_tbl_dept
          FROM order_set_link ost_lnk
         WHERE ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_envi
           AND ost_lnk.id_order_set = i_id_order_set;
    
        IF l_tbl_dept.count > 0
        THEN
        
            SELECT t.desc_domain
              BULK COLLECT
              INTO l_tbl_clin_serv_desc
              FROM TABLE(pk_order_sets.get_services_list(i_lang => i_lang, i_prof => i_prof, i_tbl_dept => l_tbl_dept)) t
              JOIN order_set_link ost_lnk
                ON ost_lnk.id_link = to_number(t.domain_value)
               AND ost_lnk.flg_link_type = pk_order_sets.g_order_set_link_clin_serv
             WHERE ost_lnk.id_order_set = i_id_order_set
             ORDER BY t.order_rank, t.desc_domain;
        
            SELECT pk_order_sets.trunc_clob_to_varchar2(pk_utils.concat_table_l(l_tbl_clin_serv_desc,
                                                                                pk_order_sets.g_separator),
                                                        pk_order_sets.g_trunc_clob_max_size)
              INTO l_ret
              FROM dual;
        END IF;
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_CLIN_SERV_DESC',
                                              l_error);
            RETURN NULL;
    END get_odst_clin_serv_desc;

    FUNCTION get_odst_detail
    (
        i_lang      IN language.id_language%TYPE,
        i_prof      IN profissional,
        i_order_set IN order_set.id_order_set%TYPE,
        o_detail    OUT pk_types.cursor_type,
        o_error     OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tab_dd_block_data  t_tab_dd_block_data := t_tab_dd_block_data();
        l_tab_dd_block_tasks t_tab_dd_block_data := t_tab_dd_block_data();
    
        l_tab_dd_data      t_tab_dd_data := t_tab_dd_data();
        l_data_source_list table_varchar := table_varchar();
    
        --l_tbl_actions table_varchar := table_varchar();
    
    BEGIN
    
        SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                   ddb.rank,
                                   NULL,
                                   NULL,
                                   ddb.condition_val,
                                   NULL,
                                   NULL,
                                   dd.data_source,
                                   dd.data_source_val,
                                   NULL)
          BULK COLLECT
          INTO l_tab_dd_block_data
          FROM (SELECT data_source, data_source_val
                  FROM (SELECT *
                          FROM (SELECT NULL action,
                                       odst.title,
                                       pk_order_sets.get_odst_order_set_type_desc(i_lang, i_prof, odst.id_order_set) order_set_type_desc,
                                       odst.author_desc,
                                       pk_order_sets.get_odst_institution_desc(i_lang, i_prof, odst.id_order_set) institution_desc,
                                       pk_order_sets.get_odst_department_desc(i_lang, i_prof, odst.id_order_set) department_desc,
                                       pk_order_sets.get_odst_clin_serv_desc(i_lang, i_prof, odst.id_order_set) clin_serv_desc,
                                       pk_sysdomain.get_domain('ORDER_SET.FLG_TARGET_PROFESSIONALS',
                                                               odst.flg_target_professionals,
                                                               i_lang) target_profs_desc,
                                       pk_sysdomain.get_domain('ORDER_SET.FLG_EDIT_PERMISSIONS',
                                                               odst.flg_edit_permissions,
                                                               i_lang) edit_perms_desc,
                                       pk_order_sets.get_odst_reason_for_visit_desc(i_lang, i_prof, odst.id_order_set) reason_for_visit_desc,
                                       pk_order_sets.get_odst_diagnosis_desc(i_lang, i_prof, odst.id_order_set) diagnosis_desc,
                                       odst.notes_global,
                                       CASE
                                            WHEN odst.id_order_set_previous_version IS NULL THEN
                                             pk_prof_utils.get_name_signature(i_lang, i_prof, odst.id_professional) ||
                                             decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                                     i_prof,
                                                                                     odst.id_professional,
                                                                                     odst.dt_order_set_tstz,
                                                                                     NULL),
                                                    NULL,
                                                    '; ',
                                                    ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                                             i_prof,
                                                                                             odst.id_professional,
                                                                                             odst.dt_order_set_tstz,
                                                                                             NULL) || '); ') ||
                                             pk_date_utils.date_char_tsz(i_lang,
                                                                         odst.dt_order_set_tstz,
                                                                         i_prof.institution,
                                                                         i_prof.software)
                                        END registry,
                                       CASE
                                            WHEN odst.id_order_set_previous_version IS NOT NULL THEN
                                             pk_prof_utils.get_name_signature(i_lang, i_prof, odst.id_professional) ||
                                             decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                                     i_prof,
                                                                                     odst.id_professional,
                                                                                     odst.dt_order_set_tstz,
                                                                                     NULL),
                                                    NULL,
                                                    '; ',
                                                    ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                                             i_prof,
                                                                                             odst.id_professional,
                                                                                             odst.dt_order_set_tstz,
                                                                                             NULL) || '); ') ||
                                             pk_date_utils.date_char_tsz(i_lang,
                                                                         odst.dt_order_set_tstz,
                                                                         i_prof.institution,
                                                                         i_prof.software)
                                        END updated,
                                       ' ' white_line
                                  FROM order_set odst
                                  LEFT OUTER JOIN professional prof
                                    ON (odst.id_professional = prof.id_professional)
                                 WHERE odst.id_order_set = i_order_set) unpivot include NULLS(data_source_val FOR data_source IN(action,
                                                                                                                                 title,
                                                                                                                                 order_set_type_desc,
                                                                                                                                 author_desc,
                                                                                                                                 institution_desc,
                                                                                                                                 department_desc,
                                                                                                                                 clin_serv_desc,
                                                                                                                                 target_profs_desc,
                                                                                                                                 edit_perms_desc,
                                                                                                                                 reason_for_visit_desc,
                                                                                                                                 diagnosis_desc,
                                                                                                                                 notes_global,
                                                                                                                                 registry,
                                                                                                                                 updated,
                                                                                                                                 white_line)))) dd
          JOIN dd_block ddb
            ON ddb.area = 'ORDER_SET_BO'
           AND ddb.id_dd_block = 1
           AND ddb.flg_available = pk_alert_constant.g_yes;
    
        SELECT t_rec_dd_block_data(ddb.id_dd_block,
                                   rownum(), --ddb.rank,
                                   NULL,
                                   NULL,
                                   ddb.condition_val,
                                   NULL,
                                   NULL,
                                   dd.data_source,
                                   dd.data_source_val,
                                   NULL)
          BULK COLLECT
          INTO l_tab_dd_block_tasks
          FROM (SELECT data_source, data_source_val
                  FROM (SELECT *
                          FROM (SELECT /*+opt_estimate (table t rows=1)*/
                                 CASE
                                      WHEN t.rn = 1 THEN
                                       ' '
                                      ELSE
                                       NULL
                                  END action,
                                 CASE
                                      WHEN t.task_rn = 1
                                           AND t.task_type_desc IS NOT NULL THEN
                                       '<b>' || t.task_type_desc || '</b>'
                                      ELSE
                                       NULL
                                  END task_type,
                                 t.task_title,
                                 t.task_instruct task_instructions,
                                 t.dependency_desc dependency,
                                 t.order_status_desc order_status,
                                 t.registry,
                                 t.updated,
                                 ' ' white_line
                                  FROM TABLE(pk_order_sets.tf_get_odst_tasks_details(i_lang         => i_lang,
                                                                                     i_prof         => i_prof,
                                                                                     i_id_order_set => i_order_set)) t) unpivot include NULLS(data_source_val FOR data_source IN(action,
                                                                                                                                                                                 task_type,
                                                                                                                                                                                 task_title,
                                                                                                                                                                                 task_instructions,
                                                                                                                                                                                 dependency,
                                                                                                                                                                                 order_status,
                                                                                                                                                                                 registry,
                                                                                                                                                                                 updated,
                                                                                                                                                                                 white_line)))) dd
          JOIN dd_block ddb
            ON ddb.area = 'ORDER_SET_BO'
           AND ddb.id_dd_block = 2
           AND ddb.flg_available = pk_alert_constant.g_yes;
    
        SELECT t_rec_dd_data(CASE
                                  WHEN data_code_message IS NOT NULL THEN
                                   pk_message.get_message(i_lang => i_lang, i_code_mess => data_code_message)
                                  ELSE
                                   NULL
                              END, --DESCR
                              CASE
                                  WHEN flg_type = 'L1' THEN
                                   NULL
                                  ELSE
                                   data_source_val
                              END, --VAL
                              flg_type,
                              flg_html,
                              NULL,
                              flg_clob), --TYPE
               data_source
          BULK COLLECT
          INTO l_tab_dd_data, l_data_source_list
          FROM (SELECT ddc.data_code_message,
                       flg_type,
                       data_source_val,
                       ddc.data_source,
                       db.rnk,
                       ddc.rank,
                       db.id_dd_block,
                       flg_html,
                       flg_clob
                  FROM TABLE(l_tab_dd_block_data) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = 'ORDER_SET_BO'
                   AND ddc.id_dd_block = 1
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL OR flg_type IN ('L1'))
                UNION ALL
                SELECT ddc.data_code_message,
                       flg_type,
                       data_source_val,
                       ddc.data_source,
                       db.rnk,
                       ddc.rank,
                       db.id_dd_block,
                       flg_html,
                       flg_clob
                  FROM TABLE(l_tab_dd_block_tasks) db
                  JOIN dd_content ddc
                    ON ddc.data_source = db.data_source
                   AND ddc.flg_available = pk_alert_constant.g_yes
                   AND ddc.area = 'ORDER_SET_BO'
                   AND ddc.id_dd_block = 2
                 WHERE ddc.id_dd_block = db.id_dd_block
                   AND (db.data_source_val IS NOT NULL))
         ORDER BY id_dd_block, rnk, rank;
    
        OPEN o_detail FOR
            SELECT descr, val, flg_type, flg_html, val_clob, flg_clob
              FROM (SELECT CASE
                                WHEN d.val IS NULL THEN
                                 d.descr
                                WHEN d.descr IS NULL THEN
                                 NULL
                                ELSE
                                 d.descr || ' '
                            END descr,
                           d.val,
                           d.flg_type,
                           flg_html,
                           val_clob,
                           flg_clob,
                           d.rn
                      FROM (SELECT rownum rn, descr, val, flg_type, flg_html, val_clob, flg_clob
                              FROM TABLE(l_tab_dd_data)) d
                      JOIN (SELECT rownum rn, column_value data_source
                             FROM TABLE(l_data_source_list)) ds
                        ON ds.rn = d.rn);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_DETAIL',
                                              o_error);
            pk_types.open_my_cursor(o_detail);
            RETURN FALSE;
    END get_odst_detail;

    FUNCTION tf_get_odst_tasks_details
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set_task.id_order_set%TYPE
    ) RETURN t_table_osdt_task IS
    
        l_tasks_rank table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
    
        l_ret t_table_osdt_task := t_table_osdt_task();
    
        l_error t_error_out;
        l_exception EXCEPTION;
    
    BEGIN
    
        g_error := 'GET ORDER SET TASKS RANK';
        -- get order set dependencies network        
        IF NOT get_odst_depends_network(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        o_dependency_type      => l_dependency_type,
                                        o_task_dependency_from => l_task_dependency_from,
                                        o_task_dependency_to   => l_task_dependency_to,
                                        o_task_type_from       => l_task_type_from,
                                        o_task_type_to         => l_task_type_to,
                                        o_task_schedule_from   => l_task_schedule_from,
                                        o_task_schedule_to     => l_task_schedule_to,
                                        o_lag_min              => l_lag_min,
                                        o_lag_max              => l_lag_max,
                                        o_lag_unit_measure     => l_lag_unit_measure,
                                        o_error                => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        -- get dependencies rank
        IF NOT get_task_dependency_rank(i_lang                 => i_lang,
                                        i_prof                 => i_prof,
                                        i_dependencies_scope   => table_number(i_id_order_set),
                                        i_flg_process          => pk_alert_constant.g_no,
                                        i_dependency_type      => l_dependency_type,
                                        i_task_dependency_from => l_task_dependency_from,
                                        i_task_dependency_to   => l_task_dependency_to,
                                        o_tasks_rank           => l_tasks_rank,
                                        o_error                => l_error)
        THEN
            RAISE l_exception;
        END IF;
    
        g_error := 'GET CURSOR WITH ORDER SET TASKS';
    
        SELECT t_rec_osdt_task(id_order_set      => t.id_order_set,
                               id_order_set_task => t.id_order_set_task,
                               group_type_id     => t.group_type_id,
                               id_task_type      => t.id_task_type,
                               task_link_type    => t.task_link_type,
                               task_type_desc    => t.task_type_desc,
                               task_title        => t.task_title,
                               task_instruct     => t.task_instruct,
                               dependency_desc   => t.dependency_desc,
                               order_status_desc => t.order_status_desc,
                               registry          => registry,
                               updated           => updated,
                               task_rn           => row_number()
                                                    over(PARTITION BY id_task_type ORDER BY order_status_desc ASC),
                               rn                => rownum())
          BULK COLLECT
          INTO l_ret
          FROM (SELECT id_order_set,
                       id_order_set_task,
                       nvl2(task_group_rank, dense_rank() over(ORDER BY task_group_rank, task_group_desc), NULL) group_type_id,
                       id_task_type,
                       task_link_type,
                       task_type_desc,
                       get_task_desc(i_lang,
                                     i_prof,
                                     id_order_set_task,
                                     id_task_type,
                                     pk_alert_constant.g_no,
                                     pk_alert_constant.g_no,
                                     g_task_desc_short_format,
                                     pk_alert_constant.g_no) task_title,
                       task_instruct,
                       dependency_desc,
                       pk_sysdomain.get_domain(g_odst_tsks_order_stat_domain, flg_task_selected, i_lang) order_status_desc,
                       task_rank,
                       registry,
                       updated
                  FROM (SELECT odst_tsk.id_order_set,
                               odst_tsk.id_order_set_task,
                               odst_tsk.id_task_type,
                               get_order_set_task_group_desc(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_desc,
                               get_order_set_task_group_rank(i_lang, i_prof, odst_tsk.id_order_set_task) task_group_rank,
                               upper(substr(pk_translation.get_translation(i_lang,
                                                                           'TASK_TYPE.CODE_TASK_TYPE.' ||
                                                                           odst_tsk.id_task_type),
                                            1,
                                            1)) ||
                               substr(pk_translation.get_translation(i_lang,
                                                                     'TASK_TYPE.CODE_TASK_TYPE.' || odst_tsk.id_task_type),
                                      2) task_type_desc,
                               check_episode_support_task(i_lang,
                                                          i_prof,
                                                          l_dependency_type,
                                                          l_task_dependency_from,
                                                          l_task_dependency_to,
                                                          odst_tsk.id_order_set_task,
                                                          odst_tsk.id_task_type) flg_episode_task,
                               get_task_instructions_desc(i_lang,
                                                          i_prof,
                                                          table_number(odst_tsk.id_order_set_task),
                                                          pk_alert_constant.g_no) task_instruct,
                               decode(get_odst_task_link_type(odst_tsk.id_order_set_task),
                                      g_task_link_null,
                                      NULL,
                                      get_odst_task_link_type(odst_tsk.id_order_set_task)) task_link_type,
                               replace_dependencies_refs_rank(i_lang,
                                                              pk_tde_db.get_depend_description(i_lang,
                                                                                               i_prof,
                                                                                               odst_tsk.id_order_set_task,
                                                                                               check_episode_support_task(i_lang,
                                                                                                                          i_prof,
                                                                                                                          l_dependency_type,
                                                                                                                          l_task_dependency_from,
                                                                                                                          l_task_dependency_to,
                                                                                                                          odst_tsk.id_order_set_task,
                                                                                                                          odst_tsk.id_task_type),
                                                                                               l_tasks_rank,
                                                                                               l_dependency_type,
                                                                                               l_task_dependency_from,
                                                                                               l_task_dependency_to,
                                                                                               l_task_type_from,
                                                                                               l_task_type_to,
                                                                                               l_task_schedule_from,
                                                                                               l_task_schedule_to,
                                                                                               l_lag_min,
                                                                                               l_lag_max,
                                                                                               l_lag_unit_measure),
                                                              l_tasks_rank) dependency_desc,
                               get_task_presel(i_lang, i_prof, odst_tsk.id_order_set_task) flg_task_selected,
                               get_task_rank(l_tasks_rank, id_order_set_task) task_rank,
                               NULL registry,
                               NULL updated
                          FROM order_set_task odst_tsk
                         INNER JOIN task_type tsk_type
                            ON odst_tsk.id_task_type = tsk_type.id_task_type
                        -- verify if the task is not included in the current episode or future episode
                          LEFT OUTER JOIN order_set_task_dependency odst_tsk_dep
                            ON (odst_tsk_dep.id_order_set_task_to = odst_tsk.id_order_set_task AND
                               odst_tsk_dep.id_order_set = i_id_order_set AND
                               odst_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                               odst_tsk_dep.id_order_set_task_from NOT IN
                               (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                         WHERE odst_tsk.id_order_set = i_id_order_set)
                UNION
                SELECT os.id_order_set,
                       NULL id_order_set_task,
                       NULL group_type_id,
                       NULL id_task_type,
                       NULL task_link_type,
                       NULL task_type_desc,
                       NULL task_title,
                       NULL task_instruct,
                       NULL dependency_desc,
                       NULL order_status_desc,
                       NULL task_rank,
                       CASE
                            WHEN os.id_order_set_previous_version IS NULL THEN
                             pk_prof_utils.get_name_signature(i_lang, i_prof, os.id_professional) ||
                             decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     os.id_professional,
                                                                     os.dt_order_set_tstz,
                                                                     NULL),
                                    NULL,
                                    '; ',
                                    ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                             i_prof,
                                                                             os.id_professional,
                                                                             os.dt_order_set_tstz,
                                                                             NULL) || '); ') ||
                             pk_date_utils.date_char_tsz(i_lang, os.dt_order_set_tstz, i_prof.institution, i_prof.software)
                        END registry,
                       CASE
                            WHEN os.id_order_set_previous_version IS NOT NULL THEN
                             pk_prof_utils.get_name_signature(i_lang, i_prof, os.id_professional) ||
                             decode(pk_prof_utils.get_spec_signature(i_lang,
                                                                     i_prof,
                                                                     os.id_professional,
                                                                     os.dt_order_set_tstz,
                                                                     NULL),
                                    NULL,
                                    '; ',
                                    ' (' || pk_prof_utils.get_spec_signature(i_lang,
                                                                             i_prof,
                                                                             os.id_professional,
                                                                             os.dt_order_set_tstz,
                                                                             NULL) || '); ') ||
                             pk_date_utils.date_char_tsz(i_lang, os.dt_order_set_tstz, i_prof.institution, i_prof.software)
                        END updated
                  FROM order_set os
                 WHERE os.id_order_set = i_id_order_set
                 ORDER BY group_type_id NULLS LAST, task_rank NULLS LAST) t;
    
        RETURN l_ret;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'TF_GET_ODST_TASKS_DETAILS',
                                              l_error);
            RETURN t_table_osdt_task();
    END tf_get_odst_tasks_details;

    PROCEDURE get_os_init_parameters
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
    
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        g_episode          CONSTANT NUMBER(24) := 5;
        g_patient          CONSTANT NUMBER(24) := 6;
    
        l_lang    CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof    CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                        i_context_ids(g_prof_institution),
                                                        i_context_ids(g_prof_software));
        l_patient CONSTANT patient.id_patient%TYPE := i_context_ids(g_patient);
        l_episode CONSTANT episode.id_episode%TYPE := i_context_ids(g_episode);
    
        l_category category.id_category%TYPE;
    
        l_error t_error_out;
    
    BEGIN
    
        l_category := pk_prof_utils.get_id_category(l_lang, l_prof);
    
        pk_context_api.set_parameter('i_lang', l_lang);
        pk_context_api.set_parameter('i_prof_id', l_prof.id);
        pk_context_api.set_parameter('i_prof_institution', l_prof.institution);
        pk_context_api.set_parameter('i_prof_software', l_prof.software);
    
        pk_context_api.set_parameter('i_patient', l_patient);
        pk_context_api.set_parameter('i_episode', l_episode);
    
        pk_context_api.set_parameter('i_category', l_category);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_id := l_lang;
            WHEN 'l_patient' THEN
                o_id := l_patient;
            WHEN 'l_episode' THEN
                o_id := l_episode;
            ELSE
                NULL;
        END CASE;
    
    END get_os_init_parameters;

    PROCEDURE get_os_epi_init_parameters
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
    
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        g_episode          CONSTANT NUMBER(24) := 5;
        g_patient          CONSTANT NUMBER(24) := 6;
    
        l_lang    CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof    CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                        i_context_ids(g_prof_institution),
                                                        i_context_ids(g_prof_software));
        l_patient CONSTANT patient.id_patient%TYPE := i_context_ids(g_patient);
        l_episode CONSTANT episode.id_episode%TYPE := i_context_ids(g_episode);
    
        l_tasks_rank table_number;
    
        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;
        l_id_order_set         order_set.id_order_set%TYPE;
    
        l_id_order_set_selected order_set.id_order_set%TYPE;
    
        l_exception EXCEPTION;
    
        l_error t_error_out;
    
    BEGIN
    
        IF i_context_vals IS NOT NULL
        THEN
            IF i_context_vals.count > 0
            THEN
                l_id_order_set_selected := i_context_vals(1);
            END IF;
        END IF;
    
        pk_context_api.set_parameter('i_lang', l_lang);
        pk_context_api.set_parameter('i_prof_id', l_prof.id);
        pk_context_api.set_parameter('i_prof_institution', l_prof.institution);
        pk_context_api.set_parameter('i_prof_software', l_prof.software);
    
        pk_context_api.set_parameter('i_patient', l_patient);
        pk_context_api.set_parameter('i_episode', l_episode);
    
        CASE i_name
            WHEN 'l_lang' THEN
                o_id := l_lang;
            WHEN 'l_tasks_rank' THEN
                o_id := l_patient;
            WHEN 'l_episode' THEN
                o_id := l_episode;
            WHEN 'l_patient' THEN
                o_id := l_patient;
            WHEN 'l_id_order_set' THEN
                o_id := l_id_order_set_selected;
            ELSE
                NULL;
        END CASE;
    
    END get_os_epi_init_parameters;

    FUNCTION get_os_actions_bo
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_actions      OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR o_actions';
        OPEN o_actions FOR
            SELECT /*+opt_estimate(table a rows=1)*/
             a.id_action,
             a.id_parent,
             a.level_nr    "LEVEL",
             a.from_state,
             a.to_state,
             a.desc_action,
             a.icon,
             a.flg_default,
             a.flg_active,
             a.action,
             NULL          id_target_task_type
              FROM TABLE(pk_action.tf_get_actions(i_lang, i_prof, 'ORDER_SETS_ACTIONS_BO', NULL)) a
            UNION ALL
            SELECT id_task_type id_action,
                   nvl(id_task_type_parent, 235534422) id_parent,
                   NULL "LEVEL",
                   NULL from_state,
                   NULL to_state,
                   task_type_desc desc_action,
                   icon,
                   NULL flg_default,
                   flg_active,
                   flg_type action,
                   id_target_task_type
              FROM (SELECT id_task_type,
                            id_task_type_parent,
                            upper(substr(task_type_desc, 1, 1)) || substr(task_type_desc, 2) task_type_desc,
                            icon,
                            flg_type,
                            id_target_task_type,
                            flg_active,
                            rank,
                            translate(upper(task_type_desc), '', 'AEIOUAEIOUAEIOUAOCAEIOUN') task_type_desc_rank
                       FROM (SELECT tsk_type.id_task_type,
                                     get_task_type_parent(i_lang, i_prof, tsk_type.id_task_type) id_task_type_parent,
                                     pk_translation.get_translation(i_lang, tsk_type.code_task_type) task_type_desc,
                                     tsk_type.icon,
                                     tsk_type.flg_type,
                                     tsk_type.id_target_task_type,
                                     -- the order set can't have more than one task of "discharge instruction" type
                                   decode(tsk_type.id_task_type,
                                          g_odst_task_discharge_instruct,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_discharge_instruct
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_intake,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_intake
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_intake_output,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_intake_output
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_urinary_output,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_urinary_output
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_drainage_records,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_drainage_records
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_all_output,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_all_output
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_odst_task_irrigation,
                                          nvl((SELECT g_inactive
                                                FROM order_set_task odst_tsk
                                               WHERE odst_tsk.id_task_type = g_odst_task_irrigation
                                                 AND odst_tsk.id_order_set = i_id_order_set),
                                              g_active),
                                          g_active) flg_active,
                                   1 rank
                              FROM task_type tsk_type
                             WHERE check_order_set_task_avail(i_lang, i_prof, tsk_type.id_task_type) = g_available
                            UNION ALL
                            SELECT -1 id_task_type,
                                   NULL id_task_type_parent,
                                   pk_message.get_message(i_lang, g_message_order_set_tasks) task_type_desc,
                                   NULL icon,
                                   NULL flg_type,
                                   NULL id_target_task_type,
                                   g_active flg_active,
                                   3 rank
                              FROM dual)
                     ORDER BY rank, task_type_desc_rank);
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_OS_ACTIONS_BO',
                                              o_error);
        
            pk_utils.undo_changes;
            pk_types.open_my_cursor(o_actions);
            pk_alert_exceptions.reset_error_state;
            RETURN FALSE;
    END get_os_actions_bo;

    FUNCTION get_services_list
    (
        i_lang     IN language.id_language%TYPE,
        i_prof     IN profissional,
        i_tbl_dept IN table_varchar
    ) RETURN t_tbl_core_domain IS
    
        l_ret   t_tbl_core_domain;
        l_error t_error_out;
    BEGIN
    
        g_error := 'OPEN L_RET';
        SELECT t_row_core_domain(internal_name => NULL,
                                 desc_domain   => label,
                                 domain_value  => data,
                                 order_rank    => rownum,
                                 img_name      => NULL)
          BULK COLLECT
          INTO l_ret
          FROM (SELECT t.id_dep_clin_serv data,
                       pk_translation.get_translation(i_lang, t.code_clinical_service) ||
                       decode(t.dept_count, 1, NULL, ' - ' || pk_translation.get_translation(i_lang, t.code_dept)) ||
                       decode(t.institution_count,
                              1,
                              NULL,
                              ' - ' || pk_translation.get_translation(i_lang, t.code_institution)) label,
                       1 rank
                  FROM (WITH service_list AS (SELECT DISTINCT i.id_institution,
                                                              i.code_institution,
                                                              dpt.id_dept,
                                                              dpt.code_dept,
                                                              c.id_clinical_service,
                                                              c.code_clinical_service,
                                                              dcs.id_dep_clin_serv
                                                FROM dept dpt
                                                JOIN department d
                                                  ON d.id_dept = dpt.id_dept
                                                JOIN dep_clin_serv dcs
                                                  ON dcs.id_department = d.id_department
                                                JOIN clinical_service c
                                                  ON c.id_clinical_service = dcs.id_clinical_service
                                                JOIN institution i
                                                  ON i.id_institution = dpt.id_institution
                                               WHERE dpt.id_dept IN (SELECT /*+opt_estimate (table td rows=1)*/
                                                                      to_number(td.column_value)
                                                                       FROM TABLE(i_tbl_dept) td)
                                                 AND d.flg_available = pk_alert_constant.g_yes
                                                 AND dcs.flg_available = pk_alert_constant.g_yes
                                                 AND c.flg_available = pk_alert_constant.g_yes)
                           SELECT id_institution,
                                  code_institution,
                                  (SELECT COUNT(DISTINCT id_institution)
                                     FROM service_list) institution_count,
                                  id_dept,
                                  code_dept,
                                  (SELECT COUNT(DISTINCT id_dept)
                                     FROM service_list) dept_count,
                                  id_clinical_service,
                                  code_clinical_service,
                                  id_dep_clin_serv
                             FROM service_list) t
                           UNION ALL
                           SELECT -1 data, pk_message.get_message(i_lang, 'COMMON_M014') label, 0 rank
                             FROM dual
                            ORDER BY rank, label
                );
    
        RETURN l_ret;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_SERVICES_LIST',
                                              l_error);
            RETURN t_tbl_core_domain();
    END get_services_list;

    FUNCTION check_order_set_co_sign
    (
        i_lang                 IN language.id_language%TYPE,
        i_prof                 IN profissional,
        i_episode              IN episode.id_episode%TYPE,
        i_id_order_set_process IN order_set_process_task.id_order_set_process%TYPE,
        o_co_sign_needed       OUT VARCHAR2,
        o_error                OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tasks_rank table_number;
    
        /*        l_dependency_type      table_number;
        l_task_dependency_from table_number;
        l_task_dependency_to   table_number;
        l_task_type_from       table_number;
        l_task_type_to         table_number;
        l_task_schedule_from   table_varchar;
        l_task_schedule_to     table_varchar;
        l_lag_min              table_number;
        l_lag_max              table_number;
        l_lag_unit_measure     table_number;*/
    
        l_exception EXCEPTION;
    
        l_test table_varchar;
    
        l_flg_needs_co_sign VARCHAR2(1 CHAR);
    
    BEGIN
    
        g_error := 'GET FLG_TASK_NEEDS_CO_SIGN';
        SELECT flg_task_needs_co_sign COLLECT
          INTO l_flg_needs_co_sign
          FROM (SELECT (SELECT check_order_task_needs_cosign(i_lang                      => i_lang,
                                                             i_prof_id                   => i_prof.id,
                                                             i_prof_inst                 => i_prof.institution,
                                                             i_prof_soft                 => i_prof.software,
                                                             i_episode                   => i_episode,
                                                             i_id_order_set_process_task => (CASE id_task_type
                                                                                                WHEN g_odst_task_medication THEN
                                                                                                -- this parameter is needed, because only the medication module knows what is the type of each prescription contained in the order set
                                                                                                 id_order_set_process_task
                                                                                                ELSE
                                                                                                -- for the other types of tasks this parameter is passed with null value, in order to take advantage of the result cache by task type
                                                                                                 NULL
                                                                                            END),
                                                             i_task_type                 => id_task_type)
                          FROM dual) flg_task_needs_co_sign
                  FROM (SELECT odst_proc_tsk.id_order_set_process_task, odst_proc_tsk.id_task_type
                          FROM order_set_process_task odst_proc_tsk
                         INNER JOIN task_type tsk_type
                            ON odst_proc_tsk.id_task_type = tsk_type.id_task_type
                        -- verify if the task is not included in the current episode or future episode
                          LEFT OUTER JOIN order_set_process_task_depend odst_proc_tsk_dep
                            ON (odst_proc_tsk_dep.id_order_set_proc_task_to = odst_proc_tsk.id_order_set_process_task AND
                               odst_proc_tsk_dep.id_order_set_process = i_id_order_set_process AND
                               odst_proc_tsk_dep.id_relationship_type = pk_alert_constant.g_tde_rel_start2start AND
                               odst_proc_tsk_dep.id_order_set_proc_task_from NOT IN
                               (to_number(g_depend_current_epis), to_number(g_depend_future_epis)))
                         WHERE odst_proc_tsk.id_order_set_process = i_id_order_set_process)
                 ORDER BY flg_task_needs_co_sign DESC)
         WHERE rownum = 1;
    
        o_co_sign_needed := l_flg_needs_co_sign;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_PROC_TASKS',
                                              o_error);
            RETURN FALSE;
    END check_order_set_co_sign;

    FUNCTION get_full_items_by_screen
    (
        i_lang        IN NUMBER,
        i_prof        IN profissional,
        i_patient     IN NUMBER,
        i_episode     IN NUMBER,
        i_screen_name IN VARCHAR2,
        i_action      IN NUMBER,
        o_components  OUT t_clin_quest_table,
        o_ds_target   OUT t_clin_quest_target_table,
        o_error       OUT t_error_out
    ) RETURN BOOLEAN IS
        l_tbl_task_type  table_number;
        l_tbl_id_request table_number;
    
        l_task_type_processed         table_number := table_number();
        l_id_request_by_task_type     table_number := table_number();
        l_id_request_by_task_type_f   table_number := table_number();
        l_sample_type_f               table_number := table_number();
        l_id_request_by_task_type_str VARCHAR2(1000 CHAR) := '';
    
        l_table_components t_clin_quest_table;
        l_table_target     t_clin_quest_target_table;
    
        l_table_components_final t_clin_quest_table;
        l_table_target_final     t_clin_quest_target_table := t_clin_quest_target_table();
        l_table_components_aux   t_clin_quest_table := t_clin_quest_table();
    
        l_exist VARCHAR2(1 CHAR);
    
        l_exception EXCEPTION;
    
    BEGIN
    
        SELECT ospt.id_task_type, ostl.id_task_link
          BULK COLLECT
          INTO l_tbl_task_type, l_tbl_id_request
          FROM order_set_process_task ospt
         INNER JOIN order_set_process osp
            ON osp.id_order_set_process = ospt.id_order_set_process
         INNER JOIN order_set os
            ON os.id_order_set = osp.id_order_set
         INNER JOIN order_set_process_task_link ostl
            ON ostl.id_order_set_process_task = ospt.id_order_set_process_task
         WHERE ospt.flg_status = g_order_set_proc_tsk_temp
           AND ospt.id_order_set_process = to_number(i_screen_name)
           AND ospt.flg_discard_type = g_task_not_discard
           AND get_proc_task_presel(i_lang, i_prof, ospt.id_order_set_process_task) = pk_alert_constant.g_yes;
    
        FOR i IN 1 .. l_tbl_task_type.count
        LOOP
            IF pk_utils.search_table_number(l_task_type_processed, l_tbl_task_type(i)) = -1
            THEN
                l_task_type_processed.extend;
                l_task_type_processed(l_task_type_processed.count) := l_tbl_task_type(i);
            
                l_id_request_by_task_type     := table_number();
                l_id_request_by_task_type_str := NULL;
            
                FOR j IN 1 .. l_tbl_id_request.count
                LOOP
                    IF l_tbl_task_type(j) = l_tbl_task_type(i)
                    THEN
                        l_id_request_by_task_type.extend;
                        l_id_request_by_task_type(l_id_request_by_task_type.count) := l_tbl_id_request(j);
                    END IF;
                END LOOP;
            
                l_exist := pk_alert_constant.g_no;
            
                CASE
                
                    WHEN l_tbl_task_type(i) IN (g_odst_task_image_exam, g_odst_task_other_exam) THEN
                    
                        SELECT id_exam
                          BULK COLLECT
                          INTO l_id_request_by_task_type_f
                          FROM exam_req_det
                         WHERE id_exam_req IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                t.*
                                                 FROM TABLE(l_id_request_by_task_type) t);
                    
                        FOR j IN 1 .. l_id_request_by_task_type_f.count
                        LOOP
                            IF l_id_request_by_task_type_str IS NULL
                            THEN
                                l_id_request_by_task_type_str := l_id_request_by_task_type_f(j);
                            ELSE
                                l_id_request_by_task_type_str := l_id_request_by_task_type_str || '|' ||
                                                                 l_id_request_by_task_type_f(j);
                            END IF;
                        END LOOP;
                    
                        IF NOT pk_exam_utils.get_full_items_by_screen(i_lang        => i_lang,
                                                                      i_prof        => i_prof,
                                                                      i_patient     => i_patient,
                                                                      i_episode     => i_episode,
                                                                      i_screen_name => l_id_request_by_task_type_str,
                                                                      i_action      => i_action,
                                                                      o_components  => l_table_components,
                                                                      o_ds_target   => l_table_target,
                                                                      o_error       => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        l_exist := pk_alert_constant.g_yes;
                    
                    WHEN l_tbl_task_type(i) = g_odst_task_analysis THEN
                    
                        SELECT id_analysis, id_sample_type
                          BULK COLLECT
                          INTO l_id_request_by_task_type_f, l_sample_type_f
                          FROM analysis_req_det
                         WHERE id_analysis_req IN (SELECT /*+opt_estimate (table t rows=1)*/
                                                    t.*
                                                     FROM TABLE(l_id_request_by_task_type) t);
                        FOR j IN 1 .. l_id_request_by_task_type_f.count
                        LOOP
                            IF l_id_request_by_task_type_str IS NULL
                            THEN
                                l_id_request_by_task_type_str := l_id_request_by_task_type_f(j) || '_' ||
                                                                 l_sample_type_f(j);
                            ELSE
                                l_id_request_by_task_type_str := l_id_request_by_task_type_str || '|' ||
                                                                 l_id_request_by_task_type_f(j) || '_' ||
                                                                 l_sample_type_f(j);
                            END IF;
                        END LOOP;
                    
                        IF NOT pk_lab_tests_utils.get_full_items_by_screen(i_lang        => i_lang,
                                                                           i_prof        => i_prof,
                                                                           i_patient     => i_patient,
                                                                           i_episode     => i_episode,
                                                                           i_screen_name => l_id_request_by_task_type_str,
                                                                           i_action      => i_action,
                                                                           o_components  => l_table_components,
                                                                           o_ds_target   => l_table_target,
                                                                           o_error       => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        l_exist := pk_alert_constant.g_yes;
                    
                    WHEN l_tbl_task_type(i) = g_odst_task_procedure THEN
                    
                        SELECT id_intervention
                          BULK COLLECT
                          INTO l_id_request_by_task_type_f
                          FROM interv_presc_det
                         WHERE id_interv_prescription IN
                               (SELECT /*+opt_estimate (table t rows=1)*/
                                 t.*
                                  FROM TABLE(l_id_request_by_task_type) t);
                    
                        FOR j IN 1 .. l_id_request_by_task_type_f.count
                        LOOP
                            IF l_id_request_by_task_type_str IS NULL
                            THEN
                                l_id_request_by_task_type_str := l_id_request_by_task_type_f(j);
                            ELSE
                                l_id_request_by_task_type_str := l_id_request_by_task_type_str || '|' ||
                                                                 l_id_request_by_task_type_f(j);
                            END IF;
                        END LOOP;
                    
                        IF NOT pk_procedures_utils.get_full_items_by_screen(i_lang        => i_lang,
                                                                            i_prof        => i_prof,
                                                                            i_patient     => i_patient,
                                                                            i_episode     => i_episode,
                                                                            i_screen_name => l_id_request_by_task_type_str,
                                                                            i_action      => i_action,
                                                                            o_components  => l_table_components,
                                                                            o_ds_target   => l_table_target,
                                                                            o_error       => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        l_exist := pk_alert_constant.g_yes;
                    
                    WHEN l_tbl_task_type(i) = g_odst_task_bp THEN
                    
                        SELECT a.id_hemo_type
                          BULK COLLECT
                          INTO l_id_request_by_task_type_f
                          FROM blood_product_det a
                         WHERE a.id_blood_product_req IN
                               (SELECT /*+opt_estimate (table t rows=1)*/
                                 t.*
                                  FROM TABLE(l_id_request_by_task_type) t);
                        FOR j IN 1 .. l_id_request_by_task_type_f.count
                        LOOP
                        
                            IF l_id_request_by_task_type_str IS NULL
                            THEN
                                l_id_request_by_task_type_str := l_id_request_by_task_type_f(j);
                            ELSE
                                l_id_request_by_task_type_str := l_id_request_by_task_type_str || '|' ||
                                                                 l_id_request_by_task_type_f(j);
                            END IF;
                        
                        END LOOP;
                    
                        IF NOT pk_blood_products_utils.get_full_items_by_screen(i_lang        => i_lang,
                                                                                i_prof        => i_prof,
                                                                                i_patient     => i_patient,
                                                                                i_episode     => i_episode,
                                                                                i_screen_name => l_id_request_by_task_type_str,
                                                                                i_action      => i_action,
                                                                                o_components  => l_table_components,
                                                                                o_ds_target   => l_table_target,
                                                                                o_error       => o_error)
                        THEN
                            RAISE l_exception;
                        END IF;
                    
                        l_exist := pk_alert_constant.g_yes;
                    
                    ELSE
                        -- for other task types, clinical questions aren't supported
                        NULL;
                END CASE;
            
                IF l_exist = pk_alert_constant.g_yes
                THEN
                    IF l_table_components_final IS NULL
                    THEN
                        l_table_components_final := l_table_components;
                        l_table_target_final     := l_table_target;
                    ELSE
                    
                        l_table_components_aux := t_clin_quest_table();
                    
                        FOR j IN 1 .. l_table_components.count
                        LOOP
                            IF l_table_components(j).id_ds_component_parent IS NOT NULL
                            THEN
                            
                                IF l_table_components(j).id_ds_component_parent = 0
                                THEN
                                    l_table_components(j).position := l_table_components_final.count;
                                    l_table_components(j).rank := l_table_components_final.count;
                                    l_table_components(j).rn := l_table_components_final.count;
                                END IF;
                            
                                l_table_components_aux.extend;
                                l_table_components_aux(l_table_components_aux.count) := l_table_components(j);
                            
                            END IF;
                        
                        END LOOP;
                    
                        l_table_components_final := l_table_components_final MULTISET UNION l_table_components_aux;
                        l_table_target_final     := l_table_target_final MULTISET UNION ALL l_table_target;
                    END IF;
                END IF;
            
            END IF;
        END LOOP;
    
        o_components := l_table_components_final;
        o_ds_target  := l_table_target_final;
    
        RETURN TRUE;
    
    EXCEPTION
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              'g_error',
                                              'g_package_owner',
                                              'g_package_name',
                                              'GET_FULL_ITEMS_BY_SCREEN',
                                              o_error);
            RETURN FALSE;
    END get_full_items_by_screen;

    PROCEDURE init_params_complaint
    (
        i_filter_name   IN VARCHAR2,
        i_custom_filter IN NUMBER,
        i_context_ids   IN table_number,
        i_context_keys  IN table_varchar DEFAULT NULL,
        i_context_vals  IN table_varchar,
        i_name          IN VARCHAR2,
        o_vc2           OUT VARCHAR2,
        o_num           OUT NUMBER,
        o_id            OUT NUMBER,
        o_tstz          OUT TIMESTAMP WITH LOCAL TIME ZONE
    ) IS
        g_lang             CONSTANT NUMBER(24) := 1;
        g_prof_id          CONSTANT NUMBER(24) := 2;
        g_prof_institution CONSTANT NUMBER(24) := 3;
        g_prof_software    CONSTANT NUMBER(24) := 4;
        g_episode          CONSTANT NUMBER(24) := 5;
        g_patient          CONSTANT NUMBER(24) := 6;
    
        l_lang CONSTANT language.id_language%TYPE := i_context_ids(g_lang);
        l_prof CONSTANT profissional := profissional(i_context_ids(g_prof_id),
                                                     i_context_ids(g_prof_institution),
                                                     i_context_ids(g_prof_software));
    
        l_order_set        NUMBER(24);
        l_clinical_service NUMBER(24);
        l_value            VARCHAR2(1000 CHAR);
    
        -- ***************************************************
        PROCEDURE set_context IS
        BEGIN
        
            pk_context_api.set_parameter('l_lang', l_lang);
            pk_context_api.set_parameter('l_prof_id', l_prof.id);
            pk_context_api.set_parameter('l_prof_institution', l_prof.institution);
            pk_context_api.set_parameter('l_prof_software', l_prof.software);
        
        END set_context;
    BEGIN
    
        IF i_context_vals IS NOT NULL
           AND i_context_vals.count > 0
        THEN
            l_order_set := i_context_vals(1);
        
            IF i_context_vals.count > 1
            THEN
                l_clinical_service := i_context_vals(2);
            END IF;
        END IF;
    
        set_context();
    
        CASE lower(i_name)
            WHEN 'i_lang' THEN
                o_id := l_lang;
            WHEN 'i_id_institution' THEN
                o_id := l_prof.institution;
            WHEN 'l_order_set' THEN
                o_id := l_order_set;
            WHEN 'i_software' THEN
                o_id := l_prof.software;
            WHEN 'i_prof_id' THEN
                o_id := l_prof.id;
            WHEN 'l_pat_gender' THEN
                o_vc2 := NULL;
            WHEN 'l_pat_age' THEN
                o_id := NULL;
            WHEN 'id_episode' THEN
                o_id := NULL; --l_episode;
            WHEN 'id_patient' THEN
                o_id := NULL; --l_patient;
            WHEN 'l_clinical_service' THEN
                o_id := l_clinical_service;
            
        END CASE;
    
    END init_params_complaint;

    --Funes de flash => APAGAR
    FUNCTION get_order_set_type_list
    (
        i_lang           IN language.id_language%TYPE,
        i_prof           IN profissional,
        i_id_order_set   IN order_set.id_order_set%TYPE,
        o_order_set_type OUT pk_types.cursor_type,
        o_error          OUT t_error_out
    ) RETURN BOOLEAN IS
    
        l_tbl_lst_values t_table_sys_list;
    
        -- order set type list group
        l_odst_type_list_group CONSTANT sys_list_group.id_sys_list_group%TYPE := 15503;
    
    BEGIN
    
        -- get order set type list values
        l_tbl_lst_values := pk_sys_list.tf_sys_list_values(i_lang              => i_lang,
                                                           i_prof              => i_prof,
                                                           i_id_sys_list_group => l_odst_type_list_group);
    
        g_error := 'GET CURSOR';
        OPEN o_order_set_type FOR
            SELECT id_order_set_type,
                   rank,
                   desc_order_set_type,
                   decode(id_order_set_type,
                          -1,
                          decode(COUNT(1) over(ORDER BY rank RANGE BETWEEN unbounded preceding AND unbounded following) -
                                 SUM(decode(flg_select, pk_alert_constant.g_yes, 1, 0))
                                 over(ORDER BY rank RANGE BETWEEN unbounded preceding AND unbounded following),
                                 1,
                                 pk_alert_constant.g_yes,
                                 flg_select),
                          flg_select) flg_select
              FROM ( /*+ opt_estimate(table ost_type rows = 1) */
                    SELECT ost_type.id_sys_list id_order_set_type,
                            ost_type.rank rank,
                            ost_type.desc_list desc_order_set_type,
                            nvl2(osl.id_link, pk_alert_constant.g_yes, pk_alert_constant.g_no) flg_select
                      FROM TABLE(l_tbl_lst_values) ost_type
                      LEFT OUTER JOIN order_set_link osl
                        ON (osl.id_link = ost_type.id_sys_list AND osl.id_order_set = i_id_order_set AND
                           osl.flg_link_type = g_order_set_link_odst_type)
                    UNION ALL
                    SELECT -1 id_order_set_type,
                            0 rank,
                            pk_message.get_message(i_lang, 'COMMON_M014') desc_order_set_type,
                            pk_alert_constant.g_no flg_select
                      FROM dual)
             ORDER BY rank, desc_order_set_type;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_TYPE_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_type);
            RETURN FALSE;
    END get_order_set_type_list;

    FUNCTION get_odst_edit_permission_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_values       OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR WITH EDIT PERMISSION DOMAIN VALUES';
        pk_alertlog.log_debug(g_error, g_package_name);
    
        OPEN o_values FOR
            SELECT desc_val, val, img_name, rank
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, g_odst_edit_perms_domain, NULL)) s
             WHERE (EXISTS (SELECT 1
                              FROM order_set_link odst_lnk
                             WHERE odst_lnk.id_order_set = i_id_order_set
                               AND odst_lnk.flg_link_type = g_order_set_link_spec) OR s.val != 'S')
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_EDIT_PERMISSION_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_values);
            RETURN FALSE;
    END get_odst_edit_permission_list;

    FUNCTION get_odst_use_permission_list
    (
        i_lang         IN language.id_language%TYPE,
        i_prof         IN profissional,
        i_id_order_set IN order_set.id_order_set%TYPE,
        o_values       OUT pk_types.cursor_type,
        o_error        OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR WITH USE PERMISSION DOMAIN VALUES';
        OPEN o_values FOR
            SELECT desc_val, val, img_name, rank
              FROM TABLE(pk_sysdomain.get_values_domain_pipelined(i_lang, i_prof, g_odst_target_profs_domain, NULL)) s
             WHERE (EXISTS (SELECT 1
                              FROM order_set_link odst_lnk
                             WHERE odst_lnk.id_order_set = i_id_order_set
                               AND odst_lnk.flg_link_type = g_order_set_link_spec) OR s.val != 'S')
             ORDER BY rank;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ODST_USE_PERMISSION_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_values);
            RETURN FALSE;
    END get_odst_use_permission_list;

    FUNCTION get_order_set_environment_list
    (
        i_lang                  IN language.id_language%TYPE,
        i_prof                  IN profissional,
        i_id_order_set          IN order_set.id_order_set%TYPE,
        o_order_set_environment OUT pk_types.cursor_type,
        o_error                 OUT t_error_out
    ) RETURN BOOLEAN IS
    
    BEGIN
    
        g_error := 'GET CURSOR WITH ORDER SET ENVIRONMENTS';
        OPEN o_order_set_environment FOR
            SELECT id_dept,
                   rank,
                   desc_dep,
                   decode(id_dept,
                          -1,
                          decode(COUNT(1) over(ORDER BY rank RANGE BETWEEN unbounded preceding AND unbounded following) -
                                 SUM(decode(flg_select, g_selected, 1, 0))
                                 over(ORDER BY decode(flg_select, g_selected, 1, 0) RANGE BETWEEN unbounded
                                      preceding AND unbounded following),
                                 1,
                                 g_selected,
                                 flg_select),
                          flg_select) flg_select
              FROM (SELECT t.id_dept, t.rank, pk_translation.get_translation(i_lang, t.code_dept) desc_dep, t.flg_select
                      FROM (SELECT d.id_dept,
                                   2 rank,
                                   d.code_dept,
                                   decode(ost_lnk.id_link, NULL, g_not_selected, g_selected) flg_select
                              FROM dept d, order_set_link ost_lnk
                             WHERE d.id_institution = i_prof.institution
                               AND d.id_dept IN
                                   (SELECT sd.id_dept
                                      FROM software_dept sd
                                     WHERE sd.id_software IN (pk_alert_constant.g_soft_outpatient,
                                                              pk_alert_constant.g_soft_oris,
                                                              pk_alert_constant.g_soft_primary_care,
                                                              pk_alert_constant.g_soft_edis,
                                                              pk_alert_constant.g_soft_inpatient,
                                                              pk_alert_constant.g_soft_private_practice,
                                                              pk_alert_constant.g_soft_ubu,
                                                              pk_alert_constant.g_soft_nutritionist,
                                                              pk_alert_constant.g_soft_home_care))
                               AND d.flg_available = pk_alert_constant.g_yes
                               AND ost_lnk.id_link(+) = d.id_dept
                               AND ost_lnk.id_order_set(+) = i_id_order_set
                               AND ost_lnk.flg_link_type(+) = g_order_set_link_envi) t
                    UNION ALL
                    SELECT -1 id_dept,
                           1 rank,
                           pk_message.get_message(i_lang, g_message_all) desc_dep,
                           g_not_selected flg_select
                      FROM dual)
             ORDER BY rank, desc_dep;
    
        RETURN TRUE;
    
    EXCEPTION
        -- Unexpected error
        WHEN OTHERS THEN
            pk_alert_exceptions.process_error(i_lang,
                                              SQLCODE,
                                              SQLERRM,
                                              g_error,
                                              g_package_owner,
                                              g_package_name,
                                              'GET_ORDER_SET_ENVIRONMENT_LIST',
                                              o_error);
            pk_types.open_my_cursor(o_order_set_environment);
            RETURN FALSE;
    END get_order_set_environment_list;

BEGIN

    -- log initialization.
    pk_alertlog.who_am_i(g_package_owner, g_package_name);
    pk_alertlog.log_init(g_package_name);
    g_debug := pk_alertlog.is_debug_enabled(i_object_name => g_package_name);

END pk_order_sets;
/
